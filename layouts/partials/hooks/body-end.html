<script>

  function checkBacklink1() {
    const params = new URLSearchParams(window.location.search);
    if (!params.has('back')) return;

    document.documentElement.classList.add('has-backlink');

    // UI-Elemente ausblenden
    ['nav[aria-label="breadcrumb"]','.td-breadcrumbs','.td-page-nav','.pagination','.section-index']
      .forEach(sel => document.querySelectorAll(sel).forEach(el => el.remove()));
    const sidebarRoot = document.querySelector('ul.td-sidebar-nav__section');
    if (sidebarRoot) {
      const sidebarContainer = sidebarRoot.closest('aside, nav, .td-sidebar, .td-sidebar-nav') || sidebarRoot;
      if (sidebarContainer) sidebarContainer.style.display = 'none';
    }

    const raw = params.get('back');
    const normalized = (raw ?? '').trim();
    const isEmptyBack =
      normalized === '' || /^=+$/.test(normalized) ||
      normalized.toLowerCase() === 'null' || normalized.toLowerCase() === 'undefined';

    const smartBackEmpty = () => {
      if (window.history.length > 1) { window.history.back(); return; }
      try { window.close(); } catch {}
      window.location.assign('/');
    };

    if (isEmptyBack) { smartBackEmpty(); return; }

    try {
      // Wichtig: gegen href auflösen (erhält Subpfade wie /docs)
      const candidate = new URL(normalized, window.location.href);
      const isSameOrigin = candidate.origin === window.location.origin;
      const isRelative = normalized.startsWith('/') && !normalized.startsWith('//');
      if (!(isRelative || isSameOrigin)) return;

      const backText = (params.get('backText') || 'Zurück').trim();
      const container =
        document.querySelector('div.td-content') ||
        document.querySelector('article.td-content') ||
        document.querySelector('main');
      if (!container) return;

      const backHref = candidate.pathname + (candidate.search || '') + (candidate.hash || '');

      // Heuristik: neues Fenster/Tab?
      const likelyNewWindow = !!window.opener || window.history.length <= 1;

      const wrap = document.createElement('div');
      wrap.style.marginTop = '2rem';

      let control; // <a> oder <button> im Link-Look
      if (likelyNewWindow) {
        control = document.createElement('button');
        control.type = 'button';
        control.className = 'backlink backlink-btn';
        control.textContent = `← ${backText}`;
        control.setAttribute('aria-label', 'Zurück zur vorherigen Seite');
        control.addEventListener('click', () => {
          if (window.opener && !window.opener.closed) {
            try {
              window.opener.location.href = backHref;
              window.opener.focus();
            } catch {}
            try { window.close(); return; } catch {}
            window.location.replace(backHref);
            return;
          }
          if (window.history.length > 1) window.history.back();
          else window.location.replace(backHref);
        });
      } else {
        control = document.createElement('a');
        control.href = backHref;
        control.textContent = `← ${backText}`;
        control.rel = 'nofollow';
        control.className = 'backlink';
        control.setAttribute('aria-label', 'Zurück zur vorherigen Seite');

        // Fallback-Intercept: falls doch im neuen Fenster gelandet
        control.addEventListener('click', (ev) => {
          if (window.opener && !window.opener.closed) {
            ev.preventDefault();
            try {
              window.opener.location.href = backHref;
              window.opener.focus();
            } catch {}
            try { window.close(); return; } catch {}
            window.location.replace(backHref);
          }
        });
      }

      wrap.appendChild(control);

      // „Last modified…“ finden (mehrsprachig) und Link davor setzen
      const lastModPattern = /(last\s*modified|zuletzt\s*geändert|derni[eè]re\s*modification|ultima\s*modifica|última\s*modificación)/i;
      const divs = container.querySelectorAll(':scope div');
      let lastModDiv = null;
      for (let i = divs.length - 1; i >= 0; i--) {
        const el = divs[i];
        if (lastModPattern.test((el.textContent || '').trim())) { lastModDiv = el; break; }
      }
      if (lastModDiv) {
        let top = lastModDiv;
        while (top.parentElement && top.parentElement !== container) top = top.parentElement;
        container.insertBefore(wrap, top);
      } else {
        container.appendChild(wrap);
      }
    } catch {
      // ungültige URL -> nichts tun
    }
  }


  function checkBacklink() {
  const params = new URLSearchParams(window.location.search);
  if (!params.has('back')) return;

  // UI reduzieren
  document.documentElement.classList.add('has-backlink');
  ['nav[aria-label="breadcrumb"]','.td-breadcrumbs','.td-page-nav','.pagination','.section-index', '.col-sm']
    .forEach(sel => document.querySelectorAll(sel).forEach(el => el.remove()));
  const sidebarRoot = document.querySelector('ul.td-sidebar-nav__section');
  if (sidebarRoot) {
    const sidebarContainer = sidebarRoot.closest('aside, nav, .td-sidebar, .td-sidebar-nav') || sidebarRoot;
    if (sidebarContainer) sidebarContainer.style.display = 'none';
  }

  const raw = params.get('back');
  const normalized = (raw ?? '').trim();
  const isEmptyBack =
    normalized === '' || /^=+$/.test(normalized) ||
    normalized.toLowerCase() === 'null' || normalized.toLowerCase() === 'undefined';

  // Content-Container (explizit .td-content)
  const container =
    document.querySelector('div.td-content') ||
    document.querySelector('article.td-content') ||
    document.querySelector('main');
  if (!container) return;

  // Helfer: Back-Control einfügen (vor "Last modified...", sonst ans Ende)
  const insertControl = (el) => {
    const lastModPattern = /(last\s*modified|zuletzt\s*geändert|derni[eè]re\s*modification|ultima\s*modifica|última\s*modificación)/i;
    const divs = container.querySelectorAll(':scope div');
    let lastModDiv = null;
    for (let i = divs.length - 1; i >= 0; i--) {
      const d = divs[i];
      if (lastModPattern.test((d.textContent || '').trim())) { lastModDiv = d; break; }
    }
    if (lastModDiv) {
      let top = lastModDiv;
      while (top.parentElement && top.parentElement !== container) top = top.parentElement;
      container.insertBefore(el, top);
    } else {
      container.appendChild(el);
    }
  };

  // Falls back leer: KEIN Auto-Back/Close! Button rendern, der es erst bei Klick macht.
  if (isEmptyBack) {
    const text = (params.get('backText') || 'Zurück').trim();
    const wrap = document.createElement('div');
    wrap.style.marginTop = '2rem';

    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'backlink backlink-btn';
    btn.textContent = `← ${text}`;
    btn.setAttribute('aria-label', 'Zurück zur vorherigen Seite');

    btn.addEventListener('click', () => {
      // Klick-Verhalten: History → Close → Startseite
      if (window.history.length > 1) { window.history.back(); return; }
      try { window.close(); return; } catch {}
      window.location.assign('/');
    });

    wrap.appendChild(btn);
    insertControl(wrap);
    return;
  }

  // back ist gesetzt → wie gehabt Button/Link erzeugen
  try {
    // Wichtig: gegen href auflösen (erhält Subpfade wie /docs)
    const target = new URL(normalized, window.location.href);
    const isSameOrigin = target.origin === window.location.origin;
    const isRelative = normalized.startsWith('/') && !normalized.startsWith('//');
    if (!(isRelative || isSameOrigin)) return;

    const backText = (params.get('backText') || 'Zurück').trim();
    const backHref = target.pathname + (target.search || '') + (target.hash || '');

    // Heuristik: neues Fenster/Tab?
    const likelyNewWindow = !!window.opener || window.history.length <= 1;

    const wrap = document.createElement('div');
    wrap.style.marginTop = '2rem';

    let control;
    if (likelyNewWindow) {
      // Button steuert Opener + schließt dieses Fenster (erst bei Klick)
      control = document.createElement('button');
      control.type = 'button';
      control.className = 'backlink backlink-btn';
      control.textContent = `← ${backText}`;
      control.setAttribute('aria-label', 'Du kannst das Fenster schliessen und in der Dokumentation fortfahren');
      control.addEventListener('click', () => {
        if (window.opener && !window.opener.closed) {
          try { window.opener.location.href = backHref; window.opener.focus(); } catch {}
          try { window.close(); return; } catch {}
          window.location.replace(backHref);
          return;
        }
        if (window.history.length > 1) window.history.back();
        else window.location.replace(backHref);
      });
    } else {
      // Normaler Link (mit Fallback-Intercept, falls doch im neuen Tab)
      control = document.createElement('a');
      control.href = backHref;
      control.textContent = `← ${backText}`;
      control.rel = 'nofollow';
      control.className = 'backlink';
      control.setAttribute('aria-label', 'Zurück zur vorherigen Seite');
      control.addEventListener('click', (ev) => {
        if (window.opener && !window.opener.closed) {
          ev.preventDefault();
          try { window.opener.location.href = backHref; window.opener.focus(); } catch {}
          try { window.close(); return; } catch {}
          window.location.replace(backHref);
        }
      });
    }

    wrap.appendChild(control);
    insertControl(wrap);
  } catch {
    // ungültige URL -> nichts tun
  }
}

  function fixUrl() {
    // Für den Back-Parameter nur der aktuelle Pfad (inkl. evtl. Subpfad wie /docs)
    const backValue = window.location.pathname;
    const backTextValue = 'Gehe zurück zur Dokumentation';
    const blankTextValue = 'Du kannst das Fenster schliessen und in der Dokumentation fortfahren';


    document.querySelectorAll('a[href]').forEach(link => {
      let txt = (link.textContent || '').trim();
      if (!txt) return;

      // Präfixe sammeln: ! = neues Fenster, * = Backlink hinzufügen
      let isNewWindow = false;
      let wantsBack = false;
      while (txt.startsWith('!') || txt.startsWith('*')) {
        if (txt.startsWith('!')) { isNewWindow = true; txt = txt.slice(1).trimStart(); }
        else if (txt.startsWith('*')) { wantsBack = true; txt = txt.slice(1).trimStart(); }
      }

      if (!isNewWindow && !wantsBack) return;

      // Text ohne Präfixe setzen
      link.textContent = txt;

      // Neues Fenster?
      if (isNewWindow) {
        link.setAttribute('target', '_blank');
        link.setAttribute('rel', 'noopener noreferrer');
      }

      // Backlink nur für interne Links (same-origin oder relative)
      if (wantsBack) {
        const href = link.getAttribute('href') || '';
        // skip Sonderprotokolle
        if (/^(mailto:|tel:|javascript:)/i.test(href)) return;

        let url;
        try {
          // ⚠️ WICHTIG: gegen window.location.href auflösen, damit /docs erhalten bleibt
          url = new URL(href, window.location.href);
        } catch {
          return;
        }

        const isSameOrigin = url.origin === window.location.origin;
        // (Wenn du *nur* same-origin willst, reicht die Zeile oben; relative sind dann automatisch same-origin.)
        if (!isSameOrigin) {
          // externer Link -> kein back/backText anhängen
          return;
        }

        // nicht doppeln
        if (!url.searchParams.has('back')) {
          if (isNewWindow){
            url.searchParams.set('back', "");
          } else {
            url.searchParams.set('back', backValue);
          }
        }
        if (!url.searchParams.has('backText')) {
          if (isNewWindow){
            url.searchParams.set('backText', blankTextValue);
          } else {
            url.searchParams.set('backText', backTextValue);
          }

        }

        // Href ohne Origin zurückschreiben (absolute Pfade mit /docs bleiben korrekt)
        const newHref = url.pathname + (url.search || '') + (url.hash || '');
        link.setAttribute('href', newHref);
      }
    });
  }

  function checkForBanner() {
    if (document.documentElement.lang !== "en") return;

    const banner = document.createElement("div");
    banner.className = "alert alert-warning alert-dismissible fade show";
    banner.style.margin = "0 0 1rem 0";
    banner.style.padding = "1rem";
    banner.style.textAlign = "left";
    banner.style.backgroundColor = "#FFDEBB";
    banner.innerHTML = `
      <strong>Hinweis:</strong>
      Willkommen im Ausbildungsprogramm 2025. Falls du deine Ausbildung vor dem 1. August 2025 begonnen hast, dann
      nutze bitte die <a href="/en">alte Version</a>.
    `;

    if (window.location.pathname == "/de/") {
      const header = document.querySelector("header.navbar, .navbar");
      const offset = (header ? header.offsetHeight : 80) + 20;
      banner.style.marginTop = offset + "px";
      banner.style.marginBottom = 0;
    }

    document.querySelectorAll("main").forEach(main => {
      const clone = banner.cloneNode(true);
      main.prepend(clone);
    });    
  }

  function replaceTextInNode(node, replacements) {
    if (node.nodeType === Node.TEXT_NODE) {
      let text = node.nodeValue;

      // Platzhalter: [[key|fallback]] oder [[key]]
      text = text.replace(/\[\[([a-zA-Z0-9_]+)(\|([^\]]+))?\]\]/g, (match, key, _fallbackPart, fallbackValue) => {
        let value;

        if (replacements.hasOwnProperty(key)) {
          value = replacements[key];
          console.log(`✅ use from replacements: [[${key}]] = "${value}"`);
        } else {
          value = localStorage.getItem(key);
          if (value !== null && value !== '') {
            console.log(`🔁 Replace [[${key}]] with local-storage-value "${value}"`);
          }
        }

        if (value !== undefined && value !== null && value !== '') {
          return value;
        } else if (fallbackValue !== undefined) {
          console.log(`🪙 [[${key}]] not defined → fallback "${fallbackValue}"`);
          return fallbackValue;
        } else {
          console.log(`⚠️ [[${key}]] not defined and no fallback`);
          return '';
        }
      });

      node.nodeValue = text;
    } else {
      node.childNodes.forEach(child => replaceTextInNode(child, replacements));
    }
  }

  function getWithDefault(key, fallback) {
    const value = localStorage.getItem(key);
    if (value === null || value === '') {
      console.log(`ℹ️ ${key} not defined → use default value: "${fallback}"`);
      return fallback;
    } else {
      console.log(`✅ ${key} loaded: "${value}"`);
      return value;
    }
  }

  function dynamicAdaptContent(){
    console.log("🚀 Use configuration settings...");

    const os = getWithDefault('itninja_os', 'Windows');
    const apprenticeshipprovider = getWithDefault('itninja_apprenticeshipprovider', '');
    const username = getWithDefault('itninja_username', 'u123456');

    // visibility for apprenticeship users
    document.querySelectorAll('[class^="is-a-"], [class*=" is-a-"]').forEach(el => {
      const matches = Array.from(el.classList).some(cls =>
        cls === 'is-a-' + apprenticeshipprovider.toLowerCase()
      );
      if (matches) {
        el.style.display = el.dataset.shouldDisplay || 'block';
      }
    });

    // visibility by OS
    document.querySelectorAll('[class^="is-os-"], [class*=" is-os-"]').forEach(el => {
      const match = Array.from(el.classList).find(cls => cls.startsWith('is-os-'));
      if (match && match === 'is-os-' + os.toLowerCase()) {
        el.style.display = el.dataset.shouldDisplay || 'block';
      }
    });

    var path = 'C:\\Users\\u123456\\local_repos\\it-ninja-labs'
    // Check for OS
    if(os.toLowerCase() === "linux") {
      path ='/home/u123456/repos.local/it-ninjas-lab'
    }
    path = path.replace("u123456", username);

    // Textreplacements
    const replacements = {
      'itninja_username': username,
      'itninja_localrepo': getWithDefault('itninja_localrepo', path),
    };

    replaceTextInNode(document.body, replacements);

    console.log("✅ Configuration settings adapted");
  }

  window.addEventListener('DOMContentLoaded', () => {

    dynamicAdaptContent();
    checkForBanner();
    fixUrl();
    checkBacklink();
  });
</script>
