











































































































































































































































































































































































































































































































































































































[{"body":"Im Exam zu Angular hast du eine Notenverwaltung erstellt. Nun sollst du sie geschickt mit NgRx erweitern, um die Fächer, Noten, Durchschnitte usw. mithilfe von NgRx zu speichern. Achte darauf, dass bei Hinzufügen, Bearbeiten oder Löschen von Noten die Berechnung des Durchschnitts nicht über einen Backend-Request erfolgt, sondern über einen Selector. Zudem sollen die GET-Anfragen minimiert werden, sodass nach dem POST einer Note keine direkte GET-Anfrage mehr erforderlich ist. Das GET ist bei NgRx nicht mehr notwendig.\n","categories":"","description":"Eine Aufgaben zu NgRx.\n","excerpt":"Eine Aufgaben zu NgRx.\n","ref":"/exams/03_web/07_angular-ngrx/01_ngrx/","tags":"","title":"Exam zu NgRx"},{"body":"Im Exam zu Angular hast du eine Notenverwaltung erstellt. Nun sollst du sie geschickt mit NgRx erweitern, um die Fächer, Noten, Durchschnitte usw. mithilfe von NgRx zu speichern. Achte darauf, dass bei Hinzufügen, Bearbeiten oder Löschen von Noten die Berechnung des Durchschnitts nicht über einen Backend-Request erfolgt, sondern über einen Selector. Zudem sollen die GET-Anfragen minimiert werden, sodass nach dem POST einer Note keine direkte GET-Anfrage mehr erforderlich ist. Das GET ist bei NgRx nicht mehr notwendig.\n","categories":"","description":"Eine Aufgaben zu NgRx.\n","excerpt":"Eine Aufgaben zu NgRx.\n","ref":"/de/exams/03_web/07_angular-ngrx/01_ngrx/","tags":"","title":"Exam zu NgRx"},{"body":"Node.js Traditionell wurde JavaScript hauptsächlich im Browser verwendet, um interaktive Webseiten zu erstellen. Node.js ermöglicht es jedoch, JavaScript-Code ausserhalb des Browsers (z.B. direkt via Kommandozeile) auszuführen und bietet auch die Möglichkeiten, serverseitige Anwendungen (Backends) mittels JavaScript zu entwickeln. Mit Node können wir später diverse Packages installieren und in unserer Webapplikation einsetzen.\nNodeJS ermöglicht es also, JavaScript als Programmiersprache im Backend zu verwenden. Zusätzlich verwenden viele Frontends wie Angular oder React NodeJS als Grundgerüst für das Projekt.\nInstallation von Node.js In diesem Kapitel werden wir nun Node.js installieren, falls das bei dir noch nicht der Fall ist.\nZuerst prüfen wir, ob Node.js bereits auf dem System installiert ist:\n1 node --version Falls nicht, kannst du hier Node.js installieren:\n5’ - Einzelarbeit\nInstalliere Node.js unter folgendem Link: https://nodejs.org/en/. Verwende die LTS Version, diese wird für die meisten Nutzer empfohlen. Bei der Installation sind keine Anpassungen notwendig. Du kannst dich einfach durchklicken. Prüfe danach die Version noch einmal.\nnpm Node.js enthält einem integrierten Package-Manager namens “npm” (Node Package Manager). npm ermöglicht es, Libraries und Module von anderen Entwicklern herunterzuladen, zu installieren und in eigenen Projekten zu verwenden. npm bietet Zugriff auf eine riesige Sammlung von Open-Source-Packages.\nnpm ermöglicht es auch, eigene Packages zu erstellen und zu veröffentlichen, sodass andere Entwickler sie verwenden können. Durch das Veröffentlichen der Packages auf npm kann man dieses für die gesamte Community zugänglich machen und Updates und Verbesserungen bereitstellen.\nnpm Commands Hier sind einige wichtige npm-Befehle, die beim Arbeiten mit Node.js-Projekten und dem Node Package Manager (npm) hilfreich sind:\nnpm init: Erstellt eine neue package.json-Datei, um ein neues Projekt zu initialisieren. npm install: Installiert alle Dependencies, die in der package.json-Datei aufgeführt sind. Der Einfachheit halber kann man auch einfach npm i schreiben. npm install \u003cpackagename\u003e: Installiert ein bestimmtes Package und fügt es zur package.json-Datei hinzu. npm uninstall \u003cpackagename\u003e: Deinstalliert ein Package und entfernt es aus der package.json-Datei. npm update: Aktualisiert alle Dependencies auf die neuste Version, gemäss den in der package.json-Datei angegebenen Versionsbeschränkungen. npm run \u003cscriptname\u003e: Führt ein in der scripts-Sektion der package.json-Datei definiertes Skript aus. Zum Beispiel: npm run build oder npm run start. package.json npm verwendet eine Datei namens package.json, um Informationen über das Projekt und seine Dependencies zu speichern. Diese Datei enthält Metadaten wie den Namen des Projekts, die Version, die Autorinformationen und die Liste der Dependencies. Man kann das package.json manuell erstellen oder den Befehl npm init verwenden, um einen interaktiven Assistenten zu starten, der hilft, die Informationen einzugeben.\nIn der package.json Datei werden die Dependencies des Projekts aufgelistet. Es gibt zwei Arten von Dependencies: “dependencies” und “devDependencies”. “dependencies” sind Packages, die für die Ausführung der Anwendung erforderlich sind, während “devDependencies” Packages sind, die nur für die Entwicklung, Tests und den Build-Prozess verwendet werden. Wenn man ein Package mit npm install installiert, wird es automatisch zur richtigen Kategorie hinzugefügt.\nZudem kann man auch benutzerdefinierte Skripte definieren, die bestimmte Aufgaben ausführen. Diese Skripte können verwendet werden, um Tests durchzuführen, den Code zu kompilieren, den Server zu starten und andere Entwicklungs- oder Build-Aufgaben zu automatisieren. Man kann die Skripte mit dem Befehl npm run \u003cscriptname\u003e ausführen.\npackage-lock.json Die package-lock.json-Datei ist eine Datei, die von npm automatisch generiert wird, sobald man das erste Mal npm install im Projektverzeichnis ausgeführt hat. Sie dient dazu, die genauen Versionen der heruntergeladenen Pakete und deren Dependencies festzuhalten. Das package-lock.json ermöglicht eine deterministische Wiederholbarkeit von Paketinstallationen in einem Projekt, was bedeutet, dass jeder Entwickler oder jede Build-Umgebung die gleichen Versionen der Pakete erhält.\nEs ist wichtig, die package-lock.json-Datei nicht manuell zu bearbeiten, da dies zu Inkonsistenzen und Problemen führen kann. npm soll die Datei automatisch generieren.\nnpm i vs npm ci Die Befehle npm i und npm ci werden beide verwendet, um die Dependencies eines Node.js-Projekts zu installieren. Es gibt jedoch einen wichtigen Unterschied zwischen den beiden Befehlen.\nnpm i installiert die neuste Version der Dependencies, auch wenn im package.json eine ältere Version angegeben ist. Jedoch ist dies aber nur bei denjenigen, die mit ^ beginnen, der Fall, also z.B. ^12.2.12, wobei sich nur die hinterste Zahl ändert. Denn die hinterste Zahl bei einer Version bedeutet, dass nur Fixes gemacht wurden. Wenn man nun so neue Versionen holt, wird die neue Version automatisch ins package-lock.json geschrieben.\nnpm ci holt die Dependencies aus package-lock.json, heisst, es holt die Dependencies direkt von «resolved» und nicht wie npm i, welches beim lokalen Register ansetzt. Zudem holt es die Version, welche je nachdem vom npm i erneuert wurde.\nnode_modules Um ein Package zu installieren, kann man den Befehl npm install \u003cpackagename\u003e verwenden. npm lädt das Package und alle seine Dependencies (Dependency) herunter und installiert sie in einem Verzeichnis namens node_modules im Projektordner. Wenn man dann den Code schreibt, kann man das installierte Package in den JavaScript-Dateien verwenden.\n","categories":"","description":"In diesem Kapitel wird Node.js genauer erläutert.\n","excerpt":"In diesem Kapitel wird Node.js genauer erläutert.\n","ref":"/docs/03_web/04_ide-advanced/01_nodejs/","tags":"","title":"Node.js"},{"body":"Node.js Traditionell wurde JavaScript hauptsächlich im Browser verwendet, um interaktive Webseiten zu erstellen. Node.js ermöglicht es jedoch, JavaScript-Code ausserhalb des Browsers (z.B. direkt via Kommandozeile) auszuführen und bietet auch die Möglichkeiten, serverseitige Anwendungen (Backends) mittels JavaScript zu entwickeln. Mit Node können wir später diverse Packages installieren und in unserer Webapplikation einsetzen.\nNodeJS ermöglicht es also, JavaScript als Programmiersprache im Backend zu verwenden. Zusätzlich verwenden viele Frontends wie Angular oder React NodeJS als Grundgerüst für das Projekt.\nInstallation von Node.js In diesem Kapitel werden wir nun Node.js installieren, falls das bei dir noch nicht der Fall ist.\nZuerst prüfen wir, ob Node.js bereits auf dem System installiert ist:\n1 node --version Falls nicht, kannst du hier Node.js installieren:\n5’ - Einzelarbeit\nInstalliere Node.js unter folgendem Link: https://nodejs.org/en/. Verwende die LTS Version, diese wird für die meisten Nutzer empfohlen. Bei der Installation sind keine Anpassungen notwendig. Du kannst dich einfach durchklicken. Prüfe danach die Version noch einmal.\nnpm Node.js enthält einem integrierten Package-Manager namens “npm” (Node Package Manager). npm ermöglicht es, Libraries und Module von anderen Entwicklern herunterzuladen, zu installieren und in eigenen Projekten zu verwenden. npm bietet Zugriff auf eine riesige Sammlung von Open-Source-Packages.\nnpm ermöglicht es auch, eigene Packages zu erstellen und zu veröffentlichen, sodass andere Entwickler sie verwenden können. Durch das Veröffentlichen der Packages auf npm kann man dieses für die gesamte Community zugänglich machen und Updates und Verbesserungen bereitstellen.\nnpm Commands Hier sind einige wichtige npm-Befehle, die beim Arbeiten mit Node.js-Projekten und dem Node Package Manager (npm) hilfreich sind:\nnpm init: Erstellt eine neue package.json-Datei, um ein neues Projekt zu initialisieren. npm install: Installiert alle Dependencies, die in der package.json-Datei aufgeführt sind. Der Einfachheit halber kann man auch einfach npm i schreiben. npm install \u003cpackagename\u003e: Installiert ein bestimmtes Package und fügt es zur package.json-Datei hinzu. npm uninstall \u003cpackagename\u003e: Deinstalliert ein Package und entfernt es aus der package.json-Datei. npm update: Aktualisiert alle Dependencies auf die neuste Version, gemäss den in der package.json-Datei angegebenen Versionsbeschränkungen. npm run \u003cscriptname\u003e: Führt ein in der scripts-Sektion der package.json-Datei definiertes Skript aus. Zum Beispiel: npm run build oder npm run start. package.json npm verwendet eine Datei namens package.json, um Informationen über das Projekt und seine Dependencies zu speichern. Diese Datei enthält Metadaten wie den Namen des Projekts, die Version, die Autorinformationen und die Liste der Dependencies. Man kann das package.json manuell erstellen oder den Befehl npm init verwenden, um einen interaktiven Assistenten zu starten, der hilft, die Informationen einzugeben.\nIn der package.json Datei werden die Dependencies des Projekts aufgelistet. Es gibt zwei Arten von Dependencies: “dependencies” und “devDependencies”. “dependencies” sind Packages, die für die Ausführung der Anwendung erforderlich sind, während “devDependencies” Packages sind, die nur für die Entwicklung, Tests und den Build-Prozess verwendet werden. Wenn man ein Package mit npm install installiert, wird es automatisch zur richtigen Kategorie hinzugefügt.\nZudem kann man auch benutzerdefinierte Skripte definieren, die bestimmte Aufgaben ausführen. Diese Skripte können verwendet werden, um Tests durchzuführen, den Code zu kompilieren, den Server zu starten und andere Entwicklungs- oder Build-Aufgaben zu automatisieren. Man kann die Skripte mit dem Befehl npm run \u003cscriptname\u003e ausführen.\npackage-lock.json Die package-lock.json-Datei ist eine Datei, die von npm automatisch generiert wird, sobald man das erste Mal npm install im Projektverzeichnis ausgeführt hat. Sie dient dazu, die genauen Versionen der heruntergeladenen Pakete und deren Dependencies festzuhalten. Das package-lock.json ermöglicht eine deterministische Wiederholbarkeit von Paketinstallationen in einem Projekt, was bedeutet, dass jeder Entwickler oder jede Build-Umgebung die gleichen Versionen der Pakete erhält.\nEs ist wichtig, die package-lock.json-Datei nicht manuell zu bearbeiten, da dies zu Inkonsistenzen und Problemen führen kann. npm soll die Datei automatisch generieren.\nnpm i vs npm ci Die Befehle npm i und npm ci werden beide verwendet, um die Dependencies eines Node.js-Projekts zu installieren. Es gibt jedoch einen wichtigen Unterschied zwischen den beiden Befehlen.\nnpm i installiert die neuste Version der Dependencies, auch wenn im package.json eine ältere Version angegeben ist. Jedoch ist dies aber nur bei denjenigen, die mit ^ beginnen, der Fall, also z.B. ^12.2.12, wobei sich nur die hinterste Zahl ändert. Denn die hinterste Zahl bei einer Version bedeutet, dass nur Fixes gemacht wurden. Wenn man nun so neue Versionen holt, wird die neue Version automatisch ins package-lock.json geschrieben.\nnpm ci holt die Dependencies aus package-lock.json, heisst, es holt die Dependencies direkt von «resolved» und nicht wie npm i, welches beim lokalen Register ansetzt. Zudem holt es die Version, welche je nachdem vom npm i erneuert wurde.\nnode_modules Um ein Package zu installieren, kann man den Befehl npm install \u003cpackagename\u003e verwenden. npm lädt das Package und alle seine Dependencies (Dependency) herunter und installiert sie in einem Verzeichnis namens node_modules im Projektordner. Wenn man dann den Code schreibt, kann man das installierte Package in den JavaScript-Dateien verwenden.\n","categories":"","description":"In diesem Kapitel wird Node.js genauer erläutert.\n","excerpt":"In diesem Kapitel wird Node.js genauer erläutert.\n","ref":"/de/docs/03_web/04_ide-advanced/01_nodejs/","tags":"","title":"Node.js"},{"body":"Ziele Du weisst was NgRx ist, kennst die dazugehörigen Kernkonzepte und weisst, wofür man NgRx nutzt. Du kannst NgRx bei dir installieren. NgRx NgRx ist ein beliebtes State-Management-Framework für Angular-Anwendungen, das auf der Redux-Architektur basiert. Es bietet eine zentrale Datenquelle, den sogenannten Store, um den Anwendungsstatus zu verwalten. Mit NgRx kann man den Zustand einer Anwendung zentralisieren, die Datenflüsse vereinfachen und eine bessere Skalierbarkeit und Testbarkeit erreichen.\nNgRx besteht aus verschiedenen Kernkonzepten:\nStore: Der Store ist der zentrale Speicherort für den Anwendungsstatus. Er enthält den globalen Zustand deiner Anwendung in einem einheitlichen JavaScript-Objekt. Du kannst den Zustand von praktisch überall auslesen und ihn mit Actions ändern.\nActions: Actions repräsentieren Ereignisse oder Absichten, die in einer Anwendung auftreten können. Sie sind einfache JavaScript-Objekte, die eine Typ-Eigenschaft haben, um den Typ der Aktion zu definieren. Actions werden verwendet, um Änderungen im Zustand anzufordern.\nReducers: Reducers sind pure Funktionen, die den vorherigen Zustand und eine Aktion als Eingabe erhalten und den neuen Zustand zurückgeben. Sie definieren, wie sich der Zustand der Anwendung basierend auf den empfangenen Actions ändert.\nSelectors: Selectors sind Funktionen, die den Zustand aus dem Store abrufen und bestimmte Teile des Zustands extrahieren. Sie werden verwendet, um Daten aus dem Store zu lesen und an die Components weiterzugeben.\nEffects: Effects ermöglichen die asynchrone Datenverarbeitung und die Interaktion mit externen APIs. Sie reagieren auf bestimmte Aktionen und führen Nebenwirkungen aus, wie z.B. das Abrufen von Daten von einem Server oder das Auslösen weiterer Aktionen.\nInstallation Um NgRx in einem Angular-Projekt zu verwenden, werden folgende Schritte benötigt:\nStelle sicher, dass Node.js und npm (Node Package Manager) auf dem Computer installiert sind. (Kann mit npm -v geprüft werden) Öffne ein Terminal oder eine andere Shell und navigiere zum Hauptverzeichnis des Projekts. Führe den folgenden Befehl aus, um NgRx zu installieren: 1 npm install @ngrx/store Dieser installiert das NgRx Store-Paket, das den zentralen Store und andere wichtige Funktionen für das State-Management bereitstellt. 4. Optional: Je nachdem, welche NgRx-Features man verwenden möchte, kann man weitere NgRx-Pakete installieren. Hier sind einige gängige Pakete:\n1 2 3 npm install @ngrx/effects // Für die Verwendung von Effects npm install @ngrx/entity // Für die Verwendung von Entity State npm install @ngrx/router-store // Für die Integration von Router-Status mit dem Store Sobald die Installation abgeschlossen ist, können die NgRx-Features im Projekt verwendet werden, indem die entsprechenden Provides angegeben und konfiguriert werden: NgRx Store: Um den NgRx Store zu verwenden, muss provideStore importiert und in der app.config.ts-Datei konfiguriert werden. (reducers stammt aus der index.ts-Datei im reducers-Ordner) 1 2 3 4 5 6 import { provideStore } from \"@ngrx/store\"; import { reducers } from \"./reducers\"; export const appConfig: ApplicationConfig = { providers: [provideStore(reducers)], }; Optional NgRx Effects: Um den NgRx Effects zu verwenden, muss provideEffects importiert und in der app.config.ts-Datei konfiguriert werden. 1 2 3 4 5 import { provideEffects } from \"@ngrx/effects\"; import { RouterEffects } from \"@ngrx/router-store\"; export const appConfig: ApplicationConfig = { providers: [provideEffects(RouterEffects)], }; Debugging Tool Damit man mit NgRx auch anständig debuggen kann, gibt es eine Chrome Extension, welche dabei sehr helfen kann. Die Extension bietet eine Vielzahl von Funktionen, um den Zustand des Redux-Stores zu überwachen, Aktionen zu verfolgen und den Ablauf der Anwendung besser zu verstehen.\n","categories":"","description":"Modul #F7 - Angular NgRx - Übersicht\n","excerpt":"Modul #F7 - Angular NgRx - Übersicht\n","ref":"/docs/03_web/07_angular-ngrx/01_ngrx/","tags":"","title":"NgRx"},{"body":"Ziele Du weisst was NgRx ist, kennst die dazugehörigen Kernkonzepte und weisst, wofür man NgRx nutzt. Du kannst NgRx bei dir installieren. NgRx NgRx ist ein beliebtes State-Management-Framework für Angular-Anwendungen, das auf der Redux-Architektur basiert. Es bietet eine zentrale Datenquelle, den sogenannten Store, um den Anwendungsstatus zu verwalten. Mit NgRx kann man den Zustand einer Anwendung zentralisieren, die Datenflüsse vereinfachen und eine bessere Skalierbarkeit und Testbarkeit erreichen.\nNgRx besteht aus verschiedenen Kernkonzepten:\nStore: Der Store ist der zentrale Speicherort für den Anwendungsstatus. Er enthält den globalen Zustand deiner Anwendung in einem einheitlichen JavaScript-Objekt. Du kannst den Zustand von praktisch überall auslesen und ihn mit Actions ändern.\nActions: Actions repräsentieren Ereignisse oder Absichten, die in einer Anwendung auftreten können. Sie sind einfache JavaScript-Objekte, die eine Typ-Eigenschaft haben, um den Typ der Aktion zu definieren. Actions werden verwendet, um Änderungen im Zustand anzufordern.\nReducers: Reducers sind pure Funktionen, die den vorherigen Zustand und eine Aktion als Eingabe erhalten und den neuen Zustand zurückgeben. Sie definieren, wie sich der Zustand der Anwendung basierend auf den empfangenen Actions ändert.\nSelectors: Selectors sind Funktionen, die den Zustand aus dem Store abrufen und bestimmte Teile des Zustands extrahieren. Sie werden verwendet, um Daten aus dem Store zu lesen und an die Components weiterzugeben.\nEffects: Effects ermöglichen die asynchrone Datenverarbeitung und die Interaktion mit externen APIs. Sie reagieren auf bestimmte Aktionen und führen Nebenwirkungen aus, wie z.B. das Abrufen von Daten von einem Server oder das Auslösen weiterer Aktionen.\nInstallation Um NgRx in einem Angular-Projekt zu verwenden, werden folgende Schritte benötigt:\nStelle sicher, dass Node.js und npm (Node Package Manager) auf dem Computer installiert sind. (Kann mit npm -v geprüft werden) Öffne ein Terminal oder eine andere Shell und navigiere zum Hauptverzeichnis des Projekts. Führe den folgenden Befehl aus, um NgRx zu installieren: 1 npm install @ngrx/store Dieser installiert das NgRx Store-Paket, das den zentralen Store und andere wichtige Funktionen für das State-Management bereitstellt. 4. Optional: Je nachdem, welche NgRx-Features man verwenden möchte, kann man weitere NgRx-Pakete installieren. Hier sind einige gängige Pakete:\n1 2 3 npm install @ngrx/effects // Für die Verwendung von Effects npm install @ngrx/entity // Für die Verwendung von Entity State npm install @ngrx/router-store // Für die Integration von Router-Status mit dem Store Sobald die Installation abgeschlossen ist, können die NgRx-Features im Projekt verwendet werden, indem die entsprechenden Provides angegeben und konfiguriert werden: NgRx Store: Um den NgRx Store zu verwenden, muss provideStore importiert und in der app.config.ts-Datei konfiguriert werden. (reducers stammt aus der index.ts-Datei im reducers-Ordner) 1 2 3 4 5 6 import { provideStore } from \"@ngrx/store\"; import { reducers } from \"./reducers\"; export const appConfig: ApplicationConfig = { providers: [provideStore(reducers)], }; Optional NgRx Effects: Um den NgRx Effects zu verwenden, muss provideEffects importiert und in der app.config.ts-Datei konfiguriert werden. 1 2 3 4 5 import { provideEffects } from \"@ngrx/effects\"; import { RouterEffects } from \"@ngrx/router-store\"; export const appConfig: ApplicationConfig = { providers: [provideEffects(RouterEffects)], }; Debugging Tool Damit man mit NgRx auch anständig debuggen kann, gibt es eine Chrome Extension, welche dabei sehr helfen kann. Die Extension bietet eine Vielzahl von Funktionen, um den Zustand des Redux-Stores zu überwachen, Aktionen zu verfolgen und den Ablauf der Anwendung besser zu verstehen.\n","categories":"","description":"Modul #F7 - Angular NgRx - Übersicht\n","excerpt":"Modul #F7 - Angular NgRx - Übersicht\n","ref":"/de/docs/03_web/07_angular-ngrx/01_ngrx/","tags":"","title":"NgRx"},{"body":"Bevor du mit dem neuen Kapitel JavaScript beginnen kannst, solltest du nochmals das Kapitel Node JS Installation durcharbeiten und sicherstellen, dass alles Nötige installiert ist.\nJetzt wird es Zeit, dass du auch Programm-Logik auf deiner Website einbauen kannst. Dafür lernst du nachfolgend die Programmiersprache JavaScript kennen, die von praktisch allen bekannten Browsern unterstützt wird.\nUm eine Übersicht über die Programmiersprache zu erhalten, kannst du dir als Erstes dieses Video anschauen.\nMotivation für JavaScript JavaScript hat sehr viele Anwendungsfälle im Browser. Einerseits können Funktionen ähnlich wie mit Java programmiert werden, sodass beispielsweise Berechnungen ausgeführt werden können. Dazu kann aber auch direkt mit dem angezeigten Inhalt interagiert werden. So können Validierungen oder auch Animationen ausgeführt werden. Wenn du mal sehen willst, wie eine Website aussieht, die kein JS verwendet, kannst du dir diese Anleitung anschauen, mit welcher du das JS einer Webseite komplett ausschalten kannst.\nWir beginnen erstmal klein: Mit einem Button, der bei einem Klick eine MessageBox anzeigt.\n1 2 3 4 5 6 7 \u003cbutton onclick=\"onClickMeClick()\" type=\"button\"\u003eKlick mich\u003c/button\u003e \u003cscript\u003e function onClickMeClick() { alert(\"Klick mich nicht an!!\"); } \u003c/script\u003e Versuche zuerst, dieses Beispiel ohne Erläuterung zu verstehen.\nErläuterung (click to expand) Zuerst hast du im HTML einen Button erstellt mit dem Text \"Klick mich\". Weiter unten siehst du ein \u003cscript\u003e-Element. In diesem ist eine Funktion namens onClickMeClick() definiert. Die Funktion führt den Block alert(message: string) aus. Diese alert-Funktion öffnet eine MessageBox mit der übergebenen Nachricht.\nWie du siehst, wird die selbst definierte Funktion beim Klick auf den Button aufgerufen. Dies passiert, weil du diesen Aufruf im onclick-Attribut des \u003cbutton\u003e-Elements definiert hast. Beachte in diesem Beispiel, dass nicht die Funktion, sondern deren Aufruf darin steht. Im Prinzip wird beim Button-Klick der Wert des onclick-Attributs ausgeführt. Theoretisch könntest du auch direkt onclick=\"alert('Klick mich nicht an!!')\" schreiben.\n","categories":"","description":"Modul #F4 - JavaScript - Code im Browser ausführen\n","excerpt":"Modul #F4 - JavaScript - Code im Browser ausführen\n","ref":"/docs/03_web/03_javascript/01_intro/","tags":"","title":"JavaScript: Einführung"},{"body":"Bevor du mit dem neuen Kapitel JavaScript beginnen kannst, solltest du nochmals das Kapitel Node JS Installation durcharbeiten und sicherstellen, dass alles Nötige installiert ist.\nJetzt wird es Zeit, dass du auch Programm-Logik auf deiner Website einbauen kannst. Dafür lernst du nachfolgend die Programmiersprache JavaScript kennen, die von praktisch allen bekannten Browsern unterstützt wird.\nUm eine Übersicht über die Programmiersprache zu erhalten, kannst du dir als Erstes dieses Video anschauen.\nMotivation für JavaScript JavaScript hat sehr viele Anwendungsfälle im Browser. Einerseits können Funktionen ähnlich wie mit Java programmiert werden, sodass beispielsweise Berechnungen ausgeführt werden können. Dazu kann aber auch direkt mit dem angezeigten Inhalt interagiert werden. So können Validierungen oder auch Animationen ausgeführt werden. Wenn du mal sehen willst, wie eine Website aussieht, die kein JS verwendet, kannst du dir diese Anleitung anschauen, mit welcher du das JS einer Webseite komplett ausschalten kannst.\nWir beginnen erstmal klein: Mit einem Button, der bei einem Klick eine MessageBox anzeigt.\n1 2 3 4 5 6 7 \u003cbutton onclick=\"onClickMeClick()\" type=\"button\"\u003eKlick mich\u003c/button\u003e \u003cscript\u003e function onClickMeClick() { alert(\"Klick mich nicht an!!\"); } \u003c/script\u003e Versuche zuerst, dieses Beispiel ohne Erläuterung zu verstehen.\nErläuterung (click to expand) Zuerst hast du im HTML einen Button erstellt mit dem Text \"Klick mich\". Weiter unten siehst du ein \u003cscript\u003e-Element. In diesem ist eine Funktion namens onClickMeClick() definiert. Die Funktion führt den Block alert(message: string) aus. Diese alert-Funktion öffnet eine MessageBox mit der übergebenen Nachricht.\nWie du siehst, wird die selbst definierte Funktion beim Klick auf den Button aufgerufen. Dies passiert, weil du diesen Aufruf im onclick-Attribut des \u003cbutton\u003e-Elements definiert hast. Beachte in diesem Beispiel, dass nicht die Funktion, sondern deren Aufruf darin steht. Im Prinzip wird beim Button-Klick der Wert des onclick-Attributs ausgeführt. Theoretisch könntest du auch direkt onclick=\"alert('Klick mich nicht an!!')\" schreiben.\n","categories":"","description":"Modul #F4 - JavaScript - Code im Browser ausführen\n","excerpt":"Modul #F4 - JavaScript - Code im Browser ausführen\n","ref":"/de/docs/03_web/03_javascript/01_intro/","tags":"","title":"JavaScript: Einführung"},{"body":"Ziele Du weisst, was Typescript ist und inwiefern es sich von Javascript unterscheidet. Du weisst, welche Vorteile Typescript im Vergleich zu Javascript hat. Du weisst, wie du den objektorientierten Programmieransatz in Typescript einbinden kannst und wie man in Typescript Klassen verwendet. Was ist TypeScript? Die Programmiersprache Typescript wurde von Microsoft entwickelt und wurde im Jahr 2012 mit der ersten Version veröffentlicht. Seitdem wird die Programmiersprache kontinuierlich weiterentwickelt. Zahlreiche JavaScript-Frameworks setzen heute auf die Verwendung von TypeScript. Dazu gehören zum Beispiel Angular 2+ und React.\nTypeScript bildet eine Erweiterung von JavaScript, fügt also JavaScript bestimmte Features hinzu. Es handelt sich dabei also um ein sogenanntes Superset von JavaScript.\nDa Quellcode geschrieben in TypeScript zu JavaScript transpiliert wird, ist der Code in jedem Browser lauffähig.\nVorteile von TypeScript TypeScript hebt Fehler während der Transpilierung hervor, während JavaScript das erst zur Laufzeit macht. TypeScript unterstützt statische Typisierung. Ermöglicht bessere Code-Strukturierung und Objekt-Orientierte Programmiertechniken. TypeScript ist in jedem Browser und jeder JS-Engine lauffähig. Hervorragendes “Tooling” mit IntelliSense, das beim Hinzufügen des Codes aktive Hinweise liefert. Grundlegende Syntax Da es sich bei TypeScript um ein Superset von JavaScript handelt, ist JavaScript-Code auch gültiger TypeScript-Code. Jedoch fügt TypeScript darüber hinaus viele neue Funktionen hinzu.\nMit TypeScript wird JavaScript zu einer stark typisierten, objektorientierten Sprache, die C# und Java ähnelt. Dies bedeutet, dass TypeScript-Code für grosse Projekte leichter zu verstehen, verwenden und verwalten ist. Die starke Typisierung bedeutet auch, dass die Sprache vorkompiliert werden kann und dass Variablen keine Werte zugewiesen werden können, die ausserhalb ihres angegebenen Bereichs liegen. Wenn zum Beispiel eine TypeScript-Variable als Zahl deklariert ist, kann man dieser Variable keinen Textwert zuweisen.\nNull Safety In TypeScript gibt es standardmässig keine “Null Safety” im Sinne einer statischen Typüberprüfung auf mögliche Null- oder Undefined-Werte. Das bedeutet, dass Variablen jeden Typ annehmen können, einschliesslich null oder undefined, es sei denn, es wird explizit angegeben, dass sie einen anderen Typ haben sollen. Das kann dazu führen, dass in TypeScript-Code unerwartete Fehler auftreten, wenn versucht wird, auf Eigenschaften oder Methoden von null- oder undefined-Variablen zuzugreifen. Solche Fehler treten normalerweise zur Laufzeit auf und werden nicht vom Compiler erkannt.\nUm das Risiko von Fehlern durch null- oder undefined-Werte zu reduzieren, kann man die Option strictNullChecks in der tsconfig.json-Datei aktivieren.\nTypanmeldungen Typdeklarationen können zu Variablen, Funktionsparametern und Funktionsrückgabetypen hinzugefügt werden. Der Typ folgt jeweils auf einen Doppelpunkt hinter dem Variablennamen:\n1 const num: number = 1; Der Compiler überprüft dann die Typen während des Transpilierens und meldet allfällige Typfehler.\nDie verschiedenen Grundtypen von TypeScript sind hier ersichtlich.\nType Any Der Typ any ist ein spezieller Typ, der es ermöglicht, Variablen, Funktionen und andere Objekte ohne explizite Typisierung zu deklarieren. Wenn eine Variable oder ein Objekt mit any deklariert wird, bedeutet dies, dass der Typ nicht eingeschränkt ist und dass alle Arten von Werten diesem Typ zugewiesen werden können, ohne dass eine Typenüberprüfung durchgeführt wird. Das bedeutet, dass man so die gesamte Typisierung umgehen kann und dann wie bei JavaScript Typfehler erst während der Laufzeit sehen würde.\nBeispiel mit any, welches zu Laufzeitfehler führt:\n1 2 3 4 5 6 function add(a: any, b: any) { return a + b; } const result = add(\"3\", 5); console.log(result); Der Objektorientierte Ansatz Bei der objektorientierten Programmierung handelt es sich um einen Programmierstil / eine Denkweise.\nMan kann sich das so vorstellen, dass alles in der objektorientierten Programmierung durch Objekte abgebildet wird. Jedes “Teil” eines Programmes wird durch ein Objekt beschrieben.\nEin Beispiel:\nIn einer Spielewelt gibt es einen frei herumlaufenden Hund. Dann wäre dieser Hund nichts anderes als ein Objekt.\nNun könnte man sich fragen, wie man diesen Hund wahrnimmt, denn nicht jeder Hund ist gleich. Sie könnten sich in Rasse, Gattung etc. unterscheiden. Ein Objekt kann also verschiedene Eigenschaften besitzen, diese werden auch Attribute genannt. Nun kann sich unser Hund von Anderen unterscheiden, jedoch kann er noch nicht bellen. Deshalb haben Objekte auch Funktionen (Methoden). In unserem Beispiel könnte der Hund z.B. über die Methode “bark()” verfügen, welche es ihm erlaubt, zu bellen.\nIn unserem Beispiel handelt es sich bei dem Hund um eine Klasse. Klassen sind also wie Baupläne für Objekte.\nNun sagen wir, dass es in unserer Spielwelt auch Katzen gibt. An dieser Stelle kommt dann die Vererbung ins Spiel.\nHunde sowie Katzen sind beides Tiere. In der Objektorientierten Programmierung würde man dazu also eine Klasse “Animal” erstellen. Die beiden Klassen “Cat” und “Dog” würden dann die Klasse “Animal” erben. Dies Bedeutet, dass sie die Eigenschaften der Klasse “Animal” übernehmen und durch ihre eigenen Eigenschaften ergänzen.\nDa sich beide Tiere fortbewegen, könnte man also der Klasse “Animal” die Funktion “move()” geben, welche dann von den beiden anderen Klassen geerbt werden würde. Dadurch hat man verhindert, dass sich die Funktion zum bewegen mehrmals im Quellcode befindet.\nKlassen Ein einfaches Beispiel einer Klasse:\n1 2 3 4 5 6 7 8 9 10 11 class Greeter { greeting: string; constructor(message: string) { this.greeting = message; } greet() { return \"Hello, \" + this.greeting; } } let greeter = new Greeter(\"world\"); In diesem Beispiel wird eine neue Klasse “Greeter” deklariert. Die Klasse enthält 3 Member:\nDas Property “greeting” Den Konstruktor Die Methode “greet” Wenn wir in einer Klasse auf ein Member innerhalb der Klasse referenzieren, verwenden wir this..\nAuf der letzten Zeile erstellen wir eine neue Instanz der Klasse Greeter mit new.\nInterfaces Interfaces in TypeScript beschreiben die Struktur von Objekten, ohne tatsächlichen JavaScript-Code zu erzeugen. Bei der Transpilation entfernt TypeScript alle Interfaces, sodass sie in der Laufzeitumgebung nicht mehr existieren. Sie sind also rein für die statische Typisierung gedacht und lassen sich beispielsweise nicht per instanceof prüfen.\nEin einfaches Beispiel ist das folgende:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 interface Person { name: string; alter: number; } ### Vererbung In TypeScript können wir allgemeine objektorientierte Muster verwenden. Eines der grundlegendsten Muster in der klassenbasierten Programmierung ist die Möglichkeit, vorhandene Klassen durch Vererbung zu erweitern, um neue Klassen zu erstellen. ```typescript class Animal { move(distanceInMeters: number = 0) { console.log(`Animal moved ${distanceInMeters}m.`); } } class Dog extends Animal { bark() { console.log(\"Woof!\"); } } const dog = new Dog(); dog.bark(); dog.move(10); dog.bark(); Dieses Beispiel zeigt die grundlegendste Vererbungsfunktion: Klassen erben Eigenschaften und Methoden von Basisklassen (Animal). Dog ist hier eine abgeleitete Klasse, die mit dem Schlüsselwort extends von der Basisklasse Animal abgeleitet wird. Abgeleitete Klassen werden häufig als Unterklassen bezeichnet, und Basisklassen als Superklassen.\nDa Dog die Funktionalität von Animal erweitert, konnten wir eine Instanz von Dog erstellen, die sowohl bark() als auch move() ausführen konnte.\nEin komplexeres Beispiel zur Vertiefung:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Animal { name: string; constructor(theName: string) { this.name = theName; } move(distanceInMeters: number = 0) { console.log(`Animal moved ${distanceInMeters}m.`); } } class Snake extends Animal { constructor(name: string) { super(name); } move(distanceInMeters: number = 5) { console.log(\"Slithering...\"); super.move(distanceInMeters); } } class Horse extends Animal { constructor(name: string) { super(name); } move(distanceInMeters: number = 45) { console.log(\"Galloping...\"); super.move(distanceInMeters); } } let sammy = new Snake(\"Sammy the Python\"); let tom: Animal = new Horse(\"Tom the Palomino\"); sammy.move(); tom.move(35); In diesem Beispiel werden zwei neue Subklassen von Animal erstellt: Horse und Snake.\nEin Unterschied zum vorherigen Beispiel besteht darin, dass jede abgeleitete Klasse, die eine Konstruktorfunktion enthält, super() aufrufen muss, wodurch der Konstruktor der Basisklasse ausgeführt wird. Ausserdem müssen wir super() aufrufen, damit wir im Konstruktorkörper auf name mit this zugreifen können.\nKonsolenausgabe des Beispiels:\n1 2 3 4 Slithering... Sammy the Python moved 5m. Galloping... Tom the Palomino moved 34m. ","categories":"","description":"Modul #F5 - TypeScript - JavaScript mit Typen.\n","excerpt":"Modul #F5 - TypeScript - JavaScript mit Typen.\n","ref":"/docs/03_web/05_typescript/01_intro-typescript/","tags":"","title":"Einführung in TypeScript"},{"body":"Ziele Du weisst, was Typescript ist und inwiefern es sich von Javascript unterscheidet. Du weisst, welche Vorteile Typescript im Vergleich zu Javascript hat. Du weisst, wie du den objektorientierten Programmieransatz in Typescript einbinden kannst und wie man in Typescript Klassen verwendet. Was ist TypeScript? Die Programmiersprache Typescript wurde von Microsoft entwickelt und wurde im Jahr 2012 mit der ersten Version veröffentlicht. Seitdem wird die Programmiersprache kontinuierlich weiterentwickelt. Zahlreiche JavaScript-Frameworks setzen heute auf die Verwendung von TypeScript. Dazu gehören zum Beispiel Angular 2+ und React.\nTypeScript bildet eine Erweiterung von JavaScript, fügt also JavaScript bestimmte Features hinzu. Es handelt sich dabei also um ein sogenanntes Superset von JavaScript.\nDa Quellcode geschrieben in TypeScript zu JavaScript transpiliert wird, ist der Code in jedem Browser lauffähig.\nVorteile von TypeScript TypeScript hebt Fehler während der Transpilierung hervor, während JavaScript das erst zur Laufzeit macht. TypeScript unterstützt statische Typisierung. Ermöglicht bessere Code-Strukturierung und Objekt-Orientierte Programmiertechniken. TypeScript ist in jedem Browser und jeder JS-Engine lauffähig. Hervorragendes “Tooling” mit IntelliSense, das beim Hinzufügen des Codes aktive Hinweise liefert. Grundlegende Syntax Da es sich bei TypeScript um ein Superset von JavaScript handelt, ist JavaScript-Code auch gültiger TypeScript-Code. Jedoch fügt TypeScript darüber hinaus viele neue Funktionen hinzu.\nMit TypeScript wird JavaScript zu einer stark typisierten, objektorientierten Sprache, die C# und Java ähnelt. Dies bedeutet, dass TypeScript-Code für grosse Projekte leichter zu verstehen, verwenden und verwalten ist. Die starke Typisierung bedeutet auch, dass die Sprache vorkompiliert werden kann und dass Variablen keine Werte zugewiesen werden können, die ausserhalb ihres angegebenen Bereichs liegen. Wenn zum Beispiel eine TypeScript-Variable als Zahl deklariert ist, kann man dieser Variable keinen Textwert zuweisen.\nNull Safety In TypeScript gibt es standardmässig keine “Null Safety” im Sinne einer statischen Typüberprüfung auf mögliche Null- oder Undefined-Werte. Das bedeutet, dass Variablen jeden Typ annehmen können, einschliesslich null oder undefined, es sei denn, es wird explizit angegeben, dass sie einen anderen Typ haben sollen. Das kann dazu führen, dass in TypeScript-Code unerwartete Fehler auftreten, wenn versucht wird, auf Eigenschaften oder Methoden von null- oder undefined-Variablen zuzugreifen. Solche Fehler treten normalerweise zur Laufzeit auf und werden nicht vom Compiler erkannt.\nUm das Risiko von Fehlern durch null- oder undefined-Werte zu reduzieren, kann man die Option strictNullChecks in der tsconfig.json-Datei aktivieren.\nTypanmeldungen Typdeklarationen können zu Variablen, Funktionsparametern und Funktionsrückgabetypen hinzugefügt werden. Der Typ folgt jeweils auf einen Doppelpunkt hinter dem Variablennamen:\n1 const num: number = 1; Der Compiler überprüft dann die Typen während des Transpilierens und meldet allfällige Typfehler.\nDie verschiedenen Grundtypen von TypeScript sind hier ersichtlich.\nType Any Der Typ any ist ein spezieller Typ, der es ermöglicht, Variablen, Funktionen und andere Objekte ohne explizite Typisierung zu deklarieren. Wenn eine Variable oder ein Objekt mit any deklariert wird, bedeutet dies, dass der Typ nicht eingeschränkt ist und dass alle Arten von Werten diesem Typ zugewiesen werden können, ohne dass eine Typenüberprüfung durchgeführt wird. Das bedeutet, dass man so die gesamte Typisierung umgehen kann und dann wie bei JavaScript Typfehler erst während der Laufzeit sehen würde.\nBeispiel mit any, welches zu Laufzeitfehler führt:\n1 2 3 4 5 6 function add(a: any, b: any) { return a + b; } const result = add(\"3\", 5); console.log(result); Der Objektorientierte Ansatz Bei der objektorientierten Programmierung handelt es sich um einen Programmierstil / eine Denkweise.\nMan kann sich das so vorstellen, dass alles in der objektorientierten Programmierung durch Objekte abgebildet wird. Jedes “Teil” eines Programmes wird durch ein Objekt beschrieben.\nEin Beispiel:\nIn einer Spielewelt gibt es einen frei herumlaufenden Hund. Dann wäre dieser Hund nichts anderes als ein Objekt.\nNun könnte man sich fragen, wie man diesen Hund wahrnimmt, denn nicht jeder Hund ist gleich. Sie könnten sich in Rasse, Gattung etc. unterscheiden. Ein Objekt kann also verschiedene Eigenschaften besitzen, diese werden auch Attribute genannt. Nun kann sich unser Hund von Anderen unterscheiden, jedoch kann er noch nicht bellen. Deshalb haben Objekte auch Funktionen (Methoden). In unserem Beispiel könnte der Hund z.B. über die Methode “bark()” verfügen, welche es ihm erlaubt, zu bellen.\nIn unserem Beispiel handelt es sich bei dem Hund um eine Klasse. Klassen sind also wie Baupläne für Objekte.\nNun sagen wir, dass es in unserer Spielwelt auch Katzen gibt. An dieser Stelle kommt dann die Vererbung ins Spiel.\nHunde sowie Katzen sind beides Tiere. In der Objektorientierten Programmierung würde man dazu also eine Klasse “Animal” erstellen. Die beiden Klassen “Cat” und “Dog” würden dann die Klasse “Animal” erben. Dies Bedeutet, dass sie die Eigenschaften der Klasse “Animal” übernehmen und durch ihre eigenen Eigenschaften ergänzen.\nDa sich beide Tiere fortbewegen, könnte man also der Klasse “Animal” die Funktion “move()” geben, welche dann von den beiden anderen Klassen geerbt werden würde. Dadurch hat man verhindert, dass sich die Funktion zum bewegen mehrmals im Quellcode befindet.\nKlassen Ein einfaches Beispiel einer Klasse:\n1 2 3 4 5 6 7 8 9 10 11 class Greeter { greeting: string; constructor(message: string) { this.greeting = message; } greet() { return \"Hello, \" + this.greeting; } } let greeter = new Greeter(\"world\"); In diesem Beispiel wird eine neue Klasse “Greeter” deklariert. Die Klasse enthält 3 Member:\nDas Property “greeting” Den Konstruktor Die Methode “greet” Wenn wir in einer Klasse auf ein Member innerhalb der Klasse referenzieren, verwenden wir this..\nAuf der letzten Zeile erstellen wir eine neue Instanz der Klasse Greeter mit new.\nInterfaces Interfaces in TypeScript beschreiben die Struktur von Objekten, ohne tatsächlichen JavaScript-Code zu erzeugen. Bei der Transpilation entfernt TypeScript alle Interfaces, sodass sie in der Laufzeitumgebung nicht mehr existieren. Sie sind also rein für die statische Typisierung gedacht und lassen sich beispielsweise nicht per instanceof prüfen.\nEin einfaches Beispiel ist das folgende:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 interface Person { name: string; alter: number; } ### Vererbung In TypeScript können wir allgemeine objektorientierte Muster verwenden. Eines der grundlegendsten Muster in der klassenbasierten Programmierung ist die Möglichkeit, vorhandene Klassen durch Vererbung zu erweitern, um neue Klassen zu erstellen. ```typescript class Animal { move(distanceInMeters: number = 0) { console.log(`Animal moved ${distanceInMeters}m.`); } } class Dog extends Animal { bark() { console.log(\"Woof!\"); } } const dog = new Dog(); dog.bark(); dog.move(10); dog.bark(); Dieses Beispiel zeigt die grundlegendste Vererbungsfunktion: Klassen erben Eigenschaften und Methoden von Basisklassen (Animal). Dog ist hier eine abgeleitete Klasse, die mit dem Schlüsselwort extends von der Basisklasse Animal abgeleitet wird. Abgeleitete Klassen werden häufig als Unterklassen bezeichnet, und Basisklassen als Superklassen.\nDa Dog die Funktionalität von Animal erweitert, konnten wir eine Instanz von Dog erstellen, die sowohl bark() als auch move() ausführen konnte.\nEin komplexeres Beispiel zur Vertiefung:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Animal { name: string; constructor(theName: string) { this.name = theName; } move(distanceInMeters: number = 0) { console.log(`Animal moved ${distanceInMeters}m.`); } } class Snake extends Animal { constructor(name: string) { super(name); } move(distanceInMeters: number = 5) { console.log(\"Slithering...\"); super.move(distanceInMeters); } } class Horse extends Animal { constructor(name: string) { super(name); } move(distanceInMeters: number = 45) { console.log(\"Galloping...\"); super.move(distanceInMeters); } } let sammy = new Snake(\"Sammy the Python\"); let tom: Animal = new Horse(\"Tom the Palomino\"); sammy.move(); tom.move(35); In diesem Beispiel werden zwei neue Subklassen von Animal erstellt: Horse und Snake.\nEin Unterschied zum vorherigen Beispiel besteht darin, dass jede abgeleitete Klasse, die eine Konstruktorfunktion enthält, super() aufrufen muss, wodurch der Konstruktor der Basisklasse ausgeführt wird. Ausserdem müssen wir super() aufrufen, damit wir im Konstruktorkörper auf name mit this zugreifen können.\nKonsolenausgabe des Beispiels:\n1 2 3 4 Slithering... Sammy the Python moved 5m. Galloping... Tom the Palomino moved 34m. ","categories":"","description":"Modul #F5 - TypeScript - JavaScript mit Typen.\n","excerpt":"Modul #F5 - TypeScript - JavaScript mit Typen.\n","ref":"/de/docs/03_web/05_typescript/01_intro-typescript/","tags":"","title":"Einführung in TypeScript"},{"body":"","categories":"","description":"Entwickungsumgebung aufsetzen für das Arbeiten mit HTML, CSS und JavaScript.\n","excerpt":"Entwickungsumgebung aufsetzen für das Arbeiten mit HTML, CSS und …","ref":"/docs/03_web/01_ide-basic/","tags":"","title":"Frontend IDE Basics"},{"body":"","categories":"","description":"Entwickungsumgebung aufsetzen für das Arbeiten mit HTML, CSS und JavaScript.\n","excerpt":"Entwickungsumgebung aufsetzen für das Arbeiten mit HTML, CSS und …","ref":"/de/docs/03_web/01_ide-basic/","tags":"","title":"Frontend IDE Basics"},{"body":"IDE In den folgenden Kapiteln sind alle Vorkehrungen aufgeführt, die man für das Entwickeln mit HTML und CSS durchführen muss.\nVS Code Die Beispiele in diesem Modul werden anhand der Nutzung von Visual Studio Code erklärt. Visual Studio Code ist ein kostenloser Code-Editor, mit welchem du unkompliziert mit dem Entwickeln beginnen kannst. Du kannst Visual Studio Code verwenden, um in beinahe jeder Programmiersprache zu programmieren, ohne den Editor zu wechseln. Es werden viele Sprachen unterstützt, darunter sind JavaScript, Angular, Vue und viele mehr. https://code.visualstudio.com/\nExtensions Extensions sind, einfach gesagt, eine Möglichkeit, die Entwicklungsumgebung, welche man verwendet, zu erweitern. Es ist möglich, dass bestehende Funktionalitäten der Umgebung verbessert oder ausgearbeitet werden, es ist aber ebenfalls möglich, dass komplett neue Funktionalitäten dazukommen. Um in VS Code eine Extension hinzuzufügen, musst du links auf den Tab “Extensions” klicken, im sich öffnenden Suchfeld nach der gewünschten Extension suchen und diese zu installieren. Je nach Art der Extension musst du VS Code neu starten, damit die Anpassungen übernommen werden.\nFolgende Extensions sind praktisch für die Entwicklung von Webapps mit VS Code (Auf die Extension “Live Server” wird nachfolgend noch genauer eingegangen):\nVS-Code: - Code Spell Checker - ESLint - GitLens - Material Icon Theme - Path Intellisense - Prettier – Code formatter - Auto Rename Tag - Auto Close Tag - Better Comments - Template String Converter - Live Server IntelliJ IntelliJ IDEA ist eine IDE für Softwareentwicklung, die von JetBrains entwickelt wurde. IntelliJ ist eine der beliebtesten IDEs für die Entwicklung von Java-Anwendungen, bietet jedoch ebenfalls Unterstützung für viele andere Programmiersprachen und Technologien wie Kotlin, Scala, Groovy, JavaScript, TypeScript, HTML, CSS, SQL etc.\nIntelliJ lässt sich am besten über die JetBrains Toolbox installieren: https://www.jetbrains.com/lp/toolbox/\nExtensions (Plugins) Folgende Extensions sind praktisch für die Entwicklung von Webapps mit IntelliJ:\nIntelliJ: - Prettier - Rainbow Bracket - Key Promoter X - ESLint (muss mittels npm instlliert werden, Anleitung befindet sich im Kapitel zu den Linter.) - LiveEdit Vim Vim steht für “Vi IMproved” und ist ein erweiterter Texteditor, der auf dem älteren vi-Editor basiert. Vim ist ein beliebter Texteditor unter Entwicklern und Systemadministratoren, der auf verschiedenen Betriebssystemen wie Linux, macOS und Windows verwendet werden kann. Vim zeichnet sich durch seine Effizienz, Flexibilität und Erweiterbarkeit aus.\nFür VS-Code muss man das Plugin Vim und für IntelliJ das Plugin IdeaVim installieren, damit man diesen Editor verwenden kann.\nLive-Server Wozu braucht man den Live-Server? Normalerweise verwendet der Browser das HTTP-Protokoll, um Websites und andere Ressourcen von einem Server zu laden. Beim lokalen Entwickeln greifen Entwickler jedoch häufig direkt über den Browser auf das Dateisystem zu. Es gibt jedoch bestimmte Technologien, wie beispielsweise JavaScript-Module, die Ressourcen nur über HTTP laden können. Aus diesem Grund müssen wir für bestimmte Funktionen auch lokal einen Webserver verwenden, der die Ressourcen über HTTP bereitstellt.\nDie Live-Server-Erweiterung erfüllt genau diese Anforderungen: Sie ermöglicht es, Dateien in einem bestimmten Ordner (dem Projektverzeichnis) auf deiner Festplatte über HTTP verfügbar zu machen. Ein zusätzliches Feature besteht darin, dass deine Seite automatisch aktualisiert wird, sobald du Änderungen vornimmst.\nLive-Server in VS Code Die Live-Server Extension ist eine beliebte Erweiterung für Visual Studio Code, die Entwicklern dabei hilft, Webanwendungen während der Entwicklung automatisch neu zu laden. Sie ermöglicht es, eine lokale Entwicklungsumgebung einzurichten und den Code in Echtzeit zu aktualisieren, ohne die Seite manuell neu laden zu müssen.\nLive-Server erstellt einen einfachen Entwicklungsserver auf dem lokalen Rechner, der die Webanwendung unter einer lokalen Adresse (z.B. “http://localhost:5500”) bereitstellt. Dadurch kann man die Anwendung in einer isolierten Umgebung testen und auf sie zugreifen.\nNeben der Bereitstellung von HTML-, CSS- und JavaScript-Dateien unterstützt Live-Server auch das Laden von statischen Dateien wie Bildern, Schriftarten und anderen Ressourcen. Dadurch kann man die gesamte Webanwendung über den Entwicklungsserver verfügbar machen.\nUm eine Datei (z.B. eine HTML-Datei) via Live Server im Browser zu öffnen, tätige einen Rechtsklick auf die gewünschte Datei und klicke auf “Open with Live Server”. Nun geht die gewünschte Seite im Browser auf und ist im Browser erreichbar via “http://localhost:5500”.\nGanz unten in VS Code siehst du nun einen Button mit der Aufschrift “Port 5500”. Wenn du darauf klickst, beendest du den Live Server wieder. Live-Server in IntelliJ Wenn man IntelliJ als seine IDE wählt, kann man ähnlich wie bei VS Code einen Live Server mittels Extension erhalten. Dazu muss man jedoch die Extension LiveEdit installieren. Nach dem man diese installiert hat, muss man die Extension noch konfigurieren. Dafür musst du in den Einstellungen auf “Build, Execution, Deployment -\u003e Debugger -\u003e Live Edit” navigieren. Dort musst du die folgenden Einstellungen tätigen:\n“Update Node.js application on changes in” Checkbox anwählen und Millisekunden auf 300ms ändern. “Update application in Chrome on changes in” Checkbox anwählen und Millisekunden auf 300ms ändern. “JavaScript, HTML and CSS” auswählen. “Track changes in files compiled to JavaScript, HTML or CSS” Checkbox anwählen. “Restart if hotswap fails” Checkbox anwählen. Diese Einstellungen musst du nun sichern, woraufhin du die Extension verwenden kannst. Dazu muss die Applikation über den Debugger gestartet werden, woraufhin sich ein Chromefenster öffnet. Die nun im Code getätigten Anpassungen werden direkt entsprechend im Browser angezeigt.\n15’ - Einzelarbeit\nInstalliere die IDE, die genannten Extensions, und richte sie entsprechend deiner Präferenz ein. Git Git ist dir bereits bekannt. Git ist ein Versionierungs-Tool für Code.\n5’ - Einzelarbeit\nInstalliere Git. Hierfür gibt es zwei Möglichkeiten: 1. Vielleicht klappt es unter Windows direkt mit diesem Kommandozeilenbefehl: winget install --id Git.Git -e --source winget 2. Ansonsten lade es unter folgendem Link herunter: https://git-scm.com/. Bei der Installation sind keine Anpassungen zwingend. Vielleicht helfen dir in Zukunft die \"Components\" \"Windows Explorer integration - Git Bash Here\" und \"Add a Git Bash Profile to Windows Terminal\". Ansonsten kannst du dich einfach durchklicken. ","categories":"","description":"In diesem Kapitel wird die IDE beschrieben.\n","excerpt":"In diesem Kapitel wird die IDE beschrieben.\n","ref":"/docs/03_web/01_ide-basic/01_ide/","tags":"","title":"IDE"},{"body":"IDE In den folgenden Kapiteln sind alle Vorkehrungen aufgeführt, die man für das Entwickeln mit HTML und CSS durchführen muss.\nVS Code Die Beispiele in diesem Modul werden anhand der Nutzung von Visual Studio Code erklärt. Visual Studio Code ist ein kostenloser Code-Editor, mit welchem du unkompliziert mit dem Entwickeln beginnen kannst. Du kannst Visual Studio Code verwenden, um in beinahe jeder Programmiersprache zu programmieren, ohne den Editor zu wechseln. Es werden viele Sprachen unterstützt, darunter sind JavaScript, Angular, Vue und viele mehr. https://code.visualstudio.com/\nExtensions Extensions sind, einfach gesagt, eine Möglichkeit, die Entwicklungsumgebung, welche man verwendet, zu erweitern. Es ist möglich, dass bestehende Funktionalitäten der Umgebung verbessert oder ausgearbeitet werden, es ist aber ebenfalls möglich, dass komplett neue Funktionalitäten dazukommen. Um in VS Code eine Extension hinzuzufügen, musst du links auf den Tab “Extensions” klicken, im sich öffnenden Suchfeld nach der gewünschten Extension suchen und diese zu installieren. Je nach Art der Extension musst du VS Code neu starten, damit die Anpassungen übernommen werden.\nFolgende Extensions sind praktisch für die Entwicklung von Webapps mit VS Code (Auf die Extension “Live Server” wird nachfolgend noch genauer eingegangen):\nVS-Code: - Code Spell Checker - ESLint - GitLens - Material Icon Theme - Path Intellisense - Prettier – Code formatter - Auto Rename Tag - Auto Close Tag - Better Comments - Template String Converter - Live Server IntelliJ IntelliJ IDEA ist eine IDE für Softwareentwicklung, die von JetBrains entwickelt wurde. IntelliJ ist eine der beliebtesten IDEs für die Entwicklung von Java-Anwendungen, bietet jedoch ebenfalls Unterstützung für viele andere Programmiersprachen und Technologien wie Kotlin, Scala, Groovy, JavaScript, TypeScript, HTML, CSS, SQL etc.\nIntelliJ lässt sich am besten über die JetBrains Toolbox installieren: https://www.jetbrains.com/lp/toolbox/\nExtensions (Plugins) Folgende Extensions sind praktisch für die Entwicklung von Webapps mit IntelliJ:\nIntelliJ: - Prettier - Rainbow Bracket - Key Promoter X - ESLint (muss mittels npm instlliert werden, Anleitung befindet sich im Kapitel zu den Linter.) - LiveEdit Vim Vim steht für “Vi IMproved” und ist ein erweiterter Texteditor, der auf dem älteren vi-Editor basiert. Vim ist ein beliebter Texteditor unter Entwicklern und Systemadministratoren, der auf verschiedenen Betriebssystemen wie Linux, macOS und Windows verwendet werden kann. Vim zeichnet sich durch seine Effizienz, Flexibilität und Erweiterbarkeit aus.\nFür VS-Code muss man das Plugin Vim und für IntelliJ das Plugin IdeaVim installieren, damit man diesen Editor verwenden kann.\nLive-Server Wozu braucht man den Live-Server? Normalerweise verwendet der Browser das HTTP-Protokoll, um Websites und andere Ressourcen von einem Server zu laden. Beim lokalen Entwickeln greifen Entwickler jedoch häufig direkt über den Browser auf das Dateisystem zu. Es gibt jedoch bestimmte Technologien, wie beispielsweise JavaScript-Module, die Ressourcen nur über HTTP laden können. Aus diesem Grund müssen wir für bestimmte Funktionen auch lokal einen Webserver verwenden, der die Ressourcen über HTTP bereitstellt.\nDie Live-Server-Erweiterung erfüllt genau diese Anforderungen: Sie ermöglicht es, Dateien in einem bestimmten Ordner (dem Projektverzeichnis) auf deiner Festplatte über HTTP verfügbar zu machen. Ein zusätzliches Feature besteht darin, dass deine Seite automatisch aktualisiert wird, sobald du Änderungen vornimmst.\nLive-Server in VS Code Die Live-Server Extension ist eine beliebte Erweiterung für Visual Studio Code, die Entwicklern dabei hilft, Webanwendungen während der Entwicklung automatisch neu zu laden. Sie ermöglicht es, eine lokale Entwicklungsumgebung einzurichten und den Code in Echtzeit zu aktualisieren, ohne die Seite manuell neu laden zu müssen.\nLive-Server erstellt einen einfachen Entwicklungsserver auf dem lokalen Rechner, der die Webanwendung unter einer lokalen Adresse (z.B. “http://localhost:5500”) bereitstellt. Dadurch kann man die Anwendung in einer isolierten Umgebung testen und auf sie zugreifen.\nNeben der Bereitstellung von HTML-, CSS- und JavaScript-Dateien unterstützt Live-Server auch das Laden von statischen Dateien wie Bildern, Schriftarten und anderen Ressourcen. Dadurch kann man die gesamte Webanwendung über den Entwicklungsserver verfügbar machen.\nUm eine Datei (z.B. eine HTML-Datei) via Live Server im Browser zu öffnen, tätige einen Rechtsklick auf die gewünschte Datei und klicke auf “Open with Live Server”. Nun geht die gewünschte Seite im Browser auf und ist im Browser erreichbar via “http://localhost:5500”.\nGanz unten in VS Code siehst du nun einen Button mit der Aufschrift “Port 5500”. Wenn du darauf klickst, beendest du den Live Server wieder. Live-Server in IntelliJ Wenn man IntelliJ als seine IDE wählt, kann man ähnlich wie bei VS Code einen Live Server mittels Extension erhalten. Dazu muss man jedoch die Extension LiveEdit installieren. Nach dem man diese installiert hat, muss man die Extension noch konfigurieren. Dafür musst du in den Einstellungen auf “Build, Execution, Deployment -\u003e Debugger -\u003e Live Edit” navigieren. Dort musst du die folgenden Einstellungen tätigen:\n“Update Node.js application on changes in” Checkbox anwählen und Millisekunden auf 300ms ändern. “Update application in Chrome on changes in” Checkbox anwählen und Millisekunden auf 300ms ändern. “JavaScript, HTML and CSS” auswählen. “Track changes in files compiled to JavaScript, HTML or CSS” Checkbox anwählen. “Restart if hotswap fails” Checkbox anwählen. Diese Einstellungen musst du nun sichern, woraufhin du die Extension verwenden kannst. Dazu muss die Applikation über den Debugger gestartet werden, woraufhin sich ein Chromefenster öffnet. Die nun im Code getätigten Anpassungen werden direkt entsprechend im Browser angezeigt.\n15’ - Einzelarbeit\nInstalliere die IDE, die genannten Extensions, und richte sie entsprechend deiner Präferenz ein. Git Git ist dir bereits bekannt. Git ist ein Versionierungs-Tool für Code.\n5’ - Einzelarbeit\nInstalliere Git. Hierfür gibt es zwei Möglichkeiten: 1. Vielleicht klappt es unter Windows direkt mit diesem Kommandozeilenbefehl: winget install --id Git.Git -e --source winget 2. Ansonsten lade es unter folgendem Link herunter: https://git-scm.com/. Bei der Installation sind keine Anpassungen zwingend. Vielleicht helfen dir in Zukunft die \"Components\" \"Windows Explorer integration - Git Bash Here\" und \"Add a Git Bash Profile to Windows Terminal\". Ansonsten kannst du dich einfach durchklicken. ","categories":"","description":"In diesem Kapitel wird die IDE beschrieben.\n","excerpt":"In diesem Kapitel wird die IDE beschrieben.\n","ref":"/de/docs/03_web/01_ide-basic/01_ide/","tags":"","title":"IDE"},{"body":"Ziele Du weisst, was ein Frontend ist. Du weisst, was Angular ist, und kennst entsprechende Alternativen dazu. Was ist das Frontend? Das Wort Frontend gibt bereits einen Hinweis, worum es sich handelt. Ein Frontend ist der Teil einer Applikation, welchen der Nutzer sieht. Bei einer Webapplikation ist es der Teil, der dem Besucher im Browser angezeigt wird: die Benutzeroberfläche.\nWas ist ein Framework? Ein Framework ist eine Art “Grundgerüst” für die Entwicklung von Software, welche es dem Entwickler ermöglicht, schnell und effizient Applikationen zu entwickeln, ohne von Grund auf beginnen zu müssen.\nJS Frameworks JavaScript-Frameworks sind also da, um die Arbeit mit JavaScript einfacher und reibungsloser zu machen.\nDurch verschiedenste Web-Frameworks wird die Gestaltung von Websites sehr flexibel, daher bevorzugen es die meisten Entwickler, ein solches zu verwenden.\nDie bekanntesten JS-Frameworks:\nAngular Eines der leistungsstärksten und effizientesten Open-Source-JavaScript-Frameworks ist Angular. Google betreibt dieses Framework, welches für die Entwicklung einer Single Page Application (SPA) verwendet wird. Eine Single-Page-Application ist eine Anwendung, welche mit dem Nutzer interagiert, indem die aktuelle Seite dynamisch mit neuen Daten gerendert wird. Das heisst, es wird für eine neue Ansicht nicht jedes mal eine neue Page erstellt, sondern wird die bestehende Seite an die neuen Daten angepasst.\nReact Das von Facebook erstellte Framework React hat innerhalb kurzer Zeit an Popularität gewonnen. Es wird verwendet, um die dynamische Benutzeroberfläche von Webseiten mit hohem eingehenden Datenverkehr zu entwickeln und zu betreiben.\nVue.js Obwohl dieses JavaScript-Framework erst im Jahr 2016 entwickelt wurde, hat es bereits seinen Weg auf den Markt gefunden und sich durch verschiedene Funktionen bewährt. Es ist sehr zuverlässig bei der Entwicklung von Cross-Plattform.\n","categories":"","description":"Modul #F6 - Angular - Was sind JavaScript Frameworks?\n","excerpt":"Modul #F6 - Angular - Was sind JavaScript Frameworks?\n","ref":"/docs/03_web/06_angular/01_1_javascript-frameworks/","tags":"","title":"Javascript Frameworks"},{"body":"Ziele Du weisst, was ein Frontend ist. Du weisst, was Angular ist, und kennst entsprechende Alternativen dazu. Was ist das Frontend? Das Wort Frontend gibt bereits einen Hinweis, worum es sich handelt. Ein Frontend ist der Teil einer Applikation, welchen der Nutzer sieht. Bei einer Webapplikation ist es der Teil, der dem Besucher im Browser angezeigt wird: die Benutzeroberfläche.\nWas ist ein Framework? Ein Framework ist eine Art “Grundgerüst” für die Entwicklung von Software, welche es dem Entwickler ermöglicht, schnell und effizient Applikationen zu entwickeln, ohne von Grund auf beginnen zu müssen.\nJS Frameworks JavaScript-Frameworks sind also da, um die Arbeit mit JavaScript einfacher und reibungsloser zu machen.\nDurch verschiedenste Web-Frameworks wird die Gestaltung von Websites sehr flexibel, daher bevorzugen es die meisten Entwickler, ein solches zu verwenden.\nDie bekanntesten JS-Frameworks:\nAngular Eines der leistungsstärksten und effizientesten Open-Source-JavaScript-Frameworks ist Angular. Google betreibt dieses Framework, welches für die Entwicklung einer Single Page Application (SPA) verwendet wird. Eine Single-Page-Application ist eine Anwendung, welche mit dem Nutzer interagiert, indem die aktuelle Seite dynamisch mit neuen Daten gerendert wird. Das heisst, es wird für eine neue Ansicht nicht jedes mal eine neue Page erstellt, sondern wird die bestehende Seite an die neuen Daten angepasst.\nReact Das von Facebook erstellte Framework React hat innerhalb kurzer Zeit an Popularität gewonnen. Es wird verwendet, um die dynamische Benutzeroberfläche von Webseiten mit hohem eingehenden Datenverkehr zu entwickeln und zu betreiben.\nVue.js Obwohl dieses JavaScript-Framework erst im Jahr 2016 entwickelt wurde, hat es bereits seinen Weg auf den Markt gefunden und sich durch verschiedene Funktionen bewährt. Es ist sehr zuverlässig bei der Entwicklung von Cross-Plattform.\n","categories":"","description":"Modul #F6 - Angular - Was sind JavaScript Frameworks?\n","excerpt":"Modul #F6 - Angular - Was sind JavaScript Frameworks?\n","ref":"/de/docs/03_web/06_angular/01_1_javascript-frameworks/","tags":"","title":"Javascript Frameworks"},{"body":"Aufgaben In diesen Aufgaben wirst du eine Applikation erstellen, die dir Informationen über verschiedene Velos anzeigt. Erstelle die Applikation anhand des bereitgestellten Codes und den dazugehörigen Informationen.\nAufgabe 1 Folgender Code ist gegeben: Datei ../interfaces.ts:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 export interface Bicycle { name: string; url: string; } export interface BicycleImage { displayLink: string; fileFormat: string; htmlSnippet: string; htmlTitle: string; image: { byteSize: number; contextLink: string; height: number; thumbnailHeight: number; thumbnailLink: string; thumbnailWidth: number; width: number; }; kind: string; link: string; mime: string; snippet: string; title: string; } export interface GoogleCustomSearchResponse { kind: string; url: { type: string; template: string; }; queries: { request: { count: number; cx: string; inputEncoding: string; outputEncoding: string; safe: string; searchTerms: string; searchType: string; startIndex: number; title: string; totalResults: string; }[]; nextPage: { count: number; cx: string; inputEncoding: string; outputEncoding: string; safe: string; searchTerms: string; searchType: string; startIndex: number; title: string; totalResults: string; }[]; }; searchInformation: { searchTime: number; formattedSearchTime: string; totalResults: string; formattedTotalResults: string; }; items: BicycleImage[]; context?: { title: string; }; } Datei bicycle.component.ts:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 import { Component, OnInit } from \"@angular/core\"; import { HttpClient } from \"@angular/common/http\"; import { Bicycle, BicycleImage, GoogleCustomSearchResponse, } from \"../interfaces\"; @Component({ selector: \"app-bicycle\", templateUrl: \"./bicycle.component.html\", styleUrls: [\"./bicycle.component.scss\"], }) export class BicycleComponent implements OnInit { public bicycle: Bicycle = { name: \"\", url: \"\" }; favoriteBicycle: BicycleImage[] = []; constructor(private httpClient: HttpClient) {} ngOnInit(): void { this.bicycle.name = \"Specialized Diverge Pro Carbon\"; this.bicycle.url = \"https://assets.specialized.com/i/specialized/96220-10_DIVERGE-PRO-CARBON-ETAP-REDWD-SMK-CHRM_HERO?bg=rgb(241,241,241)\u0026w=2500\u0026h=1406\u0026fmt=auto\"; } public displayBicycleName() { alert(this.bicycle.name); } public getFavoriteBicycleImage() { const url = \"https://www.googleapis.com/customsearch/v1?key=AIzaSyDNGfS6NUdgwXOwKu9xlZPJFm84ylG6J4g\u0026cx=005124428384360536924:rstfldysumw\u0026q=\" + this.bicycle.name + \"\u0026searchType=image\u0026safe=high\"; this.httpClient .get\u003cGoogleCustomSearchResponse\u003e(url) .subscribe((response: GoogleCustomSearchResponse) =\u003e { for (let i = 0; i \u003c 4; i++) { let item: BicycleImage = response.items[i]; item.image.height = (200 / item.image.width) * item.image.height; item.image.width = 200; this.favoriteBicycle.push(item); } }); } } Folgendes muss angezeigt werden, wenn die Seite geladen wurde:\n“Wie heisst mein Fahrrad?” ist mit der Funktion “displayBicycleName()” verknüpft. “Mein Liebslingsfahrrad suchen” ist mit der Funktion “getFavoriteBicycleImage()” verknüpft. Für die Anzeige der Lieblingsfahrräder muss ein *ngFor gebraucht werden. Tipp: Die Weite und Höhe der Bilder kann direkt mit einem Propertybinding gemacht werden. Folgendes wird nach dem Klick auf “Wie heisst mein Fahrrad?” angezeigt:\nFolgende Seite wird nach dem Klick auf “Mein Lieblingsfahrrad suchen” angezeigt:\nAufgabe 1.1 Passe den bestehenden Code aus Aufgabe 1 so an, dass das Inputfeld ein FormControl ist. Zudem soll neu dieses Inputfeld als Suche funktionieren, das bedeutet das man der Funktion der Wert des Inputs übergeben kann. So soll dann immer die Bilder zum Wert angezeigt werden und auch der Text “Mein Lieblingsfahrrad: \" sollte immer den Wert es Inputs anzeigen.\nAufgabe 2 Diese Aufgabe wird ein nun grösseres Projekt, der Sinn hinter diesem ist das Verwalten der Fahrräder mit einem objekt-orientierten Ansatz. Zusätzlich soll die Trennung von Modell-Klassen, Services und Components detaillierter betrachtet werden. Zudem besitzt man nach Abschluss der Aufgabe ein richtiges und praxisorientiertem Beispiel für ein Frontend.\nErstelle ein neues Angular Projekt.\nIm neu erstellten Projekt wollen wir Daten für folgende (Datenbank-)Entitäten mit einem objekt-orientierten Ansatz abbilden: Folgende Anforderungen sind gegeben:\nBehalte die Ordnerstruktur korrekt (Ordner für die Components, Ordner für die Services, etc.). Erstelle für jede Entität (ohne die Zwischentabelle Bicycle_Type) des Models eine geeignete Modell-Klasse. Erstelle für jede Modell-Klasse einen Service. Erstelle bei jedem Service Beispieldaten. Der BicycleService enthält folgende Funktionen: getBicycle(id: number): Gibt ein bestimmtes Bicycle über die ID zurück. getAllBicycle(): Gibt alle Bicycles zurück. Ein Bicycle hat stellvertretend für den Typ und die Marke nur die dazugehörige id. getFullBicycle(id: number): Gibt ein vollständiges Bicycle Objekt inklusive aller dazugehörigen Attribute zurück. Ein FullBicycle hat den effektiven Wert des Typs und der Marke. Der BrandService enthält folgende Funktionen: getBrand(id: number) und getBrandName(id: number). Der TypeService enthält folgende Funktionen: getTypes(ids: number[]) und getTypesName(ids: number[]). Sollte der Benutzer bei den Services versuchen etwas zu getten was es nicht gibt sol einen Fehler geworfen werden mit throw Error. Erstelle einen globalen ErrorHandler um die möglichen Fehler der Services abzufangen und gib eine Mitteilung damit der Benutzer weiss, das ein Fehler passierte (Subject verwenden). Erstelle einen neuen Component um die Daten alles Fahrräder anzuzeigen. Aufgabe 2.1 Erweitern wir die Anwendung nun ein wenig.\nErstelle einen weiteren neuen Component, welcher ein Eingabefeld, mit ReactiveForms, besitzt um nach einem Fahrrad zu suchen und dieses anzuzeigen. Erstelle eine Navigation für zwischen den Components hin und her zu wechseln. Erstelle eine Route für die Components. Der Component welcher alle Fahrräder anzeigt ist zudem die Defaultroute. Erstelle einen Guard welcher dich nur zu der Suche-Seite lässt, wenn du diese aktiviert hast mittels Button. Erstelle auch ein Routing auf den neu zu Erstellenden Component, welche mithilfe eines Parameters alle Fahrräder (der name, wert, marke und typen) der jeweiligen Marke anzeigt. Zudem soll die Marke als Titel der Seite stehen. Verlinke die brand_id, als routerLink auf der Seite aller Fahrräder um auf den neuen Component zu gelangen. Aufgabe 2.2 In den vorherigen Aufgaben hast du eine Grundstruktur geschaffen für die Anzeige. Wenn man nach einem Fahrrad sucht, sollte nun das Ergebnis mit einer Pipe angepasst werden.\nErstelle nun eine Pipe welche die Spalte value im Format 1'720.00 CHF anzeigt. Der Währungstyp wird mit einem Parameter weitergegeben. Sofern nichts angegeben wird, wähle Standardmässig CHF. Geh davon aus das in der Spalte value auch Zahlen wie 1287.87 oder 5421.21 gespeichert sind. Runde diese je nachdem auf oder ab. Auch das Hochzeichen (') soll immer nach 3 Stellen erscheinen. Erstelle eine weitere Pipe, welche den Markennamen nur mit Grossbuchstaben anzeigt und hinter den Markennamen ein Copyrightzeichen (©) setzt. Wichtig: Wende die Pipe im Template an und nicht im Typescript.\nAufgabe 2.3 Um die Anwendung nun ein bisschen schöner darzustellen, brauchen wir nun Angular Material. Hier kannst du selbst auswählen welche Components du verwenden möchtest. Du musst jedoch mindestens 5 verschiedene Components in deiner Anwendung verwendet haben.\n","categories":"","description":"Aufgaben zu Angular.\n","excerpt":"Aufgaben zu Angular.\n","ref":"/labs/03_web/04_angular/01_angular/","tags":"","title":"Labs zu Angular"},{"body":"Aufgaben In diesen Aufgaben wirst du eine Applikation erstellen, die dir Informationen über verschiedene Velos anzeigt. Erstelle die Applikation anhand des bereitgestellten Codes und den dazugehörigen Informationen.\nAufgabe 1 Folgender Code ist gegeben: Datei ../interfaces.ts:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 export interface Bicycle { name: string; url: string; } export interface BicycleImage { displayLink: string; fileFormat: string; htmlSnippet: string; htmlTitle: string; image: { byteSize: number; contextLink: string; height: number; thumbnailHeight: number; thumbnailLink: string; thumbnailWidth: number; width: number; }; kind: string; link: string; mime: string; snippet: string; title: string; } export interface GoogleCustomSearchResponse { kind: string; url: { type: string; template: string; }; queries: { request: { count: number; cx: string; inputEncoding: string; outputEncoding: string; safe: string; searchTerms: string; searchType: string; startIndex: number; title: string; totalResults: string; }[]; nextPage: { count: number; cx: string; inputEncoding: string; outputEncoding: string; safe: string; searchTerms: string; searchType: string; startIndex: number; title: string; totalResults: string; }[]; }; searchInformation: { searchTime: number; formattedSearchTime: string; totalResults: string; formattedTotalResults: string; }; items: BicycleImage[]; context?: { title: string; }; } Datei bicycle.component.ts:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 import { Component, OnInit } from \"@angular/core\"; import { HttpClient } from \"@angular/common/http\"; import { Bicycle, BicycleImage, GoogleCustomSearchResponse, } from \"../interfaces\"; @Component({ selector: \"app-bicycle\", templateUrl: \"./bicycle.component.html\", styleUrls: [\"./bicycle.component.scss\"], }) export class BicycleComponent implements OnInit { public bicycle: Bicycle = { name: \"\", url: \"\" }; favoriteBicycle: BicycleImage[] = []; constructor(private httpClient: HttpClient) {} ngOnInit(): void { this.bicycle.name = \"Specialized Diverge Pro Carbon\"; this.bicycle.url = \"https://assets.specialized.com/i/specialized/96220-10_DIVERGE-PRO-CARBON-ETAP-REDWD-SMK-CHRM_HERO?bg=rgb(241,241,241)\u0026w=2500\u0026h=1406\u0026fmt=auto\"; } public displayBicycleName() { alert(this.bicycle.name); } public getFavoriteBicycleImage() { const url = \"https://www.googleapis.com/customsearch/v1?key=AIzaSyDNGfS6NUdgwXOwKu9xlZPJFm84ylG6J4g\u0026cx=005124428384360536924:rstfldysumw\u0026q=\" + this.bicycle.name + \"\u0026searchType=image\u0026safe=high\"; this.httpClient .get\u003cGoogleCustomSearchResponse\u003e(url) .subscribe((response: GoogleCustomSearchResponse) =\u003e { for (let i = 0; i \u003c 4; i++) { let item: BicycleImage = response.items[i]; item.image.height = (200 / item.image.width) * item.image.height; item.image.width = 200; this.favoriteBicycle.push(item); } }); } } Folgendes muss angezeigt werden, wenn die Seite geladen wurde:\n“Wie heisst mein Fahrrad?” ist mit der Funktion “displayBicycleName()” verknüpft. “Mein Liebslingsfahrrad suchen” ist mit der Funktion “getFavoriteBicycleImage()” verknüpft. Für die Anzeige der Lieblingsfahrräder muss ein *ngFor gebraucht werden. Tipp: Die Weite und Höhe der Bilder kann direkt mit einem Propertybinding gemacht werden. Folgendes wird nach dem Klick auf “Wie heisst mein Fahrrad?” angezeigt:\nFolgende Seite wird nach dem Klick auf “Mein Lieblingsfahrrad suchen” angezeigt:\nAufgabe 1.1 Passe den bestehenden Code aus Aufgabe 1 so an, dass das Inputfeld ein FormControl ist. Zudem soll neu dieses Inputfeld als Suche funktionieren, das bedeutet das man der Funktion der Wert des Inputs übergeben kann. So soll dann immer die Bilder zum Wert angezeigt werden und auch der Text “Mein Lieblingsfahrrad: \" sollte immer den Wert es Inputs anzeigen.\nAufgabe 2 Diese Aufgabe wird ein nun grösseres Projekt, der Sinn hinter diesem ist das Verwalten der Fahrräder mit einem objekt-orientierten Ansatz. Zusätzlich soll die Trennung von Modell-Klassen, Services und Components detaillierter betrachtet werden. Zudem besitzt man nach Abschluss der Aufgabe ein richtiges und praxisorientiertem Beispiel für ein Frontend.\nErstelle ein neues Angular Projekt.\nIm neu erstellten Projekt wollen wir Daten für folgende (Datenbank-)Entitäten mit einem objekt-orientierten Ansatz abbilden: Folgende Anforderungen sind gegeben:\nBehalte die Ordnerstruktur korrekt (Ordner für die Components, Ordner für die Services, etc.). Erstelle für jede Entität (ohne die Zwischentabelle Bicycle_Type) des Models eine geeignete Modell-Klasse. Erstelle für jede Modell-Klasse einen Service. Erstelle bei jedem Service Beispieldaten. Der BicycleService enthält folgende Funktionen: getBicycle(id: number): Gibt ein bestimmtes Bicycle über die ID zurück. getAllBicycle(): Gibt alle Bicycles zurück. Ein Bicycle hat stellvertretend für den Typ und die Marke nur die dazugehörige id. getFullBicycle(id: number): Gibt ein vollständiges Bicycle Objekt inklusive aller dazugehörigen Attribute zurück. Ein FullBicycle hat den effektiven Wert des Typs und der Marke. Der BrandService enthält folgende Funktionen: getBrand(id: number) und getBrandName(id: number). Der TypeService enthält folgende Funktionen: getTypes(ids: number[]) und getTypesName(ids: number[]). Sollte der Benutzer bei den Services versuchen etwas zu getten was es nicht gibt sol einen Fehler geworfen werden mit throw Error. Erstelle einen globalen ErrorHandler um die möglichen Fehler der Services abzufangen und gib eine Mitteilung damit der Benutzer weiss, das ein Fehler passierte (Subject verwenden). Erstelle einen neuen Component um die Daten alles Fahrräder anzuzeigen. Aufgabe 2.1 Erweitern wir die Anwendung nun ein wenig.\nErstelle einen weiteren neuen Component, welcher ein Eingabefeld, mit ReactiveForms, besitzt um nach einem Fahrrad zu suchen und dieses anzuzeigen. Erstelle eine Navigation für zwischen den Components hin und her zu wechseln. Erstelle eine Route für die Components. Der Component welcher alle Fahrräder anzeigt ist zudem die Defaultroute. Erstelle einen Guard welcher dich nur zu der Suche-Seite lässt, wenn du diese aktiviert hast mittels Button. Erstelle auch ein Routing auf den neu zu Erstellenden Component, welche mithilfe eines Parameters alle Fahrräder (der name, wert, marke und typen) der jeweiligen Marke anzeigt. Zudem soll die Marke als Titel der Seite stehen. Verlinke die brand_id, als routerLink auf der Seite aller Fahrräder um auf den neuen Component zu gelangen. Aufgabe 2.2 In den vorherigen Aufgaben hast du eine Grundstruktur geschaffen für die Anzeige. Wenn man nach einem Fahrrad sucht, sollte nun das Ergebnis mit einer Pipe angepasst werden.\nErstelle nun eine Pipe welche die Spalte value im Format 1'720.00 CHF anzeigt. Der Währungstyp wird mit einem Parameter weitergegeben. Sofern nichts angegeben wird, wähle Standardmässig CHF. Geh davon aus das in der Spalte value auch Zahlen wie 1287.87 oder 5421.21 gespeichert sind. Runde diese je nachdem auf oder ab. Auch das Hochzeichen (') soll immer nach 3 Stellen erscheinen. Erstelle eine weitere Pipe, welche den Markennamen nur mit Grossbuchstaben anzeigt und hinter den Markennamen ein Copyrightzeichen (©) setzt. Wichtig: Wende die Pipe im Template an und nicht im Typescript.\nAufgabe 2.3 Um die Anwendung nun ein bisschen schöner darzustellen, brauchen wir nun Angular Material. Hier kannst du selbst auswählen welche Components du verwenden möchtest. Du musst jedoch mindestens 5 verschiedene Components in deiner Anwendung verwendet haben.\n","categories":"","description":"Aufgaben zu Angular.\n","excerpt":"Aufgaben zu Angular.\n","ref":"/de/labs/03_web/04_angular/01_angular/","tags":"","title":"Labs zu Angular"},{"body":"Aufgaben Aufgabe 1 Erstelle eine neue TypeScript-Projektstruktur und richte eine tsconfig.json-Datei ein, um den TypeScript-Compiler für das Projekt zu konfigurieren.\nErstelle ein neues Verzeichnis für dein TypeScript-Projekt. Navigiere in das Verzeichnis und Initialisiere das Projekt mit den Node Befehlen. Diese können hier nachgelesen werden. InstalliereTypeScript. Erstelle eine tsconfig.json-Datei im Stammverzeichnis des Projekts. Und richte diese anhand der folgenden Informationen korrekt ein: ECMAScript-Version = es6 Modulsystem = commonjs Ausgabeverzeichnis = dist Typen-Check-Modus = true Erstelle im Projektverzeichnis ein Unterverzeichnis namens src. Erstelle eine TypeScript-Datei mit dem Namen index.ts im Verzeichnis src und schreibe darin eine Funktion, welche einen Parameter entgegennimmt und diesen ausgibt (Typisiere zuerst den Parameter nicht und prüfe, ob die tsconfig-Datei funktioniert. Wenn die tsconfig-Datei korrekt ist, wird die IDE folgendes anzeigen: Parameter '' implicitly has an 'any' type.ts). Rufe danach in diesem File die Funktion mit dem Parameter HelloWorld! auf. Transpiliere die TypeScript-Datei. Führe die JS-Datei aus. In der Konsole solltest du HelloWorld! sehen.\nAufgabe 2 - Einzelarbeit\nLade die Datei herunter und fülle wo nötig Quellcode ein. Die Person soll sich folgendermassen vorstellen:\n1 Hallo, mein Name ist [Name]. Die Grundstruktur, sowie die letzten 2 Codezeilen dürfen nicht verändert werden.\nAufgabe 2.1 - Einzelarbeit\nIn dieser Übung wollen wir die Vererbung in einem Fallbeispiel anwenden. Wir erweitern in dieser Aufgabe den Quellcode von Übung 2. Erstelle dazu am Besten gleich eine neue Datei und kopiere den Quellcode von Aufgabe 2. Lösche die letzten 2 Zeilen, sodass nur noch die Klasse “Person” übrig ist. Erstelle anschliessend die Klasse Friend, welche die Klasse Person erbt. Diese Klasse soll die Methode timeKnown(), sowie introduceSelf() der Parent-Klasse zur Verfügung stellen. Die Methode timeKnown() soll folgendes ausgeben können: “Wir sind Freunde seit [AnzahlJahre] Jahren” Achte also darauf, welche zusätzlichen Eigenschaften Friend besitzen muss. Erstelle am Schluss (wie bei Übung 2) eine neue Instanz von Friend\" Verwende als Parameter “Peter” und “5”. Führe dann introduceSelf() und timeKnown() aus.\nIn der Konsole sollte Dir nun folgendes angezeigt werden.\nHallo, mein Name ist Peter\nWir sind Freunde seit 5 Jahren\nAufgabe 3 - Einzelarbeit\nLade diese Datei herunter. In dieser Aufgabe wollen wir Benutzereingabe in der Konsole verarbeiten. Dazu verwenden wir in diesem Beispiel readline(https://nodejs.org/api/readline.html) von NodeJS. Wir wollen nun ein kleines Programm schreiben, welches wie folgt aussieht.\n1 2 3 4 Wie ist dein name? Hansli hallo Hansli War diese Aufgabe lehrreich für dich= [j / n]j Super! 1 2 3 4 Wie ist dein name? Hansli hallo Hansli War diese Aufgabe lehrreich für dich= [j / n]n Schade! :( Zuerst wird der Anwender nach seinem Namen gefragt. Danach wird er begrüsst. Und anschliessend wird gefragt ob diese Aufgabe lehrreich für ihn war.\nFülle in der Aufgabendatei den benötigten Code an den entsprechenden Stellen ein.\n- Info zu readline.\nUm readline benutzen zu können, musst du erst den entsprechenden npm-Befehl ausführen. Achte darauf, dass du den Befehl im selben Verzeichnis ausführst, indem sich die .ts-Datei befindet!\nAufgabe 4 Implementiere eine Funktion, welche den Durchschnitt eines Numberarrays berechnet. Die Funktion sollte nur Numberarrays akzeptieren und eine einzelne Zahl zurückgeben. Wenn das Array jedoch leer ist sollte NaN (Not a Number) zurückgegeben werden.\nAufgabe 5 Implementiere eine User Klasse mit den Properties name und email. Die Klasse besitzt zwei Funktionen, eine um die email zu validieren (mit dem Format “example@example.com”) und die andere um einen Begrüssungsnachricht zu erhalten in welcher der Name und die Email genannt wird.\nAufgabe 6 Implementiere eine ShoppingCart Klasse, welche den ShoppingCart eines Onlineshops repräsentieren soll. Die Klasse sollte Funktionen für das hinzufügen von Produkten, dem Errechnen des gesamten Preises und für das Anzeigen der sich im ShoppingCart befindenden Produkten haben. Ein Produkt sollte einen name und price haben.\n","categories":"","description":"Einfache Aufgaben zu den Basics von TypeScript.\n","excerpt":"Einfache Aufgaben zu den Basics von TypeScript.\n","ref":"/labs/03_web/03_typescript/01_typescript/","tags":"","title":"Labs zu den TypeScript-Basics"},{"body":"Aufgaben Aufgabe 1 Erstelle eine neue TypeScript-Projektstruktur und richte eine tsconfig.json-Datei ein, um den TypeScript-Compiler für das Projekt zu konfigurieren.\nErstelle ein neues Verzeichnis für dein TypeScript-Projekt. Navigiere in das Verzeichnis und Initialisiere das Projekt mit den Node Befehlen. Diese können hier nachgelesen werden. InstalliereTypeScript. Erstelle eine tsconfig.json-Datei im Stammverzeichnis des Projekts. Und richte diese anhand der folgenden Informationen korrekt ein: ECMAScript-Version = es6 Modulsystem = commonjs Ausgabeverzeichnis = dist Typen-Check-Modus = true Erstelle im Projektverzeichnis ein Unterverzeichnis namens src. Erstelle eine TypeScript-Datei mit dem Namen index.ts im Verzeichnis src und schreibe darin eine Funktion, welche einen Parameter entgegennimmt und diesen ausgibt (Typisiere zuerst den Parameter nicht und prüfe, ob die tsconfig-Datei funktioniert. Wenn die tsconfig-Datei korrekt ist, wird die IDE folgendes anzeigen: Parameter '' implicitly has an 'any' type.ts). Rufe danach in diesem File die Funktion mit dem Parameter HelloWorld! auf. Transpiliere die TypeScript-Datei. Führe die JS-Datei aus. In der Konsole solltest du HelloWorld! sehen.\nAufgabe 2 - Einzelarbeit\nLade die Datei herunter und fülle wo nötig Quellcode ein. Die Person soll sich folgendermassen vorstellen:\n1 Hallo, mein Name ist [Name]. Die Grundstruktur, sowie die letzten 2 Codezeilen dürfen nicht verändert werden.\nAufgabe 2.1 - Einzelarbeit\nIn dieser Übung wollen wir die Vererbung in einem Fallbeispiel anwenden. Wir erweitern in dieser Aufgabe den Quellcode von Übung 2. Erstelle dazu am Besten gleich eine neue Datei und kopiere den Quellcode von Aufgabe 2. Lösche die letzten 2 Zeilen, sodass nur noch die Klasse “Person” übrig ist. Erstelle anschliessend die Klasse Friend, welche die Klasse Person erbt. Diese Klasse soll die Methode timeKnown(), sowie introduceSelf() der Parent-Klasse zur Verfügung stellen. Die Methode timeKnown() soll folgendes ausgeben können: “Wir sind Freunde seit [AnzahlJahre] Jahren” Achte also darauf, welche zusätzlichen Eigenschaften Friend besitzen muss. Erstelle am Schluss (wie bei Übung 2) eine neue Instanz von Friend\" Verwende als Parameter “Peter” und “5”. Führe dann introduceSelf() und timeKnown() aus.\nIn der Konsole sollte Dir nun folgendes angezeigt werden.\nHallo, mein Name ist Peter\nWir sind Freunde seit 5 Jahren\nAufgabe 3 - Einzelarbeit\nLade diese Datei herunter. In dieser Aufgabe wollen wir Benutzereingabe in der Konsole verarbeiten. Dazu verwenden wir in diesem Beispiel readline(https://nodejs.org/api/readline.html) von NodeJS. Wir wollen nun ein kleines Programm schreiben, welches wie folgt aussieht.\n1 2 3 4 Wie ist dein name? Hansli hallo Hansli War diese Aufgabe lehrreich für dich= [j / n]j Super! 1 2 3 4 Wie ist dein name? Hansli hallo Hansli War diese Aufgabe lehrreich für dich= [j / n]n Schade! :( Zuerst wird der Anwender nach seinem Namen gefragt. Danach wird er begrüsst. Und anschliessend wird gefragt ob diese Aufgabe lehrreich für ihn war.\nFülle in der Aufgabendatei den benötigten Code an den entsprechenden Stellen ein.\n- Info zu readline.\nUm readline benutzen zu können, musst du erst den entsprechenden npm-Befehl ausführen. Achte darauf, dass du den Befehl im selben Verzeichnis ausführst, indem sich die .ts-Datei befindet!\nAufgabe 4 Implementiere eine Funktion, welche den Durchschnitt eines Numberarrays berechnet. Die Funktion sollte nur Numberarrays akzeptieren und eine einzelne Zahl zurückgeben. Wenn das Array jedoch leer ist sollte NaN (Not a Number) zurückgegeben werden.\nAufgabe 5 Implementiere eine User Klasse mit den Properties name und email. Die Klasse besitzt zwei Funktionen, eine um die email zu validieren (mit dem Format “example@example.com”) und die andere um einen Begrüssungsnachricht zu erhalten in welcher der Name und die Email genannt wird.\nAufgabe 6 Implementiere eine ShoppingCart Klasse, welche den ShoppingCart eines Onlineshops repräsentieren soll. Die Klasse sollte Funktionen für das hinzufügen von Produkten, dem Errechnen des gesamten Preises und für das Anzeigen der sich im ShoppingCart befindenden Produkten haben. Ein Produkt sollte einen name und price haben.\n","categories":"","description":"Einfache Aufgaben zu den Basics von TypeScript.\n","excerpt":"Einfache Aufgaben zu den Basics von TypeScript.\n","ref":"/de/labs/03_web/03_typescript/01_typescript/","tags":"","title":"Labs zu den TypeScript-Basics"},{"body":" - Einzelarbeit\nAusgangslage In deinem Unternehmen werden die Arbeitszeiten immer noch im Excel erfasst. Dein Linienvorgesetzter ist mit diesem Excel-File nicht mehr so zufrieden. Er verlangt von dir, dass du ein Angular-Projekt realisieren sollst, welches das aktuelle Excel-File ablöst. Designtechnisch ist alles dir überlassen. Du kannst entweder mit einem lokalen Projekt arbeiten oder eine Backendschnittstelle basteln.\nAnforderungen Funktionale Anforderungen Dein Linienvorgesetzter gibt dir folgende funktionale Anforderungen für das Arbeitszeitprogramm:\nDie Mittagszeit von 30 Minuten muss gemacht werden. Sofern über 9h gearbeitet wird, muss mindestens 1h Mittagspause gemacht werden. Man kann entweder von Hand oder mit Hilfe eines QR-Codes ein- und ausstempeln. Es gibt drei Rollen: Admin, Vorgesetzter und Mitarbeiter.\nDer Admin kann neue Mitglieder (Admin, Vorgesetzter, Mitarbeiter) hinzufügen und den Vorgesetzten zuweisen. Sieht aber keine Zeitaufschreibung ausser die eigene. Der Vorgesetzte sieht die eigene Zeit, wieauch die Zeit seiner Mitarbeiter. Der Mitarbeiter sieht nur seine eigene Zeit. Der Admin kann neue Auftragszeiten (Projekt X, Projekt Y, Daily Business, etc.) hinzufügen, welche von allen Mitarbeitern gewählt werden können. Jedes Mitglied muss bei der Zeitaufschreibung ein Auftrag wählen, wo er gerade arbeitet. Diese Projekte können favorisiert werden, damit man sie nicht jedes Mal wählen muss. Jedes Mitglied kann zudem diverse Zeitcodes anwenden, welche vom Admin hinzugefügt werden. Das sind beispielsweise: Krank, Kompensation, Berufsschule, Ferien,etc. Man kann die Zeiten im späteren Verlauf noch ändern. Hierzu werden aber alle geänderten Zeiten (Datum bearbeitung, etc.) angezeigt. Jedes Mitglied kann sein Passwort (und Profilbild) ändern. Der Admin kann die Daten jedes Mitglieds ändern(Nachname, Vorname, Abteilung, etc.) oder löschen. Nicht-funktionale Anforderungen Das System muss innerhalb von 100ms die Daten liefern. IT-Sicherheit: Das System bockiert nach drei Fehlrversuchen die Anmeldung. Abfragen können nur mit einem JWT ausgeführt werden. Daten Mitglieder-Daten Die Mitglieder bestehen aus folgenden Werten:\nNachname Vorname Passwort(muss bei der ersten Anmeldung geändert werden) Abteilung Arbeitszeit(bspw. 100% oder 8h) Rolle (nicht zwingend Profilbild) Zeit-Daten Die Zeit besteht aus folgenden Werten:\nVon Bis Datum Auftragszeit-Daten Die Auftragszeit besteht aus folgenden Werten:\nAuftragsnummer Text Zeitcodes-Daten Die Zeitcodes besteht aus folgenden Werten:\nNummer Beschreibung - Hinweis:\nBeziehungen zwischen Daten nicht vergessen.\nBei Fragen ungeniert melden.\n","categories":"","description":"Einfache Aufgaben zu den Basics von Angular.\n","excerpt":"Einfache Aufgaben zu den Basics von Angular.\n","ref":"/exams/03_web/06_angular/01_angular-exam/","tags":"","title":"Exam zu den Angular-Basics"},{"body":" - Einzelarbeit\nAusgangslage In deinem Unternehmen werden die Arbeitszeiten immer noch im Excel erfasst. Dein Linienvorgesetzter ist mit diesem Excel-File nicht mehr so zufrieden. Er verlangt von dir, dass du ein Angular-Projekt realisieren sollst, welches das aktuelle Excel-File ablöst. Designtechnisch ist alles dir überlassen. Du kannst entweder mit einem lokalen Projekt arbeiten oder eine Backendschnittstelle basteln.\nAnforderungen Funktionale Anforderungen Dein Linienvorgesetzter gibt dir folgende funktionale Anforderungen für das Arbeitszeitprogramm:\nDie Mittagszeit von 30 Minuten muss gemacht werden. Sofern über 9h gearbeitet wird, muss mindestens 1h Mittagspause gemacht werden. Man kann entweder von Hand oder mit Hilfe eines QR-Codes ein- und ausstempeln. Es gibt drei Rollen: Admin, Vorgesetzter und Mitarbeiter.\nDer Admin kann neue Mitglieder (Admin, Vorgesetzter, Mitarbeiter) hinzufügen und den Vorgesetzten zuweisen. Sieht aber keine Zeitaufschreibung ausser die eigene. Der Vorgesetzte sieht die eigene Zeit, wieauch die Zeit seiner Mitarbeiter. Der Mitarbeiter sieht nur seine eigene Zeit. Der Admin kann neue Auftragszeiten (Projekt X, Projekt Y, Daily Business, etc.) hinzufügen, welche von allen Mitarbeitern gewählt werden können. Jedes Mitglied muss bei der Zeitaufschreibung ein Auftrag wählen, wo er gerade arbeitet. Diese Projekte können favorisiert werden, damit man sie nicht jedes Mal wählen muss. Jedes Mitglied kann zudem diverse Zeitcodes anwenden, welche vom Admin hinzugefügt werden. Das sind beispielsweise: Krank, Kompensation, Berufsschule, Ferien,etc. Man kann die Zeiten im späteren Verlauf noch ändern. Hierzu werden aber alle geänderten Zeiten (Datum bearbeitung, etc.) angezeigt. Jedes Mitglied kann sein Passwort (und Profilbild) ändern. Der Admin kann die Daten jedes Mitglieds ändern(Nachname, Vorname, Abteilung, etc.) oder löschen. Nicht-funktionale Anforderungen Das System muss innerhalb von 100ms die Daten liefern. IT-Sicherheit: Das System bockiert nach drei Fehlrversuchen die Anmeldung. Abfragen können nur mit einem JWT ausgeführt werden. Daten Mitglieder-Daten Die Mitglieder bestehen aus folgenden Werten:\nNachname Vorname Passwort(muss bei der ersten Anmeldung geändert werden) Abteilung Arbeitszeit(bspw. 100% oder 8h) Rolle (nicht zwingend Profilbild) Zeit-Daten Die Zeit besteht aus folgenden Werten:\nVon Bis Datum Auftragszeit-Daten Die Auftragszeit besteht aus folgenden Werten:\nAuftragsnummer Text Zeitcodes-Daten Die Zeitcodes besteht aus folgenden Werten:\nNummer Beschreibung - Hinweis:\nBeziehungen zwischen Daten nicht vergessen.\nBei Fragen ungeniert melden.\n","categories":"","description":"Einfache Aufgaben zu den Basics von Angular.\n","excerpt":"Einfache Aufgaben zu den Basics von Angular.\n","ref":"/de/exams/03_web/06_angular/01_angular-exam/","tags":"","title":"Exam zu den Angular-Basics"},{"body":"Schreibe eine Anwendung, welche eine Bibliothek modelliert. In der Bibliothek findet man unterschiedliche Exemplare. z.B: Bücher, Zeitschriften, CDs, DVDs.\nEin Item\nhat einen Titel Folgende Arten von Items können sich in der Bibliothek befinden:\nBuch hat einen Autor hat ein Genre Zeitschrift hat einen Herausgeber hat ein Datum CD hat den Namen des Interpreten hat eine Anzahl von Songs DVD hat den Namen des Regisseurs hat ein Genre Die Anwendung soll ein Inventar von unterschiedlichen Items verwalten (also Bücher, DVDs usw.) es ermöglichen ein Item auszuleihen, wenn es noch nicht ausgeliehen worden ist es ermöglichen ein Item zurückzugeben Auskunft zu den vorhandenen Items im Inventar geben Info: Bei dieser Aufgabe darf man NICHT Gebrauch von Lombok machen.\nEs soll kein Scanner eingesetzt werden.\nHier kannst du zurück zur Theorie.\n","categories":"","description":"Aufgabe zu Modul #J3 - [OOD](../../../../docs/02_java/07_java-ood) - Bibliothek\n","excerpt":"Aufgabe zu Modul #J3 - [OOD](../../../../docs/02_java/07_java-ood) - …","ref":"/labs/02_java/07_java-ood/01_bibliothek/","tags":"","title":"Bibliothek"},{"body":"Schreibe eine Anwendung, welche eine Bibliothek modelliert. In der Bibliothek findet man unterschiedliche Exemplare. z.B: Bücher, Zeitschriften, CDs, DVDs.\nEin Item\nhat einen Titel Folgende Arten von Items können sich in der Bibliothek befinden:\nBuch hat einen Autor hat ein Genre Zeitschrift hat einen Herausgeber hat ein Datum CD hat den Namen des Interpreten hat eine Anzahl von Songs DVD hat den Namen des Regisseurs hat ein Genre Die Anwendung soll ein Inventar von unterschiedlichen Items verwalten (also Bücher, DVDs usw.) es ermöglichen ein Item auszuleihen, wenn es noch nicht ausgeliehen worden ist es ermöglichen ein Item zurückzugeben Auskunft zu den vorhandenen Items im Inventar geben Info: Bei dieser Aufgabe darf man NICHT Gebrauch von Lombok machen.\nEs soll kein Scanner eingesetzt werden.\nHier kannst du zurück zur Theorie.\n","categories":"","description":"Aufgabe zu Modul #J3 - [OOD](../../../../docs/02_java/07_java-ood) - Bibliothek\n","excerpt":"Aufgabe zu Modul #J3 - [OOD](../../../../docs/02_java/07_java-ood) - …","ref":"/de/labs/02_java/07_java-ood/01_bibliothek/","tags":"","title":"Bibliothek"},{"body":" Dieses Kapitel gehört zum Modul #J1 des Ausbildungsplans Ziele Du verstehst den Aufbau einer typischen Modulseite bei it-ninjas. Du kannst alle verfügbaren Shortcodes korrekt einsetzen. Du kennst empfohlene und veraltete Shortcodes. ⏱️ Geschätzte Lesezeit: 10 Minuten Einführung Dieses Cheatsheet zeigt dir anhand von Beispielen, wie eine Modulseite im Projekt it-ninjas aufgebaut ist. Es basiert auf dem it-ninjas Styleguide und wird laufend aktualisiert.\nInfo-Boxen Verwende Ninja-Boxen, um Informationen klar hervorzuheben:\nDas ist eine Info-Box für ergänzende Hinweise. Das ist eine Tip-Box mit einem hilfreichen Hinweis. Das ist eine Warnung – hier muss man besonders aufpassen. Entschuldige, da fehlt noch was...\n--\u003e Hier fehlt noch etwas – markiert als TODO. Video einbinden Für zusätzliche Erklärungen kannst du Videos einbinden:\nLernvideo Wenn du dir die Erklärung noch mit einem Video anschauen möchtest, empfehlen wir dir dieses Video (ninja-pinguine). Code und Aufgaben Codeblöcke für verschiedene Betriebssysteme Kopieren echo Default is visible to all OS 1 echo Default is visible to all OS Kopieren echo Hello from Windows 1 echo Hello from Windows Kopieren echo Hello from Linux 1 echo Hello from Linux Kopieren echo Visible on all OS 1 echo Visible on all OS Links in einem neuen Fenster Da das öffnen in einem neuen Fenster von Markdown und Hugo nicht direkt unterstützt wird kümmert sich ein Script beim starten der Seite darum. Mit einem ! am Anfang des Link-Text, wird der Link in einem neuen Fenster geöffnet.\nDas wird im gleichen Fenster geöffnet.\nDas wird !in einem neuen Fenster geöffnet.\nAufgabenlinks Einzelne Aufgabe: Jetzt bist du dran. Löse bitte die folgende !*Aufgabe in den Labs. Mehrere Aufgaben: Jetzt bist du dran. Löse bitte die folgenden !*Aufgaben in den Labs. Du kannst die Klammenr auch weglassen und nur den reinen Pfad als Parameter übergeben. Das mit den Klammern hat aber den Vorteil, dass z.B. VS Code den Pfad als Link behandeln und dir in der IDE zeigen, wohin der Pfad zeigt (und so, ob er gültig ist).\nLinks zu Labs oder Dokumentationen Zu einem Lab: Zur Aufgabe\nMarkdown-Link-Variante: Zur Aufgabe\nHTML-ähnlich: Zur Aufgabe\nZur Dokumentation zurück: Hier kommst Du zurück zur Dokumentation. Hier kommst Du zurück zur Dokumentation: Java Grundlagen. Plattformabhängige Inhalte Zeige Inhalte nur, wenn ein bestimmtes Betriebssystem konfiguriert ist:\nDieser Abschnitt ist nur unter Linux sichtbar. Dieser Abschnitt ist nur unter Windows sichtbar. Formatierte Konfigurationsdateien (z. B. pom.xml) Verwende diesen Shortcode, damit der XML-Code korrekt eingerückt dargestellt wird:\nPasse das Maven-Konfigurationsfile (pom.xml) an:\n1 2 3 4 5 \u003cdependency\u003e \u003cgroupId\u003eio.github.cdimascio\u003c/groupId\u003e \u003cartifactId\u003edotenv-java\u003c/artifactId\u003e \u003cversion\u003e3.0.0\u003c/version\u003e \u003c/dependency\u003e Falls du Probleme hast, die Maven-Dependency hinzuzufügen, prüfe, ob du mit dem VPN der SBB verbunden bist! Unternehmensspezifische Inhalte Dieser Abschnitt wird nur angezeigt, wenn SBB als Ausbildungsort ausgewählt ist. Veraltete Shortcodes Folgende Shortcodes sind deprecated und sollen nicht mehr verwendet werden:\nDie nachfolgenden Informationen in diesem Abschnitt richten sich an Auszubildende der SBB\nNicht mehr verwenden! Bitte stattdessen Shortcode sbb benutzen. ChatGPT Prompt für die it-ninjas Dokumentation Damit ChatGPT eine Markdown-Datei im it-ninjas Stil überarbeiten kann, sollte der Prompt mehr enthalten als nur technische Anweisungen. Ziel ist es, den charakteristischen Ton, die Zielgruppe und die Formatkonventionen zu berücksichtigen.\nHier ein vollständiger Prompt, den du nutzen oder anpassen kannst:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 Bitte überarbeite folgenden Markdown-Text für das it-ninjas Projekt. ### Zielgruppe: - Lernende (oft ohne Vorwissen), die Java, IntelliJ oder andere Tools im Rahmen der Ausbildung verwenden - Ziel ist, Inhalte **leicht verständlich**, **freundlich**, **ermutigend** und **strukturiert** zu präsentieren ### Ton \u0026 Stil: - **Du-Form** verwenden, nicht „man“ - Aktiv, klar, ermutigend, niemals belehrend - Ein bisschen Witz ist erlaubt, aber stets respektvoll und professionell - Sprich direkt zur Leserin oder zum Leser („Du lernst...“, „So kannst du...“) ### Struktur \u0026 Formatierung: - Abschnitt **„Ziele“** zu Beginn mit klaren Bulletpoints - Nach den Zielen ein `⏱️ Geschätzte Lesezeit: X Minuten `-Block (geschätzte Lesezeit, auf 5 Minuten aufrunden, konservativ geschätzt bei 100 Wörtern/Min) - Abschnittsüberschriften auf der zweiten Ebene (`##`) beginnen - **Maximale Zeilenlänge 120 Zeichen** (auch in Codeblöcken) - Wo möglich, passende Shortcodes einsetzen (`ninja`, `lablink`, `aufgabe`, `code`, etc.) - Veraltete Shortcodes vermeiden (`SBBOnly` z. B.) ### Zusätzliche Hinweise: - Technische Inhalte wenn möglich mit Beispielen, Bildern oder Code ergänzen - Am Ende des Dokuments **freundlich abschliessen** (z. B. „Viel Erfolg!“) - Falls `## Ziele` schon vorhanden ist, nicht duplizieren ### Prettier konform - Kursiv mit `_..._`, nicht mit `*...*` ### Markdown-Text: --- (dein Markdown-Text hier) --- Damit erhalten auch andere Autor:innen dieselbe Qualität wie du – und ChatGPT arbeitet im gewünschten it-ninjas-Stil.\nHinweise zur Formatierung Achte auf maximal 120 Zeichen pro Zeile. Verwende aktive Formulierungen. Halte Inhalte zielgruppengerecht und gut strukturiert. Nutze die zur Verfügung gestellten Shortcodes, um Wiederverwendbarkeit und Einheitlichkeit sicherzustellen. Zwischen zwei Kapiteln kommt eine Linie (---) In allen Codebeispielen gilt: Kommentare, Variablennamen, Methodennamen und Code-Sprache sind auf Englisch. Die Ausgabe auf der Konsole oder dem Bildschirm darf hingegen auf Deutsch sein (z. B. System.out.println(\"Hallo Welt\")). ","categories":"","description":"Übersicht über die wichtigsten Shortcodes und Konventionen für Modulseiten im it-ninjas-Projekt.\n","excerpt":"Übersicht über die wichtigsten Shortcodes und Konventionen für …","ref":"/docs/99_tools/it-ninjas/cheatsheet/","tags":"","title":"Cheatsheet"},{"body":"Ziele Ich kann den Begriff Continuous Integration erklären. Ich kann einen typischen Aufbau eine CI-Pipeline erklären. Ich kenne typische Aufgaben einer CI-Pipeline. Continuous Integration Continuous Integration, oder kurz CI, heisst auf Deutsch so viel wie “Fortlaufende Integration”. Es beschreibt die Praxis, Codeänderungen oft und regelmässig in die Code-Basis zu integrieren. Dazu gehört auch das Testen dieser Änderungen sowie andere Checks, wie etwa Security Scans. Da dies mühsame Arbeit ist, passiert das meistens vollautomatisiert in einer sogenannten Pipeline. Diese Pipelines heissen so, da der Code wie durch ein (oder mehrere) Rohre muss, welche diese Checks ausführen und das Ventil zudrehen können, sollte etwas nicht gut sein.\nDas Ausführen so einer Pipeline passiert entweder nach einem bestimmten Ereignis, z.B. einem Push auf einen Git-Branch, oder periodisch, jede Nacht um 3:00. Damit das möglich ist, wird sie nicht auf dem Computer des Entwicklers, sondern auf einem separaten CI-Server ausgeführt. So kann sichergestellt werden, dass nichts vergessen geht und die Ergebnisse transparent sind.\nWichtig ist, dass das fortlaufende Integrieren von Änderungen nicht heisst, dass nach jeder Änderung eine neue Version der Software verfügbar ist. Das kann der Fall sein (siehe Continuous Deployment), muss aber nicht. Vielmehr geht es darum, dass die Änderungen jeweils klein und gut getestet sind.\nBeispiel einer CI-Pipeline Als Beispiel nehmen wir eine Anwendung, welche eine neue Login-Page bekommen soll. Der/Die Entwickler:in macht also einen neuen Branch feature/new-login-page. Auf diesem nimmt er/sie seine/ihre Änderungen vor und mergt - sobald fertig - diese wieder in den main-Branch. Vor dem Mergen können andere Entwickler:innen noch Tests ausführen oder einen Security-Scan laufen lassen. Da dies jedoch manuell gemacht werden muss, geht das oft vergessen oder wird aus Faulheit nicht umgesetzt.\nMithilfe einer CI-Pipeline können wir diese zwei Aufgaben automatisiert ausführen nach (oder idealerweise noch vor) einem Merge. Pipelines können also dazu dienen, langweilige, wiederkehrende Arbeiten zu verrichten und Entwickler:innen zum Einhalten von Standards zu bewegen. Durch die Pipeline merken wir z.B., dass mehrere Unit-Tests fehlschlagen. Dazu hat die Pipeline ganz einfach den Maven-Command mvn clean test ausgeführt und geschaut, ob jeder Test grün ist. So wie es ein:e Entwickler:in auch auf seiner/ihrer Maschine tun kann.\nDas hätte der/die Entwickler:in merken können, wenn er/sie nach jedem Commit die Tests ausgeführt hätte. Da dies aber manuelle und langweilige Arbeit ist, hat er/sie das natürlich nicht gemacht. Werden die Tests stattdessen auch in einer Pipeline nach jedem git push ausgeführt, merkt der/die Entwickler:in schneller, dass sein/ihr Code noch nicht gut ist.\nEs muss also nicht für jedes Ereignis die gleiche Pipeline ausgeführt werden. Der Security-Scan kann etwa mehrere Minuten dauern, weshalb er nicht bei jedem git push, sondern nur vor einem Merge ausgeführt wird. Grosse Projekte können dutzende solcher Pipelines haben für verschiedene Anlässe und Zwecke.\nAnwendungszwecke von CI-Pipelines Testing\nDie wahrscheinlich häufigste Verwendung ist das automatiserte Ausführen von Tests. Das kann von Unit-Tests bis hin zu E2E-Tests alles sein. Ein Vorteil davon ist, dass die Entwickler:innen das nicht mehr manuell machen müssen. Ein weiterer ist, dass die Tests beschleunigt werden können, etwa durch das Aufteilen der Tests auf viele Maschinen. Es wird auch vermieden, dass die Tests auf einem Entwickler-Laptop laufen, auf einem anderen aber nicht und nun nicht klar ist, ob die Tests gut sind oder nicht. Es gilt, was in der CI-Pipeline passiert. Durchsetzen von Standards Ebenfalls sehr häufig werden Pipelines eingesetzt, um gewisse Standards zu überprüfen. Dazu gehört etwa, ob der Code richtig formatiert ist oder genügend Tests geschrieben wurden. Security Checks Niemand hat Zeit, sich alle Meldungen über Hacks oder Sicherheitslücken durchzulesen und herauszufinden, ob diese auf die eigene Software zutreffen. Eine Pipeline kann stattdessen jede Nacht einen automatisierten Scan durchführen und so die Entwickler am nächsten Morgen benachrichtigen. Bauen von Artefakten Docker-Container oder JARs können durch die Pipelines automatisch generiert und richtig versioniert werden. So sind sie für ein späteres Deployment bereit oder können sogar in einer anderen Pipeline verwendet werden. Umsetzen einer CI-Pipeline Es gibt viele Möglichkeiten eine CI-Pipeline umzusetzen. Gewisse sind eigenständige Tools wie Jenkins oder CircleCI. Viele Plattformen bauen direkt ihre eigenen Lösungen ein, wie etwa GitLab oder GitHub. Für diesen Guide benutzen wir GitHub. Viele der Konzepte können aber auch auf andere Tools übertragen werden.\nGitHub stellt sogenannte Actions oder Workflows als CI-Lösung zur Verfügung. Das sind YAML-Dateien, welche in .github/workflows abgelegt werden. Jede Datei ist dabei ein “Workflow” und kann beliebig benannt werden, solange sie auf .yml oder .yaml endet. Vorhandene Workflows werden im Actions-Tab eines Repositories angezeigt.\nSimpler Workflow Ein simpler Workflow könnte etwa in .github/workflows/hello-world.yaml gespeichert sein und so aussehen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 name: GitHub Actions Hello World on: [push] jobs: hello-world: runs-on: ubuntu-latest steps: - run: echo \"Hello world!\" - run: echo \"🐧 This job is now running on a ${{ runner.os }} server hosted by GitHub!\" - run: echo \"🔎 The name of your branch is ${{ github.ref }}, your repository is ${{ github.repository }} and this workflow was triggered by ${{ github.actor }}\" - name: Check out repository code uses: actions/checkout@v4 - name: Execute multiple commands run: | echo \"One line\" echo \"Another one\" Dieser Workflow besteht aus folgenen Elementen:\nname Der Name des Workflows. on Wann der Workflow ausgeführt werden soll. Das kann von einem git push bis zum Erstellen eines neuen Issues alles Mögliche sein, wobei GitHub hier eine gute Dokumentation dazu hat. In unserem Fall wird der Workflow bei jedem git push ausgeführt. jobs Eine Liste mit Aufgaben, welche der Workflow ausführen soll. Jeder Job hat dabei einen eindeutigen Namen, hier hello-world. runs-on Definiert, auf was für einem Computer der Workflow ausgeführt werden soll. Standardmässig ist das ein Ubuntu-Linux, Windows und OSX sind aber ebenfalls möglich. steps Eine Liste mit Anweisungen, welche nacheinander in diesem Job ausgeführt werden. Ein ganz simpler Step, wie z.B. run: echo \"Hello world!\", macht nichts anderes als den Befehl echo \"Hello World!\" auszuführen.\nUm ein wenig mehr Dynamik in die Sache zu bringen, können wir Teile eines Befehls mit dieser Syntax ersetzen: ${{ dein.variable.name }}.\n1 echo \"🐧 This job is now running on a ${{ runner.os }} server hosted by GitHub!\" wird somit zu\n1 echo \"🐧 This job is now running on a ubuntu-latest server hosted by GitHub!\" Damit man nicht alles selber schreiben muss, kann man auch einfach bereits erstellte “Steps” benutzen. GitHub nennt diese “Actions” und bietet diese in einem Marktplatz an. Es lohnt sich, zuerst zu schauen, ob jemand schon eine Action geschrieben hat, bevor man sich selber die Mühe macht. Ein Beispiel davon ist dieser Step hier:\n1 2 - name: Check out repository code uses: actions/checkout@v4 name ist wie der Step heisst. uses gibt an, dass wir die Checkout Action benutzen wollen. Dieser Befehl macht ein git clone des Repositories und kann in fast jedem CI-Workflow angetroffen werden.\nFalls es mal doch keine Action gibt, welche den Zweck erfüllt, können mehrere Befehle mit dieser Syntax auch über mehrere Zeilen geschrieben werden. Das macht die Sache etwas übersichtlicher.\n1 2 3 4 - name: Execute multiple commands run: | echo \"One line\" echo \"Another one\" Testing Workflow Ein einfacher Workflow für das Testen einer Spring Boot App mit Maven könnte so aussehen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 name: Testing with Maven on: [push] jobs: test: runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 - name: Set up JDK uses: actions/setup-java@v4 with: java-version: 21 distribution: \"temurin\" cache: maven - name: Test run: mvn clean verify Dieser Workflow macht in dieser Reihenfolge:\nein git clone installiert Java mit der Version 21 führt die Tests mit dem Befehl mvn clean verify aus Sollte es zu einem Fehler in den Tests kommen, wird der Workflow fehlschlagen und den Entwickler informieren. ","categories":"","description":"Fortlaufendes Testen mit CI-Pipelines\n","excerpt":"Fortlaufendes Testen mit CI-Pipelines\n","ref":"/docs/08_cicd/01_continuous-integration/","tags":"","title":"Continuous Integration"},{"body":"Ziele Ich kann den Begriff Continuous Integration erklären. Ich kann einen typischen Aufbau eine CI-Pipeline erklären. Ich kenne typische Aufgaben einer CI-Pipeline. Continuous Integration Continuous Integration, oder kurz CI, heisst auf Deutsch so viel wie “Fortlaufende Integration”. Es beschreibt die Praxis, Codeänderungen oft und regelmässig in die Code-Basis zu integrieren. Dazu gehört auch das Testen dieser Änderungen sowie andere Checks, wie etwa Security Scans. Da dies mühsame Arbeit ist, passiert das meistens vollautomatisiert in einer sogenannten Pipeline. Diese Pipelines heissen so, da der Code wie durch ein (oder mehrere) Rohre muss, welche diese Checks ausführen und das Ventil zudrehen können, sollte etwas nicht gut sein.\nDas Ausführen so einer Pipeline passiert entweder nach einem bestimmten Ereignis, z.B. einem Push auf einen Git-Branch, oder periodisch, jede Nacht um 3:00. Damit das möglich ist, wird sie nicht auf dem Computer des Entwicklers, sondern auf einem separaten CI-Server ausgeführt. So kann sichergestellt werden, dass nichts vergessen geht und die Ergebnisse transparent sind.\nWichtig ist, dass das fortlaufende Integrieren von Änderungen nicht heisst, dass nach jeder Änderung eine neue Version der Software verfügbar ist. Das kann der Fall sein (siehe Continuous Deployment), muss aber nicht. Vielmehr geht es darum, dass die Änderungen jeweils klein und gut getestet sind.\nBeispiel einer CI-Pipeline Als Beispiel nehmen wir eine Anwendung, welche eine neue Login-Page bekommen soll. Der/Die Entwickler:in macht also einen neuen Branch feature/new-login-page. Auf diesem nimmt er/sie seine/ihre Änderungen vor und mergt - sobald fertig - diese wieder in den main-Branch. Vor dem Mergen können andere Entwickler:innen noch Tests ausführen oder einen Security-Scan laufen lassen. Da dies jedoch manuell gemacht werden muss, geht das oft vergessen oder wird aus Faulheit nicht umgesetzt.\nMithilfe einer CI-Pipeline können wir diese zwei Aufgaben automatisiert ausführen nach (oder idealerweise noch vor) einem Merge. Pipelines können also dazu dienen, langweilige, wiederkehrende Arbeiten zu verrichten und Entwickler:innen zum Einhalten von Standards zu bewegen. Durch die Pipeline merken wir z.B., dass mehrere Unit-Tests fehlschlagen. Dazu hat die Pipeline ganz einfach den Maven-Command mvn clean test ausgeführt und geschaut, ob jeder Test grün ist. So wie es ein:e Entwickler:in auch auf seiner/ihrer Maschine tun kann.\nDas hätte der/die Entwickler:in merken können, wenn er/sie nach jedem Commit die Tests ausgeführt hätte. Da dies aber manuelle und langweilige Arbeit ist, hat er/sie das natürlich nicht gemacht. Werden die Tests stattdessen auch in einer Pipeline nach jedem git push ausgeführt, merkt der/die Entwickler:in schneller, dass sein/ihr Code noch nicht gut ist.\nEs muss also nicht für jedes Ereignis die gleiche Pipeline ausgeführt werden. Der Security-Scan kann etwa mehrere Minuten dauern, weshalb er nicht bei jedem git push, sondern nur vor einem Merge ausgeführt wird. Grosse Projekte können dutzende solcher Pipelines haben für verschiedene Anlässe und Zwecke.\nAnwendungszwecke von CI-Pipelines Testing\nDie wahrscheinlich häufigste Verwendung ist das automatiserte Ausführen von Tests. Das kann von Unit-Tests bis hin zu E2E-Tests alles sein. Ein Vorteil davon ist, dass die Entwickler:innen das nicht mehr manuell machen müssen. Ein weiterer ist, dass die Tests beschleunigt werden können, etwa durch das Aufteilen der Tests auf viele Maschinen. Es wird auch vermieden, dass die Tests auf einem Entwickler-Laptop laufen, auf einem anderen aber nicht und nun nicht klar ist, ob die Tests gut sind oder nicht. Es gilt, was in der CI-Pipeline passiert. Durchsetzen von Standards Ebenfalls sehr häufig werden Pipelines eingesetzt, um gewisse Standards zu überprüfen. Dazu gehört etwa, ob der Code richtig formatiert ist oder genügend Tests geschrieben wurden. Security Checks Niemand hat Zeit, sich alle Meldungen über Hacks oder Sicherheitslücken durchzulesen und herauszufinden, ob diese auf die eigene Software zutreffen. Eine Pipeline kann stattdessen jede Nacht einen automatisierten Scan durchführen und so die Entwickler am nächsten Morgen benachrichtigen. Bauen von Artefakten Docker-Container oder JARs können durch die Pipelines automatisch generiert und richtig versioniert werden. So sind sie für ein späteres Deployment bereit oder können sogar in einer anderen Pipeline verwendet werden. Umsetzen einer CI-Pipeline Es gibt viele Möglichkeiten eine CI-Pipeline umzusetzen. Gewisse sind eigenständige Tools wie Jenkins oder CircleCI. Viele Plattformen bauen direkt ihre eigenen Lösungen ein, wie etwa GitLab oder GitHub. Für diesen Guide benutzen wir GitHub. Viele der Konzepte können aber auch auf andere Tools übertragen werden.\nGitHub stellt sogenannte Actions oder Workflows als CI-Lösung zur Verfügung. Das sind YAML-Dateien, welche in .github/workflows abgelegt werden. Jede Datei ist dabei ein “Workflow” und kann beliebig benannt werden, solange sie auf .yml oder .yaml endet. Vorhandene Workflows werden im Actions-Tab eines Repositories angezeigt.\nSimpler Workflow Ein simpler Workflow könnte etwa in .github/workflows/hello-world.yaml gespeichert sein und so aussehen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 name: GitHub Actions Hello World on: [push] jobs: hello-world: runs-on: ubuntu-latest steps: - run: echo \"Hello world!\" - run: echo \"🐧 This job is now running on a ${{ runner.os }} server hosted by GitHub!\" - run: echo \"🔎 The name of your branch is ${{ github.ref }}, your repository is ${{ github.repository }} and this workflow was triggered by ${{ github.actor }}\" - name: Check out repository code uses: actions/checkout@v4 - name: Execute multiple commands run: | echo \"One line\" echo \"Another one\" Dieser Workflow besteht aus folgenen Elementen:\nname Der Name des Workflows. on Wann der Workflow ausgeführt werden soll. Das kann von einem git push bis zum Erstellen eines neuen Issues alles Mögliche sein, wobei GitHub hier eine gute Dokumentation dazu hat. In unserem Fall wird der Workflow bei jedem git push ausgeführt. jobs Eine Liste mit Aufgaben, welche der Workflow ausführen soll. Jeder Job hat dabei einen eindeutigen Namen, hier hello-world. runs-on Definiert, auf was für einem Computer der Workflow ausgeführt werden soll. Standardmässig ist das ein Ubuntu-Linux, Windows und OSX sind aber ebenfalls möglich. steps Eine Liste mit Anweisungen, welche nacheinander in diesem Job ausgeführt werden. Ein ganz simpler Step, wie z.B. run: echo \"Hello world!\", macht nichts anderes als den Befehl echo \"Hello World!\" auszuführen.\nUm ein wenig mehr Dynamik in die Sache zu bringen, können wir Teile eines Befehls mit dieser Syntax ersetzen: ${{ dein.variable.name }}.\n1 echo \"🐧 This job is now running on a ${{ runner.os }} server hosted by GitHub!\" wird somit zu\n1 echo \"🐧 This job is now running on a ubuntu-latest server hosted by GitHub!\" Damit man nicht alles selber schreiben muss, kann man auch einfach bereits erstellte “Steps” benutzen. GitHub nennt diese “Actions” und bietet diese in einem Marktplatz an. Es lohnt sich, zuerst zu schauen, ob jemand schon eine Action geschrieben hat, bevor man sich selber die Mühe macht. Ein Beispiel davon ist dieser Step hier:\n1 2 - name: Check out repository code uses: actions/checkout@v4 name ist wie der Step heisst. uses gibt an, dass wir die Checkout Action benutzen wollen. Dieser Befehl macht ein git clone des Repositories und kann in fast jedem CI-Workflow angetroffen werden.\nFalls es mal doch keine Action gibt, welche den Zweck erfüllt, können mehrere Befehle mit dieser Syntax auch über mehrere Zeilen geschrieben werden. Das macht die Sache etwas übersichtlicher.\n1 2 3 4 - name: Execute multiple commands run: | echo \"One line\" echo \"Another one\" Testing Workflow Ein einfacher Workflow für das Testen einer Spring Boot App mit Maven könnte so aussehen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 name: Testing with Maven on: [push] jobs: test: runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 - name: Set up JDK uses: actions/setup-java@v4 with: java-version: 21 distribution: \"temurin\" cache: maven - name: Test run: mvn clean verify Dieser Workflow macht in dieser Reihenfolge:\nein git clone installiert Java mit der Version 21 führt die Tests mit dem Befehl mvn clean verify aus Sollte es zu einem Fehler in den Tests kommen, wird der Workflow fehlschlagen und den Entwickler informieren. ","categories":"","description":"Fortlaufendes Testen mit CI-Pipelines\n","excerpt":"Fortlaufendes Testen mit CI-Pipelines\n","ref":"/de/docs/08_cicd/01_continuous-integration/","tags":"","title":"Continuous Integration"},{"body":"Ziele Du kennst den allgemeinen Aufbau einer Datenbank und kannst ihn erklären. Du kennst den Unterschied zwischen relationalen und NoSQL-Datenbanken. Du weisst, wann welcher Datenbanktyp sinnvoll ist. Du kennst die wichtigsten Datentypen und ihren Nutzen. Was ist eine Datenbank? Eine Datenbank ist ein System zur elektronischen Verwaltung von Daten. Grundsätzlich sagt der Name „Datenbank“ bereits, was sie ist: In einer Datenbank werden Daten in einer bestimmten Ordnung abgelegt. Ähnlich wie bei einer normalen Bank werden die Daten an einem klar definierten Ort gespeichert – fast so wie bei deinem Bankkonto, auf das jeweils der Lohn eingezahlt wird.\nEine Datenbank ist meist in Stufen aufgebaut, die wie folgt aussehen können:\nGanz oben steht die Datenbank an sich. Sie ist vergleichbar mit dem Gebäude einer Bank, in dem sich die Infrastruktur sowie das Geld befinden. Die nächste Stufe ist das Schema. Dieses kann mit einem Raum verglichen werden, der viele verschiedene Aktenschränke enthält. Diese Aktenschränke entsprechen in einer Datenbank den Tabellen. Die Tabellen beinhalten schliesslich die verschiedenen Daten – wie zum Beispiel dein erwähntes Bankkonto mit deinem Kontostand. Zusammenfassend ergibt sich folgender Aufbau:\nSchema und Tabelle Ein Schema ist eine strukturierte Art und Weise, wie Daten organisiert werden. Es legt fest, wie die Datenbank aufgebaut ist und wie die Daten gespeichert und abgerufen werden können.\nEine Tabelle ist eine strukturierte Anordnung von Spalten und Zeilen, in der die eigentlichen Daten gespeichert werden.\nSchemata und Tabellen helfen dabei, Daten organisiert und leicht zugänglich zu halten. Sie ermöglichen es, Daten effizient abzufragen, zu aktualisieren und zu verwalten. Darüber hinaus spielen sie eine wichtige Rolle bei der Sicherstellung der Sicherheit und Integrität der Daten, indem sie Zugriffsrechte und Einschränkungen festlegen.\nIm nächsten Kapitel kannst du sehen, wie so eine Tabelle aussehen kann.\nArten von Datenbanken In diesem Kapitel soll ein kurzer Überblick über die verschiedenen Arten von Datenbanken sowie deren Vor- und Nachteile gegeben werden.\nDie am häufigsten verwendeten Datenbankarten sind relationale (SQL) und NoSQL-Datenbanken.\nRelationale (SQL) Datenbanken werden am häufigsten eingesetzt und sind auch am bekanntesten.\nIn den Übungen sowie in den Prüfungen werden ausschliesslich relationale (SQL) Datenbanken verwendet.\nRelational (SQL) Relationale Datenbanken sind ähnlich wie Excel-Tabellen aufgebaut. Der Name stammt vom Konzept der Relationen (Tabellen), die es ermöglichen, Daten logisch und strukturiert zu speichern und abzurufen.\nSie verwenden Tabellen, die jeweils Zeilen und Spalten enthalten (auch Rows und Columns genannt).\nPro Spalte (Column), auch Attribut genannt, muss ein Datentyp festgelegt werden. Dieser Datentyp definiert, welche Art von Daten in dieser Spalte gespeichert werden kann.\nBeispiel: Eine Spalte mit dem Namen „Alter“ hat einen numerischen Datentyp. Das bedeutet, dass ausschliesslich Zahlen in dieser Spalte eingegeben werden können.\nEine Zeile (Row), auch Tupel genannt, enthält jeweils einen vollständigen Datensatz, wie beispielsweise alle Benutzerdaten.\nQuelle: Wikipedia – Datenbanktabelle\nWas ist SQL? Wieso heisst es eigentlich SQL-Datenbank? SQL steht für Structured Query Language und ist eine standardisierte Sprache zur Verwaltung und Abfrage von Daten in relationalen Datenbanken.\nUm sicherzustellen, dass SQL in verschiedenen Datenbanksystemen wie MariaDB, PostgreSQL, MySQL oder SQL Server ähnlich funktioniert, gibt es den ANSI SQL-Standard. ANSI (American National Standards Institute) hat SQL standardisiert, um eine einheitliche Syntax und grundlegende Funktionen für alle relationalen Datenbanken zu gewährleisten.\nAllerdings implementieren viele Datenbanksysteme zusätzliche SQL-Erweiterungen, die nicht im ANSI-Standard enthalten sind. Deshalb kann sich die SQL-Syntax je nach System leicht unterscheiden. Im IT-Ninjas werden wir hauptsächlich mit MariaDB arbeiten.\nMehr Informationen zur SQL-Syntax findest du im Kapitel SQL Syntax.\nSQL Datentypen In diesem Teil werden kurz die wichtigsten Datentypen aufgelistet. Je nach Datenbank können die Namen der Datentypen abweichen, sollten jedoch von der Funktionalität gleich sein. In dieser Auflistung wurden die MariaDB-Datentypen verwendet:\nTyp-Name Beschreibung Beispiel INT Ganze Zahlen ohne Nachkommastellen im Bereich von -2.147.483.648 bis 2.147.483.647. 123 DECIMAL(p,s) Genaue Dezimalzahlen mit festgelegter Genauigkeit (p = Gesamtanzahl der Ziffern, s = Nachkommastellen), häufig in der Finanz- und Buchhaltungsbranche verwendet. 1234.567 CHAR(n) Zeichenkette mit fester Länge von n Zeichen, aufgefüllt mit Leerzeichen, falls kürzer. ‘ABC’ VARCHAR(n) Zeichenkette mit variabler Länge bis maximal n Zeichen. ‘OpenAI’ DATE Datumsangaben im Bereich zwischen dem Jahr 1000 und 9999. ‘2023-05-31’ TIME Zeitwerte im Bereich zwischen -838:59:59 und 838:59:59. ‘14:30:00’ DATETIME Datum und Uhrzeit kombiniert, häufig für Zeitstempel in Anwendungen verwendet. ‘2023-05-31 14:30:00’ BOOLEAN Wahrheitswerte (TINYINT 1), wobei 0 für FALSE und 1 für TRUE steht. TRUE (intern 1) Wenn du noch mehr über die einzelnen Datentypen erfahren möchtest, findest du unter diesem Link alle verfügbaren Datentypen in MariaDB:\nListe aller Datentypen (MariaDB)\nNoSQL Im Gegensatz zu relationalen Datenbanken speichern NoSQL-Datenbanken Daten in Formaten wie Dokumenten, Schlüssel-Wert-Paaren, Spalten oder Graphen. Dies ermöglicht es, unstrukturierte Daten effektiver zu speichern und abzurufen. Dadurch können natürlich auch keine Structured Query Language Abfragen gemacht werden, deshalb NoSQL.\nWie erklärt gibt es viele verschiedene Ansätze bei NoSQL, deshalb gibt es auch keine gemeinsame Syntax wie es sie bei SQL gibt. Bei den verschiedenen Anbietern kann sich also die Verwendung sehr unterscheiden. Auch wegen der verschiedenen Speicherarten ist keine NoSQL Datenbank wie die andere.\nQuelle: https://www.geeksforgeeks.org/types-of-nosql-databases/\nWann verwende ich welche Datenbank? Eine relationale Datenbank eignet sich gut für Anwendungsfälle, bei denen eine komplexe Datenstruktur mit starken Beziehungen zwischen den Daten besteht, z. B. in Unternehmenssystemen oder Finanzanwendungen, da sie eine konsistente und sichere Datenhaltung gewährleistet.\nNoSQL-Datenbanken sind nützlich, wenn Flexibilität und Skalierbarkeit Priorität haben und wenn die Datenstruktur häufig geändert werden muss oder es viele unstrukturierte oder semistrukturierte Daten gibt, wie beispielsweise in Big Data-Anwendungen, sozialen Netzwerken oder Echtzeit-Analysen.\n","categories":"","description":"","excerpt":"Ziele Du kennst den allgemeinen Aufbau einer Datenbank und kannst ihn …","ref":"/docs/05_database/01_db-erklaert/","tags":"","title":"Datenbank 101"},{"body":"Ziele Du kennst den allgemeinen Aufbau einer Datenbank und kannst ihn erklären. Du kennst den Unterschied zwischen relationalen und NoSQL-Datenbanken. Du weisst, wann welcher Datenbanktyp sinnvoll ist. Du kennst die wichtigsten Datentypen und ihren Nutzen. Was ist eine Datenbank? Eine Datenbank ist ein System zur elektronischen Verwaltung von Daten. Grundsätzlich sagt der Name „Datenbank“ bereits, was sie ist: In einer Datenbank werden Daten in einer bestimmten Ordnung abgelegt. Ähnlich wie bei einer normalen Bank werden die Daten an einem klar definierten Ort gespeichert – fast so wie bei deinem Bankkonto, auf das jeweils der Lohn eingezahlt wird.\nEine Datenbank ist meist in Stufen aufgebaut, die wie folgt aussehen können:\nGanz oben steht die Datenbank an sich. Sie ist vergleichbar mit dem Gebäude einer Bank, in dem sich die Infrastruktur sowie das Geld befinden. Die nächste Stufe ist das Schema. Dieses kann mit einem Raum verglichen werden, der viele verschiedene Aktenschränke enthält. Diese Aktenschränke entsprechen in einer Datenbank den Tabellen. Die Tabellen beinhalten schliesslich die verschiedenen Daten – wie zum Beispiel dein erwähntes Bankkonto mit deinem Kontostand. Zusammenfassend ergibt sich folgender Aufbau:\nSchema und Tabelle Ein Schema ist eine strukturierte Art und Weise, wie Daten organisiert werden. Es legt fest, wie die Datenbank aufgebaut ist und wie die Daten gespeichert und abgerufen werden können.\nEine Tabelle ist eine strukturierte Anordnung von Spalten und Zeilen, in der die eigentlichen Daten gespeichert werden.\nSchemata und Tabellen helfen dabei, Daten organisiert und leicht zugänglich zu halten. Sie ermöglichen es, Daten effizient abzufragen, zu aktualisieren und zu verwalten. Darüber hinaus spielen sie eine wichtige Rolle bei der Sicherstellung der Sicherheit und Integrität der Daten, indem sie Zugriffsrechte und Einschränkungen festlegen.\nIm nächsten Kapitel kannst du sehen, wie so eine Tabelle aussehen kann.\nArten von Datenbanken In diesem Kapitel soll ein kurzer Überblick über die verschiedenen Arten von Datenbanken sowie deren Vor- und Nachteile gegeben werden.\nDie am häufigsten verwendeten Datenbankarten sind relationale (SQL) und NoSQL-Datenbanken.\nRelationale (SQL) Datenbanken werden am häufigsten eingesetzt und sind auch am bekanntesten.\nIn den Übungen sowie in den Prüfungen werden ausschliesslich relationale (SQL) Datenbanken verwendet.\nRelational (SQL) Relationale Datenbanken sind ähnlich wie Excel-Tabellen aufgebaut. Der Name stammt vom Konzept der Relationen (Tabellen), die es ermöglichen, Daten logisch und strukturiert zu speichern und abzurufen.\nSie verwenden Tabellen, die jeweils Zeilen und Spalten enthalten (auch Rows und Columns genannt).\nPro Spalte (Column), auch Attribut genannt, muss ein Datentyp festgelegt werden. Dieser Datentyp definiert, welche Art von Daten in dieser Spalte gespeichert werden kann.\nBeispiel: Eine Spalte mit dem Namen „Alter“ hat einen numerischen Datentyp. Das bedeutet, dass ausschliesslich Zahlen in dieser Spalte eingegeben werden können.\nEine Zeile (Row), auch Tupel genannt, enthält jeweils einen vollständigen Datensatz, wie beispielsweise alle Benutzerdaten.\nQuelle: Wikipedia – Datenbanktabelle\nWas ist SQL? Wieso heisst es eigentlich SQL-Datenbank? SQL steht für Structured Query Language und ist eine standardisierte Sprache zur Verwaltung und Abfrage von Daten in relationalen Datenbanken.\nUm sicherzustellen, dass SQL in verschiedenen Datenbanksystemen wie MariaDB, PostgreSQL, MySQL oder SQL Server ähnlich funktioniert, gibt es den ANSI SQL-Standard. ANSI (American National Standards Institute) hat SQL standardisiert, um eine einheitliche Syntax und grundlegende Funktionen für alle relationalen Datenbanken zu gewährleisten.\nAllerdings implementieren viele Datenbanksysteme zusätzliche SQL-Erweiterungen, die nicht im ANSI-Standard enthalten sind. Deshalb kann sich die SQL-Syntax je nach System leicht unterscheiden. Im IT-Ninjas werden wir hauptsächlich mit MariaDB arbeiten.\nMehr Informationen zur SQL-Syntax findest du im Kapitel SQL Syntax.\nSQL Datentypen In diesem Teil werden kurz die wichtigsten Datentypen aufgelistet. Je nach Datenbank können die Namen der Datentypen abweichen, sollten jedoch von der Funktionalität gleich sein. In dieser Auflistung wurden die MariaDB-Datentypen verwendet:\nTyp-Name Beschreibung Beispiel INT Ganze Zahlen ohne Nachkommastellen im Bereich von -2.147.483.648 bis 2.147.483.647. 123 DECIMAL(p,s) Genaue Dezimalzahlen mit festgelegter Genauigkeit (p = Gesamtanzahl der Ziffern, s = Nachkommastellen), häufig in der Finanz- und Buchhaltungsbranche verwendet. 1234.567 CHAR(n) Zeichenkette mit fester Länge von n Zeichen, aufgefüllt mit Leerzeichen, falls kürzer. ‘ABC’ VARCHAR(n) Zeichenkette mit variabler Länge bis maximal n Zeichen. ‘OpenAI’ DATE Datumsangaben im Bereich zwischen dem Jahr 1000 und 9999. ‘2023-05-31’ TIME Zeitwerte im Bereich zwischen -838:59:59 und 838:59:59. ‘14:30:00’ DATETIME Datum und Uhrzeit kombiniert, häufig für Zeitstempel in Anwendungen verwendet. ‘2023-05-31 14:30:00’ BOOLEAN Wahrheitswerte (TINYINT 1), wobei 0 für FALSE und 1 für TRUE steht. TRUE (intern 1) Wenn du noch mehr über die einzelnen Datentypen erfahren möchtest, findest du unter diesem Link alle verfügbaren Datentypen in MariaDB:\nListe aller Datentypen (MariaDB)\nNoSQL Im Gegensatz zu relationalen Datenbanken speichern NoSQL-Datenbanken Daten in Formaten wie Dokumenten, Schlüssel-Wert-Paaren, Spalten oder Graphen. Dies ermöglicht es, unstrukturierte Daten effektiver zu speichern und abzurufen. Dadurch können natürlich auch keine Structured Query Language Abfragen gemacht werden, deshalb NoSQL.\nWie erklärt gibt es viele verschiedene Ansätze bei NoSQL, deshalb gibt es auch keine gemeinsame Syntax wie es sie bei SQL gibt. Bei den verschiedenen Anbietern kann sich also die Verwendung sehr unterscheiden. Auch wegen der verschiedenen Speicherarten ist keine NoSQL Datenbank wie die andere.\nQuelle: https://www.geeksforgeeks.org/types-of-nosql-databases/\nWann verwende ich welche Datenbank? Eine relationale Datenbank eignet sich gut für Anwendungsfälle, bei denen eine komplexe Datenstruktur mit starken Beziehungen zwischen den Daten besteht, z. B. in Unternehmenssystemen oder Finanzanwendungen, da sie eine konsistente und sichere Datenhaltung gewährleistet.\nNoSQL-Datenbanken sind nützlich, wenn Flexibilität und Skalierbarkeit Priorität haben und wenn die Datenstruktur häufig geändert werden muss oder es viele unstrukturierte oder semistrukturierte Daten gibt, wie beispielsweise in Big Data-Anwendungen, sozialen Netzwerken oder Echtzeit-Analysen.\n","categories":"","description":"","excerpt":"Ziele Du kennst den allgemeinen Aufbau einer Datenbank und kannst ihn …","ref":"/de/docs/05_database/01_db-erklaert/","tags":"","title":"Datenbank 101"},{"body":"Voraussetzung Du bist bereit die nachfolgende Anleitung gründlich zu lesen. Wir stellen dir bei den Übungen jeweils komplette Projekte zur Verfügung. Du musst grundsätzlich nur dort was anpassen, wo die folgende Kommentarzeile steht:\nKopieren // IT-Ninja: Füge hier Deinen Code ein: 1 // IT-Ninja: Füge hier Deinen Code ein: Alles andere kannst du für den Moment ignorieren. Wir erklären dir die einzelnen Zeilen Schritt für Schritt in den Modulen.\nVorbereitungsarbeiten Drücke auf den Pfeil links um eine detaillierte Anleitung zu erhalten, wie Du den Quellcode auf deinem Rechner ablegen sollst.\nDiese Schritte musst du bei jeder Übung erneut machen. Jede Übung hat ein eigenes ZIP-File, welches du bei dir an die richtige Stelle kopieren musst. Die Anleitung zeigt dir ziemlich gut, wie das geht… Liess vor allem am Anfang die detaillierte Anleitung gut durch und befolge die Schritte exakt. Sie helfen dir, deinen Quellcode gut organisiert, strukturiert und sicher zu verwalten. Falls du die Anleitung schon auswendig kennst, findest du den Quellcode zur Übung direkt hier: Download | Online anschauen\nNeu bei it-ninja?\nDie Anleitung enthält einige Befehle und Fachbegriffe, die dir möglicherweise noch nichts sagen. Mach dir deswegen keine Sorgen – in den kommenden Modulen erklären wir dir alles Schritt für Schritt. Schon bald wirst auch du ein it-ninja sein. Um die folgenden Aufgaben erfolgreich umzusetzen, führe diese Schritte aus:\nBeim ersten Mal:\nIntelliJ IDEA installieren → !*IntelliJ IDEA einrichten Git-Repository einrichten → !*Persönliches Git-Repository Öffne eine !*CMD-Shell und wechsle ins Verzeichnis deines Git-Repositories:\nKopieren cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git status 1 2 cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git status Kopieren cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git status 1 2 cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git status Stelle sicher, dass alle Dateien im Git-Repository committed sind. Mit git status erhältst du eine Übersicht: Kopieren git status 1 git status Falls du bei diesem Befehl einen roten Text siehst, musst du zuerst die aktuellen Dateien sichern:\nKopieren git add . git commit -m \"[gescheiter Kommentar]\" 1 2 git add . git commit -m \"[gescheiter Kommentar]\" Erstelle oder wechsle in den Template Branch:\nBeim ersten Mal musst du einen Template Branch erstellen:\nKopieren git checkout -b \"templates\" 1 git checkout -b \"templates\" Falls er bereits existiert, kannst du einfach switchen:\nKopieren git switch \"templates\" 1 git switch \"templates\" Lade den Source-Code zu den Übungen herunter und entpacke ihn im Root-Verzeichnis deines lokalen Repositories:\n[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\nDen Source-Code findest du hier: Download | Online anschauen\nCommitte den originalen Source-Code, damit er sicher im Repository gespeichert ist:\nKopieren git add . git commit -m \"Add it-ninja_02_java_03_java-grundlagen_00_simple-hello-world\" git push 1 2 3 git add . git commit -m \"Add it-ninja_02_java_03_java-grundlagen_00_simple-hello-world\" git push Erstelle einen neuen Branch, um deine Lösung zu implementieren: Kopieren git checkout -b \"labs/it-ninja_02_java_03_java-grundlagen_00_simple-hello-world\" 1 git checkout -b \"labs/it-ninja_02_java_03_java-grundlagen_00_simple-hello-world\" Hier kannst du auch einen kürzeren Namen wählen. Verwende labs am Anfang des Branch-Namens für Branches, die deinen eigenen Code enthalten.\nStelle dir einen Branch vorerst als Ordner vor. Jeder Ordner enthält eine Version oder einen Stand von deinem Quellcode. Du kannst dann mit git zwischen diesen Ordern hin und her wechseln, sie vergleichen aber später auch zusammenführen.\nPro-Tipp:\nDu kannst jederzeit einen weiteren Branch erstellen – z. B. wenn du etwas ausprobieren möchtest. Alternativ kannst du auch in der Git-History einen alten Stand wiederherstellen, was aber weniger flexibel ist. Starte IntelliJ und öffne mit File → Open das Verzeichnis mit dem Source-Code. Du musst mit IntelliJ den Ordner suchen, welches einen Ordner src oder die Datei pom.xml enthält. Ansonsten wird IntelliJ Mühe haben, dir das Programm zu kompilieren. Wenn du alles korrekt gemacht hast, findest du das Projekt hier:\nKopieren `[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\\02_java\\03_java-grundlagen\\00_simple-hello-world` 1 `[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\\02_java\\03_java-grundlagen\\00_simple-hello-world` Kopieren `[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\\02_java/03_java-grundlagen/00_simple-hello-world` 1 `[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\\02_java/03_java-grundlagen/00_simple-hello-world` Falls du zum ersten Mal mit IntelliJ arbeitest, findest du !*hier eine Anleitung, wie man ein Programm startet. Um das Programm zu starten musst du jeweils die Datei Main.java öffenen. Dann sollte in IntelliJ oben rechts ein grünes Dreieck vorhanden sein, welches das Programm startet. Nun bist du bereit, die untenstehenden Aufgaben zu lösen.\nWenn du alle Änderungen gemacht hast und mit der Übung fertig bist, oder einen ‘Zwischenstand’ festhalten willst, führe die folgenden Befehle aus um das Repository auf dem Server zu speichern (von wo du es geklont hast):\nKopieren cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git add --all git commit -m \"Kurzer Kommentar\" 1 2 3 cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git add --all git commit -m \"Kurzer Kommentar\" Kopieren cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git add . git commit -m \"Kurzer Kommentar\" 1 2 3 cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git add . git commit -m \"Kurzer Kommentar\" Wenn du deine Änderungen auf dem Git-Server sichern willst, musst du das mit einem push machen.\nBeim ersten mal musst du git noch mitteilen, wie der Branch auf dem Git-Server heissen soll:\nKopieren git push --set-upstream origin labs/it-ninja_02_java_03_java-grundlagen_00_simple-hello-world 1 git push --set-upstream origin labs/it-ninja_02_java_03_java-grundlagen_00_simple-hello-world Bei weiteren pushes wird es dann einfacher:\nKopieren git push 1 git push Die meisten Übungen sind professionell strukturiert – so wie in echten Softwareprojekten. Zu gutem Code gehören auch Tests, die sicherstellen, dass dein Code wie erwartet funktioniert. Sofern nicht anders erwähnt, kannst du mit folgendem Befehl im Root-Verzeichnis des Projekts (dort, wo sich auch die pom.xml befindet) überprüfen, ob du die Aufgabe korrekt gelöst hast:\n1 mvn test Viel Erfolg!\nEinführung Der zur Übung gehörende Quellcode zeigt dir ein einfaches Programm, welches den Text Hello World auf die Konsole ausgibt. Er soll dir helfen, dich mit der Entwicklungsumgebung (IntelliJ) vertraut zu machen.\nAufgabe - Hello World Schau Dir das Programm an und versuche es zum Laufen zu bringen. Versuche, ein paar kleine Änderungen am Programm vorzunehmen.\nIm zur Übung gehörendem Source kannst Du die Änderung an folgender Stelle machen:\nsrc\\Main.java:\n1 2 3 4 5 6 public class Main { public static void main(String[] args) { System.out.println(\"Hello, world!\"); } } ","categories":"","description":"Hier kannst Du erste Erfahrungen sammeln mit einem einfachen Java Programm\n","excerpt":"Hier kannst Du erste Erfahrungen sammeln mit einem einfachen Java …","ref":"/labs/02_java/03_java-grundlagen/00_simple-hello-world/","tags":"","title":"Java Exercises - Einfaches Hello World"},{"body":"Vom Kommandozeilentool zur Webapplikation Bisher hast du Programme geschrieben, welche auf der Kommandozeile laufen. Dein Code könnte zum Beispiel so aussehen:\n1 2 3 4 5 public class HelloWorld { public static void main(String[] args) { System.out.println(\"Hallo, Welt!\"); } } Das ist perfekt, um Grundlagen zu üben – aber was, wenn du eine Anwendung entwickeln möchtest, die über einen Browser erreichbar ist? Wie funktioniert eine Webseite wie sbb.ch eigentlich? Wie können Nutzer:innen Züge suchen oder Tickets buchen?\nGenau hier kommt das Internetprotokoll HTTP ins Spiel.\nHTTP: Wie dein Browser mit Servern spricht HTTP (HyperText Transfer Protocol) ist ein Protokoll, mit dem Clients (z. B. dein Browser) und Server (z. B. sbb.ch) miteinander kommunizieren. Ursprünglich wurde es entwickelt, um HTML-Dateien von Servern abzurufen.\nWenn du https://sbb.ch im Browser öffnest, passiert Folgendes:\nDein Browser sendet eine HTTP-Anfrage an den Server. Der Server antwortet mit Dateien – oft HTML, CSS oder JavaScript. Dein Browser stellt daraus die Webseite zusammen, die du siehst. Quelle: https://www.browserstack.com/guide/what-is-browser\nREST: Was, wenn du Daten statt Dateien möchtest? Angenommen, du möchtest wissen, welche Züge heute von Zürich nach Bern fahren. Statt einer Webseite benötigst du nun reine Daten (z.B. eine Liste der Züge). Oder du möchtest neue Fahrten hinzufügen.\nHierfür nutzt man oft REST (Representational State Transfer).\nREST beschreibt, wie Webservices aufgebaut sein sollen. Die wichtigsten HTTP-Methoden dafür sind:\nGET → Daten abrufen POST → Daten erstellen PUT → Daten aktualisieren DELETE → Daten löschen Ein typischer REST-Endpunkt könnte so aussehen:\n1 GET /api/zuege?von=Zürich\u0026nach=Bern Dazu benötigst du eine passende Methode, welche auf diesen Endpunkt mappt, auf deinem Server (also in deinem Programm). Spring nutzt dafür Annotationen:\n1 2 3 4 5 6 7 8 9 10 11 12 @RestController @RequestMapping(\"/api/zuege\") public class ZugController { @Autowired private ZugService zugService; @GetMapping public List\u003cZugverbindung\u003e suche(@RequestParam String von, @RequestParam String nach) { return zugService.findeZugverbindungen(von, nach); } } @RestController markiert diese Klasse als REST-Controller - hier sollen also HTTP-Anfragen gemappt werden. @RequestMapping legt fest, auf welchen Pfad diese Klasse reagiert - also zum Beispiel /api/zuege. @GetMapping wird bei GET-Anfragen auf diesem Pfad, also GET /api/zuege, ausgeführt. @RequestParam liest URL-Parameter aus. Java-Objekte über HTTP senden: JSON \u0026 Jackson Das Problem: Du arbeitest mit Java-Objekten – HTTP spricht aber nur Text. Vielleicht möchtest du nicht immer nur ein paar Strings haben, sondern ganze Listen von Objekten. Daher brauchen wir eine Möglichkeit, Objekte in Text zu verwandeln - und umgekehrt.\nHier hilft JSON (JavaScript Object Notation), ein einfaches Datenformat:\n1 2 3 4 5 { \"von\": \"Zürich\", \"nach\": \"Bern\", \"zeit\": 1743511904 } Um JSON in Java zu nutzen, definieren wir ein DTO (Data Transfer Object):\n1 2 3 4 5 public record TravelRequestDto( String von, String nach, Integer zeit ) {} Dank der Bibliothek Jackson geschieht die Umwandlung zwischen JSON und Java automatisch. Wir können also das DTO als RequestBody (ähnlich wie RequestParam) definieren:\n1 2 3 4 @PostMapping(\"/reise\") public void handleTravelRequest(@RequestBody TravelRequestDto request) { // Zugriff auf Werte: request.von(), request.nach(), request.zeit() } Jackson wird nun, falls möglich, automatisch den gesendeten JSON-Text in ein TravelRequestDto mappen.\nEine POST-Anfrage mit Body könnte nun so aussehen:\n1 2 3 4 5 6 7 POST /reise Host: localhost { \"von\": \"Zürich\", \"nach\": \"Bern\", \"zeit\": \"09:00\" } CRUD mit Spring: Eine bewährte Struktur Viele Webanwendungen haben dieselbe Grundstruktur – das CRUD-Prinzip:\nCreate (POST) Read (GET) Update (PUT) Delete (DELETE) Dadurch ist die Architektur vieler Webapplikation ähnlich:\nDer Client ruft den Server mit Input auf. Der Server verarbeitet die Daten und interagiert mit einer Datenbank. Der Server schickt Output zurück an den Client. Natürlich ist es möglich, all dies eigenständig umzusetzen. Allerdings bedeutet das einen erheblichen Aufwand, und das Projekt kann schnell unübersichtlich werden. Beispielsweise könnte an einer Stelle dieselbe Klasse sowohl die Anfrage entgegennehmen als auch die Datenbank abfragen, während anderswo eine klare Trennung vorgenommen wurde. Dies führt zu Inkonsistenzen und erschwert langfristig die Wartung und Erweiterung des Projekts.\nSpring bietet eine Struktur in drei Ebenen an:\nController → nimmt Anfragen entgegen. Service → Geschäftslogik, transformiert Daten. Repository → Zugriff auf Datenbanken. Controller\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @RestController @RequestMapping(\"/api/zuege\") public class ZugController { private final ZugService zugService; public ZugController(ZugService zugService) { this.zugService = zugService; } @GetMapping public List\u003cZugverbindungEntity\u003e suche(@RequestParam String von, @RequestParam String nach) { return zugService.findeZugverbindungen(von, nach); } } Im Controller wird wie oben beschrieben das Mapping von HTTP-Anfragen gemacht. Es gibt also unter /api/zuege ein Mapping für GET mit den Parametern von und nach. Optimal sollte hier aus den zwei Parameter ein DTO erstellt werden.\nService\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Service public class ZugService { private final ZugRepository zugRepository; public ZugService(ZugRepository zugRepository) { this.zugRepository = zugRepository; } public List\u003cZugverbindungEntity\u003e findeZugverbindungen(String von, String nach) { return zugRepository.findByVonUndNach(von, nach); } } Im Service befindet sich deine gesamte Geschäftslogik. Das können beispielsweise Berechnungen der Fahrzeiten sein oder das Einbinden zusätzlicher Informationen wie Baustellen oder Verspätungen. In manchen Fällen, wie im aktuellen Beispiel, wird jedoch lediglich das Repository aufgerufen, um direkt Daten abzufragen.\nRepository\n1 2 3 public interface ZugRepository extends JpaRepository\u003cZugverbindung, Long\u003e { List\u003cZugverbindungEntity\u003e findByVonUndNach(String von, String nach); } Im Repository wird die Kommunikation zu der Datenbank definiert. Du kennst bereits JDBC, in diesem Beispiel wird JPA verwendet, dazu mehr im nächsten Kapitel.\nJPA: Datenbankzugriff leicht gemacht In Java kannst du natürlich auch direkt SQL schreiben. Aber das ist fehleranfällig und aufwendig.\nSpring verwendet JPA (Java Persistence API), um Objekte direkt in Datenbanktabellen zu speichern – ohne SQL schreiben zu müssen.\nBeispiel:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Entity @Table(name = \"zugverbindung\") public class Zugverbindung { @Id @GeneratedValue private Long id; private String von; private String nach; private String zeit; // Getter, Setter... } Die Java-Klasse wird mit der Annotation @Entity markiert, wodurch sie genau einer Zeile in der Datenbanktabelle zugverbindung entspricht. Dank dieser Annotation kann JPA automatisch die Tabelle erzeugen. Wenn du etwa alle Einträge aus der Tabelle abfragst, bekommst du eine List\u003cZugverbindung\u003e, also eine Sammlung von Java-Objekten. Im Repository kannst du Methoden wie findAll() oder findByVonUndNach(String von, String nach) verwenden. Die dafür benötigten SQL-Abfragen werden automatisch von JPA generiert.\nDependency Injection \u0026 IoC: Wer erstellt die Objekte? Dir ist vielleicht aufgefallen, dass bei Controllern, Services und Repositories immer Annotationen wie @Autowired verwendet werden, aber nie Objekte manuell mit new erzeugt werden (z.B. new ZugRepository()). Hier greift das Prinzip der Inversion of Control (IoC) und Dependency Injection (DI): Anstatt dass du die Objekte selbst erzeugst, übernimmt Spring diese Aufgabe automatisch für dich.\n1 2 3 4 5 6 7 8 9 @Service public class ZugService { private final ZugRepository repository; public ZugService(ZugRepository repository) { this.repository = repository; } } Spring sucht zur Laufzeit nach einer passenden Instanz von ZugRepository und übergibt sie automatisch. Das macht deinen Code testbar, modular und lesbar. In diesem Beispiel wird es direkt im Konstruktor definiert ohne @Autowired - das ist eine weitere Möglichkeit, welche das Gleiche macht.\nWieso brauche ich überhaupt noch main? In Spring Boot startest du deine gesamte Anwendung mit einer simplen main-Methode:\n1 2 3 4 5 6 @SpringBootApplication public class ZugApplication { public static void main(String[] args) { SpringApplication.run(ZugApplication.class, args); } } Die Annotation @SpringBootApplication sorgt automatisch dafür, dass Spring alle Klassen findet, welche als Komponenten (@Controller, @Service, @Repository) definiert sind. Diese automatische Suche nennt sich Component Scan und erlaubt die Dependency Injection.\nDamit kannst du einfach und schnell deine Webanwendung starten und musst dich nicht mehr um technische Details kümmern.\nUnd wo kommt jetzt HTML ins Spiel? Mit Spring Boot entwickelst du hauptsächlich Backends – also Anwendungen, die Daten verarbeiten, speichern oder bereitstellen. Diese Anwendungen liefern oft keine komplette Webseite, sondern nur Daten im JSON-Format über eine REST-API.\nDoch wie wird daraus eine sichtbare Webseite? Und was ist eigentlich der Unterschied zwischen Frontend und Backend?\nBackend vs. Frontend\nBackend: Das ist der Teil der Anwendung, der „im Hintergrund“ läuft – etwa auf einem Server. Hier werden Daten gespeichert, verarbeitet und über eine API bereitgestellt. In unserem Fall ist das die Anwendung mit Spring Boot. Frontend: Das ist das, was Nutzer:innen im Browser sehen – z.B. Buttons, Eingabefelder oder Tabellen. Frontends werden meist mit HTML, CSS und JavaScript entwickelt. Das Frontend spricht also mit dem Backend (z.B. dein REST-API mit Spring), um Daten abzuholen oder zu bearbetien – häufig über HTTP.\n","categories":"","description":"Modul #J8 – Spring Framework\n","excerpt":"Modul #J8 – Spring Framework\n","ref":"/docs/02_java/12_spring-framework/01_spring_introduction/","tags":"","title":"Einführung in Spring und Webentwicklung"},{"body":"Vom Kommandozeilentool zur Webapplikation Bisher hast du Programme geschrieben, welche auf der Kommandozeile laufen. Dein Code könnte zum Beispiel so aussehen:\n1 2 3 4 5 public class HelloWorld { public static void main(String[] args) { System.out.println(\"Hallo, Welt!\"); } } Das ist perfekt, um Grundlagen zu üben – aber was, wenn du eine Anwendung entwickeln möchtest, die über einen Browser erreichbar ist? Wie funktioniert eine Webseite wie sbb.ch eigentlich? Wie können Nutzer:innen Züge suchen oder Tickets buchen?\nGenau hier kommt das Internetprotokoll HTTP ins Spiel.\nHTTP: Wie dein Browser mit Servern spricht HTTP (HyperText Transfer Protocol) ist ein Protokoll, mit dem Clients (z. B. dein Browser) und Server (z. B. sbb.ch) miteinander kommunizieren. Ursprünglich wurde es entwickelt, um HTML-Dateien von Servern abzurufen.\nWenn du https://sbb.ch im Browser öffnest, passiert Folgendes:\nDein Browser sendet eine HTTP-Anfrage an den Server. Der Server antwortet mit Dateien – oft HTML, CSS oder JavaScript. Dein Browser stellt daraus die Webseite zusammen, die du siehst. Quelle: https://www.browserstack.com/guide/what-is-browser\nREST: Was, wenn du Daten statt Dateien möchtest? Angenommen, du möchtest wissen, welche Züge heute von Zürich nach Bern fahren. Statt einer Webseite benötigst du nun reine Daten (z.B. eine Liste der Züge). Oder du möchtest neue Fahrten hinzufügen.\nHierfür nutzt man oft REST (Representational State Transfer).\nREST beschreibt, wie Webservices aufgebaut sein sollen. Die wichtigsten HTTP-Methoden dafür sind:\nGET → Daten abrufen POST → Daten erstellen PUT → Daten aktualisieren DELETE → Daten löschen Ein typischer REST-Endpunkt könnte so aussehen:\n1 GET /api/zuege?von=Zürich\u0026nach=Bern Dazu benötigst du eine passende Methode, welche auf diesen Endpunkt mappt, auf deinem Server (also in deinem Programm). Spring nutzt dafür Annotationen:\n1 2 3 4 5 6 7 8 9 10 11 12 @RestController @RequestMapping(\"/api/zuege\") public class ZugController { @Autowired private ZugService zugService; @GetMapping public List\u003cZugverbindung\u003e suche(@RequestParam String von, @RequestParam String nach) { return zugService.findeZugverbindungen(von, nach); } } @RestController markiert diese Klasse als REST-Controller - hier sollen also HTTP-Anfragen gemappt werden. @RequestMapping legt fest, auf welchen Pfad diese Klasse reagiert - also zum Beispiel /api/zuege. @GetMapping wird bei GET-Anfragen auf diesem Pfad, also GET /api/zuege, ausgeführt. @RequestParam liest URL-Parameter aus. Java-Objekte über HTTP senden: JSON \u0026 Jackson Das Problem: Du arbeitest mit Java-Objekten – HTTP spricht aber nur Text. Vielleicht möchtest du nicht immer nur ein paar Strings haben, sondern ganze Listen von Objekten. Daher brauchen wir eine Möglichkeit, Objekte in Text zu verwandeln - und umgekehrt.\nHier hilft JSON (JavaScript Object Notation), ein einfaches Datenformat:\n1 2 3 4 5 { \"von\": \"Zürich\", \"nach\": \"Bern\", \"zeit\": 1743511904 } Um JSON in Java zu nutzen, definieren wir ein DTO (Data Transfer Object):\n1 2 3 4 5 public record TravelRequestDto( String von, String nach, Integer zeit ) {} Dank der Bibliothek Jackson geschieht die Umwandlung zwischen JSON und Java automatisch. Wir können also das DTO als RequestBody (ähnlich wie RequestParam) definieren:\n1 2 3 4 @PostMapping(\"/reise\") public void handleTravelRequest(@RequestBody TravelRequestDto request) { // Zugriff auf Werte: request.von(), request.nach(), request.zeit() } Jackson wird nun, falls möglich, automatisch den gesendeten JSON-Text in ein TravelRequestDto mappen.\nEine POST-Anfrage mit Body könnte nun so aussehen:\n1 2 3 4 5 6 7 POST /reise Host: localhost { \"von\": \"Zürich\", \"nach\": \"Bern\", \"zeit\": \"09:00\" } CRUD mit Spring: Eine bewährte Struktur Viele Webanwendungen haben dieselbe Grundstruktur – das CRUD-Prinzip:\nCreate (POST) Read (GET) Update (PUT) Delete (DELETE) Dadurch ist die Architektur vieler Webapplikation ähnlich:\nDer Client ruft den Server mit Input auf. Der Server verarbeitet die Daten und interagiert mit einer Datenbank. Der Server schickt Output zurück an den Client. Natürlich ist es möglich, all dies eigenständig umzusetzen. Allerdings bedeutet das einen erheblichen Aufwand, und das Projekt kann schnell unübersichtlich werden. Beispielsweise könnte an einer Stelle dieselbe Klasse sowohl die Anfrage entgegennehmen als auch die Datenbank abfragen, während anderswo eine klare Trennung vorgenommen wurde. Dies führt zu Inkonsistenzen und erschwert langfristig die Wartung und Erweiterung des Projekts.\nSpring bietet eine Struktur in drei Ebenen an:\nController → nimmt Anfragen entgegen. Service → Geschäftslogik, transformiert Daten. Repository → Zugriff auf Datenbanken. Controller\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @RestController @RequestMapping(\"/api/zuege\") public class ZugController { private final ZugService zugService; public ZugController(ZugService zugService) { this.zugService = zugService; } @GetMapping public List\u003cZugverbindungEntity\u003e suche(@RequestParam String von, @RequestParam String nach) { return zugService.findeZugverbindungen(von, nach); } } Im Controller wird wie oben beschrieben das Mapping von HTTP-Anfragen gemacht. Es gibt also unter /api/zuege ein Mapping für GET mit den Parametern von und nach. Optimal sollte hier aus den zwei Parameter ein DTO erstellt werden.\nService\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Service public class ZugService { private final ZugRepository zugRepository; public ZugService(ZugRepository zugRepository) { this.zugRepository = zugRepository; } public List\u003cZugverbindungEntity\u003e findeZugverbindungen(String von, String nach) { return zugRepository.findByVonUndNach(von, nach); } } Im Service befindet sich deine gesamte Geschäftslogik. Das können beispielsweise Berechnungen der Fahrzeiten sein oder das Einbinden zusätzlicher Informationen wie Baustellen oder Verspätungen. In manchen Fällen, wie im aktuellen Beispiel, wird jedoch lediglich das Repository aufgerufen, um direkt Daten abzufragen.\nRepository\n1 2 3 public interface ZugRepository extends JpaRepository\u003cZugverbindung, Long\u003e { List\u003cZugverbindungEntity\u003e findByVonUndNach(String von, String nach); } Im Repository wird die Kommunikation zu der Datenbank definiert. Du kennst bereits JDBC, in diesem Beispiel wird JPA verwendet, dazu mehr im nächsten Kapitel.\nJPA: Datenbankzugriff leicht gemacht In Java kannst du natürlich auch direkt SQL schreiben. Aber das ist fehleranfällig und aufwendig.\nSpring verwendet JPA (Java Persistence API), um Objekte direkt in Datenbanktabellen zu speichern – ohne SQL schreiben zu müssen.\nBeispiel:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Entity @Table(name = \"zugverbindung\") public class Zugverbindung { @Id @GeneratedValue private Long id; private String von; private String nach; private String zeit; // Getter, Setter... } Die Java-Klasse wird mit der Annotation @Entity markiert, wodurch sie genau einer Zeile in der Datenbanktabelle zugverbindung entspricht. Dank dieser Annotation kann JPA automatisch die Tabelle erzeugen. Wenn du etwa alle Einträge aus der Tabelle abfragst, bekommst du eine List\u003cZugverbindung\u003e, also eine Sammlung von Java-Objekten. Im Repository kannst du Methoden wie findAll() oder findByVonUndNach(String von, String nach) verwenden. Die dafür benötigten SQL-Abfragen werden automatisch von JPA generiert.\nDependency Injection \u0026 IoC: Wer erstellt die Objekte? Dir ist vielleicht aufgefallen, dass bei Controllern, Services und Repositories immer Annotationen wie @Autowired verwendet werden, aber nie Objekte manuell mit new erzeugt werden (z.B. new ZugRepository()). Hier greift das Prinzip der Inversion of Control (IoC) und Dependency Injection (DI): Anstatt dass du die Objekte selbst erzeugst, übernimmt Spring diese Aufgabe automatisch für dich.\n1 2 3 4 5 6 7 8 9 @Service public class ZugService { private final ZugRepository repository; public ZugService(ZugRepository repository) { this.repository = repository; } } Spring sucht zur Laufzeit nach einer passenden Instanz von ZugRepository und übergibt sie automatisch. Das macht deinen Code testbar, modular und lesbar. In diesem Beispiel wird es direkt im Konstruktor definiert ohne @Autowired - das ist eine weitere Möglichkeit, welche das Gleiche macht.\nWieso brauche ich überhaupt noch main? In Spring Boot startest du deine gesamte Anwendung mit einer simplen main-Methode:\n1 2 3 4 5 6 @SpringBootApplication public class ZugApplication { public static void main(String[] args) { SpringApplication.run(ZugApplication.class, args); } } Die Annotation @SpringBootApplication sorgt automatisch dafür, dass Spring alle Klassen findet, welche als Komponenten (@Controller, @Service, @Repository) definiert sind. Diese automatische Suche nennt sich Component Scan und erlaubt die Dependency Injection.\nDamit kannst du einfach und schnell deine Webanwendung starten und musst dich nicht mehr um technische Details kümmern.\nUnd wo kommt jetzt HTML ins Spiel? Mit Spring Boot entwickelst du hauptsächlich Backends – also Anwendungen, die Daten verarbeiten, speichern oder bereitstellen. Diese Anwendungen liefern oft keine komplette Webseite, sondern nur Daten im JSON-Format über eine REST-API.\nDoch wie wird daraus eine sichtbare Webseite? Und was ist eigentlich der Unterschied zwischen Frontend und Backend?\nBackend vs. Frontend\nBackend: Das ist der Teil der Anwendung, der „im Hintergrund“ läuft – etwa auf einem Server. Hier werden Daten gespeichert, verarbeitet und über eine API bereitgestellt. In unserem Fall ist das die Anwendung mit Spring Boot. Frontend: Das ist das, was Nutzer:innen im Browser sehen – z.B. Buttons, Eingabefelder oder Tabellen. Frontends werden meist mit HTML, CSS und JavaScript entwickelt. Das Frontend spricht also mit dem Backend (z.B. dein REST-API mit Spring), um Daten abzuholen oder zu bearbetien – häufig über HTTP.\n","categories":"","description":"Modul #J8 – Spring Framework\n","excerpt":"Modul #J8 – Spring Framework\n","ref":"/de/docs/02_java/12_spring-framework/01_spring_introduction/","tags":"","title":"Einführung in Spring und Webentwicklung"},{"body":"Ziele Ich habe die Ersteinrichtung des Laptops vollständig durchgeführt Ich habe die notwendigen Programme heruntergeladen und installiert Programme und Tools Die folgenden Programme sollten heruntergeladen und installiert werden, sie werden für die Grundausbildung verwendet.\nAnwendung Link Zweck JetBrains Toolbox (optional) https://www.jetbrains.com/toolbox/app/ Management für Entwicklungsumgebungen IntelliJ IDEA Durch die JetBrains Toolbox oder direkt unter https://www.jetbrains.com/de-de/idea/download/ Entwicklungsumgebung, beim Starten den Lizenzserver eintragen: https://sbb-license.fls.jetbrains.com Notepad++ https://notepad-plus-plus.org/downloads/ Erweiterter Texteditor mit vielen nützlichen Funktionen Google Chrome https://www.google.com/intl/de/chrome/ Web-Browser von Google mit sehr guten Entwickler-Funktionen GIT https://git-scm.com/download/win Zugriff auf das Versionsverwaltungssystem GIT Apache Maven https://maven.apache.org/download.cgi Build Management Tool von Apache, beim Herunterladen das Binary auswählen (nicht die Source) OpenJDK Bei IntelliJ direkt herunterladen, z.B. Eclipse Temurin Java Development Kit zur Herstellung von Java-Anwendungen Insomnia https://insomnia.rest/ Anwendung zum Absetzen von Requests an REST-Schnittstellen Firewall / Sicherheit Dein Betriebssystem verfügt mit dem Windows-Betriebssystem über eine eigene Firewall. Du bist persönlich für deren Konfiguration verantwortlich. Gleichzeitig verfügt das SBB-Netzwerk selbstverständlich über entsprechende Schutzmechanismen, darunter auch diverse Firewalls. Im Intranet der SBB ist der Besuch von diversen Webseiten eingeschränkt. Dein Browser informiert dich sofort, wenn du auf eine nicht zugelassene Seite navigierst.\nLies den folgenden Artikel im Intranet betreffend Weisungen über Datensicherheit und Datenschutz: https://sbb.sharepoint.com/sites/intranet_servicessupport/SitePages/datensicherheit-und-datenschutz.aspx\n","categories":"","description":"Modul - Entwicklungsumgebung einrichten\n","excerpt":"Modul - Entwicklungsumgebung einrichten\n","ref":"/de/docs/02_java/01_entwicklungsumgebung/","tags":"","title":"Entwicklungsumgebung einrichten"},{"body":"Vorbereitung Erstelle selbsständig ein neues Projekt in IntelliJ. Eine Anleitung findest du hier.\nGegeben Gegeben ist das folgende Array mit Zahlen:\n1 2 3 4 5 6 7 8 9 10 11 int[] numbers = { -8, 0, 13, 0, -8, 23, -22, 18, -6, -1, -21, -1, 2, 20, -24, 21, 25, -16, -10, -2, -20, 15, -15, 0, -16, -19, 13, 24, -3, 7, 21, -15, 21, -11, 4, -17, 3, 11, 22, 12, 11, 12, 6, -4, -21, -20, -24, -3, -25, -13, 17, 19, 19, 20, 22, 9, -10, 12, 16, -1, 21, -24, 12, 19, -7, 15, 5, -22, 23, 12, 6, 2, -14, 12, 17, -13, 3, -4, -16, 8, 16, 6, -23, 0, 3, -16, -6, -14, 8, 25, -22, 2, 7, 8, -6, 20, 3, -5, -19, -15 }; Aufgabe 1 Schreibe eine Methode, welche alle Zahlen im Array zählt, welche grösser gleich 0 und kleiner gleich 10, aber nicht 5 sind. Die Methode liefert die Anzahl dieser Zahlen zurück.\nWichtig:\nErstelle deine Methoden in einem eigenen Package. Das Array mit den Zahlen soll als Parameter übergeben werden können. Rufe die Methode aus deinem main() auf und gib den erhaltenen Wert auf der Konsole aus: Es gibt x Zahlen, welche grösser gleich 0 und kleiner gleich 10, aber nicht 5 sind. Aufgabe 2 Schreibe eine Methode, welche aus dem Array alle positiven Zahlen inklusive 0 in ein neues Array schreibt. Die Reihenfolge der Zahlen im Array muss gleich bleiben, kommt eine Zahl mehrfach vor, kommt sie auch im neuen Array mehrfach vor. Die Methode liefert das neue Array zurück.\nWichtig:\nErstelle deine Methoden in einem eigenen Package. Das Array mit den Zahlen soll als Parameter übergeben werden können. Rufe die Methode aus deinem main() auf und gib das erhaltene Array auf der Konsole aus: Positive Zahlen inklusive 0: x, y, z, ... Aufgabe 3 Schreibe eine Methode, welche aus dem Array alle Zahlen sucht, welche nicht mehr als 10 von der Zahl -6 abweichen (eine Abweichung von 10 ist noch ok). Schreibe diese Zahlen in ein neues Array. Die Reihenfolge der Zahlen im Array muss gleich bleiben, kommt eine Zahl mehrfach vor, kommt sie auch im neuen Array mehrfach vor. Die Methode liefert das neue Array zurück.\nWichtig:\nErstelle deine Methoden in einem eigenen Package. Das Array mit den Zahlen soll als Parameter übergeben werden können. Rufe die Methode aus deinem main() auf und gib das erhaltene Array auf der Konsole aus: Zahlen welche nicht mehr als 10 von -6 abweichen: x, y, z, ... Aufgabe 4 Schreibe eine Methode, welche alle Zahlen aus dem Array in positive Zahlen verwandelt und diese in ein neues Array schreibt. Die Reihenfolge der Zahlen im Array muss gleich bleiben, kommt eine Zahl mehrfach vor, kommt sie auch im neuen Array mehrfach vor. Die Methode liefert das neue Array zurück.\nWichtig:\nMath.abs darf für diese Aufgabe nicht verwendet werden. Erstelle deine Methoden in einem eigenen Package. Das Array mit den Zahlen soll als Parameter übergeben werden können. Rufe die Methode aus deinem main() auf und gib das erhaltene Array auf der Konsole aus: Zahlen welche nicht mehr als 10 von -6 abweichen: x, y, z, ... Aufgabe 5 Schreibe eine Methode, welche alle Zahlen aus dem Array ausliest, die sich von ihren direkten Nachbarn um jeweils nicht mehr als den Wert 5 unterscheiden. Schreibe diese Zahlen in ein neues Array. Für die erste und die letzte Zahl im Array gibt es nur einen Nachbar. Die Reihenfolge der Zahlen im Array muss gleich bleiben, kommt eine Zahl mehrfach vor, kommt sie auch im neuen Array mehrfach vor. Die Methode liefert das neue Array zurück.\nEin Beispiel:\n1 int[] beispiel = { 2, 5, 19, 15, 12, 18 }; Hier würde die Methode folgenden Array zurückgeben:\n1 int[] result = { 2, 15 }; Erklärung:\n2: Kein Nachbar links, Nachbar rechts (5) mit Unterschied 3. 5: Nachbar links (2) mit Unterschied 3, Nachbar rechts (19) mit Unterschied 14. 19: Nachbar links (5) mit Unterschied 14, Nachbar rechts (15) mit Unterschied 4. 15: Nachbar links (19) mit Unterschied 4, Nachbar rechts (12) mit Unterschied 3. 12: Nachbar links (15) mit Unterschied 3, Nachbar rechts (18) mit Unterschied 6. 18: Nachbar links (12) mit Unterschied 6, kein Nachbar rechts. ","categories":"","description":"Einfache Aufgaben mit einem Zahlen-Array\n","excerpt":"Einfache Aufgaben mit einem Zahlen-Array\n","ref":"/exams/02_java/03_java-grundlagen/01_exam1/","tags":"","title":"Exam Java Grundlagen - Zahlen-Array"},{"body":"Gegeben Gegeben ist das folgende Array mit Zahlen:\n1 2 3 4 5 6 7 8 9 10 11 int[] numbers = { -8, 0, 13, 0, -8, 23, -22, 18, -6, -1, -21, -1, 2, 20, -24, 21, 25, -16, -10, -2, -20, 15, -15, 0, -16, -19, 13, 24, -3, 7, 21, -15, 21, -11, 4, -17, 3, 11, 22, 12, 11, 12, 6, -4, -21, -20, -24, -3, -25, -13, 17, 19, 19, 20, 22, 9, -10, 12, 16, -1, 21, -24, 12, 19, -7, 15, 5, -22, 23, 12, 6, 2, -14, 12, 17, -13, 3, -4, -16, 8, 16, 6, -23, 0, 3, -16, -6, -14, 8, 25, -22, 2, 7, 8, -6, 20, 3, -5, -19, -15 }; Aufgabe 1 Schreibe eine Methode, welche alle Zahlen im Array zählt, welche zwischen 0 und 10 liegen und keine 5 sind. Die Methode liefert die Anzahl dieser Zahlen zurück.\nAufgabe 2 Schreibe eine Methode, welche aus dem Array alle positiven Zahlen inklusive 0 in ein neues Array schreibt. Die Reihenfolge der Zahlen im Array muss gleich bleiben. Die Methode liefert das neue Array zurück.\nAufgabe 3 Schreibe eine Methode, welche aus dem Array alle Zahlen sucht, welche nicht mehr als 10 von der Zahl -6 abweichen. Schreibe diese Zahlen in ein neues Array. Die Methode liefert das neue Array zurück.\nAufgabe 4 Schreibe eine Methode, welche alle Zahlen aus dem Array in positive Zahlen verwandelt und diese in ein neues Array schreibt. Die Methode liefert das neue Array zurück.\nMath.abs darf für diese Aufgabe nicht verwendet werden.\nAufgabe 5 Schreibe eine Methode, welche alle Zahlen aus dem Array ausliest, die sich von ihren direkten Nachbarn um jeweils nicht mehr als den Wert 5 unterscheiden. Schreibe diese Zahlen in ein neues Array. Die Methode liefert das neue Array zurück. Für die erste und die letzte Zahl im Array gibt es nur einen Nachbar.\nEin Beispiel:\n1 int[] beispiel = { 2, 5, 19, 15, 12, 18 }; Hier würde die Methode folgenden Array zurückgeben:\n1 int[] result = { 2, 15 }; Erklärung:\n2: Kein Nachbar links, Nachbar rechts (5) mit Unterschied 3. 5: Nachbar links (2) mit Unterschied 3, Nachbar rechts (19) mit Unterschied 14. 19: Nachbar links (5) mit Unterschied 14, Nachbar rechts (15) mit Unterschied 4. 15: Nachbar links (19) mit Unterschied 4, Nachbar rechts (12) mit Unterschied 3. 12: Nachbar links (15) mit Unterschied 3, Nachbar rechts (18) mit Unterschied 6. 18: Nachbar links (12) mit Unterschied 6, kein Nachbar rechts. ","categories":"","description":"Einfache Aufgaben mit einem Zahlen-Array\n","excerpt":"Einfache Aufgaben mit einem Zahlen-Array\n","ref":"/de/exams/02_java/03_java-grundlagen/01_exam1/","tags":"","title":"Exam Java Grundlagen - Zahlen-Array"},{"body":"Schritt 1: Initialisiere ein Git-Repository Öffne dein Terminal oder die Kommandozeile. Erstelle ein neues Verzeichnis. Navigiere in das gerade erstellte Verzeichnis. Initialisiere ein neues Git-Repository. 1 2 git init git status Schritt 2: Erstelle eine konfliktverursachende Datei Erstelle eine neue Datei mit dem Namen index.txt und füge einen Satz hinzu. Speichere die Datei und committe die initiale Version. 1 2 git add index.txt git commit -m \"Add index.txt\" Schritt 3: Erstelle einen neuen Branch und mache Änderungen Erstelle einen neuen Branch mit dem Namen feature/my-cool-feature. 1 2 git branch feature/my-cool-feature git switch feature/my-cool-feature Öffne die index.txt Datei und ändere den Inhalt. Die Änderung soll dabei auf der gleichen Zeile sein wie den Satz den du zuvor hinzugefügt hast. Z.B. Mein Satz zu Mein viel besserer Satz. Speichere die Datei. Schritt 4: Änderungen im Feature-Branch stashens Bevor du den Feature-Branch in den Master-Branch mergst, stashe zuerst die Änderungen. 1 2 git stash save \"My stashed changes\" git stash list Schritt 5: Konfliktverursachende Änderungen auf Master hinzufügen Wechsle zurück zum master-Branch. Öffne die index.txt Datei und ändere den Inhalt. Speichere die Datei und committe die Änderungen. 1 2 git add index.txt git commit -m \"Changed something in index.html\" Schritt 6: Änderungen aus dem Feature-Branch in den Master-Branch picken Übernimm nun den letzten Commit aus dem Feature-Branch in den Master-Branch, mithilfe von cherry-pick.\nMit git log --oneline den letzten Commit-Hash anzeigen, in diesem Fall wäre das ea95358.\n1 2 6238890 (HEAD -\u003e master) Changed something in index.html ea95358 (feature/my-cool-branch) Added index.txt Danach die Änderungen aus dem Feature-Branch cherry-picken.\n1 2 git log --oneline git cherry-pick \u003cCOMMIT-HASH\u003e Wenn alles richtige gemacht wurde, erscheint danach eine Warnung über einen Merge-Konflikt.\n1 2 3 4 Auto-merging index.txt CONFLICT (add/add): Merge conflict in index.txt error: could not apply ea95358... Added index.txt ... Schritt 7: Löse den Merge-Konflikt Um den Merge-Konflikt zu lösen, öffnest du am besten IntelliJ(empfohlen) oder Visual Studio Code. Du kannst es natürlich auch über das Terminal versuchen, wenn du mutig genug bist.\nGrundsätzlich entsteht ein Merge-Conflict, wenn am gleichen Ort unterschiedliche Änderungen vorgenommen wurden. Git kann dann die Änderungen nicht mehr automatisch zusammenführen (mergen).\nGit zeigt einen Merge-Konflikt mithilfe von \u003c\u003c\u003c, \u003e\u003e\u003e und === an. Der Text bei \u003c\u003c\u003c sind deine Änderungen, die Änderungen bei \u003e\u003e\u003e kommen aus dem Remote-Repository. Getrennt werden sie durch eine Zeile an Gleichzeichen ===. Oft abstrahiert deine IDE diese Darstellung jedoch noch.\nBei dieser List von Hobbies wurde lokal die Zeile “Schlafen” hinzugefügt, remote wurde auf der gleichen Zeile jedoch “Gym” hinzugefügt.\n1 2 3 4 5 6 7 - Lesen - Gamen \u003c\u003c\u003c\u003c\u003c\u003c\u003c HEAD - Schlafen ======= - Gym \u003e\u003e\u003e\u003e\u003e\u003e\u003e 3c55804e0fa4cac9002edb45443d4a9c95bc26b4 Um den Konflikt zu lösen hast folgende Möglichkeiten:\nDu behältst deine Änderungen und verwirfst die Anderen 1 2 3 - Lesen - Gamen - Schlafen Du verwirfst deine Änderungen und behältst die Anderen 1 2 3 - Lesen - Gamen - Gym Du behältst alle Änderungen 1 2 3 4 - Lesen - Gamen - Schlafen - Gym Du verwirfst beide Änderungen 1 2 - Lesen - Gamen Eine Mischung aus allen vorherigen Möglichkeiten 1 2 3 - Lesen - Gamen - Schlafen oder Gym Um einen Merge-Konflikt zu lösen, musst du also aus diesen Möglichkeiten auswählen. Du kannst das für jeden Konflikt unterschiedlich machen. Deine IDE wird dir dabei einige Hilfestellungen liefern, welche den Prozess etwas vereinfachen, siehe dazu die Felder weiter unten.\nKonflikt mit IntelliJ lösen IntelliJ hat ein eingebautes UI um Merge Konflikte zu lösen. JetBrains stellt eine super Anleitung zur Verfügung. Konflikt mit Visual Studio Code lösen Visual Studio Code hat sogar zwei verschiedene Arten, wie du Merge-Konflikte lösen kannst. Einen eher simpeln Ansatz, \"Inline Editor\" genannt, und einen der etwas mehr an IntelliJ erinnert, \"3-Way Editor\" genannt. Eine gute Anleitung zu beiden findest du hier. Vim schliessen Je nach Betriebssystem und Einstellungen, kann es sein das Git automatisch den Texteditor Vim öffnet. Das sieht dann etwa so aus wie im Bild unten. Um den Editor wieder zu schliessen, kannst du die folgende Schritte verwenden:\nESC drücken : drücken q! eintippen ENTER drücken Es gibt noch unzählige weitere Tools wie Meld oder vimdiff, welche dazu genutzt werden können Merge-Konflikte zu lösen. Du darfst dich gerne durchprobieren und das Tool wählen, welches dir am besten gefällt. Für die meisten reicht das Tooling ihrer IDE.\nSchritt 8: Änderungen vom Stash anwenden Jetzt können wir die Änderungen auf dem Stash, dem Master-Branch hinzufügen.\n1 git stash pop 0 Du wirst wieder einen Konflikt in der index.txt Datei erhalten. Löse den Konflikt. Du kannst das wieder mit dem Tool deiner Wahl machen.\nSpeichere die Datei und mache einen Commit.\n","categories":"","description":"Hands On Aufgabe für [Git](../../../docs/04_git/01_grundwissen)\n","excerpt":"Hands On Aufgabe für [Git](../../../docs/04_git/01_grundwissen)\n","ref":"/labs/04_git/01_grundlagen/","tags":"","title":"Git Hands On Aufgabe"},{"body":"Schritt 1: Initialisiere ein Git-Repository Öffne dein Terminal oder die Kommandozeile. Erstelle ein neues Verzeichnis. Navigiere in das gerade erstellte Verzeichnis. Initialisiere ein neues Git-Repository. 1 2 git init git status Schritt 2: Erstelle eine konfliktverursachende Datei Erstelle eine neue Datei mit dem Namen index.txt und füge einen Satz hinzu. Speichere die Datei und committe die initiale Version. 1 2 git add index.txt git commit -m \"Add index.txt\" Schritt 3: Erstelle einen neuen Branch und mache Änderungen Erstelle einen neuen Branch mit dem Namen feature/my-cool-feature. 1 2 git branch feature/my-cool-feature git switch feature/my-cool-feature Öffne die index.txt Datei und ändere den Inhalt. Die Änderung soll dabei auf der gleichen Zeile sein wie den Satz den du zuvor hinzugefügt hast. Z.B. Mein Satz zu Mein viel besserer Satz. Speichere die Datei. Schritt 4: Änderungen im Feature-Branch stashens Bevor du den Feature-Branch in den Master-Branch mergst, stashe zuerst die Änderungen. 1 2 git stash save \"My stashed changes\" git stash list Schritt 5: Konfliktverursachende Änderungen auf Master hinzufügen Wechsle zurück zum master-Branch. Öffne die index.txt Datei und ändere den Inhalt. Speichere die Datei und committe die Änderungen. 1 2 git add index.txt git commit -m \"Changed something in index.html\" Schritt 6: Änderungen aus dem Feature-Branch in den Master-Branch picken Übernimm nun den letzten Commit aus dem Feature-Branch in den Master-Branch, mithilfe von cherry-pick.\nMit git log --oneline den letzten Commit-Hash anzeigen, in diesem Fall wäre das ea95358.\n1 2 6238890 (HEAD -\u003e master) Changed something in index.html ea95358 (feature/my-cool-branch) Added index.txt Danach die Änderungen aus dem Feature-Branch cherry-picken.\n1 2 git log --oneline git cherry-pick \u003cCOMMIT-HASH\u003e Wenn alles richtige gemacht wurde, erscheint danach eine Warnung über einen Merge-Konflikt.\n1 2 3 4 Auto-merging index.txt CONFLICT (add/add): Merge conflict in index.txt error: could not apply ea95358... Added index.txt ... Schritt 7: Löse den Merge-Konflikt Um den Merge-Konflikt zu lösen, öffnest du am besten IntelliJ(empfohlen) oder Visual Studio Code. Du kannst es natürlich auch über das Terminal versuchen, wenn du mutig genug bist.\nGrundsätzlich entsteht ein Merge-Conflict, wenn am gleichen Ort unterschiedliche Änderungen vorgenommen wurden. Git kann dann die Änderungen nicht mehr automatisch zusammenführen (mergen).\nGit zeigt einen Merge-Konflikt mithilfe von \u003c\u003c\u003c, \u003e\u003e\u003e und === an. Der Text bei \u003c\u003c\u003c sind deine Änderungen, die Änderungen bei \u003e\u003e\u003e kommen aus dem Remote-Repository. Getrennt werden sie durch eine Zeile an Gleichzeichen ===. Oft abstrahiert deine IDE diese Darstellung jedoch noch.\nBei dieser List von Hobbies wurde lokal die Zeile “Schlafen” hinzugefügt, remote wurde auf der gleichen Zeile jedoch “Gym” hinzugefügt.\n1 2 3 4 5 6 7 - Lesen - Gamen \u003c\u003c\u003c\u003c\u003c\u003c\u003c HEAD - Schlafen ======= - Gym \u003e\u003e\u003e\u003e\u003e\u003e\u003e 3c55804e0fa4cac9002edb45443d4a9c95bc26b4 Um den Konflikt zu lösen hast folgende Möglichkeiten:\nDu behältst deine Änderungen und verwirfst die Anderen 1 2 3 - Lesen - Gamen - Schlafen Du verwirfst deine Änderungen und behältst die Anderen 1 2 3 - Lesen - Gamen - Gym Du behältst alle Änderungen 1 2 3 4 - Lesen - Gamen - Schlafen - Gym Du verwirfst beide Änderungen 1 2 - Lesen - Gamen Eine Mischung aus allen vorherigen Möglichkeiten 1 2 3 - Lesen - Gamen - Schlafen oder Gym Um einen Merge-Konflikt zu lösen, musst du also aus diesen Möglichkeiten auswählen. Du kannst das für jeden Konflikt unterschiedlich machen. Deine IDE wird dir dabei einige Hilfestellungen liefern, welche den Prozess etwas vereinfachen, siehe dazu die Felder weiter unten.\nKonflikt mit IntelliJ lösen IntelliJ hat ein eingebautes UI um Merge Konflikte zu lösen. JetBrains stellt eine super Anleitung zur Verfügung. Konflikt mit Visual Studio Code lösen Visual Studio Code hat sogar zwei verschiedene Arten, wie du Merge-Konflikte lösen kannst. Einen eher simpeln Ansatz, \"Inline Editor\" genannt, und einen der etwas mehr an IntelliJ erinnert, \"3-Way Editor\" genannt. Eine gute Anleitung zu beiden findest du hier. Vim schliessen Je nach Betriebssystem und Einstellungen, kann es sein das Git automatisch den Texteditor Vim öffnet. Das sieht dann etwa so aus wie im Bild unten. Um den Editor wieder zu schliessen, kannst du die folgende Schritte verwenden:\nESC drücken : drücken q! eintippen ENTER drücken Es gibt noch unzählige weitere Tools wie Meld oder vimdiff, welche dazu genutzt werden können Merge-Konflikte zu lösen. Du darfst dich gerne durchprobieren und das Tool wählen, welches dir am besten gefällt. Für die meisten reicht das Tooling ihrer IDE.\nSchritt 8: Änderungen vom Stash anwenden Jetzt können wir die Änderungen auf dem Stash, dem Master-Branch hinzufügen.\n1 git stash pop 0 Du wirst wieder einen Konflikt in der index.txt Datei erhalten. Löse den Konflikt. Du kannst das wieder mit dem Tool deiner Wahl machen.\nSpeichere die Datei und mache einen Commit.\n","categories":"","description":"Hands On Aufgabe für [Git](../../../docs/04_git/01_grundwissen)\n","excerpt":"Hands On Aufgabe für [Git](../../../docs/04_git/01_grundwissen)\n","ref":"/de/labs/04_git/01_grundlagen/","tags":"","title":"Git Hands On Aufgabe"},{"body":"Ziele Du kannst ein Google-Konto erstellen. Du kannst dich im Google Developer Portal anmelden. Du kannst einen API Key für die Custom Search API generieren. Du weißt, wie du den API Key sicher speicherst. ⏱️ Geschätzte Lesezeit: 10 Minuten | Umsetzen: 15 Minuten Google API Key erstellen Die folgenden Schritte leiten dich durch den Prozess um einen API Key für die Google APIs zu erhalten.\nBehandle den Key vertraulich. Er sollte nicht in einem Git-Repository gespeichert werden. Hier erfährst du, wie du es in unseren Übungen machen kannst. Öffne https://developers.google.com/?hl=de\nMelde Dich oben rechts an Erstelle ein neues Konto\nFalls du bereits ein Konto hast, welches Du benutzen willst, kannst Du die nachfolgenden Schritte überspringen\nDu kannst dir eine neue Email Adresse erstellen (nicht empfohlen)…\noder eine bestehende Email Adresse nehmen (empfohlen)\nNimm deine Email Adresse von SBB (vorname.name@sbb.ch) Auf https://developers.google.com/?hl=de Developers Program als Student\nAPI Key anfordern\nhttps://developers.google.com/custom-search/v1/overview?hl=de\nDen Key kopieren und sicher ablegen. Nicht ins Git-Repository. Vertraulich behandeln! Hier erfährst du, wie du es in unseren Übungen machen kannst. ","categories":"","description":"Für Übungen, welche API's von Google verwenden. Nur bei Bedarf.\n","excerpt":"Für Übungen, welche API's von Google verwenden. Nur bei Bedarf.\n","ref":"/docs/99_tools/diverses/google-api-key/","tags":"","title":"Google API Key"},{"body":"Ziele Ich weiss, was HTML ist und wofür es bei der Entwicklung von Webseiten genutzt wird. Ich kann zwischen HTML, CSS und JavaScript unterscheiden. Wie funktionieren Webseiten? Im Gegensatz zu Desktop-Programmen sollten Webseiten auf jedem Betriebssystem und Browser gleich laufen und aussehen. Damit das funktionieren kann, müssen die Webseiten so programmiert worden sein, dass sie von jedem Browser verstanden werden können.\nGenau das wird mit HTML erreicht. Jeder Browser versteht HTML.\nWas ist HTML? Beginnen wir mit der Definition der Abkürzung “HTML”. Diese steht für “HyperText Markup Language”. Aber was bedeutet das konkret?\nMit HyperText ist ein Dokument gemeint, das in der Regel nicht dafür gemacht ist, um von oben nach unten gelesen zu werden. HyperText enthält also z.B. Links, die auf andere Dokumente oder zu anderen Stellen auf der gleichen Seite führen. Unter Markup ist zu verstehen, dass das Dokument strukturiert (Kopfzeile, Hauptteil, Fusszeile) und formatiert (z.B. kursiver/fetter Text) ist.\nSomit ist HTML also eine Sprache, die alle Elemente auf einer Webseite beschreibt. Das bedeutet, dass HTML keine Programmiersprache ist. Code, der auf der Webseite ausgeführt wird, ist in JavaScript geschrieben.\nÜbersicht zu HTML, CSS und JavaScript (JS) Während deiner Einführung in die Webentwicklung wirst du die Begriffe “HTML”, “CSS” und “JavaScript” immer wieder hören bzw. lesen. Deswegen beginnen wir mit einem Überblick:\nIm HTML beschreibst du die Struktur einer Webseite und fügst auch die wichtigsten Elemente davon ein. Diese Elemente können Text, UI-Elemente, Bilder und vieles mehr sein.\nIn CSS beschreibst du, wie das HTML im Browser aussehen soll. Beispielsweise kannst du Schriftfarben, -arten, -grössen, das Aussehen von UI-Elementen und Layouts damit beschreiben.\nMöchtest du im Browser Code ausführen, dann geschieht das mit der Programmiersprache JavaScript. Zum Beispiel kannst du im HTML definieren, dass eine JavaScript-Funktion ausgeführt wird, wenn du auf einen Button klickst.\n","categories":"","description":"Modul #F3 - HTML und CSS - Einführung\n","excerpt":"Modul #F3 - HTML und CSS - Einführung\n","ref":"/docs/03_web/02_html_css/01_html-intro/","tags":"","title":"HTML"},{"body":"Ziele Ich weiss, was HTML ist und wofür es bei der Entwicklung von Webseiten genutzt wird. Ich kann zwischen HTML, CSS und JavaScript unterscheiden. Wie funktionieren Webseiten? Im Gegensatz zu Desktop-Programmen sollten Webseiten auf jedem Betriebssystem und Browser gleich laufen und aussehen. Damit das funktionieren kann, müssen die Webseiten so programmiert worden sein, dass sie von jedem Browser verstanden werden können.\nGenau das wird mit HTML erreicht. Jeder Browser versteht HTML.\nWas ist HTML? Beginnen wir mit der Definition der Abkürzung “HTML”. Diese steht für “HyperText Markup Language”. Aber was bedeutet das konkret?\nMit HyperText ist ein Dokument gemeint, das in der Regel nicht dafür gemacht ist, um von oben nach unten gelesen zu werden. HyperText enthält also z.B. Links, die auf andere Dokumente oder zu anderen Stellen auf der gleichen Seite führen. Unter Markup ist zu verstehen, dass das Dokument strukturiert (Kopfzeile, Hauptteil, Fusszeile) und formatiert (z.B. kursiver/fetter Text) ist.\nSomit ist HTML also eine Sprache, die alle Elemente auf einer Webseite beschreibt. Das bedeutet, dass HTML keine Programmiersprache ist. Code, der auf der Webseite ausgeführt wird, ist in JavaScript geschrieben.\nÜbersicht zu HTML, CSS und JavaScript (JS) Während deiner Einführung in die Webentwicklung wirst du die Begriffe “HTML”, “CSS” und “JavaScript” immer wieder hören bzw. lesen. Deswegen beginnen wir mit einem Überblick:\nIm HTML beschreibst du die Struktur einer Webseite und fügst auch die wichtigsten Elemente davon ein. Diese Elemente können Text, UI-Elemente, Bilder und vieles mehr sein.\nIn CSS beschreibst du, wie das HTML im Browser aussehen soll. Beispielsweise kannst du Schriftfarben, -arten, -grössen, das Aussehen von UI-Elementen und Layouts damit beschreiben.\nMöchtest du im Browser Code ausführen, dann geschieht das mit der Programmiersprache JavaScript. Zum Beispiel kannst du im HTML definieren, dass eine JavaScript-Funktion ausgeführt wird, wenn du auf einen Button klickst.\n","categories":"","description":"Modul #F3 - HTML und CSS - Einführung\n","excerpt":"Modul #F3 - HTML und CSS - Einführung\n","ref":"/de/docs/03_web/02_html_css/01_html-intro/","tags":"","title":"HTML"},{"body":"Aufgabe 1 - Input-Elemente Um zu zeigen, wie einfach Input-Elemente verwendet werden könnten, kannst du folgendes Beispiel ausprobieren:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u003ch2\u003eLogin\u003c/h2\u003e \u003cform action=\"https://www.w3schools.com/action_page.php\" method=\"get\"\u003e \u003clabel\u003eemail: \u003cinput type=\"email\" name=\"your-email\" /\u003e\u003c/label\u003e \u003cbr /\u003e \u003clabel for=\"pw\"\u003epassword:\u003c/label\u003e \u003cinput type=\"password\" name=\"your-password\" id=\"pw\" /\u003e \u003cbr /\u003e \u003clabel \u003e\u003cinput type=\"checkbox\" name=\"stay\" value=\"yes\" /\u003eStay logged in.\u003c/label \u003e \u003ch4\u003eFavorite Language?\u003c/h4\u003e \u003cp\u003e \u003cinput type=\"radio\" id=\"html\" name=\"fav_language\" value=\"HTML\" /\u003e \u003clabel for=\"html\"\u003eHTML\u003c/label\u003e\u003cbr /\u003e \u003cinput type=\"radio\" id=\"css\" name=\"fav_language\" value=\"CSS\" /\u003e \u003clabel for=\"css\"\u003eCSS\u003c/label\u003e\u003cbr /\u003e \u003c/p\u003e \u003cinput type=\"submit\" /\u003e \u003c/form\u003e Entwickle eine Registrierungsseite. Auf dieser Seite soll man mindestens folgendes angeben müssen:\nName Email Gewünschtes Passwort Mögliche Interessen (mittels Checkboxen) Geburtsdatum Lieblingsfarbe Geschlecht (mittels Radiobuttons) Handynummer Als Backend kannst du “https://www.w3schools.com/action_page.php” (wie im vorherigen Beispiel) verwenden. Schaue nach dem Klick an, wie die Daten übermittelt worden sind. Wie sieht die URL im Browser aus? Variiere die HTTP Request Method.\nAufgabe 2 - Inspiziere diese Seite Suche auf dieser Website (ja, auf dieser IT Ninjas-Seite) mit Hilfe der Entwicklertools ([F12]-Taste) den \u003cheader\u003e, eine \u003cnav\u003e und den \u003cfooter\u003e.\nNotiere dir deine Erkenntnisse. Versuche zudem folgende Fragen zu beantworten:\nWie ist diese Seite aufgebaut? Wo befinden sich \u003cheader\u003e, \u003cnav\u003e, usw.? Halte das in einer Skizze fest. Wie wurde die Übersicht (am linken Rand) und das rechte Aside (mit Git-Informationen) realisiert. Welche Tags und Attribute sind deiner Meinung nach die relevantesten? Würdest du das gleich realisieren? Oder was würdest du anders machen? Aufgabe 3 - Dokument als HTML Suche einen spanneden Text (z.B. aus einer alten Word-Datei, Wikipedia-Artikel, Anleitung). Dieser Text sollte mehrere Überschriften und Bilder besitzen. Setze diesen Text mit HTML um und versuche bereits, viele Semantic Tags zu verwenden. Zeige dein Resultat einem Praxisbildner.\nAufgabe 4 - persönliche Portfolio Erstelle eine reine HTML-Webseite, welche dein persönliches Portfolio darstellt. Die Seite soll folgende Struktur und Elemente beinhalten:\nNavigation\nDie Navigation besteht auf drei Elemente:\nÜber mich Hobbies Kontakt Beim Klicken auf einem Navigationsitem wird die Anzeige entsprechend geändert. Dazu siehe folgende Abschnitte.\nÜber mich\nWenn man auf “Über mich” klickt, erscheint eine ähnliche Seite wie hier dargestellt:\nHobbies\nWenn man auf “Hobbies” klickt, erscheint eine ähnliche Seite wie hier dargestellt:\nDie Texte unterhalb der Fotos sind Links auf entsprechende Webseiten, welche in einem neuen Browserfenster/-tab geöffnet werden.\nKontakt\nWenn man auf “Kontakt” klickt, erscheint eine ähnliche Seite wie hier dargestellt:\nWenn man auf “Github” oder “Twitter” usw. klickt, wird ein neues Browserfenster mit der richtigen Seite geöffnet\nHinweise:\nVerwende semantische Elemente wo nötig/sinnvoll. Hier geht es um die Struktur der Seite, nicht um das Styling. Es ist wichtig, dass die Elemente gemäss der Anforderungen funktionieren und dass das HTML gut strukturiert ist. ","categories":"","description":"Aufgaben zu Modul #F3 - HTML\n","excerpt":"Aufgaben zu Modul #F3 - HTML\n","ref":"/labs/03_web/01_html-css/01_html/","tags":"","title":"HTML - Aufgaben"},{"body":"Aufgabe 1 - Input-Elemente Um zu zeigen, wie einfach Input-Elemente verwendet werden könnten, kannst du folgendes Beispiel ausprobieren:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u003ch2\u003eLogin\u003c/h2\u003e \u003cform action=\"https://www.w3schools.com/action_page.php\" method=\"get\"\u003e \u003clabel\u003eemail: \u003cinput type=\"email\" name=\"your-email\" /\u003e\u003c/label\u003e \u003cbr /\u003e \u003clabel for=\"pw\"\u003epassword:\u003c/label\u003e \u003cinput type=\"password\" name=\"your-password\" id=\"pw\" /\u003e \u003cbr /\u003e \u003clabel \u003e\u003cinput type=\"checkbox\" name=\"stay\" value=\"yes\" /\u003eStay logged in.\u003c/label \u003e \u003ch4\u003eFavorite Language?\u003c/h4\u003e \u003cp\u003e \u003cinput type=\"radio\" id=\"html\" name=\"fav_language\" value=\"HTML\" /\u003e \u003clabel for=\"html\"\u003eHTML\u003c/label\u003e\u003cbr /\u003e \u003cinput type=\"radio\" id=\"css\" name=\"fav_language\" value=\"CSS\" /\u003e \u003clabel for=\"css\"\u003eCSS\u003c/label\u003e\u003cbr /\u003e \u003c/p\u003e \u003cinput type=\"submit\" /\u003e \u003c/form\u003e Entwickle eine Registrierungsseite. Auf dieser Seite soll man mindestens folgendes angeben müssen:\nName Email Gewünschtes Passwort Mögliche Interessen (mittels Checkboxen) Geburtsdatum Lieblingsfarbe Geschlecht (mittels Radiobuttons) Handynummer Als Backend kannst du “https://www.w3schools.com/action_page.php” (wie im vorherigen Beispiel) verwenden. Schaue nach dem Klick an, wie die Daten übermittelt worden sind. Wie sieht die URL im Browser aus? Variiere die HTTP Request Method.\nAufgabe 2 - Inspiziere diese Seite Suche auf dieser Website (ja, auf dieser IT Ninjas-Seite) mit Hilfe der Entwicklertools ([F12]-Taste) den \u003cheader\u003e, eine \u003cnav\u003e und den \u003cfooter\u003e.\nNotiere dir deine Erkenntnisse. Versuche zudem folgende Fragen zu beantworten:\nWie ist diese Seite aufgebaut? Wo befinden sich \u003cheader\u003e, \u003cnav\u003e, usw.? Halte das in einer Skizze fest. Wie wurde die Übersicht (am linken Rand) und das rechte Aside (mit Git-Informationen) realisiert. Welche Tags und Attribute sind deiner Meinung nach die relevantesten? Würdest du das gleich realisieren? Oder was würdest du anders machen? Aufgabe 3 - Dokument als HTML Suche einen spanneden Text (z.B. aus einer alten Word-Datei, Wikipedia-Artikel, Anleitung). Dieser Text sollte mehrere Überschriften und Bilder besitzen. Setze diesen Text mit HTML um und versuche bereits, viele Semantic Tags zu verwenden. Zeige dein Resultat einem Praxisbildner.\nAufgabe 4 - persönliche Portfolio Erstelle eine reine HTML-Webseite, welche dein persönliches Portfolio darstellt. Die Seite soll folgende Struktur und Elemente beinhalten:\nNavigation\nDie Navigation besteht auf drei Elemente:\nÜber mich Hobbies Kontakt Beim Klicken auf einem Navigationsitem wird die Anzeige entsprechend geändert. Dazu siehe folgende Abschnitte.\nÜber mich\nWenn man auf “Über mich” klickt, erscheint eine ähnliche Seite wie hier dargestellt:\nHobbies\nWenn man auf “Hobbies” klickt, erscheint eine ähnliche Seite wie hier dargestellt:\nDie Texte unterhalb der Fotos sind Links auf entsprechende Webseiten, welche in einem neuen Browserfenster/-tab geöffnet werden.\nKontakt\nWenn man auf “Kontakt” klickt, erscheint eine ähnliche Seite wie hier dargestellt:\nWenn man auf “Github” oder “Twitter” usw. klickt, wird ein neues Browserfenster mit der richtigen Seite geöffnet\nHinweise:\nVerwende semantische Elemente wo nötig/sinnvoll. Hier geht es um die Struktur der Seite, nicht um das Styling. Es ist wichtig, dass die Elemente gemäss der Anforderungen funktionieren und dass das HTML gut strukturiert ist. ","categories":"","description":"Aufgaben zu Modul #F3 - HTML\n","excerpt":"Aufgaben zu Modul #F3 - HTML\n","ref":"/de/labs/03_web/01_html-css/01_html/","tags":"","title":"HTML - Aufgaben"},{"body":"","categories":"","description":"Exercises zu HTML und CSS\n","excerpt":"Exercises zu HTML und CSS\n","ref":"/labs/03_web/01_html-css/","tags":"","title":"HTML und CSS - Aufgaben"},{"body":"","categories":"","description":"Exercises zu HTML und CSS\n","excerpt":"Exercises zu HTML und CSS\n","ref":"/de/labs/03_web/01_html-css/","tags":"","title":"HTML und CSS - Aufgaben"},{"body":"Ziel IntelliJ IDEA ist auf deinem Rechner installiert. Du kannst ein einfaches Projekt laden und ausführen. IntelliJ IDEA installieren Schritt 1: Download Wenn du bei der SBB in Ausbildung bist dann wähle hier die Ultimate Edition. Damit stehen dir alle Features zur Verfügung.\nWie du diese Version aktivierst, erfährst du weiter unten.\nÖffne https://www.jetbrains.com/idea/download. Wähle die Community Edition für dein Betriebssystem. Unterschied Community und Ultimate Edition Feature Community Edition Ultimate Edition Lizenz Kostenlos (Open Source) Kostenpflichtig (kommerziell) Sprachen-Support Java, Kotlin, Groovy, Scala Alle aus Community + mehr Web-Entwicklung ❌ ✅ HTML, CSS, JavaScript, etc. Framework-Support Grundlegend (z. B. Maven) ✅ Spring, Java EE, Micronaut Datenbank-Tools \u0026 SQL ❌ ✅ Integrierter DB-Support Remote Development ❌ ✅ (z. B. via JetBrains Gateway) Erweiterte Debugging-Tools Einfaches Debugging ✅ HTTP Client, Performance Profiler Enterprise Features ❌ ✅ (z. B. Jakarta EE, Web Services) Support \u0026 Updates Community-Support ✅ JetBrains-Support Die Community Edition eignet sich gut für reine Java/Kotlin-Entwicklung und reicht für die grundlegenden Module auf IT-Ninjas.\nDie Ultimate Edition ist ideal für professionelle Full-Stack- und Enterprise-Entwicklung. Sie wird in späteren Modulen (Angular, Spring Boot) benötigt wenn man nicht auf Visual Studio Code wechseln will.\nSchritt 2: Installation Lade die .exe-Datei herunter und starte sie. Wähle: Installationsverzeichnis Optional: Add launchers dir to the PATH Optional: .java-Dateien mit IntelliJ verknüpfen Klicke auf Install. Starte IntelliJ IDEA nach Abschluss der Installation. Lade die .dmg-Datei herunter und öffne sie. Ziehe das IntelliJ-Icon in den Ordner Applications. Starte IntelliJ IDEA. Lade das .tar.gz-Archiv herunter. Entpacke das Archiv (z. B. in ~/apps). Führe das Startskript bin/idea.sh aus. Schritt 3: Erststart Beim ersten Start:\nFrühere Einstellungen übernehmen? → Optional UI-Stil wählen (hell/dunkel) Diese Einstellungen kannst du später jederzeit anpassen.\nDas hier musst Du unbedingt lesen! Um einen positiven Lerneffekt zu erhalten, verzichten wir am Anfang auf die Unterstützung von KI.\nDie folgenden Schritte must du ausführen um Code-Vervollständigung innerhalb von IntelliJ auszuschalten.\nZIP-Datei herunterladen\nLade die bereitgestellte ZIP-Datei mit den IntelliJ-Settings herunter:\nDownload Editor-Settings\nZIP entpacken\nEntpacke die ZIP-Datei an einem Ort deiner Wahl.\nDu solltest danach die beiden Dateien sehen:\neditor.xml full.line.xml IntelliJ-Options-Verzeichnis finden\nDas Options-Verzeichnis liegt im Benutzereinstellungen-Ordner von IntelliJ IDEA.\nJe nach Betriebssystem findest du diesen hier:\nWindows:\nC:\\Users\\\u003cBENUTZERNAME\u003e\\AppData\\Roaming\\JetBrains\\IntelliJIdea\u003cVersion\u003e\\options macOS:\n~/Library/Application Support/JetBrains/IntelliJIdea\u003cVersion\u003e/options Linux:\n~/.config/JetBrains/IntelliJIdea\u003cVersion\u003e/options Ersetze \u003cVersion\u003e durch deine IntelliJ-Version, z. B. 2025.2.\nDateien kopieren\nKopiere die beiden Dateien editor.xml und full.line.xml in das options-Verzeichnis.\nIntelliJ neu starten\nSchließe IntelliJ IDEA vollständig und starte es neu, damit die Änderungen übernommen werden.\nFalls das options-Verzeichnis noch nicht existiert, starte IntelliJ einmal und beende es wieder – danach wird es automatisch angelegt. Denk daran, dass du dich verpflichtet hast, auf den Einsatz von KI zu verzichten. Bei Unsicherheiten gehe auf deinen Praxisbildner zu, damit er mit dir zusammen prüfen kann, ob alles korrekt eingestellt ist. Nach der Installation beginnt ein 30-tägiger Testzeitraum der Ultimate Edition.\nNutze diesen Zeitraum und fordere eine Lizenz an:\nBesuche https://omada.sbb.ch/home\nSuche nach der Gruppe DG_RBT_INTELLIJ-LICENSE\nKlicke auf Zugriff anfordern\nSobald du Zugriff hast, registriere IntelliJ:\nWähle Activate (another) License Wähle License Server Gib die Adresse https://sbb-license.fls.jetbrains.com ein Klicke auf Activate\nDanach ist IntelliJ Ultimate aktiviert.\nSchritt 4: JDK einrichten In der Ausbildung nutzen wir Eclipse Temurin JDK 21 (LTS) als Standard JDK.\nÖffne File → Project Structure… (Strg+Alt+Shift+S).\nLinks Platform Settings → SDKs.\nKlicke + → Download JDK\nWähle:\nVersion: 21 Anbieter: Eclipse Temurin, nicht Oracle! Den Installationsordner so belassen wie vorgeschlagen\nIntelliJ lädt und installiert das JDK automatisch.\n","categories":"","description":"Installation der IntelliJ IDEA\n","excerpt":"Installation der IntelliJ IDEA\n","ref":"/docs/99_tools/ide/intellij/01_installation/","tags":"","title":"IntelliJ installieren"},{"body":"IntelliJ IDEA ist eine moderne und leistungsstarke Entwicklungsumgebung (IDE), die dir das Programmieren spürbar erleichtert – besonders, wenn du mit Java arbeitest.\nDie IDE bietet viele Funktionen, die dir helfen, schneller zu programmieren, deinen Code besser zu verstehen und Fehler frühzeitig zu erkennen. IntelliJ schlägt passende Methoden vor, überprüft deinen Code in Echtzeit, unterstützt dich beim Testen – und vieles mehr.\nKurz gesagt: IntelliJ ist nicht nur ein Editor, sondern dein persönlicher Programmier-Coach.\nWir setzen IntelliJ bei it-ninja bewusst von Anfang an ein, damit du lernst, professionell zu arbeiten – so wie in der echten Arbeitswelt. Die gute Nachricht: Du musst nicht alles auf einmal verstehen. Wir steigen gemeinsam Schritt für Schritt ein – mit einfachen Projekten und Übungen, bei denen du IntelliJ kennenlernen und ausprobieren kannst.\nDamit du die Grundlagen wirklich verstehst, nutzen wir zu Beginn nur einen Teil der Funktionen. Viele automatische Hilfen und Assistenten sind zunächst deaktiviert – so lernst du, eigenständig zu denken und den Code selbst zu schreiben. Schritt für Schritt schalten wir später mehr Features frei. ","categories":"","description":"Mit IntelliJ IDEA lernst du von Anfang an, wie professionelle Softwareentwicklung funktioniert – effizient, smart und mit vielen Hilfestellungen.\n","excerpt":"Mit IntelliJ IDEA lernst du von Anfang an, wie professionelle …","ref":"/docs/99_tools/ide/intellij/","tags":"","title":"IntelliJ IDEA – dein Einstieg ins professionelle Programmieren"},{"body":"Ziele Ich weiss, wie ich IT-Ninjas nutze. Ich habe einen GitHub-Account erstellt, um an Diskussionen und Kommentaren teilzunehmen. Ich weiss, wie ich Kommentare verfasse und an Diskussionen teilnehme. Einführung Du befindest dich auf labs.it-ninjas.ch, einer Lernplattform, die dich auf deinem Weg begleiten wird. Diese Seite wird ständig weiterentwickelt und verbessert – und du kannst dazu beitragen!\nDie Plattform wird auf GitHub gehostet, ähnlich wie dein eigenes Git-Repository, welches du im nächsten Schritt erstellen wirst. Doch GitHub kann noch mehr:\nAuf jeder IT-Ninjas-Seite gibt es eine Kommentarfunktion, mit der du Fragen stellen, Probleme melden oder an Diskussionen teilnehmen kannst. Alle Kommentare werden auf der GitHub-Discussions-Seite von IT-Ninjas gespeichert. Wenn du oben rechts auf der Seite nachsiehst, solltest du einen Hyperlink zu der Kommentarfunktion finden. Klickst du darauf, scrollst du ans Ende der Seite. Dort findest du die Kommentarfunktion. Falls diese für dich nicht sichtbar oder gesperrt ist, musst du dich zuerst mit GitHub anmelden.\nGitHub Account Damit du teilnehmen kannst, benötigst du einen GitHub-Account. Falls du noch keinen hast, erstelle einen nach dieser Anleitung.\nHast du bereits einen GitHub-Account? Dann kannst du diesen nutzen. Sobald du dich registriert hast, klicke auf “Mit GitHub anmelden” auf IT-Ninjas – danach kannst du Kommentare schreiben!\nWie sind die Diskussionen zu benutzen? Bevor du eine Frage stellst oder einen Fehler meldest:\nLies alle vorhandenen Kommentare auf der Seite. Es ist gut möglich, dass dein Problem schon jemand angesprochen hat. Falls du eine passende Frage oder Meldung findest, kannst du darauf reagieren (z. B. mit einem 👍). Falls du keine passende Antwort findest, erstelle einen neuen Kommentar. Wichtiger Hinweis: Alles, was du in den Kommentaren postest, ist öffentlich sichtbar!\nBitte poste nicht: 🚫 Musterlösungen 🚫 Persönliche Informationen 🚫 Interne Firmeninformationen\nViel Erfolg auf IT-Ninjas!\n","categories":"","description":"Tools - IT-Ninja\n","excerpt":"Tools - IT-Ninja\n","ref":"/de/docs/01_tools/01_it-ninjas/","tags":"","title":"Willkommen bei IT-Ninjas"},{"body":"","categories":"","description":"Challenges zu Java Module\n","excerpt":"Challenges zu Java Module\n","ref":"/challenges/java/","tags":"","title":"Java Challenges"},{"body":"","categories":"","description":"Challenges zu Java Module\n","excerpt":"Challenges zu Java Module\n","ref":"/de/challenges/java/","tags":"","title":"Java Challenges"},{"body":"Was ist Java? Java ist eine objektorientierte Programmiersprache, die seit über zwei Jahrzehnten grosse Popularität geniesst. Die Entwicklung begann Anfang der 1990er-Jahre beim US-amerikanischen Unternehmen Sun Microsystems. 1995 erschien die erste Java-Version. Seit der Übernahme von Sun durch Oracle im Jahr 2010 wird Java von Oracle weiterentwickelt.\nAktuell erscheint alle sechs Monate eine neue Java-Version. Die zuletzt veröffentlichte Version ist Java 24 (März 2025). Die nächste geplante Version ist Java 25, ein Long-Term-Support-Release (LTS), das im September 2025 erscheinen soll.\nWichtige Merkmale von Java Plattformunabhängigkeit: «Write once, run anywhere» Java-Code wird nicht direkt von der Hardware ausgeführt. Stattdessen wird er vom Compiler in sogenannten Bytecode übersetzt. Dieser Bytecode wird von der Java Virtual Machine (JVM) interpretiert.\nDie JVM ist eine Software, die eine virtuelle Umgebung schafft – sie simuliert einen Computer innerhalb deines Rechners.\nWeil es JVMs für Windows, Linux und macOS gibt, kann derselbe Bytecode auf allen Plattformen ausgeführt werden, ohne Anpassung am Code.\nDas macht Java besonders plattformunabhängig: Einmal schreiben – überall ausführen.\nObjektorientierte Programmierung Java ist in erster Linie eine objektorientierte Sprache. Das bedeutet: Fast alles besteht aus Objekten, die bestimmte Eigenschaften (Daten) und Fähigkeiten (Methoden) besitzen.\nIn einem Programm beschreibst du Klassen – das sind Baupläne für Objekte.\nEin Beispiel: Ein Auto könnte als Objekt Eigenschaften wie Farbe, Marke oder Anzahl Sitze haben und Methoden wie fahren() oder stoppen().\nEin Java-Programm besteht aus vielen solcher Objekte, die zusammenarbeiten, um Aufgaben zu erfüllen.\nWeitere Programmierkonzepte in Java Neben der Objektorientierung unterstützt Java auch weitere Konzepte:\nGenerische Programmierung\nErmöglicht es, Klassen und Methoden so zu schreiben, dass sie mit beliebigen Datentypen arbeiten.\nBeispiel: List\u003cString\u003e oder List\u003cInteger\u003e.\nParallele Programmierung\nJava erlaubt es, mehrere Aufgaben gleichzeitig auszuführen – etwa mit Threads. Das ist hilfreich für performante Anwendungen.\nFunktionale Programmierung\nSeit Java 8 unterstützt Java Funktionen als Objekte (z. B. Lambdas). Das erlaubt einen funktionalen Stil – oft nützlich bei Streams und Events.\nProzedurale Programmierung\nBei der prozeduralen Programmierung steht nicht die Modellierung von Objekten im Vordergrund, sondern die Gliederung in Funktionen (in Java: statische Methoden), die auf Datenstrukturen zugreifen.\nAnstatt ein Objekt mit Methoden und Eigenschaften zu definieren, wird eine Datenstruktur verwendet, die an verschiedene Funktionen übergeben wird.\nGerade als Einsteiger wirst du viele Programme prozedural aufbauen. Du verwendest einfache Daten (z. B. int, String, Arrays oder Listen) und rufst Methoden auf, ohne eigene Objekte zu definieren. ¨ Das hilft dir, die Grundlagen der Programmierung zu lernen, bevor du dich mit objektorientierten Konzepten beschäftigst. Begriffe zum Nachschlagen Bytecode und Ausführung Java-Programme werden in Bytecode übersetzt – das ist ein plattformunabhängiger Zwischencode. Ausführbare Programme benötigen eine spezielle Methode namens main, z. B.:\n1 2 3 4 5 public class HelloWorld { public static void main(String[] args) { System.out.println(\"Hallo Java!\"); } } Mehrere Klassen und Bibliotheken werden oft in einer JAR-Datei (Java ARchive) zusammengefasst. Eine .jar ist technisch gesehen eine ZIP-Datei mit einem definierten Aufbau.\nKlassenpfad Der Klassenpfad (Classpath) sagt der JVM, wo sie nach Klassen und Bibliotheken suchen soll. Er kann beim Ausführen angegeben oder über Umgebungsvariablen gesetzt werden.\nGarbage Collector Java kümmert sich automatisch um die Speicherbereinigung. Nicht mehr benötigte Objekte werden durch den Garbage Collector entfernt – du musst dich nicht selbst darum kümmern, wie z. B. in C oder C++.\nDas vereinfacht die Programmierung und verhindert viele typische Speicherfehler.\nMultithreading Java unterstützt die gleichzeitige Ausführung von mehreren Threads. Ein Thread ist ein Teilprozess, der unabhängig vom Rest des Programms läuft.\nDas ist nützlich bei:\nparallelen Datenverarbeitungen Benutzeroberflächen Netzwerkanwendungen Jetzt starten: Java-Programmierung lernen\n","categories":"","description":"Alles, was du über Java wissen solltest – von den Grundlagen bis zu fortgeschrittenen Konzepten.\n","excerpt":"Alles, was du über Java wissen solltest – von den Grundlagen bis zu …","ref":"/docs/99_tools/programmiersprachen/java/","tags":"","title":"Java"},{"body":"Die Aufgabe besteht darin ein “Vier-Gewinnt” Spielfeld in Form eines zweidimensionalen Arrays zu überprüfen. Das zweidimensionale Array hat in beiden Dimensionen eine variable Grösse. Die zweite Dimension ist jedoch bei allen Arrays gleich gross.\nDas Ziel ist herauszufinden, ob auf einem gegebenen Spielfeld einer der Spieler gewonnen hat. Die Gewinnkombination in Form von vier aufeinanderfolgenden gleichen Feldern kann dabei horizontal, vertikal oder diagonal auf dem Spielfeld liegen. Im Spielfeld kommen drei Zeichen vor: “X” für Spielsteine von Spieler 1, “O” für Spielsteine von Spieler 2 und \" \" für ein Feld, wo noch kein Spielstein liegt.\nDie Methode, welche das Spielfeld überprüft liefert einen String als Rückgabewert zurück. Der Rückgabewert ist “X” falls Spieler 1 gewonnen hat, “O” wenn Spieler 2 gewonnen hat und \" \" wenn noch keiner der Spieler eine Gewinnkombination hat.\nDie Implementation muss in der folgenden Klasse gemacht werden:\n1 2 3 4 5 6 7 8 9 public class ConnectFourExtra implements ConnectFourCheck { @Override public String checkWin(String[][] board) { // TODO: Implementation here ... // TODO: Change return value according to the challenge description return \" \" + \"X\" + \"O\"; } } Das dazugehörige Interface kann einfach als neue Klasse im gleichen Package angelegt werden:\n1 2 3 interface ConnectFourCheck { String checkWin(String[][] board); } Wenn du an der Challenge teilnehmen willst, dann musst du die Aufgabe alleine lösen. Die Lösung vom Pult-Nachbar interessiert uns also (leider) nicht.\n","categories":"","description":"Challenge zu Modul #J1\n","excerpt":"Challenge zu Modul #J1\n","ref":"/challenges/java/java-grundlagen/01_basicchallenge/","tags":"","title":"Java Grundlagen Challenge"},{"body":"Die Aufgabe besteht darin ein “Vier-Gewinnt” Spielfeld in Form eines zweidimensionalen Arrays zu überprüfen. Das zweidimensionale Array hat in beiden Dimensionen eine variable Grösse. Die zweite Dimension ist jedoch bei allen Arrays gleich gross.\nDas Ziel ist herauszufinden, ob auf einem gegebenen Spielfeld einer der Spieler gewonnen hat. Die Gewinnkombination in Form von vier aufeinanderfolgenden gleichen Feldern kann dabei horizontal, vertikal oder diagonal auf dem Spielfeld liegen. Im Spielfeld kommen drei Zeichen vor: “X” für Spielsteine von Spieler 1, “O” für Spielsteine von Spieler 2 und \" \" für ein Feld, wo noch kein Spielstein liegt.\nDie Methode, welche das Spielfeld überprüft liefert einen String als Rückgabewert zurück. Der Rückgabewert ist “X” falls Spieler 1 gewonnen hat, “O” wenn Spieler 2 gewonnen hat und \" \" wenn noch keiner der Spieler eine Gewinnkombination hat.\nDie Implementation muss in der folgenden Klasse gemacht werden:\n1 2 3 4 5 6 7 8 9 public class ConnectFourExtra implements ConnectFourCheck { @Override public String checkWin(String[][] board) { // TODO: Implementation here ... // TODO: Change return value according to the challenge description return \" \" + \"X\" + \"O\"; } } Das dazugehörige Interface kann einfach als neue Klasse im gleichen Package angelegt werden:\n1 2 3 interface ConnectFourCheck { String checkWin(String[][] board); } Wenn du an der Challenge teilnehmen willst, dann musst du die Aufgabe alleine lösen. Die Lösung vom Pult-Nachbar interessiert uns also (leider) nicht.\n","categories":"","description":"Challenge zu Modul #J1\n","excerpt":"Challenge zu Modul #J1\n","ref":"/de/challenges/java/java-grundlagen/01_basicchallenge/","tags":"","title":"Java Grundlagen Challenge"},{"body":"Ziele Ich weiss, dass jede Anweisung mit einem Strichpunkt (auch bekannt als Semikolon: ;) abgeschlossen werden muss. Ich weiss, dass geschweifte Klammern einen Block definieren und ich verwende sie in jeder Kontrollstruktur, um die Codeblöcke voneinander abzugrenzen. Ich kenne die main-Methode und weiss, warum eine Applikation nur EINE main-Methode haben sollte. Ich kenne die Methode System.out.println und kann sie anwenden. Cheatsheet zum Herunterladen Core Java Cheatsheet\nEinführung Was ist Java? Java ist eine objektorientierte Programmiersprache, die schon seit über zwei Jahrzehnten grosse Popularität geniesst. Die Entwicklung von Java begann Anfang der 1990er-Jahre beim US-amerikanischen Hard- und Softwarehersteller Sun Microsystems. 1995 wurde die erste Version veröffentlicht. 2010 wurde Sun Microsystems von Oracle übernommen. Gegenwärtig erscheinen im Halbjahrestakt neue Java-Versionen; die nächste Version, Java 24, wird im März 2025 veröffentlicht.\nWichtigste Merkmale von Java Plattformunabhängigkeit: «Write once, Run anywhere» Programmiersprachen wie Java können von einem Computer nicht interpretiert werden. Diese Sprachen sind speziell implementiert, dass sie für Entwickler einfach zu verstehen und schreiben sind. Der Compiler ist ein Programm, das den von dir geschriebenen Code in eine andere Form umwandelt, die der Computer verstehen kann. In Java wandelt der Compiler den Quellcode in Bytecode um.\nBytecode ist ein Zwischencode, der nicht direkt von der Hardware deines Computers ausgeführt wird, sondern von einer speziellen Software, der Java Virtual Machine (JVM).\nDie Java Virtual Machine ist eine virtuelle Maschine, das heisst, sie simuliert einen Computer innerhalb deines Computers. Die JVM kann den Bytecode ausführen, egal ob der simulierte Computer auf Windows, Linux oder Mac OS läuft. Der Vorteil von Bytecode ist, dass er plattformunabhängig ist. Das bedeutet, dass du deinen Java-Code einmal schreibst und dann auf jedem Betriebssystem ausführen kannst, das eine JVM unterstützt, ohne den Code anpassen zu müssen.\nMehrfach-Paradigma Java ist in erster Linie eine objektorientierte Programmiersprache. Das bedeutet, dass in Java fast alles als ein Objekt dargestellt wird. Ein Objekt ist eine Art Bauplan, der verschiedene Eigenschaften (Daten) und Funktionen (Methoden) enthält. Diese Objekte basieren auf sogenannten Klassen, die als Vorlagen für das Erstellen von Objekten dienen.\nStell dir vor, du programmierst ein Spiel, in dem Autos vorkommen. Jedes Auto hat bestimmte Eigenschaften wie Farbe, Geschwindigkeit oder Marke. Diese Eigenschaften kannst du in einer Klasse namens Auto festlegen. Jedes einzelne Auto in deinem Spiel wäre dann ein Objekt, das auf dieser Klasse basiert – also eine Instanz (ein Exemplar) der Klasse Auto. Somit haben zum Beispiel ein Ferrari und ein Fiat eine Geschwindigkeit und eine Farbe, jedoch sind diese Werte bei beiden unterschiedlich.\nEin Java-Programm besteht also aus vielen dieser Objekte, die zusammenarbeiten und miteinander kommunizieren, um Aufgaben zu erledigen. Wenn wir ein Programm schreiben, beschreiben wir, wie diese Objekte miteinander interagieren sollen.\nJava unterstützt aber auch andere Programmierparadigmen, das heisst, andere Arten, wie man ein Programm strukturieren kann, unter anderem:\nGenerische Programmierung: Generische Programmierung erlaubt es, Methoden und Klassen so zu schreiben, dass sie mit verschiedenen Datentypen funktionieren. Statt für jeden Datentyp eine eigene Version zu schreiben, kannst du einen Platzhalter verwenden. Parallele Programmierung: Java ermöglicht es, dass mehrere Aufgaben gleichzeitig ausgeführt werden. Dies ist besonders nützlich, wenn Programme schneller und effizienter ausgeführt werden sollen. Funktionale Programmierung: Auch wenn Java hauptsächlich objektorientiert ist, unterstützt es teilweise auch funktionale Programmierung, bei der Funktionen wie Variablen behandelt und in andere Funktionen übergeben werden können. Hier wird weniger Fokus auf Objekte und Klassen gelegt. Ausführbarer Bytecode Eine kompilierte Java-Klasse, die bestimmte Voraussetzungen erfüllt (wie eine Main-Methode, siehe untern im Beispiel), kann direkt ausgeführt werden. Applikationen und Klassenbibliotheken bestehen oft aus mehreren Klassen, die in einer JAR-Datei (Java-Archiv) zusammengefasst sind. Diese Datei kann leicht verteilt und von der JVM ausgeführt werden. Eine JAR-Datei ist technisch gesehen eine komprimierte Datei im ZIP-Format.\nKlassenpfad Der Klassenpfad gibt der JVM an, wo sich die Java-Klassen befinden, die sie zum Ausführen benötigt. Diese Klassen können in Ordnern oder in JAR-Dateien abgelegt sein. Der Klassenpfad kann bei der Ausführung des Programms übergeben oder als Umgebungsvariable eingestellt werden.\nGarbage Collector Java kümmert sich automatisch um das Aufräumen nicht mehr benötigter Objekte im Speicher. Das sind also Daten, welche vom Programm nicht mehr verwendet werden. Diese Aufgabe übernimmt der sogenannte Garbage Collector, der zur Laufzeit (also wenn das Programm läuft) überflüssige Objekte entfernt. In anderen Programmiersprachen wie C oder C++ muss der Entwickler sich um das Aufräumen von ungenutzten Daten kümmern. Dies kann zu Fehler im Programm führen und macht die Entwicklung aufwendiger.\nMultithreading Java unterstützt die parallele Ausführung mehrerer Threads (kleine Subprozesse) innerhalb eines Programms. Dadurch können Aufgaben schneller und effizienter erledigt werden, besonders bei komplexen Anwendungen, welche eine grosse Anzahl an Daten bearbeiten.\nCode, Compile, Run Als Java-Entwickler/in schreibst du ein Programm in eine Textdatei mit der Erweiterung .java. Diese Datei enthält den Quellcode. Der Compiler (javac) wandelt diesen Quellcode in eine .class-Datei um, die den Bytecode enthält. Anschliessend führt die JVM den Bytecode aus. Der Prozess von „Code schreiben“ über „kompilieren“ bis hin zum „ausführen“ sieht einfach aus, doch die eigentliche Arbeit übernimmt die JVM, die den plattformunabhängigen Bytecode ausführt: Hello World Anhand des simplen Hello-World-Programms können wir bereits vieles über die zentralen Bestandteile einer Java-Anwendung erklären. Der folgende Quellcode ist in einer Datei mit dem Namen HelloWorld.java abgelegt.\n1 2 3 4 5 public class HelloWorld { public static void main(String[] args) { System.out.println(\"Hello, world!\"); } } Klasse definieren: Der Quellcode beginnt mit der Definition einer Klasse namens HelloWorld. Der Name der Klasse muss exakt mit dem Dateinamen übereinstimmen, also wie oben definiert: HelloWorld.java. Der Block der Klasse beginnt und endet mit geschweiften Klammern {}.\nDie main-Methode: Die main-Methode ist der Startpunkt jedes Java-Programms. Sie wird als Erstes aufgerufen, wenn du dein Programm ausführst. Der Name der Methode ist immer main und ihre Signatur lautet:\n1 public static void main(String[] args){} Dies bedeutet, dass die Methode öffentlich zugänglich (public) ist, zur Klasse selbst gehört (static) und sie keinen Rückgabewert hat (void).\nAusgabe auf die Konsole: Innerhalb der main-Methode befindet sich die Anweisung System.out.println(\"Hello, world!\");. Diese Anweisung gibt den Text „Hello, world!“ in der Konsole aus. Jede Anweisung in Java endet mit einem Semikolon.\nJetzt kennst du die Grundstruktur eines Java-Programms! Probiere es aus, indem du dein erstes Programm schreibst und kompilierst.\nJetzt bist du dran. Löse bitte die Aufgabe 1 in den Labs.\n","categories":"","description":"Modul #J1\n","excerpt":"Modul #J1\n","ref":"/de/docs/02_java/03_java-grundlagen/01_java_intro/","tags":"","title":"Java-Einführung"},{"body":"Aufgabe 1 - Seite mit Joke Schreibe eine Website, die auf Knopfdruck einen Witz anzeigt.\nVerwende hierfür die Juck Norris-API: GET https://api.chucknorris.io/jokes/random\nSolltest du fertig mit dieser Aufgabe sein, dann melde dich bei einem Praxisbildner.\nAufgabe 2 - Eine andere API anbinden Versuche, ein(e) andere(s) API/Backend anzubinden und etwas auf einer Website anzuzeigen.\nAufgabe 3 - Uhr Schreibe ein HTML, das eine Uhrzeit visuell anzeigt.\nDeine Website soll zentriert eine Uhrzeit anzeigen. Die Uhrzeit soll analog angezeigt werden - also mit Stunden-, Minuten- und Sekundenzeiger.\nEine analoge Uhr kannst du mit Hilfe von Vektorgrafiken (SVGs) oder Canvas rendern.\nDu kannst es aber auch mit gewöhnlichen HTML-Elementen versuchen.\nHilfestellungen zu\nSVG Canvas Aufgabe 4 - Global Scope, Function Scope und Block-Scope Im Kapitel ES6: Variablen deklarieren hast du die Funktionsweise vom Global und Function Scope kennengelernt mit einem Beispiel-Code mit console.log(...)s. In diesem Beispiel wurden alle Variablen mit var deklariert/definiert - also keine lets oder consts.\nÄndere in diesem Code alle vars zu lets oder consts.\nBeantworte folgende Fragen und dokumentiere deine Antworten:\nWas ist ein Scope? Was sind Global Scope, Function Scope und Block-Scope? Was sind die Unterschiede? Mit welchem Scope arbeitest du in Java? Begründe. Wie werden Variablen im globalen Scope definiert? Wie kannst du definieren, welche Variable welchen Scope haben soll? Wann könnte die Verwendung von var sinnvoll sein? Aufgabe 5 - Nummern Liste Erstelle eine HTML-Seite, auf der ein Benutzer eine Liste von Zahlen eingeben kann. Die Eingabe soll geprüft werden, damit der Benutzer nur Zahlen eingeben kann. Der Benutzer kann die Liste speichern und dann Operationen auf der Liste durchführen lassen. Es sind folgende Operationen gefordert:\nDie grösste Zahl der Liste finden. Die kleinste Zahl der Liste finden. Die Summe aller geraden Zahlen der Liste finden. Die Summe der ungeraden Zahlen der Liste finden. Die Liste der grösse nach sortieren. Alle Zahlen der Liste zusammenrechnen. Den Durchschnitt der Liste errechnen. Die Ergebnisse der Operationen sollen dem Benutzer im HTML angezeigt werden.\nAufgabe 6 - Die optionalen Import-Inseln Entwerfe eine HTML-Seite, welche nachfolgendes JavaScript als Daten-Grundlage verwendet.\nHierfür musst du eine Klasse Island in der Datei island.js mit genau EINEM Konstruktor erstellen. Auf der HTML-Seite zeigst du alle Inseln an. Wenn eine Insel einen bestimmten Wert besitzt, wird dieser Wert angezeigt, ansonsten nicht. Wenn die Insel ein Bild besitzt, blendest du dieses ein. Das nachfolgende Script darfst du NICHT abändern (auch keine geschweiften Klammern beim Import hinzufügen). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import Island from \"./island.js\"; export const islands = [ new Island({ name: \"Atlantis\" }), new Island({ name: \"Maldives\", country: \"Maldives\", imageUrl: \"https://www.planetware.com/photos-large/SEY/best-islands-maldives.jpg\", }), new Island({ name: \"Bora Bora\", country: \"French Polynesia\", imageUrl: \"https://www.planetware.com/photos-large/SEY/best-islands-bora-bora.jpg\", }), new Island({ name: \"Seychelles\", country: \"Seychelles\", imageUrl: \"https://www.planetware.com/photos-large/SEY/best-islands-seychelles.jpg\", }), new Island({ name: \"Diomede\", imageUrl: \"https://upload.wikimedia.org/wikipedia/commons/thumb/8/8e/Little_Diomede_Island_village.jpeg/1280px-Little_Diomede_Island_village.jpeg\", }), ]; for (const island of islands) { console.info( `Explore the island ${island.name} in ${ island.country ?? \"an unknown country\" }: ${island.imageUrl ?? \"no image available :/\"}`, ); } Aufgabe 7 Schreibe eine Funktion, die ein Array von Objekten erwartet. Jedes Objekt im Array repräsentiert einen Schüler mit den folgenden Eigenschaften:\nname: Der Name des Schülers grades: Ein Array von Noten des Schülers (in Dezimalzahlen) Jeder Schüler darf nur einmal vorkommen, also keine Duplikate.\nDie Funktion soll ein Promise zurückgeben, das den Durchschnitt der Noten aller Schüler berechnet und als Ergebnis ein Objekt zurückgibt, das den Durchschnitt als eine Dezimalzahl und eine Beschreibung des Durchschnitts enthält. Die Beschreibung sollte basierend auf folgendem generiert werden:\nWenn der Durchschnitt 6,0 ist, soll die Beschreibung “Sehr gut” sein. Wenn der Durchschnitt grösser oder gleich 5,0 und kleiner als 6,0 ist, soll die Beschreibung “Gut” sein. Wenn der Durchschnitt grösser oder gleich 4,0 und kleiner als 5,0 ist, soll die Beschreibung “Befriedigend” sein. Wenn der Durchschnitt grösser oder gleich 3,0 und kleiner als 4,0 ist, soll die Beschreibung “Ausreichend” sein. Wenn der Durchschnitt kleiner als 3,0 ist, soll die Beschreibung “Mangelhaft” sein. Schreibe zusätzlich eine Funktion, um neue Schüler zu erfassen. Der zu erfassende Schüler darf jedoch noch nicht existieren ansonsten soll eine Exception geworfen werden. Auch die Noten sollen validiert werden so, dass nur Dezimalzahlen als Noten akzeptiert werden und die Dezimalzahl muss zwischen 1.0 und 6.0 liegen.\nNoch zu ergänzen sind je eine Funktion, welche beide auch ein Array von Schülern erwarten. Die eine Funktion soll den Schüler mit der besten und die andere Funktion mit dem schlechtesten Durchschnitt herausfinden. Die Funktionen sollen den Namen des Schülers und dessen Durchschnitt zurückgegeben. Versuche diese beiden Funktionen mit so wenig Redundanzen wie möglich zu schreiben (evtl. kann man eine Funktion draus machen).\nDie letzte Funktion sollte ein Array von Schülern entgegennehmen und sie anhand des Durchschnitts ordnen. Der schlechteste Durchschnitt kommt zuerst. Die Funktion soll ein Promise mit nur den Namen aller Schüler zurückgeben, nachdem diese sortiert wurden.\nSchreibe ein HTML-File, in welchem man neue Schüler hinzufügen kann und wo die Ergebnisse aus den Funktionen angezeigt werden.\n","categories":"","description":"Aufgaben zu Modul #F4 - JavaScript\n","excerpt":"Aufgaben zu Modul #F4 - JavaScript\n","ref":"/labs/03_web/02_javascript/01_javascript/","tags":"","title":"JavaScript - Aufgaben"},{"body":"Aufgabe 1 - Seite mit Joke Schreibe eine Website, die auf Knopfdruck einen Witz anzeigt.\nVerwende hierfür die Juck Norris-API: GET https://api.chucknorris.io/jokes/random\nSolltest du fertig mit dieser Aufgabe sein, dann melde dich bei einem Praxisbildner.\nAufgabe 2 - Eine andere API anbinden Versuche, ein(e) andere(s) API/Backend anzubinden und etwas auf einer Website anzuzeigen.\nAufgabe 3 - Uhr Schreibe ein HTML, das eine Uhrzeit visuell anzeigt.\nDeine Website soll zentriert eine Uhrzeit anzeigen. Die Uhrzeit soll analog angezeigt werden - also mit Stunden-, Minuten- und Sekundenzeiger.\nEine analoge Uhr kannst du mit Hilfe von Vektorgrafiken (SVGs) oder Canvas rendern.\nDu kannst es aber auch mit gewöhnlichen HTML-Elementen versuchen.\nHilfestellungen zu\nSVG Canvas Aufgabe 4 - Global Scope, Function Scope und Block-Scope Im Kapitel ES6: Variablen deklarieren hast du die Funktionsweise vom Global und Function Scope kennengelernt mit einem Beispiel-Code mit console.log(...)s. In diesem Beispiel wurden alle Variablen mit var deklariert/definiert - also keine lets oder consts.\nÄndere in diesem Code alle vars zu lets oder consts.\nBeantworte folgende Fragen und dokumentiere deine Antworten:\nWas ist ein Scope? Was sind Global Scope, Function Scope und Block-Scope? Was sind die Unterschiede? Mit welchem Scope arbeitest du in Java? Begründe. Wie werden Variablen im globalen Scope definiert? Wie kannst du definieren, welche Variable welchen Scope haben soll? Wann könnte die Verwendung von var sinnvoll sein? Aufgabe 5 - Nummern Liste Erstelle eine HTML-Seite, auf der ein Benutzer eine Liste von Zahlen eingeben kann. Die Eingabe soll geprüft werden, damit der Benutzer nur Zahlen eingeben kann. Der Benutzer kann die Liste speichern und dann Operationen auf der Liste durchführen lassen. Es sind folgende Operationen gefordert:\nDie grösste Zahl der Liste finden. Die kleinste Zahl der Liste finden. Die Summe aller geraden Zahlen der Liste finden. Die Summe der ungeraden Zahlen der Liste finden. Die Liste der grösse nach sortieren. Alle Zahlen der Liste zusammenrechnen. Den Durchschnitt der Liste errechnen. Die Ergebnisse der Operationen sollen dem Benutzer im HTML angezeigt werden.\nAufgabe 6 - Die optionalen Import-Inseln Entwerfe eine HTML-Seite, welche nachfolgendes JavaScript als Daten-Grundlage verwendet.\nHierfür musst du eine Klasse Island in der Datei island.js mit genau EINEM Konstruktor erstellen. Auf der HTML-Seite zeigst du alle Inseln an. Wenn eine Insel einen bestimmten Wert besitzt, wird dieser Wert angezeigt, ansonsten nicht. Wenn die Insel ein Bild besitzt, blendest du dieses ein. Das nachfolgende Script darfst du NICHT abändern (auch keine geschweiften Klammern beim Import hinzufügen). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import Island from \"./island.js\"; export const islands = [ new Island({ name: \"Atlantis\" }), new Island({ name: \"Maldives\", country: \"Maldives\", imageUrl: \"https://www.planetware.com/photos-large/SEY/best-islands-maldives.jpg\", }), new Island({ name: \"Bora Bora\", country: \"French Polynesia\", imageUrl: \"https://www.planetware.com/photos-large/SEY/best-islands-bora-bora.jpg\", }), new Island({ name: \"Seychelles\", country: \"Seychelles\", imageUrl: \"https://www.planetware.com/photos-large/SEY/best-islands-seychelles.jpg\", }), new Island({ name: \"Diomede\", imageUrl: \"https://upload.wikimedia.org/wikipedia/commons/thumb/8/8e/Little_Diomede_Island_village.jpeg/1280px-Little_Diomede_Island_village.jpeg\", }), ]; for (const island of islands) { console.info( `Explore the island ${island.name} in ${ island.country ?? \"an unknown country\" }: ${island.imageUrl ?? \"no image available :/\"}`, ); } Aufgabe 7 Schreibe eine Funktion, die ein Array von Objekten erwartet. Jedes Objekt im Array repräsentiert einen Schüler mit den folgenden Eigenschaften:\nname: Der Name des Schülers grades: Ein Array von Noten des Schülers (in Dezimalzahlen) Jeder Schüler darf nur einmal vorkommen, also keine Duplikate.\nDie Funktion soll ein Promise zurückgeben, das den Durchschnitt der Noten aller Schüler berechnet und als Ergebnis ein Objekt zurückgibt, das den Durchschnitt als eine Dezimalzahl und eine Beschreibung des Durchschnitts enthält. Die Beschreibung sollte basierend auf folgendem generiert werden:\nWenn der Durchschnitt 6,0 ist, soll die Beschreibung “Sehr gut” sein. Wenn der Durchschnitt grösser oder gleich 5,0 und kleiner als 6,0 ist, soll die Beschreibung “Gut” sein. Wenn der Durchschnitt grösser oder gleich 4,0 und kleiner als 5,0 ist, soll die Beschreibung “Befriedigend” sein. Wenn der Durchschnitt grösser oder gleich 3,0 und kleiner als 4,0 ist, soll die Beschreibung “Ausreichend” sein. Wenn der Durchschnitt kleiner als 3,0 ist, soll die Beschreibung “Mangelhaft” sein. Schreibe zusätzlich eine Funktion, um neue Schüler zu erfassen. Der zu erfassende Schüler darf jedoch noch nicht existieren ansonsten soll eine Exception geworfen werden. Auch die Noten sollen validiert werden so, dass nur Dezimalzahlen als Noten akzeptiert werden und die Dezimalzahl muss zwischen 1.0 und 6.0 liegen.\nNoch zu ergänzen sind je eine Funktion, welche beide auch ein Array von Schülern erwarten. Die eine Funktion soll den Schüler mit der besten und die andere Funktion mit dem schlechtesten Durchschnitt herausfinden. Die Funktionen sollen den Namen des Schülers und dessen Durchschnitt zurückgegeben. Versuche diese beiden Funktionen mit so wenig Redundanzen wie möglich zu schreiben (evtl. kann man eine Funktion draus machen).\nDie letzte Funktion sollte ein Array von Schülern entgegennehmen und sie anhand des Durchschnitts ordnen. Der schlechteste Durchschnitt kommt zuerst. Die Funktion soll ein Promise mit nur den Namen aller Schüler zurückgeben, nachdem diese sortiert wurden.\nSchreibe ein HTML-File, in welchem man neue Schüler hinzufügen kann und wo die Ergebnisse aus den Funktionen angezeigt werden.\n","categories":"","description":"Aufgaben zu Modul #F4 - JavaScript\n","excerpt":"Aufgaben zu Modul #F4 - JavaScript\n","ref":"/de/labs/03_web/02_javascript/01_javascript/","tags":"","title":"JavaScript - Aufgaben"},{"body":"Persistente Notenverwaltungssystem Schreibe eine Konsolen-basierte Java Anwendung, welche deine Schulnoten verwaltet und in einer Datenbank persistiert.\nDie Anwendung soll mindestens die folgende Funktionalität beinhalten:\nNeue Note für ein bestimmtes Fach erfassen (inkl. Datum) Eine bestehende Note löschen Eine bestehende Note bearbeiten Den aktuellen Notenstand eines Fachs ausgeben (Auflistung aller Noten und die Durchschnittsnote) Die Durchschnittsnoten aller Fächer ausgeben (#Zeugnis) Verwende eine MariaDB und setzte sie selbst auf. Den nötigen Treiber dazu findest du im Internet. Die Datenbank muss mindestens die folgenden Tabellen beinhalten:\nSCHOOL_SUBJECT - beinhaltet alle Schulfächer GRADE - beinhaltet alle gültigen Noten zwischen 1 und 6 (in 0.25 Stufen -\u003e also 1, 1.25. 1.5, 1.75, 2 usw..) SCHOOL_SUBJECT_GRADE - beinhaltet die Relation zwischen Schulfächern und Noten. Jede Zeile stellt eine Note für ein Fach an einem bestimmten Tag dar. Nutze die folgende Maven-Dependency in deinem pom.xml File:\n1 2 3 4 5 \u003cdependency\u003e \u003cgroupId\u003eorg.mariadb.jdbc\u003c/groupId\u003e \u003cartifactId\u003emariadb-java-client\u003c/artifactId\u003e \u003cversion\u003e3.1.0\u003c/version\u003e \u003c/dependency\u003e Achte auf korrektes Exception-Handling (denke an “try with resources”) und sauberen Code.\nZudem wird erwartet, dass ein eigenes Testing (wie in J4 Testing gelernt) zu der Umsetzung gehört.\nHier kannst du zurück zur Theorie.\n","categories":"","description":"Modul #J7 - JDBC\n","excerpt":"Modul #J7 - JDBC\n","ref":"/labs/02_java/11_java-jdbc/01_jdbc_exercises/","tags":"","title":"JDBC - Aufgaben"},{"body":"Persistente Notenverwaltungssystem Schreibe eine Konsolen-basierte Java Anwendung, welche deine Schulnoten verwaltet und in einer Datenbank persistiert.\nDie Anwendung soll mindestens die folgende Funktionalität beinhalten:\nNeue Note für ein bestimmtes Fach erfassen (inkl. Datum) Eine bestehende Note löschen Eine bestehende Note bearbeiten Den aktuellen Notenstand eines Fachs ausgeben (Auflistung aller Noten und die Durchschnittsnote) Die Durchschnittsnoten aller Fächer ausgeben (#Zeugnis) Verwende eine MariaDB und setzte sie selbst auf. Den nötigen Treiber dazu findest du im Internet. Die Datenbank muss mindestens die folgenden Tabellen beinhalten:\nSCHOOL_SUBJECT - beinhaltet alle Schulfächer GRADE - beinhaltet alle gültigen Noten zwischen 1 und 6 (in 0.25 Stufen -\u003e also 1, 1.25. 1.5, 1.75, 2 usw..) SCHOOL_SUBJECT_GRADE - beinhaltet die Relation zwischen Schulfächern und Noten. Jede Zeile stellt eine Note für ein Fach an einem bestimmten Tag dar. Nutze die folgende Maven-Dependency in deinem pom.xml File:\n1 2 3 4 5 \u003cdependency\u003e \u003cgroupId\u003eorg.mariadb.jdbc\u003c/groupId\u003e \u003cartifactId\u003emariadb-java-client\u003c/artifactId\u003e \u003cversion\u003e3.1.0\u003c/version\u003e \u003c/dependency\u003e Achte auf korrektes Exception-Handling (denke an “try with resources”) und sauberen Code.\nZudem wird erwartet, dass ein eigenes Testing (wie in J4 Testing gelernt) zu der Umsetzung gehört.\nHier kannst du zurück zur Theorie.\n","categories":"","description":"Modul #J7 - JDBC\n","excerpt":"Modul #J7 - JDBC\n","ref":"/de/labs/02_java/11_java-jdbc/01_jdbc_exercises/","tags":"","title":"JDBC - Aufgaben"},{"body":" Voraussetzung Du weisst, was mit Konsole gemeint ist. Du kannst Ausgaben auf die Konsole machen. Du weisst wie und warum man Zeichen escapen muss. Wir stellen dir bei den Übungen jeweils komplette Projekte zur Verfügung. Du musst grundsätzlich nur dort was anpassen, wo die folgende Kommentarzeile steht:\nKopieren // IT-Ninja: Füge hier Deinen Code ein: 1 // IT-Ninja: Füge hier Deinen Code ein: Alles andere kannst du für den Moment ignorieren. Wir erklären dir die einzelnen Zeilen Schritt für Schritt in den Modulen.\nVorbereitungsarbeiten Drücke auf den Pfeil links um eine detaillierte Anleitung zu erhalten, wie Du den Quellcode auf deinem Rechner ablegen sollst.\nDiese Schritte musst du bei jeder Übung erneut machen. Jede Übung hat ein eigenes ZIP-File, welches du bei dir an die richtige Stelle kopieren musst. Die Anleitung zeigt dir ziemlich gut, wie das geht… Liess vor allem am Anfang die detaillierte Anleitung gut durch und befolge die Schritte exakt. Sie helfen dir, deinen Quellcode gut organisiert, strukturiert und sicher zu verwalten. Falls du die Anleitung schon auswendig kennst, findest du den Quellcode zur Übung direkt hier: Download | Online anschauen\nNeu bei it-ninja?\nDie Anleitung enthält einige Befehle und Fachbegriffe, die dir möglicherweise noch nichts sagen. Mach dir deswegen keine Sorgen – in den kommenden Modulen erklären wir dir alles Schritt für Schritt. Schon bald wirst auch du ein it-ninja sein. Um die folgenden Aufgaben erfolgreich umzusetzen, führe diese Schritte aus:\nBeim ersten Mal:\nIntelliJ IDEA installieren → !*IntelliJ IDEA einrichten Git-Repository einrichten → !*Persönliches Git-Repository Öffne eine !*CMD-Shell und wechsle ins Verzeichnis deines Git-Repositories:\nKopieren cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git status 1 2 cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git status Kopieren cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git status 1 2 cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git status Stelle sicher, dass alle Dateien im Git-Repository committed sind. Mit git status erhältst du eine Übersicht: Kopieren git status 1 git status Falls du bei diesem Befehl einen roten Text siehst, musst du zuerst die aktuellen Dateien sichern:\nKopieren git add . git commit -m \"[gescheiter Kommentar]\" 1 2 git add . git commit -m \"[gescheiter Kommentar]\" Erstelle oder wechsle in den Template Branch:\nBeim ersten Mal musst du einen Template Branch erstellen:\nKopieren git checkout -b \"templates\" 1 git checkout -b \"templates\" Falls er bereits existiert, kannst du einfach switchen:\nKopieren git switch \"templates\" 1 git switch \"templates\" Lade den Source-Code zu den Übungen herunter und entpacke ihn im Root-Verzeichnis deines lokalen Repositories:\n[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\nDen Source-Code findest du hier: Download | Online anschauen\nCommitte den originalen Source-Code, damit er sicher im Repository gespeichert ist:\nKopieren git add . git commit -m \"Add it-ninja_02_java_03_java-grundlagen_01_console\" git push 1 2 3 git add . git commit -m \"Add it-ninja_02_java_03_java-grundlagen_01_console\" git push Erstelle einen neuen Branch, um deine Lösung zu implementieren: Kopieren git checkout -b \"labs/it-ninja_02_java_03_java-grundlagen_01_console\" 1 git checkout -b \"labs/it-ninja_02_java_03_java-grundlagen_01_console\" Hier kannst du auch einen kürzeren Namen wählen. Verwende labs am Anfang des Branch-Namens für Branches, die deinen eigenen Code enthalten.\nStelle dir einen Branch vorerst als Ordner vor. Jeder Ordner enthält eine Version oder einen Stand von deinem Quellcode. Du kannst dann mit git zwischen diesen Ordern hin und her wechseln, sie vergleichen aber später auch zusammenführen.\nPro-Tipp:\nDu kannst jederzeit einen weiteren Branch erstellen – z. B. wenn du etwas ausprobieren möchtest. Alternativ kannst du auch in der Git-History einen alten Stand wiederherstellen, was aber weniger flexibel ist. Starte IntelliJ und öffne mit File → Open das Verzeichnis mit dem Source-Code. Du musst mit IntelliJ den Ordner suchen, welches einen Ordner src oder die Datei pom.xml enthält. Ansonsten wird IntelliJ Mühe haben, dir das Programm zu kompilieren. Wenn du alles korrekt gemacht hast, findest du das Projekt hier:\nKopieren `[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\\02_java\\03_java-grundlagen\\01_console` 1 `[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\\02_java\\03_java-grundlagen\\01_console` Kopieren `[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\\02_java/03_java-grundlagen/01_console` 1 `[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\\02_java/03_java-grundlagen/01_console` Falls du zum ersten Mal mit IntelliJ arbeitest, findest du !*hier eine Anleitung, wie man ein Programm startet. Um das Programm zu starten musst du jeweils die Datei Main.java öffenen. Dann sollte in IntelliJ oben rechts ein grünes Dreieck vorhanden sein, welches das Programm startet. Nun bist du bereit, die untenstehenden Aufgaben zu lösen.\nWenn du alle Änderungen gemacht hast und mit der Übung fertig bist, oder einen ‘Zwischenstand’ festhalten willst, führe die folgenden Befehle aus um das Repository auf dem Server zu speichern (von wo du es geklont hast):\nKopieren cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git add --all git commit -m \"Kurzer Kommentar\" 1 2 3 cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git add --all git commit -m \"Kurzer Kommentar\" Kopieren cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git add . git commit -m \"Kurzer Kommentar\" 1 2 3 cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git add . git commit -m \"Kurzer Kommentar\" Wenn du deine Änderungen auf dem Git-Server sichern willst, musst du das mit einem push machen.\nBeim ersten mal musst du git noch mitteilen, wie der Branch auf dem Git-Server heissen soll:\nKopieren git push --set-upstream origin labs/it-ninja_02_java_03_java-grundlagen_01_console 1 git push --set-upstream origin labs/it-ninja_02_java_03_java-grundlagen_01_console Bei weiteren pushes wird es dann einfacher:\nKopieren git push 1 git push Die meisten Übungen sind professionell strukturiert – so wie in echten Softwareprojekten. Zu gutem Code gehören auch Tests, die sicherstellen, dass dein Code wie erwartet funktioniert. Sofern nicht anders erwähnt, kannst du mit folgendem Befehl im Root-Verzeichnis des Projekts (dort, wo sich auch die pom.xml befindet) überprüfen, ob du die Aufgabe korrekt gelöst hast:\n1 mvn test Viel Erfolg!\nAufgabe 1 - Hello World Passe den Code an damit Hello World auf der Konsole ausgegeben wird.\nIm zur Übung gehörendem Source kannst Du die Änderung an folgender Stelle machen:\nsrc\\main\\java\\ch\\itninja\\labs\\basicexercises\\HelloWorld.java:\n1 2 3 4 5 public static void printHelloWorld(){ // IT-Ninja: Füge hier Deinen Code ein: } Aufgabe 2 - Ascii House Zeichne ein Haus in der Konsole. Du darfst dazu folgende Zeichen verwenden:\n'/', '\\', '+', '-', '_', '[', ']', '|', Leerzeichen (' ') Im zur Übung gehörendem Source kannst Du die Änderung an folgender Stelle machen:\nsrc\\main\\java\\ch\\itninja\\labs\\basicexercises\\AsciiHouse.java:\n1 2 3 4 5 public static void printHouse(){ // IT-Ninja: Füge hier Deinen Code ein: } Hinweis: Vorsicht bei '\\', das ist ein besonderes Zeichen in einem String und muss escaped werden, das heisst für ein '\\' muss man innerhalb von einem String das Zeichen zweimal schreiben → \".\\\\.\"\nFalls unklar ist, was hier gemeint ist, schau dir ASCII-Art an.\nHier eine Katze als Beispiel:\n1 2 3 /\\_/\\ ( o.o ) \u003e ^ \u003c Aufgabe 3 - Ascii Swiss Flag Zeichne eine Schweizer Fahne. Die Fahne muss einen Rahmen haben. Du darfst dazu folgende Zeichen verwenden:\nIm Rahmen: '|', '-', '+'', Leerzeichen (' ') Innerhalb: '|', '-', '+', '*', '=', '@'', Leerzeichen (' ') Im zur Übung gehörendem Source kannst Du die Änderung an folgender Stelle machen:\nsrc\\main\\java\\ch\\itninja\\labs\\basicexercises\\AsciiSwissFlag.java:\n1 2 3 4 5 public static void printSwissFlag(){ // IT-Ninja: Füge hier Deinen Code ein: } Falls unklar ist, was hier gemeint ist, schau dir ASCII-Art an.\nHier ist die japanische Flagge als Beispiel:\n1 2 3 4 5 6 7 8 9 ------------------ | | | @@@@ | | @@@@@@@@ | | @@@@@@@@@@ | | @@@@@@@@ | | @@@@ | | | ------------------ ","categories":"","description":"Mit diesen Übungen kannst du dein Wissen über die Ausgabe auf die Kommandozeile (Konsole) vertiefen.\n","excerpt":"Mit diesen Übungen kannst du dein Wissen über die Ausgabe auf die …","ref":"/labs/02_java/03_java-grundlagen/01_console/","tags":"","title":"Java Exercises - Ausgabe auf die Kommandozeile"},{"body":"java.util.List Listen sind geordnete Collections, denn sie enthalten beliebige Objekte in einer bestimmten Reihenfolge. In Listen werden eine Menge von Elemente (genauer genommen Referenzen auf Objekte) abgespeichert, wobei die Menge geordnet ist, da jedes Element an einer bestimmten Position zu finden ist:\nBeachte, dass wir bei den Listen, die Indexierung der Positionen bei 0 beginnt, genauso wie bei dem primitiven Datentyp Array.\nListen haben eine dynamische Grösse, d.h. die Grösse der Liste muss bei der Erstellung nicht bekannt sein und die Anzahl der enthaltenen Elemente kann sich während der Laufzeit ändern. Daher ist es möglich, fortlaufend Elemente zur Liste hinzuzufügen oder aus der Liste zu entfernen. Hierbei entstehen nie Lücken: Fügt man ein Element an einer bestimmten Position zur Liste hinzu, dann rutschen alle nachfolgenden Elemente eine Position nach. Entfernt man ein Element an einer bestimmten Position, so rutschen alle nachfolgen Elemente eine Position nach oben.\nMan kann auf Elemente über ihren ganzzahligen Index (Position in der Liste) zugreifen und nach Elementen in der Liste suchen.\nEin Element aus einer Liste entfernen:\nWie zu Beginn erwähnt, enthalten Lists Referenzen auf Objekte. Deshalb ist es nicht möglich, Listen zu erstellen, welche primitive Datentypen als Elemente enthalten (int, double, boolean, char, ...). Dafür müssen die sogenannten Wrapper-Klassen verwendet werden. Wrapper-Klassen bieten eine Möglichkeit, primitive Datentypen (int, double, boolean, char, …) als Objekte zu verwenden: java.lang.Integer, java.lang.Double, java.lang.Boolean, java.lang.Character,..\nSchauen wir uns die folgenden Beispiele an, wo wir einer Liste mit Elementen vom Typ Integer das Element 3 hinzufügen:\n1 2 List\u003cInteger\u003e integerList = new ArrayList\u003c\u003e(); integerList.add(Integer.valueOf(3)); Oben haben wir der Liste das Integer-Objekt 3 hinzugefügt - also ein Integer-Objekt und nicht der Wert des primitiven Datentyps int.\n1 2 List\u003cInteger\u003e integerList = new ArrayList\u003c\u003e(); integerList.add(3); Beim unteren Beispiel haben wir der Liste den int-Wert 3 als primitiven Datentyp hinzu. Obwohl wir den int-Wert 3 als primitiver Datentypen und nicht als Integer-Objekte zur Liste integerList hinzufügen, kompiliert dieser Code genau so ohne Fehler. integerList ist jedoch eine Liste von Integer-Objekten und nicht eine Liste von int-Werten. Warum haben wir dann beim Kompilieren dieses Codes kein gekriegt?\nDer Copmiler konvertiert den int-Wert zu einem Integer-Objekt und fügt dieses dann zur Liste integerList hinzu. Diese Konvertierung nennt man Autoboxing. Autoboxing ist die automatische Konvertierung zwischen den primitiven Datentypen zu Objekten ihrer entsprechenden Wrapper-Klassen, die der Java Compiler durchführt (beispielsweise int zu Integer, double zu Double, ect.). Wenn die Konvertierung in die andere Richtung erfolgt, nennt man dies Unboxing.\nSomit ist es nicht mehr nötig, dass wir dieses Autoboxing wie im ersten Beispiel selber durchführen müssen.\nEinige Methoden vom Interface java.util.List 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 /* * Gibt die Anzahl der Elemente in dieser Liste zurück. */ int size(); /* * Gibt true zurück, wenn diese Liste keine Elemente enthält. */ boolean isEmpty(); /* * Gibt true zurück, wenn diese Liste das angegebene Element enthält. */ boolean contains(Object o); /* * Gibt das Element an der angegebenen Position in dieser Liste zurück. */ E get(int index); /* * Ersetzt das Element an der angegebenen Position in dieser Liste durch das angegebene Element. */ E set(int index,E element); /* * Gibt den Index des ersten Auftretens des angegebenen Elements in dieser Liste zurück, * oder -1, wenn diese Liste das Element nicht enthält. */ int indexOf(Object o); /* * Hängt das angegebene Element an das Ende der Liste an */ boolean add(E e); /* * Fügt das angegebene Element an der angegebenen Position in dieser Liste ein. * Verschiebt das Element, das sich derzeit an dieser Position befindet (falls vorhanden), * und alle nachfolgenden Elemente. */ void add(int index,E element); /* * Entfernt das erste Vorkommen des angegebenen Elements aus dieser Liste, * sofern es vorhanden ist. Wenn diese Liste das Element nicht enthält, * bleibt sie unverändert. */ boolean remove(Object o); /* * Entfernt das Element an der angegebenen Position in dieser Liste. */ E remove(int index); /* * Entfernt alle Elemente aus dieser Liste. /* void clear(); ... Das Interface java.util.List im Collection Framework ist der Datentyp der Listen, wobei in der abstrakten Klasse java.util.AbstractList die grundlegenden Funktionalitäten implementiert sind, sodass diese den verschiedenen konkreten Listen-Implementierungen weiter geerbt werden können.\nAuf der nächsten Seite geht es mit einer konkreten Umsetzung einer List weiter. Nun wird es also praktischer!\n","categories":"","description":"Das Interface List.\n","excerpt":"Das Interface List.\n","ref":"/docs/02_java/10_java-collections/01_list/","tags":"","title":"List"},{"body":"java.util.List Listen sind geordnete Collections, denn sie enthalten beliebige Objekte in einer bestimmten Reihenfolge. In Listen werden eine Menge von Elemente (genauer genommen Referenzen auf Objekte) abgespeichert, wobei die Menge geordnet ist, da jedes Element an einer bestimmten Position zu finden ist:\nBeachte, dass wir bei den Listen, die Indexierung der Positionen bei 0 beginnt, genauso wie bei dem primitiven Datentyp Array.\nListen haben eine dynamische Grösse, d.h. die Grösse der Liste muss bei der Erstellung nicht bekannt sein und die Anzahl der enthaltenen Elemente kann sich während der Laufzeit ändern. Daher ist es möglich, fortlaufend Elemente zur Liste hinzuzufügen oder aus der Liste zu entfernen. Hierbei entstehen nie Lücken: Fügt man ein Element an einer bestimmten Position zur Liste hinzu, dann rutschen alle nachfolgenden Elemente eine Position nach. Entfernt man ein Element an einer bestimmten Position, so rutschen alle nachfolgen Elemente eine Position nach oben.\nMan kann auf Elemente über ihren ganzzahligen Index (Position in der Liste) zugreifen und nach Elementen in der Liste suchen.\nEin Element aus einer Liste entfernen:\nWie zu Beginn erwähnt, enthalten Lists Referenzen auf Objekte. Deshalb ist es nicht möglich, Listen zu erstellen, welche primitive Datentypen als Elemente enthalten (int, double, boolean, char, ...). Dafür müssen die sogenannten Wrapper-Klassen verwendet werden. Wrapper-Klassen bieten eine Möglichkeit, primitive Datentypen (int, double, boolean, char, …) als Objekte zu verwenden: java.lang.Integer, java.lang.Double, java.lang.Boolean, java.lang.Character,..\nSchauen wir uns die folgenden Beispiele an, wo wir einer Liste mit Elementen vom Typ Integer das Element 3 hinzufügen:\n1 2 List\u003cInteger\u003e integerList = new ArrayList\u003c\u003e(); integerList.add(Integer.valueOf(3)); Oben haben wir der Liste das Integer-Objekt 3 hinzugefügt - also ein Integer-Objekt und nicht der Wert des primitiven Datentyps int.\n1 2 List\u003cInteger\u003e integerList = new ArrayList\u003c\u003e(); integerList.add(3); Beim unteren Beispiel haben wir der Liste den int-Wert 3 als primitiven Datentyp hinzu. Obwohl wir den int-Wert 3 als primitiver Datentypen und nicht als Integer-Objekte zur Liste integerList hinzufügen, kompiliert dieser Code genau so ohne Fehler. integerList ist jedoch eine Liste von Integer-Objekten und nicht eine Liste von int-Werten. Warum haben wir dann beim Kompilieren dieses Codes kein gekriegt?\nDer Copmiler konvertiert den int-Wert zu einem Integer-Objekt und fügt dieses dann zur Liste integerList hinzu. Diese Konvertierung nennt man Autoboxing. Autoboxing ist die automatische Konvertierung zwischen den primitiven Datentypen zu Objekten ihrer entsprechenden Wrapper-Klassen, die der Java Compiler durchführt (beispielsweise int zu Integer, double zu Double, ect.). Wenn die Konvertierung in die andere Richtung erfolgt, nennt man dies Unboxing.\nSomit ist es nicht mehr nötig, dass wir dieses Autoboxing wie im ersten Beispiel selber durchführen müssen.\nEinige Methoden vom Interface java.util.List 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 /* * Gibt die Anzahl der Elemente in dieser Liste zurück. */ int size(); /* * Gibt true zurück, wenn diese Liste keine Elemente enthält. */ boolean isEmpty(); /* * Gibt true zurück, wenn diese Liste das angegebene Element enthält. */ boolean contains(Object o); /* * Gibt das Element an der angegebenen Position in dieser Liste zurück. */ E get(int index); /* * Ersetzt das Element an der angegebenen Position in dieser Liste durch das angegebene Element. */ E set(int index,E element); /* * Gibt den Index des ersten Auftretens des angegebenen Elements in dieser Liste zurück, * oder -1, wenn diese Liste das Element nicht enthält. */ int indexOf(Object o); /* * Hängt das angegebene Element an das Ende der Liste an */ boolean add(E e); /* * Fügt das angegebene Element an der angegebenen Position in dieser Liste ein. * Verschiebt das Element, das sich derzeit an dieser Position befindet (falls vorhanden), * und alle nachfolgenden Elemente. */ void add(int index,E element); /* * Entfernt das erste Vorkommen des angegebenen Elements aus dieser Liste, * sofern es vorhanden ist. Wenn diese Liste das Element nicht enthält, * bleibt sie unverändert. */ boolean remove(Object o); /* * Entfernt das Element an der angegebenen Position in dieser Liste. */ E remove(int index); /* * Entfernt alle Elemente aus dieser Liste. /* void clear(); ... Das Interface java.util.List im Collection Framework ist der Datentyp der Listen, wobei in der abstrakten Klasse java.util.AbstractList die grundlegenden Funktionalitäten implementiert sind, sodass diese den verschiedenen konkreten Listen-Implementierungen weiter geerbt werden können.\nAuf der nächsten Seite geht es mit einer konkreten Umsetzung einer List weiter. Nun wird es also praktischer!\n","categories":"","description":"Das Interface List.\n","excerpt":"Das Interface List.\n","ref":"/de/docs/02_java/10_java-collections/01_list/","tags":"","title":"List"},{"body":"Aufgabe 1 Wir programmieren eine eigene ArrayList-Klasse MyArrayListSimple:\nDie Elemente sollen in einem Array gespeichert werden. Es dürfen keine Klassen aus dem Collection-Framework verwendet werden. Die Klasse muss das Interface MyListInterfaceSimple implementieren. Die Klasse weiss nicht, wie viele Elemente man speichert. Sie muss die Grösse der internen Datenstruktur dynamische anpassen. Die toString() Methode der java.lang.Object Klasse soll von der MyArrayListSimple so überschrieben werden, dass die Elemente kommasepariert ausgegeben werden: [Cat, Hamster, Dog, Goldfish] Überprüfe deine Implemenation mit dem JUnitTest MyArrayListSimpleTest Input Inferface MyListInterfaceSimple 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 package com.examples.list; public interface MyListInterfaceSimple\u003cE\u003e { /** * Appends the specified element to the end of this list . * @param element element to be appended to this list */ void add(E element); /** * Returns the element at the specified position in this list. * @param index index of the element to return * @return the element at the specified position in this list * @throws IndexOutOfBoundsException if the index is out of range */ E get(int index) throws IndexOutOfBoundsException; /** * Removes the element at the specified position in this list. * Returns the element that was removed from the list. * soll IndexOutOfBoundsException werfen * @param index the index of the element to be removed * @return the element previously at the specified position */ E remove(int index) throws IndexOutOfBoundsException; /** * Returns the number of elements in this list. * If this list contains more than Integer.MAX_VALUE elements, returns Integer.MAX_VALUE. * @return the number of elements in this list */ int size(); /** * Returns true if this list contains no elements. * @return true if this list contains no elements */ boolean isEmpty(); /** * Removes all the elements from this list. The list will be empty after this call returns. */ void clear(); } Aufgabe 2 Nun erweitern wir unsere MyArrayListSimple Klasse.\nErstelle eine Kopie deiner Klasse und nenne diese MyArrayListExtended. Diese soll das Interface MyListInterfaceExtended implementieren, welche folgende zusätzliche Methoden aufweist: void add(int index, E element) boolean contains(Object o) int indexOf(Object o) E set(int index, E element) boolean equals(Object o) boolean remove(Object o) Überprüfe deine Implemenation mit dem JUnitTest MyArrayListExtendedTest Input Inferface MyListInterfaceExtended 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 package com.examples.list; public interface MyListInterfaceExtended\u003cE\u003e { /** * Appends the specified element to the end of this list . * @param element element to be appended to this list */ void add(E element); /** * Returns the element at the specified position in this list. * @param index index of the element to return * @return the element at the specified position in this list * @throws IndexOutOfBoundsException if the index is out of range */ E get(int index) throws IndexOutOfBoundsException; /** * Removes the element at the specified position in this list. * Returns the element that was removed from the list. * soll IndexOutOfBoundsException werfen * @param index the index of the element to be removed * @return the element previously at the specified position */ E remove(int index) throws IndexOutOfBoundsException; /** * Returns the number of elements in this list. * If this list contains more than Integer.MAX_VALUE elements, returns Integer.MAX_VALUE. * @return the number of elements in this list */ int size(); /** * Returns true if this list contains no elements. * @return true if this list contains no elements */ boolean isEmpty(); /** * Removes all the elements from this list. The list will be empty after this call returns. */ void clear(); /** * Inserts the specified element at the specified position in this list. * Shifts the element currently at that position (if any) and any subsequent elements to the right. * @param index index at which the specified element is to be inserted * @param element element to be inserted * @throws IndexOutOfBoundsException if the add operation is not supported by this list */ void add(int index, E element) throws IndexOutOfBoundsException; /** * Returns true if this list contains the specified element. * @param o element whose presence in this list is to be tested * @return true if this list contains the specified element */ boolean contains(Object o); /** * Returns the index of the first occurrence of the specified element in this list, * or -1 if this list does not contain the element. * @param o element to search for * @return the index of the first occurrence of the specified element in this list, * or -1 if this list does not contain the element */ int indexOf(Object o); /** * Replaces the element at the specified position in this list with the specified element. * @param index index of the element to replace * @param element element to be stored at the specified position * @return the element previously at the specified position * @throws IndexOutOfBoundsException if the index is out of range */ E set(int index, E element) throws IndexOutOfBoundsException; /** * Compares the specified object with this list for equality. * Returns true if and only if the specified object is also a list, both lists have the same size, * and all corresponding pairs of elements in the two lists are equal. * @param o the object to be compared for equality with this list * @return true if the specified object is equal to this list */ boolean equals(Object o); /** * Removes the first occurrence of the specified element from this list, if it is present. * If this list does not contain the element, it is unchanged. * @param o element to be removed from this list, if present * @return true if this list contained the specified element */ boolean remove(Object o); } Aufgabe 3 (Optional) Erstelle ein Programm, welches ein Zeugnis bestehend aus Modulen und deren Schlussnoten generiert und in der Konsole ausgibt.\nDazu sollen die Klassen Modul und LBV (Prüfung) erstellt werden. Zur weiteren Hilfe soll die ModulNotGradeableException dienen.\nAnforderungen an die LBV-Klasse:\nDie Note der LBV ist als Float-Attribut gespeichert Die Gewichtung der LBV ist ebenfalls als Float-Attribut gespeichert Anforderungen an die Modul-Klasse:\nEin Modul hat den Modulnamen als Attribut. Alle LBVs des Moduls, werden in einer ArrayList gespeichert. LBVs werden dem Modul über die addLBV(LBV exam) Methode hinzugefügt. Der Moduldurchschnitt, soll von der Methode getFinalModuleGrade() als float zurückgegeben werden. Das Modul kann nur bewertet werden, wenn die Gewichtung aller LBVs genau 1 ergib. Ansonsten soll eine ModulNotGradeableException geworfen werden. Die Methode printReportEntry() soll den Zeugnis-Eintrag des Moduls generieren und ausgeben. Dieser ist im Format \u003c MODUL_NAME\u003e : \u003cMODUL_SCHLUSSNOTE\u003e auszugeben. Zudem wird erwartet, dass ein eigenes Testing (wie in J4 Testing gelernt) zu der Umsetzung gehört.\n","categories":"","description":"Aufgaben zu [Java Collections - List](../../../docs/02_java/10_java-collections/02_array-list)\n","excerpt":"Aufgaben zu [Java Collections - …","ref":"/labs/02_java/10_java-collections/01_list/","tags":"","title":"List - Aufgaben"},{"body":"Aufgabe 1 Wir programmieren eine eigene ArrayList-Klasse MyArrayListSimple:\nDie Elemente sollen in einem Array gespeichert werden. Es dürfen keine Klassen aus dem Collection-Framework verwendet werden. Die Klasse muss das Interface MyListInterfaceSimple implementieren. Die Klasse weiss nicht, wie viele Elemente man speichert. Sie muss die Grösse der internen Datenstruktur dynamische anpassen. Die toString() Methode der java.lang.Object Klasse soll von der MyArrayListSimple so überschrieben werden, dass die Elemente kommasepariert ausgegeben werden: [Cat, Hamster, Dog, Goldfish] Überprüfe deine Implemenation mit dem JUnitTest MyArrayListSimpleTest Input Inferface MyListInterfaceSimple 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 package com.examples.list; public interface MyListInterfaceSimple\u003cE\u003e { /** * Appends the specified element to the end of this list . * @param element element to be appended to this list */ void add(E element); /** * Returns the element at the specified position in this list. * @param index index of the element to return * @return the element at the specified position in this list * @throws IndexOutOfBoundsException if the index is out of range */ E get(int index) throws IndexOutOfBoundsException; /** * Removes the element at the specified position in this list. * Returns the element that was removed from the list. * soll IndexOutOfBoundsException werfen * @param index the index of the element to be removed * @return the element previously at the specified position */ E remove(int index) throws IndexOutOfBoundsException; /** * Returns the number of elements in this list. * If this list contains more than Integer.MAX_VALUE elements, returns Integer.MAX_VALUE. * @return the number of elements in this list */ int size(); /** * Returns true if this list contains no elements. * @return true if this list contains no elements */ boolean isEmpty(); /** * Removes all the elements from this list. The list will be empty after this call returns. */ void clear(); } Aufgabe 2 Nun erweitern wir unsere MyArrayListSimple Klasse.\nErstelle eine Kopie deiner Klasse und nenne diese MyArrayListExtended. Diese soll das Interface MyListInterfaceExtended implementieren, welche folgende zusätzliche Methoden aufweist: void add(int index, E element) boolean contains(Object o) int indexOf(Object o) E set(int index, E element) boolean equals(Object o) boolean remove(Object o) Überprüfe deine Implemenation mit dem JUnitTest MyArrayListExtendedTest Input Inferface MyListInterfaceExtended 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 package com.examples.list; public interface MyListInterfaceExtended\u003cE\u003e { /** * Appends the specified element to the end of this list . * @param element element to be appended to this list */ void add(E element); /** * Returns the element at the specified position in this list. * @param index index of the element to return * @return the element at the specified position in this list * @throws IndexOutOfBoundsException if the index is out of range */ E get(int index) throws IndexOutOfBoundsException; /** * Removes the element at the specified position in this list. * Returns the element that was removed from the list. * soll IndexOutOfBoundsException werfen * @param index the index of the element to be removed * @return the element previously at the specified position */ E remove(int index) throws IndexOutOfBoundsException; /** * Returns the number of elements in this list. * If this list contains more than Integer.MAX_VALUE elements, returns Integer.MAX_VALUE. * @return the number of elements in this list */ int size(); /** * Returns true if this list contains no elements. * @return true if this list contains no elements */ boolean isEmpty(); /** * Removes all the elements from this list. The list will be empty after this call returns. */ void clear(); /** * Inserts the specified element at the specified position in this list. * Shifts the element currently at that position (if any) and any subsequent elements to the right. * @param index index at which the specified element is to be inserted * @param element element to be inserted * @throws IndexOutOfBoundsException if the add operation is not supported by this list */ void add(int index, E element) throws IndexOutOfBoundsException; /** * Returns true if this list contains the specified element. * @param o element whose presence in this list is to be tested * @return true if this list contains the specified element */ boolean contains(Object o); /** * Returns the index of the first occurrence of the specified element in this list, * or -1 if this list does not contain the element. * @param o element to search for * @return the index of the first occurrence of the specified element in this list, * or -1 if this list does not contain the element */ int indexOf(Object o); /** * Replaces the element at the specified position in this list with the specified element. * @param index index of the element to replace * @param element element to be stored at the specified position * @return the element previously at the specified position * @throws IndexOutOfBoundsException if the index is out of range */ E set(int index, E element) throws IndexOutOfBoundsException; /** * Compares the specified object with this list for equality. * Returns true if and only if the specified object is also a list, both lists have the same size, * and all corresponding pairs of elements in the two lists are equal. * @param o the object to be compared for equality with this list * @return true if the specified object is equal to this list */ boolean equals(Object o); /** * Removes the first occurrence of the specified element from this list, if it is present. * If this list does not contain the element, it is unchanged. * @param o element to be removed from this list, if present * @return true if this list contained the specified element */ boolean remove(Object o); } Aufgabe 3 (Optional) Erstelle ein Programm, welches ein Zeugnis bestehend aus Modulen und deren Schlussnoten generiert und in der Konsole ausgibt.\nDazu sollen die Klassen Modul und LBV (Prüfung) erstellt werden. Zur weiteren Hilfe soll die ModulNotGradeableException dienen.\nAnforderungen an die LBV-Klasse:\nDie Note der LBV ist als Float-Attribut gespeichert Die Gewichtung der LBV ist ebenfalls als Float-Attribut gespeichert Anforderungen an die Modul-Klasse:\nEin Modul hat den Modulnamen als Attribut. Alle LBVs des Moduls, werden in einer ArrayList gespeichert. LBVs werden dem Modul über die addLBV(LBV exam) Methode hinzugefügt. Der Moduldurchschnitt, soll von der Methode getFinalModuleGrade() als float zurückgegeben werden. Das Modul kann nur bewertet werden, wenn die Gewichtung aller LBVs genau 1 ergib. Ansonsten soll eine ModulNotGradeableException geworfen werden. Die Methode printReportEntry() soll den Zeugnis-Eintrag des Moduls generieren und ausgeben. Dieser ist im Format \u003c MODUL_NAME\u003e : \u003cMODUL_SCHLUSSNOTE\u003e auszugeben. Zudem wird erwartet, dass ein eigenes Testing (wie in J4 Testing gelernt) zu der Umsetzung gehört.\n","categories":"","description":"Aufgaben zu [Java Collections - List](../../../docs/02_java/10_java-collections/02_array-list)\n","excerpt":"Aufgaben zu [Java Collections - …","ref":"/de/labs/02_java/10_java-collections/01_list/","tags":"","title":"List - Aufgaben"},{"body":"Aufgabe 1 In dieser Aufgabe werden wir eine Liste von Wörtern analysieren. Die Liste enthält bereits vordefinierte Wörter, und dein Programm soll die folgenden Schritte ausführen:\nGib die Anzahl der Wörter in der Liste aus. Gib alle Wörter in der Konsole wieder. Gib alle Nomen (Wörter, die mit einem grossen Buchstaben beginnen) in Grossbuchstaben aus. Gib die Wörter in umgekehrter Reihenfolge aus. Die Liste, die du verwenden sollst, lautet:\n1 2 3 4 5 6 7 8 9 10 List\u003cString\u003e words = new ArrayList\u003c\u003e(List.of( \"Abstraktion\", \"API\", \"Annotation\", \"ArrayList\", \"Bedingung\", \"Bibliothek\", \"Bytecode\", \"Collection\", \"Compiler\", \"Debugging\", \"Deployment\", \"entwickeln\", \"Exception\", \"Framework\", \"GarbageCollector\", \"generisch\", \"HashMap\", \"Heap\", \"implementieren\", \"Interface\", \"JVM\", \"Kapselung\", \"Klasse\", \"konstruieren\", \"Konstruktor\", \"Lambda\", \"lernen\", \"Methoden\", \"Modifikator\", \"Objekt\", \"optimieren\", \"Polymorphismus\", \"reflektieren\", \"Reflexion\", \"Schleife\", \"sortieren\", \"Stack\", \"Stream\", \"Synchronisation\", \"Thread\", \"TreeSet\", \"UnitTest\", \"Variable\", \"Vererbung\" )); Bei der Umsetzung dürfen keine Streams verwendet werden!\nAufgabe 2 Schreibe ein Programm, das die Fibonacci-Zahlen bis zu einer bestimmten Zahl n berechnet und in einer ArrayList speichert.\nWas ist Fibonacci? Die Fibonacci-Folge ist eine berühmte Zahlenreihe, bei der jede Zahl die Summe der beiden vorangehenden Zahlen ist. Sie beginnt immer mit den Zahlen 0 und 1. Die ersten Fibonacci-Zahlen sind:\n1 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ... Die Berechnungen verlaufen also folgendermassen:\n0 (erste Zahl, fixer Wert) 1 (zweite Zahl, fixer Wert) 1 (= 0 + 1) 2 (= 1 + 1) 3 (= 1 + 2) 5 (= 2 + 3) 8 (= 3 + 5) 13 (= 5 + 8) 21 (= 8 + 13) 34 (= 13 + 21) … Eine ArrayList eignet sich besonders gut, um Fibonacci-Zahlen zu speichern, da wir im Voraus nicht wissen, wie viele Zahlen berechnet werden müssen, bis eine bestimmte Zahl erreicht ist. Die ArrayList kann dynamisch wachsen und neue Zahlen aufnehmen. Durch diese Aufgabe lernst du den Umgang mit ArrayLists und wie sie sich dynamisch vergrössern lassen, ohne dass du dir Gedanken über die feste Größe von Arrays machen musst.\nDie Fibonacci-Folge ist relevant, weil sie in der Natur häufig vorkommt, wie bei der Anordnung von Blättern oder der Struktur von Tannenzapfen.\nUmsetzung Du schreibst eine Methode für die Berechnung der Fibonacci-Zahlen bis zu einem bestimmten Wert. Die Methode berechnet die Fibonacci-Zahlen, bis die aktuell berechnete Zahl grösser als n ist, und gibt die Liste der berechneten Fibonacci-Zahlen als Rückgabewert zurück. Es ist also vor der Berechnung unklar, wie lange die Liste werden kann.\nMethodensignatur:\n1 List\u003cInteger\u003e fibonacci(int n); Wenn wir also zum Beispiel n auf 20 setzen, wäre das Resultat eine ArrayList mit den folgenden Einträgen:\n1 [0, 1, 1, 2, 3, 5, 8, 13, 21] 21 ist grösser als 20, deshalb stoppt die Liste nach diesem Eintrag.\nBei der Umsetzung dürfen keine Streams verwendet werden!\nHier kannst du zurück zur Theorie.\n","categories":"","description":"Aufgaben zu Modul #J2 - Lists Basics\n","excerpt":"Aufgaben zu Modul #J2 - Lists Basics\n","ref":"/labs/02_java/04_java-oop/01_lists/","tags":"","title":"Lists Basics - Aufgaben"},{"body":"Aufgabe 1 In dieser Aufgabe werden wir eine Liste von Wörtern analysieren. Die Liste enthält bereits vordefinierte Wörter, und dein Programm soll die folgenden Schritte ausführen:\nGib die Anzahl der Wörter in der Liste aus. Gib alle Wörter in der Konsole wieder. Gib alle Nomen (Wörter, die mit einem grossen Buchstaben beginnen) in Grossbuchstaben aus. Gib die Wörter in umgekehrter Reihenfolge aus. Die Liste, die du verwenden sollst, lautet:\n1 2 3 4 5 6 7 8 9 10 List\u003cString\u003e words = new ArrayList\u003c\u003e(List.of( \"Abstraktion\", \"API\", \"Annotation\", \"ArrayList\", \"Bedingung\", \"Bibliothek\", \"Bytecode\", \"Collection\", \"Compiler\", \"Debugging\", \"Deployment\", \"entwickeln\", \"Exception\", \"Framework\", \"GarbageCollector\", \"generisch\", \"HashMap\", \"Heap\", \"implementieren\", \"Interface\", \"JVM\", \"Kapselung\", \"Klasse\", \"konstruieren\", \"Konstruktor\", \"Lambda\", \"lernen\", \"Methoden\", \"Modifikator\", \"Objekt\", \"optimieren\", \"Polymorphismus\", \"reflektieren\", \"Reflexion\", \"Schleife\", \"sortieren\", \"Stack\", \"Stream\", \"Synchronisation\", \"Thread\", \"TreeSet\", \"UnitTest\", \"Variable\", \"Vererbung\" )); Bei der Umsetzung dürfen keine Streams verwendet werden!\nAufgabe 2 Schreibe ein Programm, das die Fibonacci-Zahlen bis zu einer bestimmten Zahl n berechnet und in einer ArrayList speichert.\nWas ist Fibonacci? Die Fibonacci-Folge ist eine berühmte Zahlenreihe, bei der jede Zahl die Summe der beiden vorangehenden Zahlen ist. Sie beginnt immer mit den Zahlen 0 und 1. Die ersten Fibonacci-Zahlen sind:\n1 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ... Die Berechnungen verlaufen also folgendermassen:\n0 (erste Zahl, fixer Wert) 1 (zweite Zahl, fixer Wert) 1 (= 0 + 1) 2 (= 1 + 1) 3 (= 1 + 2) 5 (= 2 + 3) 8 (= 3 + 5) 13 (= 5 + 8) 21 (= 8 + 13) 34 (= 13 + 21) … Eine ArrayList eignet sich besonders gut, um Fibonacci-Zahlen zu speichern, da wir im Voraus nicht wissen, wie viele Zahlen berechnet werden müssen, bis eine bestimmte Zahl erreicht ist. Die ArrayList kann dynamisch wachsen und neue Zahlen aufnehmen. Durch diese Aufgabe lernst du den Umgang mit ArrayLists und wie sie sich dynamisch vergrössern lassen, ohne dass du dir Gedanken über die feste Größe von Arrays machen musst.\nDie Fibonacci-Folge ist relevant, weil sie in der Natur häufig vorkommt, wie bei der Anordnung von Blättern oder der Struktur von Tannenzapfen.\nUmsetzung Du schreibst eine Methode für die Berechnung der Fibonacci-Zahlen bis zu einem bestimmten Wert. Die Methode berechnet die Fibonacci-Zahlen, bis die aktuell berechnete Zahl grösser als n ist, und gibt die Liste der berechneten Fibonacci-Zahlen als Rückgabewert zurück. Es ist also vor der Berechnung unklar, wie lange die Liste werden kann.\nMethodensignatur:\n1 List\u003cInteger\u003e fibonacci(int n); Wenn wir also zum Beispiel n auf 20 setzen, wäre das Resultat eine ArrayList mit den folgenden Einträgen:\n1 [0, 1, 1, 2, 3, 5, 8, 13, 21] 21 ist grösser als 20, deshalb stoppt die Liste nach diesem Eintrag.\nBei der Umsetzung dürfen keine Streams verwendet werden!\nHier kannst du zurück zur Theorie.\n","categories":"","description":"Aufgaben zu Modul #J2 - Lists Basics\n","excerpt":"Aufgaben zu Modul #J2 - Lists Basics\n","ref":"/de/labs/02_java/04_java-oop/01_lists/","tags":"","title":"Lists Basics - Aufgaben"},{"body":"Ziele Ich kann ein Java-Package ohne main erstellen und darin nur statische Hilfsfunktionen bereitstellen. Ich kann zeilenweise Logausgaben in eine Datei schreiben (anhängen, nicht überschreiben). Ich kann Log-Level unterscheiden und sichtbar machen. Ich kann ein leicht lesbares Zeitformat vorneweg in jeder Zeile schreiben. ⏱️ Geschätzte Lesezeit: 15 Minuten Für das Logger-Projekt musst Du ein neues Repository erstellen! Einführung Was ist ein Logger? Ein Logger schreibt wichtige Ereignisse deines Programms in eine Datei, damit du später nachvollziehen kannst, was wann passiert ist (z. B. Start, Fehler, Warnungen). Jedes Ereignis ist eine Zeile (bei langen Nachrichten ggf. mehrere Zeilen), die u. a. Informationen zu Zeit, Prozess und Thread des Ereignisses enthält.\nWas ist ein Log-Level? Log-Level sind Bedeutungsstufen: z. B. INF (Information), WRN (Warnung), ERR (Fehler). Optional: DBG (Debug), TRC (sehr detailliert). Über einen Minimal-Level kannst du steuern, ab welcher Stufe geschrieben wird: TRC → DBG → INF → WRN → ERR. Bei Minimal-Level INF werden auch WRN und ERR geschrieben, bei Minimal-Level WRN nur noch WRN und ERR.\nPID \u0026 TID (kurz):\nPID = Process ID, die Kennzahl deines laufenden Prozesses (Programms). TID = Thread ID, die Kennzahl eines Ausführungsstrangs innerhalb des Prozesses. Details zu Threads behandeln wir später im eigenen Modul. Für das Loggen reicht: PID/TID helfen, Aktivitäten voneinander zu unterscheiden.\nKontext \u0026 Einschränkungen Nur statische Hilfsfunktionen: keine Instanzen, keine Vererbungsthemen. Kein main: Das Ergebnis ist ein Package, das in anderen Projekten genutzt werden kann. Kein Test-Framework: Du testest manuell (siehe Abschnitt Manuelles Testen). Coding-Style: Halte den Coding-Style-Guide strikt ein (Einrückung, Namen, Konstanten, Javadoc etc.). Aufgabenstellung Implementiere ein Logging-Package, das folgende Aufgaben erfüllt:\nLog-Zeilen schreiben: Pflicht-Methoden info, warn, error(msg), error(msg, ex), debug schreiben eine oder mehrere Zeile(n) in eine Log-Datei (append → am Ende anfügen, falls Datei schon existiert). Die API ist weiter unten definiert.\nDateiformat: In der Log-Datei muss klar ersichtlich sein, wann welches Ereignis wo vorgekommen ist.\nZeitstempel: Logging-Einträge können über mehrere Tage verteilt, aber auch innerhalb von Millisekunden erfolgen. Das muss ersichtlich sein. Message: freie Nachricht; kann mehrere Zeilen enthalten. PID/TID: nach Möglichkeit im Bereich 000–999 darstellen; falls grösser, darf kein Abschneiden erfolgen. Log-Level: Kurzform verwenden: INF, WRN, ERR, … Quelle (optional): Mit einem 4-stelligen String soll mitgeteilt werden können, aus welchem Package der Eintrag kommt (z. B. MAIN → aus dem Main-Package, STHE → aus dem String-Helper-Package, …). Dateiverwaltung \u0026 Dateiname:\nVerzeichnis: bei Bedarf erstellen. Dateiname: es muss klar unterschieden werden können, in welcher Reihenfolge die Dateien erstellt wurden (über Zeitstempel, Index, …). Es soll ein Text definiert werden können, der jeweils im Dateinamen enthalten ist (File Identifier). Dateigrösse: es muss festgelegt werden können, wie gross die Log-Datei werden darf (z. B. 1 MB). Rotation (Rolling): es soll definiert werden können, wie viele (Zahl) oder wie lange (Zeit) Log-Dateien aufbewahrt werden sollen. Wird eine der beiden Limiten überschritten, sollen zu viele vorhandene Log-Dateien gelöscht werden. Thread-Sicherheit (basic): Mehrere Aufrufe dürfen keine Zeilen vermischen (synchronisieren oder Files.newBufferedWriter mit Append \u0026 Flush benutzen).\nKonfiguration (ENV/User-Datei):\nDer Logger liest Einstellungen aus Umgebungsvariablen oder einer User-Konfigdatei.\nLogFolder: Speicherort der Log-Dateien. LogIdentifier: String, der in jeder Log-Datei enthalten sein soll. MinLevel: Minimal-Level. MaxFiles: maximale Anzahl an Log-Dateien, die aufbewahrt werden sollen. MaxDays: maximale Aufbewahrungszeit für eine Log-Datei in Tagen. LineLen (optional): maximale Länge einer Zeile in der Log-Datei. Längere Zeilen sollen umgebrochen werden. Konfig-Pfad-Ermittlung (Reihenfolge):\nexplizit via setConfigPath(Path) (falls genutzt), ENV ITNINJA_LOGGER_CONFIG, Default: im Benutzerverzeichnis, z. B. ~/.itninja-logger (Windows: %USERPROFILE%\\.itninja-logger). Umgebungsvariablen:\nITNINJA_LOGGER_LOGFOLDER: Speicherort der Log-Dateien. ITNINJA_LOGGER_LOGIDENTIFIER: String, der in jeder Log-Datei enthalten sein soll. ITNINJA_LOGGER_MINLEVEL: Minimal-Level. ITNINJA_LOGGER_MAXFILES: maximale Anzahl an Log-Dateien, die aufbewahrt werden sollen. ITNINJA_LOGGER_MAXDAYS: maximale Aufbewahrungszeit für eine Log-Datei in Tagen. ITNINJA_LOGGER_LINELEN (optional): maximale Länge einer Zeile in der Log-Datei. Längere Zeilen sollen umgebrochen werden. Konfigurationsermittlung (Reihenfolge):\nexplizit via Methodenaufruf im Code (falls vorhanden), aus der Konfigurationsdatei, falls definiert und vorhanden, aus den Umgebungsvariablen. Fehlertoleranz: Wenn die Log-Datei nicht geschrieben werden kann, wirf keine Exception nach aussen. Dokumentiere das Verhalten (z. B. Fallback auf System.err).\nPerformance: Das Schreiben in die Log-Datei soll so performant wie möglich erfolgen. Alle zusätzlichen Aufgaben wie z. B. die Dateiverwaltung erfolgen in separaten Methoden, die beim Start aufgerufen werden und vom Benutzer des Logging-Packages aufgerufen werden können.\nKonsole: Per Konfiguration soll es möglich sein, die Log-Ausgabe nicht nur in die Log-Datei zu schreiben, sondern auch auf der Konsole auszugeben. (Optional) Mittels farbigem Text soll zwischen den verschiedenen Log-Levels unterschieden werden können.\nAPI – minimale Pflicht Die folgenden Pflicht-Methoden müssen vorhanden sein; alle weiteren sind optional. Der Logger funktioniert ohne optionale Methoden (Defaults \u0026 Konfigurationsdatei/Umgebungsvariablen).\n1 2 3 4 5 6 7 public static void info(String message); public static void warn(String message); public static void error(String message); public static void error(String message, Throwable exception); public static void debug(String message); public static void maintain(); // checks for outdated files, configuration changes, ... API – optionale Erweiterungen 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // Optional: explizit Konfigpfad setzen (ansonsten ENV/Default) public static void setConfigPath(java.nio.file.Path configFile); // Optional: direkte Datei- oder Verzeichnis-Init (bypasst/ergänzt Konfigdatei) public static void initWithDir(java.nio.file.Path logDir, String postfix, LogLevel minLevel, String moduleCode); public static void init(java.nio.file.Path logFile, LogLevel minLevel, String moduleCode); // Optionale Setter (falls nicht ausschliesslich per Konfigdatei gesteuert) public static void setLogFolder(Path path); enum LogLevel { TRC, DBG, INF, WRN, ERR } public static void setMinLevel(LogLevel level); public static void setLogIdentifier(String identifier); public static void setMaxLineLength(int len); public static void setMaxFiles(int count); public static void setMaxDays(int days); // Optional Convenience public static void trace(String message); Du darfst die API vereinfachen oder erweitern, solange die Anforderungen erfüllt sind.\nManuelles Testen (ohne Test-Framework) Mini-Demo-Klasse in einem separaten Projekt (oder im selben Repo unter demo/), nicht im Logger-Package:\n1 2 3 4 5 6 7 8 public class LoggerDemo { public static void main(String[] args) { Logger.init(Path.of(\"./logs/app.log\"), \"Tournament\", LogLevel.INF); Logger.info(\"Round started\"); Logger.warn(\"Low disk space (drive=C: freeMB=512)\"); Logger.error(\"Failed to open config file (path=./cfg/app.yaml)\"); } } Mehrfachlauf: Programm 3–5× starten → prüfen, dass Zeilen angehängt werden.\nLevel-Filter: setMinLevel(LogLevel.WRN) setzen → INF darf nicht mehr erscheinen.\nRace-Test (einfach): In der Demo mehrere Threads starten, die parallel loggen → keine Zeilenverschachtelung.\nDatei öffnen: Mit einem Editor prüfen, dass keine leeren Zeilen entstehen.\n(Optional) Rotation: Datei bis \u003e 1 MB füllen → prüfen, dass eine neue Log-Datei erstellt und beschrieben wird.\nAkzeptanzkriterien (Definition of Done) Package baut ohne Fehler, ohne main. Es wird ein .jar erstellt. Es existiert eine README.md im Package mit kurzer API- und Konfigurations-Beschreibung und Beispiel. API ist mit JavaDoc dokumentiert. Log-Datei wird angelegt, angehängt und enthält die geforderten Informationen. Minimal-Level-Filter funktioniert. Keine Exceptions verlassen die öffentlichen Methoden (Fehler beim Schreiben werden intern behandelt und dokumentiert). Coding-Style-Guide eingehalten (Formatierung, Namen, Kommentare/Javadoc, keine Magic Numbers, sinnvolle final-Konstanten). Ordner-/Dateistruktur (Vorschlag) Nutze die folgende Struktur, damit du deinen Code im Logger-Projekt entwickeln und im Demo-Projekt testen kannst! Für die pom.xml in den Verzeichnissen logger und demo kannst du eine pom.xml aus deinen Übungen als Vorlage nehmen. 1 2 3 4 5 6 7 8 9 10 11 12 13 project-root/ pom.xml (Aggregator) logger/ src/main/java/ ch/individuell/logger/ Logger.java pom.xml README.md demo/ src/main/java/ LoggerDemo.java pom.xml pom.xml im Root:\n1 2 3 4 5 6 7 8 9 10 11 12 \u003cproject\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cgroupId\u003ech.itninja\u003c/groupId\u003e \u003cartifactId\u003eitninja-logger-parent\u003c/artifactId\u003e \u003cversion\u003e1.0.0-SNAPSHOT\u003c/version\u003e \u003cpackaging\u003epom\u003c/packaging\u003e \u003cmodules\u003e \u003cmodule\u003elogger\u003c/module\u003e \u003cmodule\u003edemo\u003c/module\u003e \u003c/modules\u003e \u003c/project\u003e Abgabe Für das Logger-Projekt musst Du ein neues Repository erstellen! Eigenes Repo it-ninja-[deinName]-logger (ersetze [deinName] mit deinem Namen). Repo-URL mit logger/ (Package) und demo/ (manuelle Tests). Kurze Beschreibung in der README.md – wie ausführen, wo die Datei liegt. Architektur \u0026 Austauschbarkeit (Ausblick) Ziel ist eine Struktur, in der wir Packages austauschen können: Logger, Tournament, Game sowie getrennte Frontend- und Backend-Varianten. Damit können wir z. B. vergleichen, wie GameEngine A ein Spiel gegenüber GameEngine B anders spielt, ohne den Logger oder das Frontend zu ändern.\nHalte die API des Loggers stabil und minimal. Verwende neutrale, sprechende Methodennamen und kurze, robuste Formate (siehe Pflichtformat), damit andere Module leicht integrieren können. Erstelle zusätzliche Utility-Klassen, wenn sinnvoll. ","categories":"","description":"Baue ein simples Logging-Package mit statischen Hilfsfunktionen. Das Package schreibt strukturierte Log-Zeilen in eine Datei und kann manuell getestet werden.\n","excerpt":"Baue ein simples Logging-Package mit statischen Hilfsfunktionen. Das …","ref":"/project/project-2025/logger/","tags":"","title":"Projekt: Logger"},{"body":"Ziele Ich weiss, was Markdown ist und welche Vorteile es hat Ich weiss, wie man mit Markdown eine einfache Dokumentation erstellt Ich weiss, wie man verschiedene Titel erstellt Ich weiss, wie man Paragraphen und Zeilenumbrüche erstellt Ich weiss, wie man fett und kursiv schreibt oder die beiden kombiniert Ich weiss, wie man Texte hervorheben kann Ich weiss, wie man Listen erstellt Ich weiss, wie man Code-Blöcke mit entsprechender Syntax erstellt Ich weiss, wie man Bilder und Links einfügen kann Ich weiss, wie man Tabellen erstellt Einführung Lies den Markdown-Guide zur Einführung Markdown - Getting started durch. Das IntelliJ enthält per Default die Möglichkeit Markdown-Dateien zu bearbeiten und ihr finales Aussehen anzuzeigen. Um eine Markdown-Datei anzusehen gibt es auch die Möglichkeit den Online Markdown Editor Dillinger zu verwenden.\nAndere Markdown-Editoren sind:\nGhostwriter Markdown Monster Für Linux und Mac stehen jeweils andere Editoren zur Verfügung.\nBasic Syntax Lies die Dokumentation zur Basic Syntax durch. Dort erfährst du, wie man die wichtigsten Elemente im Markdown anlegen kann, um eine Dokumentation zu erstellen.\nExtended Syntax In der Erweiterung lernst du Tabellen und weitere nützliche Funktionen kennen. Lies das Kapitel durch und mach dich mit den Tabellen und dem Hervorheben von Code vertraut.\nHacks Wenn du noch mehr wissen willst, bringt dich das Kapitel Hacks noch tiefer in nicht offizielle Funktionen von Markdown hinein.\nCheat Sheet Das Cheat-Sheet mit den wichtigsten Teilen der Markdown-Syntax findest du hier\n","categories":"","description":"Dokumentieren mit Markdown\n","excerpt":"Dokumentieren mit Markdown\n","ref":"/docs/99_tools/documentation/markdown/","tags":"","title":"Markdown"},{"body":"Vorbereitung Repository und Maven Mirror einrichten Die nachfolgenden Informationen in diesem Abschnitt richten sich an Auszubildende der SBB\nFalls du nicht in Ausbildung bei der SBB bist und deinen Code in einem Repository ablegen möchtest, musst du dir ein eigenes Repository eröffnen, z.B. auf BitBucket, GitHub oder Azure. Erstelle ein neues persönliches Repository\nKlone das neue Repository mit IntelliJ IDEA\nRichte das Repository ein, wie auf code.sbb.ch beschrieben (nachdem man das Repo erstellt hat)\nOptional: Konfigure den Maven Mirror von SBB\nAchtung: Der Maven Mirror von SBB ist nur im VPN erreichbar. Mit konfiguriertem Maven Mirror von SBB kann es beim Builden zu Problemen kommen, wenn man nicht mit dem VPN verbunden ist.\nMaven-Projekt aufsetzen Erstelle ein neues Projekt, welches wir später für das Modul Unit-Testing verwenden werden.\nErstelle in IntelliJ IDEA die für Maven erforderliche Ordnerstruktur:\nIm Root-Verzeichnis des Repositories eine .gitignore Datei, angepasst für ein IntelliJ Maven Projekt. Ordner src erstellen Im Ordner src zwei Ordner erstellen: main und test In den beiden Ordnern main und test jeweils zwei weitere Ordner erstellen: java und resources Die Ordner markieren (Rechtsklick -\u003e Mark Directory as…) src/main/java -\u003e Sources Root src/main/resources -\u003e Resources Root src/test/java -\u003e Test Sources Root src/test/resources -\u003e Test Resources Root Lege im Root des Projektes eine Datei mit dem Namen pom.xml an und füge den folgenden Inhalt ein:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cgroupId\u003eDeine Group-ID\u003c/groupId\u003e \u003cartifactId\u003eDeine Artifact-ID\u003c/artifactId\u003e \u003cversion\u003e0.0.1-SNAPSHOT\u003c/version\u003e \u003cname\u003eName des Projekts\u003c/name\u003e \u003cdescription\u003eBeschreibung des Projekts\u003c/description\u003e \u003cproperties\u003e \u003cproject.build.sourceEncoding\u003eUTF-8\u003c/project.build.sourceEncoding\u003e \u003cjava.version\u003eJava-Major-Version wählen, z.B. 21\u003c/java.version\u003e \u003cmaven.build.timestamp.format\u003eyyyy-MM-dd HH:mm\u003c/maven.build.timestamp.format\u003e \u003ctimestamp\u003e${maven.build.timestamp}\u003c/timestamp\u003e \u003c/properties\u003e \u003cdependencies\u003e \u003c!-- Test --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter\u003c/artifactId\u003e \u003cversion\u003e5.6.2\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter-api\u003c/artifactId\u003e \u003cversion\u003e5.6.2\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter-engine\u003c/artifactId\u003e \u003cversion\u003e5.6.2\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter-params\u003c/artifactId\u003e \u003cversion\u003e5.6.2\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.vintage\u003c/groupId\u003e \u003cartifactId\u003ejunit-vintage-engine\u003c/artifactId\u003e \u003cversion\u003e5.6.2\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.platform\u003c/groupId\u003e \u003cartifactId\u003ejunit-platform-engine\u003c/artifactId\u003e \u003cversion\u003e1.7.0-RC1\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.platform\u003c/groupId\u003e \u003cartifactId\u003ejunit-platform-commons\u003c/artifactId\u003e \u003cversion\u003e1.7.0-RC1\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mockito\u003c/groupId\u003e \u003cartifactId\u003emockito-core\u003c/artifactId\u003e \u003cversion\u003e4.1.0\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003cbuild\u003e \u003cplugins\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e \u003cartifactId\u003emaven-compiler-plugin\u003c/artifactId\u003e \u003cconfiguration\u003e \u003ccompilerVersion\u003e${java.version}\u003c/compilerVersion\u003e \u003csource\u003e${java.version}\u003c/source\u003e \u003ctarget\u003e${java.version}\u003c/target\u003e \u003c/configuration\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c/build\u003e \u003cdevelopers\u003e \u003cdeveloper\u003e \u003cid\u003eDeine Personalnummer\u003c/id\u003e \u003cname\u003eDein Name\u003c/name\u003e \u003cemail\u003eDein E-Mail\u003c/email\u003e \u003corganization\u003eSBB\u003c/organization\u003e \u003corganizationUrl\u003ehttps://www.sbb.ch\u003c/organizationUrl\u003e \u003croles\u003e \u003crole\u003eDeine Rolle\u003c/role\u003e \u003c/roles\u003e \u003c/developer\u003e \u003c/developers\u003e \u003c/project\u003e Passe die GroupID und ArtifactID gemäss der Theorie an. Dabei kannst du für die GroupID ch.sbb.{dein_name} und für die ArtifactID die aktuelle Aufgabe wählen, also zum Beispiel ch.sbb.johncarmack:J5.\nPasse die Java Version an: \u003cjava.version\u003eJava-Major-Version wählen, z.B. 21\u003c/java.version\u003e. Mit dem Befehl mvn --version oder java --version findest du heraus, welche Version verwendet wird (Achtung, als Version nur die erste Zahl von der Version nehmen).\nHinterlege das Projekt im IntelliJ als Maven-Projekt. Zu diesem Zweck Ctrl+Shift+A drücken und unter Aktion nach “Maven” suchen.\nAus der Liste dann entweder “Add as Maven Project” oder “Add Maven Projects” wählen.\nBei der ersten Aktion wird das Projekt direkt hinzugefügt, bei der zweiten muss das pom.xml noch ausgewählt werden.\nAuf der rechten Seite in IntelliJ gibt es den Tab Maven, dort müsste das Projekt nun erscheinen.\nWenn alles geklappt hat, dann werden die definierten Abhängigkeiten aus dem POM in das lokale Repository heruntergeladen.\nMAVEN Troubleshoot Es kann sein, dass nach Ctrl+Shift+A und dem Auswählen als Maven Project der Maven Tab rechts nicht erscheint. Der Grund wird wahrscheinlich ein Fehler im pom.xml sein.\nUm den Fehler zu finden kannst du in IntelliJ eine Konsole öffnen und dort den Befehl mvn install clean -e ausführen. Das -e gibt zusätzliche Informationen in der Konsole aus, falls es ein Problem gibt.\nAufgaben Aufgabe 1 - Warnungen behandeln Mit dem folgenden Befehl kannst Du die Maven Umgebung so aufsetzen, wie sie im pom.xml definiert ist:\n1 mvn clean install -e Dabei wirst Du womöglich feststellen, dass es mehrere Warnings gibt.\nSchau Dir die Warnings an und passe das pom.xml an, damit die Warnings nicht mehr kommen. Falls Du nicht weisst, welche Version Du für eine Dependency oder ein Plugin nehmen sollst, kannst Du im Maven Repository nachschauen gehen.\nAufgabe 2 - Dependencies aktualisieren Im pom.xml wird z.B. org.junit.jupiter:junit-jupiter in der Version 5.6.2 verwendet. Diese ist aus dem Jahr 2020 und hat zahlreiche Verbesserungen erfahren. Auch die anderen Dependencies sind schon recht alt.\nAktualisiere alle Dependencies mit Hilfe des Plugins org.codehaus.mojo:versions-maven-plugin:\nInstalliere das Plugin in der pom.xml, den Xml-Code für das Plugin findest du im Maven Repository.\nMit der Standard Konfiguration werden die Dependencies auf die aktuellste Version aktualisert. Das kann auch ein Snapshot oder ein Version mit Qualifier sein. Um nur Releases zu berücksichtigen kannst du folgende Konfiguration zum org.codehaus.mojo:versions-maven-plugin Plugin hinzufügen (damit werden alle Versionen ignoriert, welche ein ‘-’ enthalten):\n1 2 3 \u003cconfiguration\u003e \u003cignoredVersions\u003e.*-.*\u003c/ignoredVersions\u003e \u003c/configuration\u003e Mit dem folgenden Befehl kannst du testen, wie ein Update aussehen würde:\n1 mvn versions:display-dependency-updates Wenn du mit dem Resultat zufrieden bist, die pom.xml mit folgendem Befehl aktualisieren:\n1 mvn versions:use-latest-versions Aufgabe 3 - Remote Repository einrichten Erstelle auf deinem Rechner ein Verzeichnis (z.B. unter C:\\Development\\Repository)\npasse die Einstellungen in deinem Projekt so an, dass beim Befehl mvn -deploy das Artefakt von deinem Projekt in den zuvor erstellten Ordner erstellt wird.\nHier kannst du zurück zur Theorie.\n","categories":"","description":"Aufgaben zu Modul #S2 - [Maven](../../../../docs/02_java/05_maven)\n","excerpt":"Aufgaben zu Modul #S2 - [Maven](../../../../docs/02_java/05_maven)\n","ref":"/labs/02_java/05_maven/01_exercises/","tags":"","title":"Maven - Aufgaben"},{"body":"Vorbereitung Repository und Maven Mirror einrichten Die nachfolgenden Informationen in diesem Abschnitt richten sich an Auszubildende der SBB\nFalls du nicht in Ausbildung bei der SBB bist und deinen Code in einem Repository ablegen möchtest, musst du dir ein eigenes Repository eröffnen, z.B. auf BitBucket, GitHub oder Azure. Erstelle ein neues persönliches Repository\nKlone das neue Repository mit IntelliJ IDEA\nRichte das Repository ein, wie auf code.sbb.ch beschrieben (nachdem man das Repo erstellt hat)\nOptional: Konfigure den Maven Mirror von SBB\nAchtung: Der Maven Mirror von SBB ist nur im VPN erreichbar. Mit konfiguriertem Maven Mirror von SBB kann es beim Builden zu Problemen kommen, wenn man nicht mit dem VPN verbunden ist.\nMaven-Projekt aufsetzen Erstelle ein neues Projekt, welches wir später für das Modul Unit-Testing verwenden werden.\nErstelle in IntelliJ IDEA die für Maven erforderliche Ordnerstruktur:\nIm Root-Verzeichnis des Repositories eine .gitignore Datei, angepasst für ein IntelliJ Maven Projekt. Ordner src erstellen Im Ordner src zwei Ordner erstellen: main und test In den beiden Ordnern main und test jeweils zwei weitere Ordner erstellen: java und resources Die Ordner markieren (Rechtsklick -\u003e Mark Directory as…) src/main/java -\u003e Sources Root src/main/resources -\u003e Resources Root src/test/java -\u003e Test Sources Root src/test/resources -\u003e Test Resources Root Lege im Root des Projektes eine Datei mit dem Namen pom.xml an und füge den folgenden Inhalt ein:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cgroupId\u003eDeine Group-ID\u003c/groupId\u003e \u003cartifactId\u003eDeine Artifact-ID\u003c/artifactId\u003e \u003cversion\u003e0.0.1-SNAPSHOT\u003c/version\u003e \u003cname\u003eName des Projekts\u003c/name\u003e \u003cdescription\u003eBeschreibung des Projekts\u003c/description\u003e \u003cproperties\u003e \u003cproject.build.sourceEncoding\u003eUTF-8\u003c/project.build.sourceEncoding\u003e \u003cjava.version\u003eJava-Major-Version wählen, z.B. 21\u003c/java.version\u003e \u003cmaven.build.timestamp.format\u003eyyyy-MM-dd HH:mm\u003c/maven.build.timestamp.format\u003e \u003ctimestamp\u003e${maven.build.timestamp}\u003c/timestamp\u003e \u003c/properties\u003e \u003cdependencies\u003e \u003c!-- Test --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter\u003c/artifactId\u003e \u003cversion\u003e5.6.2\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter-api\u003c/artifactId\u003e \u003cversion\u003e5.6.2\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter-engine\u003c/artifactId\u003e \u003cversion\u003e5.6.2\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter-params\u003c/artifactId\u003e \u003cversion\u003e5.6.2\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.vintage\u003c/groupId\u003e \u003cartifactId\u003ejunit-vintage-engine\u003c/artifactId\u003e \u003cversion\u003e5.6.2\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.platform\u003c/groupId\u003e \u003cartifactId\u003ejunit-platform-engine\u003c/artifactId\u003e \u003cversion\u003e1.7.0-RC1\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.platform\u003c/groupId\u003e \u003cartifactId\u003ejunit-platform-commons\u003c/artifactId\u003e \u003cversion\u003e1.7.0-RC1\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mockito\u003c/groupId\u003e \u003cartifactId\u003emockito-core\u003c/artifactId\u003e \u003cversion\u003e4.1.0\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003cbuild\u003e \u003cplugins\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e \u003cartifactId\u003emaven-compiler-plugin\u003c/artifactId\u003e \u003cconfiguration\u003e \u003ccompilerVersion\u003e${java.version}\u003c/compilerVersion\u003e \u003csource\u003e${java.version}\u003c/source\u003e \u003ctarget\u003e${java.version}\u003c/target\u003e \u003c/configuration\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c/build\u003e \u003cdevelopers\u003e \u003cdeveloper\u003e \u003cid\u003eDeine Personalnummer\u003c/id\u003e \u003cname\u003eDein Name\u003c/name\u003e \u003cemail\u003eDein E-Mail\u003c/email\u003e \u003corganization\u003eSBB\u003c/organization\u003e \u003corganizationUrl\u003ehttps://www.sbb.ch\u003c/organizationUrl\u003e \u003croles\u003e \u003crole\u003eDeine Rolle\u003c/role\u003e \u003c/roles\u003e \u003c/developer\u003e \u003c/developers\u003e \u003c/project\u003e Passe die GroupID und ArtifactID gemäss der Theorie an. Dabei kannst du für die GroupID ch.sbb.{dein_name} und für die ArtifactID die aktuelle Aufgabe wählen, also zum Beispiel ch.sbb.johncarmack:J5.\nPasse die Java Version an: \u003cjava.version\u003eJava-Major-Version wählen, z.B. 21\u003c/java.version\u003e. Mit dem Befehl mvn --version oder java --version findest du heraus, welche Version verwendet wird (Achtung, als Version nur die erste Zahl von der Version nehmen).\nHinterlege das Projekt im IntelliJ als Maven-Projekt. Zu diesem Zweck Ctrl+Shift+A drücken und unter Aktion nach “Maven” suchen.\nAus der Liste dann entweder “Add as Maven Project” oder “Add Maven Projects” wählen.\nBei der ersten Aktion wird das Projekt direkt hinzugefügt, bei der zweiten muss das pom.xml noch ausgewählt werden.\nAuf der rechten Seite in IntelliJ gibt es den Tab Maven, dort müsste das Projekt nun erscheinen.\nWenn alles geklappt hat, dann werden die definierten Abhängigkeiten aus dem POM in das lokale Repository heruntergeladen.\nMAVEN Troubleshoot Es kann sein, dass nach Ctrl+Shift+A und dem Auswählen als Maven Project der Maven Tab rechts nicht erscheint. Der Grund wird wahrscheinlich ein Fehler im pom.xml sein.\nUm den Fehler zu finden kannst du in IntelliJ eine Konsole öffnen und dort den Befehl mvn install clean -e ausführen. Das -e gibt zusätzliche Informationen in der Konsole aus, falls es ein Problem gibt.\nAufgaben Aufgabe 1 - Warnungen behandeln Mit dem folgenden Befehl kannst Du die Maven Umgebung so aufsetzen, wie sie im pom.xml definiert ist:\n1 mvn clean install -e Dabei wirst Du womöglich feststellen, dass es mehrere Warnings gibt.\nSchau Dir die Warnings an und passe das pom.xml an, damit die Warnings nicht mehr kommen. Falls Du nicht weisst, welche Version Du für eine Dependency oder ein Plugin nehmen sollst, kannst Du im Maven Repository nachschauen gehen.\nAufgabe 2 - Dependencies aktualisieren Im pom.xml wird z.B. org.junit.jupiter:junit-jupiter in der Version 5.6.2 verwendet. Diese ist aus dem Jahr 2020 und hat zahlreiche Verbesserungen erfahren. Auch die anderen Dependencies sind schon recht alt.\nAktualisiere alle Dependencies mit Hilfe des Plugins org.codehaus.mojo:versions-maven-plugin:\nInstalliere das Plugin in der pom.xml, den Xml-Code für das Plugin findest du im Maven Repository.\nMit der Standard Konfiguration werden die Dependencies auf die aktuellste Version aktualisert. Das kann auch ein Snapshot oder ein Version mit Qualifier sein. Um nur Releases zu berücksichtigen kannst du folgende Konfiguration zum org.codehaus.mojo:versions-maven-plugin Plugin hinzufügen (damit werden alle Versionen ignoriert, welche ein ‘-’ enthalten):\n1 2 3 \u003cconfiguration\u003e \u003cignoredVersions\u003e.*-.*\u003c/ignoredVersions\u003e \u003c/configuration\u003e Mit dem folgenden Befehl kannst du testen, wie ein Update aussehen würde:\n1 mvn versions:display-dependency-updates Wenn du mit dem Resultat zufrieden bist, die pom.xml mit folgendem Befehl aktualisieren:\n1 mvn versions:use-latest-versions Aufgabe 3 - Remote Repository einrichten Erstelle auf deinem Rechner ein Verzeichnis (z.B. unter C:\\Development\\Repository)\npasse die Einstellungen in deinem Projekt so an, dass beim Befehl mvn -deploy das Artefakt von deinem Projekt in den zuvor erstellten Ordner erstellt wird.\nHier kannst du zurück zur Theorie.\n","categories":"","description":"Aufgaben zu Modul #S2 - [Maven](../../../../docs/02_java/05_maven)\n","excerpt":"Aufgaben zu Modul #S2 - [Maven](../../../../docs/02_java/05_maven)\n","ref":"/de/labs/02_java/05_maven/01_exercises/","tags":"","title":"Maven - Aufgaben"},{"body":"Ziele Ich kann ohne Hilfsmittel die Bestandteile einer Klasse vollständig auflisten. Ich kann den Unterschied zwischen einer Klasse und einem Objekt mit konkreten Beispielen demonstrieren. Ich implementiere Klassen anhand vorgegebenen Anforderungen und instanziiere (erzeuge) Objekte dazu. Einführung In der realen Welt können wir viele Objekte wie Autos, Gebäude und Menschen um uns herum finden. Alle diese Objekte haben einen bestimmten Zustand/Merkmale und ein bestimmtes Verhalten.\nWenn wir ein Auto betrachten, so könnte sein Zustand/seine Merkmale\neinen Markennamen, eine bestimmte Geschwindigkeit oder den zu tankenden Kraftstoff enthalten. Mögliche Verhaltensweisen eines Autos sind normalerweise\nfahren und einparken. Problemstellung Stell dir vor, du möchtest ein Auto in Java programmieren. Dazu könnten wir für jedes Auto einfach drei separate Variablen verwenden:\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class AutoProblemOhneOOP { public static void main(String[] args) { String autoName = \"BMW\"; int geschwindigkeit = 120; String kraftstoff = \"Benzin\"; // Weitere Autos String autoName2 = \"Audi\"; int geschwindigkeit2 = 100; String kraftstoff2 = \"Diesel\"; } } Das funktioniert für ein oder zwei Autos, aber was passiert, wenn wir viele Autos haben? Was passiert, wenn wir viele Autos haben? Es wird schwierig, jedes Auto mit seinen individuellen Merkmalen zu verwalten, und der Code wird unübersichtlich. Wir müssten mehrere Variablen für jeden Zustand eines Autos pflegen. Eine Lösung wäre die Verwendung von Arrays:\n1 2 3 4 5 6 7 8 public class AutoProblemMitArrays { public static void main(String[] args) { String[] autoName = {\"BMW\", \"Audi\"}; int[] geschwindigkeit = {120, 100}; String[] kraftstoff = {\"Benzin\", \"Diesel\"}; } } Probleme mit dieser Lösung:\nWir müssen immer sicherstellen, dass die Daten für jedes Auto an der gleichen Position in allen Arrays stehen. Das erhöht die Komplexität. Es ist schwer, weitere Funktionen für jedes Auto hinzuzufügen oder das Verhalten zu modellieren. Wäre es nicht cool, wenn wir diese Eigenschaften zusammenfassen könnten? Eine bessere Lösung besteht darin, eine Klasse zu erstellen, die alle Merkmale eines Autos beschreibt. Dadurch können wir sowohl den Zustand als auch das Verhalten eines Autos kapseln.\n1 2 3 4 5 public class Auto { String marke; int geschwindigkeit; String kraftstoff; } Nun können wir Objekte dieser Klasse erstellen. Ein Objekt hat diese Eigenschaften zur Verfügung und kann sie entsprechend setzen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class AutoBeispiel { public static void main(String[] args) { Auto auto1 = new Auto(); //mit new wird ein neues Objekt von dieser Klasse erstellt auto1.marke = \"BMW\"; auto1.geschwindigkeit = 120; auto1.kraftstoff = \"Benzin\"; Auto auto2 = new Auto(); auto2.marke = \"Audi\"; auto2.geschwindigkeit = 100; auto2.kraftstoff = \"Diesel\"; System.out.println(auto1.marke); // Output: BMW System.out.println(auto2.marke); //Output: Audi } } Vorteile dieser Lösung:\nDie Eigenschaften eines Autos sind in einer einzigen Einheit (Klasse) zusammengefasst. Es ist einfach, neue Autos zu erstellen und zu verwalten, da wir nicht mehr mehrere Arrays benötigen. Wir können einfach einen Array von unserem Typ Auto erstellen: Auto[] autos. Der Code wird klarer und wartbarer. Klassen können noch viel mehr als nur Behälter für mehrere Variablen sein. Das wirst du in den folgenden Kapiteln lernen.\nDefinitionen Um die nachfolgenden Kapitel besser zu verstehen, ist es hilfreich zuerst einige Basisdefinitionen zu etablieren.\nObjektorientierte Programmierung Das Konzept der objektorientierten Programmierung soll helfen eine Struktur in eine Anwendung zu bringen. Das Ziel ist es, Daten und Methoden, die zusammengehören, in einer Klasse zusammenzufassen. Dies führt auch dazu, dass der Code wiederverwendbarer wird, da einfach neue Instanzen/Objekte dieser Klasse erstellt werden können.\nKlasse Eine Klasse ist eine Vorlage, die die gemeinsamen Eigenschaften und das Verhalten von Objekten desselben Typs beschreibt Die Klasse dient als Bauplan für die Abbildung von realen Objekten in Softwareobjekte und beschreibt Attribute (Eigenschaften) und Methoden ( Verhaltensweisen) der Objekte.\nObjekt Ein Objekt bezeichnet in der objektorientierten Programmierung ein Exemplar eines bestimmten Datentyps oder einer bestimmter Klasse. Objekte sind konkrete Ausprägungen (=Instanzen) einer Klasse und werden zur Laufzeit erzeugt (Instanziierung).\nDatenfelder Datenfelder (Attribute) enthalten Informationen, die für Objekte dieser Klasse relevant sind. Beispielsweise hat ein Auto eine Höchstgeschwindigkeit, eine bestimmte Anzahl von Sitzen, usw. Das heisst, ein Feld ist eine Variable, in der Daten gespeichert werden können. Es kann einen beliebigen Typ haben, einschliesslich primitiver Typen (int, float, boolean usw.) und Klassen. Eine Klasse kann auch sich selber als Feld enthalten. Eine Klasse kann beliebig viele Felder haben.\nMethoden Methoden dienen dazu, den Zustand eines Objekts zu verändern. Die Methode refuel() (siehe Klassendiagramm unten) füllt beispielsweise den Tank, bis dessen Kapazität erreicht wird.\nZusammenfassung Klassen werden verwendet, um benutzerdefinierte Datentypen darzustellen. Damit werden Attribute und Verhalten, welche zu diesem neuen Datentyp gehören, an einer Stelle im Code zusammengefasst und verwaltet. Diese neuen, benutzerdefinierte Datentypen können dann wie anderen Datentypen (primitive Datentypen oder andere Klassen) verwendet werden.\nBeginnen wir mit einem Beispiel einer Auto-Klasse; hier siehst du das UML-Klassendiagramm der Klasse Car, die wir selber erfunden haben. Die oberen 4 Einträge sind ihre Instanzvariablen und die untersten 3 sind ihre Methoden. Einträge mit einem - sind private, Einträge mit einem + sind öffentlich (public):\nclass Car - topSpeed: int - totalSeats: int - fuelCapacity: int - manufacturer: String + refuel(): void + park(): void + drive(): void Klassen und Objekte im Schnelldurchlauf Klassen deklarieren Eine Java Klasse besteht aus zwei Teilen: Dem Klassenkopf und dem Klassenrumpf.\nIm Klassenkopf (auch Klassendeklaration genannt) wird eine neue Klasse mit dem Keyword class gefolgt vom Namen der Klasse deklariert. Per Konvention folgt die Benamsung der Klasse dem PascalCase. Das bedeutet, dass der Klassen-Name und jedes neue Wort darin mit einem Grossbuchstaben beginnt, der Rest besteht aus Kleinbuchstaben.\nWie folgt kannst du eine Klasse mit dem Namen Nothing erstellen:\n1 2 3 public class Nothing { } Der “Klassenrumpf” besteht aus einer öffnender { und schliessenden geschweiften Klammer }. Diese Klammern bilden die Grenzen der Klasse. Der Klassenrumpf kann Felder, Methoden und Konstruktoren enthalten. Felder speichern Daten, Methoden definieren das Verhalten und Konstruktoren ermöglichen es uns, neue Objekte der Klasse zu erstellen und zu initialisieren. Felder und Methoden gelten als Klassenmitglieder (class members).\nDer Quellcode einer Klasse wird in eine .java-Datei eingefügt. Normalerweise enthält eine Quellcodedatei nur eine Klasse und hat denselben Namen wie diese Klasse. Manchmal kann eine Datei jedoch auch mehrere Klassen enthalten, jedoch darf es nur eine öffentliche (public) Klasse pro Datei geben. Deren Name muss mit dem Dateinamen übereinstimmen.\nNachfolgend die Klasse Patient in der Datei Patient.java:\n1 2 3 4 5 6 7 public class Patient { String name; // Feld bzw. Instanzvariable vom Datentyp String mit dem Bezeichner 'name' int age; // Feld bzw. Instanzvariable vom Datentyp int mit dem Bezeichner 'age' float size; // Feld bzw. Instanzvariable vom Datentyp float mit dem Bezeichner 'size' String[] complaints; // ein Feld kann auch ein Array sein } Diese Klasse repräsentiert einen Patienten in einem Krankenhausinformationssystem. Sie verfügt über vier Felder: name, age, size und complaints. Alle Objekte der Klasse Patient haben dieselben Felder, aber ihre Werte können für jedes Objekt unterschiedlich sein.\nObjekte erstellen Patient.java\n1 2 3 4 5 6 class Patient { String name; int age; float height; } Wir können ein Objekt (auch “eine Instanz” genannt) der Klasse Patient mit dem Operator new erstellen:\n1 Patient patient = new Patient(); Wenn du ein neues Objekt erstellst, wird jedes Feld mit dem Standardwert des entsprechenden Typs initialisiert (insofern du keinen Konstruktor mit Argumenten verwendest, dazu aber später mehr). Wenn die Instanzvariablen eines Objektes nicht mit einem Zugriffsmodifikator wie private versehen sind (dazu unten mehr), können wir mittels Punkt-Operator auf die Variablen des Objekts zugreifen:\n1 2 System.out.println(patient.name); // es wird null ausgeben System.out.println(patient.age); // es wird 0 ausgeben Das folgende Programm erstellt zwei Objekte der Klasse Patient und druckt die Informationen der Objekte aus.\nPatientDemo.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class PatientDemo { public static void main(String[] args) { // Wir erstellen einen neuen Patienten, alle Variablen werden mit ihren Standardwerten initialisiert Patient john = new Patient(); // Wir greifen über den Punkt-Operator auf die Variablen zu und speichern Werte darin john.name = \"John\"; john.age = 30; john.height = 180f; System.out.println(john.name + \" \" + john.age + \" \" + john.height); Patient alice = new Patient(); alice.name = \"Alice\"; alice.age = 22; alice.height = 165f; System.out.println(alice.name + \" \" + alice.age + \" \" + alice.height); } } Im obigen Code haben wir zwei Patienten erstellt, John und Alice, die Werte ihrer Felder definiert und dann die Informationen über sie ausgedruckt. Wir sehen, dass wir mit dem Punkt-Operator auf die Felder des Objekts zugreifen können (john.name = “John”). Allerdings soll hier erwähnt sein, dass das nur geht, wenn die Instanzvariablen nicht private sind (wir behandeln das Thema Zugriffsmodifikatoren später).\nReferenzen teilen Objekte sind Referenztypen. In einer Variable wird also nicht das Objekt selbst, sondern die Speicheradresse hinterlegt, welche auf das Objekt zeigt. Es können sich also mehrere Referenzen auf dasselbe Objekt beziehen.\n1 2 3 4 5 6 7 8 Patient patient = new Patient(); patient.name = \"Mary\"; patient.age = 24; System.out.println(patient.name + \" \" + patient.age); // Mary 24 // Wir weisen der Variablen patient2 die Speicheradresse der Variablen patient zu Patient patient2 = patient; System.out.println(patient2.name + \" \" + patient2.age); // Mary 24 Es ist wichtig zu verstehen, dass sich die zwei Referenzen oben auf das gleiche Objekt im Speicher beziehen und nicht auf zwei unabhängige Kopien. Da unsere Klasse veränderbar ist, können wir das Objekt mit Hilfe beider Referenzen ändern.\n1 2 patient.age = 25; System.out.println(patient2.age); // 25 ","categories":"","description":"Modul #J2\n","excerpt":"Modul #J2\n","ref":"/docs/02_java/04_java-oop/01_oop/","tags":"","title":"Objektorientierte Programmierung"},{"body":"Ziele Ich kann ohne Hilfsmittel die Bestandteile einer Klasse vollständig auflisten. Ich kann den Unterschied zwischen einer Klasse und einem Objekt mit konkreten Beispielen demonstrieren. Ich implementiere Klassen anhand vorgegebenen Anforderungen und instanziiere (erzeuge) Objekte dazu. Einführung In der realen Welt können wir viele Objekte wie Autos, Gebäude und Menschen um uns herum finden. Alle diese Objekte haben einen bestimmten Zustand/Merkmale und ein bestimmtes Verhalten.\nWenn wir ein Auto betrachten, so könnte sein Zustand/seine Merkmale\neinen Markennamen, eine bestimmte Geschwindigkeit oder den zu tankenden Kraftstoff enthalten. Mögliche Verhaltensweisen eines Autos sind normalerweise\nfahren und einparken. Problemstellung Stell dir vor, du möchtest ein Auto in Java programmieren. Dazu könnten wir für jedes Auto einfach drei separate Variablen verwenden:\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class AutoProblemOhneOOP { public static void main(String[] args) { String autoName = \"BMW\"; int geschwindigkeit = 120; String kraftstoff = \"Benzin\"; // Weitere Autos String autoName2 = \"Audi\"; int geschwindigkeit2 = 100; String kraftstoff2 = \"Diesel\"; } } Das funktioniert für ein oder zwei Autos, aber was passiert, wenn wir viele Autos haben? Was passiert, wenn wir viele Autos haben? Es wird schwierig, jedes Auto mit seinen individuellen Merkmalen zu verwalten, und der Code wird unübersichtlich. Wir müssten mehrere Variablen für jeden Zustand eines Autos pflegen. Eine Lösung wäre die Verwendung von Arrays:\n1 2 3 4 5 6 7 8 public class AutoProblemMitArrays { public static void main(String[] args) { String[] autoName = {\"BMW\", \"Audi\"}; int[] geschwindigkeit = {120, 100}; String[] kraftstoff = {\"Benzin\", \"Diesel\"}; } } Probleme mit dieser Lösung:\nWir müssen immer sicherstellen, dass die Daten für jedes Auto an der gleichen Position in allen Arrays stehen. Das erhöht die Komplexität. Es ist schwer, weitere Funktionen für jedes Auto hinzuzufügen oder das Verhalten zu modellieren. Wäre es nicht cool, wenn wir diese Eigenschaften zusammenfassen könnten? Eine bessere Lösung besteht darin, eine Klasse zu erstellen, die alle Merkmale eines Autos beschreibt. Dadurch können wir sowohl den Zustand als auch das Verhalten eines Autos kapseln.\n1 2 3 4 5 public class Auto { String marke; int geschwindigkeit; String kraftstoff; } Nun können wir Objekte dieser Klasse erstellen. Ein Objekt hat diese Eigenschaften zur Verfügung und kann sie entsprechend setzen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class AutoBeispiel { public static void main(String[] args) { Auto auto1 = new Auto(); //mit new wird ein neues Objekt von dieser Klasse erstellt auto1.marke = \"BMW\"; auto1.geschwindigkeit = 120; auto1.kraftstoff = \"Benzin\"; Auto auto2 = new Auto(); auto2.marke = \"Audi\"; auto2.geschwindigkeit = 100; auto2.kraftstoff = \"Diesel\"; System.out.println(auto1.marke); // Output: BMW System.out.println(auto2.marke); //Output: Audi } } Vorteile dieser Lösung:\nDie Eigenschaften eines Autos sind in einer einzigen Einheit (Klasse) zusammengefasst. Es ist einfach, neue Autos zu erstellen und zu verwalten, da wir nicht mehr mehrere Arrays benötigen. Wir können einfach einen Array von unserem Typ Auto erstellen: Auto[] autos. Der Code wird klarer und wartbarer. Klassen können noch viel mehr als nur Behälter für mehrere Variablen sein. Das wirst du in den folgenden Kapiteln lernen.\nDefinitionen Um die nachfolgenden Kapitel besser zu verstehen, ist es hilfreich zuerst einige Basisdefinitionen zu etablieren.\nObjektorientierte Programmierung Das Konzept der objektorientierten Programmierung soll helfen eine Struktur in eine Anwendung zu bringen. Das Ziel ist es, Daten und Methoden, die zusammengehören, in einer Klasse zusammenzufassen. Dies führt auch dazu, dass der Code wiederverwendbarer wird, da einfach neue Instanzen/Objekte dieser Klasse erstellt werden können.\nKlasse Eine Klasse ist eine Vorlage, die die gemeinsamen Eigenschaften und das Verhalten von Objekten desselben Typs beschreibt Die Klasse dient als Bauplan für die Abbildung von realen Objekten in Softwareobjekte und beschreibt Attribute (Eigenschaften) und Methoden ( Verhaltensweisen) der Objekte.\nObjekt Ein Objekt bezeichnet in der objektorientierten Programmierung ein Exemplar eines bestimmten Datentyps oder einer bestimmter Klasse. Objekte sind konkrete Ausprägungen (=Instanzen) einer Klasse und werden zur Laufzeit erzeugt (Instanziierung).\nDatenfelder Datenfelder (Attribute) enthalten Informationen, die für Objekte dieser Klasse relevant sind. Beispielsweise hat ein Auto eine Höchstgeschwindigkeit, eine bestimmte Anzahl von Sitzen, usw. Das heisst, ein Feld ist eine Variable, in der Daten gespeichert werden können. Es kann einen beliebigen Typ haben, einschliesslich primitiver Typen (int, float, boolean usw.) und Klassen. Eine Klasse kann auch sich selber als Feld enthalten. Eine Klasse kann beliebig viele Felder haben.\nMethoden Methoden dienen dazu, den Zustand eines Objekts zu verändern. Die Methode refuel() (siehe Klassendiagramm unten) füllt beispielsweise den Tank, bis dessen Kapazität erreicht wird.\nZusammenfassung Klassen werden verwendet, um benutzerdefinierte Datentypen darzustellen. Damit werden Attribute und Verhalten, welche zu diesem neuen Datentyp gehören, an einer Stelle im Code zusammengefasst und verwaltet. Diese neuen, benutzerdefinierte Datentypen können dann wie anderen Datentypen (primitive Datentypen oder andere Klassen) verwendet werden.\nBeginnen wir mit einem Beispiel einer Auto-Klasse; hier siehst du das UML-Klassendiagramm der Klasse Car, die wir selber erfunden haben. Die oberen 4 Einträge sind ihre Instanzvariablen und die untersten 3 sind ihre Methoden. Einträge mit einem - sind private, Einträge mit einem + sind öffentlich (public):\nclass Car - topSpeed: int - totalSeats: int - fuelCapacity: int - manufacturer: String + refuel(): void + park(): void + drive(): void Klassen und Objekte im Schnelldurchlauf Klassen deklarieren Eine Java Klasse besteht aus zwei Teilen: Dem Klassenkopf und dem Klassenrumpf.\nIm Klassenkopf (auch Klassendeklaration genannt) wird eine neue Klasse mit dem Keyword class gefolgt vom Namen der Klasse deklariert. Per Konvention folgt die Benamsung der Klasse dem PascalCase. Das bedeutet, dass der Klassen-Name und jedes neue Wort darin mit einem Grossbuchstaben beginnt, der Rest besteht aus Kleinbuchstaben.\nWie folgt kannst du eine Klasse mit dem Namen Nothing erstellen:\n1 2 3 public class Nothing { } Der “Klassenrumpf” besteht aus einer öffnender { und schliessenden geschweiften Klammer }. Diese Klammern bilden die Grenzen der Klasse. Der Klassenrumpf kann Felder, Methoden und Konstruktoren enthalten. Felder speichern Daten, Methoden definieren das Verhalten und Konstruktoren ermöglichen es uns, neue Objekte der Klasse zu erstellen und zu initialisieren. Felder und Methoden gelten als Klassenmitglieder (class members).\nDer Quellcode einer Klasse wird in eine .java-Datei eingefügt. Normalerweise enthält eine Quellcodedatei nur eine Klasse und hat denselben Namen wie diese Klasse. Manchmal kann eine Datei jedoch auch mehrere Klassen enthalten, jedoch darf es nur eine öffentliche (public) Klasse pro Datei geben. Deren Name muss mit dem Dateinamen übereinstimmen.\nNachfolgend die Klasse Patient in der Datei Patient.java:\n1 2 3 4 5 6 7 public class Patient { String name; // Feld bzw. Instanzvariable vom Datentyp String mit dem Bezeichner 'name' int age; // Feld bzw. Instanzvariable vom Datentyp int mit dem Bezeichner 'age' float size; // Feld bzw. Instanzvariable vom Datentyp float mit dem Bezeichner 'size' String[] complaints; // ein Feld kann auch ein Array sein } Diese Klasse repräsentiert einen Patienten in einem Krankenhausinformationssystem. Sie verfügt über vier Felder: name, age, size und complaints. Alle Objekte der Klasse Patient haben dieselben Felder, aber ihre Werte können für jedes Objekt unterschiedlich sein.\nObjekte erstellen Patient.java\n1 2 3 4 5 6 class Patient { String name; int age; float height; } Wir können ein Objekt (auch “eine Instanz” genannt) der Klasse Patient mit dem Operator new erstellen:\n1 Patient patient = new Patient(); Wenn du ein neues Objekt erstellst, wird jedes Feld mit dem Standardwert des entsprechenden Typs initialisiert (insofern du keinen Konstruktor mit Argumenten verwendest, dazu aber später mehr). Wenn die Instanzvariablen eines Objektes nicht mit einem Zugriffsmodifikator wie private versehen sind (dazu unten mehr), können wir mittels Punkt-Operator auf die Variablen des Objekts zugreifen:\n1 2 System.out.println(patient.name); // es wird null ausgeben System.out.println(patient.age); // es wird 0 ausgeben Das folgende Programm erstellt zwei Objekte der Klasse Patient und druckt die Informationen der Objekte aus.\nPatientDemo.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class PatientDemo { public static void main(String[] args) { // Wir erstellen einen neuen Patienten, alle Variablen werden mit ihren Standardwerten initialisiert Patient john = new Patient(); // Wir greifen über den Punkt-Operator auf die Variablen zu und speichern Werte darin john.name = \"John\"; john.age = 30; john.height = 180f; System.out.println(john.name + \" \" + john.age + \" \" + john.height); Patient alice = new Patient(); alice.name = \"Alice\"; alice.age = 22; alice.height = 165f; System.out.println(alice.name + \" \" + alice.age + \" \" + alice.height); } } Im obigen Code haben wir zwei Patienten erstellt, John und Alice, die Werte ihrer Felder definiert und dann die Informationen über sie ausgedruckt. Wir sehen, dass wir mit dem Punkt-Operator auf die Felder des Objekts zugreifen können (john.name = “John”). Allerdings soll hier erwähnt sein, dass das nur geht, wenn die Instanzvariablen nicht private sind (wir behandeln das Thema Zugriffsmodifikatoren später).\nReferenzen teilen Objekte sind Referenztypen. In einer Variable wird also nicht das Objekt selbst, sondern die Speicheradresse hinterlegt, welche auf das Objekt zeigt. Es können sich also mehrere Referenzen auf dasselbe Objekt beziehen.\n1 2 3 4 5 6 7 8 Patient patient = new Patient(); patient.name = \"Mary\"; patient.age = 24; System.out.println(patient.name + \" \" + patient.age); // Mary 24 // Wir weisen der Variablen patient2 die Speicheradresse der Variablen patient zu Patient patient2 = patient; System.out.println(patient2.name + \" \" + patient2.age); // Mary 24 Es ist wichtig zu verstehen, dass sich die zwei Referenzen oben auf das gleiche Objekt im Speicher beziehen und nicht auf zwei unabhängige Kopien. Da unsere Klasse veränderbar ist, können wir das Objekt mit Hilfe beider Referenzen ändern.\n1 2 patient.age = 25; System.out.println(patient2.age); // 25 ","categories":"","description":"Modul #J2\n","excerpt":"Modul #J2\n","ref":"/de/docs/02_java/04_java-oop/01_oop/","tags":"","title":"Objektorientierte Programmierung"},{"body":"Projekt 2025 – Online Game Im Projekt 2025 ist das Ziel, ein einfaches Spiel zu realisieren, das online auf einer Webseite spielbar ist.\nDie einzelnen Teilprojekte orientieren sich am Ausbildungsstand und wachsen am Ende zu einer Gesamtlösung zusammen.\nModule Logger\nUtility-Klasse zur Ausgabe von Informationen über den Programmablauf.\nErste Version ohne OOP, rein statisch.\nTournament Engine\nPackage, das verschiedene Turnierarten unterstützt (z. B. Jeder-gegen-Jeden, KO-System, Weltmeisterschaft).\nTeilnehmer und Spielorte können definiert werden, der Ablauf ist abrufbar oder via Callbacks/Dependency Injection steuerbar.\nGame Engine\nVerantwortlich für den Spielablauf.\nZwei Implementierungen werden erstellt: Trumpf-Quartett und ein Fantasy-Kampf-Spiel (z. B. Elfen gegen Hexen).\nPersistence\nSpeicherung von Spielständen sowie Eigenschaften (z. B. Trumpfkarten, Fantasy-Figuren) in einer Datenbank.\nBackend\nAnstelle der Konsole wird das Spiel über eine REST-API mit Spring Boot zugänglich.\nFrontend\nZum Abschluss erhält das Spiel ein ansprechendes Web-Frontend.\nDas Lernprojekt erstreckt sich über rund 11 Monate und läuft parallel zum Modulplan.\nDie Projektaufgaben orientieren sich jeweils am aktuellen Ausbildungsstand.\nArchitektur Übersicht Varianten Es stehen zwei Umsetzungen zur Auswahl:\nHerr der Bits und Bytes – lass Elfen, Gnome, Zauberer und Hexen digital gegeneinander kämpfen Trumpf-Quartett – wähle ein Thema (z. B. Schiffe, Autos, Blumen) und entwickle ein digitales Kartenspiel ","categories":"","description":"Im Projekt 2025 entwickelst du ein einfaches Online-Spiel, das schrittweise aufgebaut wird. Von Utility-Klassen über eine Gaming Engine bis hin zu Backend und Frontend entsteht ein vollständiges Projekt.\n","excerpt":"Im Projekt 2025 entwickelst du ein einfaches Online-Spiel, das …","ref":"/project/project-2025/","tags":"","title":"Projekt 2025 – Online Game"},{"body":"In dieser Aufgabe wird ein Fantasy-Rollenspiel mit Vererbung modelliert. Lies zuerst die Einführung und arbeite dann die untenstehenden Aufgaben ab.\nEinführung Spielfiguren Es gibt verschiedene Spielfiguren: Menschen Zwerge Elfen Orks Goblins Trolle Jede Spielfigur hat einen Namen und besitzt eine bestimmte Anzahl an Lebenspunkten. Diese Lebenspunkte werden später im Kampf mit anderen Spielfiguren verringert Jede Spielfigur hat eine gewisse Tragkraft um Gegenstände und Ausrüstung mit sich herumtragen zu können (siehe weiter unten) Elfen können zaubern und haben einen Zauberwert Alle Spielfigur-Klassen sollen in einem entsprechenden Package angelegt werden Waffen Es gibt verschiedene Waffenarten Nahkampfwaffen (Schwert und Keule) Fernkampfwaffen (Bogen und Wurfmesser) Alle Waffen haben einen Angriffswert Nahkampfwaffen haben zusätzlich zu ihrem Angriffswert noch einen Verteidigungswert Alle Waffen haben ein Gewicht Alle Waffen-Klassen sollen in einem entsprechenden Package angelegt werden Gegenstände Es gibt verschiedene Gegenstände Tränke (Heiltrank und Stärketrank) Ein Heiltrank kann bei einer Spielfigur eine bestimmte Anzahl an Lebenspunkten wiederherstellen Ein Stärketrank erhöht den Angriffswert einer Spielfigur dauerhaft um einen bestimmten Wert Zauberringe (Kraftring, Schutzring) Ein Kraftring erhöht die Tragkraft einer Spielfigur dauerhaft um einen bestimmten Wert Ein Schutzring verringert dauerhaft den erlittenen Schaden Jeder Gegenstand hat eine Bezeichnung und ein Gewicht Alle Gegenstand-Klassen sollen in einem entsprechenden Package angelegt werden Aufgabe 1 Implementation\nder Packages der Klassen der Instanzvariablen in den Klassen der Beziehungen zwischen den einzelnen Klassen Vergiss nicht, dass es Generalisierungen und Spezalisierungen gibt. Achte auf eine gute Namensgebung bei Klassen und Variablen.\nAufgabe 2 Ergänze die Applikation mit den folgenden Möglichkeiten:\nSpielfigur Jede Spielfigur braucht einen Namen um instanziiert werden zu können Zu Beginn hat eine Spielfigur keine Waffe Jede Spielfigur hat eine Methode, die ihren Kampfwert zurückgibt Der Kampfwert der Spielfigur setzt sich aus dem Kampfwert der akitven Waffe und der Multiplikation mit einer Zufallszahl zusammen. Die Zufallszahl liegt zwischen 0.9 und 1.1 Wenn eine Spielfigur keine Waffe besitzt, so ist ihr Kampfwert 1 Elfen\nUm einen Elfen instanziieren zu können, muss zusätzlich zum Namen der Zauberwert des Elfen angegeben werden Einem Elfen wird die Hälfte seines Zauberwerts zum Kampfwert addiert Elfen sind gute Bogenschützen, ihr Kampfwert erhöht sich um 50%, wenn sie einen Bogen als aktive Waffe benutzen Goblins\nGoblins sind gute Bogenschützen, ihr Kampfwert erhöht sich um 50%, wenn sie einen Bogen als aktive Waffe benutzen Trolle\nTrolle verdoppeln ihren Kampfwert wenn sie eine Keule verwenden Orks\nOrks können in einen Kampfrausch verfallen, wenn ihre Lebenspunkte unter 25% fallen. Sie erhalten dann den dreifachen Kampfwert und erleiden nur den halben Schaden Waffen Jede Spielfigur kann mit einer Waffe ausgerüstet werden Wird eine Waffe aufgenommen, wird die Tragkraft entsprechend reduziert Ist die Waffe zu schwer für die verbleibende Tragkraft, so kann die Spielfigur die Waffe nicht aufnehmen Eine Spielfigur kann mehrere Waffen mit sich rumtragen, aber jeweils nur eine Waffe aktiv verwenden Spielfiguren können Waffen ablegen, um die verbleibende Tragkraft zu erhöhen Alle Keulen haben den Angriffswert 5 und den Verteidigungswert 5. Die beiden Werte sind also konstant Jede Waffe hat einen Kampfwert Waffen geben als Kampfwert ihren Angriffswert zurück Bei Nahkampfwaffen wird zum Angriffswert der halbe Verteidigungswert hinzuaddiert Gegenstände Jede Spielfigur kann Gegenstände bis zur maximalen Tragkraft aufnehmen Wird ein Gegenstand aufgenommen, wird die Tragkraft entsprechend reduziert Ist der Gegenstand zu schwer für die verbleibende Tragkraft, so kann die Spielfigur den Gegenstand nicht aufnehmen Eine Spielfigur kann mehrere Gegenstände mit sich rumtragen und diese Gegenstände später im Kampf aktiv einsetzen Kampf Jede Spielfigur kann gegen eine andere Spielfigur kämpfen Der Kampf findet in Runden statt Es wird solange gekämpft, bis eine oder beide Spielfiguren keine Lebenspunkte mehr haben Steht nach 20 Runden noch kein Sieger fest, wird der Kampf abgebrochen Bei jeder Runde wird der Kampfwert der einen Spielfigur den Lebenspunkten des Gegners abgezogen und umgekehrt Diejenige Spielfigur mit den meisten verbliebenen Lebenspunkten gewinnt Jede Spielfigur kann in einem Kampf von ihren Gegenständen Gebrauch machen Aufgabe 3 Definiere nun eigene Regeln für deine Spielfiguren, damit das Spiel ein wenig ausgeglichener wird Die Regeln können beliebig geändert werden Es dürfen natürlich auch neue Waffen und Gegenstände eingeführt werden Dein Entwurf soll mindestens eine neue Spielfigur, eine neue Waffe, einen neuen Gegenstand und eine neue Spezialität für eine Spielfigur enthalten Aufgabe 4 Die Kämpfe können sehr unausgeglichen sein Das Spiel soll so gestaltet werden, dass nicht immer die gleichen Spielfiguren gewinnen Aufgabe 5 Das Spiel soll für alle Aktionen einen übersichtlichen Log generieren Eine Ausgabe für die Kommandozeile genügt, wenn sie sauber formatiert ist Aufgabe 6 Die Applikation hat nun aufgrund der vielen Klassen und Möglichkeiten eine gewisse Grösse erreicht und damit auch an Übersichtlichkeit verloren. Die Logik der Applikation ist nun, je nach Implementation, in sehr vielen unterschiedlichen Klassen vorhanden. In bestimmten Fällen, wie der Spezalisierung einer bestimmten Klasse, ist dies in Ordnung.\nWir arbeiten aber wenn immer möglich nach dem Single-Responsibility-Principle. Dieses Prinzip besagt, dass jeder Teil (bspw. Klasse, Methode) einer Applikation nur für genau eine Aufgabe innerhalb dieser Applikation zuständig und verantwortlich ist. Kurz gesagt: eine Methode macht beispielsweise niemals zwei verschiedene Dinge gleichzeitig.\nErstelle eine Klasse, welche den Kampf zwischen zwei Spielfiguren verwaltet. Diese Klasse enthält diverse Methoden und ist verantwortlich für: das Starten eines neuen Kampfes zwischen zwei Spielfiguren das Zählen der Kampfrunden das Verrechnen von Schaden das Ermitteln des Gewinners Stelle sicher, dass die spezalisierten Modell-Klassen (Elf, Heiltrank) nur die Logik enthalten, die für eine Spezalisierung gerechtfertigt ist Beispiel 1: die Berechnung des Kampfwerts eines Elfen gehört in die Elf-Klasse, die diese die Spezialisierung für einen Elfen enthält Beispiel 2: der Kampf zwischen zwei Spielfiguren gehört NICHT in die Spielfigur-Klasse, da diese generell gültige Informationen zu einer Spielfigur enthält und das eigentliche “Spiel” mit dem Kampf zweier Spielfiguren nicht die Aufgabe dieser Klasse ist Aufgabe 7 Das Spiel soll erweitert werden, dass eine Spielfigur eine Rüstung tragen kann Es gibt leichte und schwere Rüstungen Elfen und Goblins dürfen nur leichte Rüstungen tragen Menschen, Zwerge und Orks dürfen schwere Rüstungen tragen Trolle können aufgrund ihrer Grösse keine Rüstung tragen Eine Spielfigur, welche eine schwere Rüstung tragen kann, kann selbstverständlich auch eine leichte Rüstung anziehen Eine Spielfigur muss nicht zwingend eine Rüstung tragen Jede Rüstung hat ein Gewicht, welches die Tragkraft der Spielfigur entsprechend verringert Eine Spielfigur kann eine Rüstung anziehen oder sie ablegen Mit dem Tragen einer Rüstung ist es einer Spielfigur möglich im Kampf pro Runde den Schaden komplett zu verhindern. Die schwere Rüstung ist dabei erfolgreicher. Das Verhindern von Schaden passiert zufällig Aufgabe 8 Verhindere die Instanziierung von Klassen, die keinen Sinn ergeben (Beispiel Waffe, Spielfigur, …) Aufgabe 9 Jede Spielfigur erhält einen Initiative-Wert Je höher der Wert, desto früher darf die Spielfigur im Kampf zuschlagen Tiefere Werte verteilen also ihren Schaden später als höhere Werte Eine Spielfigur mit tiefem Initiative-Wert kann nicht mehr zurückschlagen wenn sie getötet wird Das Tragen von schweren Rüstungen verringert den Initiative-Wert ","categories":"","description":"Exam zu Modul #J3 - OOD - Rollenspiel\n","excerpt":"Exam zu Modul #J3 - OOD - Rollenspiel\n","ref":"/exams/02_java/07_java-ood/01_rollenspiel/","tags":"","title":"Rollenspiel"},{"body":"In dieser Aufgabe wird ein Fantasy-Rollenspiel mit Vererbung modelliert. Lies zuerst die Einführung und arbeite dann die untenstehenden Aufgaben ab.\nEinführung Spielfiguren Es gibt verschiedene Spielfiguren: Menschen Zwerge Elfen Orks Goblins Trolle Jede Spielfigur hat einen Namen und besitzt eine bestimmte Anzahl an Lebenspunkten. Diese Lebenspunkte werden später im Kampf mit anderen Spielfiguren verringert Jede Spielfigur hat eine gewisse Tragkraft um Gegenstände und Ausrüstung mit sich herumtragen zu können (siehe weiter unten) Elfen können zaubern und haben einen Zauberwert Alle Spielfigur-Klassen sollen in einem entsprechenden Package angelegt werden Waffen Es gibt verschiedene Waffenarten Nahkampfwaffen (Schwert und Keule) Fernkampfwaffen (Bogen und Wurfmesser) Alle Waffen haben einen Angriffswert Nahkampfwaffen haben zusätzlich zu ihrem Angriffswert noch einen Verteidigungswert Alle Waffen haben ein Gewicht Alle Waffen-Klassen sollen in einem entsprechenden Package angelegt werden Gegenstände Es gibt verschiedene Gegenstände Tränke (Heiltrank und Stärketrank) Ein Heiltrank kann bei einer Spielfigur eine bestimmte Anzahl an Lebenspunkten wiederherstellen Ein Stärketrank erhöht den Angriffswert einer Spielfigur dauerhaft um einen bestimmten Wert Zauberringe (Kraftring, Schutzring) Ein Kraftring erhöht die Tragkraft einer Spielfigur dauerhaft um einen bestimmten Wert Ein Schutzring verringert dauerhaft den erlittenen Schaden Jeder Gegenstand hat eine Bezeichnung und ein Gewicht Alle Gegenstand-Klassen sollen in einem entsprechenden Package angelegt werden Aufgabe 1 Implementation\nder Packages der Klassen der Instanzvariablen in den Klassen der Beziehungen zwischen den einzelnen Klassen Vergiss nicht, dass es Generalisierungen und Spezalisierungen gibt. Achte auf eine gute Namensgebung bei Klassen und Variablen.\nAufgabe 2 Ergänze die Applikation mit den folgenden Möglichkeiten:\nSpielfigur Jede Spielfigur braucht einen Namen um instanziiert werden zu können Zu Beginn hat eine Spielfigur keine Waffe Jede Spielfigur hat eine Methode, die ihren Kampfwert zurückgibt Der Kampfwert der Spielfigur setzt sich aus dem Kampfwert der akitven Waffe und der Multiplikation mit einer Zufallszahl zusammen. Die Zufallszahl liegt zwischen 0.9 und 1.1 Wenn eine Spielfigur keine Waffe besitzt, so ist ihr Kampfwert 1 Elfen\nUm einen Elfen instanziieren zu können, muss zusätzlich zum Namen der Zauberwert des Elfen angegeben werden Einem Elfen wird die Hälfte seines Zauberwerts zum Kampfwert addiert Elfen sind gute Bogenschützen, ihr Kampfwert erhöht sich um 50%, wenn sie einen Bogen als aktive Waffe benutzen Goblins\nGoblins sind gute Bogenschützen, ihr Kampfwert erhöht sich um 50%, wenn sie einen Bogen als aktive Waffe benutzen Trolle\nTrolle verdoppeln ihren Kampfwert wenn sie eine Keule verwenden Orks\nOrks können in einen Kampfrausch verfallen, wenn ihre Lebenspunkte unter 25% fallen. Sie erhalten dann den dreifachen Kampfwert und erleiden nur den halben Schaden Waffen Jede Spielfigur kann mit einer Waffe ausgerüstet werden Wird eine Waffe aufgenommen, wird die Tragkraft entsprechend reduziert Ist die Waffe zu schwer für die verbleibende Tragkraft, so kann die Spielfigur die Waffe nicht aufnehmen Eine Spielfigur kann mehrere Waffen mit sich rumtragen, aber jeweils nur eine Waffe aktiv verwenden Spielfiguren können Waffen ablegen, um die verbleibende Tragkraft zu erhöhen Alle Keulen haben den Angriffswert 5 und den Verteidigungswert 5. Die beiden Werte sind also konstant Jede Waffe hat einen Kampfwert Waffen geben als Kampfwert ihren Angriffswert zurück Bei Nahkampfwaffen wird zum Angriffswert der halbe Verteidigungswert hinzuaddiert Gegenstände Jede Spielfigur kann Gegenstände bis zur maximalen Tragkraft aufnehmen Wird ein Gegenstand aufgenommen, wird die Tragkraft entsprechend reduziert Ist der Gegenstand zu schwer für die verbleibende Tragkraft, so kann die Spielfigur den Gegenstand nicht aufnehmen Eine Spielfigur kann mehrere Gegenstände mit sich rumtragen und diese Gegenstände später im Kampf aktiv einsetzen Kampf Jede Spielfigur kann gegen eine andere Spielfigur kämpfen Der Kampf findet in Runden statt Es wird solange gekämpft, bis eine oder beide Spielfiguren keine Lebenspunkte mehr haben Steht nach 20 Runden noch kein Sieger fest, wird der Kampf abgebrochen Bei jeder Runde wird der Kampfwert der einen Spielfigur den Lebenspunkten des Gegners abgezogen und umgekehrt Diejenige Spielfigur mit den meisten verbliebenen Lebenspunkten gewinnt Jede Spielfigur kann in einem Kampf von ihren Gegenständen Gebrauch machen Aufgabe 3 Definiere nun eigene Regeln für deine Spielfiguren, damit das Spiel ein wenig ausgeglichener wird Die Regeln können beliebig geändert werden Es dürfen natürlich auch neue Waffen und Gegenstände eingeführt werden Dein Entwurf soll mindestens eine neue Spielfigur, eine neue Waffe, einen neuen Gegenstand und eine neue Spezialität für eine Spielfigur enthalten Aufgabe 4 Die Kämpfe können sehr unausgeglichen sein Das Spiel soll so gestaltet werden, dass nicht immer die gleichen Spielfiguren gewinnen Aufgabe 5 Das Spiel soll für alle Aktionen einen übersichtlichen Log generieren Eine Ausgabe für die Kommandozeile genügt, wenn sie sauber formatiert ist Aufgabe 6 Die Applikation hat nun aufgrund der vielen Klassen und Möglichkeiten eine gewisse Grösse erreicht und damit auch an Übersichtlichkeit verloren. Die Logik der Applikation ist nun, je nach Implementation, in sehr vielen unterschiedlichen Klassen vorhanden. In bestimmten Fällen, wie der Spezalisierung einer bestimmten Klasse, ist dies in Ordnung.\nWir arbeiten aber wenn immer möglich nach dem Single-Responsibility-Principle. Dieses Prinzip besagt, dass jeder Teil (bspw. Klasse, Methode) einer Applikation nur für genau eine Aufgabe innerhalb dieser Applikation zuständig und verantwortlich ist. Kurz gesagt: eine Methode macht beispielsweise niemals zwei verschiedene Dinge gleichzeitig.\nErstelle eine Klasse, welche den Kampf zwischen zwei Spielfiguren verwaltet. Diese Klasse enthält diverse Methoden und ist verantwortlich für: das Starten eines neuen Kampfes zwischen zwei Spielfiguren das Zählen der Kampfrunden das Verrechnen von Schaden das Ermitteln des Gewinners Stelle sicher, dass die spezalisierten Modell-Klassen (Elf, Heiltrank) nur die Logik enthalten, die für eine Spezalisierung gerechtfertigt ist Beispiel 1: die Berechnung des Kampfwerts eines Elfen gehört in die Elf-Klasse, die diese die Spezialisierung für einen Elfen enthält Beispiel 2: der Kampf zwischen zwei Spielfiguren gehört NICHT in die Spielfigur-Klasse, da diese generell gültige Informationen zu einer Spielfigur enthält und das eigentliche “Spiel” mit dem Kampf zweier Spielfiguren nicht die Aufgabe dieser Klasse ist Aufgabe 7 Das Spiel soll erweitert werden, dass eine Spielfigur eine Rüstung tragen kann Es gibt leichte und schwere Rüstungen Elfen und Goblins dürfen nur leichte Rüstungen tragen Menschen, Zwerge und Orks dürfen schwere Rüstungen tragen Trolle können aufgrund ihrer Grösse keine Rüstung tragen Eine Spielfigur, welche eine schwere Rüstung tragen kann, kann selbstverständlich auch eine leichte Rüstung anziehen Eine Spielfigur muss nicht zwingend eine Rüstung tragen Jede Rüstung hat ein Gewicht, welches die Tragkraft der Spielfigur entsprechend verringert Eine Spielfigur kann eine Rüstung anziehen oder sie ablegen Mit dem Tragen einer Rüstung ist es einer Spielfigur möglich im Kampf pro Runde den Schaden komplett zu verhindern. Die schwere Rüstung ist dabei erfolgreicher. Das Verhindern von Schaden passiert zufällig Aufgabe 8 Verhindere die Instanziierung von Klassen, die keinen Sinn ergeben (Beispiel Waffe, Spielfigur, …) Aufgabe 9 Jede Spielfigur erhält einen Initiative-Wert Je höher der Wert, desto früher darf die Spielfigur im Kampf zuschlagen Tiefere Werte verteilen also ihren Schaden später als höhere Werte Eine Spielfigur mit tiefem Initiative-Wert kann nicht mehr zurückschlagen wenn sie getötet wird Das Tragen von schweren Rüstungen verringert den Initiative-Wert ","categories":"","description":"Exam zu Modul #J3 - OOD - Rollenspiel\n","excerpt":"Exam zu Modul #J3 - OOD - Rollenspiel\n","ref":"/de/exams/02_java/07_java-ood/01_rollenspiel/","tags":"","title":"Rollenspiel"},{"body":"Ziele Du lernst, wie man .env-Dateien verwendet. Du verwendest dotenv-java für einfache Integration in Java-Projekte. Du stellst sicher, dass deine API-Keys nicht im Code landen. ⏱️ Geschätzte Lesezeit: 10 Minuten Geheimnisse in einem Java-Projekt schützen Die nachfolgende Anleitung soll dir helfen, Geheimnisse zu schützen, welche dein Projekt benötigt (z.B. Passwort für Datenbank-Zugriff).\nSchritt 1: .env-Datei erstellen Im Projektverzeichnis (z. B. labs/) eine Datei .env mit folgendem Inhalt anlegen:\n1 GOOGLE_API_KEY=dein_api_key Diese Datei enthält vertrauliche Informationen und darf nicht ins Git-Repository eingecheckt werden.\nTrage sie deshalb in .gitignore ein:\n1 .env Vergewissere dich, dass die .env-Datei nicht ins Git-Repository gelangt – bevor du deine Geheimnisse einträgst! Schritt 2: Maven-Dependency hinzufügen Passe das Maven-Konfigurationsfile (pom.xml) an:\n1 2 3 4 5 \u003cdependency\u003e \u003cgroupId\u003eio.github.cdimascio\u003c/groupId\u003e \u003cartifactId\u003edotenv-java\u003c/artifactId\u003e \u003cversion\u003e3.0.0\u003c/version\u003e \u003c/dependency\u003e Falls du Probleme hast, die Maven-Dependency hinzuzufügen, prüfe, ob du mit dem VPN der SBB verbunden bist! Schritt 3: Zugriff im Java-Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import io.github.cdimascio.dotenv.Dotenv; import java.util.MissingResourceException; Dotenv dotenv = Dotenv.configure() .ignoreIfMissing() .load(); String apiKey = dotenv.get(\"GOOGLE_API_KEY\"); if (apiKey == null) { throw new MissingResourceException( \"API key not set. Please check your .env file or environment variables.\", \"GOOGLE_API_KEY\", null ); } dotenv-java prüft zuerst System.getenv(...), dann .env – ideal für lokale Entwicklung, Testing und Verteilung.\nWie die .env-Datei beim Deployment erstellt und verteilt wird, gehört zum Thema Configuration Management – das behandeln wir hier nicht weiter. Schritt 4: Vorlage für andere bereitstellen Lege eine .env.template oder .env.example mit folgendem Inhalt ins Repository:\n1 2 3 4 # This file contains the required environment variables! To use it, rename it to '.env'. # Always make sure that the '.env' file containing sensitive information is never committed to a Git repository! GOOGLE_API_KEY=HIER_EINTRAGEN Diese Datei darf eingecheckt werden – sie enthält keine echten Schlüssel, sondern dient als Vorlage.\nVorteile von dotenv-java Vorteil Beschreibung IDE-unabhängig Funktioniert mit IntelliJ, VS Code, CLI, Docker usw. Deployment-tauglich .env wird zur Laufzeit geladen – kein Startskript nötig Testing-freundlich Ideal für Integrationstests mit Umgebungsvariablen Einfach integrierbar Nur eine kleine, leichtgewichtige Dependency Zukunftssicher Standardlösung für reale Java-Projekte Natürlich ist dotenv-java nicht die einzige Möglichkeit, um Konfiguration und Code voneinander zu trennen. In anderen Projekten wirst du vielleicht auf alternative Lösungen stossen.\nWichtig ist dabei immer:\nGeheimnisse wie API-Schlüssel und Passwörter dürfen niemals im Quellcode oder in öffentlich zugänglichen Repositories gespeichert werden.\nIn CI/CD-Umgebungen (z. B. GitHub Actions, GitLab CI) ist die Verwendung einer .env-Datei nur im Rahmen von Tests oder lokalen Simulationen sinnvoll. Beim eigentlichen Build-Prozess hat sie keine Wirkung, da dort keine .env geladen wird – es sei denn, du startest deine Anwendung oder Tests explizit.\nFür produktive CI/CD-Prozesse solltest du die benötigten Werte als echte Umgebungsvariablen im jeweiligen CI-System hinterlegen.\nOptional: Einstieg mit IntelliJ Plugin „Env File“ Wenn du keine zusätzliche Bibliothek verwenden willst und nur lokal mit IntelliJ arbeitest, kannst du das Plugin Env File nutzen.\nInstallation IntelliJ IDEA öffnen → Settings → Plugins Nach Env File (von Aeris) suchen und installieren IntelliJ neu starten Run-Konfiguration anpassen Run-Konfiguration öffnen (Edit Configurations…) Abschnitt EnvFile aktivieren: ✅ „Enable EnvFile“ Mit ➕ deine .env-Datei hinzufügen Zugriff im Code 1 2 3 4 5 6 7 8 9 10 11 import java.util.MissingResourceException; String apiKey = System.getenv(\"GOOGLE_API_KEY\"); if (apiKey == null) { throw new MissingResourceException( \"API key not set. Please check your .env file or environment variables.\", \"GOOGLE_API_KEY\", null ); } Das Plugin funktioniert nur in IntelliJ und ist nicht geeignet für Deployment oder CI/CD.\nVerwende es nur zum Einstieg oder für Tests – produktiv empfehlen wir dotenv-java. Empfehlung für it-ninjas-Projekte Szenario Empfehlung Lokale Entwicklung (kurzfristig) .env + Plugin (optional) Verteilung, Produktivbetrieb .env mit dotenv-java Verwende dotenv-java, wenn dein Projekt wachsen oder weitergegeben werden soll.\nSo stellst du sicher, dass deine Zugangsdaten nicht im Code landen – und dein Projekt überall funktioniert.\n","categories":"","description":"Zugriff auf API-Keys im Java-Code – mit `.env` und der Bibliothek `dotenv-java`\n","excerpt":"Zugriff auf API-Keys im Java-Code – mit `.env` und der Bibliothek …","ref":"/docs/99_tools/ide/intellij/05_secrets/01_secrets-in-java/","tags":"","title":"Secrets im Java-Projekt"},{"body":"Um alle Übungen machen zu können wird eine lokale Datenbank benötigt. Dazu verwenden wir MariaDB. Falls du MariaDB noch nicht installiert hast, sind hier die Downloadlinks. Das DB-Tool dbeaver ist optional. Beim Download von MariaDB wird gleichzeitig HeidiSQL installiert, jedoch ist dieses Tool teilweise nicht so praktisch. Eine Alternative zu dbeaver ist die Intellij-Datenbankview, die bereits in Intellij ohne installation vorhanden ist.\nMariaDB:\nDownload: https://mariadb.org/download/ DB-Tool: https://dbeaver.io/download/ Intellij-Datenbankview: https://www.jetbrains.com/help/idea/relational-databases.html#first-steps Bei beiden Tools kann der normale Installationsprozess durchlaufen werden. Merke dir das Passwort, dass du bei MariaDB gesetzt hast. Du wirst es im nächsten Schritt brauchen. Nach der Installation kannst du DBeaver öffnen und MariaDB wie folgt verbinden:\nKlicke oben links auf das Verbinden-Icon (Stecker, im Bild rot markiert): Wähle MariaDB aus und klicke auf “Weiter”: Gib dein Passwort ein und klicke auf “Fertigstellen”: Wenn alles funktioniert hat, solltest du die DB in der Liste sehen können: Um ein SQL-Script auszuführen, musst du einen SQL-Editor öffnen. Mache dazu Rechtsklick auf localhost und wähle SQL-Editor -\u003e SQL-Skript aus:\nVom SQL-Editor aus kannst du alle gelernten SQL-Statements anwenden. Zuerst solltest du jedoch eine Datenbank mit CREATE DATABASE name erstellen. Dort kannst du wie in den Docs gelernt Tabellen usw. erstellen. Wenn diese Schritte funktioniert haben, bist du für die Labs bereit.\n","categories":"","description":"","excerpt":"Um alle Übungen machen zu können wird eine lokale Datenbank benötigt. …","ref":"/labs/05_database/01_setup/","tags":"","title":"Setup"},{"body":"Um alle Übungen machen zu können wird eine lokale Datenbank benötigt. Dazu verwenden wir MariaDB. Falls du MariaDB noch nicht installiert hast, sind hier die Downloadlinks. Das DB-Tool dbeaver ist optional. Beim Download von MariaDB wird gleichzeitig HeidiSQL installiert, jedoch ist dieses Tool teilweise nicht so praktisch. Eine Alternative zu dbeaver ist die Intellij-Datenbankview, die bereits in Intellij ohne installation vorhanden ist.\nMariaDB:\nDownload: https://mariadb.org/download/ DB-Tool: https://dbeaver.io/download/ Intellij-Datenbankview: https://www.jetbrains.com/help/idea/relational-databases.html#first-steps Bei beiden Tools kann der normale Installationsprozess durchlaufen werden. Merke dir das Passwort, dass du bei MariaDB gesetzt hast. Du wirst es im nächsten Schritt brauchen. Nach der Installation kannst du DBeaver öffnen und MariaDB wie folgt verbinden:\nKlicke oben links auf das Verbinden-Icon (Stecker, im Bild rot markiert): Wähle MariaDB aus und klicke auf “Weiter”: Gib dein Passwort ein und klicke auf “Fertigstellen”: Wenn alles funktioniert hat, solltest du die DB in der Liste sehen können: Um ein SQL-Script auszuführen, musst du einen SQL-Editor öffnen. Mache dazu Rechtsklick auf localhost und wähle SQL-Editor -\u003e SQL-Skript aus:\nVom SQL-Editor aus kannst du alle gelernten SQL-Statements anwenden. Zuerst solltest du jedoch eine Datenbank mit CREATE DATABASE name erstellen. Dort kannst du wie in den Docs gelernt Tabellen usw. erstellen. Wenn diese Schritte funktioniert haben, bist du für die Labs bereit.\n","categories":"","description":"","excerpt":"Um alle Übungen machen zu können wird eine lokale Datenbank benötigt. …","ref":"/de/labs/05_database/01_setup/","tags":"","title":"Setup"},{"body":" Voraussetzung Du weisst, was mit Geheimnissen gemeint ist. Du weisst was Umgebungsvariablen sind. Du weisst was Maven ist und kannst Maven-Projekte aufsetzen. Du weisst wie man bei Maven ein Paket hinzufügt. Wir stellen dir bei den Übungen jeweils komplette Projekte zur Verfügung. Du musst grundsätzlich nur dort was anpassen, wo die folgende Kommentarzeile steht:\nKopieren // IT-Ninja: Füge hier Deinen Code ein: 1 // IT-Ninja: Füge hier Deinen Code ein: Alles andere kannst du für den Moment ignorieren. Wir erklären dir die einzelnen Zeilen Schritt für Schritt in den Modulen.\nVorbereitungsarbeiten Drücke auf den Pfeil links um eine detaillierte Anleitung zu erhalten, wie Du den Quellcode auf deinem Rechner ablegen sollst.\nDiese Schritte musst du bei jeder Übung erneut machen. Jede Übung hat ein eigenes ZIP-File, welches du bei dir an die richtige Stelle kopieren musst. Die Anleitung zeigt dir ziemlich gut, wie das geht… Liess vor allem am Anfang die detaillierte Anleitung gut durch und befolge die Schritte exakt. Sie helfen dir, deinen Quellcode gut organisiert, strukturiert und sicher zu verwalten. Falls du die Anleitung schon auswendig kennst, findest du den Quellcode zur Übung direkt hier: Download | Online anschauen\nNeu bei it-ninja?\nDie Anleitung enthält einige Befehle und Fachbegriffe, die dir möglicherweise noch nichts sagen. Mach dir deswegen keine Sorgen – in den kommenden Modulen erklären wir dir alles Schritt für Schritt. Schon bald wirst auch du ein it-ninja sein. Um die folgenden Aufgaben erfolgreich umzusetzen, führe diese Schritte aus:\nBeim ersten Mal:\nIntelliJ IDEA installieren → !*IntelliJ IDEA einrichten Git-Repository einrichten → !*Persönliches Git-Repository Öffne eine !*CMD-Shell und wechsle ins Verzeichnis deines Git-Repositories:\nKopieren cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git status 1 2 cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git status Kopieren cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git status 1 2 cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git status Stelle sicher, dass alle Dateien im Git-Repository committed sind. Mit git status erhältst du eine Übersicht: Kopieren git status 1 git status Falls du bei diesem Befehl einen roten Text siehst, musst du zuerst die aktuellen Dateien sichern:\nKopieren git add . git commit -m \"[gescheiter Kommentar]\" 1 2 git add . git commit -m \"[gescheiter Kommentar]\" Erstelle oder wechsle in den Template Branch:\nBeim ersten Mal musst du einen Template Branch erstellen:\nKopieren git checkout -b \"templates\" 1 git checkout -b \"templates\" Falls er bereits existiert, kannst du einfach switchen:\nKopieren git switch \"templates\" 1 git switch \"templates\" Lade den Source-Code zu den Übungen herunter und entpacke ihn im Root-Verzeichnis deines lokalen Repositories:\n[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\nDen Source-Code findest du hier: Download | Online anschauen\nCommitte den originalen Source-Code, damit er sicher im Repository gespeichert ist:\nKopieren git add . git commit -m \"Add it-ninja_99_Tools_java_05_secrets_01_SimpleExample\" git push 1 2 3 git add . git commit -m \"Add it-ninja_99_Tools_java_05_secrets_01_SimpleExample\" git push Erstelle einen neuen Branch, um deine Lösung zu implementieren: Kopieren git checkout -b \"labs/it-ninja_99_Tools_java_05_secrets_01_SimpleExample\" 1 git checkout -b \"labs/it-ninja_99_Tools_java_05_secrets_01_SimpleExample\" Hier kannst du auch einen kürzeren Namen wählen. Verwende labs am Anfang des Branch-Namens für Branches, die deinen eigenen Code enthalten.\nStelle dir einen Branch vorerst als Ordner vor. Jeder Ordner enthält eine Version oder einen Stand von deinem Quellcode. Du kannst dann mit git zwischen diesen Ordern hin und her wechseln, sie vergleichen aber später auch zusammenführen.\nPro-Tipp:\nDu kannst jederzeit einen weiteren Branch erstellen – z. B. wenn du etwas ausprobieren möchtest. Alternativ kannst du auch in der Git-History einen alten Stand wiederherstellen, was aber weniger flexibel ist. Starte IntelliJ und öffne mit File → Open das Verzeichnis mit dem Source-Code. Du musst mit IntelliJ den Ordner suchen, welches einen Ordner src oder die Datei pom.xml enthält. Ansonsten wird IntelliJ Mühe haben, dir das Programm zu kompilieren. Wenn du alles korrekt gemacht hast, findest du das Projekt hier:\nKopieren `[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\\99_Tools\\java\\05_secrets\\01_SimpleExample` 1 `[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\\99_Tools\\java\\05_secrets\\01_SimpleExample` Kopieren `[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\\99_Tools/java/05_secrets/01_SimpleExample` 1 `[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\\99_Tools/java/05_secrets/01_SimpleExample` Falls du zum ersten Mal mit IntelliJ arbeitest, findest du !*hier eine Anleitung, wie man ein Programm startet. Um das Programm zu starten musst du jeweils die Datei Main.java öffenen. Dann sollte in IntelliJ oben rechts ein grünes Dreieck vorhanden sein, welches das Programm startet. Nun bist du bereit, die untenstehenden Aufgaben zu lösen.\nWenn du alle Änderungen gemacht hast und mit der Übung fertig bist, oder einen ‘Zwischenstand’ festhalten willst, führe die folgenden Befehle aus um das Repository auf dem Server zu speichern (von wo du es geklont hast):\nKopieren cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git add --all git commit -m \"Kurzer Kommentar\" 1 2 3 cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git add --all git commit -m \"Kurzer Kommentar\" Kopieren cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git add . git commit -m \"Kurzer Kommentar\" 1 2 3 cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git add . git commit -m \"Kurzer Kommentar\" Wenn du deine Änderungen auf dem Git-Server sichern willst, musst du das mit einem push machen.\nBeim ersten mal musst du git noch mitteilen, wie der Branch auf dem Git-Server heissen soll:\nKopieren git push --set-upstream origin labs/it-ninja_99_Tools_java_05_secrets_01_SimpleExample 1 git push --set-upstream origin labs/it-ninja_99_Tools_java_05_secrets_01_SimpleExample Bei weiteren pushes wird es dann einfacher:\nKopieren git push 1 git push Die meisten Übungen sind professionell strukturiert – so wie in echten Softwareprojekten. Zu gutem Code gehören auch Tests, die sicherstellen, dass dein Code wie erwartet funktioniert. Sofern nicht anders erwähnt, kannst du mit folgendem Befehl im Root-Verzeichnis des Projekts (dort, wo sich auch die pom.xml befindet) überprüfen, ob du die Aufgabe korrekt gelöst hast:\n1 mvn test Viel Erfolg!\nÜbung Das Beispiel zeigt, wie ein Projekt korrekt aufgesetzt wird, damit es sicher in einem Git-Repository gesichert werden kann.\nSchaue dir die Datei .env.template an und folge den Anweisungen dort. Ersetze dabei das_geheimnis mit mein_geheimnis.\nPasse das Maven-Konfigurationsfile (pom.xml) an:\n1 2 3 4 5 \u003cdependency\u003e \u003cgroupId\u003eio.github.cdimascio\u003c/groupId\u003e \u003cartifactId\u003edotenv-java\u003c/artifactId\u003e \u003cversion\u003e3.0.0\u003c/version\u003e \u003c/dependency\u003e Falls du Probleme hast, die Maven-Dependency hinzuzufügen, prüfe, ob du mit dem VPN der SBB verbunden bist! Wenn Du alles korrekt erledigt hast, sollte der Unittest erfolgreich durchlaufen:\n1 mvn test Wenn du den Unittest anschaust, wirst du feststellen, dass auch dort nirgends das Geheimnis im Klartext steht. Um zu testen, ob du das Geheimnis korrekt konfiguriert hast vergleichen wir es mit einem Hash. Der Hash kann nicht zurück in einen Klartext verwandelt werden, aber mit der Funktion match kann man feststellen, ob ein Wert den gleich Hash erzeugt und so verifizieren, ob der Wert korrekt ist. ","categories":"","description":"Dieses Beispiel zeigt, wie man Geheimnisse in einer Java Applikation sicher hinterlegen kann.\n","excerpt":"Dieses Beispiel zeigt, wie man Geheimnisse in einer Java Applikation …","ref":"/labs/99_tools/java/05_secrets/01_simpleexample/","tags":"","title":"Secrets - Geheimnisse sicher hinterlegen"},{"body":"Ziele Du verstehst, was ein Source Repository ist Du kennst die Unterschiede zwischen GitHub, GitLab und Bitbucket Du kannst ein Repository als Backup- und Versionsverwaltungs-Tool nutzen Was ist ein Source Repository? Ein Source Repository ist ein zentraler Ort, an dem Quellcode und andere Dateien gespeichert werden. Meistens basiert es auf Git, einem weit verbreiteten Versionskontrollsystem. Es erlaubt dir:\ndeine Arbeit chronologisch zu speichern (“Snapshots”), Änderungen nachzuvollziehen, auf frühere Versionen zurückzugreifen, und gemeinsam im Team an Projekten zu arbeiten. Ein Repository ist wie ein intelligentes Backup deiner Arbeit, kombiniert mit der Möglichkeit, Änderungen zu dokumentieren und zurückzuverfolgen. Anbieter im Vergleich Anbieter Beschreibung Authentifizierung Cloud / Self-Hosted GitHub Größtes öffentliches Repository-Netzwerk. Starke Community, viele Open-Source-Projekte. Benutzername + Token, SSH Cloud GitLab Fokus auf DevOps. CI/CD und Issue-Management direkt integriert. Benutzername + Token, SSH Cloud \u0026 Self-Hosted Bitbucket Wird von Atlassian (Hersteller von Jira) betrieben. Gut integriert in Unternehmensprozesse. Benutzername + Token, SSH Cloud \u0026 Self-Hosted Nutzung in der Ausbildung In der Talent Factory verwenden wir Bitbucket, da es intern gehostet wird und eine sichere Verwaltung deiner Arbeit ermöglicht. Du wirst lernen, wie du:\nein Repository erstellst, deine Dateien dort sicherst, Snapshots erstellst (Commits), und deine Arbeit jederzeit wiederherstellen kannst. Weiter zur praktischen Anleitung: 👉 Bitbucket Repository einrichten\n","categories":"","description":"Einführung in Source Repositories wie GitHub, GitLab und Bitbucket\n","excerpt":"Einführung in Source Repositories wie GitHub, GitLab und Bitbucket\n","ref":"/docs/99_tools/zusammenarbeit/source-repositories/","tags":"","title":"Source Repositories"},{"body":"Aufträge Voraussetzungen Im Lab zu Modul #J8 (JDBC) hast du ein persistentes Notenverwaltungssystem umgesetzt. Zu diesem Zweck hast du eine MariaDB-Instanz mit folgenden Tabellen aufgesetzt:\nSCHOOL_SUBJECT GRADE SCHOOL_SUBJECT_GRADE Mehr Details dazu findest du im obenerwähnten Lab. Diese Datenbank und das dazu gehörende Datenbankmodel wirst du für unsere Spring-Aufgabe benötigen.\nBei Bedarf kannst du das Model erweitern.\nAuftrag Die Aufgaben in diesem Lab führen dich Schritt für Schritt durch die Umsetzung einer Webanwendung mit Spring Boot, welche einem Notenverwaltungssystem entspricht. Die folgenden Abschnitte listen die groben Funktionalen (was soll die Anwendung können) und die nicht-funktionalen (zusätzliche Anforderungen z.B. an die Qualität der Anwendung) Anforderungen an die Anwendung auf. Der Ablauf, um ein Spring Projekt zu erstellen, findet du in den Docs zu Spring Boot.\nFunktionale Anforderungen Die Anwendung unterstützt zwei unterschiedliche Profile: “student” und “admin” Wenn die Anwendung mit dem Profil “student” gestartet wird, stehen die folgenden Funktionalitäten zur Verfügung: Alle Fächer und all deren Noten auflisten (ein Fach kann mehreren Noten beinhalten) Alle Fächer und deren Durchschnittsnote auflisten Für ein bestimmtes Fach: Alle Noten und die Durchschnittsnote des Fachs auflisten Eine neue Note hinzufügen Eine bestehende Note ändern Eine bestehende Note löschen Wenn die Anwendung mit dem Profil “admin” gestartet wird, stehen zusätzlich auch folgende Funktionalitäten zur Verfügung: Alle Fächer auflisten Neue Fächer hinzufügen Bestehende Fächer bearbeiten Bestehende Fächer löschen Die Anwendung bietet die Möglichkeit abzufragen, welches Profil gestartet ist. Nicht funktionale Anforderungen (NFAs) Der Code (das Design) der Anwendung ist sinnvoll in entsprechenden Packages aufgeteilt. Eine Klasse hat eine einzige Aufgabe (Single Responsibility Principle). Direkter Zugriff auf der internen Struktur einer Klasse ist verboten (Encapsulation / Information Hiding). Jede Klasse ist getestet. Unittests Schreibe zu den Integrationtests auch noch Unittest. Diese solltest du aus J4 Testing bereits kennen.\nZurück zur Spring und Spring Boot Theorie.\n","categories":"","description":"Umsetzung einer Spring Boot Applikation für die Notenverwaltung aus Modul #J8\n","excerpt":"Umsetzung einer Spring Boot Applikation für die Notenverwaltung aus …","ref":"/labs/02_java/12_spring-framework/01_spring/","tags":"","title":"Spring und Spring Boot - Aufgaben"},{"body":"Aufträge Voraussetzungen Im Lab zu Modul #J8 (JDBC) hast du ein persistentes Notenverwaltungssystem umgesetzt. Zu diesem Zweck hast du eine MariaDB-Instanz mit folgenden Tabellen aufgesetzt:\nSCHOOL_SUBJECT GRADE SCHOOL_SUBJECT_GRADE Mehr Details dazu findest du im obenerwähnten Lab. Diese Datenbank und das dazu gehörende Datenbankmodel wirst du für unsere Spring-Aufgabe benötigen.\nBei Bedarf kannst du das Model erweitern.\nAuftrag Die Aufgaben in diesem Lab führen dich Schritt für Schritt durch die Umsetzung einer Webanwendung mit Spring Boot, welche einem Notenverwaltungssystem entspricht. Die folgenden Abschnitte listen die groben Funktionalen (was soll die Anwendung können) und die nicht-funktionalen (zusätzliche Anforderungen z.B. an die Qualität der Anwendung) Anforderungen an die Anwendung auf. Der Ablauf, um ein Spring Projekt zu erstellen, findet du in den Docs zu Spring Boot.\nFunktionale Anforderungen Die Anwendung unterstützt zwei unterschiedliche Profile: “student” und “admin” Wenn die Anwendung mit dem Profil “student” gestartet wird, stehen die folgenden Funktionalitäten zur Verfügung: Alle Fächer und all deren Noten auflisten (ein Fach kann mehreren Noten beinhalten) Alle Fächer und deren Durchschnittsnote auflisten Für ein bestimmtes Fach: Alle Noten und die Durchschnittsnote des Fachs auflisten Eine neue Note hinzufügen Eine bestehende Note ändern Eine bestehende Note löschen Wenn die Anwendung mit dem Profil “admin” gestartet wird, stehen zusätzlich auch folgende Funktionalitäten zur Verfügung: Alle Fächer auflisten Neue Fächer hinzufügen Bestehende Fächer bearbeiten Bestehende Fächer löschen Die Anwendung bietet die Möglichkeit abzufragen, welches Profil gestartet ist. Nicht funktionale Anforderungen (NFAs) Der Code (das Design) der Anwendung ist sinnvoll in entsprechenden Packages aufgeteilt. Eine Klasse hat eine einzige Aufgabe (Single Responsibility Principle). Direkter Zugriff auf der internen Struktur einer Klasse ist verboten (Encapsulation / Information Hiding). Jede Klasse ist getestet. Unittests Schreibe zu den Integrationtests auch noch Unittest. Diese solltest du aus J4 Testing bereits kennen.\nZurück zur Spring und Spring Boot Theorie.\n","categories":"","description":"Umsetzung einer Spring Boot Applikation für die Notenverwaltung aus Modul #J8\n","excerpt":"Umsetzung einer Spring Boot Applikation für die Notenverwaltung aus …","ref":"/de/labs/02_java/12_spring-framework/01_spring/","tags":"","title":"Spring und Spring Boot - Aufgaben"},{"body":" Dieses Kapitel gehört zum Modul #J1 des Ausbildungsplans Ziele Ich weiss, dass jede Anweisung mit einem Strichpunkt (auch bekannt als Semikolon: ;) abgeschlossen werden muss. Ich weiss, dass geschweifte Klammern einen Block definieren und ich verwende sie in jeder Kontrollstruktur, um die Codeblöcke voneinander abzugrenzen. Ich kenne die main-Methode und weiss, warum eine Applikation nur EINE main-Methode haben sollte. Ich kenne die Methode System.out.println und kann sie anwenden. ⏱️ Geschätzte Lesezeit: 10 Minuten Cheatsheet zum Herunterladen Das Cheatsheet enthält eine Übersicht über grundlegende Java-Syntax, wichtige Befehle und Beispiele. Ideal als schnelle Nachschlagehilfe beim Üben: !Core Java Cheatsheet\nEinführung Als Java-Entwickler/in schreibst du ein Programm in eine Textdatei mit der Erweiterung .java. Diese Datei enthält den Quellcode. Der Compiler (javac) wandelt diesen Quellcode in eine .class-Datei um, die den Bytecode enthält. Anschliessend führt die JVM den Bytecode aus. Der Prozess von „Code schreiben“ über „kompilieren“ bis hin zum „ausführen“ sieht einfach aus, doch die eigentliche Arbeit übernimmt die JVM, die den plattformunabhängigen Bytecode ausführt: Wie du im Bild siehst, kann der Java Byte Code auf einem OSX, Linux oder Windows Rechner ausgeführt werden. Das ist der grosse Vorteil einer platformunabhängigen Programmiersprache. Bei vielen anderen Sprachen wie C oder C++ wandelt der Compiler den Quellcode zusammen mit platformabhängigen Bibliotheken direkt in Maschinenausführbaren Code um. Dieser Code wird auch nativer Code bezeichnet und es muss neben der Platform (OSX, Linux, Windows) auch die Architektur des Prozessors (X86, ARM) bekannt sein. Hello World Anhand des simplen Hello-World-Programms können wir bereits vieles über die zentralen Bestandteile einer Java-Anwendung erklären. Der folgende Quellcode ist in einer Datei mit dem Namen HelloWorld.java abgelegt.\n1 2 3 4 5 public class HelloWorld { public static void main(String[] args) { System.out.println(\"Hello, world!\"); } } Klasse definieren: Der Quellcode beginnt mit der Definition einer Klasse namens HelloWorld. Der Name der Klasse muss exakt mit dem Dateinamen übereinstimmen, also wie oben definiert: HelloWorld.java. Der Block der Klasse beginnt und endet mit geschweiften Klammern {}.\nDie main-Methode: Die main-Methode ist der Startpunkt jedes Java-Programms. Sie wird als Erstes aufgerufen, wenn du dein Programm ausführst. Der Name der Methode ist immer main und ihre Signatur lautet:\n1 public static void main(String[] args){} Dies bedeutet, dass die Methode öffentlich zugänglich (public) ist, zur Klasse selbst gehört (static) und sie keinen Rückgabewert hat (void).\nAusgabe auf die Konsole: Innerhalb der main-Methode befindet sich die Anweisung System.out.println(\"Hello, world!\");. Diese Anweisung gibt den Text „Hello, world!“ in der Konsole aus. Jede Anweisung in Java endet mit einem Semikolon.\nJetzt kennst du die Grundstruktur eines Java-Programms! Probiere es aus, indem du dein erstes Programm schreibst und kompilierst.\nJetzt bist du dran. Löse bitte die folgende !*Aufgabe in den Labs. Vom einfachen Beispiel zum echten Projekt Im vorherigen Kapitel hast du ein einfaches Java-Programm geschrieben – eine einzelne Datei mit dem Namen HelloWorld.java. Damit konntest du sehen, wie man ein Java-Programm grundsätzlich startet und ausführt.\nDoch sobald Programme grösser werden – mit mehreren Klassen, Tests und Bibliotheken – reicht so ein einzelnes File nicht mehr aus.\nDeshalb verwenden wir bei it-ninja von Anfang an ein strukturierteres Projektlayout, wie es auch in der Berufswelt üblich ist. Das klingt auf den ersten Blick vielleicht komplizierter, bringt aber viele Vorteile – vor allem, wenn du später mit modernen Tools und grösseren Projekten arbeitest.\nAber keine Sorge – wir starten jetzt nicht gleich mit viel Theorie oder komplexen Konzepten. Stattdessen schauen wir uns das Hello World-Beispiel gleich nochmals an – dieses Mal aber in der strukturierten Projektform, wie sie in der Praxis üblich ist.\nDabei wirst du sehen, dass sich gar nicht so viel ändert – aber der Aufbau deutlich mehr Möglichkeiten bietet. Und danach kannst du direkt mit ein paar kleinen Übungen loslegen, um dich mit dem Aufbau und der Arbeitsweise vertraut zu machen.\nJetzt bist du dran. Löse bitte die folgenden !*Aufgaben in den Labs. ","categories":"","description":"In diesem Module lernst du die Struktur kennen, wie ein Java Programm aufgebaut ist.\n","excerpt":"In diesem Module lernst du die Struktur kennen, wie ein Java Programm …","ref":"/docs/02_java/03_java-grundlagen/01_java_intro/","tags":"","title":"Struktur und Syntax"},{"body":"Inhalt In diesem Bereich werden Tools vorgestellt, welche du beim Erstellen von Lerndokumentation o.ä\neinsetzen wirst.\n","categories":"","description":"Einführung Markdown,   Word Basics\n","excerpt":"Einführung Markdown,   Word Basics\n","ref":"/de/docs/01_tools/","tags":"","title":"Tools"},{"body":"Die folgenden Aufgaben bestehen darin für bestehende Programmlogik entsprechende Unit-Tests zu schreiben.\nAufgabe 1: Tageszeit Schreibe Unit-Tests, um die Logik der folgenden Methode zu testen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import java.time.LocalDateTime; public class TimeOfDay { public String getTimeOfDay(LocalDateTime time) { if (time.getHour() \u003c 6) { return \"Night\"; } if (time.getHour() \u003c 12) { return \"Morning\"; } if (time.getHour() \u003c 18) { return \"Afternoon\"; } return \"Evening\"; } } Aufgabe 2 Schreibe Unit-Tests, um die Methode move zu testen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 public class Mover { private LocalDateTime lastMovingTime; private Direction lastDirection; public void move(Direction direction) { if (Direction.getOpposite(direction) != this.lastDirection) { this.lastDirection = direction; this.lastMovingTime = LocalDateTime.now(); } } public LocalDateTime getLastMovingTime() { return lastMovingTime; } public Direction getLastDirection() { return lastDirection; } public enum Direction { NORTH, EAST, SOUTH, WEST; public static Direction getOpposite(Direction direction) { switch (direction) { case NORTH -\u003e { return SOUTH; } case EAST -\u003e { return WEST; } case SOUTH -\u003e { return NORTH; } case WEST -\u003e { return EAST; } } return null; } } } Falls du meinst, dass es unmöglich ist diese Methode genau zu testen. Schreibe die Methode um, damit sie einfacher zu testen ist. Benutze dazu ein Clock-Objekt. Weitere Informationen findest du hier.\nAufgabe 3 In dieser Aufgabe geht es darum, dass die Unit-Tests für eine bestimmte Methode schon geschrieben wurden. Die Methode muss nun implementiert werden, so dass sie alle Unit-Tests erfüllt. Arbeite dich von Test zu Test durch.\nTest Source\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 import static org.junit.jupiter.api.Assertions.assertTrue; import org.junit.jupiter.api.Test; public class PasswordValidatorTest { private PasswordValidator uut = new PasswordValidator(); @Test public void testPasswordNull() { assertFalse(this.uut.isPasswordValid(null)); } @Test public void testPasswordTooShort() { // NIST Password Guidelines: Minimum 8 Zeichen String password = \"aB1$Cd3\"; assertFalse(this.uut.isPasswordValid(password)); } @Test public void testPasswordTooLong() { // NIST Password Guidelines: Maximum 64 Zeichen String password = \"aB1$cdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!\"; assertFalse(this.uut.isPasswordValid(password)); } @Test public void testPasswordContainsNoSpace() { String password = \"aB1$cdefghij k\"; assertFalse(this.uut.isPasswordValid(password)); } @Test public void testPasswordContainsNoNumeric() { String password = \"aB$cdefghijklm\"; assertFalse(this.uut.isPasswordValid(password)); } @Test public void testPasswordContainsNoLowercaseChar() { String password = \"AB1$CDEFGHIJKLMN\"; assertFalse(this.uut.isPasswordValid(password)); } @Test public void testPasswordContainsNoUppercaseChar() { String password = \"ab1$cdefghijklmn\"; assertFalse(this.uut.isPasswordValid(password)); } @Test public void testPasswordContainsNoSpecialChar() { String password = \"aB1cdefghijklm\"; assertFalse(this.uut.isPasswordValid(password)); } @Test public void testPasswordValid() { String password = \"aB1$cdefghij\"; assertTrue(this.uut.isPasswordValid(password)); } } Source\n1 2 3 4 5 6 public class PasswordValidator { public boolean isPasswordValid(String password) { // Ersetze die Exception durch deine Implementation... throw new IllegalStateException(); } } Wenn du eine Lösung gefunden hast, dann kannst du diese noch aufräumen (Refactoring).\nHier kannst du zurück zur Theorie.\n","categories":"","description":"Aufgaben zu Modul #J4 - Unit Testing / JUnit\n","excerpt":"Aufgaben zu Modul #J4 - Unit Testing / JUnit\n","ref":"/labs/02_java/08_java-testing/01_unit-testing/","tags":"","title":"Unit Testing mit JUnit - Aufgaben"},{"body":"Die folgenden Aufgaben bestehen darin für bestehende Programmlogik entsprechende Unit-Tests zu schreiben.\nAufgabe 1: Tageszeit Schreibe Unit-Tests, um die Logik der folgenden Methode zu testen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import java.time.LocalDateTime; public class TimeOfDay { public String getTimeOfDay(LocalDateTime time) { if (time.getHour() \u003c 6) { return \"Night\"; } if (time.getHour() \u003c 12) { return \"Morning\"; } if (time.getHour() \u003c 18) { return \"Afternoon\"; } return \"Evening\"; } } Aufgabe 2 Schreibe Unit-Tests, um die Methode move zu testen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 public class Mover { private LocalDateTime lastMovingTime; private Direction lastDirection; public void move(Direction direction) { if (Direction.getOpposite(direction) != this.lastDirection) { this.lastDirection = direction; this.lastMovingTime = LocalDateTime.now(); } } public LocalDateTime getLastMovingTime() { return lastMovingTime; } public Direction getLastDirection() { return lastDirection; } public enum Direction { NORTH, EAST, SOUTH, WEST; public static Direction getOpposite(Direction direction) { switch (direction) { case NORTH -\u003e { return SOUTH; } case EAST -\u003e { return WEST; } case SOUTH -\u003e { return NORTH; } case WEST -\u003e { return EAST; } } return null; } } } Falls du meinst, dass es unmöglich ist diese Methode genau zu testen. Schreibe die Methode um, damit sie einfacher zu testen ist. Benutze dazu ein Clock-Objekt. Weitere Informationen findest du hier.\nAufgabe 3 In dieser Aufgabe geht es darum, dass die Unit-Tests für eine bestimmte Methode schon geschrieben wurden. Die Methode muss nun implementiert werden, so dass sie alle Unit-Tests erfüllt. Arbeite dich von Test zu Test durch.\nTest Source\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 import static org.junit.jupiter.api.Assertions.assertTrue; import org.junit.jupiter.api.Test; public class PasswordValidatorTest { private PasswordValidator uut = new PasswordValidator(); @Test public void testPasswordNull() { assertFalse(this.uut.isPasswordValid(null)); } @Test public void testPasswordTooShort() { // NIST Password Guidelines: Minimum 8 Zeichen String password = \"aB1$Cd3\"; assertFalse(this.uut.isPasswordValid(password)); } @Test public void testPasswordTooLong() { // NIST Password Guidelines: Maximum 64 Zeichen String password = \"aB1$cdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!\"; assertFalse(this.uut.isPasswordValid(password)); } @Test public void testPasswordContainsNoSpace() { String password = \"aB1$cdefghij k\"; assertFalse(this.uut.isPasswordValid(password)); } @Test public void testPasswordContainsNoNumeric() { String password = \"aB$cdefghijklm\"; assertFalse(this.uut.isPasswordValid(password)); } @Test public void testPasswordContainsNoLowercaseChar() { String password = \"AB1$CDEFGHIJKLMN\"; assertFalse(this.uut.isPasswordValid(password)); } @Test public void testPasswordContainsNoUppercaseChar() { String password = \"ab1$cdefghijklmn\"; assertFalse(this.uut.isPasswordValid(password)); } @Test public void testPasswordContainsNoSpecialChar() { String password = \"aB1cdefghijklm\"; assertFalse(this.uut.isPasswordValid(password)); } @Test public void testPasswordValid() { String password = \"aB1$cdefghij\"; assertTrue(this.uut.isPasswordValid(password)); } } Source\n1 2 3 4 5 6 public class PasswordValidator { public boolean isPasswordValid(String password) { // Ersetze die Exception durch deine Implementation... throw new IllegalStateException(); } } Wenn du eine Lösung gefunden hast, dann kannst du diese noch aufräumen (Refactoring).\nHier kannst du zurück zur Theorie.\n","categories":"","description":"Aufgaben zu Modul #J4 - Unit Testing / JUnit\n","excerpt":"Aufgaben zu Modul #J4 - Unit Testing / JUnit\n","ref":"/de/labs/02_java/08_java-testing/01_unit-testing/","tags":"","title":"Unit Testing mit JUnit - Aufgaben"},{"body":" Git [ɡɪt] ist eine freie Software zur verteilten Versionsverwaltung von Dateien, die durch Linus Torvalds initiiert wurde.\nInhalt Was ist Versionsverwaltung Geschichte Name Wie funktioniert Git Ziele Ich weiss, was eine Versionsverwaltung ist und kann erklären, wofür sie verwendet wird. Ich kenne die Unterschiede zwischen lokaler, zentraler und verteilter Versionsverwaltung. Ich kann anhand der drei Zustände einer Datei grob beschreiben wie Git funktioniert. Was ist Versionsverwaltung Eine Versionsverwaltung ist ein System, welches Änderungen an einer oder mehreren Dateien über die Zeit protokolliert, um die Entwicklung nachvollziehbar zu machen und womit man jederzeit auf bestimmte vorherige Versionen zugreifen kann.\nLokale Versionsverwaltung Eine lokale Versionsverwaltung hat wohl fast jeder schon mal bei sich eingesetzt. Die einfachste Version davon ist, wenn man zum Beispiel eine Datei kopiert und an der Kopie weiter arbeitet:\n1 2 [user@computer ~/gymi/arbeit/]$ ls matura_arbeit.docx matura_arbeit_fastfertig.docx matura_arbeit_wirklichfertig.docx matura_arbeit_wirklichfertig_formatiert.docx matura_final.docx Dies ist jedoch sehr fehleranfällig, da man schnell die falsche Datei erwischt. Aus diesem Grund, haben Programmierer bereits vor langer Zeit, lokale Versionsverwaltungssysteme entwickelt, die alle Änderungen an allen relevanten Dateien in einer Datenbank verwalten. Ein Beispiel dafür ist RCS\nZentrale Versionsverwaltung Um die Zusammenarbeit von mehreren Personen zu vereinfachen wurden zentrale Versionsverwaltungssysteme entwickelt. Diese Systeme basieren auf einem zentralen Server der alle Dateien verwaltet. User holen eine Datei ab (Auschecken oder engl. to check out) editieren sie und nur berechtigte User dürfen die Datei anschliessend wieder auf den Server stellen. Ein Beispiel dafür ist SVN\nVerteilte Versionsverwaltung Im Gegensatz zu zentralen Systemen, wo der Benutzer nur den letzten Stand zur Verfügung hat, kopiert er bei verteilten Versionsverwaltungen einen vollständigen Klon des Repositories auf sein System und hat somit auch die komplette Geschichte lokal. Dies vereinfacht dem Entwickler das lokale arbeiten und erhöht die Ausfallsicherheit. Zusätzlich können solche Systeme gut mit verschiedenen externen Repositories (Remotes) umgehen, was die Zusammenarbeit weiter vereinfacht. Ein Beispiel dafür ist GIT\nGeschichte Git entstand aufgrund einer Lizenzänderung von BitKeeper, der Versionsverwaltung welche vom Linux Kernel bis 2005 verwendet wurde. Da die Kernel Entwickler die Software nicht mehr kostenlos nutzen konnten, entwickelten sie selber eine Lösung. Ziele der neuen Software waren Geschwindigkeit, einfaches Design, gute Unterstützung von nicht linearer Entwicklung, dezentrale Struktur und die Fähigkeit grosse Projekte effektiv zu verwalten. Git wird seit 2005 kontinuierlich weiterentwickelt.\nName Der Name „Git“ bedeutet in der britischen Umgangssprache so viel wie „Blödmann“. Linus Torvalds erklärte seine Wahl des ungewöhnlichen Namens mit einem Witz sowie damit, dass das Wort praktikabel und in der Softwarewelt noch weitgehend unbenutzt war:\n„Ich bin ein egoistischer Mistkerl, und ich benenne all meine Projekte nach mir. Zuerst ‚Linux‘, jetzt eben ‚Git‘.“\n– Linus Torvalds\nDazu muss man anmerken, dass Linus den Namen Linux nur widerwillig akzeptierte.\nWie funktioniert Git Git funktioniert im Gegensatz zu den meisten anderen Versionsverwaltungen nicht, indem es eine Liste von Änderungen an einer Datei abspeichert, sondern eher wie ein Dateisystem, welches bei jedem Commit ein Snapshot aller Dateien anlegt. Um effizient zu bleiben, werden unveränderte Dateien nicht kopiert sondern nur verknüpft. Weiter stellt Git die Integrität aller verwalteten Dateien sicher, indem es eine Prüfsumme jeder Datei anlegt. Dies verunmöglicht Änderungen an Dateien, ohne dass es Git mitbekommen würde.\nDrei Zustände einer Datei Eine Datei in einem Git Repository kann drei (Haupt-) Zustände haben:\nModified: Die Datei wurde geändert aber noch nicht in die lokale Datenbank eingecheckt. Staged: Die Datei wurde im aktuellen Zustand für den nächsten Commit vorgemerkt. Commited: Die Datei ist im aktuellen Zustand in die lokale Datenbank eingecheckt. Minimaler Workflow Hat man ein Repository von einem anderen Rechner geklont, kann man eine oder mehrere Dateien im Verzeichnisbaum editieren. Anschliessend staged man diese Änderungen und commited diese zum Schluss.\n","categories":"","description":"","excerpt":" Git [ɡɪt] ist eine freie Software zur verteilten Versionsverwaltung …","ref":"/docs/04_git/01_grundwissen/01_was-ist-git/","tags":"","title":"Was ist Git"},{"body":" Git [ɡɪt] ist eine freie Software zur verteilten Versionsverwaltung von Dateien, die durch Linus Torvalds initiiert wurde.\nInhalt Was ist Versionsverwaltung Geschichte Name Wie funktioniert Git Ziele Ich weiss, was eine Versionsverwaltung ist und kann erklären, wofür sie verwendet wird. Ich kenne die Unterschiede zwischen lokaler, zentraler und verteilter Versionsverwaltung. Ich kann anhand der drei Zustände einer Datei grob beschreiben wie Git funktioniert. Was ist Versionsverwaltung Eine Versionsverwaltung ist ein System, welches Änderungen an einer oder mehreren Dateien über die Zeit protokolliert, um die Entwicklung nachvollziehbar zu machen und womit man jederzeit auf bestimmte vorherige Versionen zugreifen kann.\nLokale Versionsverwaltung Eine lokale Versionsverwaltung hat wohl fast jeder schon mal bei sich eingesetzt. Die einfachste Version davon ist, wenn man zum Beispiel eine Datei kopiert und an der Kopie weiter arbeitet:\n1 2 [user@computer ~/gymi/arbeit/]$ ls matura_arbeit.docx matura_arbeit_fastfertig.docx matura_arbeit_wirklichfertig.docx matura_arbeit_wirklichfertig_formatiert.docx matura_final.docx Dies ist jedoch sehr fehleranfällig, da man schnell die falsche Datei erwischt. Aus diesem Grund, haben Programmierer bereits vor langer Zeit, lokale Versionsverwaltungssysteme entwickelt, die alle Änderungen an allen relevanten Dateien in einer Datenbank verwalten. Ein Beispiel dafür ist RCS\nZentrale Versionsverwaltung Um die Zusammenarbeit von mehreren Personen zu vereinfachen wurden zentrale Versionsverwaltungssysteme entwickelt. Diese Systeme basieren auf einem zentralen Server der alle Dateien verwaltet. User holen eine Datei ab (Auschecken oder engl. to check out) editieren sie und nur berechtigte User dürfen die Datei anschliessend wieder auf den Server stellen. Ein Beispiel dafür ist SVN\nVerteilte Versionsverwaltung Im Gegensatz zu zentralen Systemen, wo der Benutzer nur den letzten Stand zur Verfügung hat, kopiert er bei verteilten Versionsverwaltungen einen vollständigen Klon des Repositories auf sein System und hat somit auch die komplette Geschichte lokal. Dies vereinfacht dem Entwickler das lokale arbeiten und erhöht die Ausfallsicherheit. Zusätzlich können solche Systeme gut mit verschiedenen externen Repositories (Remotes) umgehen, was die Zusammenarbeit weiter vereinfacht. Ein Beispiel dafür ist GIT\nGeschichte Git entstand aufgrund einer Lizenzänderung von BitKeeper, der Versionsverwaltung welche vom Linux Kernel bis 2005 verwendet wurde. Da die Kernel Entwickler die Software nicht mehr kostenlos nutzen konnten, entwickelten sie selber eine Lösung. Ziele der neuen Software waren Geschwindigkeit, einfaches Design, gute Unterstützung von nicht linearer Entwicklung, dezentrale Struktur und die Fähigkeit grosse Projekte effektiv zu verwalten. Git wird seit 2005 kontinuierlich weiterentwickelt.\nName Der Name „Git“ bedeutet in der britischen Umgangssprache so viel wie „Blödmann“. Linus Torvalds erklärte seine Wahl des ungewöhnlichen Namens mit einem Witz sowie damit, dass das Wort praktikabel und in der Softwarewelt noch weitgehend unbenutzt war:\n„Ich bin ein egoistischer Mistkerl, und ich benenne all meine Projekte nach mir. Zuerst ‚Linux‘, jetzt eben ‚Git‘.“\n– Linus Torvalds\nDazu muss man anmerken, dass Linus den Namen Linux nur widerwillig akzeptierte.\nWie funktioniert Git Git funktioniert im Gegensatz zu den meisten anderen Versionsverwaltungen nicht, indem es eine Liste von Änderungen an einer Datei abspeichert, sondern eher wie ein Dateisystem, welches bei jedem Commit ein Snapshot aller Dateien anlegt. Um effizient zu bleiben, werden unveränderte Dateien nicht kopiert sondern nur verknüpft. Weiter stellt Git die Integrität aller verwalteten Dateien sicher, indem es eine Prüfsumme jeder Datei anlegt. Dies verunmöglicht Änderungen an Dateien, ohne dass es Git mitbekommen würde.\nDrei Zustände einer Datei Eine Datei in einem Git Repository kann drei (Haupt-) Zustände haben:\nModified: Die Datei wurde geändert aber noch nicht in die lokale Datenbank eingecheckt. Staged: Die Datei wurde im aktuellen Zustand für den nächsten Commit vorgemerkt. Commited: Die Datei ist im aktuellen Zustand in die lokale Datenbank eingecheckt. Minimaler Workflow Hat man ein Repository von einem anderen Rechner geklont, kann man eine oder mehrere Dateien im Verzeichnisbaum editieren. Anschliessend staged man diese Änderungen und commited diese zum Schluss.\n","categories":"","description":"","excerpt":" Git [ɡɪt] ist eine freie Software zur verteilten Versionsverwaltung …","ref":"/de/docs/04_git/01_grundwissen/01_was-ist-git/","tags":"","title":"Was ist Git"},{"body":"Für dieses Exam dürfen auch Inhalte der Themen Lists und Generics verwendet werden.\nWeltmeisterschaft - OOP Exam Bei diesem Exam geht es darum, dass du deine Vorgehensweise beim Erstellen eines objektorientierten Modells trainierst.\nZentral bei dieser Aufgabe ist also, wie du das Datenmodell erstellst, welches beschreibt, welche Klassen mit welchen Feldern und Methoden du schreibst.\nZiel ist nicht, dass du dich mit Scanner oder viel Logik herumschlagen musst.\nSachverhalt Bei diesem Exam modellierst du das Turnier von der Fussball-WM 1954 in der Schweiz. Im Prinzip sollst du die Informationen, die in der results.txt-Datei gespeichert sind, im Code abbilden. Die Idee ist nicht, dass du diese Datei im Programm ausliest oder diese Information mit System.out.print() direkt ausgibst, sondern dass dein Code die Informationen repräsentiert. Mehr dazu in Aufgabe 3.\nDeine Klassen sollen folgendes abbilden:\nIn diesem Turnier (Competition) spielen die Mannschaften (Team) gegeneinander. Jedes Spiel beschreibt entweder eine Vorrunde/Gruppenspiel (GROUP), PLAYOFF, Viertel- (QUARTER_FINAL), Halbfinale (SEMI_FINAL) oder FINAL. Bei jedem Spiel (Game) gibt es immer eine Heim- (home) und Gast-Mannschaft (visiting/away team). Bei jedem Spiel wird festgehalten, wie viele Tore (goals) welche Mannschaft (home oder visiting) geschossen hat. Zudem wird festgehalten, wo (location) das Spiel stattgefunden hat. Was soll die Anwendung können? Auf Stufe Spiel (Game)\nmöchten wir wissen, ob eine bestimmte Mannschaft dieses Spiel gespielt hat (didTeamPlayThisGame(team)). Zudem möchten wir schnell ermitteln können, wie viele Punkte eine Mannschaft in diesem Spiel erzielt hat (Sieg: 3, Unentschieden: 1, Niederlage: 0) (getPointsFor(team)). Auf Stufe Turnier (Competition)\nwollten wir ermitteln können, welche Mannschaft wie viele Punkte während der Gruppenphase erzielt hat (getScoresDuringGroupStageFor(team)). Zudem möchten wir herausfinden, wie viele Tore eine Mannschaft während des ganzen Turniers geschossen hat (getGoalsForTeam(team)). Des Weiteren wollen wir eine Auflistung, welche Spiele alles an einem bestimmten Ort (location) stattgefunden haben (getAllGamesForLocation(location)). Abgesehen von der main(...)-Methode soll keine weitere Methode statisch sein.\nAufgaben Aufgabe 1 - Entwurf Erstelle einen Entwurf vom Klassenmodell.\nDer Entwurf kann auf Papier oder mit einem Tool (z.B. draw.io, Visio, plantUML) erstellt werden. Plane auch schon die Methoden im Entwurf ein. Zeige den Entwurf zuerst einem Praxisbildner, bevor du weiterfährst.\nAufgabe 2 - Klassen umsetzen Setze die Klassen im Code um, inkl. Methoden.\nFür den Moment müssen die Methoden noch nichts machen und sollen für den Beginn nur einen Default-Wert zurückgeben - der Einfachheit halber.\nZiel dieser Aufgabe ist, dass du dich nur aufs Klassen-Design im Code konzentrierst, nicht aber um die konkreten Methoden-Umsetzungen.\nAufgabe 3 - Methoden umsetzen Setze nun die Methoden korrekt um.\nVerwende zur Demonstration die Daten aus der results.txt-Datei. Du sollst die Daten nicht automatisiert via Dateisystem laden, sondern du kannst die Informationen aus dieser Datei direkt hartkodiert in eine .java-Datei hinein kopieren und in Java-Code umschreiben, damit es mit deinen Klassen kompatibel ist. Damit ist keine Hexerei erwartet, sondern wenn z.B. folgendes in der results.txt-Datei steht\n1 2 # Gruppe 1 Frankreich\tJugoslawien\t0:1 dann kannst du das wie folgt direkt in deine Java-Datei schreiben:\n1 new Game(FRANCE, YUGOSLAVIA, 0, 1); ","categories":"","description":"Exam zu Modul #J2\n","excerpt":"Exam zu Modul #J2\n","ref":"/exams/02_java/04_java-oop/01_weltmeisterschaft/","tags":"","title":"Weltmeisterschaft"},{"body":"Für dieses Exam dürfen auch Inhalte der Themen Lists und Generics verwendet werden.\nWeltmeisterschaft - OOP Exam Bei diesem Exam geht es darum, dass du deine Vorgehensweise beim Erstellen eines objektorientierten Modells trainierst.\nZentral bei dieser Aufgabe ist also, wie du das Datenmodell erstellst, welches beschreibt, welche Klassen mit welchen Feldern und Methoden du schreibst.\nZiel ist nicht, dass du dich mit Scanner oder viel Logik herumschlagen musst.\nSachverhalt Bei diesem Exam modellierst du das Turnier von der Fussball-WM 1954 in der Schweiz. Im Prinzip sollst du die Informationen, die in der results.txt-Datei gespeichert sind, im Code abbilden. Die Idee ist nicht, dass du diese Datei im Programm ausliest oder diese Information mit System.out.print() direkt ausgibst, sondern dass dein Code die Informationen repräsentiert. Mehr dazu in Aufgabe 3.\nDeine Klassen sollen folgendes abbilden:\nIn diesem Turnier (Competition) spielen die Mannschaften (Team) gegeneinander. Jedes Spiel beschreibt entweder eine Vorrunde/Gruppenspiel (GROUP), PLAYOFF, Viertel- (QUARTER_FINAL), Halbfinale (SEMI_FINAL) oder FINAL. Bei jedem Spiel (Game) gibt es immer eine Heim- (home) und Gast-Mannschaft (visiting/away team). Bei jedem Spiel wird festgehalten, wie viele Tore (goals) welche Mannschaft (home oder visiting) geschossen hat. Zudem wird festgehalten, wo (location) das Spiel stattgefunden hat. Was soll die Anwendung können? Auf Stufe Spiel (Game)\nmöchten wir wissen, ob eine bestimmte Mannschaft dieses Spiel gespielt hat (didTeamPlayThisGame(team)). Zudem möchten wir schnell ermitteln können, wie viele Punkte eine Mannschaft in diesem Spiel erzielt hat (Sieg: 3, Unentschieden: 1, Niederlage: 0) (getPointsFor(team)). Auf Stufe Turnier (Competition)\nwollten wir ermitteln können, welche Mannschaft wie viele Punkte während der Gruppenphase erzielt hat (getScoresDuringGroupStageFor(team)). Zudem möchten wir herausfinden, wie viele Tore eine Mannschaft während des ganzen Turniers geschossen hat (getGoalsForTeam(team)). Des Weiteren wollen wir eine Auflistung, welche Spiele alles an einem bestimmten Ort (location) stattgefunden haben (getAllGamesForLocation(location)). Abgesehen von der main(...)-Methode soll keine weitere Methode statisch sein.\nAufgaben Aufgabe 1 - Entwurf Erstelle einen Entwurf vom Klassenmodell.\nDer Entwurf kann auf Papier oder mit einem Tool (z.B. draw.io, Visio, plantUML) erstellt werden. Plane auch schon die Methoden im Entwurf ein. Zeige den Entwurf zuerst einem Praxisbildner, bevor du weiterfährst.\nAufgabe 2 - Klassen umsetzen Setze die Klassen im Code um, inkl. Methoden.\nFür den Moment müssen die Methoden noch nichts machen und sollen für den Beginn nur einen Default-Wert zurückgeben - der Einfachheit halber.\nZiel dieser Aufgabe ist, dass du dich nur aufs Klassen-Design im Code konzentrierst, nicht aber um die konkreten Methoden-Umsetzungen.\nAufgabe 3 - Methoden umsetzen Setze nun die Methoden korrekt um.\nVerwende zur Demonstration die Daten aus der results.txt-Datei. Du sollst die Daten nicht automatisiert via Dateisystem laden, sondern du kannst die Informationen aus dieser Datei direkt hartkodiert in eine .java-Datei hinein kopieren und in Java-Code umschreiben, damit es mit deinen Klassen kompatibel ist. Damit ist keine Hexerei erwartet, sondern wenn z.B. folgendes in der results.txt-Datei steht\n1 2 # Gruppe 1 Frankreich\tJugoslawien\t0:1 dann kannst du das wie folgt direkt in deine Java-Datei schreiben:\n1 new Game(FRANCE, YUGOSLAVIA, 0, 1); ","categories":"","description":"Exam zu Modul #J2\n","excerpt":"Exam zu Modul #J2\n","ref":"/de/exams/02_java/04_java-oop/01_weltmeisterschaft/","tags":"","title":"Weltmeisterschaft"},{"body":"Ziele Ich weiss, wie ich IT-Ninjas nutze. Ich habe einen GitHub-Account erstellt, um an Diskussionen und Kommentaren teilzunehmen. Ich weiss, wie ich Kommentare verfasse und an Diskussionen teilnehme. Einführung Du befindest dich auf labs.it-ninjas.ch, einer Lernplattform, die dich auf deinem Weg begleiten wird. Diese Seite wird ständig weiterentwickelt und verbessert – und du kannst dazu beitragen!\nDie Plattform wird auf GitHub gehostet, ähnlich wie dein eigenes Git-Repository, welches du im nächsten Schritt erstellen wirst. Doch GitHub kann noch mehr:\nAuf jeder IT-Ninjas-Seite gibt es eine Kommentarfunktion, mit der du Fragen stellen, Probleme melden oder an Diskussionen teilnehmen kannst. Alle Kommentare werden auf der GitHub-Discussions-Seite von IT-Ninjas gespeichert. Wenn du oben rechts auf der Seite nachsiehst, solltest du einen Hyperlink zu der Kommentarfunktion finden. Klickst du darauf, scrollst du ans Ende der Seite. Dort findest du die Kommentarfunktion. Falls diese für dich nicht sichtbar oder gesperrt ist, musst du dich zuerst mit GitHub anmelden.\nGitHub Account Damit du teilnehmen kannst, benötigst du einen GitHub-Account. Falls du noch keinen hast, erstelle einen nach dieser Anleitung.\nHast du bereits einen GitHub-Account? Dann kannst du diesen nutzen. Sobald du dich registriert hast, klicke auf “Mit GitHub anmelden” auf IT-Ninjas – danach kannst du Kommentare schreiben!\nWie sind die Diskussionen zu benutzen? Bevor du eine Frage stellst oder einen Fehler meldest:\nLies alle vorhandenen Kommentare auf der Seite. Es ist gut möglich, dass dein Problem schon jemand angesprochen hat. Falls du eine passende Frage oder Meldung findest, kannst du darauf reagieren (z. B. mit einem 👍). Falls du keine passende Antwort findest, erstelle einen neuen Kommentar. Wichtiger Hinweis: Alles, was du in den Kommentaren postest, ist öffentlich sichtbar!\nBitte poste nicht: 🚫 Musterlösungen 🚫 Persönliche Informationen 🚫 Interne Firmeninformationen\nViel Erfolg auf IT-Ninjas!\n","categories":"","description":"Nützliche Informationen rund um IT-Ninjas\n","excerpt":"Nützliche Informationen rund um IT-Ninjas\n","ref":"/docs/99_tools/it-ninjas/","tags":"","title":"Willkommen bei IT-Ninjas"},{"body":"","categories":"","description":"Labs zu Javascript\n","excerpt":"Labs zu Javascript\n","ref":"/labs/03_web/02_javascript/","tags":"","title":"Javascript Labs"},{"body":"","categories":"","description":"Labs zu Javascript\n","excerpt":"Labs zu Javascript\n","ref":"/de/labs/03_web/02_javascript/","tags":"","title":"Javascript Labs"},{"body":"Ziele Du weisst, was NgRx Actions sind und kannst diese anwenden. NgRx Actions Actions sind einfache JS-Objekte, die eine bestimmte Aktion beschreiben, die in einer Anwendung ausgeführt werden soll. Jede Action hat einen Typ und optional zusätzliche Daten.\nActions spielen eine zentrale Rolle in der Redux-Architektur und dienen als Auslöser für Zustandsänderungen im Store. Durch die Verwendung von Actions, kann man den Zustand der Anwendung eindeutig beschreiben und die Auswirkungen dieser Aktionen auf den Zustand zentral verwalten.\nDie Action-Typen werden meistens in einem Enum definiert. Auf diese Weise hat man eine bessere Übersicht darüber, welche Actions die Anwendung besitzt. Die Typen werden in eckigen Klammern mit einem Präfix, der den Kontext der Aktion angibt, geschrieben.\nHier ein Beispiel:\n1 2 3 4 5 export enum ActionTypes { GETABILITIES = \"[Dragon Warrior] Get Abilities\", ADDABILITY = \"[Dragon Warrior] Add Ability\", DELETEABILITY = \"[Dragon Warrior] Delete Ability\", } Als Nächstes muss man die Typen in einer Action-Creator-Funktion verwenden. Dazu muss diese Funktion zuerst erstellt werden. Mithilfe der createAction-Funktion aus dem @ngrx/store-Package kann man Action-Creator-Funktionen erstellen. Die Funktion createAction akzeptiert den Action-Typ und optional zusätzliche Daten (Props) und gibt eine Action zurück.\n1 2 3 4 5 6 7 8 9 10 11 12 13 import { createAction, props } from \"@ngrx/store\"; export const getAbilities = createAction(ActionTypes.GETABILITIES); export const addAbility = createAction( ActionTypes.ADDABILITY, props\u003c{ ability: string }\u003e(), ); export const deleteAbility = createAction( ActionTypes.DELETEABILITY, props\u003c{ ability: string }\u003e(), ); Diese Action-Creator-Funktionen kann man nun in den Components verwenden und sie auslösen.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import { Component, inject, OnInit } from \"@angular/core\"; import { FormControl } from \"@angular/forms\"; import { select, Store } from \"@ngrx/store\"; import { Observable } from \"rxjs\"; import { addAbility, deleteAbility } from \"src/app/actions/ability.actions\"; @Component({ // .. }) export class AbilityComponent implements OnInit { ability$: Observable\u003c{ abilities: string[] }\u003e = new Observable\u003c{ abilities: string[]; }\u003e(); abilities$: Observable\u003cstring[]\u003e = new Observable\u003cstring[]\u003e(); abilityForm: FormControl = new FormControl(\"\"); private store = inject(Store\u003c{ ability: { abilities: string[] } }\u003e); constructor() {} ngOnInit(): void { this.ability$ = this.store.select(\"ability\"); this.abilities$ = this.ability$.pipe( map((x) =\u003e { return x.abilities; }), ); } addAbility() { this.store.dispatch(addAbility({ ability: this.abilityForm.value ?? \"\" })); } deleteAbility(ability: string) { this.store.dispatch(deleteAbility({ ability: ability })); } } Die Actions werden dann von den Reducer-Funktionen behandelt, um den Zustand zu aktualisieren und auf die Aktionen zu reagieren.\n","categories":"","description":"Modul #F7 - Angular NgRx - Actions\n","excerpt":"Modul #F7 - Angular NgRx - Actions\n","ref":"/docs/03_web/07_angular-ngrx/02_ngrx_actions/","tags":"","title":"NgRx Actions"},{"body":"Ziele Du weisst, was NgRx Actions sind und kannst diese anwenden. NgRx Actions Actions sind einfache JS-Objekte, die eine bestimmte Aktion beschreiben, die in einer Anwendung ausgeführt werden soll. Jede Action hat einen Typ und optional zusätzliche Daten.\nActions spielen eine zentrale Rolle in der Redux-Architektur und dienen als Auslöser für Zustandsänderungen im Store. Durch die Verwendung von Actions, kann man den Zustand der Anwendung eindeutig beschreiben und die Auswirkungen dieser Aktionen auf den Zustand zentral verwalten.\nDie Action-Typen werden meistens in einem Enum definiert. Auf diese Weise hat man eine bessere Übersicht darüber, welche Actions die Anwendung besitzt. Die Typen werden in eckigen Klammern mit einem Präfix, der den Kontext der Aktion angibt, geschrieben.\nHier ein Beispiel:\n1 2 3 4 5 export enum ActionTypes { GETABILITIES = \"[Dragon Warrior] Get Abilities\", ADDABILITY = \"[Dragon Warrior] Add Ability\", DELETEABILITY = \"[Dragon Warrior] Delete Ability\", } Als Nächstes muss man die Typen in einer Action-Creator-Funktion verwenden. Dazu muss diese Funktion zuerst erstellt werden. Mithilfe der createAction-Funktion aus dem @ngrx/store-Package kann man Action-Creator-Funktionen erstellen. Die Funktion createAction akzeptiert den Action-Typ und optional zusätzliche Daten (Props) und gibt eine Action zurück.\n1 2 3 4 5 6 7 8 9 10 11 12 13 import { createAction, props } from \"@ngrx/store\"; export const getAbilities = createAction(ActionTypes.GETABILITIES); export const addAbility = createAction( ActionTypes.ADDABILITY, props\u003c{ ability: string }\u003e(), ); export const deleteAbility = createAction( ActionTypes.DELETEABILITY, props\u003c{ ability: string }\u003e(), ); Diese Action-Creator-Funktionen kann man nun in den Components verwenden und sie auslösen.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import { Component, inject, OnInit } from \"@angular/core\"; import { FormControl } from \"@angular/forms\"; import { select, Store } from \"@ngrx/store\"; import { Observable } from \"rxjs\"; import { addAbility, deleteAbility } from \"src/app/actions/ability.actions\"; @Component({ // .. }) export class AbilityComponent implements OnInit { ability$: Observable\u003c{ abilities: string[] }\u003e = new Observable\u003c{ abilities: string[]; }\u003e(); abilities$: Observable\u003cstring[]\u003e = new Observable\u003cstring[]\u003e(); abilityForm: FormControl = new FormControl(\"\"); private store = inject(Store\u003c{ ability: { abilities: string[] } }\u003e); constructor() {} ngOnInit(): void { this.ability$ = this.store.select(\"ability\"); this.abilities$ = this.ability$.pipe( map((x) =\u003e { return x.abilities; }), ); } addAbility() { this.store.dispatch(addAbility({ ability: this.abilityForm.value ?? \"\" })); } deleteAbility(ability: string) { this.store.dispatch(deleteAbility({ ability: ability })); } } Die Actions werden dann von den Reducer-Funktionen behandelt, um den Zustand zu aktualisieren und auf die Aktionen zu reagieren.\n","categories":"","description":"Modul #F7 - Angular NgRx - Actions\n","excerpt":"Modul #F7 - Angular NgRx - Actions\n","ref":"/de/docs/03_web/07_angular-ngrx/02_ngrx_actions/","tags":"","title":"NgRx Actions"},{"body":"Inhalt Im Lab von Spring Boot hast du bereits ein Backend für eine Notenverwaltung geschrieben. In diesem Exam sollst du zusätzlich ein Frontend schreiben, welches dieses Backend verwendet. Schlussendlich solltest du eine komplett selbst erstellte Fullstack Applikation haben, die einwandfrei funktioniert.\nSetup Bevor du mit den Aufgaben beginnst, solltest du ein neues Angular Projekt wie gelernt aufsetzen. Du kannst beim Setup bereits das Routing integrieren und wähle als stylesheet SCSS aus. Den Namen kannst du frei wählen. Wenn diese Bedingungen erfüllt sind, kannst du mit den Aufgaben beginnen.\nAnforderungen Funktional Die Anwendung unterstützt zwei unterschiedliche Profile: “student” und “admin”\nWenn die Anwendung mit dem Profil “student” gestartet wird, steht folgende Funktionalität zur Verfügung:\nAlle Fächer und all deren Noten auflisten (ein Fach kann mehreren Noten beinhalten) Alle Fächer und deren Durchschnittsnote auflisten Für ein bestimmtes Fach: Alle Noten und die Durchschnittsnote des Fachs auflisten Eine neue Note hinzufügen Eine bestehende Note ändern Eine bestehende Note löschen Wenn die Anwendung mit dem Profil “admin” gestartet wird, steht zusätzlich auch folgende Funktionalität zur Verfügung:\nAlle Fächer auflisten Neue Fächer hinzufügen Bestehende Fächer bearbeiten Bestehende Fächer löschen Die Anwendung ist Responsive gestaltet und ist auf Desktop, Tablet und Mobile verwendbar\nDie Verwendung von Bootstrap ist nicht erlaubt Zusätzliche Anforderungen\nDie Anwendung ist in den Sprachen Deutsch, Französisch und Englisch verfügbar Die Sprache kann direkt in der Applikation gewechselt werden Nicht-Funktional Der Code (das Design) der Anwendung ist sinnvoll in entsprechenden Components/Services aufgesplittet. Ein Component/Service hat eine einzige Aufgabe (Single Responsibility Prinzip). Design Die Notenverwaltung sollte ungefähr dem vorgegebenen Design entsprechen. Farben und Schriftarten können frei gewählt werden, jedoch sollte das vorgegebene Design immer noch erkennbar sein.\nDas Design wurde mit Figma erstellt und ist navigierbar. Also kannst du die benötigten Verlinkungen so selbst herausfinden. Teilweise wurde eine Funktion, wie das Bearbeiten einer Note, nur einmal umgesetzt. Die Funktion soll beim Endprodukt aber logischerweise überall umgesetzt sein. Das Design wurde für Desktop, Tablet und Mobile erstellt, die Anwendung sollte sich dementsprechend wie im Design anpassen.\nHier der Link zum Design: Figma Design - Notenverwaltung\nEs ist zu empfehlen, dass zum Erstellen der Applikation Angular Material eingesetzt wird. So können bereits erstellte Komponenten inklusive Design verwendet werden.\nAufgabe 1 - Erstellen der Components Um alle Daten der Notenverwaltung anzeigen, erstellen, löschen und bearbeiten zu können, werden verschiedene Components benötigt. In dieser Aufgabe solltest du diese Punkte abarbeiten:\nÜberlege dir anhand der Anforderungen, wofür du alles einen Component benötigst. Die Unterscheidung zwischen Admin und Student Profil kann aktuell ignoriert werden. Erstelle bereits jetzt alle Components dazu. Entwickle ein einfaches und benutzerfreundliches Design für die einzelnen Seiten. Verwende aktuell feste Daten, diese werden in einer späteren Aufgabe ersetzt. Aufgabe 2 - Models erstellen und verwenden Aktuell werden in deiner Applikation feste Daten angezeigt, die im HTML angegeben sind. Da die Daten später jedoch aus dem Backend kommen sollten, ist es von Vorteil, wenn du Models hast, die den benötigten Daten entsprechen. Diese Punkte sollten in dieser Aufgabe erledigt werden:\nErstelle alle deiner Meinung nach benötigten Models. Ändere deine festen Daten und setze deine erstellten Models ein. Versuche, wo nötig, Forms zu verwenden, um diese Später verwenden zu können. Tipp: Wenn du dir unsicher bist welche Daten du benötigst, kannst du im Backend bei den DAOs etwas spicken und so die richtige Struktur finden.\nAufgabe 3 - Services erstellen und verwenden Da wir bald schon das Backend anbinden, solltest du noch die benötigten Services erstellen. Erledige dazu folgende Aufgaben:\nErstelle alle deiner Meinung nach benötigten Services Lass alle Daten aus einem Service laden und erstelle dazu Mockdaten Aufgabe 4 - Backend anbinden In dieser Aufgabe verbindest du jetzt das Frontend mit dem Backend. Erledige dazu diese Aufgaben:\nVerwende die korrekten Endpoints aus dem Backend Hole die Daten Asynchron aus dem Backend Entferne alle Mockdaten Aufgabe 5 - Admin und Student Ab diesem Zeitpunkt sollten alle grundlegenden Funktionen deiner Applikation umgesetzt sein, Glückwunsch! Jetzt möchten wir noch die Admin- und Student-Funktionen trennen. Dazu besteht im Backend ein Endpunkt, welcher das gestartete Profil im Backend an das Frontend sendet. Darüber soll das Frontend die verschiedenen freischalten oder verstecken. Dazu hast du im Backend einen oder mehrere Endpunkte erstellt, die du jetzt einsetzen kannst. Deine Applikation soll auch selbständig erkennen, welche Funktionen verfügbar sind und welche nicht.\n","categories":"","description":"Ein Angular Exam zum Erstellen eines Frontends zu einem bestehenden Backend.\n","excerpt":"Ein Angular Exam zum Erstellen eines Frontends zu einem bestehenden …","ref":"/exams/03_web/06_angular/02_notenverwaltung/","tags":"","title":"Exam zu Angular"},{"body":"Inhalt Im Lab von Spring Boot hast du bereits ein Backend für eine Notenverwaltung geschrieben. In diesem Exam sollst du zusätzlich ein Frontend schreiben, welches dieses Backend verwendet. Schlussendlich solltest du eine komplett selbst erstellte Fullstack Applikation haben, die einwandfrei funktioniert.\nSetup Bevor du mit den Aufgaben beginnst, solltest du ein neues Angular Projekt wie gelernt aufsetzen. Du kannst beim Setup bereits das Routing integrieren und wähle als stylesheet SCSS aus. Den Namen kannst du frei wählen. Wenn diese Bedingungen erfüllt sind, kannst du mit den Aufgaben beginnen.\nAnforderungen Funktional Die Anwendung unterstützt zwei unterschiedliche Profile: “student” und “admin”\nWenn die Anwendung mit dem Profil “student” gestartet wird, steht folgende Funktionalität zur Verfügung:\nAlle Fächer und all deren Noten auflisten (ein Fach kann mehreren Noten beinhalten) Alle Fächer und deren Durchschnittsnote auflisten Für ein bestimmtes Fach: Alle Noten und die Durchschnittsnote des Fachs auflisten Eine neue Note hinzufügen Eine bestehende Note ändern Eine bestehende Note löschen Wenn die Anwendung mit dem Profil “admin” gestartet wird, steht zusätzlich auch folgende Funktionalität zur Verfügung:\nAlle Fächer auflisten Neue Fächer hinzufügen Bestehende Fächer bearbeiten Bestehende Fächer löschen Die Anwendung ist Responsive gestaltet und ist auf Desktop, Tablet und Mobile verwendbar\nDie Verwendung von Bootstrap ist nicht erlaubt Zusätzliche Anforderungen\nDie Anwendung ist in den Sprachen Deutsch, Französisch und Englisch verfügbar Die Sprache kann direkt in der Applikation gewechselt werden Nicht-Funktional Der Code (das Design) der Anwendung ist sinnvoll in entsprechenden Components/Services aufgesplittet. Ein Component/Service hat eine einzige Aufgabe (Single Responsibility Prinzip). Design Die Notenverwaltung sollte ungefähr dem vorgegebenen Design entsprechen. Farben und Schriftarten können frei gewählt werden, jedoch sollte das vorgegebene Design immer noch erkennbar sein.\nDas Design wurde mit Figma erstellt und ist navigierbar. Also kannst du die benötigten Verlinkungen so selbst herausfinden. Teilweise wurde eine Funktion, wie das Bearbeiten einer Note, nur einmal umgesetzt. Die Funktion soll beim Endprodukt aber logischerweise überall umgesetzt sein. Das Design wurde für Desktop, Tablet und Mobile erstellt, die Anwendung sollte sich dementsprechend wie im Design anpassen.\nHier der Link zum Design: Figma Design - Notenverwaltung\nEs ist zu empfehlen, dass zum Erstellen der Applikation Angular Material eingesetzt wird. So können bereits erstellte Komponenten inklusive Design verwendet werden.\nAufgabe 1 - Erstellen der Components Um alle Daten der Notenverwaltung anzeigen, erstellen, löschen und bearbeiten zu können, werden verschiedene Components benötigt. In dieser Aufgabe solltest du diese Punkte abarbeiten:\nÜberlege dir anhand der Anforderungen, wofür du alles einen Component benötigst. Die Unterscheidung zwischen Admin und Student Profil kann aktuell ignoriert werden. Erstelle bereits jetzt alle Components dazu. Entwickle ein einfaches und benutzerfreundliches Design für die einzelnen Seiten. Verwende aktuell feste Daten, diese werden in einer späteren Aufgabe ersetzt. Aufgabe 2 - Models erstellen und verwenden Aktuell werden in deiner Applikation feste Daten angezeigt, die im HTML angegeben sind. Da die Daten später jedoch aus dem Backend kommen sollten, ist es von Vorteil, wenn du Models hast, die den benötigten Daten entsprechen. Diese Punkte sollten in dieser Aufgabe erledigt werden:\nErstelle alle deiner Meinung nach benötigten Models. Ändere deine festen Daten und setze deine erstellten Models ein. Versuche, wo nötig, Forms zu verwenden, um diese Später verwenden zu können. Tipp: Wenn du dir unsicher bist welche Daten du benötigst, kannst du im Backend bei den DAOs etwas spicken und so die richtige Struktur finden.\nAufgabe 3 - Services erstellen und verwenden Da wir bald schon das Backend anbinden, solltest du noch die benötigten Services erstellen. Erledige dazu folgende Aufgaben:\nErstelle alle deiner Meinung nach benötigten Services Lass alle Daten aus einem Service laden und erstelle dazu Mockdaten Aufgabe 4 - Backend anbinden In dieser Aufgabe verbindest du jetzt das Frontend mit dem Backend. Erledige dazu diese Aufgaben:\nVerwende die korrekten Endpoints aus dem Backend Hole die Daten Asynchron aus dem Backend Entferne alle Mockdaten Aufgabe 5 - Admin und Student Ab diesem Zeitpunkt sollten alle grundlegenden Funktionen deiner Applikation umgesetzt sein, Glückwunsch! Jetzt möchten wir noch die Admin- und Student-Funktionen trennen. Dazu besteht im Backend ein Endpunkt, welcher das gestartete Profil im Backend an das Frontend sendet. Darüber soll das Frontend die verschiedenen freischalten oder verstecken. Dazu hast du im Backend einen oder mehrere Endpunkte erstellt, die du jetzt einsetzen kannst. Deine Applikation soll auch selbständig erkennen, welche Funktionen verfügbar sind und welche nicht.\n","categories":"","description":"Ein Angular Exam zum Erstellen eines Frontends zu einem bestehenden Backend.\n","excerpt":"Ein Angular Exam zum Erstellen eines Frontends zu einem bestehenden …","ref":"/de/exams/03_web/06_angular/02_notenverwaltung/","tags":"","title":"Exam zu Angular"},{"body":"Ziele Du kennst die wichtigsten Special Operators in Angular und kannst diese anwenden. Special Operators Viele der relevanten Operatoren wurden bereits beim JavaScript behandelt, diese können auch in TypeScript verwendet werden. Die Operatoren können hier nachgelesen werden.\n?-Operator Der ?-Operator ist der optionale Aufruf-Operator (optional chaining operator). Er ermöglicht den Zugriff auf Eigenschaften oder Methoden eines Objekts, wenn das Objekt potenziell null oder undefined sein kann.\nEr wird verwendet, um sicherzustellen, dass der Code nicht abbricht und einen Fehler auslöst, wenn eine Eigenschaft oder Methode auf einem möglicherweise null oder undefined Objekt aufgerufen wird. Wenn das Objekt null oder undefined ist, gibt er undefined zurück, anstatt einen Fehler zu werfen.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 interface Person { name: string; age?: number; getInfo(): string; } const person1: Person = null; const person2: Person = { name: \"Alice\", getInfo() { return `Name: ${this.name}, Age: ${this.age}`; }, }; console.log(person1?.name); // undefined console.log(person2?.name); // 'Alice' console.log(person1?.getInfo()); // undefined console.log(person2?.getInfo()); // 'Name: Alice, Age: undefined' Wichtig der hier gezeigte Operator ist nicht das gleiche wie der ternary Operator(?:)! Wenn du unsicher bist, lies dir nochmal die Beschreibung des ternary Operators durch.\n!-Operator Der !-Operator ist ein Non-null-Assertion-Operator. Er wird verwendet, um dem Compiler mitzuteilen und zu garantieren, dass eine Variable während der Laufzeit nicht null oder undefined ist und somit einen gültigen Wert hat.\nDadurch wird der Compiler davon abgehalten, Warnungen oder Fehlermeldungen auszugeben, die normalerweise auftreten würden, wenn eine mögliche Null- oder Undefined-Zuweisung vorliegt.\nEs ist wichtig zu beachten, dass der Operator mit Vorsicht verwendet werden sollte. Wenn der Wert tatsächlich null oder undefined ist und der Operator verwendet wird, tritt zur Laufzeit ein Fehler auf.\n1 2 3 4 5 6 7 8 9 function greet(name: string): string { return `Hello, ${name!.toUpperCase()}!`; } let userName: string = \"Alice\"; console.log(greet(userName)); // 'Hello, ALICE!' userName = null; console.log(greet(userName)); // Error: Cannot read properties of null (reading 'toUpperCase') ","categories":"","description":"Modul #F5 - TypeScript - Special Operators\n","excerpt":"Modul #F5 - TypeScript - Special Operators\n","ref":"/docs/03_web/05_typescript/02_special-operators/","tags":"","title":"Special Typescript Operators"},{"body":"Ziele Du kennst die wichtigsten Special Operators in Angular und kannst diese anwenden. Special Operators Viele der relevanten Operatoren wurden bereits beim JavaScript behandelt, diese können auch in TypeScript verwendet werden. Die Operatoren können hier nachgelesen werden.\n?-Operator Der ?-Operator ist der optionale Aufruf-Operator (optional chaining operator). Er ermöglicht den Zugriff auf Eigenschaften oder Methoden eines Objekts, wenn das Objekt potenziell null oder undefined sein kann.\nEr wird verwendet, um sicherzustellen, dass der Code nicht abbricht und einen Fehler auslöst, wenn eine Eigenschaft oder Methode auf einem möglicherweise null oder undefined Objekt aufgerufen wird. Wenn das Objekt null oder undefined ist, gibt er undefined zurück, anstatt einen Fehler zu werfen.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 interface Person { name: string; age?: number; getInfo(): string; } const person1: Person = null; const person2: Person = { name: \"Alice\", getInfo() { return `Name: ${this.name}, Age: ${this.age}`; }, }; console.log(person1?.name); // undefined console.log(person2?.name); // 'Alice' console.log(person1?.getInfo()); // undefined console.log(person2?.getInfo()); // 'Name: Alice, Age: undefined' Wichtig der hier gezeigte Operator ist nicht das gleiche wie der ternary Operator(?:)! Wenn du unsicher bist, lies dir nochmal die Beschreibung des ternary Operators durch.\n!-Operator Der !-Operator ist ein Non-null-Assertion-Operator. Er wird verwendet, um dem Compiler mitzuteilen und zu garantieren, dass eine Variable während der Laufzeit nicht null oder undefined ist und somit einen gültigen Wert hat.\nDadurch wird der Compiler davon abgehalten, Warnungen oder Fehlermeldungen auszugeben, die normalerweise auftreten würden, wenn eine mögliche Null- oder Undefined-Zuweisung vorliegt.\nEs ist wichtig zu beachten, dass der Operator mit Vorsicht verwendet werden sollte. Wenn der Wert tatsächlich null oder undefined ist und der Operator verwendet wird, tritt zur Laufzeit ein Fehler auf.\n1 2 3 4 5 6 7 8 9 function greet(name: string): string { return `Hello, ${name!.toUpperCase()}!`; } let userName: string = \"Alice\"; console.log(greet(userName)); // 'Hello, ALICE!' userName = null; console.log(greet(userName)); // Error: Cannot read properties of null (reading 'toUpperCase') ","categories":"","description":"Modul #F5 - TypeScript - Special Operators\n","excerpt":"Modul #F5 - TypeScript - Special Operators\n","ref":"/de/docs/03_web/05_typescript/02_special-operators/","tags":"","title":"Special Typescript Operators"},{"body":"Ziele Du weisst, was ein Linter ist und was dieser macht. Du weisst, was Prettier ist, wozu es verwendet wird und wie man es konfiguriert. Du weisst, was ESLint ist, wozu es verwendet wird und wie man es konfiguriert. Linter Ein Linter analysiert den Quellcode auf der Grundlage vordefinierter Regeln, Konventionen und Best Practices. Er prüft den Code auf häufige Fehler wie fehlende Semikolons, undefinierte Variablen, nicht verwendete Imports, ungültige Syntax und andere potenzielle Probleme. Darüber hinaus kann ein Linter auch den Code-Stil überprüfen, um sicherzustellen, dass er den vereinbarten Standards im Projekt entspricht. Der Hauptzweck eines Linters besteht darin, Entwicklern dabei zu helfen, qualitativ hochwertigen Code zu schreiben, der gut strukturiert und leicht wartbar ist.\nPrettier Prettier ist ein beliebtes Codeformatierungstool, das dazu dient, den Code in einem einheitlichen und konsistenten Stil zu formatieren. Im Gegensatz zu einem Linter wie ESLint, der sich auf Code-Stilregeln konzentriert, konzentriert sich Prettier ausschliesslich auf die Formatierung des Codes.\nPrettier unterstützt eine Vielzahl von Programmiersprachen, einschliesslich JavaScript, TypeScript, HTML, CSS, JSON etc. Es bietet eine Reihe von Formatierungsregeln, die auf bewährten Praktiken basieren, um den Code lesbarer und einheitlicher zu gestalten. Prettier kann den gesamten Code automatisch formatieren, einschliesslich Einrückungen, Zeilenumbrüchen, Leerzeichen, Klammern und anderen Formatierungsaspekten.\nPrettier konfigurieren Prettier benötigt normalerweise keine umfangreiche Konfiguration, da es über standardmässige Formatierungsregeln verfügt. Man kann jedoch bestimmte Einstellungen in einer .prettierrc-Datei festlegen, um das Verhalten anzupassen.\nHier ist ein Beispiel wie man das machen kann:\nWenn man beispielsweise.\ndie Anzahl der Leerzeichen (2) festlegen will, die für einen Tab verwendet werden sollen, doppelte Anführungszeichen \" mit einfachen ' ersetzen will, Tabs durch Leerzeichen ersetzen will, fehlende Semikolons (im JavaScript) automatisch hinzufügen will, automatisch Spaces bei Klammern hinzufügen will, dann kann das wie folgt getan werden. 1 2 3 4 5 6 7 8 { \"printWidth\": 120, \"singleQuote\": true, \"useTabs\": false, \"tabWidth\": 2, \"semi\": true, \"bracketSpacing\": true } Weitere Informationen zu den verfügbaren Optionen und deren Werten findet man in der Prettier-Dokumentation unter https://prettier.io/docs/en/configuration.html.\nPrettier ausführen Das Prettier Plugin kann man wie folgt ausführen:\nIntelliJ: Alt-Shift-Ctrl-P auf Windows und Linux oder Alt-Shift-Cmd-P auf macOS.\nVSCode: [Shift] + [Alt] + [F] unter Windows und Linux und [Shift] + [Option] + [F] auf macOS. Alternativ kannst du durch Klick auf [F1] den Task “Format Document (With…)” auswählen. Auf diese Weise kannst du auch gleich den Default-Formatter festlegen (wenn du es noch nicht in der Datei settings.json wie oben beschrieben getan hast).\nESLint ESLint ist ein äusserst beliebtes und leistungsstarkes statisches Code-Analysetool für JavaScript- und TypeScript-Projekte.\nESLint installieren Bevor ESLint verwendet werden kann, muss es installiert werden (und bei Windows am besten noch der PC neu gestartet werden). Mit den folgenden drei Befehlen kann man es installeren:\n1 2 3 npm install eslint --save-dev npx eslint --init npx eslint src/index.js ESLint konfigurieren Man kann eigene Regeln erstellen oder bereits vorhandene Regeln anpassen, um den Anforderungen des Projekts gerecht zu werden. Die Konfiguration erfolgt über eine .eslintrc-Datei, in der man die Regeln, Erweiterungen und spezifischen Projekteinstellungen festlegen kann.\nHier einige Beispiele wie man dies tun kann:\nAnpassen bestehender Regel:\nIn der .eslintrc-Datei kann man die Einstellungen für eine spezifische Regel ändern. Wenn die maximale Zeilenlänge auf 100 Zeichen beschränkt werden soll, wird dies wie folgt eingerichtet.\n1 2 3 4 5 { \"rules\": { \"max-len\": [\"error\", { \"code\": 100 }] } } Hinzufügen neuer Regel:\nMan kann Regeln hinzufügen oder entfernen, indem man die rules-Eigenschaft anpasst. Angenommen, man möchte die Regel “no-console” aktivieren, um den Einsatz von console.log zu verhindern:\n1 2 3 4 5 { \"rules\": { \"no-console\": \"error\" } } Weitere Informationen findest du in der ESLint-Dokumentation unter https://eslint.org/docs/user-guide/configuring.\nESLint ausführen ESLint kann man über die Konsole ausführen, dazu sind folgende Schritte erforderlich:\nIn der Konsole zum Wurzelverzeichnis des Projekts navigieren. Den Befehl eslint gefolgt von den Datei- oder Verzeichnisnamen ausführen, die man überprüfen möchte. 1 eslint src/index.js ESLint überprüft nun die angegebenen Dateien oder Verzeichnisse anhand der definierten Regeln und gibt mögliche Fehler oder Warnungen in der Konsole aus. ESLint kann man mit zusätzlichen Optionen und Flags verwenden, die wichtigste Flag ist --fix. Man kann sie verwenden, um automatische Code-Fixes für bestimmte Probleme durchzuführen.\n1 eslint --fix src/index.js Vielfach ist ESLint bereits als Script im package.json hinterlegt und kann dann so mit dem Befehl npm run \u003cscriptname\u003e (beispielsweise npm run lint) aufgerufen werden.\nESLint automatisch beim Speichern In VS-Code:\nMan öffnet die VS Code-Einstellungen, indem man “Datei” (File) in der Menüleiste wählt und dann “Einstellungen” (Preferences) auswählt. Oder man verwendet den Shortcut “[Ctrl] + [,]” für Windows/Linux oder “[Cmd] + [,]” für macOS.\nMan sucht nach Save Actions in den Einstellungen und wählt “In settings.json bearbeiten” (Edit in settings.json).\nIn der settings.json-Datei fügt man den folgenden Code hinzu:\n1 2 3 4 5 \"editor.formatOnSave\": true, \"editor.defaultFormatter\": \"esbenp.prettier-vscode\", \"editor.codeActionsOnSave\": { \"source.fixAll.eslint\": true } \"editor.formatOnSave\": true: Diese Einstellung bewirkt, dass der Code automatisch entsprechend den in den Editor-Einstellungen konfigurierten Regeln formatiert wird, wenn das Dokument gespeichert wird.\n\"editor.defaultFormatter\": \"esbenp.prettier-vscode\": Diese Einstellung gibt den Standard-Codeformatter an, der verwendet wird, wenn \"editor.formatOnSave\" aktiviert ist. In diesem Fall wird Prettier verwendet.\n\"editor.codeActionsOnSave\": { \"source.fixAll.eslint\": true } : Diese Einstellung aktiviert Code-Aktionen beim Speichern des Dokuments. Konkret wird hier die ESLint-Erweiterung verwendet. Durch das Aktivieren von \"source.fixAll.eslint\": true werden automatisch Vorschläge zur Fehlerbehebung und Verbesserung des Codes angezeigt, wenn das Dokument gespeichert wird.\nNun noch die Datei speichern und VS-Code wird automatisch den Code formatieren und Lint-Fixes anwenden.\nIn IntelliJ:\nMan öffnet die IntelliJ-Einstellungen, indem man den Shortcut “Strg + Alt + S” für Windows/Linux oder “Cmd + ,” für macOS verwendet.\nMan navigiert zu Languages \u0026 Frameworks -\u003e [Code-Language z.B. JavaScript] -\u003e Code Quality Tools -\u003e ESLint nun wählt man die Automatic ESLint configuration und Run eslint --fix on save Option an.\nÜberprüfen Nun gehen wir davon aus, dass alle nötigen Installationen erfolgreich ausgeführt wurden.\n5’ - Einzelarbeit\n- Öffne deine IDE - Öffne in deiner IDE ein neues Terminal - git --version - npm -v Sofern alle Versionen angezeigt werden, war die Installation erfolgreich. Anderweitig solltest du einen Praxisbildner konsultieren.\n","categories":"","description":"Hier wird erklärt was Linter sind und wie man diese benutzt.\n","excerpt":"Hier wird erklärt was Linter sind und wie man diese benutzt.\n","ref":"/docs/03_web/04_ide-advanced/02_linter/","tags":"","title":"Linter"},{"body":"Ziele Du weisst, was ein Linter ist und was dieser macht. Du weisst, was Prettier ist, wozu es verwendet wird und wie man es konfiguriert. Du weisst, was ESLint ist, wozu es verwendet wird und wie man es konfiguriert. Linter Ein Linter analysiert den Quellcode auf der Grundlage vordefinierter Regeln, Konventionen und Best Practices. Er prüft den Code auf häufige Fehler wie fehlende Semikolons, undefinierte Variablen, nicht verwendete Imports, ungültige Syntax und andere potenzielle Probleme. Darüber hinaus kann ein Linter auch den Code-Stil überprüfen, um sicherzustellen, dass er den vereinbarten Standards im Projekt entspricht. Der Hauptzweck eines Linters besteht darin, Entwicklern dabei zu helfen, qualitativ hochwertigen Code zu schreiben, der gut strukturiert und leicht wartbar ist.\nPrettier Prettier ist ein beliebtes Codeformatierungstool, das dazu dient, den Code in einem einheitlichen und konsistenten Stil zu formatieren. Im Gegensatz zu einem Linter wie ESLint, der sich auf Code-Stilregeln konzentriert, konzentriert sich Prettier ausschliesslich auf die Formatierung des Codes.\nPrettier unterstützt eine Vielzahl von Programmiersprachen, einschliesslich JavaScript, TypeScript, HTML, CSS, JSON etc. Es bietet eine Reihe von Formatierungsregeln, die auf bewährten Praktiken basieren, um den Code lesbarer und einheitlicher zu gestalten. Prettier kann den gesamten Code automatisch formatieren, einschliesslich Einrückungen, Zeilenumbrüchen, Leerzeichen, Klammern und anderen Formatierungsaspekten.\nPrettier konfigurieren Prettier benötigt normalerweise keine umfangreiche Konfiguration, da es über standardmässige Formatierungsregeln verfügt. Man kann jedoch bestimmte Einstellungen in einer .prettierrc-Datei festlegen, um das Verhalten anzupassen.\nHier ist ein Beispiel wie man das machen kann:\nWenn man beispielsweise.\ndie Anzahl der Leerzeichen (2) festlegen will, die für einen Tab verwendet werden sollen, doppelte Anführungszeichen \" mit einfachen ' ersetzen will, Tabs durch Leerzeichen ersetzen will, fehlende Semikolons (im JavaScript) automatisch hinzufügen will, automatisch Spaces bei Klammern hinzufügen will, dann kann das wie folgt getan werden. 1 2 3 4 5 6 7 8 { \"printWidth\": 120, \"singleQuote\": true, \"useTabs\": false, \"tabWidth\": 2, \"semi\": true, \"bracketSpacing\": true } Weitere Informationen zu den verfügbaren Optionen und deren Werten findet man in der Prettier-Dokumentation unter https://prettier.io/docs/en/configuration.html.\nPrettier ausführen Das Prettier Plugin kann man wie folgt ausführen:\nIntelliJ: Alt-Shift-Ctrl-P auf Windows und Linux oder Alt-Shift-Cmd-P auf macOS.\nVSCode: [Shift] + [Alt] + [F] unter Windows und Linux und [Shift] + [Option] + [F] auf macOS. Alternativ kannst du durch Klick auf [F1] den Task “Format Document (With…)” auswählen. Auf diese Weise kannst du auch gleich den Default-Formatter festlegen (wenn du es noch nicht in der Datei settings.json wie oben beschrieben getan hast).\nESLint ESLint ist ein äusserst beliebtes und leistungsstarkes statisches Code-Analysetool für JavaScript- und TypeScript-Projekte.\nESLint installieren Bevor ESLint verwendet werden kann, muss es installiert werden (und bei Windows am besten noch der PC neu gestartet werden). Mit den folgenden drei Befehlen kann man es installeren:\n1 2 3 npm install eslint --save-dev npx eslint --init npx eslint src/index.js ESLint konfigurieren Man kann eigene Regeln erstellen oder bereits vorhandene Regeln anpassen, um den Anforderungen des Projekts gerecht zu werden. Die Konfiguration erfolgt über eine .eslintrc-Datei, in der man die Regeln, Erweiterungen und spezifischen Projekteinstellungen festlegen kann.\nHier einige Beispiele wie man dies tun kann:\nAnpassen bestehender Regel:\nIn der .eslintrc-Datei kann man die Einstellungen für eine spezifische Regel ändern. Wenn die maximale Zeilenlänge auf 100 Zeichen beschränkt werden soll, wird dies wie folgt eingerichtet.\n1 2 3 4 5 { \"rules\": { \"max-len\": [\"error\", { \"code\": 100 }] } } Hinzufügen neuer Regel:\nMan kann Regeln hinzufügen oder entfernen, indem man die rules-Eigenschaft anpasst. Angenommen, man möchte die Regel “no-console” aktivieren, um den Einsatz von console.log zu verhindern:\n1 2 3 4 5 { \"rules\": { \"no-console\": \"error\" } } Weitere Informationen findest du in der ESLint-Dokumentation unter https://eslint.org/docs/user-guide/configuring.\nESLint ausführen ESLint kann man über die Konsole ausführen, dazu sind folgende Schritte erforderlich:\nIn der Konsole zum Wurzelverzeichnis des Projekts navigieren. Den Befehl eslint gefolgt von den Datei- oder Verzeichnisnamen ausführen, die man überprüfen möchte. 1 eslint src/index.js ESLint überprüft nun die angegebenen Dateien oder Verzeichnisse anhand der definierten Regeln und gibt mögliche Fehler oder Warnungen in der Konsole aus. ESLint kann man mit zusätzlichen Optionen und Flags verwenden, die wichtigste Flag ist --fix. Man kann sie verwenden, um automatische Code-Fixes für bestimmte Probleme durchzuführen.\n1 eslint --fix src/index.js Vielfach ist ESLint bereits als Script im package.json hinterlegt und kann dann so mit dem Befehl npm run \u003cscriptname\u003e (beispielsweise npm run lint) aufgerufen werden.\nESLint automatisch beim Speichern In VS-Code:\nMan öffnet die VS Code-Einstellungen, indem man “Datei” (File) in der Menüleiste wählt und dann “Einstellungen” (Preferences) auswählt. Oder man verwendet den Shortcut “[Ctrl] + [,]” für Windows/Linux oder “[Cmd] + [,]” für macOS.\nMan sucht nach Save Actions in den Einstellungen und wählt “In settings.json bearbeiten” (Edit in settings.json).\nIn der settings.json-Datei fügt man den folgenden Code hinzu:\n1 2 3 4 5 \"editor.formatOnSave\": true, \"editor.defaultFormatter\": \"esbenp.prettier-vscode\", \"editor.codeActionsOnSave\": { \"source.fixAll.eslint\": true } \"editor.formatOnSave\": true: Diese Einstellung bewirkt, dass der Code automatisch entsprechend den in den Editor-Einstellungen konfigurierten Regeln formatiert wird, wenn das Dokument gespeichert wird.\n\"editor.defaultFormatter\": \"esbenp.prettier-vscode\": Diese Einstellung gibt den Standard-Codeformatter an, der verwendet wird, wenn \"editor.formatOnSave\" aktiviert ist. In diesem Fall wird Prettier verwendet.\n\"editor.codeActionsOnSave\": { \"source.fixAll.eslint\": true } : Diese Einstellung aktiviert Code-Aktionen beim Speichern des Dokuments. Konkret wird hier die ESLint-Erweiterung verwendet. Durch das Aktivieren von \"source.fixAll.eslint\": true werden automatisch Vorschläge zur Fehlerbehebung und Verbesserung des Codes angezeigt, wenn das Dokument gespeichert wird.\nNun noch die Datei speichern und VS-Code wird automatisch den Code formatieren und Lint-Fixes anwenden.\nIn IntelliJ:\nMan öffnet die IntelliJ-Einstellungen, indem man den Shortcut “Strg + Alt + S” für Windows/Linux oder “Cmd + ,” für macOS verwendet.\nMan navigiert zu Languages \u0026 Frameworks -\u003e [Code-Language z.B. JavaScript] -\u003e Code Quality Tools -\u003e ESLint nun wählt man die Automatic ESLint configuration und Run eslint --fix on save Option an.\nÜberprüfen Nun gehen wir davon aus, dass alle nötigen Installationen erfolgreich ausgeführt wurden.\n5’ - Einzelarbeit\n- Öffne deine IDE - Öffne in deiner IDE ein neues Terminal - git --version - npm -v Sofern alle Versionen angezeigt werden, war die Installation erfolgreich. Anderweitig solltest du einen Praxisbildner konsultieren.\n","categories":"","description":"Hier wird erklärt was Linter sind und wie man diese benutzt.\n","excerpt":"Hier wird erklärt was Linter sind und wie man diese benutzt.\n","ref":"/de/docs/03_web/04_ide-advanced/02_linter/","tags":"","title":"Linter"},{"body":"Ziele Du kennst die Vor- und Nachteile von Angular. Du weisst, wie du ein erstes Angular-Projekt aufsetzen kannst. Was ist Angular Angular ist ein Framework um SPA’s (Single Page Applications) mittels HTML und JavaScript zu erstellen und besteht aus verschiedenen Core- und Optional-JavaScript-Bibliotheken. Angular wird für Frontend-Applikationen verwendet. Oft wird ein Backend via HTTP(S) angebunden. Vorteile von Angular Umfangreiche Funktionalität: Angular bietet eine Vielzahl von Funktionen und Features, die für die Entwicklung von komplexen Webanwendungen erforderlich sind. Es enthält ein leistungsfähiges Template-System, Datenbindung, Routing, Formularvalidierung, Dependency Injection und vieles mehr.\nStrukturierte Architektur: Angular basiert auf dem Konzept der Components-Based Architektur. Die Anwendung wird in unabhängige, wiederverwendbare Components strukturiert, was die Wartbarkeit und Testbarkeit erleichtert.\nProduktivität: Angular bietet viele Hilfsmittel, die die Entwicklungszeit verkürzen. Dazu gehören die Angular CLI (Command Line Interface) zur Projektgenerierung und automatisierten Aufgaben, ein reichhaltiges Ökosystem von Libraries und Extensions sowie eine umfangreiche Dokumentation.\nTypeScript-Unterstützung: Angular ist in TypeScript geschrieben. TypeScript bietet statische Typisierung, verbesserte IDE-Unterstützung und ermöglicht eine bessere Fehlererkennung zur Entwicklungszeit.\nGrosse Community: Angular ist ein viel genutztes Framework, wodurch bereits viele Best-Practices, standartisierte Vorgehensweisen und bewährte Praktiken und Konventionen bestehen, an denen man sich als Entwickler orientieren kann.\nNachteile von Angular Lernkurve: Angular ist ein umfangreiches Framework und erfordert eine gewisse Einarbeitungszeit. Die Konzepte wie Dependency Injection, TypeScript und das Componentmodel können für Entwickler mit wenig Erfahrung zunächst herausfordernd sein.\nGrösse: Angular ist ein umfangreiches Framework, was zu grossen Anwendungen führen kann. Das kann die Ladezeit beeinflussen, insbesondere für mobile Geräte mit langsamer Internetverbindung.\nKomplexität: Aufgrund der vielen Funktionen und Konzepte kann die Komplexität von Angular zunehmen, insbesondere für kleinere Projekte, bei denen nicht alle Funktionen benötigt werden.\nAbhängigkeit von Google: Angular wurde von Google entwickelt und ist stark mit dem Unternehmen verbunden. Einige Entwickler haben Bedenken hinsichtlich der langfristigen Unterstützung und der Unabhängigkeit von Google.\nAngular Projekt aufsetzen Um ein neues Angular-Projekt zu erstellen, kannst du das Angular CLI (Command Line Interface) verwenden. Dazu muss es aber zuerst installiert werden.\nAngular CLI installieren Man muss als Vorarbeit sicherstellen, dass Node.js auf dem Computer installiert ist (npm -v im Terminal eingeben). Im Terminal muss man danach den folgenden Befehl ausführen, um die Angular CLI global zu installieren:\n1 npm install -g @angular/cli Projekt erstellen Nun muss in das Verzeichnis gewechselt werden, in dem das Angular-Projekt erstellen werden soll, und nun muss man den folgenden Befehl ausführen:\n1 ng new new-angular-project Als nächstes muss in das Projektverzeichnis gewechselt werden, indem man den folgenden Befehl ausführt:\n1 cd new-angular-project Projekt starten Mit dem folgenden Befehl kann man den Entwicklungsserver starten, um das Angular-Projekt im Browser anzuzeigen:\n1 ng serve Der Entwicklungsserver wird gestartet und die Anwendung wird (standardmässig) auf http://localhost:4200 bereitgestellt. Man kann diese URL in einem Webbrowser öffnen, um die Angular-Anwendung anzuschauen.\nAngular CLI Das Angular CLI (Command Line Interface) ist ein Befehlszeilenwerkzeug, das von Angular bereitgestellt wird. Es ermöglicht Entwicklern, effizienter mit Angular zu arbeiten, indem es verschiedene Funktionen und Befehle zur Verfügung stellt, um die Erstellung, Entwicklung, Bereitstellung und Wartung von Angular-Projekten zu unterstützen.\nCommands ng new : Erstellt ein neues Angular-Projekt mit der angegebenen Projektstruktur und -konfiguration.\nng serve: Startet den Entwicklungsserver und stellt die Angular-Anwendung auf http://localhost:4200 bereit. Änderungen werden in Echtzeit reflektiert.\nng serve –open: Startet den Entwicklungsserver und öffnet automatisch den Standardwebbrowser, um die Anwendung anzuzeigen.\nng generate (oder ng g ): Generiert eine neue Datei oder Komponente basierend auf einer vorgegebenen Vorlage.\nComponent: ng generate component oder ng g c Erzeugt eine neue Komponente mit einer Component-Datei, einer Template-Datei, einer Stylesheet-Datei und einem Testfile.\nModule: ng generate module oder ng g m Service: ng generate service oder ng g s Directive: ng generate directive oder ng g d Klassen: ng generate class oder ng g cl Enum: ng generate enum oder ng g e Interface: ng generate interface oder ng g i Pipe: ng generate pipe oder ng g p Guard: ng generate guard ng build: Kompiliert und baut die Angular-Anwendung für die Produktion. Erzeugt optimierten JavaScript-Code, der für die Bereitstellung auf einem Webserver verwendet werden kann.\nng test: Führt die Unit-Tests des Projekts aus, um sicherzustellen, dass die Anwendung ordnungsgemäß funktioniert.\nng lint: Überprüft den Code auf Einhaltung der definierten Linting-Regeln.\nng update: Aktualisiert die Angular-Abhängigkeiten und -Pakete auf die neuesten Versionen.\nng add : Fügt ein externes Paket oder eine Bibliothek zum Angular-Projekt hinzu. Installiert und konfiguriert das Paket automatisch.\nng help: Zeigt eine Liste der verfügbaren Befehle und Optionen der Angular CLI an.\nKonfigurationsdatei für eine Angular-Anwendung Die angular.json-Datei ist die Konfigurationsdatei eines Angular-Projekts. Sie enthält verschiedene Einstellungen und Konfigurationen für das Build-System, die Erstellung des Projekts, den Asset-Manager und vieles mehr. Die Datei wird automatisch generiert, wenn ein neues Angular-Projekt mit der Angular CLI erstellt wird.\nEinstiegspunkt einer Angular-Anwendung Typescript Der Einstiegspunkt einer Angular-Anwendung ist die Datei main.ts. Diese Datei ist das Hauptmodul der Anwendung, in dem der Bootstrap-Prozess gestartet wird.\n1 2 3 4 5 6 7 import { platformBrowserDynamic } from \"@angular/platform-browser-dynamic\"; import { AppModule } from \"./app/app.module\"; platformBrowserDynamic() .bootstrapModule(AppModule) .catch((err) =\u003e console.error(err)); Das AppModule selbst ist das Root-Modul der Angular-Anwendung. Es wird in der Regel in einer separaten Datei (app.module.ts) definiert und enthält die erforderlichen Importe und Konfigurationen für die Anwendung, einschliesslich der Components, Services, Modules und anderer Funktionen, welche d Anwendung benötigt.\nDie main.ts-Datei wird beim Starten der Angular-Anwendung vom Build-System oder von der Angular CLI aufgerufen. Sie ist der erste Punkt, an dem der Angular-Bootstrap-Prozess beginnt und die erforderlichen Ressourcen und Module geladen werden.\nEs ist wichtig zu beachten, dass die main.ts-Datei normalerweise nicht manuell bearbeitet werden muss, es sei denn, man hat spezifische Anpassungen oder Erweiterungen für den Bootstrap-Prozess vorzunehmen. Die meisten Änderungen und Konfigurationen sollten im AppModule und den anderen Modulen der Anwendung vorgenommen werden.\nEs ist wichtig zu beachten, dass seit Angular 17 das App-Modul nicht mehr standardmässig beim Erstellen eines neuen Angular-Projekts generiert wird, da seit Angular 17 alle Components standardmässig standalone sind und alle nötigen Imports selber enthalten, womit das App-Modul entfällt. Wenn du trotzdem ein App-Modul generieren möchtest, musst du beim Erstellen des Angular-Projekts das “– no-standalone”-Flag zum Befehl hinzufügen:\n1 ng new \u003cname\u003e --no-standalone Das Einstiegs-HTML-Dokument einer Angular-Anwendung ist die index.html-Datei. Diese Datei wird automatisch generiert, wenn die Anwendung kompiliert.\nIn der index.html-Datei befindet sich das grundlegende HTML-Markup für die Anwendung. Hier werden die erforderlichen Skripte und Stylesheets eingebunden und der Ort definiert, an dem die Angular-Anwendung in das DOM eingefügt wird.\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u003c!doctype html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\" /\u003e \u003ctitle\u003eAngular App\u003c/title\u003e \u003cbase href=\"/\" /\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /\u003e \u003clink rel=\"icon\" type=\"image/x-icon\" href=\"favicon.ico\" /\u003e \u003c/head\u003e \u003cbody\u003e \u003capp-root\u003e\u003c/app-root\u003e \u003c/body\u003e \u003c/html\u003e Im \u003chead\u003e-Tag befindet sich der \u003ctitle\u003e-tag, dieser definiert den Titel der Webseite, der normalerweise im Browser-Tab angezeigt wird. Das \u003clink rel=\"icon\" type=\"image/x-icon\" href=\"...\"\u003e-Tag bindet das Favicon (Favoriten-Symbol) der Webseite ein, das normalerweise im Browser-Tab und in Lesezeichen angezeigt wird. Diese zwei kann man nach Belieben ändern.\nBeim Starten der Angular-Anwendung wird der Inhalt der index.html-Datei vom Webbrowser geladen. Der Angular-Bootstrap-Prozess findet das \u003capp-root\u003e-Element und ersetzt es durch den gerenderten Inhalt der Angular-Komponenten.\nApp Component Der “AppComponent” ist der Hauptcomponent einer Angular-Anwendung. Es handelt sich um den Wurzelcomponent, von dem aus alle anderen Components und Elemente der Anwendung hierarchisch aufgebaut sind.\nEr wird automatisch während der Initialisierung der Anwendung erstellt und gerendert. Er dient als Container für das gesamte Anwendungslayout und ist der erste Component, der in der index.html-Datei der Anwendung mittels dem \u003capp-root\u003e-Tag geladen wird.\nAngular Best(Good)-Practices Angular bietet eine Reihe von bewährten Best Practices, die helfen können, die Angular-Anwendungen effizienter, wartbarer und skalierbarer zu gestalten. Hier sind einige wichtige Angular Best Practices:\nVerwendung der Angular CLI: Die Angular CLI erstellt automatisch eine standardisierte Projektstruktur, die bewährten Praktiken und Konventionen folgt. Das erleichtert die Organisation und Wartung des Codes, da Entwickler eine einheitliche Struktur innerhalb des Projekts erwarten können. Daher sollte zum Erstellen von neuen Dateien und / oder Komponenten auch immer die CLI verwendet werden. Eine Aufgabe pro Component: Der Code sollte in kleine, wiederverwendbare Komponenten aufgeteilt werden. Jeder Component sollte eine klare Verantwortung haben und nur für eine spezifische Aufgabe zuständig sein. Um im Typescript Code Konventionen und Best Practices zu befolgen, sollte man zudem einen Linter verwenden, um dies zu prüfen. Nutzung der Angular Template-Syntax: Es sollte die Angular-spezifische Template-Syntax verwendet werden, um Data-Bindung, Ereignisbehandlung und Strukturierung des DOMs im Templates zu erleichtern. Komplexe Logik in den Templates sollte vermieden werden, sie sollte möglichst lesbar sein. Dazu kann man Formatter wie Prettier verwenden, um den gesamten Code zu vereinfachen. Nutzung von Lazy Loading für Module: Das Lazy-Loading-Feature von Angular sollte verwendet werden, um die Ladezeit der Anwendung zu verbessern. Man sollte Module nur dann laden, wenn sie benötigt werden, anstatt die gesamte Anwendung auf einmal zu laden. Angular Dokumentation Die offizielle Dokumentation bietet den Entwicklern eine umfassende und verlässliche Informationsquelle für das entsprechende Framework oder die entsprechende Technologie bereitzustellen. Diese Dokumentationen bieten eine strukturierte Anleitungen und Erklärungen zu den verschiedenen Funktionen, Konzepten, APIs, Best Practices und Verwendungsmöglichkeiten. Angular hat mit dem Update auf die Version 19 auch eine neue Dokumentationsseite veröffentlicht. In dieser findet man alle Informationen zu den neuen Standards und Funktionen.\nEin wichtiger Teil der Dokumentation ist die detaillierte API-Referenz. Hier werden alle verfügbaren Klassen, Methoden, Parameter und Rückgabewerte beschrieben. Dies erleichtert es Entwicklern, die verfügbaren Funktionalitäten zu verstehen und effektiv zu nutzen.\nAbgesehen von reinen Codebeispielen bieten Dokumentationen auch konzeptionelle Erklärungen. Diese beschreiben die zugrunde liegenden Prinzipien, Architekturkonzepte und Entscheidungen, die beim Design der Technologie getroffen wurden.\nIn der Angular Dokumentation sind zudem auch Tutorials zu finden, welche durchgeführt werden können, um das Verständnis in Angular zu stärken.\nZudem ist nun auch ein sogenannter Playground von Angular selbst hinzugefügt worden, diesen kann man auch über die Dokumentation erreichen. Der Playground erfüllt den Nutzen, dass Entwickler ihren Code vorab isoliert im Browser testen können, ohne dafür ein neues Angular-Projekt aufsetzen zu müssen. Vor dem offiziellen Playground musste fürs Testen vorab Stackblitz verwenden. Die Seite ist jedoch auch heutzutage immer noch sehr hilfreich, da man dort in verschiedensten Sprachen Code im Browser testen kann.\nDebugging Auch bei Angular bleibt Debugging ein wichtiges Thema. Grundsätzlich bleibt alles gleich wie bei JavaScript, wenn du dein Wissen jedoch nochmals auffrischen möchtest, kannst du hier klicken.\n","categories":"","description":"Modul #F6 - Angular - Was ist Angular?\n","excerpt":"Modul #F6 - Angular - Was ist Angular?\n","ref":"/docs/03_web/06_angular/02_1_einfuehrung/","tags":"","title":"Einführung in Angular"},{"body":"Ziele Du kennst die Vor- und Nachteile von Angular. Du weisst, wie du ein erstes Angular-Projekt aufsetzen kannst. Was ist Angular Angular ist ein Framework um SPA’s (Single Page Applications) mittels HTML und JavaScript zu erstellen und besteht aus verschiedenen Core- und Optional-JavaScript-Bibliotheken. Angular wird für Frontend-Applikationen verwendet. Oft wird ein Backend via HTTP(S) angebunden. Vorteile von Angular Umfangreiche Funktionalität: Angular bietet eine Vielzahl von Funktionen und Features, die für die Entwicklung von komplexen Webanwendungen erforderlich sind. Es enthält ein leistungsfähiges Template-System, Datenbindung, Routing, Formularvalidierung, Dependency Injection und vieles mehr.\nStrukturierte Architektur: Angular basiert auf dem Konzept der Components-Based Architektur. Die Anwendung wird in unabhängige, wiederverwendbare Components strukturiert, was die Wartbarkeit und Testbarkeit erleichtert.\nProduktivität: Angular bietet viele Hilfsmittel, die die Entwicklungszeit verkürzen. Dazu gehören die Angular CLI (Command Line Interface) zur Projektgenerierung und automatisierten Aufgaben, ein reichhaltiges Ökosystem von Libraries und Extensions sowie eine umfangreiche Dokumentation.\nTypeScript-Unterstützung: Angular ist in TypeScript geschrieben. TypeScript bietet statische Typisierung, verbesserte IDE-Unterstützung und ermöglicht eine bessere Fehlererkennung zur Entwicklungszeit.\nGrosse Community: Angular ist ein viel genutztes Framework, wodurch bereits viele Best-Practices, standartisierte Vorgehensweisen und bewährte Praktiken und Konventionen bestehen, an denen man sich als Entwickler orientieren kann.\nNachteile von Angular Lernkurve: Angular ist ein umfangreiches Framework und erfordert eine gewisse Einarbeitungszeit. Die Konzepte wie Dependency Injection, TypeScript und das Componentmodel können für Entwickler mit wenig Erfahrung zunächst herausfordernd sein.\nGrösse: Angular ist ein umfangreiches Framework, was zu grossen Anwendungen führen kann. Das kann die Ladezeit beeinflussen, insbesondere für mobile Geräte mit langsamer Internetverbindung.\nKomplexität: Aufgrund der vielen Funktionen und Konzepte kann die Komplexität von Angular zunehmen, insbesondere für kleinere Projekte, bei denen nicht alle Funktionen benötigt werden.\nAbhängigkeit von Google: Angular wurde von Google entwickelt und ist stark mit dem Unternehmen verbunden. Einige Entwickler haben Bedenken hinsichtlich der langfristigen Unterstützung und der Unabhängigkeit von Google.\nAngular Projekt aufsetzen Um ein neues Angular-Projekt zu erstellen, kannst du das Angular CLI (Command Line Interface) verwenden. Dazu muss es aber zuerst installiert werden.\nAngular CLI installieren Man muss als Vorarbeit sicherstellen, dass Node.js auf dem Computer installiert ist (npm -v im Terminal eingeben). Im Terminal muss man danach den folgenden Befehl ausführen, um die Angular CLI global zu installieren:\n1 npm install -g @angular/cli Projekt erstellen Nun muss in das Verzeichnis gewechselt werden, in dem das Angular-Projekt erstellen werden soll, und nun muss man den folgenden Befehl ausführen:\n1 ng new new-angular-project Als nächstes muss in das Projektverzeichnis gewechselt werden, indem man den folgenden Befehl ausführt:\n1 cd new-angular-project Projekt starten Mit dem folgenden Befehl kann man den Entwicklungsserver starten, um das Angular-Projekt im Browser anzuzeigen:\n1 ng serve Der Entwicklungsserver wird gestartet und die Anwendung wird (standardmässig) auf http://localhost:4200 bereitgestellt. Man kann diese URL in einem Webbrowser öffnen, um die Angular-Anwendung anzuschauen.\nAngular CLI Das Angular CLI (Command Line Interface) ist ein Befehlszeilenwerkzeug, das von Angular bereitgestellt wird. Es ermöglicht Entwicklern, effizienter mit Angular zu arbeiten, indem es verschiedene Funktionen und Befehle zur Verfügung stellt, um die Erstellung, Entwicklung, Bereitstellung und Wartung von Angular-Projekten zu unterstützen.\nCommands ng new : Erstellt ein neues Angular-Projekt mit der angegebenen Projektstruktur und -konfiguration.\nng serve: Startet den Entwicklungsserver und stellt die Angular-Anwendung auf http://localhost:4200 bereit. Änderungen werden in Echtzeit reflektiert.\nng serve –open: Startet den Entwicklungsserver und öffnet automatisch den Standardwebbrowser, um die Anwendung anzuzeigen.\nng generate (oder ng g ): Generiert eine neue Datei oder Komponente basierend auf einer vorgegebenen Vorlage.\nComponent: ng generate component oder ng g c Erzeugt eine neue Komponente mit einer Component-Datei, einer Template-Datei, einer Stylesheet-Datei und einem Testfile.\nModule: ng generate module oder ng g m Service: ng generate service oder ng g s Directive: ng generate directive oder ng g d Klassen: ng generate class oder ng g cl Enum: ng generate enum oder ng g e Interface: ng generate interface oder ng g i Pipe: ng generate pipe oder ng g p Guard: ng generate guard ng build: Kompiliert und baut die Angular-Anwendung für die Produktion. Erzeugt optimierten JavaScript-Code, der für die Bereitstellung auf einem Webserver verwendet werden kann.\nng test: Führt die Unit-Tests des Projekts aus, um sicherzustellen, dass die Anwendung ordnungsgemäß funktioniert.\nng lint: Überprüft den Code auf Einhaltung der definierten Linting-Regeln.\nng update: Aktualisiert die Angular-Abhängigkeiten und -Pakete auf die neuesten Versionen.\nng add : Fügt ein externes Paket oder eine Bibliothek zum Angular-Projekt hinzu. Installiert und konfiguriert das Paket automatisch.\nng help: Zeigt eine Liste der verfügbaren Befehle und Optionen der Angular CLI an.\nKonfigurationsdatei für eine Angular-Anwendung Die angular.json-Datei ist die Konfigurationsdatei eines Angular-Projekts. Sie enthält verschiedene Einstellungen und Konfigurationen für das Build-System, die Erstellung des Projekts, den Asset-Manager und vieles mehr. Die Datei wird automatisch generiert, wenn ein neues Angular-Projekt mit der Angular CLI erstellt wird.\nEinstiegspunkt einer Angular-Anwendung Typescript Der Einstiegspunkt einer Angular-Anwendung ist die Datei main.ts. Diese Datei ist das Hauptmodul der Anwendung, in dem der Bootstrap-Prozess gestartet wird.\n1 2 3 4 5 6 7 import { platformBrowserDynamic } from \"@angular/platform-browser-dynamic\"; import { AppModule } from \"./app/app.module\"; platformBrowserDynamic() .bootstrapModule(AppModule) .catch((err) =\u003e console.error(err)); Das AppModule selbst ist das Root-Modul der Angular-Anwendung. Es wird in der Regel in einer separaten Datei (app.module.ts) definiert und enthält die erforderlichen Importe und Konfigurationen für die Anwendung, einschliesslich der Components, Services, Modules und anderer Funktionen, welche d Anwendung benötigt.\nDie main.ts-Datei wird beim Starten der Angular-Anwendung vom Build-System oder von der Angular CLI aufgerufen. Sie ist der erste Punkt, an dem der Angular-Bootstrap-Prozess beginnt und die erforderlichen Ressourcen und Module geladen werden.\nEs ist wichtig zu beachten, dass die main.ts-Datei normalerweise nicht manuell bearbeitet werden muss, es sei denn, man hat spezifische Anpassungen oder Erweiterungen für den Bootstrap-Prozess vorzunehmen. Die meisten Änderungen und Konfigurationen sollten im AppModule und den anderen Modulen der Anwendung vorgenommen werden.\nEs ist wichtig zu beachten, dass seit Angular 17 das App-Modul nicht mehr standardmässig beim Erstellen eines neuen Angular-Projekts generiert wird, da seit Angular 17 alle Components standardmässig standalone sind und alle nötigen Imports selber enthalten, womit das App-Modul entfällt. Wenn du trotzdem ein App-Modul generieren möchtest, musst du beim Erstellen des Angular-Projekts das “– no-standalone”-Flag zum Befehl hinzufügen:\n1 ng new \u003cname\u003e --no-standalone Das Einstiegs-HTML-Dokument einer Angular-Anwendung ist die index.html-Datei. Diese Datei wird automatisch generiert, wenn die Anwendung kompiliert.\nIn der index.html-Datei befindet sich das grundlegende HTML-Markup für die Anwendung. Hier werden die erforderlichen Skripte und Stylesheets eingebunden und der Ort definiert, an dem die Angular-Anwendung in das DOM eingefügt wird.\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u003c!doctype html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\" /\u003e \u003ctitle\u003eAngular App\u003c/title\u003e \u003cbase href=\"/\" /\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /\u003e \u003clink rel=\"icon\" type=\"image/x-icon\" href=\"favicon.ico\" /\u003e \u003c/head\u003e \u003cbody\u003e \u003capp-root\u003e\u003c/app-root\u003e \u003c/body\u003e \u003c/html\u003e Im \u003chead\u003e-Tag befindet sich der \u003ctitle\u003e-tag, dieser definiert den Titel der Webseite, der normalerweise im Browser-Tab angezeigt wird. Das \u003clink rel=\"icon\" type=\"image/x-icon\" href=\"...\"\u003e-Tag bindet das Favicon (Favoriten-Symbol) der Webseite ein, das normalerweise im Browser-Tab und in Lesezeichen angezeigt wird. Diese zwei kann man nach Belieben ändern.\nBeim Starten der Angular-Anwendung wird der Inhalt der index.html-Datei vom Webbrowser geladen. Der Angular-Bootstrap-Prozess findet das \u003capp-root\u003e-Element und ersetzt es durch den gerenderten Inhalt der Angular-Komponenten.\nApp Component Der “AppComponent” ist der Hauptcomponent einer Angular-Anwendung. Es handelt sich um den Wurzelcomponent, von dem aus alle anderen Components und Elemente der Anwendung hierarchisch aufgebaut sind.\nEr wird automatisch während der Initialisierung der Anwendung erstellt und gerendert. Er dient als Container für das gesamte Anwendungslayout und ist der erste Component, der in der index.html-Datei der Anwendung mittels dem \u003capp-root\u003e-Tag geladen wird.\nAngular Best(Good)-Practices Angular bietet eine Reihe von bewährten Best Practices, die helfen können, die Angular-Anwendungen effizienter, wartbarer und skalierbarer zu gestalten. Hier sind einige wichtige Angular Best Practices:\nVerwendung der Angular CLI: Die Angular CLI erstellt automatisch eine standardisierte Projektstruktur, die bewährten Praktiken und Konventionen folgt. Das erleichtert die Organisation und Wartung des Codes, da Entwickler eine einheitliche Struktur innerhalb des Projekts erwarten können. Daher sollte zum Erstellen von neuen Dateien und / oder Komponenten auch immer die CLI verwendet werden. Eine Aufgabe pro Component: Der Code sollte in kleine, wiederverwendbare Komponenten aufgeteilt werden. Jeder Component sollte eine klare Verantwortung haben und nur für eine spezifische Aufgabe zuständig sein. Um im Typescript Code Konventionen und Best Practices zu befolgen, sollte man zudem einen Linter verwenden, um dies zu prüfen. Nutzung der Angular Template-Syntax: Es sollte die Angular-spezifische Template-Syntax verwendet werden, um Data-Bindung, Ereignisbehandlung und Strukturierung des DOMs im Templates zu erleichtern. Komplexe Logik in den Templates sollte vermieden werden, sie sollte möglichst lesbar sein. Dazu kann man Formatter wie Prettier verwenden, um den gesamten Code zu vereinfachen. Nutzung von Lazy Loading für Module: Das Lazy-Loading-Feature von Angular sollte verwendet werden, um die Ladezeit der Anwendung zu verbessern. Man sollte Module nur dann laden, wenn sie benötigt werden, anstatt die gesamte Anwendung auf einmal zu laden. Angular Dokumentation Die offizielle Dokumentation bietet den Entwicklern eine umfassende und verlässliche Informationsquelle für das entsprechende Framework oder die entsprechende Technologie bereitzustellen. Diese Dokumentationen bieten eine strukturierte Anleitungen und Erklärungen zu den verschiedenen Funktionen, Konzepten, APIs, Best Practices und Verwendungsmöglichkeiten. Angular hat mit dem Update auf die Version 19 auch eine neue Dokumentationsseite veröffentlicht. In dieser findet man alle Informationen zu den neuen Standards und Funktionen.\nEin wichtiger Teil der Dokumentation ist die detaillierte API-Referenz. Hier werden alle verfügbaren Klassen, Methoden, Parameter und Rückgabewerte beschrieben. Dies erleichtert es Entwicklern, die verfügbaren Funktionalitäten zu verstehen und effektiv zu nutzen.\nAbgesehen von reinen Codebeispielen bieten Dokumentationen auch konzeptionelle Erklärungen. Diese beschreiben die zugrunde liegenden Prinzipien, Architekturkonzepte und Entscheidungen, die beim Design der Technologie getroffen wurden.\nIn der Angular Dokumentation sind zudem auch Tutorials zu finden, welche durchgeführt werden können, um das Verständnis in Angular zu stärken.\nZudem ist nun auch ein sogenannter Playground von Angular selbst hinzugefügt worden, diesen kann man auch über die Dokumentation erreichen. Der Playground erfüllt den Nutzen, dass Entwickler ihren Code vorab isoliert im Browser testen können, ohne dafür ein neues Angular-Projekt aufsetzen zu müssen. Vor dem offiziellen Playground musste fürs Testen vorab Stackblitz verwenden. Die Seite ist jedoch auch heutzutage immer noch sehr hilfreich, da man dort in verschiedensten Sprachen Code im Browser testen kann.\nDebugging Auch bei Angular bleibt Debugging ein wichtiges Thema. Grundsätzlich bleibt alles gleich wie bei JavaScript, wenn du dein Wissen jedoch nochmals auffrischen möchtest, kannst du hier klicken.\n","categories":"","description":"Modul #F6 - Angular - Was ist Angular?\n","excerpt":"Modul #F6 - Angular - Was ist Angular?\n","ref":"/de/docs/03_web/06_angular/02_1_einfuehrung/","tags":"","title":"Einführung in Angular"},{"body":"Aufgaben Aufgabe 1 Im folgenden Code befindet sich eine Funktion für das Erhalten einer zufälligen Zahl zwischen dem min und max. Zudem befindet sich bereits ein Observable im Code, welches in zufälligen Intervallen einen Wert zurückgeben soll.\nDie Aufgabe ist nun das Observable so anzupassen, dass in der Subscription jeweils in zufälligen Abständen ein Wert zurückgegeben wird.\n1 2 3 4 5 6 7 8 9 10 11 12 13 import { Observable } from \"rxjs\"; function getRandomInterval(min: number, max: number): number { return Math.floor(Math.random() * (max - min + 1)) + min; } // Observable const intervalObservable = new Observable\u003cnumber\u003e(); // subcription intervalObservable.subscribe((interval) =\u003e { console.log(`Interval: ${interval}ms`); }); Aufgabe 2 Auch bei dieser Aufgabe ist bereits ein wenig Code schon gegeben. Und zwar erneut eine Funktion zum Erhalten einer zufälligen Zahl für die Celsiusgrade. Auch das Observable ist hier bereits gegeben, dieses emitted alle zwei Sekunden eine neue Random Celsiusgrad Zahl.\nDie Aufgabe ist nun beim subscriben auf das Observable, die kommende Celsius Zahl in Fahreinheiten umzuwandeln und dann beide zu loggen.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { Observable } from \"rxjs\"; function getRandomDegree(min: number, max: number): number { return Math.floor(Math.random() * (max - min + 1)) + min; } const temperatureInC = new Observable\u003cnumber\u003e((subscriber) =\u003e { setInterval(() =\u003e { subscriber.next(getRandomDegree(0, 45)); }, 2000); }); temperatureInC.subscribe((celsius) =\u003e { console.log(`Celsius: ${celsius}`); }); Aufgabe 3 In den Docs wurden dir verschiedene Versionen von Subjects vorgestellt. Jede davon hat ihre speziellen Eigenschaften. Diese sollst du in dieser Aufgabe vertiefen. In der nachfolgenden Vorlage befindet sich ein grober Aufbau, den du erweitern sollt. Du sollst anhand dieser Vorlage eine Art Chat erstellen, der eine Nachricht an ein Subject schickt. Jede Nachricht soll ausserdem einen Zeitstempel haben. Ziel ist es, dass du alle bekannten Subjects verwendest. Schlussendlich soll jeweils die Ausgabe der Subjects im \u003cdiv class=\"output\"\u003e zu sehen sein. Schreibe dazu die benötigten Funktionen submit, addSubscriptions und complete.\nVorlage 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 \u003c!doctype html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\" /\u003e \u003ctitle\u003eSubject Lab\u003c/title\u003e \u003cscript src=\"https://unpkg.com/rxjs@6.2.0/bundles/rxjs.umd.min.js\"\u003e\u003c/script\u003e \u003cscript\u003e function submit() { // TODO: Nachricht zu Subject senden } function addSubscriptions() { // TODO: Subscription starten } function complete() { // TODO: Subject complete } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"wrapper\"\u003e \u003cdiv class=\"actions\"\u003e \u003cinput id=\"chat\" type=\"text\" placeholder=\"Please enter your message\" /\u003e \u003cbutton id=\"submit\"\u003eSend\u003c/button\u003e \u003cbutton id=\"add-subscriptions\"\u003eSubscriptions\u003c/button\u003e \u003cbutton id=\"complete\"\u003eComplete\u003c/button\u003e \u003c/div\u003e \u003cdiv class=\"output\"\u003e \u003c!-- TODO: Für jeden Typ von Subject einen separaten Output--\u003e \u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ","categories":"","description":"Aufgaben zu Observales und RxJS.\n","excerpt":"Aufgaben zu Observales und RxJS.\n","ref":"/labs/03_web/04_angular/02_rxjs/","tags":"","title":"Labs zu RxJS"},{"body":"Aufgaben Aufgabe 1 Im folgenden Code befindet sich eine Funktion für das Erhalten einer zufälligen Zahl zwischen dem min und max. Zudem befindet sich bereits ein Observable im Code, welches in zufälligen Intervallen einen Wert zurückgeben soll.\nDie Aufgabe ist nun das Observable so anzupassen, dass in der Subscription jeweils in zufälligen Abständen ein Wert zurückgegeben wird.\n1 2 3 4 5 6 7 8 9 10 11 12 13 import { Observable } from \"rxjs\"; function getRandomInterval(min: number, max: number): number { return Math.floor(Math.random() * (max - min + 1)) + min; } // Observable const intervalObservable = new Observable\u003cnumber\u003e(); // subcription intervalObservable.subscribe((interval) =\u003e { console.log(`Interval: ${interval}ms`); }); Aufgabe 2 Auch bei dieser Aufgabe ist bereits ein wenig Code schon gegeben. Und zwar erneut eine Funktion zum Erhalten einer zufälligen Zahl für die Celsiusgrade. Auch das Observable ist hier bereits gegeben, dieses emitted alle zwei Sekunden eine neue Random Celsiusgrad Zahl.\nDie Aufgabe ist nun beim subscriben auf das Observable, die kommende Celsius Zahl in Fahreinheiten umzuwandeln und dann beide zu loggen.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { Observable } from \"rxjs\"; function getRandomDegree(min: number, max: number): number { return Math.floor(Math.random() * (max - min + 1)) + min; } const temperatureInC = new Observable\u003cnumber\u003e((subscriber) =\u003e { setInterval(() =\u003e { subscriber.next(getRandomDegree(0, 45)); }, 2000); }); temperatureInC.subscribe((celsius) =\u003e { console.log(`Celsius: ${celsius}`); }); Aufgabe 3 In den Docs wurden dir verschiedene Versionen von Subjects vorgestellt. Jede davon hat ihre speziellen Eigenschaften. Diese sollst du in dieser Aufgabe vertiefen. In der nachfolgenden Vorlage befindet sich ein grober Aufbau, den du erweitern sollt. Du sollst anhand dieser Vorlage eine Art Chat erstellen, der eine Nachricht an ein Subject schickt. Jede Nachricht soll ausserdem einen Zeitstempel haben. Ziel ist es, dass du alle bekannten Subjects verwendest. Schlussendlich soll jeweils die Ausgabe der Subjects im \u003cdiv class=\"output\"\u003e zu sehen sein. Schreibe dazu die benötigten Funktionen submit, addSubscriptions und complete.\nVorlage 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 \u003c!doctype html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\" /\u003e \u003ctitle\u003eSubject Lab\u003c/title\u003e \u003cscript src=\"https://unpkg.com/rxjs@6.2.0/bundles/rxjs.umd.min.js\"\u003e\u003c/script\u003e \u003cscript\u003e function submit() { // TODO: Nachricht zu Subject senden } function addSubscriptions() { // TODO: Subscription starten } function complete() { // TODO: Subject complete } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"wrapper\"\u003e \u003cdiv class=\"actions\"\u003e \u003cinput id=\"chat\" type=\"text\" placeholder=\"Please enter your message\" /\u003e \u003cbutton id=\"submit\"\u003eSend\u003c/button\u003e \u003cbutton id=\"add-subscriptions\"\u003eSubscriptions\u003c/button\u003e \u003cbutton id=\"complete\"\u003eComplete\u003c/button\u003e \u003c/div\u003e \u003cdiv class=\"output\"\u003e \u003c!-- TODO: Für jeden Typ von Subject einen separaten Output--\u003e \u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ","categories":"","description":"Aufgaben zu Observales und RxJS.\n","excerpt":"Aufgaben zu Observales und RxJS.\n","ref":"/de/labs/03_web/04_angular/02_rxjs/","tags":"","title":"Labs zu RxJS"},{"body":"Eine Nachricht loggen In Java hast du Text mit System.out.println(...), in C# mit Console.WriteLine(...) und vielleicht auch schon in Python mit print(...) geloggt. Natürlich ist das Loggen von Werten auch JavaScript möglich.\nDazu kannst du in deiner HTML-Datei (im \u003cscript\u003e-Tag) die folgende Zeile hinzufügen:\n1 2 3 4 5 \u003cscript\u003e ... // console output: hello world console.log('hello world'); \u003c/script\u003e Um diese Meldung sehen zu können, musst du die Konsole des Browsers öffnen. Dies kannst du machen, indem du die Entwickler-Tools des Browsers öffnest (meist über die [F12]-Taste). Anschliessend navigierst du zum “Konsole”-Tab. Nun solltest du die geloggte Nachricht einsehen können:\nCode direkt im Browser ausführen Du kannst Code auch direkt in der Konsole des Browsers ausführen lassen. Klicke hierfür in das Eingabefeld unterhalt deiner geloggten Nachricht (gekennzeichnet durch das \u003e-Symbol am Anfang). Dort kannst du dann Folgendes reinkopieren:\n1 2 3 for (let i = 0; i \u003c 10; i++) { console.log(i); } Nun sollten in deiner Konsole die Zahlen 0 - 9 geloggt worden sein. Den Code solltest du bereits durch deine Einführung in Java verstehen. Der einzige grosse Unterschied hier ist, dass du die Nummer-Variable mit let deklarieren musst.\nDu siehst also, wie einfach es ist, Code auf einer Website mithilfe der Konsole auszuführen. Die Konsole ist ein sehr mächtiges Tool, welches die Entwicklung mit JavaScript enorm vereinfachen kann. Oft kannst du, bevor du Code in der IDE (also deiner Entwicklungsumgebung) schreibst, vorher in der Konsole ausprobieren, ob dieser zum gewünschten Resultat führt.\nJavaScript in HTML einbinden Es gibt hauptsächlich 2 Möglichkeiten, wie du Javascript in ein HTML-File einbinden kannst, ähnlich wie es bei CSS der Fall ist.\nPer Inline-Script: JavaScript-Code kann direkt innerhalb einer HTML-Datei mit dem \u003cscript\u003e-Tag eingebettet werden. Der \u003cscript\u003e-Tag sollte entweder im \u003chead\u003e-Bereich oder am Ende des \u003cbody\u003e-Bereichs platziert werden. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u003c!doctype html\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eJavaScript in HTML\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eJavaScript in HTML\u003c/h1\u003e \u003cscript\u003e // Hier kannst du deinen JavaScript-Code schreiben alert(\"Hallo, Welt!\"); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e Per externem Skript: JavaScript-Code kann auch innerhalb einer separaten Datei geschrieben werden, welche dann mit dem \u003cscript\u003e-Tag in die HTML-Datei eingebunden werden kann. Dazu kannst du eine neue JavaScript-Datei mit der Erweiterung .js erstellen und dann im \u003cscript\u003e-Tag auf diese Datei mit dem src-Attribut verweisen. 1 2 3 4 5 6 7 8 9 10 \u003c!doctype html\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eJavaScript in HTML\u003c/title\u003e \u003cscript src=\"script.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eJavaScript in HTML\u003c/h1\u003e \u003c/body\u003e \u003c/html\u003e Es ist ebenfalls möglich, mehrere externe JavaScript-Dateien in dein HTML-File einzubinden, indem mehrere \u003cscript\u003e-Tags mit unterschiedlichen src-Attributen verwendet werden.\n","categories":"","description":"Modul #F4 - JavaScript - Konsole des Browsers benutzen.\n","excerpt":"Modul #F4 - JavaScript - Konsole des Browsers benutzen.\n","ref":"/docs/03_web/03_javascript/02_browser-tools/","tags":"","title":"JavaScript: Konsole"},{"body":"Eine Nachricht loggen In Java hast du Text mit System.out.println(...), in C# mit Console.WriteLine(...) und vielleicht auch schon in Python mit print(...) geloggt. Natürlich ist das Loggen von Werten auch JavaScript möglich.\nDazu kannst du in deiner HTML-Datei (im \u003cscript\u003e-Tag) die folgende Zeile hinzufügen:\n1 2 3 4 5 \u003cscript\u003e ... // console output: hello world console.log('hello world'); \u003c/script\u003e Um diese Meldung sehen zu können, musst du die Konsole des Browsers öffnen. Dies kannst du machen, indem du die Entwickler-Tools des Browsers öffnest (meist über die [F12]-Taste). Anschliessend navigierst du zum “Konsole”-Tab. Nun solltest du die geloggte Nachricht einsehen können:\nCode direkt im Browser ausführen Du kannst Code auch direkt in der Konsole des Browsers ausführen lassen. Klicke hierfür in das Eingabefeld unterhalt deiner geloggten Nachricht (gekennzeichnet durch das \u003e-Symbol am Anfang). Dort kannst du dann Folgendes reinkopieren:\n1 2 3 for (let i = 0; i \u003c 10; i++) { console.log(i); } Nun sollten in deiner Konsole die Zahlen 0 - 9 geloggt worden sein. Den Code solltest du bereits durch deine Einführung in Java verstehen. Der einzige grosse Unterschied hier ist, dass du die Nummer-Variable mit let deklarieren musst.\nDu siehst also, wie einfach es ist, Code auf einer Website mithilfe der Konsole auszuführen. Die Konsole ist ein sehr mächtiges Tool, welches die Entwicklung mit JavaScript enorm vereinfachen kann. Oft kannst du, bevor du Code in der IDE (also deiner Entwicklungsumgebung) schreibst, vorher in der Konsole ausprobieren, ob dieser zum gewünschten Resultat führt.\nJavaScript in HTML einbinden Es gibt hauptsächlich 2 Möglichkeiten, wie du Javascript in ein HTML-File einbinden kannst, ähnlich wie es bei CSS der Fall ist.\nPer Inline-Script: JavaScript-Code kann direkt innerhalb einer HTML-Datei mit dem \u003cscript\u003e-Tag eingebettet werden. Der \u003cscript\u003e-Tag sollte entweder im \u003chead\u003e-Bereich oder am Ende des \u003cbody\u003e-Bereichs platziert werden. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u003c!doctype html\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eJavaScript in HTML\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eJavaScript in HTML\u003c/h1\u003e \u003cscript\u003e // Hier kannst du deinen JavaScript-Code schreiben alert(\"Hallo, Welt!\"); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e Per externem Skript: JavaScript-Code kann auch innerhalb einer separaten Datei geschrieben werden, welche dann mit dem \u003cscript\u003e-Tag in die HTML-Datei eingebunden werden kann. Dazu kannst du eine neue JavaScript-Datei mit der Erweiterung .js erstellen und dann im \u003cscript\u003e-Tag auf diese Datei mit dem src-Attribut verweisen. 1 2 3 4 5 6 7 8 9 10 \u003c!doctype html\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eJavaScript in HTML\u003c/title\u003e \u003cscript src=\"script.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eJavaScript in HTML\u003c/h1\u003e \u003c/body\u003e \u003c/html\u003e Es ist ebenfalls möglich, mehrere externe JavaScript-Dateien in dein HTML-File einzubinden, indem mehrere \u003cscript\u003e-Tags mit unterschiedlichen src-Attributen verwendet werden.\n","categories":"","description":"Modul #F4 - JavaScript - Konsole des Browsers benutzen.\n","excerpt":"Modul #F4 - JavaScript - Konsole des Browsers benutzen.\n","ref":"/de/docs/03_web/03_javascript/02_browser-tools/","tags":"","title":"JavaScript: Konsole"},{"body":"","categories":"","description":"Webseiten erstellen mit HTML und CSS.\n","excerpt":"Webseiten erstellen mit HTML und CSS.\n","ref":"/docs/03_web/02_html_css/","tags":"","title":"HTML und CSS"},{"body":"","categories":"","description":"Webseiten erstellen mit HTML und CSS.\n","excerpt":"Webseiten erstellen mit HTML und CSS.\n","ref":"/de/docs/03_web/02_html_css/","tags":"","title":"HTML und CSS"},{"body":"","categories":"","description":"Exams zu HTML, CSS und JavaScript.\n","excerpt":"Exams zu HTML, CSS und JavaScript.\n","ref":"/exams/03_web/02_html_css/","tags":"","title":"HTML-, CSS- und JavaScript-Exams"},{"body":"","categories":"","description":"Exams zu HTML, CSS und JavaScript.\n","excerpt":"Exams zu HTML, CSS und JavaScript.\n","ref":"/de/exams/03_web/02_html_css/","tags":"","title":"HTML-, CSS- und JavaScript-Exams"},{"body":"Exam 1 - HTML5 \u0026 CSS3 - Einzelarbeit\nErstelle mit Hilfe deines aktuellen Wissen eine neue Webseite. Sie soll nur die HTML-Elemente und das CSS-Styling besitzen. Die logischen Instrumente sind nicht nötig, da wir uns im nächsten Kurs mit Javascript/Typescript beschäftigen werden. Verwende die HTML5 konformen Tags.\nRTM Nachzubauen ist die neue Webseite vom RTM(login).\nNachfolgend werden die einzelnen Komponenten erklärt. Es werden nur diverse Stylings gegeben, den Rest müsst ihr selber versuchen zu definieren. Zu unterst im File findet ihr noch diverse Hints, welche euch helfen könnten.\nDie Icons sind hier hinterlegt. Header Was Farbe Logo Grösse Hover Farbe Hintergrundfarbe in Header rgba(236,239,242,1); - height: 57.25px; - login Logo - login_logo.svg width: 180px; - Text in Header rgba(119,119,119,1); - - - Datum(Tag) rgba(213,45,40,1); - - - Kommen Logo - kommen.svg width: 22px; height: 22px; rgba(255,255,255,1); Farbe untere Zeile Logo rgba(255,0,0,1); - width: 250px; rgba(255,255,255,1); Uhr Logo - uhr.svg width: 22px; height: 22px; rgba(255,255,255,1); Pfeil (Menu Sprache) Logo - pfeil_unten.svg - rgba(255,255,255,1); Refresh Logo - refresh.svg width: 22px; height: 22px; rgba(255,255,255,1); Personen Logo - persons.svg width: 22px; height: 22px; rgba(255,255,255,1); Profil Logo - profil.svg width: 22px; height: 22px; rgba(255,255,255,1); Logout Logo - logout.svg width: 22px; height: 22px; rgba(255,255,255,1); Linke Sidenav Was Farbe Logo Grösse Hover Farbe Hintergrund in Sidenav rgba(0,158,195,1) - width: 180px; rgba(0,100,128,1); Profil Logo - profil.svg width: 88px;height: 88px; - Abwesend Text rgb(211, 47, 47); - - - Cockpit Logo background: rgba(230,230,230,1);color: rgba(115,115,115,1); cockpit.svg width: 16px; height: 16px; - Personen Logo - persons.svg width: 16px; height: 16px; background: rgba(0,100,128,1); Einsatzplan Logo - einsatzplan.svg width: 16px; height: 16px; background: rgba(0,100,128,1); Abfragen Logo - abfragen.svg width: 16px; height: 16px; background: rgba(0,100,128,1); Abfragen Pfeil Logo - pfeil_oben.svg width: 9px; height: 14px; rgba(0,100,128,1); Palungsliste Logo - einsatzplan.svg width: 16px; height: 16px; rgba(0,100,128,1); Tagesübersicht Logo - buchung.svg width: 16px; height: 16px; rgba(0,100,128,1); Buchungsliste Logo - buchung.svg width: 16px; height: 16px; rgba(0,100,128,1); Zeitwertliste Logo - buchung.svg width: 16px; height: 16px; rgba(0,100,128,1); Saldoübersicht Logo - saldo.svg width: 16px; height: 16px; rgba(0,100,128,1); Spesenauswertung Logo - buchung.svg width: 16px; height: 16px; rgba(0,100,128,1); Auftragsauswertung Logo - buchung.svg width: 16px; height: 16px; rgba(0,100,128,1); Berichte Logo - drucken.svg width: 16px; height: 16px; rgba(0,100,128,1); Rechte Sidenav Was Farbe Logo Grösse Hover Farbe Hintergrund in Sidenav rgba(255, 255, 255, 1); - width: 250px; rgba(245, 245, 245, 1); Anwesend Text rgba(66,159,70,1); - - - Profil Logo - profil.svg width: 35px; height: 35px; - Uhr Logo - clock.svg width: 24px; height: 28px; - Abwesend Text rgba(255,0,0,1); - - - Text allgemein rgba(33,33,33,1); - - - Content Was Farbe Logo Grösse Hover Farbe Hintergrund in Content background: rgb(243, 243, 243,1); color: rgba(33,33,33,1); - - - Bearbeiten Logo - edit.svg width: 14px; height: 14px; rgba(250, 250, 250, 1); Plus Logo (disabled) plus.svg color: lightgrey; width: 11px; height: 14px; rgba(250, 250, 250, 1); Pfeil-Unten Logo (disabled) pfeil_unten.svg color: lightgrey; width: 9px; height: 14px; rgba(250, 250, 250, 1); Speichern Logo (disabled) save.svg color: lightgrey; width: 12px; height: 14px; rgba(250, 250, 250, 1); Rückgängig Logo (disabled) undo.svg color: lightgrey; width: 12px; height: 14px; rgba(250, 250, 250, 1); JS Beginner rgba(217,230,242,1); - width: 716.5px; height: 180px; rgba(224,231,235,1); Profil Logo - profil.svg width: 140px; height: 140px; - Ausrufezeichen Logos - request.svg width: 24px; height: 24px; - Absenzen Text rgb(33, 150, 243); - width: 352.75px; height: 180px; - Visum Text rgb(16, 85, 192); - width: 352.75px; height: 180px; - Warnung Logo - warning.svg width: 24px; height: 24px; - Warnung Text rgb(219, 73, 216); - width: 352.75px; height: 180px; - Alarm Logo - alert.svg width: 24px; height: 24px; - Alart Text rgb(255, 67, 81); - width: 352.75px; height: 180px; - Hint: über allen hover-Elementen pointer\nSchatten: box-shadow\nScrollleiste: overflow-y oder overflow-x\nSobald du fertig bist… Wenn du fertig mit diesem Exam bist, zeige dein Resultat einem Praxisbildner. Nach dem Okay des Praxisbildners kannst du mit JavaScript beginnen.\n","categories":"","description":"Erstelle dein eigenes Zeiterfassungs-Dashboard - zumindest das Layout dafür ;).\n","excerpt":"Erstelle dein eigenes Zeiterfassungs-Dashboard - zumindest das Layout …","ref":"/exams/03_web/02_html_css/01_exam-html-css-rtm/","tags":"","title":"Exam zu den HTML- und CSS-Basics"},{"body":"Exam 1 - HTML5 \u0026 CSS3 - Einzelarbeit\nErstelle mit Hilfe deines aktuellen Wissen eine neue Webseite. Sie soll nur die HTML-Elemente und das CSS-Styling besitzen. Die logischen Instrumente sind nicht nötig, da wir uns im nächsten Kurs mit Javascript/Typescript beschäftigen werden. Verwende die HTML5 konformen Tags.\nRTM Nachzubauen ist die neue Webseite vom RTM(login).\nNachfolgend werden die einzelnen Komponenten erklärt. Es werden nur diverse Stylings gegeben, den Rest müsst ihr selber versuchen zu definieren. Zu unterst im File findet ihr noch diverse Hints, welche euch helfen könnten.\nDie Icons sind hier hinterlegt. Header Was Farbe Logo Grösse Hover Farbe Hintergrundfarbe in Header rgba(236,239,242,1); - height: 57.25px; - login Logo - login_logo.svg width: 180px; - Text in Header rgba(119,119,119,1); - - - Datum(Tag) rgba(213,45,40,1); - - - Kommen Logo - kommen.svg width: 22px; height: 22px; rgba(255,255,255,1); Farbe untere Zeile Logo rgba(255,0,0,1); - width: 250px; rgba(255,255,255,1); Uhr Logo - uhr.svg width: 22px; height: 22px; rgba(255,255,255,1); Pfeil (Menu Sprache) Logo - pfeil_unten.svg - rgba(255,255,255,1); Refresh Logo - refresh.svg width: 22px; height: 22px; rgba(255,255,255,1); Personen Logo - persons.svg width: 22px; height: 22px; rgba(255,255,255,1); Profil Logo - profil.svg width: 22px; height: 22px; rgba(255,255,255,1); Logout Logo - logout.svg width: 22px; height: 22px; rgba(255,255,255,1); Linke Sidenav Was Farbe Logo Grösse Hover Farbe Hintergrund in Sidenav rgba(0,158,195,1) - width: 180px; rgba(0,100,128,1); Profil Logo - profil.svg width: 88px;height: 88px; - Abwesend Text rgb(211, 47, 47); - - - Cockpit Logo background: rgba(230,230,230,1);color: rgba(115,115,115,1); cockpit.svg width: 16px; height: 16px; - Personen Logo - persons.svg width: 16px; height: 16px; background: rgba(0,100,128,1); Einsatzplan Logo - einsatzplan.svg width: 16px; height: 16px; background: rgba(0,100,128,1); Abfragen Logo - abfragen.svg width: 16px; height: 16px; background: rgba(0,100,128,1); Abfragen Pfeil Logo - pfeil_oben.svg width: 9px; height: 14px; rgba(0,100,128,1); Palungsliste Logo - einsatzplan.svg width: 16px; height: 16px; rgba(0,100,128,1); Tagesübersicht Logo - buchung.svg width: 16px; height: 16px; rgba(0,100,128,1); Buchungsliste Logo - buchung.svg width: 16px; height: 16px; rgba(0,100,128,1); Zeitwertliste Logo - buchung.svg width: 16px; height: 16px; rgba(0,100,128,1); Saldoübersicht Logo - saldo.svg width: 16px; height: 16px; rgba(0,100,128,1); Spesenauswertung Logo - buchung.svg width: 16px; height: 16px; rgba(0,100,128,1); Auftragsauswertung Logo - buchung.svg width: 16px; height: 16px; rgba(0,100,128,1); Berichte Logo - drucken.svg width: 16px; height: 16px; rgba(0,100,128,1); Rechte Sidenav Was Farbe Logo Grösse Hover Farbe Hintergrund in Sidenav rgba(255, 255, 255, 1); - width: 250px; rgba(245, 245, 245, 1); Anwesend Text rgba(66,159,70,1); - - - Profil Logo - profil.svg width: 35px; height: 35px; - Uhr Logo - clock.svg width: 24px; height: 28px; - Abwesend Text rgba(255,0,0,1); - - - Text allgemein rgba(33,33,33,1); - - - Content Was Farbe Logo Grösse Hover Farbe Hintergrund in Content background: rgb(243, 243, 243,1); color: rgba(33,33,33,1); - - - Bearbeiten Logo - edit.svg width: 14px; height: 14px; rgba(250, 250, 250, 1); Plus Logo (disabled) plus.svg color: lightgrey; width: 11px; height: 14px; rgba(250, 250, 250, 1); Pfeil-Unten Logo (disabled) pfeil_unten.svg color: lightgrey; width: 9px; height: 14px; rgba(250, 250, 250, 1); Speichern Logo (disabled) save.svg color: lightgrey; width: 12px; height: 14px; rgba(250, 250, 250, 1); Rückgängig Logo (disabled) undo.svg color: lightgrey; width: 12px; height: 14px; rgba(250, 250, 250, 1); JS Beginner rgba(217,230,242,1); - width: 716.5px; height: 180px; rgba(224,231,235,1); Profil Logo - profil.svg width: 140px; height: 140px; - Ausrufezeichen Logos - request.svg width: 24px; height: 24px; - Absenzen Text rgb(33, 150, 243); - width: 352.75px; height: 180px; - Visum Text rgb(16, 85, 192); - width: 352.75px; height: 180px; - Warnung Logo - warning.svg width: 24px; height: 24px; - Warnung Text rgb(219, 73, 216); - width: 352.75px; height: 180px; - Alarm Logo - alert.svg width: 24px; height: 24px; - Alart Text rgb(255, 67, 81); - width: 352.75px; height: 180px; - Hint: über allen hover-Elementen pointer\nSchatten: box-shadow\nScrollleiste: overflow-y oder overflow-x\nSobald du fertig bist… Wenn du fertig mit diesem Exam bist, zeige dein Resultat einem Praxisbildner. Nach dem Okay des Praxisbildners kannst du mit JavaScript beginnen.\n","categories":"","description":"Erstelle dein eigenes Zeiterfassungs-Dashboard - zumindest das Layout dafür ;).\n","excerpt":"Erstelle dein eigenes Zeiterfassungs-Dashboard - zumindest das Layout …","ref":"/de/exams/03_web/02_html_css/01_exam-html-css-rtm/","tags":"","title":"Exam zu den HTML- und CSS-Basics"},{"body":"","categories":"","description":"Exams zu Java Technologie\n","excerpt":"Exams zu Java Technologie\n","ref":"/exams/02_java/","tags":"","title":"Java Exams"},{"body":"","categories":"","description":"Exams zu Java Technologie\n","excerpt":"Exams zu Java Technologie\n","ref":"/de/exams/02_java/","tags":"","title":"Java Exams"},{"body":"java.util.ArrayList java.util.ArrayList erbt von der abstrakten Klasse java.util.AbstractList und liefert eine konkrete Implementierung für das Interface java.util.List. Die ArrayList Klasse implementiert alle Methoden des Interface java.util.List. Der Implementierung der ArrayList Klasse liegen Arrays zugrunde, weshalb diese konkrete Klasse auch ArrayList heisst. Die Klasse ArrayList enthält also ein normales Array. Wenn ein Element hinzugefügt wird, wird es in dieses Array eingefügt. Wenn das Array nicht gross genug ist, wird ein neues, grösseres Array erstellt, um das alte zu ersetzen, d.h. die Kapazität des Arrays wird fortlaufend angepasst.\nMethodenübersicht 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 /* * Konstruktor: Erstellt eine initial leere Liste */ public ArrayList\u003cE\u003e() /* * Appends the specified element to the end of this list. */ public boolean add(E e) /* * Fügt das angegebene Element an der angegebenen Position in diese Liste ein. */ public void add(int index,E element) /* * Entfernt alle Elemente aus dieser Liste. */ public void clear() /* * Entfernt das Element an der angegebenen Position in dieser Liste. */ public E remove(int index) /* * Gibt das Element an der angegebenen Position in dieser Liste zurück. */ public E get(int index) /* * Gibt den Index des ersten Auftretens des angegebenen Elements in dieser Liste zurück, * oder -1, wenn diese Liste das Element nicht enthält. */ public int indexOf(Object o) /* * Gibt die Anzahl der Elemente in dieser Liste zurück. */ public int size() /* * Gibt true zurück, wenn diese Liste keine Elemente enthält. */ public boolean isEmpty() /* * Gibt true zurück, wenn diese Liste das angegebene Element enthält. */ public boolean contains(Object o) Beispiel IndexOutOfBoundsException Eine der häufigsten Exceptions, die im Zusammenhang mit Listen auftritt, ist folgende: Es wird versucht, auf ein Element mit einem Index zuzugreifen, wobei der Index grösser als (oder gleich wie) die Länge der Liste ist. Dann wird die IndexOutOfBoundsException geworfen:\n1 2 3 4 5 6 List\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"uno\"); list.add(\"dos\"); list.add(\"tres\"); System.out.println(list.get(3)); Hier wird dann diese Meldung angezeigt:\n1 \"java.lang.IndexOutOfBoundsException: Index 3 out of bounds for length 3\" Der Fehler war hier, dass die Liste 3 Elemente enthielt, und versucht wird, auf das 4. Element (also Index 3) zuzugreifen. Weil das 4. Element in dieser Liste nicht existiert, wird eine Exception geworfen.\nGanz generell wird die IndexOutOfBoundException geworfen, wenn versucht wird, auf einen ungültigen Index innerhalb einer Collection zuzugreifen. Hat eine Liste die Grösse x:\ndann sind die gültigen Indizes, um auf Elemente zuzugreifen 0, 1, 2, …, x-1 und die Indizes x, x+1, x+2, … wären ungültig. Diese Exception kann bei den folgenden Methoden von oben geworfen werden: (Diese Liste hier ist genau so nicht vollständig, wie die oben.)\npublic void add(int index, E element) (beachte das Argument index.) public E remove(int index) public E get(int index) Beispiel Beispiel 1 - ArrayList Im folgenden Beispiel erstellen wir zunächst eine leere ArrayList mit Elementen vom Typ String und wenden einige einfache ArrayList Methoden an und sehen, wie diese funktionieren (Das Hinzufügen von Elementen, das Entfernen von Elementen, …),\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import java.util.ArrayList; import java.util.List; public class Pets { public static void main(String[] args) { // Creating an ArrayList of String List\u003cString\u003e pets = new ArrayList\u003c\u003e(); System.out.println(pets); // Output: [] // Adding new elements to the ArrayList pets.add(\"Cat\"); pets.add(\"Hamster\"); pets.add(\"Dog\"); pets.add(\"Goldfish\"); System.out.println(pets); // Output: [Cat, Hamster, Dog, Goldfish] // Adding an element at a particular index in an ArrayList pets.add(2, \"Guinea pigs\"); System.out.println(pets); // Output: [Cat, Hamster, Guinea pigs, Dog, Goldfish] pets.remove(2); System.out.println(pets); // Output: [Cat, Hamster, Dog, Goldfish] pets.remove(\"Dog\"); System.out.println(pets); // Output: [Cat, Hamster, Goldfish] pets.clear(); System.out.println(pets); // Output: [] } } Beispiel 2 - for-Schleife Dieses Beispiel zeigt auf wie mit einer for-Schleife über die Elemente einer Liste iteriert werden kann.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import java.util.ArrayList; class ListSum { public static void main(String[] args) { ArrayList\u003cInteger\u003e numbers = new ArrayList\u003c\u003e(); numbers.add(1000); numbers.add(2500); numbers.add(3750); numbers.add(625); int listSum = 0; for (Integer e : numbers) { listSum += e; } System.out.println(\"Die Summe der Elemente beträgt \" + listSum); } } Output:\n1 Die Summe der Elemente beträgt 7875 Beispiel 3 - while-Schleife Dieses Beispiel zeigt auf wie mit einer while-Schleife über die Elemente einer Liste iteriert werden kann.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import java.util.Arrays; import java.util.List; public class WhileLoopExample { public static void main(String[] args) { String[] namesArray = { \"Anna\", \"Simon\", \"Jan\", \"Nicole\"}; // convert array to list List\u003cString\u003e namesArrayList = Arrays.asList(namesArray); int i = 0; while (i \u003c namesArrayList.size()) { System.out.println(namesArrayList.get(i)); i++; } } } Output:\n1 2 3 4 Anna Simon Jan Nicole Aufgaben Aufgaben Aufgaben zu Modul #J6 - Java Collections - List\n","categories":"","description":"Eine konkrete Umsetzung einer List: Die ArrayList.\n","excerpt":"Eine konkrete Umsetzung einer List: Die ArrayList.\n","ref":"/docs/02_java/10_java-collections/02_array-list/","tags":"","title":"ArrayList"},{"body":"java.util.ArrayList java.util.ArrayList erbt von der abstrakten Klasse java.util.AbstractList und liefert eine konkrete Implementierung für das Interface java.util.List. Die ArrayList Klasse implementiert alle Methoden des Interface java.util.List. Der Implementierung der ArrayList Klasse liegen Arrays zugrunde, weshalb diese konkrete Klasse auch ArrayList heisst. Die Klasse ArrayList enthält also ein normales Array. Wenn ein Element hinzugefügt wird, wird es in dieses Array eingefügt. Wenn das Array nicht gross genug ist, wird ein neues, grösseres Array erstellt, um das alte zu ersetzen, d.h. die Kapazität des Arrays wird fortlaufend angepasst.\nMethodenübersicht 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 /* * Konstruktor: Erstellt eine initial leere Liste */ public ArrayList\u003cE\u003e() /* * Appends the specified element to the end of this list. */ public boolean add(E e) /* * Fügt das angegebene Element an der angegebenen Position in diese Liste ein. */ public void add(int index,E element) /* * Entfernt alle Elemente aus dieser Liste. */ public void clear() /* * Entfernt das Element an der angegebenen Position in dieser Liste. */ public E remove(int index) /* * Gibt das Element an der angegebenen Position in dieser Liste zurück. */ public E get(int index) /* * Gibt den Index des ersten Auftretens des angegebenen Elements in dieser Liste zurück, * oder -1, wenn diese Liste das Element nicht enthält. */ public int indexOf(Object o) /* * Gibt die Anzahl der Elemente in dieser Liste zurück. */ public int size() /* * Gibt true zurück, wenn diese Liste keine Elemente enthält. */ public boolean isEmpty() /* * Gibt true zurück, wenn diese Liste das angegebene Element enthält. */ public boolean contains(Object o) Beispiel IndexOutOfBoundsException Eine der häufigsten Exceptions, die im Zusammenhang mit Listen auftritt, ist folgende: Es wird versucht, auf ein Element mit einem Index zuzugreifen, wobei der Index grösser als (oder gleich wie) die Länge der Liste ist. Dann wird die IndexOutOfBoundsException geworfen:\n1 2 3 4 5 6 List\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"uno\"); list.add(\"dos\"); list.add(\"tres\"); System.out.println(list.get(3)); Hier wird dann diese Meldung angezeigt:\n1 \"java.lang.IndexOutOfBoundsException: Index 3 out of bounds for length 3\" Der Fehler war hier, dass die Liste 3 Elemente enthielt, und versucht wird, auf das 4. Element (also Index 3) zuzugreifen. Weil das 4. Element in dieser Liste nicht existiert, wird eine Exception geworfen.\nGanz generell wird die IndexOutOfBoundException geworfen, wenn versucht wird, auf einen ungültigen Index innerhalb einer Collection zuzugreifen. Hat eine Liste die Grösse x:\ndann sind die gültigen Indizes, um auf Elemente zuzugreifen 0, 1, 2, …, x-1 und die Indizes x, x+1, x+2, … wären ungültig. Diese Exception kann bei den folgenden Methoden von oben geworfen werden: (Diese Liste hier ist genau so nicht vollständig, wie die oben.)\npublic void add(int index, E element) (beachte das Argument index.) public E remove(int index) public E get(int index) Beispiel Beispiel 1 - ArrayList Im folgenden Beispiel erstellen wir zunächst eine leere ArrayList mit Elementen vom Typ String und wenden einige einfache ArrayList Methoden an und sehen, wie diese funktionieren (Das Hinzufügen von Elementen, das Entfernen von Elementen, …),\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import java.util.ArrayList; import java.util.List; public class Pets { public static void main(String[] args) { // Creating an ArrayList of String List\u003cString\u003e pets = new ArrayList\u003c\u003e(); System.out.println(pets); // Output: [] // Adding new elements to the ArrayList pets.add(\"Cat\"); pets.add(\"Hamster\"); pets.add(\"Dog\"); pets.add(\"Goldfish\"); System.out.println(pets); // Output: [Cat, Hamster, Dog, Goldfish] // Adding an element at a particular index in an ArrayList pets.add(2, \"Guinea pigs\"); System.out.println(pets); // Output: [Cat, Hamster, Guinea pigs, Dog, Goldfish] pets.remove(2); System.out.println(pets); // Output: [Cat, Hamster, Dog, Goldfish] pets.remove(\"Dog\"); System.out.println(pets); // Output: [Cat, Hamster, Goldfish] pets.clear(); System.out.println(pets); // Output: [] } } Beispiel 2 - for-Schleife Dieses Beispiel zeigt auf wie mit einer for-Schleife über die Elemente einer Liste iteriert werden kann.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import java.util.ArrayList; class ListSum { public static void main(String[] args) { ArrayList\u003cInteger\u003e numbers = new ArrayList\u003c\u003e(); numbers.add(1000); numbers.add(2500); numbers.add(3750); numbers.add(625); int listSum = 0; for (Integer e : numbers) { listSum += e; } System.out.println(\"Die Summe der Elemente beträgt \" + listSum); } } Output:\n1 Die Summe der Elemente beträgt 7875 Beispiel 3 - while-Schleife Dieses Beispiel zeigt auf wie mit einer while-Schleife über die Elemente einer Liste iteriert werden kann.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import java.util.Arrays; import java.util.List; public class WhileLoopExample { public static void main(String[] args) { String[] namesArray = { \"Anna\", \"Simon\", \"Jan\", \"Nicole\"}; // convert array to list List\u003cString\u003e namesArrayList = Arrays.asList(namesArray); int i = 0; while (i \u003c namesArrayList.size()) { System.out.println(namesArrayList.get(i)); i++; } } } Output:\n1 2 3 4 Anna Simon Jan Nicole Aufgaben Aufgaben Aufgaben zu Modul #J6 - Java Collections - List\n","categories":"","description":"Eine konkrete Umsetzung einer List: Die ArrayList.\n","excerpt":"Eine konkrete Umsetzung einer List: Die ArrayList.\n","ref":"/de/docs/02_java/10_java-collections/02_array-list/","tags":"","title":"ArrayList"},{"body":"Ziele Ich kann den Begriff Continuous Delivery erklären. Continuous Delivery Continuous Delivery, kurz CD, erweitert das automatische Testing um einen automatiserten Freigabeprozess. Eine neue Version der Anwendung soll also per Knopfdruck (und nach dem erfolgreichen Durchlaufen der CI-Pipeline) jederzeit deployed werden können.\nTheoretisch kann man mit CD also mit einem einzigen Knopfdruck die neue Version der Software auf den Server laden. Dabei spielt es im Prinzip keine Rolle, ob man das täglich, wöchentlich oder nach Lust und Laune tut. Es ist jedoch generell eine gute Idee, regelmässig Deployments durchzuführen. Falls etwas dabei schiefgeht, ist das Problemlöseverfahren meistens einfacher.\n","categories":"","description":"Fortlaufendes Delivery\n","excerpt":"Fortlaufendes Delivery\n","ref":"/docs/08_cicd/02_continuous-delivery/","tags":"","title":"Continuous Delivery"},{"body":"Ziele Ich kann den Begriff Continuous Delivery erklären. Continuous Delivery Continuous Delivery, kurz CD, erweitert das automatische Testing um einen automatiserten Freigabeprozess. Eine neue Version der Anwendung soll also per Knopfdruck (und nach dem erfolgreichen Durchlaufen der CI-Pipeline) jederzeit deployed werden können.\nTheoretisch kann man mit CD also mit einem einzigen Knopfdruck die neue Version der Software auf den Server laden. Dabei spielt es im Prinzip keine Rolle, ob man das täglich, wöchentlich oder nach Lust und Laune tut. Es ist jedoch generell eine gute Idee, regelmässig Deployments durchzuführen. Falls etwas dabei schiefgeht, ist das Problemlöseverfahren meistens einfacher.\n","categories":"","description":"Fortlaufendes Delivery\n","excerpt":"Fortlaufendes Delivery\n","ref":"/de/docs/08_cicd/02_continuous-delivery/","tags":"","title":"Continuous Delivery"},{"body":"Aufgabe 1 - Header-Navigation Erstelle nachfolgende Seite.\nDer Schwerpunkt ist die Navigation im Header: Das Bild und die Links auf der rechten Seite.\nAufgabe 2 - relative Positionierung In Aufgabe 1 hast du eine Seite mit Header und Navigation erstellt.\nAdjustiere dort das Bild oben links.\nAufgabe 3 - Info-Box Erstelle eine HTML-Seite (oder erweitere eine andere so, dass) die ganz unten eine Meldung anzeigt mit einem “OK”-Button.\nInspiriere dich an den nervigen Cookie-Meldungen von anderen Seiten.\nDu kannst die Meldung ganz unten oder in der Mitte des Bildschirms anzeigen.\nWenn du willst, kannst du über alles andere ein “Overlay” schmeissen mit einem Transparenzwert von 50 - 90%, damit der User sich automatisch auf die Meldung fokussiert.\nWenn du willst, kannst du alles andere auch verschwommen darstellen. Hierfür könnte das CSS-Property backdrop-filter interessant sein, siehe https://www.w3schools.com/cssref/css3_pr_backdrop-filter.php.\nErstelle nun eine Cookie-Meldung wie diese (der weisse Teil mit dem roten Button ist die Meldung, der Rest gehört zum Hintergrund):\nAufgabe 4 - Transitionen Erstelle einen Fliesstext. Dort drin soll es bestimmte Elemente haben wie z.B. Links. Diese Elemente befinden sich zwingend im Fliesstext.\nLasse diese Elemente (z.B. Links) vergrössern und gib ihnen z.B. einen Border, wenn sich die Maus darüber befindet. Zusätzlich sollen noch weitere Informationen zum Element angezeigt werden.\nBeispiel: Auf Wikipedia erscheint eine kleine Ansicht, die eine Kurzbeschreibung beinhaltet, wenn du mit der Maus über einen Wikipedia-Link darüberfährst.\nAufgabe 5 - Animationen Hier hattest du ein Beispiel für einen Ladebalken: https://www.w3schools.com/howto/howto_css_loader.asp\nSicherlich kennst du den Ladebalken von Apple. Sieh dir den Cupertino Loading Indicator als GIF hier an: https://flutterawesome.com/a-collection-of-high-fidelity-loading-animations-in-gif-format-with-flutter/\nImplementiere diesen Loading Indicator. Du darfst gerne ein (aber nicht mehrere) Bild benutzen, welches du dann entsprechend animierst.\nAufgabe 6 - Bootstrap Nachfolgend ist eine Beispiel-Seite. Setze diese mit Bootstrap um:\nSchaue dir diese Seite auch auf einem kleineren Bildschirm an, indem du die Fensterbreite deines Browsers veränderst. Du wirst sehen, dass z.B. die einzelnen Abos untereinander erscheinen, wenn die Breite kleiner wird. Berücksichtige dies auch in deinem Code.\nHinweis Solltest du nicht weiterkommen, dann schaue in den Entwickler-Tools ([F12]-Taste) im DOM nach. Da diese Seite auch mit Bootstrap umgesetzt wurde, kannst du nachschauen, welche Bootstrap-Klassen sie verwendet haben.\n","categories":"","description":"Aufgaben zu Modul #F3 - CSS\n","excerpt":"Aufgaben zu Modul #F3 - CSS\n","ref":"/labs/03_web/01_html-css/02_css/","tags":"","title":"CSS - Aufgaben"},{"body":"Aufgabe 1 - Header-Navigation Erstelle nachfolgende Seite.\nDer Schwerpunkt ist die Navigation im Header: Das Bild und die Links auf der rechten Seite.\nAufgabe 2 - relative Positionierung In Aufgabe 1 hast du eine Seite mit Header und Navigation erstellt.\nAdjustiere dort das Bild oben links.\nAufgabe 3 - Info-Box Erstelle eine HTML-Seite (oder erweitere eine andere so, dass) die ganz unten eine Meldung anzeigt mit einem “OK”-Button.\nInspiriere dich an den nervigen Cookie-Meldungen von anderen Seiten.\nDu kannst die Meldung ganz unten oder in der Mitte des Bildschirms anzeigen.\nWenn du willst, kannst du über alles andere ein “Overlay” schmeissen mit einem Transparenzwert von 50 - 90%, damit der User sich automatisch auf die Meldung fokussiert.\nWenn du willst, kannst du alles andere auch verschwommen darstellen. Hierfür könnte das CSS-Property backdrop-filter interessant sein, siehe https://www.w3schools.com/cssref/css3_pr_backdrop-filter.php.\nErstelle nun eine Cookie-Meldung wie diese (der weisse Teil mit dem roten Button ist die Meldung, der Rest gehört zum Hintergrund):\nAufgabe 4 - Transitionen Erstelle einen Fliesstext. Dort drin soll es bestimmte Elemente haben wie z.B. Links. Diese Elemente befinden sich zwingend im Fliesstext.\nLasse diese Elemente (z.B. Links) vergrössern und gib ihnen z.B. einen Border, wenn sich die Maus darüber befindet. Zusätzlich sollen noch weitere Informationen zum Element angezeigt werden.\nBeispiel: Auf Wikipedia erscheint eine kleine Ansicht, die eine Kurzbeschreibung beinhaltet, wenn du mit der Maus über einen Wikipedia-Link darüberfährst.\nAufgabe 5 - Animationen Hier hattest du ein Beispiel für einen Ladebalken: https://www.w3schools.com/howto/howto_css_loader.asp\nSicherlich kennst du den Ladebalken von Apple. Sieh dir den Cupertino Loading Indicator als GIF hier an: https://flutterawesome.com/a-collection-of-high-fidelity-loading-animations-in-gif-format-with-flutter/\nImplementiere diesen Loading Indicator. Du darfst gerne ein (aber nicht mehrere) Bild benutzen, welches du dann entsprechend animierst.\nAufgabe 6 - Bootstrap Nachfolgend ist eine Beispiel-Seite. Setze diese mit Bootstrap um:\nSchaue dir diese Seite auch auf einem kleineren Bildschirm an, indem du die Fensterbreite deines Browsers veränderst. Du wirst sehen, dass z.B. die einzelnen Abos untereinander erscheinen, wenn die Breite kleiner wird. Berücksichtige dies auch in deinem Code.\nHinweis Solltest du nicht weiterkommen, dann schaue in den Entwickler-Tools ([F12]-Taste) im DOM nach. Da diese Seite auch mit Bootstrap umgesetzt wurde, kannst du nachschauen, welche Bootstrap-Klassen sie verwendet haben.\n","categories":"","description":"Aufgaben zu Modul #F3 - CSS\n","excerpt":"Aufgaben zu Modul #F3 - CSS\n","ref":"/de/labs/03_web/01_html-css/02_css/","tags":"","title":"CSS - Aufgaben"},{"body":"Ziele Du kennst die wichtigsten Funktionen von IntelliJ IDEA. Du kannst Projekte in IntelliJ IDEA anlegen, konfigurieren und verwalten. Du kannst Plugins suchen und installieren. Einführung in IntelliJ IDEA Besuche die folgenden Links und lies dir die Inhalte aufmerksam durch:\nNavigation und Suche Benutzeroberfläche Ansicht und Verhalten können je nach IntelliJ-Version, installierten Plugins oder deinen Einstellungen leicht abweichen. Tastenkombinationen (Keymap) IntelliJ bietet viele nützliche Shortcuts, um effizienter zu arbeiten. Du findest die wichtigsten in der offiziellen Referenz:\n👉 IntelliJ IDEA Reference Card (PDF)\nPersonalisierte Keymap Manche Tastenkombinationen funktionieren nur unter bestimmten Bedingungen. Zum Beispiel ist Ctrl + / nur auf Tastaturen mit Nummernblock verfügbar.\nDu kannst deine Shortcuts anpassen:\nÖffne die Einstellungen (Ctrl + Alt + S). Suche nach Keymap. Ändere oder suche Tastenkombinationen. Alternativ kannst du auch eine andere Keymap wie Eclipse oder Visual Studio wählen. Unter Help → Keymap Reference kannst du deine persönliche Keymap als PDF exportieren. Nützliche Tastenkombinationen für den Einstieg Funktion Shortcut Einstellungen öffnen Ctrl + Alt + S Überall suchen 2× Shift Smart Code Completion Ctrl + Alt + Space Code formatieren Ctrl + Alt + L Imports optimieren Ctrl + Alt + O Code generieren (Konstruktor, Getter, Setter usw.) Alt + Insert Code-Snippets mit Kürzeln IntelliJ bietet Kürzel, mit denen du automatisch Code generieren kannst. Nutze Ctrl + J, um alle verfügbaren Kürzel anzuzeigen.\nKürzel Funktion psvm public static void main(...)-Methode sout System.out.println(...) souf Formatierter System.out.printf(...) serr System.err.println(...) fori for-Schleife mit Zähler i foreach foreach-Schleife ifn if (x == null) itli Iteration über eine Liste itit Iteration mit Iterator Neues Projekt anlegen Nutze folgendes offizielles Tutorial für deinen Einstieg: 👉 Dein erstes Java-Projekt erstellen\nFür viele unserer Übungen stellen wir dir ein vorbereitetes Projekt zur Verfügung. Trotzdem lohnt es sich, das Anlegen eines neuen Projekts selbst zu üben – vielleicht willst du ja bald deine eigene Applikation entwickeln. Plugins installieren Plugins erweitern die Funktionalität von IntelliJ IDEA. Du findest sie unter Einstellungen → Plugins im Marktplatz.\nWarum Plugins? Integration mit Git, Application Servern usw. Unterstützung für zusätzliche Sprachen und Frameworks Produktivitätssteigerung durch Live-Vorschau, File Watcher, Shortcuts Lernhilfe durch Übungs-Plugins Empfehlung: Key Promoter X Dieses Plugin zeigt dir bei jeder Mausaktion den entsprechenden Shortcut an – ideal, um effizienter zu arbeiten.\nCode formatieren So formatierst du deinen Code in IntelliJ IDEA:\nWähle den gewünschten Code aus (eine Zeile, ein Block oder alles).\nNutze die Tastenkombination:\nWindows/Linux: Ctrl + Alt + L macOS: Cmd + Option + L Oder über das Kontextmenü: Rechtsklick → Code neu formatieren\nFormatierungsstil anpassen Wenn du den Stil ändern möchtest:\nDatei → Einstellungen (Windows/Linux)\nIntelliJ IDEA → Einstellungen (macOS) Navigiere zu Editor → Code-Stil. Wähle die Sprache (z. B. Java). Passe Einrückungen, Leerzeichen, Klammern usw. an. Speichern mit OK oder Apply. IntelliJ wendet die Regeln künftig bei jeder Formatierung automatisch an.\n","categories":"","description":"IntelliJ IDEA einrichten\n","excerpt":"IntelliJ IDEA einrichten\n","ref":"/docs/99_tools/ide/intellij/02_einrichten/","tags":"","title":"IntelliJ einrichten"},{"body":"","categories":"","description":"Tools zur Code-Entwicklung und Ausführung.\n","excerpt":"Tools zur Code-Entwicklung und Ausführung.\n","ref":"/docs/99_tools/ide/","tags":"","title":"Entwicklungsumgebungen - IDE"},{"body":"Ziele Ich weiss, wie ich eine HTML-Seite erstellen kann. Ich weiss, wie ich meine erstellte HTML-Seite im Browser anschauen kann. Eine HTML-Seite mit formatiertem Text erstellen Wir beginnen ganz unkompliziert und erstellen eine Seite, welchen einen simplen Text darstellt. Dafür musst du zuerst einen Ordner erstellen, in dem du später deine Projekt-Dateien speichern kannst. Anschliessend kannst du diesen Ordner mit der IDE (Integrated Development Environment = Entwicklungsumgebung) deiner Wahl öffnen (hier VS Code). Erstelle nun eine neue HTML-Datei im soeben erstellten Ordner. In VS Code kannst du das z.B. wie folgt machen:\nFülle diese Datei nun mit einem beliebigen Text und speichere deine Änderungen (beispielsweise mit “ctrl” + “s”. Kopiere jetzt den Pfad zu dieser Datei. In VS Code kannst du den Pfad mit einem Rechtsklick auf die Datei kopieren:\nGib diesen Pfad im Browser deiner Wahl ein. Du solltest nun einen unformatierten Text im Browser sehen:\nObwohl du vorher vielleicht Zeilenumbrüche und mehrere Leerschläge hattest, sind diese im Browser nun nicht sichtbar. Willst du deinen Text strukturieren, kannst du den Text mithilfe von HTML-Tags formatieren. Der HTML-Code könnte dann zum Beispiel so aussehen:\n1 2 3 4 5 6 7 \u003ch1\u003eKleiner Witz\u003c/h1\u003e \u003cp\u003e Wie viele Softwareentwickler braucht man, um eine Glühbirne auszuwechseln? \u003c/p\u003e \u003cp\u003eKeinen, das ist ein Hardware-Problem!\u003c/p\u003e Nun hast du eine Seite mit formatiertem Text:\nWas wir hier genau gemacht haben, erfährst du auf der nächsten Seite.\n","categories":"","description":"Modul #F3 - HTML und CSS - Erste HTML-Seite erstellen\n","excerpt":"Modul #F3 - HTML und CSS - Erste HTML-Seite erstellen\n","ref":"/docs/03_web/02_html_css/02_html-first-code/","tags":"","title":"Erste Seite erstellen"},{"body":"Ziele Ich weiss, wie ich eine HTML-Seite erstellen kann. Ich weiss, wie ich meine erstellte HTML-Seite im Browser anschauen kann. Eine HTML-Seite mit formatiertem Text erstellen Wir beginnen ganz unkompliziert und erstellen eine Seite, welchen einen simplen Text darstellt. Dafür musst du zuerst einen Ordner erstellen, in dem du später deine Projekt-Dateien speichern kannst. Anschliessend kannst du diesen Ordner mit der IDE (Integrated Development Environment = Entwicklungsumgebung) deiner Wahl öffnen (hier VS Code). Erstelle nun eine neue HTML-Datei im soeben erstellten Ordner. In VS Code kannst du das z.B. wie folgt machen:\nFülle diese Datei nun mit einem beliebigen Text und speichere deine Änderungen (beispielsweise mit “ctrl” + “s”. Kopiere jetzt den Pfad zu dieser Datei. In VS Code kannst du den Pfad mit einem Rechtsklick auf die Datei kopieren:\nGib diesen Pfad im Browser deiner Wahl ein. Du solltest nun einen unformatierten Text im Browser sehen:\nObwohl du vorher vielleicht Zeilenumbrüche und mehrere Leerschläge hattest, sind diese im Browser nun nicht sichtbar. Willst du deinen Text strukturieren, kannst du den Text mithilfe von HTML-Tags formatieren. Der HTML-Code könnte dann zum Beispiel so aussehen:\n1 2 3 4 5 6 7 \u003ch1\u003eKleiner Witz\u003c/h1\u003e \u003cp\u003e Wie viele Softwareentwickler braucht man, um eine Glühbirne auszuwechseln? \u003c/p\u003e \u003cp\u003eKeinen, das ist ein Hardware-Problem!\u003c/p\u003e Nun hast du eine Seite mit formatiertem Text:\nWas wir hier genau gemacht haben, erfährst du auf der nächsten Seite.\n","categories":"","description":"Modul #F3 - HTML und CSS - Erste HTML-Seite erstellen\n","excerpt":"Modul #F3 - HTML und CSS - Erste HTML-Seite erstellen\n","ref":"/de/docs/03_web/02_html_css/02_html-first-code/","tags":"","title":"Erste Seite erstellen"},{"body":"Gegeben Gegeben ist der folgende String:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 String endOfTheWorld = \"That's great, it starts with an earthquake \" + \"Birds and snakes, and aeroplanes \" + \"And Lenny Bruce is not afraid \" + \"Eye of a hurricane, listen to yourself churn \" + \"World serves its own needs \" + \"Don't mis-serve your own needs \" + \"Speed it up a notch, speed, grunt, no, strength \" + \"The ladder starts to clatter \" + \"With a fear of height, down, height \" + \"Wire in a fire, represent the seven games \" + \"And a government for hire and a combat site \" + \"Left her, wasn't coming in a hurry \" + \"With the Furies breathing down your neck \" + \"Team by team, reporters baffled, trumped, tethered, cropped \" + \"Look at that low plane, fine, then \" + \"Uh oh, overflow, population, common group \" + \"But it'll do, save yourself, serve yourself \" + \"World serves its own needs, listen to your heart bleed \" + \"Tell me with the Rapture and the reverent in the right, right \" + \"You vitriolic, patriotic, slam fight, bright light \" + \"Feeling pretty psyched \" + \"It's the end of the world as we know it \" + \"It's the end of the world as we know it \" + \"It's the end of the world as we know it and I feel fine \" + \"Six o'clock, T.V. hour, don't get caught in foreign tower \" + \"Slash and burn, return, listen to yourself churn \" + \"Lock him in uniform, book burning, bloodletting \" + \"Every motive escalate, automotive incinerate \" + \"Light a candle, light a motive, step down, step down \" + \"Watch your heel crush, crush, uh oh \" + \"This means no fear, cavalier, renegade and steering clear \" + \"A tournament, a tournament, a tournament of lies \" + \"Offer me solutions, offer me alternatives and I decline \" + \"It's the end of the world as we know it (I had some time alone) \" + \"It's the end of the world as we know it (I had some time alone) \" + \"It's the end of the world as we know it and I feel fine (time I had some time alone) \" + \"I feel fine (I feel fine) \" + \"It's the end of the world as we know it (time I had some time alone) \" + \"It's the end of the world as we know it (time I had some time alone) \" + \"It's the end of the world as we know it and I feel fine (time I had some time alone) \" + \"The other night I drifted nice continental drift divide \" + \"Mountains sit in a line, Leonard Bernstein \" + \"Leonid Brezhnev, Lenny Bruce and Lester Bangs \" + \"Birthday party, cheesecake, jellybean, boom \" + \"You symbiotic, patriotic, slam but neck, right, right \" + \"It's the end of the world as we know it (time I had some time alone) \" + \"It's the end of the world as we know it (time I had some time alone) \" + \"It's the end of the world as we know it and I feel fine (time I had some time alone) \" + \"It's the end of the world as we know it \" + \"It's the end of the world as we know it \" + \"It's the end of the world as we know it and I feel fine (time I had some time alone) \" + \"It's the end of the world as we know it (time I had some time alone) \" + \"It's the end of the world as we know it (time I had some time alone) \" + \"It's the end of the world as we know it and I feel fine (time I had some time alone) \" + \"It's the end of the world as we know it (time I had some time alone) \" + \"It's the end of the world as we know it (time I had some time alone) \" + \"It's the end of the world as we know it and I feel fine (time I had some time alone)\"; // Copyright R.E.M. Aufgabe 1 Schreibe eine Methode, welche die Anzahl der Wörter zählt, die mindestens zweimal im Text vorkommen. Entferne zu diesem Zweck zuerst die Sonderzeichen. Die Methode liefert die Anzahl dieser Wörter zurück.\nAufgabe 2 Schreibe eine Methode, welche die Wörter aus dem obigen Text alphabetisch sortiert. Entferne zu diesem Zweck zuerst die Sonderzeichen. Die Methode liefert ein Array mit den sortierten Wörtern zurück.\nDie Verwendung von Arrays.sort() und Collections.sort() ist nicht erlaubt.\nDu kannst allerdings String.compareTo verwenden. Sieh dir zudem diese Visualisierung zu Bubble Sort an. Neben Bubble Sort gibt es noch weitere Sortieralgorithmen, die du anwenden kannst.\nAufgabe 3 Schreibe eine Methode, welche die durchschnittliche Wortlänge berechnet. Entferne zu diesem Zweck zuerst die Sonderzeichen. Die Methode liefert die durchschnittliche Wortlänge als Gleitkommazahl zurück.\nAufgabe 4 Schreibe eine Methode, welche die Wörter aus dem Text nach ihrer Länge sortiert. Kurze Wörter kommen dabei zuerst. Entferne zu diesem Zweck zuerst die Sonderzeichen. Die Methode liefert ein Array mit den sortierten Wörtern zurück.\nAufgabe 5 Schreibe eine Methode, welche das Wort zurückliefert, das im Text oben am häufigsten vorkommt. Entferne zu diesem Zweck zuerst die Sonderzeichen. Die Methode liefert das gesuchte Wort zurück.\nAufgabe 6 Schreibe eine Methode, welche das Vorkommen der einzelnen Buchstaben des Textes mithilfe eines zweidimensionalen Arrays von Strings tabellarisch darstellt. In der ersten Reihe sollen alle einzigartigen im Text vorhandenen Buchstaben stehen. Diese sollen in alphabetischer Reihenfolge sortiert sein. Sonderzeichen sollen auch aufgelistet werden. Stellvertretend für ein Aufkommen soll der Index (Position im Text) unter dem entsprechenden Zeichen aufgelistet werden. Sämtliche Buchstaben sollen immer nur als kleingeschriebene Buchstaben behandelt werden.\nBeispiel:\nString text = “Hallo mein Name ist Claudio”\na c d e h i l m n o s t u 5 1 20 24 7 0 8 2 6 9 4 17 18 23 10 12 14 16 3 13 11 26 15 22 25 21 19 Der Tabelle kann folgendes entnommen werden: Der Buchstabe a befindet sich an den Positionen 1 und 12 im String Hallo mein Name ist Claudio. Das erste Zeichen in der Tabelle ist ein Leerschlag (whitespace).\nUm die Tabelle formattiert auszugeben, kannst du String.format(\"%-10s\", deineZahl) verwenden. Dabei wird der Text immer mit Leerzeichen aufgefüllt und sichergestellt, dass der Text immer 10 Zeichen lang ist, auch wenn die Zahlen unterschiedlich lang sind.\n","categories":"","description":"Einfache Aufgaben mit Strings\n","excerpt":"Einfache Aufgaben mit Strings\n","ref":"/exams/02_java/03_java-grundlagen/02_exam2/","tags":"","title":"Exam Java Grundlagen - Strings"},{"body":"Gegeben Gegeben ist der folgende String:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 String endOfTheWorld = \"That's great, it starts with an earthquake \" + \"Birds and snakes, and aeroplanes \" + \"And Lenny Bruce is not afraid \" + \"Eye of a hurricane, listen to yourself churn \" + \"World serves its own needs \" + \"Don't mis-serve your own needs \" + \"Speed it up a notch, speed, grunt, no, strength \" + \"The ladder starts to clatter \" + \"With a fear of height, down, height \" + \"Wire in a fire, represent the seven games \" + \"And a government for hire and a combat site \" + \"Left her, wasn't coming in a hurry \" + \"With the Furies breathing down your neck \" + \"Team by team, reporters baffled, trumped, tethered, cropped \" + \"Look at that low plane, fine, then \" + \"Uh oh, overflow, population, common group \" + \"But it'll do, save yourself, serve yourself \" + \"World serves its own needs, listen to your heart bleed \" + \"Tell me with the Rapture and the reverent in the right, right \" + \"You vitriolic, patriotic, slam fight, bright light \" + \"Feeling pretty psyched \" + \"It's the end of the world as we know it \" + \"It's the end of the world as we know it \" + \"It's the end of the world as we know it and I feel fine \" + \"Six o'clock, T.V. hour, don't get caught in foreign tower \" + \"Slash and burn, return, listen to yourself churn \" + \"Lock him in uniform, book burning, bloodletting \" + \"Every motive escalate, automotive incinerate \" + \"Light a candle, light a motive, step down, step down \" + \"Watch your heel crush, crush, uh oh \" + \"This means no fear, cavalier, renegade and steering clear \" + \"A tournament, a tournament, a tournament of lies \" + \"Offer me solutions, offer me alternatives and I decline \" + \"It's the end of the world as we know it (I had some time alone) \" + \"It's the end of the world as we know it (I had some time alone) \" + \"It's the end of the world as we know it and I feel fine (time I had some time alone) \" + \"I feel fine (I feel fine) \" + \"It's the end of the world as we know it (time I had some time alone) \" + \"It's the end of the world as we know it (time I had some time alone) \" + \"It's the end of the world as we know it and I feel fine (time I had some time alone) \" + \"The other night I drifted nice continental drift divide \" + \"Mountains sit in a line, Leonard Bernstein \" + \"Leonid Brezhnev, Lenny Bruce and Lester Bangs \" + \"Birthday party, cheesecake, jellybean, boom \" + \"You symbiotic, patriotic, slam but neck, right, right \" + \"It's the end of the world as we know it (time I had some time alone) \" + \"It's the end of the world as we know it (time I had some time alone) \" + \"It's the end of the world as we know it and I feel fine (time I had some time alone) \" + \"It's the end of the world as we know it \" + \"It's the end of the world as we know it \" + \"It's the end of the world as we know it and I feel fine (time I had some time alone) \" + \"It's the end of the world as we know it (time I had some time alone) \" + \"It's the end of the world as we know it (time I had some time alone) \" + \"It's the end of the world as we know it and I feel fine (time I had some time alone) \" + \"It's the end of the world as we know it (time I had some time alone) \" + \"It's the end of the world as we know it (time I had some time alone) \" + \"It's the end of the world as we know it and I feel fine (time I had some time alone)\"; // Copyright R.E.M. Aufgabe 1 Schreibe eine Methode, welche die Anzahl der Wörter zählt, die mindestens zweimal im Text vorkommen. Entferne zu diesem Zweck zuerst die Sonderzeichen. Die Methode liefert die Anzahl dieser Wörter zurück.\nAufgabe 2 Schreibe eine Methode, welche die Wörter aus dem obigen Text alphabetisch sortiert. Entferne zu diesem Zweck zuerst die Sonderzeichen. Die Methode liefert ein Array mit den sortierten Wörtern zurück.\nDie Verwendung von Arrays.sort() und Collections.sort() ist nicht erlaubt.\nDu kannst allerdings String.compareTo verwenden. Sieh dir zudem diese Visualisierung zu Bubble Sort an. Neben Bubble Sort gibt es noch weitere Sortieralgorithmen, die du anwenden kannst.\nAufgabe 3 Schreibe eine Methode, welche die durchschnittliche Wortlänge berechnet. Entferne zu diesem Zweck zuerst die Sonderzeichen. Die Methode liefert die durchschnittliche Wortlänge als Gleitkommazahl zurück.\nAufgabe 4 Schreibe eine Methode, welche die Wörter aus dem Text nach ihrer Länge sortiert. Kurze Wörter kommen dabei zuerst. Entferne zu diesem Zweck zuerst die Sonderzeichen. Die Methode liefert ein Array mit den sortierten Wörtern zurück.\nAufgabe 5 Schreibe eine Methode, welche das Wort zurückliefert, das im Text oben am häufigsten vorkommt. Entferne zu diesem Zweck zuerst die Sonderzeichen. Die Methode liefert das gesuchte Wort zurück.\nAufgabe 6 Schreibe eine Methode, welche das Vorkommen der einzelnen Buchstaben des Textes mithilfe eines zweidimensionalen Arrays von Strings tabellarisch darstellt. In der ersten Reihe sollen alle einzigartigen im Text vorhandenen Buchstaben stehen. Diese sollen in alphabetischer Reihenfolge sortiert sein. Sonderzeichen sollen auch aufgelistet werden. Stellvertretend für ein Aufkommen soll der Index (Position im Text) unter dem entsprechenden Zeichen aufgelistet werden. Sämtliche Buchstaben sollen immer nur als kleingeschriebene Buchstaben behandelt werden.\nBeispiel:\nString text = “Hallo mein Name ist Claudio”\na c d e h i l m n o s t u 5 1 20 24 7 0 8 2 6 9 4 17 18 23 10 12 14 16 3 13 11 26 15 22 25 21 19 Der Tabelle kann folgendes entnommen werden: Der Buchstabe a befindet sich an den Positionen 1 und 12 im String Hallo mein Name ist Claudio. Das erste Zeichen in der Tabelle ist ein Leerschlag (whitespace).\nUm die Tabelle formattiert auszugeben, kannst du String.format(\"%-10s\", deineZahl) verwenden. Dabei wird der Text immer mit Leerzeichen aufgefüllt und sichergestellt, dass der Text immer 10 Zeichen lang ist, auch wenn die Zahlen unterschiedlich lang sind.\n","categories":"","description":"Einfache Aufgaben mit Strings\n","excerpt":"Einfache Aufgaben mit Strings\n","ref":"/de/exams/02_java/03_java-grundlagen/02_exam2/","tags":"","title":"Exam Java Grundlagen - Strings"},{"body":"","categories":"","description":"Labs zu [Git Vertiefung](../../../docs/04_git/02_vertiefung/02_zusammenarbeit)\n","excerpt":"Labs zu [Git …","ref":"/labs/04_git/02_vertiefung/","tags":"","title":"Git Vertiefung Labs"},{"body":"","categories":"","description":"Labs zu [Git Vertiefung](../../../docs/04_git/02_vertiefung/02_zusammenarbeit)\n","excerpt":"Labs zu [Git …","ref":"/de/labs/04_git/02_vertiefung/","tags":"","title":"Git Vertiefung Labs"},{"body":"","categories":"","description":"In diesen Übungen kannst du die grundlegenden Themen zu Java vertiefen.\n","excerpt":"In diesen Übungen kannst du die grundlegenden Themen zu Java …","ref":"/labs/02_java/03_java-grundlagen/","tags":"","title":"Java Exercises - Grundlagen"},{"body":"Inhalt Git unter Linux installieren Git unter Windows installieren Ziele Ich weiss, wie ich Git in meinem Betriebssystem installiere. Überprüfe die Installation Verwende den folgenden Befehl, um zu überprüfen, ob git bereits installiert ist:\n1 git --version Git unter Linux installieren Debian basierte Linux (Ubuntu): sudo apt install git Redhat basierte Linux (Fedora, Rocky Linux): sudo dnf install git Überprüfe die Installation mit git --version.\nGit unter Windows installieren Navigiere zum Git für Windows Installer und lade die neuste Version herunter. Folge den Installationsanweisungen bis die Installation abgeschlossen ist. Es wird empfohlen während der Installation Git Bash zu installieren Es wird empfohlen während der Installation den PATH zu ändern. Öffne Git Bash Schreibe git --version zum Überprüfen, ob Git erfolgreich installiert wurde. ","categories":"","description":"","excerpt":"Inhalt Git unter Linux installieren Git unter Windows installieren …","ref":"/docs/04_git/01_grundwissen/02_git-install/","tags":"","title":"Install Git"},{"body":"Inhalt Git unter Linux installieren Git unter Windows installieren Ziele Ich weiss, wie ich Git in meinem Betriebssystem installiere. Überprüfe die Installation Verwende den folgenden Befehl, um zu überprüfen, ob git bereits installiert ist:\n1 git --version Git unter Linux installieren Debian basierte Linux (Ubuntu): sudo apt install git Redhat basierte Linux (Fedora, Rocky Linux): sudo dnf install git Überprüfe die Installation mit git --version.\nGit unter Windows installieren Navigiere zum Git für Windows Installer und lade die neuste Version herunter. Folge den Installationsanweisungen bis die Installation abgeschlossen ist. Es wird empfohlen während der Installation Git Bash zu installieren Es wird empfohlen während der Installation den PATH zu ändern. Öffne Git Bash Schreibe git --version zum Überprüfen, ob Git erfolgreich installiert wurde. ","categories":"","description":"","excerpt":"Inhalt Git unter Linux installieren Git unter Windows installieren …","ref":"/de/docs/04_git/01_grundwissen/02_git-install/","tags":"","title":"Install Git"},{"body":" Noch nicht sicher, was Debugging genau ist oder wann man es verwendet? Schau dir zuerst das Modul Debugging – Fehler finden und verstehen an. Ziele Du kannst in IntelliJ Breakpoints setzen und konfigurieren. Du verstehst die wichtigsten Funktionen des Debuggers. Du kannst den Zustand deines Programms gezielt analysieren. Breakpoints setzen Linksklick auf die Zeilennummer: Standard-Breakpoint Rechtsklick für erweiterte Optionen wie Conditional Breakpoints Erweiterte Breakpoint-Einstellungen Bedingung festlegen Nur einmal auslösen Log-Nachricht statt Pause Nur aktiv, wenn ein anderer Breakpoint vorher ausgelöst wurde Debug starten Klicke oben rechts auf das Käfer-Symbol, um im Debug-Modus zu starten:\nDebugger-Panel Hier findest du alle wichtigen Bereiche:\nDebugger Controls (Steuerung) Variables (aktuelle Werte) Frames (Call Stack) Watches (beobachtete Variablen) Console (Fehlermeldungen, Ausgaben) Controls (oben links) ▶ Resume: weiterlaufen lassen ⏯ Step Over: nächste Zeile 🔽 Step Into: in Methode springen 🔼 Step Out: aus Methode raus ⏹ Stop: Debug beenden ♻ Rerun: neu starten 🔕 Mute Breakpoints: pausiert alle Breakpoints Watches \u0026 Variables Variablen und eigene Ausdrücke überwachen:\nRechtsklick → „Add to Watches“ Oder ins Watch-Feld schreiben Weitere Infos 👉 Offizielle JetBrains Doku zu Debugging\n","categories":"","description":"Lerne, wie du mit IntelliJ effizient Java-Code debuggen kannst – mit Breakpoints, Watches und anderen Tools.\n","excerpt":"Lerne, wie du mit IntelliJ effizient Java-Code debuggen kannst – mit …","ref":"/docs/99_tools/ide/intellij/06_debugging/","tags":"","title":"Debugging in IntelliJ"},{"body":"Ziele Ich kenne die wichtigsten Funktionen der IntelliJ IDEA Ich kann Projekte innerhalb IntelliJ IDEA neu anlegen, konfigurieren und verwalten Ich kann IntelliJ IDEA zusammen mit einem GIT-Repository verwenden Ich kann Plugins suchen und installieren Ich verstehe das Grundprinzip von Debugging Einführung in IntelliJ IDEA Besuche die folgenden Links und lies die Informationen durch:\nNavigation und Suche Benutzer Interface Die Ansicht und/oder das Verhalten kann abhängig von den installierten Plugins, der IntelliJ IDEA Version oder den Benutzereinstellungen variieren.\nDefault Keymap IntelliJ verfügt über diverse Tastenkombinationen, um die Produktivität zu erhöhen. Im unten stehenden PDF findest du die standardmässig eingestellten Tastenkombinationen. IntelliJ IDEA Reference Card\nPersonalisierte Keymap Es kann vorkommen, dass einige Tastenkombinationen nicht ausführbar sind, als Beispiel ist die Kombination Ctrl + / nur ausführbar, wenn die Tastatur über einen Nummernblock verfügt. Um die Tastenkombinationen deinen Bedürfnissen anzupassen, kannst du in den Einstellungen im IntelliJ nach Keymap und der entsprechenden Funktion suchen und diese anpassen. Zusätzlich bietet IntelliJ IDEA diverse Keymaps an, welche sich z.B. an den Tastenkombinationen von Eclipse oder Visual Studio orientieren und die Umstellung erleichtern sollen.\nFalls Du die Tastenkombinationen deinen Bedürfnissen angepasst hast, kannst du dir deine personalisierte Keymap als PDF von IntelliJ IDEA erstellen lassen unter Help → Keymap Reference.\nWichtige Kombinationen für den Anfang Funktion Shortcut Einstellungen öffnen Ctrl + Alt + S Überall suchen 2x Shift Smart Code Completion Ctr + Alt + Space Code formatieren Ctrl + Alt + L Imports optimieren Ctrl + Alt + O Generiere Code (Constructor, Getter, Setter, etc.) Alt + Insert Wichtige Kombinationen zur Code-Generierung IntelliJ bietet nicht nur Tastenkombinationen, um die Produktivität zu verbessern, sondern auch vordefinierte Wörter, Kürzel oder Buchstaben, welche automatisch Code generieren. Mit der Tastenkombination Ctrl + J kannst du diese anzeigen lassen.\nCode Shortcut eine main()-Methode psvm eine forEach-Schleife foreach eine for-Schleife mit “i” als Zähler fori einen if == null check ifn eine Iteration (while-Schleife) über einen Iterator itit eine Iteration (for-Schleife) über eine Liste itli eine print()-Methode, welche einen Error auf der Konsole ausgibt serr eine print()-Methode sout eine formatierte print()-Methode souf Neues Projekt anlegen Um einen ersten Einblick in die Erstellung eines neuen Projektes zu erhalten kann das folgende Tutorial von IntelliJ IDEA absolviert werden: https://www.jetbrains.com/help/idea/creating-and-running-your-first-java-application.html\nInstallation von Plugins Plugins erweitern die Kernfunktionalität von IntelliJ IDEA.\nPlugins ermöglichen die Integration mit Versionskontrollsystemen, Anwendungsservern und anderen externen Applikationen Plugins fügen Unterstützung bei der Kodierungshilfe für verschiedene Sprachen und Frameworks hinzu Plugins steigern die Produktivität mit Shortcut-Hinweisen, Live-Vorschauen, File Watchers etc. Plugins helfen dir beim Erlernen einer neuen Programmiersprache mit Programmierübungen und Verifizierung Plugins müssen über den Marktplatz von IntelliJ installiert werden. Dieser ist über die Einstellungen unter Plugins verfügbar. Dort können Plugins gesucht und über einen Klick auf Install einfach und unkompliziert installiert werden.\nHilfreiche Plugins für den Anfang Ein sehr hilfreiches Plugin ist der “Key Promoter X”. Dieses Plugin ermöglicht das Erlernen der IntelliJ IDEA Tastenkombinationen. Jede verfügbare Tastenkombinationen wird dir bei Verwendung eines Menüs oder Kontextmenüs angezeigt.\nCode-Formatierung Um den Code in IntelliJ IDEA zu formatieren, können die integrierten Funktionen für Codeformatierung verwendet werden. So kann der Code formatiert werden:\nDen Code auswählen, welcher zu formatieren ist. Es kann sich um eine einzelne Zeile, einen Codeblock oder die gesamte Datei handeln.\nDie entsprechende Tastenkombination basierend auf deinem Betriebssystem drücken:\nWindows/Linux: Strg + Alt + L macOS: Cmd + Option + L\nAlternativ kann mit der rechten Maustaste auf den ausgewählten Code geklickt und “Code neu formatieren” im Kontextmenü ausgewählt werden.\nIntelliJ IDEA wird den ausgewählten Code automatisch gemäss den konfigurierten Codeformatierungseinstellungen formatieren. Wenn die Codeformatierungseinstellungen in IntelliJ noch nicht konfiguriert wurden, kann das je nach den entsprechend Vorlieben angepasst werden. So kann man die Codeformatierung konfigurieren:\nZu “Datei” \u003e “Einstellungen” (Windows/Linux) oder “IntelliJ IDEA” \u003e “Einstellungen” (macOS) gehen.\nIn dem Einstellungsfenster zu “Editor” \u003e “Code-Stil” navigieren.\nDie gewünschte Programmiersprache auswählen, für die der Code-Stil konfiguriert werden möchte (z.B. Java, JavaScript usw.).\nDie Codeformatierungseinstellungen nach den Vorlieben anpassen. Man kann Einrückung, Abstände, Platzierung der Klammern und viele andere Formatierungsoptionen festlegen.\nAuf “Übernehmen” oder “OK” klicken, um die Änderungen zu speichern.\nNachdem der Code-Stil konfiguriert wurde, wird IntelliJ die definierten Formatierungsregeln anwenden, wenn die Tastenkombination für die Codeformatierung verwendet wird oder “Code neu formatieren” im Kontextmenü ausgewählt wird.\n","categories":"","description":"Modul - IntelliJ IDEA einrichten\n","excerpt":"Modul - IntelliJ IDEA einrichten\n","ref":"/de/docs/02_java/02_intellij-einrichten/","tags":"","title":"IntelliJ IDEA einrichten"},{"body":" Dieses Kapitel gehört zum Modul #Java des Ausbildungsplans Voraussetzungen Grundlegende Computerkenntnisse (z. B. Datei öffnen/speichern) Motivation, Neues zu lernen Neugier – und etwas Geduld 😉 Übersicht Hier lernst du die Programmiersprache Java – von Grund auf. Dieses Modul ist der perfekte Einstieg ins Programmieren.\nDu startest mit den Grundlagen wie Variablen, Kontrollstrukturen und Methoden. Danach lernst du:\nObjektorientierte Programmierung (OOP) Datenstrukturen wie Listen und Streams Konzeptuelles Design und sauberes Modellieren Tools wie Maven und Unit-Testing Richte möglichst früh deine Entwicklungsumgebung ein – du wirst sie für die Übungen benötigen.\nAnleitung: !*IntelliJ IDEA installieren\nAchtung: Installiere nur IntelliJ IDEA. Die anderen Module kannst du vorerst ignorieren.\nDer Inhalt ist praxisnah aufgebaut – mit Übungen, Beispielprojekten und kleinen Challenges. Fast jedes Thema ist mit konkreten Aufgaben verknüpft, die du direkt ausprobieren kannst.\nViele der späteren Module bauen auf diesem Wissen auf – je sicherer du hier bist, desto einfacher wird dein weiterer Weg in der Softwareentwicklung. Aufbau des Moduls Das Modul ist in kleine, leicht verständliche Teile unterteilt:\nProgramaufbau und Ausgabe auf die Konsole Variablen und Primitive Datentypen Kontrollstrukturen (if, while, for) Mathematische und Logische Operationen Referenztypen Strings (Texte) Methoden und Wiederverwendung Scanner für Dateneingabe Arrays (Liste mit gleichen Elementen) Fehler finden (debuggen) Zu jedem Kapitel gibt es passende Übungen – meist direkt als IntelliJ-Projekt mit automatisierter Auswertung.\nWarum Java? Java ist eine bewährte und weit verbreitete Sprache, die in vielen Bereichen der Softwareentwicklung zum Einsatz kommt:\nPlattformunabhängig: Einmal geschrieben, überall lauffähig (JVM). Weit verbreitet in Unternehmen, Schulen und bei Behörden. Stark typisiert: Fehler können früh erkannt werden. Gute Basis für das Verständnis von objektorientierter Programmierung. Wenn du mehr über Programmiersprachen im allgemeinen erfahren willst, schau dir das Modul !*Programmiersprachen an. Es wird dir helfen, besser zu verstehen, warum gewisse Sachen in Java entsprechend umgesetzt wurden. Terminologie (zum Nachschlagen) Begriff Beschreibung Programm Eine Folge von Anweisungen, die ein Computer ausführen kann Anweisung (statement) Ein einzelner Befehl, z. B. eine Ausgabe auf der Konsole Block Mehrere Anweisungen, zusammengefasst mit {} Methode Eine benannte Gruppe von Anweisungen mit Wiederverwendbarkeit Syntax Grammatikregeln der Sprache Keyword Reserviertes Wort in Java (z. B. public, class) Bezeichner (identifier) Namen für Variablen, Methoden etc. Kommentar Beschreibungen im Code, die vom Compiler ignoriert werden Whitespace Leerzeichen und Einrückungen für bessere Lesbarkeit ","categories":"","description":"Grundlagen der Programmiersprache Java\n","excerpt":"Grundlagen der Programmiersprache Java\n","ref":"/docs/02_java/","tags":"","title":"Java"},{"body":"Inhalt Dieser Bereich ermöglicht dir das Erlernen der Java-Programmiersprache von Grund auf. Nach der Einrichtung der Entwicklungsumgebung lernst du die Basics von Java kennen. Die objektorienterte Programmierung bringt dich tiefer in die Möglichkeiten von Java hinein. Das Arbeiten mit Listen und Streams vereinfacht dir die Übungen der objektorientierten Programmierung. Das objektorientierte Design erlaubt dir die reale Welt innerhalb von Java besser abzubilden. Mit Maven lernst du ein mächtiges Build-Management Tool kennen. Das Schreiben von automatisierten Tests erlaubt dir deine Applikationen zu testen.\n","categories":"","description":"Grundlagen von Java\n","excerpt":"Grundlagen von Java\n","ref":"/de/docs/02_java/","tags":"","title":"Java"},{"body":"","categories":"","description":"Übungen zu Java\n","excerpt":"Übungen zu Java\n","ref":"/labs/02_java/","tags":"","title":"Java Labs"},{"body":"","categories":"","description":"Labs zu Java\n","excerpt":"Labs zu Java\n","ref":"/de/labs/02_java/","tags":"","title":"Java Labs"},{"body":"Diese Richtlinien helfen dir, Java-Code lesbar, konsistent und wartbar zu schreiben. Sie orientieren sich an den Erfahrungen der IT-Ninjas und enthalten ausgewählte Empfehlungen aus dem Google Java Style Guide.\nKläre im Projekt oder Unternehmen, ob eigene Coding Guidelines gelten. Motivation Guter Code ist Teamkommunikation. Klare Struktur, konsistente Formatierung und verständliche Namen helfen dir – und allen, die deinen Code warten oder erweitern müssen.\nVergleiche selbst dieses Beispiel:\n1 public class W{double c(double[]p,double s){double t=0;for(double x:p)t+=x;return t*(1-s);}} Ist dieser Code leicht verständlich?\nHier dasselbe, nach den Java Coding Guidelines von IT-Ninjas:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class ShoppingCart { /** * Calculates the total amount after applying a discount. * * @param prices Array of item prices * @param discount Discount as a decimal (e.g. 0.05 for 5%) * @return Total amount after discount */ public double calculateTotalWithDiscount(double[] prices, double discount) { double total = 0.0; for (double price : prices) { total += price; } return total * (1 - discount); } } Der Unterschied ist klar:\nDie Namen machen deutlich, was der Code tut. Strukturierte Formatierung verbessert die Lesbarkeit. Dokumentation erklärt die Schnittstelle. Sprache Verwende durchgehend Englisch im Code, in Kommentaren und in der Dokumentation – besonders in internationalen Projekten. Alternativ ist auch Deutsch erlaubt, jedoch kein Sprachmix. Fachbegriffe dürfen verwendet werden, wenn sie gängig und verständlich sind (z. B. interface).\nEinrückung und Formatierung Verwende 4 Leerzeichen, keine Tabs. { steht in derselben Zeile wie die Anweisung. Annotations (z. B. @Override) stehen immer in eigener Zeile. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Bad: public int badMethode() { int a=3;int b=4;return a+b; } // Better: public int betterMethode() { int a=3; int b=4; return a+b; } // Annotations: @Override public String toString() { return \"example\"; } Zeilenlänge und Umbrüche Empfohlene maximale Zeilenlänge: 120 Zeichen Lange Ausdrücke umschlagen – Parameter pro Zeile. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // Bad: public String badLongExample(String theFirstParameter, String theSecondParameter, String theThirdParameter, String theFourthParameter, String theFifthParameter) { return \"...\"; } // Better: public String goodLongExample( String firstParameter, String secondParameter, String thirdParameter, String fourthParameter, String fifthParameter ) { return firstParameter + secondParameter + thirdParameter + fourthParameter + fifthParameter; } Benennungsregeln Element Stil Beispiel Klassen PascalCase CustomerAccount Methoden camelCase getUserName() Variablen camelCase maxRetries Konstanten UPPER_SNAKE MAX_CONNECTIONS Pakete lower.case com.company.project.module Konstanten Vermeide “magische Zahlen” oder Strings. Verwende benannte Konstanten mit sinnvollen Namen.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // Bad: public static int D(int x) { if (x != 0) { return -3; } int a = 2; int b = 5; return a + b; } // Good: private static final int STATUS_ERROR = -3; private static final int STATUS_OK = 0; private static final int WEEKEND_DAYS = 2; private static final int WORKING_DAYS = 5; public static int getWeekdaysOnSuccess(int status) { if (status != STATUS_OK) { return STATUS_ERROR; } int weekendDays = WEEKEND_DAYS; int workingDays = WORKING_DAYS; int weekDays = weekendDays + workingDays; return weekDays; } Kommentare Inline-Kommentare Nur wenn nötig – guter Code erklärt sich selbst. Meist eigene Zeile vor dem Code. Nur bei sehr kurzen Hinweisen: am Zeilenende. 1 2 3 4 5 6 7 8 9 10 11 // Bad: int counter = 0; // set counter to zero to start counting from zero ← useless and long // Good: // defensive null check, required by legacy API if (api == null) return 0; int timeout = 5000; // in milliseconds ← Short inline comment ok // Better: int timeoutMs = 5000; JavaDoc Für öffentliche Klassen, Methoden, Konstruktoren und Felder Auch bei protected, wenn sie vererbbar sind Private nur bei komplexem Verhalten Keine JavaDoc für triviale Getter/Setter nötig Tipp: Aussagekräftige Namen reduzieren den Bedarf an JavaDoc.\n1 2 3 4 5 6 7 8 9 10 11 12 13 /** * Returns an Image object that can then be painted on the screen. * * @param url an absolute URL giving the location of the image * @return the image at the specified URL * @throws IOException if the URL is invalid or cannot be read */ public Image getImage(URL url) throws IOException { if(url == null) { throw new IOException(\"Invalid URL\"); } return url.Get(); } JavaDoc-Tags @param – bei mehreren oder komplexen Parametern @return – wenn Methode etwas zurückgibt @throws – bei geworfenen Exceptions Klassenaufbau Reihenfolge innerhalb einer Klasse (nach Google Java Style Guide):\npublic static final Konstanten Statische Felder Instanzvariablen Konstruktoren Öffentliche Methoden Geschützte Methoden Package-private Methoden Private Methoden Statische Methoden Innere Klassen und Enums Fehlerbehandlung Checked Exceptions nur, wenn sinnvoll Fehler sinnvoll loggen, keine Log-Spam Leere catch-Blöcke nur mit Kommentar wie // intentionally empty 1 2 3 4 5 6 7 8 9 try { userService.save(user); } catch (IOException e) { logger.error(\"Failed to save user.\", e); } catch (Exception ignored) { // intentionally empty } Tools Formatter: IntelliJ / Eclipse mit einheitlichem Profil Analyse: Checkstyle, PMD, SpotBugs, Sonar CI/CD: Format- und Lint-Checks im Build-Prozess Vergleich mit anderen Guidelines Übersicht Aspekt IT-Ninjas Spring Format Google Style Oracle/Sun Einrückung 4 Leerzeichen 4 Leerzeichen 2 Leerzeichen 4 Leerzeichen Zeilenlänge max. 120 Zeichen max. 120 Zeichen max. 100 Zeichen max. 80 Zeichen Klammern {} gleiche Zeile gleiche Zeile gleiche Zeile gleiche Zeile Annotations eigene Zeile eigene Zeile eigene Zeile – Leere Blöcke mit Kommentar optionaler Kommentar // intentionally empty – JavaDoc \u0026 Kommentare Aspekt IT-Ninjas Spring Format Google Style Oracle/Sun JavaDoc Pflicht öffentliche APIs empfohlen alle öffentlichen APIs empfohlen JavaDoc-Tags param/return/throws empfohlen verpflichtend empfohlen Benennungen (alle identisch) Element Stil Beispiel Klassen PascalCase MyService Methoden camelCase calculateSum() Variablen camelCase userName Konstanten UPPER_SNAKE MAX_SIZE Pakete lower.case com.example.project Klassenstruktur Reihenfolge (vereinfacht) IT-Ninjas Spring Google Oracle Konstanten → Felder → Konstruktor → Methoden ✅ ✅ ✅ ✅ Tooling Aspekt IT-Ninjas Spring Format Google Style Oracle/Sun Formatter IntelliJ/Eclipse (manuell) spring-javaformat Google Java Format keine Vorgabe Checkstyle optional selten verwendet eigene Checkstyle-Regeln Sun Checkstyle-XML IDE-Integration manuell gut integriert Plugins verfügbar – ","categories":"","description":"Regeln, damit Java-Code gut lesbar und wartbar bleibt.\n","excerpt":"Regeln, damit Java-Code gut lesbar und wartbar bleibt.\n","ref":"/docs/99_tools/zusammenarbeit/guidelines/coding/java/","tags":"","title":"Java Coding Guidelines"},{"body":"Ziele Ich weiss, wie man mit Microsoft Word eine einfache Dokumentation erstellt Ich weiss, wie man ein Deckblatt einfügt Ich weiss, wie man eine Kopf- und Fusszeile einfügt und bearbeitet Ich weiss, wie man Bilder einfügt und bearbeitet Ich weiss, wie man die Formatvorlagen benutzt Ich weiss, wie man ein Inhaltsverzeichnis generieren und aktualisieren kann Deckblatt einfügen Um einen guten Einstieg in eine Dokumentation zu erhalten, kann man ein Deckblatt einfügen. Dies geht ganz simpel über das Register Einfügen und dann die Option Deckblatt auswählen. Dort gibt es einige Vorlagen, welche man aber auch anpassen kann. Es dient als gute Vorlage um wichtige Informationen wie den Autor oder den Titel des Dokuments darzustellen.\nKopf- und Fusszeile In den Kopf- und Fusszeilen werden Texte eingegeben (oder auch Bilder eingefügt), die im gesamten Dokument oder einem gewissen Bereich des Dokuments am oberen oder unteren Seitenrand dargestellt werden. Typische Anwendungen sind zum Beispiel ein Firmenlogo in der Kopfzeile und die Seitenzahl oder der Dateiname in der Fusszeile.\nUm für das Dokument Kopf- und Fusszeile zu erstellen kann man in der Menüleiste auf das Register Einfügen wechseln. Im Abschnitt Kopfzeile oder Fusszeile können wir nun diese einfügen. Word hat schon einige Vorlagen, die wir benutzen können, aber es ist auch möglich eigene Formatvorlagen zu erstellen. Sobald man eine Kopf- oder Fusszeile erstellt hat, wechselt Word automatisch das Register. Nun können wir einige Einstellungen anpassen.\nDie wichtigsten Anpassungen sind folgende:\nSeitenzahl\nUm die Seitenzahl automatisch generieren zu lassen, kann man diese direkt einfügen lassen. Auch dort ist uns Word sehr behilflich und bietet uns einige Vorlagen an.\nOptionen\nIn den meisten Fällen ist die erste Seite eines Dokuments ein Titelblatt. Dort werden die Kopf- und Fusszeilen nicht dargestellt. Um das einzustellen, kann man unter Optionen den Punkt Erste Seite anders auswählen. Damit bekommt die erste Seite eine eigene Kopf- und Fusszeile.\nBilder einfügen Um ein Bild einzufügen, kann man entweder über das Register Einfügen ein Bild über einen Dateipfad einfügen oder man kann das Bild auch direkt in das Dokument kopieren. Das Bild können wir nun bearbeiten. Zum Beispiel können wir es zuschneiden, die Grösse anpassen, eine Formatvorlage hinzufügen oder verschiedene Effekte hinzufügen.\nDamit man in einer Dokumentation die Bilder zusammen mit Text darstellen kann, gibt es für die Bilder Layoutoptionen. Mit diesen Optionen kann man den Textumbruch verändern und somit das Bild in den Text integrieren.\nFormatvorlagen Formatvorlagen vereinheitlichen das Dokument und lassen es professioneller wirken. Diese sind direkt im Register Start zu finden. Die verschiedenen Formatvorlagen kann man anpassen oder auch selbst neue Formatvorlagen erstellen. Um eine Vorlage zu bearbeiten, macht man einfach einen Rechtsklick auf die Vorlage und wählt dort Ändern aus. Nun kann man alle Optionen individuell anpassen.\nInhaltsverzeichnis Um eine Übersicht über das Dokument zu erhalten, kann man ein Inhaltsverzeichnis generieren lassen. Dafür ist unter dem Register Referenzen die Option Inhaltsverzeichnis. Dort finden wir Vorlagen für integrierte Inhaltsverzeichnisse, die von Word selber bearbeitet werden. Wenn wir mit Inhaltsverzeichnissen arbeiten, müssen wir auch mit dem Formatvorlagen für die Titel arbeiten. So können Titel und Untertitel im Inhaltsverzeichnis erkannt und abgebildet werden. Zum Beispiel die Formatvorlage Überschrift 2 wird im Inhaltsverzeichnis eingerückt, da sie als Untertitel verwendet wird.\nNimmt man nach dem Einfügen vom Inhaltsverzeichnis noch weitere Änderungen am Dokument vor, muss man das Verzeichnis aktualisieren. Dafür klickt man einfach auf das Inhaltsverzeichnis im Dokument und kann dann oberhalb vom Verzeichnis auf Inhaltsverzeichnis aktualisieren klicken. Damit werden die Titel und Seitenzahlen aktualisiert.\n","categories":"","description":"Dokumentieren mit Microsoft Word\n","excerpt":"Dokumentieren mit Microsoft Word\n","ref":"/docs/99_tools/documentation/ms-word/","tags":"","title":"Microsoft Word"},{"body":"Eine Wörterbuch-Anwendung bewahrt die Einträge in einer Datenbank. Die Interaktion mit der Datenbank wird durch ein DictionaryRepository umgesetzt.\nEin DictionaryRepository setzt folgendes Interface um:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public interface DictionaryRepository { /** * Die Methode erhält ein Wort und die Definition dazu und speichert diese als Eintrag in der Datenbank * * @Param word das Wort, welche in dem Wörterbuch hinzugefügt werden soll * @Param definition die Definition des Wortes * */ void add(String key, String value); /** * Die Methode aktualisiert die Definition des Wortes in der Wörterbuch-Datenbank * * @Param word das Wort, welche in dem Wörterbuch bereits existiert * @Param definition die aktualisierte Definition des Wortes * */ void update(String key, String value); /** * Die Methode liefert die Definition für das gegebene Wort aus der Wörterbuch-Datenbank zurück. * * @Param word das Wort, dessen Definition gesucht wird * @Return die Definition des Wortes aus der Wörterbuch-Datenbank, falls vorhanden, ansonsten null * */ String getDefinition(String word); } Die Klasse Dictionary beinhaltet die Business-Logik des Wörterbuchs und verwendet ein DictionaryRepository, um die Einträge in der Datenbank zu speichern und zu finden:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 public enum DictionaryStatus { ADDED, UPDATED, INVALID, NOT_FOUND } public class Dictionary { private final DictionaryRepository repository; public Dictionary(DictionaryRepository repository) { this.repository = repository; } /** * Die Methode schreibt eine Definition für ein Wort in der Wörterbuch-Datenbank. * Zuerst wird geschaut, ob das Wort in der Datenbank bereits existiert. * Falls das Wort noch nicht existiert, wird einen neuen Eintrag in der Datenbank erstellt. * Falls das Wort bereits existiert, wird seine Definition aktualisiert. * * @Param word das Wort, welche in dem Wörterbuch hinzugefügt oder aktualisiert werden soll * @Param definition die Definition des Wortes * @Return DictionaryStatus.ADDED falls das Wort neu ist, DictionaryStatus.UPDATED falls das Wort * bereits vorhanden war und DictionaryStatus.INVALID, falls das Wort ein leerer String ist oder Zahlen beinhaltet * */ public DictionaryStatus addOrUpdateWord(String word, String definition) { //TODO gemäss JavaDoc umsetzen } /** * Die Methode sucht nach der Definition des gegebenen Worts. * Falls das Wort existiert, wird die Definition zurückgeliefert und ansonsten einen * Text, welcher darauf hinweist, dass das Wort nicht vorhanden ist. * * @Param word das Wort, dessen Definition gesucht wird * @Return die Definition des Wortes, falls das Wort im Wörterbuch existiert. Ansonsten folgenden Text: * \"Das Wort xxx konnte im Wörterbuch nicht gefunden werden\" (xxx steht als Platzhalter für das gesuchte Wort) * */ public String getDefinition(String word) { //TODO gemäss JavaDoc umsetzen } } Aufgabe Schreibe eine Test-Klasse für Dictionary, welche folgende Tests beinhaltet:\nTests der Methode addOrUpdateWord: Das Wort befindet sich noch nicht in der Datenbank Das Wort befindet sich bereits in der Datenbank Das Wort ist ein leerer String Das Wort beinhaltet Zahlen Tests der Methode getDefinition: Das gesuchte Wort existiert in der Datenbank Das gesuchte Wort existiert nicht in der Datenbank Anforderungen\nSchreibe jeweils einen Test und erweitere den Code dann nur soweit bis der Test grün ist. Wiederhole dies für alle Tests (die bestehende Tests müssen weiterhin funktionieren!). Der Interface DictionaryRepository darf nicht umgesetzt werden. Für die Tests wird ein Mock oder ein Spy aus dem Mockito-Framework verwendet. Jede Test-Methode hat folgendes Namensschema: 1 2 3 public void given_when_then() { ... } Wobei: given die Ausgangslage definiert when ist der Name der Methode, welche getestet wird then ist das Ergebnis, welche erwartet wird Jede Test-Methode prüft, dass alle Methoden eines Mocks/Spy’s welche aufgerufen werden müssen, auch aufgerufen wurden. Jede Test-Methode prüft, dass alle Methoden eines Mocks/Spy’s welche NICHT aufgerufen werden sollen, auch nicht aufgerufen wurden. Hier kannst du zurück zur Theorie.\n","categories":"","description":"Aufgaben zu Modul #J4 - Testing / Mockito\n","excerpt":"Aufgaben zu Modul #J4 - Testing / Mockito\n","ref":"/labs/02_java/08_java-testing/02_mockito/","tags":"","title":"Mockito - Aufgaben"},{"body":"Eine Wörterbuch-Anwendung bewahrt die Einträge in einer Datenbank. Die Interaktion mit der Datenbank wird durch ein DictionaryRepository umgesetzt.\nEin DictionaryRepository setzt folgendes Interface um:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public interface DictionaryRepository { /** * Die Methode erhält ein Wort und die Definition dazu und speichert diese als Eintrag in der Datenbank * * @Param word das Wort, welche in dem Wörterbuch hinzugefügt werden soll * @Param definition die Definition des Wortes * */ void add(String key, String value); /** * Die Methode aktualisiert die Definition des Wortes in der Wörterbuch-Datenbank * * @Param word das Wort, welche in dem Wörterbuch bereits existiert * @Param definition die aktualisierte Definition des Wortes * */ void update(String key, String value); /** * Die Methode liefert die Definition für das gegebene Wort aus der Wörterbuch-Datenbank zurück. * * @Param word das Wort, dessen Definition gesucht wird * @Return die Definition des Wortes aus der Wörterbuch-Datenbank, falls vorhanden, ansonsten null * */ String getDefinition(String word); } Die Klasse Dictionary beinhaltet die Business-Logik des Wörterbuchs und verwendet ein DictionaryRepository, um die Einträge in der Datenbank zu speichern und zu finden:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 public enum DictionaryStatus { ADDED, UPDATED, INVALID, NOT_FOUND } public class Dictionary { private final DictionaryRepository repository; public Dictionary(DictionaryRepository repository) { this.repository = repository; } /** * Die Methode schreibt eine Definition für ein Wort in der Wörterbuch-Datenbank. * Zuerst wird geschaut, ob das Wort in der Datenbank bereits existiert. * Falls das Wort noch nicht existiert, wird einen neuen Eintrag in der Datenbank erstellt. * Falls das Wort bereits existiert, wird seine Definition aktualisiert. * * @Param word das Wort, welche in dem Wörterbuch hinzugefügt oder aktualisiert werden soll * @Param definition die Definition des Wortes * @Return DictionaryStatus.ADDED falls das Wort neu ist, DictionaryStatus.UPDATED falls das Wort * bereits vorhanden war und DictionaryStatus.INVALID, falls das Wort ein leerer String ist oder Zahlen beinhaltet * */ public DictionaryStatus addOrUpdateWord(String word, String definition) { //TODO gemäss JavaDoc umsetzen } /** * Die Methode sucht nach der Definition des gegebenen Worts. * Falls das Wort existiert, wird die Definition zurückgeliefert und ansonsten einen * Text, welcher darauf hinweist, dass das Wort nicht vorhanden ist. * * @Param word das Wort, dessen Definition gesucht wird * @Return die Definition des Wortes, falls das Wort im Wörterbuch existiert. Ansonsten folgenden Text: * \"Das Wort xxx konnte im Wörterbuch nicht gefunden werden\" (xxx steht als Platzhalter für das gesuchte Wort) * */ public String getDefinition(String word) { //TODO gemäss JavaDoc umsetzen } } Aufgabe Schreibe eine Test-Klasse für Dictionary, welche folgende Tests beinhaltet:\nTests der Methode addOrUpdateWord: Das Wort befindet sich noch nicht in der Datenbank Das Wort befindet sich bereits in der Datenbank Das Wort ist ein leerer String Das Wort beinhaltet Zahlen Tests der Methode getDefinition: Das gesuchte Wort existiert in der Datenbank Das gesuchte Wort existiert nicht in der Datenbank Anforderungen\nSchreibe jeweils einen Test und erweitere den Code dann nur soweit bis der Test grün ist. Wiederhole dies für alle Tests (die bestehende Tests müssen weiterhin funktionieren!). Der Interface DictionaryRepository darf nicht umgesetzt werden. Für die Tests wird ein Mock oder ein Spy aus dem Mockito-Framework verwendet. Jede Test-Methode hat folgendes Namensschema: 1 2 3 public void given_when_then() { ... } Wobei: given die Ausgangslage definiert when ist der Name der Methode, welche getestet wird then ist das Ergebnis, welche erwartet wird Jede Test-Methode prüft, dass alle Methoden eines Mocks/Spy’s welche aufgerufen werden müssen, auch aufgerufen wurden. Jede Test-Methode prüft, dass alle Methoden eines Mocks/Spy’s welche NICHT aufgerufen werden sollen, auch nicht aufgerufen wurden. Hier kannst du zurück zur Theorie.\n","categories":"","description":"Aufgaben zu Modul #J4 - Testing / Mockito\n","excerpt":"Aufgaben zu Modul #J4 - Testing / Mockito\n","ref":"/de/labs/02_java/08_java-testing/02_mockito/","tags":"","title":"Mockito - Aufgaben"},{"body":"Hogwarts Sorting Hat System Hogwarts ist bekanntlich die beste Schule für Hexerei und Zauberei. Alle Hogwarts Schüler:innen werden vor Beginn des ersten Schuljahres gemäss ihren Charakter-Eigenschaften und Fähigkeiten in einem der vier Hogwarts “Häuser” eingeteilt. Die Einteilung in die Häuser ist die Aufgabe des “sprechenden Hutes” (engl. “Sorting Hat”).\nDer sprechende Hut ist mittlerweile mehr als 1000 Jahre alt und soll in den verdienten Ruhestand gehen. Dazu ist die Digitalisierung auch bei Hogwarts endlich angekommen und der Schulmeister möchte dich beauftragen ein Sorting-Hat System zu bauen, welche die Aufgabe des sprechenden Hutes übernimmt und neue Schüler:innen in eines der vier Hogwarts-Häuser aufgrund von bestimmten Kriterien und Eigenschaften einteilt.\nDie Hogwarts Häuser und ihre Eigenschaften/Merkmale Die vier Hogwarts Häuser - Gryffindor, Hufflepuff, Ravenclaw und Slytherin - haben bestimmte Merkmale und Eigenschaften, welche dem sprechenden Hut dabei helfen, die Schüler:innen in das richtige Haus einzuteilen.\nDie folgende Tabelle listet ein paar wichtige Merkmale für jedes Haus auf:\nHaus Wichtigste Charakter-Eigenschaften Hausfarben Haustier Element Gründer:in Anzahl Schüler:innen Gryffindor Tapferkeit, Kühnheit, Courage, Ritterlichkeit, Entschlossenheit Gold, Scharlachrot Löwe Feuer Godric Gryffindor 31 Hufflepuff Fleiss, Hingabe, Geduld, Loyalität, Fairplay Gelb, Schwarz Dachs Erde Helga Hufflepuff 15 Ravenclaw Intelligenz, Wissen, Neugier, Kreativität, geistige Wendigkeit Blau, Bronze Adler Luft Rowena Ravenclaw 33 Slytherin Ehrgeiz, Führerschaft, Selbsterhaltung, List, Einfallsreichtum Smaragdgrün, Silber Schlange Wasser Salazar Slytherin 48 Einteilungsalgorithmus Der sprechende Hut teilt angehende Hogwarts Schüler:innen in eines der vier Hogwarts-Häuser anhand von bestimmten Kriterien ein. Diese Kriterien sind:\nCharakter-Eigenschaften der Person, verglichen mit den Charakter-Eigenschaften, welche dem/der Gründer:in des Hauses wichtig waren Lieblingsfarbe, verglichen mit den Hausfarben Verwandtschaft mit einem ehemaligen Mitglied eines der Häuser Das Wunschhaus der Person, welche eingeteilt werden soll Der/die Schüler:in wird zu jedem Kriterium befragt (mehrere Antworten sind bei den meisten Kriterien möglich!). Die Antworten zu jedem Kriterium werden bewertet, sodass am Schluss für jedes Haus eine Gesamtbewertung vorliegt. Der/die Schüler:in wird in das Haus mit dem höchsten Wert eingeteilt.\nAber vorsicht, es gelten auch folgende Bestimmungen, welche die Auswertung des gewählten Hauses beeinflussen:\nNicht alle Kriterien/Werte werden beim Einteilungsentscheid gleich gewichtet (die Gewichtung wird später erläutert). Wenn zwei Häuser die gleiche Bewertung erhalten, wird das Haus mit der niedrigeren Anzahl Schüler:innen ausgewählt. Das Wunschhaus wird bei der Gesamtbeurteilung manchmal berücksichtigt und manchmal nicht (mehr dazu später) Gewichtung der Kriterien Folgend findest du die Bestimmungen und Gewichtungen, welche bei der Auswertung des passenden Hauses eingehalten werden müssen. Die Gesamtauswertung eines Hauses besteht aus der Summe aller Punkte, welche bei jedem Kriterium für dieses Haus berechnet worden sind.\nCharakter-Eigenschaften Es sind insgesamt 20 Charakter-Eigenschaften möglich (siehe Tabelle der Hogwarts-Häuser hier oben). Der/die Benutzer:in muss mindestens drei Charakter-Eigenschaften auswählen, welche zu ihm/ihr passen.\nPer Haus, hat jede Charakter-Eigenschaft ein Gewicht zwischen 1 und 20. Die wichtigsten Charakter-Eigenschaften eines Hauses erhalten die höchsten Gewichtswerte für dieses Haus. Die anderen Charakter-Eigenschaften bekommen niedrigere Werte. Bei der Auswertung werden für jedes Haus die Gewichtswerte für die eingegebenen Eigenschaften zusammenaddiert.\nFarben In Hogwarts gibt es vier Hausfarben-Paare, also insgesamt acht Hausfarben (siehe Tabelle der Hogwarts-Häuser hier oben). Der/die Benutzer:in gibt seine/ihre Lieblingsfarbe ein. Wenn die Farbe, mit einer Hausfarbe übereinstimmt, erhält dieses Haus zusätzliche 10 Punkte.\nVerwandtschaft Eine Person kann mehrere Verwandte haben, welche in Hogwarts studiert haben und entsprechend einem Haus eingeteilt wurden.\nDie Anzahl Verwandte, welche einem Haus eingeteilt wurden, gibt diesem Haus einen zusätzlichen Wert, welcher der Fakultät dieser Anzahl Verwandten entspricht.\nHinweis: eine Person kann mehrere Verwandte haben, welche in unterschiedliche Häuser eingeteilt worden waren…\nWunschhaus Der/die Benutzer:in kann sein/ihr Wunschhaus eingeben. Das Wunschhaus “schenkt” dem gewählten Haus eine zufällige Anzahl Punkte zwischen 5 und 10 zur Gesamtbeurteilung aber nur wenn der/die Benutzer:in auch eine der Hausfarben dieses Hauses als Lieblingsfarbe ausgewählt hat.\nAnforderungen an das System Verwende viele verschiedene Klassen, um dein System zu modellieren Erzeuge ein gutes Abbild der Aufgabenstellung Die main Methode soll nur zur Interaktion mit dem/der Benutzer:in dienen. Skizziere dein Modell, sodass du es danach auch erklären kannst Teil der Aufgabe ist es, bestimmte Prinzipien kennenzulernen und zu verstehen. Wende entsprechend bei der Umsetzung folgende Prinzipien an: Single Responsibility Principle Immutable Objects Bonus Anforderungen\nWenn sinnvoll, wende Generics an Verwende, wenn möglich, Streams statt Loops Füge ein Einteilungskriterium hinzu Wenn du an der Challenge teilnehmen willst, dann musst du die Aufgabe alleine lösen. Die Lösung vom Pult-Nachbar interessiert uns also nicht.\n","categories":"","description":"Challenge zu Modul #J2\n","excerpt":"Challenge zu Modul #J2\n","ref":"/challenges/java/java-oop/01_oop_challenge/","tags":"","title":"Objektorientierte Programmierung Challenge"},{"body":"Hogwarts Sorting Hat System Hogwarts ist bekanntlich die beste Schule für Hexerei und Zauberei. Alle Hogwarts Schüler:innen werden vor Beginn des ersten Schuljahres gemäss ihren Charakter-Eigenschaften und Fähigkeiten in einem der vier Hogwarts “Häuser” eingeteilt. Die Einteilung in die Häuser ist die Aufgabe des “sprechenden Hutes” (engl. “Sorting Hat”).\nDer sprechende Hut ist mittlerweile mehr als 1000 Jahre alt und soll in den verdienten Ruhestand gehen. Dazu ist die Digitalisierung auch bei Hogwarts endlich angekommen und der Schulmeister möchte dich beauftragen ein Sorting-Hat System zu bauen, welche die Aufgabe des sprechenden Hutes übernimmt und neue Schüler:innen in eines der vier Hogwarts-Häuser aufgrund von bestimmten Kriterien und Eigenschaften einteilt.\nDie Hogwarts Häuser und ihre Eigenschaften/Merkmale Die vier Hogwarts Häuser - Gryffindor, Hufflepuff, Ravenclaw und Slytherin - haben bestimmte Merkmale und Eigenschaften, welche dem sprechenden Hut dabei helfen, die Schüler:innen in das richtige Haus einzuteilen.\nDie folgende Tabelle listet ein paar wichtige Merkmale für jedes Haus auf:\nHaus Wichtigste Charakter-Eigenschaften Hausfarben Haustier Element Gründer:in Anzahl Schüler:innen Gryffindor Tapferkeit, Kühnheit, Courage, Ritterlichkeit, Entschlossenheit Gold, Scharlachrot Löwe Feuer Godric Gryffindor 31 Hufflepuff Fleiss, Hingabe, Geduld, Loyalität, Fairplay Gelb, Schwarz Dachs Erde Helga Hufflepuff 15 Ravenclaw Intelligenz, Wissen, Neugier, Kreativität, geistige Wendigkeit Blau, Bronze Adler Luft Rowena Ravenclaw 33 Slytherin Ehrgeiz, Führerschaft, Selbsterhaltung, List, Einfallsreichtum Smaragdgrün, Silber Schlange Wasser Salazar Slytherin 48 Einteilungsalgorithmus Der sprechende Hut teilt angehende Hogwarts Schüler:innen in eines der vier Hogwarts-Häuser anhand von bestimmten Kriterien ein. Diese Kriterien sind:\nCharakter-Eigenschaften der Person, verglichen mit den Charakter-Eigenschaften, welche dem/der Gründer:in des Hauses wichtig waren Lieblingsfarbe, verglichen mit den Hausfarben Verwandtschaft mit einem ehemaligen Mitglied eines der Häuser Das Wunschhaus der Person, welche eingeteilt werden soll Der/die Schüler:in wird zu jedem Kriterium befragt (mehrere Antworten sind bei den meisten Kriterien möglich!). Die Antworten zu jedem Kriterium werden bewertet, sodass am Schluss für jedes Haus eine Gesamtbewertung vorliegt. Der/die Schüler:in wird in das Haus mit dem höchsten Wert eingeteilt.\nAber vorsicht, es gelten auch folgende Bestimmungen, welche die Auswertung des gewählten Hauses beeinflussen:\nNicht alle Kriterien/Werte werden beim Einteilungsentscheid gleich gewichtet (die Gewichtung wird später erläutert). Wenn zwei Häuser die gleiche Bewertung erhalten, wird das Haus mit der niedrigeren Anzahl Schüler:innen ausgewählt. Das Wunschhaus wird bei der Gesamtbeurteilung manchmal berücksichtigt und manchmal nicht (mehr dazu später) Gewichtung der Kriterien Folgend findest du die Bestimmungen und Gewichtungen, welche bei der Auswertung des passenden Hauses eingehalten werden müssen. Die Gesamtauswertung eines Hauses besteht aus der Summe aller Punkte, welche bei jedem Kriterium für dieses Haus berechnet worden sind.\nCharakter-Eigenschaften Es sind insgesamt 20 Charakter-Eigenschaften möglich (siehe Tabelle der Hogwarts-Häuser hier oben). Der/die Benutzer:in muss mindestens drei Charakter-Eigenschaften auswählen, welche zu ihm/ihr passen.\nPer Haus, hat jede Charakter-Eigenschaft ein Gewicht zwischen 1 und 20. Die wichtigsten Charakter-Eigenschaften eines Hauses erhalten die höchsten Gewichtswerte für dieses Haus. Die anderen Charakter-Eigenschaften bekommen niedrigere Werte. Bei der Auswertung werden für jedes Haus die Gewichtswerte für die eingegebenen Eigenschaften zusammenaddiert.\nFarben In Hogwarts gibt es vier Hausfarben-Paare, also insgesamt acht Hausfarben (siehe Tabelle der Hogwarts-Häuser hier oben). Der/die Benutzer:in gibt seine/ihre Lieblingsfarbe ein. Wenn die Farbe, mit einer Hausfarbe übereinstimmt, erhält dieses Haus zusätzliche 10 Punkte.\nVerwandtschaft Eine Person kann mehrere Verwandte haben, welche in Hogwarts studiert haben und entsprechend einem Haus eingeteilt wurden.\nDie Anzahl Verwandte, welche einem Haus eingeteilt wurden, gibt diesem Haus einen zusätzlichen Wert, welcher der Fakultät dieser Anzahl Verwandten entspricht.\nHinweis: eine Person kann mehrere Verwandte haben, welche in unterschiedliche Häuser eingeteilt worden waren…\nWunschhaus Der/die Benutzer:in kann sein/ihr Wunschhaus eingeben. Das Wunschhaus “schenkt” dem gewählten Haus eine zufällige Anzahl Punkte zwischen 5 und 10 zur Gesamtbeurteilung aber nur wenn der/die Benutzer:in auch eine der Hausfarben dieses Hauses als Lieblingsfarbe ausgewählt hat.\nAnforderungen an das System Verwende viele verschiedene Klassen, um dein System zu modellieren Erzeuge ein gutes Abbild der Aufgabenstellung Die main Methode soll nur zur Interaktion mit dem/der Benutzer:in dienen. Skizziere dein Modell, sodass du es danach auch erklären kannst Teil der Aufgabe ist es, bestimmte Prinzipien kennenzulernen und zu verstehen. Wende entsprechend bei der Umsetzung folgende Prinzipien an: Single Responsibility Principle Immutable Objects Bonus Anforderungen\nWenn sinnvoll, wende Generics an Verwende, wenn möglich, Streams statt Loops Füge ein Einteilungskriterium hinzu Wenn du an der Challenge teilnehmen willst, dann musst du die Aufgabe alleine lösen. Die Lösung vom Pult-Nachbar interessiert uns also nicht.\n","categories":"","description":"Challenge zu Modul #J2\n","excerpt":"Challenge zu Modul #J2\n","ref":"/de/challenges/java/java-oop/01_oop_challenge/","tags":"","title":"Objektorientierte Programmierung Challenge"},{"body":"Ziele Ich kann ohne Hilfsmittel mindestens zwei Vorteile für das Verwenden von Packages nennen. Ich kann ohne Hilfsmittel die Namenkonvention für Java-Packages beschreiben. Ich zeige auf, wie mehrere Klassen vom gleichen Packet mit einem import-Statement importiert werden. Ich kann korrekt und ohne Hilfsmittel erklären, was ein statischer Import ist und wozu er verwendet wird. Ich kann erläutern, warum es keine gute Idee ist, Klassen ohne Package-Anweisung zu schreiben. Packages Bevor wir uns intensiver mit den Bestandteilen einer Klasse auseinandersetzen, schauen wir uns Packages an. Ein Package dient der Gruppierung und Organisation von Klassen, Schnittstellen und anderen Packages. Es wird zwischen zwei Arten von Packages unterschieden:\nimplizit importierte Packages explizit zu importierende Packages Wenn wir beispielsweise die Klasse Scanner benötigen, müssen wir dies durch ein import Statement machen.\n1 import java.util.Scanner Die Klasse Scanner befindet sich also im Package java und darin im Package util. Ein Package kann beliebig viele andere Packages enthalten. Ein Package wird auf dem Dateisystem als Verzeichnis behandelt.\nVorteile Code-Organisation. Klassen von gleicher Natur (wie beispielsweise Modelle oder Services) befinden sich im gleichen Package Auffindbarkeit. Klassen sind durch die Organisation einfacher zu finden Vermeiden von Namenskonflikten. Zwei Klassen dürfen den gleichen Namen haben, solange sie in unterschiedlichen Packages liegen Zugriffsteuerung. Bestimmte Zugriffsmodifikatoren erlauben den Zugriff auf Klassen im gleichen Package Namenskonventionen Gemäss der Namenskonvention werden Package-Namen immer in Kleinbuchstaben geschrieben. Die Trennung der verschiedenen Packages erfolgt beim Import-Statement durch einen Punkt.\nOrdnerstruktur Programmcode muss organisiert sein. Obwohl die Ordnerstruktur nicht vorgegeben ist, hat sich die folgende Konvention in Java-Projekten (vor allem solche, welche Maven im Einsatz haben - dazu mehr im Maven-Modul) etabliert.\nGrundsätzlich legen wir Quellcode im einem Verzeichnis ab, das src genannt wird. Innerhalb dieses Verzeichnisses legen wir ein Verzeichnis main und darin wiederum ein Verzeichnis java an. Innerhalb des Java-Verzeichnisses können wir beliebig viele eigene Packages anlegen, um unseren Programmcode zu organisieren.\nKlassen mit gleichem Namen Es kann passieren, dass wir zwei Klassen haben, die den gleichen Namen haben. Beispiel: Wir arbeiten mit der externen Bibliothek Abstract Window Toolkit (AWT). Darin gibt es eine Klasse mit dem Namen Rectangle. Es ist natürlich erlaubt eine eigene Klasse mit diesem Namen anzulegen, solang sie sich nicht in einem Package mit dem gleichen Namen befindet.\n1 2 3 4 5 6 7 8 9 10 11 12 13 package ch.sbb.main; import ch.sbb.rectangle.Rectangle; public class Main { public static void main(String[] args) { // Deklaration und Initialisierung eines AWT-Rectangles: java.awt.Rectangle rectAWT = new java.awt.Rectangle() // Deklaration und Initialisierung eines Rectangles aus dem Package ch.sbb.rectangle: Rectangle myRect = new Rectangle(); } } Wir importieren die eigene Rectangle-Klasse mit der Import-Anweisung Wir deklarieren und initialisieren ein AWT-Rectangle, indem wir den vollständigen Namen (Package und Klassennamen) angeben Import * Wenn sich zwei Klassen im selben Paket befinden und eine Klasse in der anderen verwendet wird, muss die Klasse nicht importiert werden. Es ist auch möglich, alle Klassen aus dem Paket zu importieren. Dazu müssen wir einen * anstelle eines bestimmten Klassennamens in das Import-Statement schreiben.\n1 import java.awt.*; Alle Klassen eines Packages, wie in diesem Beispiel, zu importieren ist schlechter Style und soll vermieden werden. Es soll immer explizit importiert werden.\nPackage java.lang Obwohl wir die meisten Pakete importieren müssen, gibt es ein Java-Paket, das immer automatisch importiert wird. Es ist java.lang. Dieses Paket enthält viele weit verbreitete Klassen wie String, System, Long, Integer, NullPointerException und andere.\nStatischer Import Wir können auch statische Elemente (wie z.B. Konstanten oder auch statische Methoden) einer Klasse in eine andere Klasse importieren. Wenn wir * in die import-Anweisung schreiben, müssen wir den importierten Klassennamen nicht angeben, bevor wir statische Methoden aufrufen oder statische Felder lesen. Hier ist ein Beispiel für den statischen Import der Klasse Arrays, die viele nützliche Methoden zur Verarbeitung von Arrays enthält:\n1 2 3 4 5 6 7 8 9 10 11 package org.hyperskill.java.packages.theory; import static java.util.Arrays.*; public class Main { public static void main(String[] args) { int[] numbers = { 10, 4, 5, 47, 5, 12 }; // an array sort(numbers); // instead of writing Arrays.sort(...) int[] copy = copyOf(numbers, numbers.length); // instead of writing Arrays.copyOf(...) } } Wenn wir bei der Implementation von Klassen keine Package-Anweisung schreiben, wird die Klasse ins Default-Package eingefügt. Dies sollte vermieden werden, da Klassen aus dem Default-Package nicht in andere Klasse importiert werden können, welche sich nicht auch im Default-Package befinden.\nEigene Packages definieren Packages können auch selber definiert werden. Die Package-Struktur entspricht hierbei der Verzeichnisstruktur des Projekts. Packages erstellt man primär um den Code zu strukturieren.\nIn einem Spring Boot Projekt wird der Code typischerweise in folgende Packages unterteilt:\nController-Package (ch.sbb.demo.controller): Beinhaltet die Controller-Klassen, die HTTP-Anfragen verarbeiten. Service-Package (ch.sbb.demo.service): Enthält die Service-Klassen, die die Geschäftslogik implementieren. Repository-Package (ch.sbb.demo.repository): Beinhaltet die Repository-Klassen für die Datenbankinteraktionen Model-Package (ch.sbb.demo.model): Enthält die Datenmodellklassen (Entities), die die Datenbanktabellen repräsentieren. Ein eigene Package-Struktur zu definieren ist also gar nicht so schwer, im Grunde muss man dafür nur Verzeichnise erstellen.\nWie der Import von eigen definierten Packages erfolgt, ist dem folgenden Beispiel zu entnehmen. Im Beispiel gehen wir von dieser Verzeichnisstruktur aus:\n1 2 3 4 5 /src └── ch └── sbb └── examplepackage └── Beispiel.java Die Ordner ch, sbb examplepackage wurden von Hand erstellt. Das Package enthält die Klasse Beispiel.java.\n1 2 3 4 5 6 7 package ch.sbb.examplepackage; public class Beispiel { public void sagHallo() { System.out.println(\"Hallo, Welt!\"); } } In einer anderen Klasse kann das Package wie zuvor beschrieben importiert und verwendet werden. Ein Beispiel für eine Klasse welche das Package importiert und verwendet könnte wie folgt aussehen:\n1 2 3 4 5 6 7 8 9 10 11 package ch.sbb.main; import ch.sbb.examplepackage.*; public class Main { public static void main(String[] args) { Beispiel b = new Beispiel(); b.sagHallo(); } } ","categories":"","description":"Modul #J2\n","excerpt":"Modul #J2\n","ref":"/docs/02_java/04_java-oop/02_packages/","tags":"","title":"Packages"},{"body":"Ziele Ich kann ohne Hilfsmittel mindestens zwei Vorteile für das Verwenden von Packages nennen. Ich kann ohne Hilfsmittel die Namenkonvention für Java-Packages beschreiben. Ich zeige auf, wie mehrere Klassen vom gleichen Packet mit einem import-Statement importiert werden. Ich kann korrekt und ohne Hilfsmittel erklären, was ein statischer Import ist und wozu er verwendet wird. Ich kann erläutern, warum es keine gute Idee ist, Klassen ohne Package-Anweisung zu schreiben. Packages Bevor wir uns intensiver mit den Bestandteilen einer Klasse auseinandersetzen, schauen wir uns Packages an. Ein Package dient der Gruppierung und Organisation von Klassen, Schnittstellen und anderen Packages. Es wird zwischen zwei Arten von Packages unterschieden:\nimplizit importierte Packages explizit zu importierende Packages Wenn wir beispielsweise die Klasse Scanner benötigen, müssen wir dies durch ein import Statement machen.\n1 import java.util.Scanner Die Klasse Scanner befindet sich also im Package java und darin im Package util. Ein Package kann beliebig viele andere Packages enthalten. Ein Package wird auf dem Dateisystem als Verzeichnis behandelt.\nVorteile Code-Organisation. Klassen von gleicher Natur (wie beispielsweise Modelle oder Services) befinden sich im gleichen Package Auffindbarkeit. Klassen sind durch die Organisation einfacher zu finden Vermeiden von Namenskonflikten. Zwei Klassen dürfen den gleichen Namen haben, solange sie in unterschiedlichen Packages liegen Zugriffsteuerung. Bestimmte Zugriffsmodifikatoren erlauben den Zugriff auf Klassen im gleichen Package Namenskonventionen Gemäss der Namenskonvention werden Package-Namen immer in Kleinbuchstaben geschrieben. Die Trennung der verschiedenen Packages erfolgt beim Import-Statement durch einen Punkt.\nOrdnerstruktur Programmcode muss organisiert sein. Obwohl die Ordnerstruktur nicht vorgegeben ist, hat sich die folgende Konvention in Java-Projekten (vor allem solche, welche Maven im Einsatz haben - dazu mehr im Maven-Modul) etabliert.\nGrundsätzlich legen wir Quellcode im einem Verzeichnis ab, das src genannt wird. Innerhalb dieses Verzeichnisses legen wir ein Verzeichnis main und darin wiederum ein Verzeichnis java an. Innerhalb des Java-Verzeichnisses können wir beliebig viele eigene Packages anlegen, um unseren Programmcode zu organisieren.\nKlassen mit gleichem Namen Es kann passieren, dass wir zwei Klassen haben, die den gleichen Namen haben. Beispiel: Wir arbeiten mit der externen Bibliothek Abstract Window Toolkit (AWT). Darin gibt es eine Klasse mit dem Namen Rectangle. Es ist natürlich erlaubt eine eigene Klasse mit diesem Namen anzulegen, solang sie sich nicht in einem Package mit dem gleichen Namen befindet.\n1 2 3 4 5 6 7 8 9 10 11 12 13 package ch.sbb.main; import ch.sbb.rectangle.Rectangle; public class Main { public static void main(String[] args) { // Deklaration und Initialisierung eines AWT-Rectangles: java.awt.Rectangle rectAWT = new java.awt.Rectangle() // Deklaration und Initialisierung eines Rectangles aus dem Package ch.sbb.rectangle: Rectangle myRect = new Rectangle(); } } Wir importieren die eigene Rectangle-Klasse mit der Import-Anweisung Wir deklarieren und initialisieren ein AWT-Rectangle, indem wir den vollständigen Namen (Package und Klassennamen) angeben Import * Wenn sich zwei Klassen im selben Paket befinden und eine Klasse in der anderen verwendet wird, muss die Klasse nicht importiert werden. Es ist auch möglich, alle Klassen aus dem Paket zu importieren. Dazu müssen wir einen * anstelle eines bestimmten Klassennamens in das Import-Statement schreiben.\n1 import java.awt.*; Alle Klassen eines Packages, wie in diesem Beispiel, zu importieren ist schlechter Style und soll vermieden werden. Es soll immer explizit importiert werden.\nPackage java.lang Obwohl wir die meisten Pakete importieren müssen, gibt es ein Java-Paket, das immer automatisch importiert wird. Es ist java.lang. Dieses Paket enthält viele weit verbreitete Klassen wie String, System, Long, Integer, NullPointerException und andere.\nStatischer Import Wir können auch statische Elemente (wie z.B. Konstanten oder auch statische Methoden) einer Klasse in eine andere Klasse importieren. Wenn wir * in die import-Anweisung schreiben, müssen wir den importierten Klassennamen nicht angeben, bevor wir statische Methoden aufrufen oder statische Felder lesen. Hier ist ein Beispiel für den statischen Import der Klasse Arrays, die viele nützliche Methoden zur Verarbeitung von Arrays enthält:\n1 2 3 4 5 6 7 8 9 10 11 package org.hyperskill.java.packages.theory; import static java.util.Arrays.*; public class Main { public static void main(String[] args) { int[] numbers = { 10, 4, 5, 47, 5, 12 }; // an array sort(numbers); // instead of writing Arrays.sort(...) int[] copy = copyOf(numbers, numbers.length); // instead of writing Arrays.copyOf(...) } } Wenn wir bei der Implementation von Klassen keine Package-Anweisung schreiben, wird die Klasse ins Default-Package eingefügt. Dies sollte vermieden werden, da Klassen aus dem Default-Package nicht in andere Klasse importiert werden können, welche sich nicht auch im Default-Package befinden.\nEigene Packages definieren Packages können auch selber definiert werden. Die Package-Struktur entspricht hierbei der Verzeichnisstruktur des Projekts. Packages erstellt man primär um den Code zu strukturieren.\nIn einem Spring Boot Projekt wird der Code typischerweise in folgende Packages unterteilt:\nController-Package (ch.sbb.demo.controller): Beinhaltet die Controller-Klassen, die HTTP-Anfragen verarbeiten. Service-Package (ch.sbb.demo.service): Enthält die Service-Klassen, die die Geschäftslogik implementieren. Repository-Package (ch.sbb.demo.repository): Beinhaltet die Repository-Klassen für die Datenbankinteraktionen Model-Package (ch.sbb.demo.model): Enthält die Datenmodellklassen (Entities), die die Datenbanktabellen repräsentieren. Ein eigene Package-Struktur zu definieren ist also gar nicht so schwer, im Grunde muss man dafür nur Verzeichnise erstellen.\nWie der Import von eigen definierten Packages erfolgt, ist dem folgenden Beispiel zu entnehmen. Im Beispiel gehen wir von dieser Verzeichnisstruktur aus:\n1 2 3 4 5 /src └── ch └── sbb └── examplepackage └── Beispiel.java Die Ordner ch, sbb examplepackage wurden von Hand erstellt. Das Package enthält die Klasse Beispiel.java.\n1 2 3 4 5 6 7 package ch.sbb.examplepackage; public class Beispiel { public void sagHallo() { System.out.println(\"Hallo, Welt!\"); } } In einer anderen Klasse kann das Package wie zuvor beschrieben importiert und verwendet werden. Ein Beispiel für eine Klasse welche das Package importiert und verwendet könnte wie folgt aussehen:\n1 2 3 4 5 6 7 8 9 10 11 package ch.sbb.main; import ch.sbb.examplepackage.*; public class Main { public static void main(String[] args) { Beispiel b = new Beispiel(); b.sagHallo(); } } ","categories":"","description":"Modul #J2\n","excerpt":"Modul #J2\n","ref":"/de/docs/02_java/04_java-oop/02_packages/","tags":"","title":"Packages"},{"body":"Schreibe eine Anwendung, in welcher Patienten einen medizinischen Check-Up durchgehen, um ihre Daten für das Spital zu erfassen.\nEin Patient\nhat einen Namen hat eine Grösse hat eine Temperatur ist geimpft oder nicht Der Check-Up soll eine Methode auf dem Patienten sein, welche alle aktuellen Werte ausgibt.\nDie Anwendung soll mit einem Patienten einen Check-Up durchführen die Grösse eines Patienten zurückgeben das Gewicht eines Patienten zurückgeben die Temperatur eines Patienten zurückgeben Überprüfen ob der Patient geimpft ist Es sollen keine Set-Methoden für das Einfügen der Werte verwendet werden! Verwende jedoch Get-Methoden für das zurückgeben der Eigenschaften.\nEs soll kein Scanner eingesetzt werden.\nHier kannst du zurück zur Theorie.\n","categories":"","description":"Aufgabe zu Modul #J2 - OOP - Patienten\n","excerpt":"Aufgabe zu Modul #J2 - OOP - Patienten\n","ref":"/labs/02_java/04_java-oop/02_patienten/","tags":"","title":"Patienten"},{"body":"Schreibe eine Anwendung, in welcher Patienten einen medizinischen Check-Up durchgehen, um ihre Daten für das Spital zu erfassen.\nEin Patient\nhat einen Namen hat eine Grösse hat eine Temperatur ist geimpft oder nicht Der Check-Up soll eine Methode auf dem Patienten sein, welche alle aktuellen Werte ausgibt.\nDie Anwendung soll mit einem Patienten einen Check-Up durchführen die Grösse eines Patienten zurückgeben das Gewicht eines Patienten zurückgeben die Temperatur eines Patienten zurückgeben Überprüfen ob der Patient geimpft ist Es sollen keine Set-Methoden für das Einfügen der Werte verwendet werden! Verwende jedoch Get-Methoden für das zurückgeben der Eigenschaften.\nEs soll kein Scanner eingesetzt werden.\nHier kannst du zurück zur Theorie.\n","categories":"","description":"Aufgabe zu Modul #J2 - OOP - Patienten\n","excerpt":"Aufgabe zu Modul #J2 - OOP - Patienten\n","ref":"/de/labs/02_java/04_java-oop/02_patienten/","tags":"","title":"Patienten"},{"body":"Ziele Ich kann anhand von Beispielen erklären, wozu Git verwendet werden kann. Ich richte selbständig ein persönliches Git-Repository gemäss Anleitung korrekt ein. Ich verwalte meine Code-Aufgaben im persönlichen Git-Repository unter Einhaltung der firmeninternen Richtlinien korrekt. Voraussetzungen Du hast Zugriff auf das Git-Tool Bitbucket Git (inkl. Git-Bash) ist auf deinem Computer installiert. Falls das noch nicht geschehen ist, siehe: Install Git Du hast die Grundeinstellungen für Git im Terminal nach der Installation gemacht Folgende Einstellungen sind hier gemeint und können im Git-Bash Terminal ausgeführt werden: 1 2 3 4 5 git config --global user.name \"u123456\" git config --global user.email \"u123456@sbb.ch\" # Für Windows zusätzlich: git config --global core.autocrlf true git config --global core.longpaths true Warum du Git ab heute verwenden wirst Stell dir folgendes Szenario vor: Du arbeitest mit deinem Computer seit mehreren Stunden an deine Hausaufgaben, welche morgen fällig werden. Du speicherst deine Anpassungen immer wieder, damit diese nicht verloren gehen. Plötzlich stürzt dein Computer ab und startet nicht wieder. Zum Glück hast du noch einen alten Laptop, welcher noch funktioniert und mit dem du morgen in die Schule gehen kannst. Nur, was ist mit deinen Hausaufgaben? Die ganze Arbeit ist verloren und du musst wieder von Anfang an beginnen. Grrr….\nWenn du deine Arbeit nicht nur auf deinem Computer, sondern auch irgendwo anders gespeichert hättest (z.B. Dropbox, Google-Drive usw.), wäre es ganz einfach die Arbeit auf deinem Ersatz-Computer von dort aus herunterzuladen und dort weiterzumachen, wo du aufgehört hast.\nUnd hier ein weiteres Szenario: Du arbeitest an einem Computer-Programm. Es funktioniert. Nun musst du etwas Neues in dem Programm einbauen. Du arbeitest ein paar Stunden dran und am Schluss merkst du, dass was bisher einwandfrei funktioniert hat, jetzt gar nicht funktioniert. Du willst die Änderungen rückgängig machen, weisst aber nicht wie der Code vor der Änderungen ausgesehen hat. Grrr….\nWenn du deine ursprüngliche Arbeit als eine Art “Snapshot” irgendwo abgelegt hättest, bevor du mit den Änderungen begonnen hast, so hättest du ganz einfach auf diesen “Snapshot” zurückgreifen können und den alten, funktionierenden Zustand wiederherstellen können.\nDiese zwei, in der Realität nicht ganz seltenen, Szenarien sind nur zwei Gründe, warum du ab heute mit Git und mit dem Git-Tool “Bitbucket” arbeiten wirst. Git ist ein Software-System, das es ermöglicht, den Arbeitszustand in einem sog. lokalen Repository aufzubewahren und diesen bei Bedarf (z.B. im zweiten Szenario) wiederherzustellen. Bitbucket ist ein Git-Cloud-Tool, welches sog. Remote-Repositories in der Cloud zur Verfügung stellt. Diese Remote-Repositories sind im Wesentlichen eine Kopie der lokalen Repositories und dienen unter anderem auch als Backup der Arbeit ausserhalb der eigenen Maschine.\nSpäter im Ausbildungsprogramm wirst du mehr über Git und seine weitere Anwendungszwecke erfahren. Hier geht es aber in erster Linie um das Backup deiner Arbeit, damit du bei einem Computerabsturz nicht alles von vorne machen musstest.\nPersönliches Bitbucket Repository einrichten Um deine Arbeit ausserhalb deines Computers zu sichern, wirst du in den nächsten Abschnitten ein Remote Git-Repository in Bitbucket erstellen und einrichten. Anschliessend wirst du dieses Repository bei dir (lokal) “klonen”, sodass du auch ein lokales Repository hast, womit du auch ohne Internetverbindung arbeiten kannst.\nRemote Repository erstellen Klicke auf den folgenden Link, um Bitbucket in deinem Browser zu öffnen: Bitbucket. Wenn du noch nicht eingeloggt bist, folge den Anweisungen auf der Login-Seite. Nach dem Login wirst du oben rechts ein, vermutlich, noch leeres Profil-Bild sehen. Klicke darauf und wähle View Profile (Profil anzeigen) aus: Auf deiner Profilseite, klickst du nun den Create repository (Neues Repository erstellen) Button. Gib im geöffneten Formular deinem Repository einen Namen. Grundsätzlich ist der Name frei wählbar, aber wir empfehlen etwas in der Form von “IT-Ninjas-{jahr}-{vorname}{name}” zu nutzen, wobei für {jahr} das aktuelle Jahr eingesetzt wird, {vorname} ersetzt Du durch Deinen Vornamen und {name} durch Deinen Namen. Das erleichtert uns die Zusammenarbeit. Lasse die andere Felder leer. Anschliessend klicke auf Create Repository (Repository erstellen). Bitbucket erstellt nun das Repository für dich und du wirst automatisch zu deinem, noch leeren, Repository geführt. Herzliche Gratulation! Du hast soeben dein erstes Git-Repository erstellt.\nSSH-Schlüssel für dein Repository erstellen Ein SSH-Schlüssel ist ein Zugriffsberechtigungsnachweis für das SSH-Netzwerkprotokoll (Secure Shell). Dieses authentifizierte und verschlüsselte sichere Netzwerkprotokoll wird für die Remote-Kommunikation zwischen Computern verwendet.\nSSH verwendet ein Schlüsselpaar, um einen sicheren Handshake zwischen Remote-Parteien zu initiieren. Das Schlüsselpaar enthält einen öffentlichen und einen privaten Schlüssel. Den öffentlichen Schlüssel kannst du dir als Schloss und den privaten Schlüssel als Schlüssel für dieses Schloss vorstellen.\nSSH Schlüssel-Paar erstellen: Öffne ein Git-Bash Terminal und gib folgenden Befehl ein. Verwende hierfür deine E-Mail-Adresse:\n1 ssh-keygen -t rsa -b 4096 -C \"u123456@sbb.ch\" Danach wirst du aufgefordert, eine Datei anzugeben, in der der Schlüssel gespeichert werden soll. Drücke hier die Eingabetaste (Enter), um den Standardspeicherort zu übernehmen. Bei der nächsten Eingabeaufforderung wirst du nach einer sicheren Passphrase gefragt. Auch hier kannst du die Eingabetaste verwenden, um keine Passphrase zu definieren (oder du wählst dir eine Passphrase aus).\nDeine SSH-Schlüsselpaar-Dateien sind nun in deinem Standardverzeichnis (auf Windows: C:\\Users\u003cdeine-uNummer\u003e.ssh) vorhanden: Der private Schlüssel ist in der Datei id_rsa abgelegt. Der private Schlüssel darf nie geteilt werden. Der öffentliche Schlüssel ist in der Datei id_rsa.pub abgelegt.\nÖffentlicher Schlüssel in Bitbucket ablegen Als letzter Schritt legst du deinen öffentlichen SSH-Schlüssel wie folgt in Bitbucket ab:\nÖffne ein Git-Bash Terminal und navigiere zum Speicherort deines SSH-Schlüsselpaars. Gib folgenden Befehl ein, um deinen Schlüssel im Terminal auszugeben: 1 C:\\Users\\u123456\\.ssh\u003e type id_rsa.pub Markiere die Ausgabe und kopiere sie zum Clipboard (CTRL+C). Klicke hier, um deinen öffentlichen Schlüssel ins Bitbucket hinzuzufügen. Klicke die “Add key” Schaltfläche, fülle das geöffnete Formular wie folgt aus und drücke anschliessend die “Save” Schaltfläche:\nSomit hast du die SSH-Konfiguration abgeschlossen und du kannst dieses Protokoll beim Klonen benutzen.\nRepository lokal klonen Dein erstelltes Repository befindet sich nun auf dem Bitbucket-Server.\nDamit du diesen Repository aus deinem Computer benutzen kannst, musst du jetzt dieses lokal “klonen”.\nKlonen bedeutet hier einerseits lokal kopieren und andererseits eine Verbindung zwischen Remote- und Lokal-Repository herzustellen, um die Arbeit zwischen den beiden synchronisieren zu können.\nDa du jetzt einen Ort hast, an dem du deine Arbeitsdateien hinzufügen und sichern kannst, muss es auch eine Möglichkeit geben,\nvon deinem lokalen System (also direkt von deinem Computer und nicht nur über Browser) darauf zuzugreifen.\nUm dies einzurichten, kopierst du das Bitbucket-Repository auf dein System.\nBei Git wird dieser Kopiervorgang als Klonen bezeichnet.\nWenn du ein Repository klonst, erstellst du eine Verbindung zwischen dem Bitbucket-Server (bei Git als “origin” benannt) und deinem lokalen System.\nOrdner für deine Repositories anlegen Bevor du dein Repository klonen wirst, erstellst du nun ein Ordner, welcher dieses Repository (und später auch weitere Repositories) beinhalten wird.\nAufgabe\nErstelle den Ordner “local_repos” unter deinem Startverzeichnis (bei Windows unter *“C:\\Users\\\u003cdein Benutzername\u003e”_)\nFalls du Hilfe brauchst.. 1 2 3 4 C:\\\u003e cd Users\\e123456 # e123456 ist der Benutzername auf dieser Maschine C:\\Users\\e123456\u003e mkdir local_repos # erstellt den Ordner \"local_repos\" unter dein Startverzeichnis C:\\Users\\e123456\u003e cd local_repos # ins Ordner local_repos navigieren C:\\Users\\e123456\\local_repos\u003e # fertig... Repository klonen Auf deiner Bitbucket-Repository Seite, klicke die Clone (klonen) Schaltfläche. Im geöffneten Popup-Fenster, wähle SSH als Protokoll und kopiere (CTRL+C) die URL zu deinem Repository (direkt neben dem Protokoll) in dein Clipboard: Öffne nun dein Git-Bash Terminal und navigiere zu deinem, im vorherigen Schritt erstellten, “local_repos” Ordner. Verwende folgenden Befehl, um dein Repository zu klonen: 1 C:\\Users\\e123456\\local_repos\u003e git clone ssh://git@codessh.sbb.ch:7999/~e123456/ausbildungsprogramm.git Nun findest du unter deinem “local_repos” Ordner einen neuen Ordner mit dem Namen deines Repositorys. Dieser neue Ordner ist dein lokales Git-Repository und hier wirst du deine Arbeit ab jetzt speichern und verwalten.\nGratuliere! Nun hast du dein lokales Repository, worin du deine Arbeit verwalten kannst.\nOrdnerstruktur im lokalen Repository anlegen Jetzt erstellst du eine Ordnerstruktur, welche dazu dient, deine Arbeit im Ausbildungsprogramm strukturiert zu speichern und zu verwalten.\nAufgabe:\nErstelle folgende Ordnerstruktur in deinem lokalen Repository Ordner:\nIm Ordner J1 wirst du die Arbeit, welche zum ersten Java-Modul gehört speichern und verwalten (J1 entspricht der ID des ersten Moduls). Für jedes weitere Modul, welches du bearbeitest, wirst du einen Ordner unter deinem Repository-Ordner erstellen mit der ID des Moduls als Ordnername. Der src Ordner wirst du mit deinem Code befüllen. Darin wird später eine Java-Package-Struktur sein, die du dann anlegen wirst.\n“Snapshots” erstellen und ins Repository commiten In diesem Schritt wirst du eine neue Datei erstellen, diese in deinem lokalen Repository hinzufügen und Änderungen als “Snapshots” im Repository speichern.\nAufgabe:\nErstelle eine Datei mit dem Namen “README.md” in deinem src Folder.\n“git add” und “git status” Die Datei, welche du eben erstellt hast, befindet sich in deinem Arbeitsverzeichnis. Damit du diese nun in deinem Repository speichern kannst, musst du die Datei zuerst in eine sog. Staging-Umgebung verschieben. Dies wird mit dem Befehl git add gemacht. Gib folgenden Befehl in deinem Git-Bash Terminal ein:\n1 C:\\Users\\e123456\\local_repos\\ausbildungsprogramm\\J1\u003e git add README.md Somit befindet sich ein Snapshot deiner Datei in der Staging-Umgebung.\nMit dem Befehl git status kannst du dies auch prüfen. Gebe den Befehl im Terminal ein.\nDie Ausgabe zeigt dir, dass es eine neue Datei in der Staging-Umgebung gibt, die aber noch nicht ins Repository “commited” wurde. Dies machst du nun im nächsten Schritt.\n“git commit” Wenn du den Befehl git commit eingibst, speicherst du die “gestagete” Arbeit in deinem lokalen Repository. Bei Bedarf kannst du diesen Snapshot aus dem Repository wiederherstellen.\nFühre folgender Befehl aus, um den ersten Snapshot deiner Datei im Repository zu speichern:\n1 C:\\Users\\e123456\\local_repos\\ausbildungsprogramm\\J1\u003e git commit -m 'Eine leere README.md Datei' Das “-m” gibt an, dass eine Commit-Nachricht folgt. Diese ist dann im Repository auch ersichtlich und hilft dir später herauszufinden was du in diesem Snapshot gemacht hast. Nun ist der erste Snapshot deiner Datei im lokalen Repository gespeichert.\nWenn du wieder git status ausführst, wirst du sehen, dass es jetzt nichts zu commiten gibt.\nWenn du beim Ausführen von git status die folgende Meldung siehst:\nkannst du dies mit dem vorgeschlagenen Befehl korrigieren:\n1 C:\\Users\\e123456\\local_repos\\ausbildungsprogramm\\J1\u003e git branch --unset-upstream Wenn du git status oder auch andere Git-Befehle nun eingibst, siehst du diese Meldung nicht mehr.\nAufgabe:\nÖffne deine README.md Datei mit einem Text-Editor (z.B. Notepad++) und füge den folgenden Text hinzu:\n1 2 3 4 Nützliche Git-Befehle: git add: verschiebt Änderungen aus dem Arbeitsverzeichnis in die Staging-Umgebung von Git. git status: gibt den Status des Arbeitsverzeichnisses und den Status des Snapshots in der Staging-Umgebung zurück. git commit: committet den Snapshot aus der Staging-Umgebung in den Projektverlauf. Das bedeutet, dass dieser Snapshot nun in deinem lokalen Repository gespeichert wurde. Erstelle einen neuen Snapshot deiner Datei und commite sie in deinem lokalen Repository.\nDateien ins Remote-Repository laden Bis jetzt hast du deine Arbeit im lokalen Repository, sprich nur auf der Festplatte deines Computers, gespeichert. Damit du diese Arbeit immer noch hast, auch wenn dein Computer oder die Festplatte versagen, wirst du nun deine Arbeit zum Remote-Repository auf Bitbucket schicken.\n“git push” Der Befehl git push, schickt die committeten Änderungen von deinem lokalen Repository an das Remote-Repository. Das Remote-Repository wird als origin bezeichnet.\nGib also folgenden Befehl in deinem Git-Bash Terminal ein:\n1 C:\\Users\\e123456\\local_repos\\ausbildungsprogramm\\J1\\src\u003egit push origin master Wenn du dein Bitbucket-Repository im Browser öffnest, wirst du deine Arbeit jetzt auch dort sehen.\nNun ist deine Arbeit auch ausserhalb deines Computers abgesichert.\nAufgabe\nÖffne deine README.md Datei in einem Texteditor und füge den folgenden Text hinzu:\n1 git push origin master: pusht die Änderungen aus dem lokalen Repository in den Haupt-Branch **master** (Bitbucket-Branch) auf \"origin\" (Bitbucket-Server). Erstelle einen neuen Snapshot deiner Datei, commite sie in deinem lokalen Repository und pushe sie auf den Bitbucket-Server.\nDen Ernstfall üben Deine Arbeit ist nun auf dem Bitbucket-Server gesichert.\nWenn dein Computer sich jetzt für immer verabschiedet, kannst du die Arbeit auf einem neuen Computer wiederherstellen.\nDieses Szenario wirst du jetzt üben.\nAufgabe\nLösche dein lokale Repository (das Verzeichnis unter local_repos und alles darunter löschen). Stelle deine Arbeit aus dem Bitbucket-Server wieder her. Füge folgenden Text deinem README.md File hinzu: “git clone: klont ein Remote-Repository auf das lokale System in einem lokalen Repository.” Erstelle ein Snapshot für die Änderung, commite sie und pushe sie auf den Bitbucket-Server. Falls du etwas Hilfe brauchst... 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # Mit Git-Bash auf deinem \"local_repos\" Verzeichnis wechseln cd C:\\Users\\[deine U/E-Nummer]\\local_repos # Remote Repository klonen git clone ssh://git@codessh.sbb.ch:7999/~[deine U/E-Nummer]/ausbildungsprogramm.git # Wechsle in das Arbeitsverzeichnis deines lokalen Repositorys # Du findest deine README.md Datei im Verzeichnis C:\\Users\\[deine U/E-Nummer]\\local_repos\\ausbildungsprogramm\\J1\\src cd ausbildungsprogramm\\J1\\src # Füge den gewünschten Text mit einem Texteditor hinzu und speichere die Datei # Verschiebe die Datei in die Staging-Umgebung git add README.md # Commite deine Änderungen in das lokale Repository git commit -m 'Information zu git clone hinzugefügt' # pushe deine Änderungen auf dem Bitbucket-Server git push origin master Praxisbildner auf deinem Repository berechtigen Nun kannst du deine Arbeit mit Git verwalten. Somit stellst du sicher, dass deine Arbeit auch im schlimmsten Fall nicht verloren geht. Damit deine Praxisbildner dich bei Problemsituationen unterstützen können, musst du sie auf deinem Bitbucket-Repository berechtigen. Dies erledigst du mit folgenden Schritten:\nÖffne dein Bitbucket-Repository im Browser. Im Navigationsbereich klicke auf Repository Settings und dort auf Repository Permissions: Klicke die Schaltfläche “Add user or group” und berechtige alle Praxisbildner als Administratoren auf deinem Repository. Anschliessend klicke die “Add” Schaltfläche: Nun sind alle Praxisbildner auf deinem Repository berechtigt.\n","categories":"","description":"Tools - Persönliches Git-Repository einrichten\n","excerpt":"Tools - Persönliches Git-Repository einrichten\n","ref":"/de/docs/01_tools/02_personal-bitbucket/","tags":"","title":"Persönliches Git-Repository einrichten"},{"body":"Aufgabe 1 Schreibe ein Programm, welches die Personen von vier Vereine auswertet.\nPro Verein existiert ein Set mit allen Vereinsmitliedern (siehe Input). Das Programm analysiert die Vereinsmitglieder und schreibt die folgenden Aussagen in die Konsole (siehe Beispiel-Ausgabe unten): Wie viele Personen machen min. in einem Verein mit: Anzahl: Namen Alle Personen, welche im Fussball und Tanz Verein sind: Anzahl: Namen Alle Personen, welche im Fussball sind und nicht im Tanz oder Schwimm Verein: Anzahl: Namen Die Namen der Personen müssen in alphabetischer Reihenfolge angezeigt werden. Ein eigenes Testing (wie in J4 Testing gelernt) soll umgesetzt werden. Input 4 Sets 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Set\u003cString\u003e fussballVerein = Set.of( \"Emil\", \"Hans\", \"Felix\", \"Fritz\", \"Patrick\", \"Hanne\", \"Anja\", \"Paula\", \"Petra\", \"Anna\" ); Set\u003cString\u003e schwimmVerein = Set.of( \"Emil\", \"Klaus\", \"Paul\", \"Fritz\", \"Patrick\", \"Hanne\", \"Anina\", \"Nicole\", \"Petra\", \"Gerda\" ); Set\u003cString\u003e musikVerein = Set.of( \"Kari\", \"Hans\", \"Max\", \"Karin\", \"Petra\", \"Anna\" ); Set\u003cString\u003e tanzVerein = Set.of( \"Emil\", \"Hans\", \"Paul\", \"Felix\", \"Max\", \"Lara\", \"Anja\", \"Sabine\", \"Anna\" ); Ausgabe Die Ausgabe soll vom Format her so aussehen\n1 2 3 - Wie viele Personen machen min. in einem Verein mit: [anzahl]: [namen] - Alle Personen, welche im Fussball und Tanz Verein sind: [anzahl]: [namen] - Alle Personen, welche im Fussball sind und nicht im Tanz oder Schwimm Verein: [anzahl]: [namen] Achte auf Details wie, dass die Namen ohne Lücken aufgeführt werden ansonsten stimmt der Hash nicht. Die Ausgabe könnte beispielsweise so aussehen:\n1 2 3 - Wie viele Personen machen min. in einem Verein mit: 19: Anja,Anna,Emil,Fritz,Gerda,Hanne,Hans,Karin,Klaus,Lara,Max,Nicole,Patrick,Paul,Paula,Petra,Sabine - Alle Personen, welche im Fussball und Tanz Verein sind: 4: Anna,Emil,Felix,Hans,Gerda - Alle Personen, welche im Fussball sind und nicht im Tanz oder Schwimm Verein: 3: Anja,Emil,Hanne Ausgabe überprüfen Wie könnt ihr die Ausgabe überprüfen? Wir benützen dazu eine kleine Hilfsklasse OutputValidation. Die Klasse erlaubt es eure System.out.println() Anweisungen mit OutputValidation.logAndPrint() zu ersetzten. Am Schluss des Programmes kann man mit OutputValidation.printControlHash() den Hash-Wert der eigenen Ausgabe anzeigen, oder mit OutputValidation.verifyControlHash() einen Hash-Wert zur Überprüfung mit eurer Ausgabe überreichen.\nEin Anwendungsbeispiel seht ihr unter OutputValidationUsage.\nDer Hash für diese Aufgabe ist: -1421274666\nAufgabe 2 Wir programmieren eine eigene Set-Klasse MySet, welche noch kein Hash-Code verwendet.\nEs dürfen keine Klassen aus dem Collection-Framework verwendet werden. Die Klasse muss das Interface MySetInterfaceSimple implementieren. Die Klasse weiss nicht, wie viele Elemente man speichern muss. Sie muss die Grösse des Arrays dynamische anpassen. Die toString() der java.lang.Object Klasse soll von der MySet so überschrieben werden, dass die Elemente kommasepariert ausgegeben werden. Überprüfe deine Implemenation mit dem JUnitTest MySetTest Input Inferface MySetInterfaceSimple 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 package com.examples.list; public interface MySetInterfaceSimple\u003cE\u003e { /** * Adds the specified element to this set if it is not already present. * @param element element to be appended to this list * @return true if this set did not already contain the specified element */ boolean add(E element); /** * Removes the specified element from this set if it is present. * @param element element to be removed from this set, if present * @return true if the set contained the specified element */ boolean remove(E element); /** * Returns true if this set contains the specified element. * @param element element whose presence in this set is to be tested * @return true if this set contains the specified element */ public boolean contains(E element); /** * Returns the number of elements in this set. * @return the number of elements in this set */ int size(); /** * Returns true if this set contains no elements. * @return true if this set contains no elements */ boolean isEmpty(); /** * Removes all the elements from this set. The set will be empty after this call returns. */ void clear(); } Aufgabe 3 (Optional) Wir Kopieren unsere MySet Klasse zu der Klasse MyHashSet und erweitern diese, damit sie Hash Funktionalität verwendet:\nBeim Hinzufügen von neuen Elementen wird deren Hash-Code berechnet und ebenfalls abgespeichert. Die Suche nach bestehenden Elementen wird anschliessend über den gespeicherten Hash-Code durchgeführt statt über die Elemente selbst. Du kannst deine Implemenation mit dem gleichen JUnitTest MySetTest überprüfen, da sich die neue Klasse gleich verhalten soll. Erstelle vom Test eine Kopie MyHashSetTest und ändere MySet überall zu MyHahsSet. ","categories":"","description":"Aufgaben zu [Java Collections - Set](../../../docs/02_java/10_java-collections/03_set)\n","excerpt":"Aufgaben zu [Java Collections - …","ref":"/labs/02_java/10_java-collections/02_set/","tags":"","title":"Set - Aufgaben"},{"body":"Aufgabe 1 Schreibe ein Programm, welches die Personen von vier Vereine auswertet.\nPro Verein existiert ein Set mit allen Vereinsmitliedern (siehe Input). Das Programm analysiert die Vereinsmitglieder und schreibt die folgenden Aussagen in die Konsole (siehe Beispiel-Ausgabe unten): Wie viele Personen machen min. in einem Verein mit: Anzahl: Namen Alle Personen, welche im Fussball und Tanz Verein sind: Anzahl: Namen Alle Personen, welche im Fussball sind und nicht im Tanz oder Schwimm Verein: Anzahl: Namen Die Namen der Personen müssen in alphabetischer Reihenfolge angezeigt werden. Ein eigenes Testing (wie in J4 Testing gelernt) soll umgesetzt werden. Input 4 Sets 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Set\u003cString\u003e fussballVerein = Set.of( \"Emil\", \"Hans\", \"Felix\", \"Fritz\", \"Patrick\", \"Hanne\", \"Anja\", \"Paula\", \"Petra\", \"Anna\" ); Set\u003cString\u003e schwimmVerein = Set.of( \"Emil\", \"Klaus\", \"Paul\", \"Fritz\", \"Patrick\", \"Hanne\", \"Anina\", \"Nicole\", \"Petra\", \"Gerda\" ); Set\u003cString\u003e musikVerein = Set.of( \"Kari\", \"Hans\", \"Max\", \"Karin\", \"Petra\", \"Anna\" ); Set\u003cString\u003e tanzVerein = Set.of( \"Emil\", \"Hans\", \"Paul\", \"Felix\", \"Max\", \"Lara\", \"Anja\", \"Sabine\", \"Anna\" ); Ausgabe Die Ausgabe soll vom Format her so aussehen\n1 2 3 - Wie viele Personen machen min. in einem Verein mit: [anzahl]: [namen] - Alle Personen, welche im Fussball und Tanz Verein sind: [anzahl]: [namen] - Alle Personen, welche im Fussball sind und nicht im Tanz oder Schwimm Verein: [anzahl]: [namen] Achte auf Details wie, dass die Namen ohne Lücken aufgeführt werden ansonsten stimmt der Hash nicht. Die Ausgabe könnte beispielsweise so aussehen:\n1 2 3 - Wie viele Personen machen min. in einem Verein mit: 19: Anja,Anna,Emil,Fritz,Gerda,Hanne,Hans,Karin,Klaus,Lara,Max,Nicole,Patrick,Paul,Paula,Petra,Sabine - Alle Personen, welche im Fussball und Tanz Verein sind: 4: Anna,Emil,Felix,Hans,Gerda - Alle Personen, welche im Fussball sind und nicht im Tanz oder Schwimm Verein: 3: Anja,Emil,Hanne Ausgabe überprüfen Wie könnt ihr die Ausgabe überprüfen? Wir benützen dazu eine kleine Hilfsklasse OutputValidation. Die Klasse erlaubt es eure System.out.println() Anweisungen mit OutputValidation.logAndPrint() zu ersetzten. Am Schluss des Programmes kann man mit OutputValidation.printControlHash() den Hash-Wert der eigenen Ausgabe anzeigen, oder mit OutputValidation.verifyControlHash() einen Hash-Wert zur Überprüfung mit eurer Ausgabe überreichen.\nEin Anwendungsbeispiel seht ihr unter OutputValidationUsage.\nDer Hash für diese Aufgabe ist: -1421274666\nAufgabe 2 Wir programmieren eine eigene Set-Klasse MySet, welche noch kein Hash-Code verwendet.\nEs dürfen keine Klassen aus dem Collection-Framework verwendet werden. Die Klasse muss das Interface MySetInterfaceSimple implementieren. Die Klasse weiss nicht, wie viele Elemente man speichern muss. Sie muss die Grösse des Arrays dynamische anpassen. Die toString() der java.lang.Object Klasse soll von der MySet so überschrieben werden, dass die Elemente kommasepariert ausgegeben werden. Überprüfe deine Implemenation mit dem JUnitTest MySetTest Input Inferface MySetInterfaceSimple 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 package com.examples.list; public interface MySetInterfaceSimple\u003cE\u003e { /** * Adds the specified element to this set if it is not already present. * @param element element to be appended to this list * @return true if this set did not already contain the specified element */ boolean add(E element); /** * Removes the specified element from this set if it is present. * @param element element to be removed from this set, if present * @return true if the set contained the specified element */ boolean remove(E element); /** * Returns true if this set contains the specified element. * @param element element whose presence in this set is to be tested * @return true if this set contains the specified element */ public boolean contains(E element); /** * Returns the number of elements in this set. * @return the number of elements in this set */ int size(); /** * Returns true if this set contains no elements. * @return true if this set contains no elements */ boolean isEmpty(); /** * Removes all the elements from this set. The set will be empty after this call returns. */ void clear(); } Aufgabe 3 (Optional) Wir Kopieren unsere MySet Klasse zu der Klasse MyHashSet und erweitern diese, damit sie Hash Funktionalität verwendet:\nBeim Hinzufügen von neuen Elementen wird deren Hash-Code berechnet und ebenfalls abgespeichert. Die Suche nach bestehenden Elementen wird anschliessend über den gespeicherten Hash-Code durchgeführt statt über die Elemente selbst. Du kannst deine Implemenation mit dem gleichen JUnitTest MySetTest überprüfen, da sich die neue Klasse gleich verhalten soll. Erstelle vom Test eine Kopie MyHashSetTest und ändere MySet überall zu MyHahsSet. ","categories":"","description":"Aufgaben zu [Java Collections - Set](../../../docs/02_java/10_java-collections/03_set)\n","excerpt":"Aufgaben zu [Java Collections - …","ref":"/de/labs/02_java/10_java-collections/02_set/","tags":"","title":"Set - Aufgaben"},{"body":"Spring Ziele Ich kann am Beispiel Spring erklären, was ein “Framework” ausmacht, indem ich Unterschiede zu einer gewöhnlichen externen Library aufzählen kann. Ich kenne einige Vor- und Nachteile, wenn ein Frameworks im Projekt eingesetzt wird. Ich kann erläutern, welche Zuständigkeiten die folgenden Module im Spring-Framework haben: Core, Data-Access, Web und welche Aufgaben sie erfüllen. Ich bin mit den bedeutendsten Spring-Projekten (Spring-Boot, Spring-Cloud, Spring-Security) vertraut, und kann erklären, wann und wofür welche eingesetzt werden. Ich verstehe das Konzept hinter “Inversion of Control” (IoC) und kann erklären, auf welche Art und Weise es in Spring eingesetzt wird. Ich kann mind. 2 Arten auflisten, wie “Dependency-Injection” (DI) dazu verwendet werden kann, um Variabeln automatisch einen Wert zuzuweisen. (Constructor-Based, Setter-Based, Field-Based) um DI in Spring zu benutzen. Ich kann das Konzept hinter @Beans in Spring skizzieren und kann erläutern, wie @Beans definiert und verwendet werden können. Ich kann den Scopes einer “Spring-Beans” ändern. (z.B. Singleton, Session, Application usw.). Ich kenne die am häufigsten verwendeten Spring-Bean-Annotationen @Service, @Configuration, @Component, @Repository, @Controller und weiss, wie ich diese einsetze und welchen Zweck sie erfüllen. Ich weiss, was “Wiring” bedeutet und wie es in Spring verwendet wird. Ich kann in Spring-Projekten sogenannte Properties setzen und abfragen. Ich kenne Anwendungsfälle, in welchen Spring-Profiles verwendet werden und weiss, wie ich sie setzen kann. Framework Ein Framework kann die Grundstruktur für Applikationen vorgeben. Es stellt Funktionen, Bibliotheken und Regeln bereit, um den Entwicklungsprozess zu erleichtern und zu beschleunigen. Häufig gibt es eine standartisierte Struktur und Methodik vor, um eine gewisse Konsistenz und Qualität des Codes und der Software sicherzustellen.\nSpring Framework Das Spring Framework ist ein weit verbreitetes Framework für die Entwicklung von Java-Anwendungen. Es bietet eine umfassende Infrastruktur, die Entwicklern hilft, robuste und wartbare Anwendungen zu erstellen. Eines der Kernkonzepte von Spring ist die Inversion of Control (IoC), bei der das Framework die Verantwortung für das Erstellen und Verwalten von Objekten übernimmt, anstatt dass der Entwickler dies manuell tun muss.\nSpring bietet viele nützliche Module und Funktionen, wie z.B. Spring MVC für die Entwicklung von Webanwendungen, Spring Data für den einfachen Zugriff auf Datenbanken und Spring Security für die Implementierung von Sicherheitsfunktionen. Durch die Nutzung von Spring können Entwickler sich auf die Geschäftslogik ihrer Anwendungen konzentrieren, während das Framework viele der wiederkehrenden Aufgaben übernimmt. Dies führt zu saubererem, besser organisiertem Code und erleichtert die Wartung und Erweiterung der Anwendungen.\nModule Das Spring-Framework besteht aus verschiedenen Modulen, die unterschiedliche Aufgaben erfüllen und in Kategorien wie Core, Data Access, Web usw. organisiert sind.\nQuelle: https://docs.spring.io/spring-framework/docs/4.0.x/spring-framework-reference/html/images/spring-overview.png\nDas Core-Modul umfasst essenzielle Funktionen wie Dependency Injection. Das Beans-Modul beinhaltet alles, was zur Erstellung von Beans benötigt wird.\nDas JDBC-Modul bietet ein JDBC-Interface für den Datenbankzugriff. Das ORM-Modul ermöglicht den Zugriff auf Object-Mapping-APIs wie JPA, JDO, Hibernate. Das OXM-Modul ermöglicht den Zugriff auf Objekt/XML-Speicher-Implementierungen.\nDas Web-Modul ist für die Kommunikation mit der Aussenwelt (Internet) verantwortlich.\nWeitere Informationen befinden sich in der offiziellen Dokumentation.\nSpring Projekte Es gibt verschiedene Spring-Projekte, die auf dem Spring Framework aufbauen und dessen Anwendungsmöglichkeiten erweitern. Zu diesen gehören z. B. Spring Security, Spring Shell, Spring Boot, die jeweils spezifische Funktionalitäten bereitstellen.\nMehr dazu auf GitHub Spring Projects.\nSpring Boot Spring Boot vereinfacht das normale Spring Framework. Mit dem Spring Initializer können Abhängigkeiten wie Datenbanktreiber oder Software für die Cloud-Infrastruktur ausgewählt werden, was die manuelle Konfiguration des Projekts überflüssig macht. Spring Boot ist jedoch kein Ersatz für das Spring Framework, sondern vereinfacht die Konfiguration.\n","categories":"","description":"Modul #J8 - Spring Framework - Spring\n","excerpt":"Modul #J8 - Spring Framework - Spring\n","ref":"/docs/02_java/12_spring-framework/02_spring/","tags":"","title":"Spring"},{"body":"Spring Ziele Ich kann am Beispiel Spring erklären, was ein “Framework” ausmacht, indem ich Unterschiede zu einer gewöhnlichen externen Library aufzählen kann. Ich kenne einige Vor- und Nachteile, wenn ein Frameworks im Projekt eingesetzt wird. Ich kann erläutern, welche Zuständigkeiten die folgenden Module im Spring-Framework haben: Core, Data-Access, Web und welche Aufgaben sie erfüllen. Ich bin mit den bedeutendsten Spring-Projekten (Spring-Boot, Spring-Cloud, Spring-Security) vertraut, und kann erklären, wann und wofür welche eingesetzt werden. Ich verstehe das Konzept hinter “Inversion of Control” (IoC) und kann erklären, auf welche Art und Weise es in Spring eingesetzt wird. Ich kann mind. 2 Arten auflisten, wie “Dependency-Injection” (DI) dazu verwendet werden kann, um Variabeln automatisch einen Wert zuzuweisen. (Constructor-Based, Setter-Based, Field-Based) um DI in Spring zu benutzen. Ich kann das Konzept hinter @Beans in Spring skizzieren und kann erläutern, wie @Beans definiert und verwendet werden können. Ich kann den Scopes einer “Spring-Beans” ändern. (z.B. Singleton, Session, Application usw.). Ich kenne die am häufigsten verwendeten Spring-Bean-Annotationen @Service, @Configuration, @Component, @Repository, @Controller und weiss, wie ich diese einsetze und welchen Zweck sie erfüllen. Ich weiss, was “Wiring” bedeutet und wie es in Spring verwendet wird. Ich kann in Spring-Projekten sogenannte Properties setzen und abfragen. Ich kenne Anwendungsfälle, in welchen Spring-Profiles verwendet werden und weiss, wie ich sie setzen kann. Framework Ein Framework kann die Grundstruktur für Applikationen vorgeben. Es stellt Funktionen, Bibliotheken und Regeln bereit, um den Entwicklungsprozess zu erleichtern und zu beschleunigen. Häufig gibt es eine standartisierte Struktur und Methodik vor, um eine gewisse Konsistenz und Qualität des Codes und der Software sicherzustellen.\nSpring Framework Das Spring Framework ist ein weit verbreitetes Framework für die Entwicklung von Java-Anwendungen. Es bietet eine umfassende Infrastruktur, die Entwicklern hilft, robuste und wartbare Anwendungen zu erstellen. Eines der Kernkonzepte von Spring ist die Inversion of Control (IoC), bei der das Framework die Verantwortung für das Erstellen und Verwalten von Objekten übernimmt, anstatt dass der Entwickler dies manuell tun muss.\nSpring bietet viele nützliche Module und Funktionen, wie z.B. Spring MVC für die Entwicklung von Webanwendungen, Spring Data für den einfachen Zugriff auf Datenbanken und Spring Security für die Implementierung von Sicherheitsfunktionen. Durch die Nutzung von Spring können Entwickler sich auf die Geschäftslogik ihrer Anwendungen konzentrieren, während das Framework viele der wiederkehrenden Aufgaben übernimmt. Dies führt zu saubererem, besser organisiertem Code und erleichtert die Wartung und Erweiterung der Anwendungen.\nModule Das Spring-Framework besteht aus verschiedenen Modulen, die unterschiedliche Aufgaben erfüllen und in Kategorien wie Core, Data Access, Web usw. organisiert sind.\nQuelle: https://docs.spring.io/spring-framework/docs/4.0.x/spring-framework-reference/html/images/spring-overview.png\nDas Core-Modul umfasst essenzielle Funktionen wie Dependency Injection. Das Beans-Modul beinhaltet alles, was zur Erstellung von Beans benötigt wird.\nDas JDBC-Modul bietet ein JDBC-Interface für den Datenbankzugriff. Das ORM-Modul ermöglicht den Zugriff auf Object-Mapping-APIs wie JPA, JDO, Hibernate. Das OXM-Modul ermöglicht den Zugriff auf Objekt/XML-Speicher-Implementierungen.\nDas Web-Modul ist für die Kommunikation mit der Aussenwelt (Internet) verantwortlich.\nWeitere Informationen befinden sich in der offiziellen Dokumentation.\nSpring Projekte Es gibt verschiedene Spring-Projekte, die auf dem Spring Framework aufbauen und dessen Anwendungsmöglichkeiten erweitern. Zu diesen gehören z. B. Spring Security, Spring Shell, Spring Boot, die jeweils spezifische Funktionalitäten bereitstellen.\nMehr dazu auf GitHub Spring Projects.\nSpring Boot Spring Boot vereinfacht das normale Spring Framework. Mit dem Spring Initializer können Abhängigkeiten wie Datenbanktreiber oder Software für die Cloud-Infrastruktur ausgewählt werden, was die manuelle Konfiguration des Projekts überflüssig macht. Spring Boot ist jedoch kein Ersatz für das Spring Framework, sondern vereinfacht die Konfiguration.\n","categories":"","description":"Modul #J8 - Spring Framework - Spring\n","excerpt":"Modul #J8 - Spring Framework - Spring\n","ref":"/de/docs/02_java/12_spring-framework/02_spring/","tags":"","title":"Spring"},{"body":"Aufträge Erweitere/Korrigiere deine Tests aus den Spring und Spring Boot Aufgaben wie folgt:\nSchreibe Mockito-Tests für den Service, der die Schulfächer verwaltet (z.B. SchulfachAdminService). Ändere den Integrationstest zur Verwaltung von Schulfächern (z.B. AdminControllerIntegrationTest) zu einem @WebMvcTest. Schreibe einen @DataJpaTest respektive @DataJdbcTest, der das Repository zur Verwaltung von Schulfächern inklusive seiner Entities abdeckt. Schreibe einen @SpringBootTest als kompletten Integrationstest, der vom Controller-Aufruf mittels MockMvc bis auf die H2-DB “runter” geht. Teste, ob das Anlegen eines neuen Schulfachs funktioniert und ob die Daten persistiert werden. ","categories":"","description":"Testen der Spring Boot Applikation für die Notenverwaltung aus Modul #J8\n","excerpt":"Testen der Spring Boot Applikation für die Notenverwaltung aus Modul …","ref":"/labs/02_java/12_spring-framework/02_spring_boot_testing/","tags":"","title":"Spring Boot Testing - Aufgaben"},{"body":"Aufträge Erweitere/Korrigiere deine Tests aus den Spring und Spring Boot Aufgaben wie folgt:\nSchreibe Mockito-Tests für den Service, der die Schulfächer verwaltet (z.B. SchulfachAdminService). Ändere den Integrationstest zur Verwaltung von Schulfächern (z.B. AdminControllerIntegrationTest) zu einem @WebMvcTest. Schreibe einen @DataJpaTest respektive @DataJdbcTest, der das Repository zur Verwaltung von Schulfächern inklusive seiner Entities abdeckt. Schreibe einen @SpringBootTest als kompletten Integrationstest, der vom Controller-Aufruf mittels MockMvc bis auf die H2-DB “runter” geht. Teste, ob das Anlegen eines neuen Schulfachs funktioniert und ob die Daten persistiert werden. ","categories":"","description":"Testen der Spring Boot Applikation für die Notenverwaltung aus Modul #J8\n","excerpt":"Testen der Spring Boot Applikation für die Notenverwaltung aus Modul …","ref":"/de/labs/02_java/12_spring-framework/02_spring_boot_testing/","tags":"","title":"Spring Boot Testing - Aufgaben"},{"body":"Ziele Du weisst wofür SQL verwendet wird Du kennst die verschiedenen Statements in SQL Du kannst einfache SQL Queries/Statements schreiben Was ist SQL? SQL oder „Structured Query Language“ ist eine Programmiersprache für die Bearbeitung von Daten und relationalen Datenbanksystemen. Diese Sprache wird hauptsächlich für die Kommunikation mit Datenbanken verwendet, um die darin enthaltenen Daten zu verwalten.\nStatements Was ist ein SQL Statement? Ganz einfach gesagt ist ein Statement ein Befehl, der an die Datenbank geschickt und dort ausgeführt wird. Es gibt viele verschiedene Statements, die teilweise kombiniert werden können, um den gewünschten Effekt auf der Datenbank zu erzielen. Grundsätzlich werden Teile der Syntax (Select, Insert, usw.) gross geschrieben, um eine Unterscheidung zwischen der Syntax und anderen Elementen wie tabellennamen usw. zu erhalten. Jedoch ist diese Regel nicht erzwungen.\nSELECT Das Select Statement wird verwendet, um Daten aus bestimmten Tabellen auszuwählen. Ein SELECT ist grundsätzlich wie folgt aufgebaut:\n1 2 3 4 SELECT * FROM table_name; -- Beispiel mit der Tabelle \"benutzer\" SELECT * from benutzer; Als Erstes kommt immer das “SELECT” gefolgt von den gewünschten Attribute. In diesem Statement wird ein Stern verwendet, dieser steht für alle Attribute. Dementsprechend werden alle Attribute, die in der Tabelle vorhanden sind, zurückgegeben. Auf die Attribute folgt das FROM, auf dieses folgt jeweils eine Tabelle, von welcher die Werte gewünscht sind. Im Beispiel ist es die Tabelle “benutzer”. Das Resultat dieses Statements würde schlussendlich so aussehen:\nvorname nachname alter beruf Anja Ackermann 13 Schüler/in Fritz Fischer 26 Pilot/in Hans Hansen 52 Hochbauzeichner/in Wenn wir nur eine Spalte auswählen möchten, können wir das Statement wie folgt anpassen:\n1 2 3 4 SELECT column_name FROM table_name; --Beispiel mit der Tabelle \"benutzer\" SELECT vorname FROM benutzer; Das Resultat würde dementsprechend so aussehen:\nvorname Anja Fritz Hans INSERT Das Insert Statement wird verwendet, um Daten in eine bestimmte Tabelle einzufügen. Ein INSERT ist grundsätzlich wie folgt aufgebaut:\n1 INSERT INTO table_name (column1, column2, column3, ...) VALUES (value1, value2, value3, ...); Als Erstes kommt immer das “INSERT INTO” gefolgt von der betroffenen Tabelle. Schlussendlich wird mit VALUES angegeben, dass ein oder mehrere Tupel eingefügt werden. In den Klammern können respektiv die Spaltennamen (optional) und die Inhalte angegeben werden.\nEin konkretes Beispiel würde mit dieser Tabelle beginnen:\nvorname nachname alter beruf Anja Ackermann 13 Schüler/in Fritz Fischer 26 Pilot/in Hans Hansen 52 Hochbauzeichner/in Dann wird dieses INSERT Statement ausgeführt:\n1 INSERT INTO benutzer VALUES (\"Max\", \"Mustermann\", 16, \"Maurer/in\"); Nach dem Statement ist der neue Benutzer Max in der Tabelle zu finden:\nvorname nachname alter beruf Anja Ackermann 13 Schüler/in Fritz Fischer 26 Pilot/in Hans Hansen 52 Hochbauzeichner/in Max Mustermann 16 Maurer/in Alternativ zum vorherigen Statement können auch nur bestimmte Daten eingefügt werden. In unserem Beispiel könnte ein Benutzer auch Arbeitslos sein, dementsprechend hätte er keinen Beruf. Wenn wir also so einen Benutzer hinzufügen möchten würden wir das wie folgt machen:\n1 INSERT INTO benutzer(vorname, nachname, alter) VALUES (\"Peter\", \"Piccolo\", 37); In den Klammern nach der Tabelle können wir also die Attribute auswählen, die wir hinzufügen möchten. In der Tabelle würde es so aussehen:\nvorname nachname alter beruf Anja Ackermann 13 Schüler/in Fritz Fischer 26 Pilot/in Hans Hansen 52 Hochbauzeichner/in Max Mustermann 16 Maurer/in Peter Piccolo 37 null Der Beruf wurde automatisch auf null gesetzt und ist dementsprechend leer.\nCREATE Das Create Statement wird verwendet, um Tabellen, Datenbanken, usw. zu erstellen. Ein CREATE Statement ist grundsätzlich wie folgt aufgebaut:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 -- Datenbank erstellen CREATE DATABASE databasename; --Tabelle erstellen CREATE TABLE table_name ( column1 datatype, column2 datatype, column3 datatype, .... ); -- Beispiel: die Tabelle \"benutzer\" erstellen CREATE TABLE benutzer (vorname varchar(255), nachname varchar(255), alter number, beruf varchar(255)); Als Erstes kommt immer das “CREATE” gefolgt dem zu erstellenden Objekt, in diesem Fall eine Tabelle. Schlussendlich wird noch ein Name festgelegt (die neue Tabelle heisst “benutzer”), gefolgt von den gewünschten Attributen der Tabelle und dem entsprechenden Datentyp.\nDas Resultat dieses Statements würde schliesslich so aussehen:\nvorname nachname alter beruf WHERE Die WHERE-Klausel ist im Vergleich zu den anderen kein Statement, sondern eine Ergänzung dazu. Mit WHERE kann spezifiziert werden, welche Daten für das Statement verwendet werden sollen. Mehrere Bedingungen können mit den Keywords AND und OR aneinandergereiht werden. Hier ein Beispiel dazu:\nAusgangstabelle:\nvorname nachname alter beruf Anja Ackermann 13 Schüler/in Fritz Fischer 26 Pilot/in Hans Hansen 52 Hochbauzeichner/in Max Mustermann 16 Maurer/in Dieses Statement schränkt das Alter zwischen 15 und 30 Jahren ein.\n1 SELECT * FROM benutzer WHERE alter \u003e 15 AND alter \u003c 30; Das Statement gibt schliesslich alle Werte zurück, die die Bedingung erfüllen:\nvorname nachname alter beruf Fritz Fischer 26 Pilot/in Max Mustermann 16 Maurer/in Zusätzlich gibt es bei Texten die Möglichkeit eine Teilüberprüfung mit Like zu machen. Damit können beispielsweise Alle Adressen gesucht werden, die mit “Strasse” enden. Dazu muss beim Like angegeben werden, wo sich der Rest des Textes befinden. Das funktioniert mit dem % Zeichen. Wenn der restliche Text vor dem Suchtext ist, wird das % vor diesem platziert. Dasselbe funktioniert natürlich auch umgekehrt. Weiter kann auch auf beiden Seiten ein % verwendet werden, so ist es egal wo sich der Suchtext befinden. Hier ein Beispiel-Query dazu:\nAusgangstabelle:\nvorname nachname alter beruf Anja Ackermann 13 Schüler/in Fritz Fischer 26 Pilot/in Hans Hansen 52 Hochbauzeichner/in Max Mustermann 16 Maurer/in 1 SELECT * FROM person WHERE nachname like '%mann' Resultat:\nvorname nachname alter beruf Anja Ackermann 13 Schüler/in Max Mustermann 16 Maurer/in UPDATE Das Update Statement wird verwendet, um Inhalte (Tabelle, Datenbank, Constraints, etc.) zu ändern. Ein UPDATE Statement ist grundsätzlich wie folgt aufgebaut:\n1 2 3 UPDATE table_name SET column1 = value1, column2 = value2, ... WHERE condition; Als Erstes kommt immer das “UPDATE” gefolgt von dem zu aktualisierenden Objekt, in diesem Fall eine Tabelle. Anschliessend wird ein SET durchgeführt, wo die gewünschte Änderung gemacht wird. Dabei können auch mehrere Attribute gleichzeitig geändert werden. Dazu kann hinter dem Wert ein Komma hinzugefügt werden und eine weitere Änderung angegeben werden. Nach dem SET kann optional ein WHERE hinzugefügt werden, wenn die aktualisierung nicht für alle Werte durchgeführt werden soll. Hier ein konkretes Beispiel dazu:\nAusgangstabelle:\nvorname nachname alter beruf Anja Ackermann 13 Schüler/in Fritz Fischer 26 Pilot/in Hans Hansen 52 Hochbauzeichner/in Max Mustermann 16 Maurer/in Dieses Statement setzt das Alter aller Benutzer mit dem Vornamen “Max” auf 18 und ändert den Beruf zu “Lehrer/in”\n1 2 3 UPDATE benutzer SET alter = 18, beruf = \"Lehrer/in\" WHERE vorname = \"Max\"; Resultat:\nvorname nachname alter beruf Anja Ackermann 13 Schüler/in Fritz Fischer 26 Pilot/in Hans Hansen 52 Hochbauzeichner/in Max Mustermann 18 Lehrer/in DELETE Wie es der Name schon sagt, wird das Delete Statement zum Löschen von Daten verwendet. Ein DELETE Statement ist grundsätzlich wie folgt aufgebaut:\n1 DELETE FROM table_name WHERE condition; Als Erstes kommt immer das “DELETE” gefolgt von FROM und der betroffenen Tabelle. Ein Delete sollte immer mit einem Where verwendet werden, da sonst alle Daten aus der Tabelle gelöscht werden. Hier ein konkretes Beispiel dazu:\nAusgangstabelle:\nvorname nachname alter beruf Anja Ackermann 13 Schüler/in Fritz Fischer 26 Pilot/in Hans Hansen 52 Hochbauzeichner/in Max Mustermann 18 Maurer/in Dieses Statement löscht alle Benutzer mit dem Vornamen “Max”.\n1 DELETE FROM benutzer WHERE vorname = \"Max\"; Resultat:\nvorname nachname alter beruf Anja Ackermann 13 Schüler/in Fritz Fischer 26 Pilot/in Hans Hansen 52 Hochbauzeichner/in Join Ähnlich wie Where ist Join kein eigenes Statement, sondern eine Erweiterung. Mit dem Join Keyword werden in einem Select mehrere Tabellen miteinander verbunden. Das wird benötigt wenn die gewünschten Daten sich nicht in einer sondern in mehreren Tabellen befinden. Zum Beispiel, wenn die Personalien und die Adresse einer Person in verschiedenen Tabellen gespeichert wird. Ein Join funktioniert eigentlich immer gleich, es gibt jeweils eine Tabelle A die mit der Tabelle B verbunden wird. Dazu wird jeweils eine Id oder zumindest ein Attribut verwendet, welches in beiden Tabellen vertreten ist. So wird dann die Verbindung hergestellt.\nBei Joins gibt es viele verschiedene und teilweise sehr komplexe Varianten, welche auch dementsprechend selten benutzt werden. Wir schauen uns hier die vier wichtigsten an.\nInner Join (join) Der Inner Join ist der wichtigste und am meisten benötigte Join. Der Inner Join verbindet die Tabellen und gibt nur die Schnittmenge zurück. Also alle Werte aus der Tabelle A, die auch ein Gegenstück in der Tabelle B haben. Grafisch dargestellt würde dieser Join so aus sehen:\nQuelle: https://www.geeksforgeeks.org/sql-join-set-1-inner-left-right-and-full-joins/\nDas dazugehörige Statement würde so aussehen:\n1 SELECT * FROM tabelle_a INNER JOIN tabelle_b ON tabelle_a.id = tabelle_b.id; Right und Left Join Im Vergleich zum Inner Join wird beim Right und Left Join nicht nur die Schnittmenge, sondern auch noch eine äussere Menge zurückgegeben. Grafisch würde das so aussehen:\nRight Join Quelle: https://www.geeksforgeeks.org/sql-join-set-1-inner-left-right-and-full-joins/\nLeft Join Quelle: https://www.geeksforgeeks.org/sql-join-set-1-inner-left-right-and-full-joins/\nDie äussere Menge ist jeweils eine der beiden angegebenen Tabellen. Welche Tabelle das verwendet wird, ist dabei abhängig vom Statement und welches Keyword verwendet wird. Schauen wir uns das in einem Beispiel an.\n1 SELECT * FROM tabelle_a RIGHT JOIN tabelle_b ON tabelle_a.id = tabelle_b.id; In diesem Query wird das Keyword RIGHT verwendet. Das bedeutet, dass die rechte Tabelle verwendet wird. Was definiert jetzt aber welches die rechte Tabelle ist? In diesem Fall ist tabelle_b die rechte Tabelle, da sie rechts vom JOIN steht. Dieser Logik entsprechend ist im unteren Beispiel tabelle_a die linke Tabelle, die also komplett zurückgegeben wird.\n1 SELECT * FROM tabelle_a LEFT JOIN tabelle_b ON tabelle_a.id = tabelle_b.id; Was jedoch bei einem Right und Left Join zu beachten ist, dass null Werte entstehen können. Bei allen Werten, die kein Gegenstück haben, werden die Attribute dieser Tabelle null sein. So würde das Resultat eines Left Joins aussehen:\nPerson:\nvorname nachname alter beruf_id Rolf Ringer 30 1 Loris Liechti 21 40 Beruf:\nberuf_id berufsbezeichnung 1 Lehrer/in 2 Informatiker/in Statement:\n1 SELECT * FROM person LEFT JOIN beruf ON person.beruf_id = beruf.beruf_id; Resultat:\nvorname nachname alter beruf_id beruf_id berufsbezeichnung Rolf Ringer 30 1 1 Lehrer/in Loris Liechti 21 40 null null beruf_id ist doppelt, da es in beiden Tabellen ein Attribut mit diesem Namen gibt. Könnte mit der Auswahl im Select auch ausgeblendet werden.\nUmgekehrt würde das ganze so aussehen:\nStatement:\n1 SELECT * FROM person RIGHT JOIN beruf ON person.beruf_id = beruf.beruf_id; Resultat:\nvorname nachname alter beruf_id beruf_id berufsbezeichnung Rolf Ringer 30 1 1 Lehrer/in null null null null 2 Informatiker/in beruf_id ist doppelt, da es in beiden Tabellen ein Attribut mit diesem Namen gibt. Könnte mit der Auswahl im Select auch ausgeblendet werden.\nFull Join Der Full Join ist sehr eng mit dem Left und Right Join verwandt. Jetzt werden jedoch alle Werte zurückgegeben. Wenn kein Gegenstück zu einem Wert vorhanden ist, werden diese gleich wie beim Left und Right Join mit null angegeben. Grafisch sieht das ganze so aus:\nQuelle: https://www.geeksforgeeks.org/sql-join-set-1-inner-left-right-and-full-joins/\nDas Statement würde schlussendlich so aussehen:\n1 SELECT * FROM tabelle_a FULL JOIN tabelle_b ON tabelle_a.id = tabelle_b.id; Mit dem vorherigen Beispiel würde das Resultat so aussehen:\nPerson:\nvorname nachname alter beruf_id Rolf Ringer 30 1 Loris Liechti 21 40 Beruf:\nberuf_id berufsbezeichnung 1 Lehrer/in 2 Informatiker/in Resultat:\nvorname nachname alter beruf_id beruf_id berufsbezeichnung Rolf Ringer 30 1 1 Lehrer/in null null null null 2 Informatiker/in Loris Liechti 21 40 null null beruf_id ist doppelt, da es in beiden Tabellen ein Attribut mit diesem Namen gibt. Könnte mit der Auswahl im Select auch ausgeblendet werden.\nAggregationen \u0026 weiteres In diesem Abschnitt gehen wird auf Aggregationen und weitere wichtige Syntax-Elemente ein. Aggregationen in SQL sind Funktionen, die verwendet werden, um zusammengefasste Informationen aus großen Datenmengen zu erhalten. Dadurch wird es einfacher, die Daten zu analysieren und Muster oder Trends zu erkennen.\nCount Die Aggregation Count zählt wie viele Resultate das beim Query zurückgegeben werden. Count funktioniert bei allen Datentypen gleich und muss nicht angepasst werden. Hier ein Beispiel zu Count:\nAusgangstabelle Person:\nvorname nachname alter beruf Anja Ackermann 13 Schüler/in Fritz Fischer 26 Pilot/in Hans Hansen 52 Hochbauzeichner/in Max Mustermann 18 Maurer/in Leo Leonidas 35 null Statement:\n1 SELECT COUNT(*), COUNT(beruf) FROM person; Resultat:\ncount(*) count(beruf) 5 4 Aus dem Resultat lässt sich schliessen, dass NULL-Werte im Count nicht beachtet werden.\nMax/Min Die Aggregationen Max und Min sind logischerweise zum Finden des grössten und kleinsten Wertes. Beide funktionieren bei allen Datentypen, jedoch haben sie beispielsweise bei einem String einen anderen Weg das Maximum und Minimum zu finden. Dort wird anhand einer Collation (Sortierungsregel) das Maximum und Minimum bestimmt. Bei normalen Zahlen sieht es so aus:\nAusgangstabelle Person:\nvorname nachname alter beruf Anja Ackermann 13 Schüler/in Fritz Fischer 26 Pilot/in Hans Hansen 52 Hochbauzeichner/in Max Mustermann 18 Maurer/in Leo Leonidas 35 null Statement:\n1 SELECT MAX(alter), MIN(alter) FROM person; Resultat:\nmax(alter) min(alter) 52 13 Sum Sum summiert die Werte einer Spalte. Im Gegensatz zu den vorherigen Aggregationen funktioniert Sum nur mit Zahlenwerten. Bei Strings oder ähnlichem wird ein Fehler zurückgegeben. Hier ein Beispiel zur Verwendung von Sum:\nAusgangstabelle Person:\nvorname nachname alter beruf Anja Ackermann 13 Schüler/in Fritz Fischer 26 Pilot/in Hans Hansen 52 Hochbauzeichner/in Max Mustermann 18 Maurer/in Leo Leonidas 35 null Statement:\n1 SELECT SUM(alter) FROM person; Resultat:\nsum(alter) 144 Avg Um den Durchschnitt von Zahlen zu finden wird die Funktion AVG verwendet. Gleich wie Sum funktioniert Avg nur mit Zahlen. Hier ein Beispiel zu avg:\nAusgangstabelle Person:\nvorname nachname alter beruf Anja Ackermann 13 Schüler/in Fritz Fischer 26 Pilot/in Hans Hansen 52 Hochbauzeichner/in Max Mustermann 18 Maurer/in Leo Leonidas 35 null Statement:\n1 SELECT AVG(alter) FROM person; Resultat:\navg(alter) 28.8 Order By Das Keyword Order By ist zum Sortieren des Resultats sehr nützlich. Zusammen mit ASC (=Ascending, Aufsteigend) und DESC (=Descending, Absteigend) kann das Resultat auf verschiedenste Weisen nach einem oder mehreren Attributen sortiert werden. Standardmässig verwendet Order By ASC, daher kann das ASC im Query auch weggelassen werden. Beispiel zu Order By:\nAusgangstabelle Person:\nvorname nachname alter beruf Anja Ackermann 13 Schüler/in Fritz Fischer 26 Pilot/in Hans Hansen 52 Hochbauzeichner/in Max Mustermann 18 Maurer/in Leo Leonidas 35 null Statement ASC:\n1 SELECT vorname, alter FROM person ORDER BY alter ASC; Resultat:\nvorname alter Anja 13 Max 18 Fritz 26 Leo 35 Hans 52 Statement DESC:\n1 SELECT vorname, alter FROM person ORDER BY alter DESC; Resultat:\nvorname alter Hans 52 Leo 35 Fritz 26 Max 18 Anja 13 Group By Mit Group By können Tupel mit gleichen Werten bei einem Attribut zusammen geführt werden, um beispielsweise in einem Count gezählt zu werden. Wie bei Order By kann ein Resultat mehrfach gruppiert werden. Hier ein einfaches Beispiel zu Order By:\nAusgangstabelle Person:\nvorname nachname alter beruf Anja Ackermann 13 Hochbauzeichner/in Fritz Fischer 26 Pilot/in Hans Hansen 52 Hochbauzeichner/in Max Mustermann 18 Pilot/in Leo Leonidas 35 Pilot/in Statement:\n1 SELECT COUNT(*), beruf FROM person GROUP BY beruf; Resultat:\ncount(*) beruf 2 Hochbauzeichner/in 3 Pilot/in ","categories":"","description":"","excerpt":"Ziele Du weisst wofür SQL verwendet wird Du kennst die verschiedenen …","ref":"/docs/05_database/02_sql-syntax/","tags":"","title":"SQL Syntax"},{"body":"Ziele Du weisst wofür SQL verwendet wird Du kennst die verschiedenen Statements in SQL Du kannst einfache SQL Queries/Statements schreiben Was ist SQL? SQL oder „Structured Query Language“ ist eine Programmiersprache für die Bearbeitung von Daten und relationalen Datenbanksystemen. Diese Sprache wird hauptsächlich für die Kommunikation mit Datenbanken verwendet, um die darin enthaltenen Daten zu verwalten.\nStatements Was ist ein SQL Statement? Ganz einfach gesagt ist ein Statement ein Befehl, der an die Datenbank geschickt und dort ausgeführt wird. Es gibt viele verschiedene Statements, die teilweise kombiniert werden können, um den gewünschten Effekt auf der Datenbank zu erzielen. Grundsätzlich werden Teile der Syntax (Select, Insert, usw.) gross geschrieben, um eine Unterscheidung zwischen der Syntax und anderen Elementen wie tabellennamen usw. zu erhalten. Jedoch ist diese Regel nicht erzwungen.\nSELECT Das Select Statement wird verwendet, um Daten aus bestimmten Tabellen auszuwählen. Ein SELECT ist grundsätzlich wie folgt aufgebaut:\n1 2 3 4 SELECT * FROM table_name; -- Beispiel mit der Tabelle \"benutzer\" SELECT * from benutzer; Als Erstes kommt immer das “SELECT” gefolgt von den gewünschten Attribute. In diesem Statement wird ein Stern verwendet, dieser steht für alle Attribute. Dementsprechend werden alle Attribute, die in der Tabelle vorhanden sind, zurückgegeben. Auf die Attribute folgt das FROM, auf dieses folgt jeweils eine Tabelle, von welcher die Werte gewünscht sind. Im Beispiel ist es die Tabelle “benutzer”. Das Resultat dieses Statements würde schlussendlich so aussehen:\nvorname nachname alter beruf Anja Ackermann 13 Schüler/in Fritz Fischer 26 Pilot/in Hans Hansen 52 Hochbauzeichner/in Wenn wir nur eine Spalte auswählen möchten, können wir das Statement wie folgt anpassen:\n1 2 3 4 SELECT column_name FROM table_name; --Beispiel mit der Tabelle \"benutzer\" SELECT vorname FROM benutzer; Das Resultat würde dementsprechend so aussehen:\nvorname Anja Fritz Hans INSERT Das Insert Statement wird verwendet, um Daten in eine bestimmte Tabelle einzufügen. Ein INSERT ist grundsätzlich wie folgt aufgebaut:\n1 INSERT INTO table_name (column1, column2, column3, ...) VALUES (value1, value2, value3, ...); Als Erstes kommt immer das “INSERT INTO” gefolgt von der betroffenen Tabelle. Schlussendlich wird mit VALUES angegeben, dass ein oder mehrere Tupel eingefügt werden. In den Klammern können respektiv die Spaltennamen (optional) und die Inhalte angegeben werden.\nEin konkretes Beispiel würde mit dieser Tabelle beginnen:\nvorname nachname alter beruf Anja Ackermann 13 Schüler/in Fritz Fischer 26 Pilot/in Hans Hansen 52 Hochbauzeichner/in Dann wird dieses INSERT Statement ausgeführt:\n1 INSERT INTO benutzer VALUES (\"Max\", \"Mustermann\", 16, \"Maurer/in\"); Nach dem Statement ist der neue Benutzer Max in der Tabelle zu finden:\nvorname nachname alter beruf Anja Ackermann 13 Schüler/in Fritz Fischer 26 Pilot/in Hans Hansen 52 Hochbauzeichner/in Max Mustermann 16 Maurer/in Alternativ zum vorherigen Statement können auch nur bestimmte Daten eingefügt werden. In unserem Beispiel könnte ein Benutzer auch Arbeitslos sein, dementsprechend hätte er keinen Beruf. Wenn wir also so einen Benutzer hinzufügen möchten würden wir das wie folgt machen:\n1 INSERT INTO benutzer(vorname, nachname, alter) VALUES (\"Peter\", \"Piccolo\", 37); In den Klammern nach der Tabelle können wir also die Attribute auswählen, die wir hinzufügen möchten. In der Tabelle würde es so aussehen:\nvorname nachname alter beruf Anja Ackermann 13 Schüler/in Fritz Fischer 26 Pilot/in Hans Hansen 52 Hochbauzeichner/in Max Mustermann 16 Maurer/in Peter Piccolo 37 null Der Beruf wurde automatisch auf null gesetzt und ist dementsprechend leer.\nCREATE Das Create Statement wird verwendet, um Tabellen, Datenbanken, usw. zu erstellen. Ein CREATE Statement ist grundsätzlich wie folgt aufgebaut:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 -- Datenbank erstellen CREATE DATABASE databasename; --Tabelle erstellen CREATE TABLE table_name ( column1 datatype, column2 datatype, column3 datatype, .... ); -- Beispiel: die Tabelle \"benutzer\" erstellen CREATE TABLE benutzer (vorname varchar(255), nachname varchar(255), alter number, beruf varchar(255)); Als Erstes kommt immer das “CREATE” gefolgt dem zu erstellenden Objekt, in diesem Fall eine Tabelle. Schlussendlich wird noch ein Name festgelegt (die neue Tabelle heisst “benutzer”), gefolgt von den gewünschten Attributen der Tabelle und dem entsprechenden Datentyp.\nDas Resultat dieses Statements würde schliesslich so aussehen:\nvorname nachname alter beruf WHERE Die WHERE-Klausel ist im Vergleich zu den anderen kein Statement, sondern eine Ergänzung dazu. Mit WHERE kann spezifiziert werden, welche Daten für das Statement verwendet werden sollen. Mehrere Bedingungen können mit den Keywords AND und OR aneinandergereiht werden. Hier ein Beispiel dazu:\nAusgangstabelle:\nvorname nachname alter beruf Anja Ackermann 13 Schüler/in Fritz Fischer 26 Pilot/in Hans Hansen 52 Hochbauzeichner/in Max Mustermann 16 Maurer/in Dieses Statement schränkt das Alter zwischen 15 und 30 Jahren ein.\n1 SELECT * FROM benutzer WHERE alter \u003e 15 AND alter \u003c 30; Das Statement gibt schliesslich alle Werte zurück, die die Bedingung erfüllen:\nvorname nachname alter beruf Fritz Fischer 26 Pilot/in Max Mustermann 16 Maurer/in Zusätzlich gibt es bei Texten die Möglichkeit eine Teilüberprüfung mit Like zu machen. Damit können beispielsweise Alle Adressen gesucht werden, die mit “Strasse” enden. Dazu muss beim Like angegeben werden, wo sich der Rest des Textes befinden. Das funktioniert mit dem % Zeichen. Wenn der restliche Text vor dem Suchtext ist, wird das % vor diesem platziert. Dasselbe funktioniert natürlich auch umgekehrt. Weiter kann auch auf beiden Seiten ein % verwendet werden, so ist es egal wo sich der Suchtext befinden. Hier ein Beispiel-Query dazu:\nAusgangstabelle:\nvorname nachname alter beruf Anja Ackermann 13 Schüler/in Fritz Fischer 26 Pilot/in Hans Hansen 52 Hochbauzeichner/in Max Mustermann 16 Maurer/in 1 SELECT * FROM person WHERE nachname like '%mann' Resultat:\nvorname nachname alter beruf Anja Ackermann 13 Schüler/in Max Mustermann 16 Maurer/in UPDATE Das Update Statement wird verwendet, um Inhalte (Tabelle, Datenbank, Constraints, etc.) zu ändern. Ein UPDATE Statement ist grundsätzlich wie folgt aufgebaut:\n1 2 3 UPDATE table_name SET column1 = value1, column2 = value2, ... WHERE condition; Als Erstes kommt immer das “UPDATE” gefolgt von dem zu aktualisierenden Objekt, in diesem Fall eine Tabelle. Anschliessend wird ein SET durchgeführt, wo die gewünschte Änderung gemacht wird. Dabei können auch mehrere Attribute gleichzeitig geändert werden. Dazu kann hinter dem Wert ein Komma hinzugefügt werden und eine weitere Änderung angegeben werden. Nach dem SET kann optional ein WHERE hinzugefügt werden, wenn die aktualisierung nicht für alle Werte durchgeführt werden soll. Hier ein konkretes Beispiel dazu:\nAusgangstabelle:\nvorname nachname alter beruf Anja Ackermann 13 Schüler/in Fritz Fischer 26 Pilot/in Hans Hansen 52 Hochbauzeichner/in Max Mustermann 16 Maurer/in Dieses Statement setzt das Alter aller Benutzer mit dem Vornamen “Max” auf 18 und ändert den Beruf zu “Lehrer/in”\n1 2 3 UPDATE benutzer SET alter = 18, beruf = \"Lehrer/in\" WHERE vorname = \"Max\"; Resultat:\nvorname nachname alter beruf Anja Ackermann 13 Schüler/in Fritz Fischer 26 Pilot/in Hans Hansen 52 Hochbauzeichner/in Max Mustermann 18 Lehrer/in DELETE Wie es der Name schon sagt, wird das Delete Statement zum Löschen von Daten verwendet. Ein DELETE Statement ist grundsätzlich wie folgt aufgebaut:\n1 DELETE FROM table_name WHERE condition; Als Erstes kommt immer das “DELETE” gefolgt von FROM und der betroffenen Tabelle. Ein Delete sollte immer mit einem Where verwendet werden, da sonst alle Daten aus der Tabelle gelöscht werden. Hier ein konkretes Beispiel dazu:\nAusgangstabelle:\nvorname nachname alter beruf Anja Ackermann 13 Schüler/in Fritz Fischer 26 Pilot/in Hans Hansen 52 Hochbauzeichner/in Max Mustermann 18 Maurer/in Dieses Statement löscht alle Benutzer mit dem Vornamen “Max”.\n1 DELETE FROM benutzer WHERE vorname = \"Max\"; Resultat:\nvorname nachname alter beruf Anja Ackermann 13 Schüler/in Fritz Fischer 26 Pilot/in Hans Hansen 52 Hochbauzeichner/in Join Ähnlich wie Where ist Join kein eigenes Statement, sondern eine Erweiterung. Mit dem Join Keyword werden in einem Select mehrere Tabellen miteinander verbunden. Das wird benötigt wenn die gewünschten Daten sich nicht in einer sondern in mehreren Tabellen befinden. Zum Beispiel, wenn die Personalien und die Adresse einer Person in verschiedenen Tabellen gespeichert wird. Ein Join funktioniert eigentlich immer gleich, es gibt jeweils eine Tabelle A die mit der Tabelle B verbunden wird. Dazu wird jeweils eine Id oder zumindest ein Attribut verwendet, welches in beiden Tabellen vertreten ist. So wird dann die Verbindung hergestellt.\nBei Joins gibt es viele verschiedene und teilweise sehr komplexe Varianten, welche auch dementsprechend selten benutzt werden. Wir schauen uns hier die vier wichtigsten an.\nInner Join (join) Der Inner Join ist der wichtigste und am meisten benötigte Join. Der Inner Join verbindet die Tabellen und gibt nur die Schnittmenge zurück. Also alle Werte aus der Tabelle A, die auch ein Gegenstück in der Tabelle B haben. Grafisch dargestellt würde dieser Join so aus sehen:\nQuelle: https://www.geeksforgeeks.org/sql-join-set-1-inner-left-right-and-full-joins/\nDas dazugehörige Statement würde so aussehen:\n1 SELECT * FROM tabelle_a INNER JOIN tabelle_b ON tabelle_a.id = tabelle_b.id; Right und Left Join Im Vergleich zum Inner Join wird beim Right und Left Join nicht nur die Schnittmenge, sondern auch noch eine äussere Menge zurückgegeben. Grafisch würde das so aussehen:\nRight Join Quelle: https://www.geeksforgeeks.org/sql-join-set-1-inner-left-right-and-full-joins/\nLeft Join Quelle: https://www.geeksforgeeks.org/sql-join-set-1-inner-left-right-and-full-joins/\nDie äussere Menge ist jeweils eine der beiden angegebenen Tabellen. Welche Tabelle das verwendet wird, ist dabei abhängig vom Statement und welches Keyword verwendet wird. Schauen wir uns das in einem Beispiel an.\n1 SELECT * FROM tabelle_a RIGHT JOIN tabelle_b ON tabelle_a.id = tabelle_b.id; In diesem Query wird das Keyword RIGHT verwendet. Das bedeutet, dass die rechte Tabelle verwendet wird. Was definiert jetzt aber welches die rechte Tabelle ist? In diesem Fall ist tabelle_b die rechte Tabelle, da sie rechts vom JOIN steht. Dieser Logik entsprechend ist im unteren Beispiel tabelle_a die linke Tabelle, die also komplett zurückgegeben wird.\n1 SELECT * FROM tabelle_a LEFT JOIN tabelle_b ON tabelle_a.id = tabelle_b.id; Was jedoch bei einem Right und Left Join zu beachten ist, dass null Werte entstehen können. Bei allen Werten, die kein Gegenstück haben, werden die Attribute dieser Tabelle null sein. So würde das Resultat eines Left Joins aussehen:\nPerson:\nvorname nachname alter beruf_id Rolf Ringer 30 1 Loris Liechti 21 40 Beruf:\nberuf_id berufsbezeichnung 1 Lehrer/in 2 Informatiker/in Statement:\n1 SELECT * FROM person LEFT JOIN beruf ON person.beruf_id = beruf.beruf_id; Resultat:\nvorname nachname alter beruf_id beruf_id berufsbezeichnung Rolf Ringer 30 1 1 Lehrer/in Loris Liechti 21 40 null null beruf_id ist doppelt, da es in beiden Tabellen ein Attribut mit diesem Namen gibt. Könnte mit der Auswahl im Select auch ausgeblendet werden.\nUmgekehrt würde das ganze so aussehen:\nStatement:\n1 SELECT * FROM person RIGHT JOIN beruf ON person.beruf_id = beruf.beruf_id; Resultat:\nvorname nachname alter beruf_id beruf_id berufsbezeichnung Rolf Ringer 30 1 1 Lehrer/in null null null null 2 Informatiker/in beruf_id ist doppelt, da es in beiden Tabellen ein Attribut mit diesem Namen gibt. Könnte mit der Auswahl im Select auch ausgeblendet werden.\nFull Join Der Full Join ist sehr eng mit dem Left und Right Join verwandt. Jetzt werden jedoch alle Werte zurückgegeben. Wenn kein Gegenstück zu einem Wert vorhanden ist, werden diese gleich wie beim Left und Right Join mit null angegeben. Grafisch sieht das ganze so aus:\nQuelle: https://www.geeksforgeeks.org/sql-join-set-1-inner-left-right-and-full-joins/\nDas Statement würde schlussendlich so aussehen:\n1 SELECT * FROM tabelle_a FULL JOIN tabelle_b ON tabelle_a.id = tabelle_b.id; Mit dem vorherigen Beispiel würde das Resultat so aussehen:\nPerson:\nvorname nachname alter beruf_id Rolf Ringer 30 1 Loris Liechti 21 40 Beruf:\nberuf_id berufsbezeichnung 1 Lehrer/in 2 Informatiker/in Resultat:\nvorname nachname alter beruf_id beruf_id berufsbezeichnung Rolf Ringer 30 1 1 Lehrer/in null null null null 2 Informatiker/in Loris Liechti 21 40 null null beruf_id ist doppelt, da es in beiden Tabellen ein Attribut mit diesem Namen gibt. Könnte mit der Auswahl im Select auch ausgeblendet werden.\nAggregationen \u0026 weiteres In diesem Abschnitt gehen wird auf Aggregationen und weitere wichtige Syntax-Elemente ein. Aggregationen in SQL sind Funktionen, die verwendet werden, um zusammengefasste Informationen aus großen Datenmengen zu erhalten. Dadurch wird es einfacher, die Daten zu analysieren und Muster oder Trends zu erkennen.\nCount Die Aggregation Count zählt wie viele Resultate das beim Query zurückgegeben werden. Count funktioniert bei allen Datentypen gleich und muss nicht angepasst werden. Hier ein Beispiel zu Count:\nAusgangstabelle Person:\nvorname nachname alter beruf Anja Ackermann 13 Schüler/in Fritz Fischer 26 Pilot/in Hans Hansen 52 Hochbauzeichner/in Max Mustermann 18 Maurer/in Leo Leonidas 35 null Statement:\n1 SELECT COUNT(*), COUNT(beruf) FROM person; Resultat:\ncount(*) count(beruf) 5 4 Aus dem Resultat lässt sich schliessen, dass NULL-Werte im Count nicht beachtet werden.\nMax/Min Die Aggregationen Max und Min sind logischerweise zum Finden des grössten und kleinsten Wertes. Beide funktionieren bei allen Datentypen, jedoch haben sie beispielsweise bei einem String einen anderen Weg das Maximum und Minimum zu finden. Dort wird anhand einer Collation (Sortierungsregel) das Maximum und Minimum bestimmt. Bei normalen Zahlen sieht es so aus:\nAusgangstabelle Person:\nvorname nachname alter beruf Anja Ackermann 13 Schüler/in Fritz Fischer 26 Pilot/in Hans Hansen 52 Hochbauzeichner/in Max Mustermann 18 Maurer/in Leo Leonidas 35 null Statement:\n1 SELECT MAX(alter), MIN(alter) FROM person; Resultat:\nmax(alter) min(alter) 52 13 Sum Sum summiert die Werte einer Spalte. Im Gegensatz zu den vorherigen Aggregationen funktioniert Sum nur mit Zahlenwerten. Bei Strings oder ähnlichem wird ein Fehler zurückgegeben. Hier ein Beispiel zur Verwendung von Sum:\nAusgangstabelle Person:\nvorname nachname alter beruf Anja Ackermann 13 Schüler/in Fritz Fischer 26 Pilot/in Hans Hansen 52 Hochbauzeichner/in Max Mustermann 18 Maurer/in Leo Leonidas 35 null Statement:\n1 SELECT SUM(alter) FROM person; Resultat:\nsum(alter) 144 Avg Um den Durchschnitt von Zahlen zu finden wird die Funktion AVG verwendet. Gleich wie Sum funktioniert Avg nur mit Zahlen. Hier ein Beispiel zu avg:\nAusgangstabelle Person:\nvorname nachname alter beruf Anja Ackermann 13 Schüler/in Fritz Fischer 26 Pilot/in Hans Hansen 52 Hochbauzeichner/in Max Mustermann 18 Maurer/in Leo Leonidas 35 null Statement:\n1 SELECT AVG(alter) FROM person; Resultat:\navg(alter) 28.8 Order By Das Keyword Order By ist zum Sortieren des Resultats sehr nützlich. Zusammen mit ASC (=Ascending, Aufsteigend) und DESC (=Descending, Absteigend) kann das Resultat auf verschiedenste Weisen nach einem oder mehreren Attributen sortiert werden. Standardmässig verwendet Order By ASC, daher kann das ASC im Query auch weggelassen werden. Beispiel zu Order By:\nAusgangstabelle Person:\nvorname nachname alter beruf Anja Ackermann 13 Schüler/in Fritz Fischer 26 Pilot/in Hans Hansen 52 Hochbauzeichner/in Max Mustermann 18 Maurer/in Leo Leonidas 35 null Statement ASC:\n1 SELECT vorname, alter FROM person ORDER BY alter ASC; Resultat:\nvorname alter Anja 13 Max 18 Fritz 26 Leo 35 Hans 52 Statement DESC:\n1 SELECT vorname, alter FROM person ORDER BY alter DESC; Resultat:\nvorname alter Hans 52 Leo 35 Fritz 26 Max 18 Anja 13 Group By Mit Group By können Tupel mit gleichen Werten bei einem Attribut zusammen geführt werden, um beispielsweise in einem Count gezählt zu werden. Wie bei Order By kann ein Resultat mehrfach gruppiert werden. Hier ein einfaches Beispiel zu Order By:\nAusgangstabelle Person:\nvorname nachname alter beruf Anja Ackermann 13 Hochbauzeichner/in Fritz Fischer 26 Pilot/in Hans Hansen 52 Hochbauzeichner/in Max Mustermann 18 Pilot/in Leo Leonidas 35 Pilot/in Statement:\n1 SELECT COUNT(*), beruf FROM person GROUP BY beruf; Resultat:\ncount(*) beruf 2 Hochbauzeichner/in 3 Pilot/in ","categories":"","description":"","excerpt":"Ziele Du weisst wofür SQL verwendet wird Du kennst die verschiedenen …","ref":"/de/docs/05_database/02_sql-syntax/","tags":"","title":"SQL Syntax"},{"body":"Übung 1 In der ersten Übung sollst du anhand eines Textes ein ERD erstellen. Du sollst für einen Kunden ein ERD für einen Online-Shop erstellen. Der Kunde gibt dir folgende Informationen:\nDer Online-Shop verfügt über Produkte, Kunden und Bestellungen. Ein Kunde kann mehrere Produkte bestellen, und eine Bestellung kann mehrere Produkte enthalten. Die Produkte haben Eigenschaften wie Name, Beschreibung und Preis.\nHier sind einige grundlegende Informationen, die dir helfen sollen, ein ERD für den Online-Shop zu erstellen:\nProdukte: Jedes Produkt hat eine eindeutige Produkt-ID, einen Namen, eine Beschreibung und einen Preis. Kunden: Jeder Kunde hat eine eindeutige Kunden-ID, einen Vornamen, einen Nachnamen, eine Adresse und eine E-Mail-Adresse. Bestellungen: Jede Bestellung hat eine eindeutige Bestell-ID, ein Bestelldatum und ist einem bestimmten Kunden zugeordnet. Bestellpositionen: Eine Bestellung kann mehrere Positionen enthalten, und jede Position ist einem bestimmten Produkt zugeordnet. Eine Position enthält Informationen wie die Produktmenge. Erstelle das ERD mithilfe von Draw.io so, dass die 3NF erreicht wird. Schaue anschliessend das fertige ERD mit einem Praxisbildner an, um Feedback dazu zu erhalten.\nÜbung 2 Erstelle anhand dieses ERDs eine Datenbank. Verwende hierbei die deiner Meinung nach richtigen Datentypen. Die Datenbank soll die 3NF erreichen. Achtung! das ERD ist nicht in der 3NF. Schau deine fertige Datenbank mit einem Praxisbildner an.\nÜbung 3 In dieser Übung geht es darum, mit deinen SQL-Kenntnissen einen Mord zu lösen. Ziel ist es, dass du alle Rätsel löst und das letzte Query mit einem Praxisbildner anschaust. Beim Lösen empfiehlt es sich Zwischenschritte aufzuschreiben, um die Übersicht zu behalten. Falls du diese Zwischenschritte auch mit einem Praxisbildner anschauen möchtest, ist dies auch möglich. SQL Murder Mystery\n","categories":"","description":"","excerpt":"Übung 1 In der ersten Übung sollst du anhand eines Textes ein ERD …","ref":"/labs/05_database/02_sql_syntax/","tags":"","title":"SQL Syntax"},{"body":"Übung 1 In der ersten Übung sollst du anhand eines Textes ein ERD erstellen. Du sollst für einen Kunden ein ERD für einen Online-Shop erstellen. Der Kunde gibt dir folgende Informationen:\nDer Online-Shop verfügt über Produkte, Kunden und Bestellungen. Ein Kunde kann mehrere Produkte bestellen, und eine Bestellung kann mehrere Produkte enthalten. Die Produkte haben Eigenschaften wie Name, Beschreibung und Preis.\nHier sind einige grundlegende Informationen, die dir helfen sollen, ein ERD für den Online-Shop zu erstellen:\nProdukte: Jedes Produkt hat eine eindeutige Produkt-ID, einen Namen, eine Beschreibung und einen Preis. Kunden: Jeder Kunde hat eine eindeutige Kunden-ID, einen Vornamen, einen Nachnamen, eine Adresse und eine E-Mail-Adresse. Bestellungen: Jede Bestellung hat eine eindeutige Bestell-ID, ein Bestelldatum und ist einem bestimmten Kunden zugeordnet. Bestellpositionen: Eine Bestellung kann mehrere Positionen enthalten, und jede Position ist einem bestimmten Produkt zugeordnet. Eine Position enthält Informationen wie die Produktmenge. Erstelle das ERD mithilfe von Draw.io so, dass die 3NF erreicht wird. Schaue anschliessend das fertige ERD mit einem Praxisbildner an, um Feedback dazu zu erhalten.\nÜbung 2 Erstelle anhand dieses ERDs eine Datenbank. Verwende hierbei die deiner Meinung nach richtigen Datentypen. Die Datenbank soll die 3NF erreichen. Achtung! das ERD ist nicht in der 3NF. Schau deine fertige Datenbank mit einem Praxisbildner an.\nÜbung 3 In dieser Übung geht es darum, mit deinen SQL-Kenntnissen einen Mord zu lösen. Ziel ist es, dass du alle Rätsel löst und das letzte Query mit einem Praxisbildner anschaust. Beim Lösen empfiehlt es sich Zwischenschritte aufzuschreiben, um die Übersicht zu behalten. Falls du diese Zwischenschritte auch mit einem Praxisbildner anschauen möchtest, ist dies auch möglich. SQL Murder Mystery\n","categories":"","description":"","excerpt":"Übung 1 In der ersten Übung sollst du anhand eines Textes ein ERD …","ref":"/de/labs/05_database/02_sql_syntax/","tags":"","title":"SQL Syntax"},{"body":" Dieses Kapitel gehört zum Modul #J1 des Ausbildungsplans Ziele Ich weiss, was Variablen sind. Ich kann eine Variable $deklarieren und initialisieren. ⏱️ Geschätzte Lesezeit: 10 Minuten Was sind Variablen? Eine Variable dient dazu, einen Wert zu speichern, damit man später darauf zugreifen oder ihn mehrfach verwenden kann.\nSchau dir dieses leicht abgeänderte Hello-World-Beispiel an:\n1 2 3 4 5 6 public class HelloWorld { public static void main(String[] args) { var nachricht = \"Hello, world!\"; System.out.println(nachricht); } } Was passiert hier?\nvar nachricht = \"Hello, world!\"; erstellt eine neue Variable namens nachricht und speichert den Text darin. Mit System.out.println(nachricht); wird der gespeicherte Text ausgegeben. Du kannst jetzt denselben Text mehrfach ausgeben, ohne ihn mehrfach zu schreiben:\n1 2 3 System.out.println(nachricht); System.out.println(nachricht); System.out.println(nachricht); Das macht deinen Code übersichtlicher und leichter wartbar.\nDeklaration Bevor du eine Variable verwenden kannst, musst du sie deklarieren. Dabei gibst du ihren Typ und ihren Namen an:\n1 \u003cTyp\u003e \u003cName\u003e; Zum Beispiel:\n1 String nachricht; Hier ist String der Datentyp (für Text) und nachricht der Name der Variable.\nMit var kannst du seit Java 10 den Typ weglassen – der Compiler erkennt ihn automatisch. Wir zeigen aber beide Varianten, weil der explizite Typ in vielen Projekten bevorzugt wird.\nInitialisierung Eine Initialisierung weist einer deklarierten Variable einen Wert zu:\n1 \u003cTyp\u003e \u003cName\u003e = \u003cWert\u003e; Beispiel:\n1 int zahl = 3; Du kannst eine Variable auch zuerst deklarieren und später initialisieren:\n1 2 int zahl; // Deklaration zahl = 3; // Initialisierung Oder beides in einer Zeile:\n1 int zahl = 3; Wichtige Regel für lokale Variablen Lokale Variablen (also solche, die in einer Methode deklariert sind) müssen initialisiert werden, bevor du sie verwendest:\n1 2 3 4 5 6 7 public class Beispiel { public static void main(String[] args) { int a = 1; int b; int summe = a + b; // Fehler! } } Dieser Code führt zu folgendem Fehler:\n1 error: variable b might not have been initialized Lösung:\n1 int b = 2; Namenskonventionen für Variablen Beim Benennen von Variablen beachtest du folgende Regeln:\nDer Name beginnt mit einem Kleinbuchstaben. Er darf Buchstaben (A–Z, a–z), Ziffern (0–9), $ und _ enthalten. Der Name darf nicht mit einer Ziffer beginnen. Der Name sollte den Inhalt der Variable beschreiben (z. B. summe für das Ergebnis einer Addition). Beispiele für gültige Namen:\n1 2 3 int alter; double preisProStunde; String benutzername; Du wirst während deiner Ausbildung noch mehrmals Regeln sehen, was wie benannt oder strukturiert werden soll. In der Fachsprache nennen wir das Coding Guidelines und für Java findest du unsere Regeln hier. Zusammenfassung Begriff Bedeutung Deklaration Eine Variable benennen und ihren Typ angeben (int zahl;) Initialisierung Einer Variable einen Wert zuweisen (zahl = 5;) Zuweisung Eine bestehende Variable erhält einen neuen Wert Lernvideo Wenn du dir die Erklärung noch mit einem Video anschauen möchtest, empfehlen wir dir dieses Video (YouTube, bis 4:25). ","categories":"","description":"In diesem Module lernst du, was Variablen sind und für was sie gebraucht werden.\n","excerpt":"In diesem Module lernst du, was Variablen sind und für was sie …","ref":"/docs/02_java/03_java-grundlagen/02_variables/","tags":"","title":"Variablen in Java"},{"body":"Ziele Ich weiss, was Variablen sind. Ich kann eine Variable deklarieren und initialisieren. Variablen Auf der letzten Seite hast du ein kleines “Hello World” geschrieben, welches den Text “Hello, world!” in der Konsole ausschreibt. Stelle sicher, dass dieses Programm bei dir auch läuft.\nÄndere dann den Code leicht ab in diesen und führe ihn aus:\n1 2 3 4 5 6 7 public class HelloWorld { public static void main(String[] args) { var nachricht = \"Hello, world!\"; System.out.println(nachricht); } } In diesem Beispiel haben wir den Text, den wir ausgeben wollen (“Hello, world!”), in eine sogenannte “Variable” mit dem Namen nachricht ausgelagert:\n1 var nachricht = \"Hello, world!\"; Aber was macht dieser Code?\nMit dem Keyword var teilen wir mit, dass wir eine neue Variable definieren. Mit var nachricht deklarieren wir eine neue Variable mit dem Namen nachricht. Mit dem =-Operator teilen wir mit, dass wir der Variable den Wert von der rechten Seite zuweisen möchten. Die Variable nachricht wird dann also den Wert \"Hello, world!\" enthalten. Mit dem Semikolon (\";\") teilen wir mit, dass diese Anweisung (also die Zuweisung der Variable) abgeschlossen ist. Aber was genau bringt mir das jetzt?\nVariablen werden dazu verwendet, um Werte zu speichern und später ein- oder mehrmals darauf zuzugreifen. Möchtest du beispielsweise diesen Text 5 mal ausgeben, dann könntest du das wie folgt tun:\n1 2 3 4 5 6 7 8 9 10 11 public class HelloWorld { public static void main(String[] args) { var nachricht = \"Hello, world!\"; System.out.println(nachricht); System.out.println(nachricht); System.out.println(nachricht); System.out.println(nachricht); System.out.println(nachricht); } } Deklaration Bevor eine Variable verwendet werden kann, muss das Programm diese Variable kennen. Dies tust du, indem du sie “deklarierst”. Unter der Deklaration einer Variable versteht man das erste “Erwähnen” einer Variable. In Java bedeutet dies, dass der Typ der Variable festgelegt wird.\nFormal gilt:\n1 \u003cTyp-der-Variable\u003e \u003cVariablen-Name\u003e; Wir geben also den Datentyp und den Namen der Variable an.\nIm vorherigen Beispiel hatten wir eine Variable so definiert:\n1 var nachricht = \"Hello, world!\"; Das Keyword var ist ein neueres Feature von Java, das den Typ erratet. Normalerweise gibt man stattdessen den Typ der Variable an:\n1 String nachricht; Bei der Variable nachricht ist also String der Typ. String bedeutet, dass es sich hierbei um einen Text - also eine “Zeichenkette” - handelt.\nDer Wert selbst muss bei der Deklaration nicht zwingend festgelegt werden. Zur Laufzeit (also wenn das Programm läuft) wird dann für die Variable einen Bereich im Arbeitsspeicher (RAM) reserviert. Hier werden später die Werte, die der Variablen zugewiesen werden, gespeichert. Die Grösse des Speicherbereichs hängt vom Typ der Variable ab.\nInitialisierung Unter dem Begriff Initialisierung wird die direkte Zuweisen eines Wertes bei der Deklaration einer Variablen verstanden. Lokale Variablen (Variablen, die lediglich innerhalb einer Methode gültig sind) müssen initialisiert werden, bevor sie verwendet werden können.\nFormal wird wie folgt eine Variable initialisiert (inkl. Deklaration):\n1 \u003cTyp-der-Variable\u003e \u003cVariablen-Name\u003e = \u003cWert-der-Variable\u003e; Hier ein kleines Beispiel, in welchem der Variable number den Wert 3 zuweisen und ausgeben:\n1 2 3 4 public static void main(String[] args) { int number = 3; System.out.println(number); } Nachfolgend ein Beispiel, in welchem versucht wird, zwei Zahlen zu addieren. Der erste Summand firstSummand hat den Wert 1, beim zweiten Summand secondSummand wird kein Wert zugewiesen:\n1 2 3 4 5 6 public static void main(String[] args) { int firstSummand = 1; int secondSummand; int sum = firstSummand + secondSummand; System.out.println(sum); } Weil die Variable secondSummand nicht initialisiert wurde, kann die Zuweisung int sum = firstSummand + secondSummand folglich nicht funktionieren. Deswegen führt dieser Code zu dieser Fehlermeldung:\n1 error: variable secondSummand might not have been initialized. Um dieses Problem zu lösen, muss die Variable secondSummand initialisiert (also einen Wert zugewiesen) werden:\n1 2 3 4 5 6 public static void main(String[] args) { int firstSummand = 1; int secondSummand = 2; int sum = firstSummand + secondSummand; System.out.println(sum); } Deklaration mit Initialisierung Wir können eine Variable nacheinander deklarieren und dann initialisieren oder beides zusammen:\n1 2 3 4 int number; // 1. Deklaration number = 2; // 2. Initialisierung int number = 2; // beides in einer Zeile Namensgebung Variablen dienen dazu, Werte zu speichern. Zur Benennung von Variablen gibt es vier Regeln:\nVariablennamen beginnen mit einem Kleinbuchstaben. Ein Variablenname darf die Buchstaben A-Z und a-z enthalten. Ein Variablenname darf beliebige Zahlen von 0-9 enthalten, nicht aber am Anfang. Ein Variablenname darf die Sonderzeichen $ und _ enthalten. Der Name einer Variable sollte so gewählt werden, dass klar ist, welcher Wert darin gespeichert wird. Als Beispiel wählen wir den Namen sum für eine Variable, welche das Resultat einer Addition enthält.\nLernvideo Wenn du dir die Erklärung noch mit einem Video genauer anschauen möchtest, empfiehlt dir das Praxisbildner-Team dieses Video. Relevant sind nur die Themen bis 4:25.\n","categories":"","description":"Modul #J1\n","excerpt":"Modul #J1\n","ref":"/de/docs/02_java/03_java-grundlagen/02_variables/","tags":"","title":"Variablen in Java"},{"body":"Entwirf ein Fahrzeugverwaltungssystem für ein Autohaus.\nDas Fahrzeugverwaltungssystem soll die Verwaltung von verschiedenen Fahrzeugtypen wie Autos, Lastwagen, Motorrädern. ermöglichen. Jedes Fahrzeug soll eine eindeutige Fahrzeugidentifikationsnummer (VIN) haben.\nJedes Fahrzeug verfügt über folgende Eigenschaften:\nFahrzeugtyp (Auto, Lastwagen, Motorrad) Marke Modell Farbe Baujahr Preis Verfügbarkeit (ob das Fahrzeug zum Verkauf steht oder nicht) Das Auto hat zudem:\nType (Familienauto, Sportauto etc.) Anzahl Sitze Stauraum im Kofferraum in m^2 Der Lastwagen hat zudem:\nmit Anhänger Ladefläche Das Motorrad hat zudem:\nFahrzeugklasse (Sportmotorrad, Cruiser, Touring) Das Fahrzeugverwaltungssystem soll die folgenden Funktionen unterstützen:\nHinzufügen eines neuen Fahrzeugs zum Inventar des Autohauses. Aktualisieren der Details eines vorhandenen Fahrzeugs (z. B. Preisänderung, Verfügbarkeitsstatus, Ausstattungsmerkmale hinzufügen/entfernen). Entfernen eines Fahrzeugs aus dem Inventar, wenn es verkauft wurde oder nicht mehr verfügbar ist. Anzeigen einer Liste aller verfügbaren Fahrzeuge zum Verkauf. Reservierung eines Fahrzeugs für einen Kunden, bevor der endgültige Kauf abgeschlossen ist. Verkauf eines reservierten Fahrzeugs und Aktualisierung des Bestands. Info: Ab diesem Lab darf, für alles folgenden Labs/Exams, Lombok verwendet werden, wenn man möchte.\nHier kannst du zurück zur Theorie.\n","categories":"","description":"Aufgabe zu Modul #J3 - [OOD](../../../../docs/02_java/07_java-ood) - Vehicles\n","excerpt":"Aufgabe zu Modul #J3 - [OOD](../../../../docs/02_java/07_java-ood) - …","ref":"/labs/02_java/07_java-ood/02_vehicles/","tags":"","title":"Vehicles"},{"body":"Entwirf ein Fahrzeugverwaltungssystem für ein Autohaus.\nDas Fahrzeugverwaltungssystem soll die Verwaltung von verschiedenen Fahrzeugtypen wie Autos, Lastwagen, Motorrädern. ermöglichen. Jedes Fahrzeug soll eine eindeutige Fahrzeugidentifikationsnummer (VIN) haben.\nJedes Fahrzeug verfügt über folgende Eigenschaften:\nFahrzeugtyp (Auto, Lastwagen, Motorrad) Marke Modell Farbe Baujahr Preis Verfügbarkeit (ob das Fahrzeug zum Verkauf steht oder nicht) Das Auto hat zudem:\nType (Familienauto, Sportauto etc.) Anzahl Sitze Stauraum im Kofferraum in m^2 Der Lastwagen hat zudem:\nmit Anhänger Ladefläche Das Motorrad hat zudem:\nFahrzeugklasse (Sportmotorrad, Cruiser, Touring) Das Fahrzeugverwaltungssystem soll die folgenden Funktionen unterstützen:\nHinzufügen eines neuen Fahrzeugs zum Inventar des Autohauses. Aktualisieren der Details eines vorhandenen Fahrzeugs (z. B. Preisänderung, Verfügbarkeitsstatus, Ausstattungsmerkmale hinzufügen/entfernen). Entfernen eines Fahrzeugs aus dem Inventar, wenn es verkauft wurde oder nicht mehr verfügbar ist. Anzeigen einer Liste aller verfügbaren Fahrzeuge zum Verkauf. Reservierung eines Fahrzeugs für einen Kunden, bevor der endgültige Kauf abgeschlossen ist. Verkauf eines reservierten Fahrzeugs und Aktualisierung des Bestands. Info: Ab diesem Lab darf, für alles folgenden Labs/Exams, Lombok verwendet werden, wenn man möchte.\nHier kannst du zurück zur Theorie.\n","categories":"","description":"Aufgabe zu Modul #J3 - [OOD](../../../../docs/02_java/07_java-ood) - Vehicles\n","excerpt":"Aufgabe zu Modul #J3 - [OOD](../../../../docs/02_java/07_java-ood) - …","ref":"/de/labs/02_java/07_java-ood/02_vehicles/","tags":"","title":"Vehicles"},{"body":"Das Modul soll den Einsatz von Git/Bitbucket unter realen Bedingungen vermitteln. Dazu ist es erforderlich, dass ihr als Team agiert. Mehrere IT-Ninjas, die das Modul #S1 - Git erfolgreich abgeschlossen haben, bilden ein Team, welches gemeinsam an zwei unterschiedlichen Projekten arbeitet. Hierbei geht es weniger um die Programmierung, sondern um die gemeinsame Arbeit an der gleichen Codebase und den daraus folgenden Herausforderungen in der Zusammenarbeit und in der Arbeit mit den Versionierungstools.\nZiele Ihr wisst, wer zu eurem Team gehört und wie die Aufgaben verteilt sind. Ihr habt alle den Zugriff auf dieselben Repositories mit der initialen Version des Beispielprojektes. Die Branches master und develop sind angelegt. Alle Teammitglieder haben die Repositories ausgecheckt. Aufgaben In einem ersten Schritt solltet ihr die Voraussetzungen für dieses Modul schaffen. Dazu müsst ihr\nein Team bilden, das aus minimal zwei, maximal fünf IT-Ninjas besteht, die das Modul Git erfolgreich abgeschlossen haben. die folgenden Aufgaben als Team ausführen. ein Szenario aufbauen, welches den Wechsel zwischen Branches und Projekten unterstützt und eine praxisnahe Zusammenarbeit ermöglicht. Für die Umsetzung könnt ihr die Git Befehle über die Kommandozeile eingeben oder die Funktionen in IntelliJ und der Bitbucket Weboberfläche nutzen. Die folgenden Screenshots sollen euch dabei helfen, die Funktionen in den Tools schneller zu finden.\nFork eines Repositories erstellen (Bitbucket) Achtung: Diese Aktion muss nur von einem Team-Mitglied ausgeführt werden!\nHinweis:\nDie Bilder zeigen ein Beispielprojekt, welches nicht zur Verfügung steht. Als Projekte für diese Aufgabe können die bereits abgeschlossenen Labs oder Exams der Module #J2 und #J3 verwendet werden.\nFür die Arbeit im Team sollten neue Repositories angelegt werden, damit die Arbeit aus den abgeschlossenen Modulen erhalten bleibt. Dazu kann der Fork Befehl genutzt werden. Entweder über die Git Kommandozeile oder - bequemer - über die Bitbucket Weboberfläche:\nWenn du die Kopien der Repositories erfolgreich angelegt hast, musst du diese noch für die anderen Team-Mitglieder freigeben.\nKlonen von Repositories in IntelliJ Jeder Ninja erstellt einen Klon der Repositories in seinem lokalen Arbeitsbereich:\nBitbucket im Browser aufrufen und zum gewünschten Repository wechseln. Dann Klonen in der Seitenleiste auswählen und die URL kopieren. Git im Menu auswählen (ggf. zuerst auf das Hamburger-Menu klicken). Im Git-Submenu den Eintrag Clone… auswählen. Im oberen Feld wird die aus Bitbucket kopierte URL eingefügt. Im unteren Feld ist das lokale Zielverzeichnis (muss leer sein!) auszuwählen. Hier geht es zu den Labs. Teambildung Vorbereitung ","categories":"","description":"","excerpt":"Das Modul soll den Einsatz von Git/Bitbucket unter realen Bedingungen …","ref":"/docs/04_git/02_vertiefung/01_voraussetzungen/","tags":"","title":"Voraussetzungen"},{"body":"Das Modul soll den Einsatz von Git/Bitbucket unter realen Bedingungen vermitteln. Dazu ist es erforderlich, dass ihr als Team agiert. Mehrere IT-Ninjas, die das Modul #S1 - Git erfolgreich abgeschlossen haben, bilden ein Team, welches gemeinsam an zwei unterschiedlichen Projekten arbeitet. Hierbei geht es weniger um die Programmierung, sondern um die gemeinsame Arbeit an der gleichen Codebase und den daraus folgenden Herausforderungen in der Zusammenarbeit und in der Arbeit mit den Versionierungstools.\nZiele Ihr wisst, wer zu eurem Team gehört und wie die Aufgaben verteilt sind. Ihr habt alle den Zugriff auf dieselben Repositories mit der initialen Version des Beispielprojektes. Die Branches master und develop sind angelegt. Alle Teammitglieder haben die Repositories ausgecheckt. Aufgaben In einem ersten Schritt solltet ihr die Voraussetzungen für dieses Modul schaffen. Dazu müsst ihr\nein Team bilden, das aus minimal zwei, maximal fünf IT-Ninjas besteht, die das Modul Git erfolgreich abgeschlossen haben. die folgenden Aufgaben als Team ausführen. ein Szenario aufbauen, welches den Wechsel zwischen Branches und Projekten unterstützt und eine praxisnahe Zusammenarbeit ermöglicht. Für die Umsetzung könnt ihr die Git Befehle über die Kommandozeile eingeben oder die Funktionen in IntelliJ und der Bitbucket Weboberfläche nutzen. Die folgenden Screenshots sollen euch dabei helfen, die Funktionen in den Tools schneller zu finden.\nFork eines Repositories erstellen (Bitbucket) Achtung: Diese Aktion muss nur von einem Team-Mitglied ausgeführt werden!\nHinweis:\nDie Bilder zeigen ein Beispielprojekt, welches nicht zur Verfügung steht. Als Projekte für diese Aufgabe können die bereits abgeschlossenen Labs oder Exams der Module #J2 und #J3 verwendet werden.\nFür die Arbeit im Team sollten neue Repositories angelegt werden, damit die Arbeit aus den abgeschlossenen Modulen erhalten bleibt. Dazu kann der Fork Befehl genutzt werden. Entweder über die Git Kommandozeile oder - bequemer - über die Bitbucket Weboberfläche:\nWenn du die Kopien der Repositories erfolgreich angelegt hast, musst du diese noch für die anderen Team-Mitglieder freigeben.\nKlonen von Repositories in IntelliJ Jeder Ninja erstellt einen Klon der Repositories in seinem lokalen Arbeitsbereich:\nBitbucket im Browser aufrufen und zum gewünschten Repository wechseln. Dann Klonen in der Seitenleiste auswählen und die URL kopieren. Git im Menu auswählen (ggf. zuerst auf das Hamburger-Menu klicken). Im Git-Submenu den Eintrag Clone… auswählen. Im oberen Feld wird die aus Bitbucket kopierte URL eingefügt. Im unteren Feld ist das lokale Zielverzeichnis (muss leer sein!) auszuwählen. Hier geht es zu den Labs. Teambildung Vorbereitung ","categories":"","description":"","excerpt":"Das Modul soll den Einsatz von Git/Bitbucket unter realen Bedingungen …","ref":"/de/docs/04_git/02_vertiefung/01_voraussetzungen/","tags":"","title":"Voraussetzungen"},{"body":"Aufgaben Aufgabe 1 Erstelle eine neue Angular-Komponente mit dem Namen SignalExample. Verwende die Funktion createSignal, um innerhalb der Komponente ein Signal namens messageSignal zu definieren. Zeige den Wert von messageSignal im Template an. Aufgabe 2 Erweitere die Komponente aus Aufgabe 1 um zwei Eingabefelder - eines für einen Namen und eines für eine Nachricht. Binde die Werte dieser Eingabefelder an separate Signale (nameSignal und messageSignal). Zeige eine formatierte Nachricht im Template unter Verwendung der Werte aus den Signalen an. Aufgabe 3 Füge zur Komponente aus den vorherigen Aufgaben einen Button hinzu. Verwende ein Signal (showMessageSignal), um die Sichtbarkeit einer Nachrichten-Div im Template zu steuern. Beim Klicken des Buttons, ändere den Wert von showMessageSignal, um die Nachricht anzuzeigen/zu verbergen Aufgabe 4 Erstelle einen Service namens DatenService mit einem Signal dataSignal, das ein Array von Daten emittiert. Injiziere den DatenService in die bestehende Komponente der vorherigen Aufgaben. Verwende `dataSignal, um eine Liste von Daten im Komponenten-Template anzuzeigen Aufgabe 5 Füge der Komponente aus der vorherigen Aufgaben einen Effekt hinzu, der eine Nachricht protokolliert, wenn sich das messageSignal ändert. Teste den Effekt, indem du den Wert von messageSignal änderst und die Konsole beobachtest. ","categories":"","description":"Aufgaben zu Signals in Angular.\n","excerpt":"Aufgaben zu Signals in Angular.\n","ref":"/labs/03_web/04_angular/03_signals/","tags":"","title":"Labs zu Signals"},{"body":"Aufgaben Aufgabe 1 Erstelle eine neue Angular-Komponente mit dem Namen SignalExample. Verwende die Funktion createSignal, um innerhalb der Komponente ein Signal namens messageSignal zu definieren. Zeige den Wert von messageSignal im Template an. Aufgabe 2 Erweitere die Komponente aus Aufgabe 1 um zwei Eingabefelder - eines für einen Namen und eines für eine Nachricht. Binde die Werte dieser Eingabefelder an separate Signale (nameSignal und messageSignal). Zeige eine formatierte Nachricht im Template unter Verwendung der Werte aus den Signalen an. Aufgabe 3 Füge zur Komponente aus den vorherigen Aufgaben einen Button hinzu. Verwende ein Signal (showMessageSignal), um die Sichtbarkeit einer Nachrichten-Div im Template zu steuern. Beim Klicken des Buttons, ändere den Wert von showMessageSignal, um die Nachricht anzuzeigen/zu verbergen Aufgabe 4 Erstelle einen Service namens DatenService mit einem Signal dataSignal, das ein Array von Daten emittiert. Injiziere den DatenService in die bestehende Komponente der vorherigen Aufgaben. Verwende `dataSignal, um eine Liste von Daten im Komponenten-Template anzuzeigen Aufgabe 5 Füge der Komponente aus der vorherigen Aufgaben einen Effekt hinzu, der eine Nachricht protokolliert, wenn sich das messageSignal ändert. Teste den Effekt, indem du den Wert von messageSignal änderst und die Konsole beobachtest. ","categories":"","description":"Aufgaben zu Signals in Angular.\n","excerpt":"Aufgaben zu Signals in Angular.\n","ref":"/de/labs/03_web/04_angular/03_signals/","tags":"","title":"Labs zu Signals"},{"body":"","categories":"","description":"Labs zu Typescript\n","excerpt":"Labs zu Typescript\n","ref":"/labs/03_web/03_typescript/","tags":"","title":"Typescript Labs"},{"body":"","categories":"","description":"Labs zu Typescript\n","excerpt":"Labs zu Typescript\n","ref":"/de/labs/03_web/03_typescript/","tags":"","title":"Typescript Labs"},{"body":"Ziele Du weisst, was die tsconfig-Datei ist und wofür diese verwendet wird. Du kennst die wichtigsten Einstellungen und Optionen, die du in der tsconfig-Datei anpassen kannst. Konfigurationsdatei für TypeScript-Projekte Die tsconfig.json-Datei ist eine Konfigurationsdatei für TypeScript-Projekte. Sie wird verwendet, um verschiedene Einstellungen für den TypeScript-Compiler festzulegen. Wenn sich die tsconfig.json-Datei im Stammverzeichnis eines Projekts befindet, werden diese Einstellungen automatisch von jeder TypeScript-Datei im Projekt übernommen.\nHier sind einige der wichtigsten Einstellungen, die in der tsconfig.json-Datei vorgenommen werden können:\ncompilerOptions: Dieser Abschnitt enthält die Compiler-Optionen, die das Verhalten des TypeScript-Compilers steuern. Einstellungen wie die ECMAScript-Version (target), das Modulsystem (module), der Pfad zum Ausgabeverzeichnis (outDir), der Typen-Check-Modus (strict) und viele andere Optionen können hier konfigurieren werden. include und exclude: Mit diesen Optionen gibt man an, welche Dateien vom Compiler einbezogen bzw. ausgeschlossen werden sollen. Es können Muster (z.B. src/\\*_/_.ts für alles .ts Dateien) verwendet werden, um Dateien zu filtern. extends: Diese Option ermöglicht es, eine andere tsconfig.json-Datei als Basis zu verwenden und ihre Einstellungen zu erweitern. Das ist nützlich, wenn eine gemeinsame Konfiguration für mehrere Projekte vorhanden ist und man nur spezifische Einstellungen in der aktuellen Datei ändern möchte. files: Diese Option ermöglicht es, explizit eine Liste von Dateien anzugeben, die vom Compiler verarbeitet werden soll. Das wird normalerweise gemacht, wenn die include-Option nicht verwendet werden soll und nur bestimmte Dateien im Projekt berücksichtigt werden sollen. references: Mit dieser Option können Referenzen zu anderen Projekten angegeben werden, um die Abhängigkeiten zwischen den Projekten zu definieren. Das ist nützlich, wenn mehrere TypeScript-Projekte existieren und diese miteinander verknüpfen werden sollen. Eine der wichtigsten compilerOptions ist die strict-Option. Diese ist eine Sammlung von Compiler-Optionen, welche aktiviert werden können, um die strenge Überprüfung von Typen und Codequalität sicherzustellen. Wenn die strict-Option auf true gesetzt wird, werden mehrere einzelne Compiler-Optionen aktiviert, um die Typsicherheit zu verbessern und potenziell unsichere Codepraktiken zu verhindern.\nHier sind einige der wichtigsten Compiler-Optionen, die von der strict-Option in der tsconfig.json-Datei aktiviert werden:\nstrictNullChecks: Stellt sicher, dass null und undefined nur auf Nullable-Typen zugewiesen werden können. Dadurch werden potenzielle Fehler vermieden, wenn auf Eigenschaften oder Methoden von Null- oder Undefined-Werten zugegriffen wird. noImplicitAny: Verhindert, dass Variablen implizit den any-Typ annehmen. Dadurch wird man dazu gezwungen, explizite Typen für Variablen zu definieren und den any-Typ so weit wie möglich zu vermeiden. strictFunctionTypes: Erzwingt die Kompatibilität von Funktionstypen, einschliesslich der Rückgabetypen von Funktionen. Dadurch werden Fehler vermieden, wenn Funktionen mit inkompatiblen Typen zugewiesen oder aufgerufen werden. strictPropertyInitialization: Stellt sicher, dass alle Eigenschaften von Klassen explizit initialisiert werden, entweder in ihrem Deklarationsabschnitt oder im Konstruktor. Dadurch wird verhindert, dass unbeabsichtigt auf nicht initialisierte Eigenschaften zugegriffen wird. strictBindCallApply: Überprüft die Verwendung von bind, call und apply auf Funktionen und stellt sicher, dass die Parameter und Rückgabewerte korrekt typisiert sind. noImplicitThis: Stellt sicher, dass this in Funktionen explizit typisiert wird, um Fehler bei der Verwendung zu vermeiden. Auf der folgenden Seite kannst du dir die tsconfig-Datei und ihre jeweiligen Konfigurationsoptionen noch etwas genauer anschauen: typescriptlang.org\n","categories":"","description":"Modul #F5 - TypeScript - TsConfig\n","excerpt":"Modul #F5 - TypeScript - TsConfig\n","ref":"/docs/03_web/05_typescript/03_config/","tags":"","title":"tsconfig Datei"},{"body":"Ziele Du weisst, was die tsconfig-Datei ist und wofür diese verwendet wird. Du kennst die wichtigsten Einstellungen und Optionen, die du in der tsconfig-Datei anpassen kannst. Konfigurationsdatei für TypeScript-Projekte Die tsconfig.json-Datei ist eine Konfigurationsdatei für TypeScript-Projekte. Sie wird verwendet, um verschiedene Einstellungen für den TypeScript-Compiler festzulegen. Wenn sich die tsconfig.json-Datei im Stammverzeichnis eines Projekts befindet, werden diese Einstellungen automatisch von jeder TypeScript-Datei im Projekt übernommen.\nHier sind einige der wichtigsten Einstellungen, die in der tsconfig.json-Datei vorgenommen werden können:\ncompilerOptions: Dieser Abschnitt enthält die Compiler-Optionen, die das Verhalten des TypeScript-Compilers steuern. Einstellungen wie die ECMAScript-Version (target), das Modulsystem (module), der Pfad zum Ausgabeverzeichnis (outDir), der Typen-Check-Modus (strict) und viele andere Optionen können hier konfigurieren werden. include und exclude: Mit diesen Optionen gibt man an, welche Dateien vom Compiler einbezogen bzw. ausgeschlossen werden sollen. Es können Muster (z.B. src/\\*_/_.ts für alles .ts Dateien) verwendet werden, um Dateien zu filtern. extends: Diese Option ermöglicht es, eine andere tsconfig.json-Datei als Basis zu verwenden und ihre Einstellungen zu erweitern. Das ist nützlich, wenn eine gemeinsame Konfiguration für mehrere Projekte vorhanden ist und man nur spezifische Einstellungen in der aktuellen Datei ändern möchte. files: Diese Option ermöglicht es, explizit eine Liste von Dateien anzugeben, die vom Compiler verarbeitet werden soll. Das wird normalerweise gemacht, wenn die include-Option nicht verwendet werden soll und nur bestimmte Dateien im Projekt berücksichtigt werden sollen. references: Mit dieser Option können Referenzen zu anderen Projekten angegeben werden, um die Abhängigkeiten zwischen den Projekten zu definieren. Das ist nützlich, wenn mehrere TypeScript-Projekte existieren und diese miteinander verknüpfen werden sollen. Eine der wichtigsten compilerOptions ist die strict-Option. Diese ist eine Sammlung von Compiler-Optionen, welche aktiviert werden können, um die strenge Überprüfung von Typen und Codequalität sicherzustellen. Wenn die strict-Option auf true gesetzt wird, werden mehrere einzelne Compiler-Optionen aktiviert, um die Typsicherheit zu verbessern und potenziell unsichere Codepraktiken zu verhindern.\nHier sind einige der wichtigsten Compiler-Optionen, die von der strict-Option in der tsconfig.json-Datei aktiviert werden:\nstrictNullChecks: Stellt sicher, dass null und undefined nur auf Nullable-Typen zugewiesen werden können. Dadurch werden potenzielle Fehler vermieden, wenn auf Eigenschaften oder Methoden von Null- oder Undefined-Werten zugegriffen wird. noImplicitAny: Verhindert, dass Variablen implizit den any-Typ annehmen. Dadurch wird man dazu gezwungen, explizite Typen für Variablen zu definieren und den any-Typ so weit wie möglich zu vermeiden. strictFunctionTypes: Erzwingt die Kompatibilität von Funktionstypen, einschliesslich der Rückgabetypen von Funktionen. Dadurch werden Fehler vermieden, wenn Funktionen mit inkompatiblen Typen zugewiesen oder aufgerufen werden. strictPropertyInitialization: Stellt sicher, dass alle Eigenschaften von Klassen explizit initialisiert werden, entweder in ihrem Deklarationsabschnitt oder im Konstruktor. Dadurch wird verhindert, dass unbeabsichtigt auf nicht initialisierte Eigenschaften zugegriffen wird. strictBindCallApply: Überprüft die Verwendung von bind, call und apply auf Funktionen und stellt sicher, dass die Parameter und Rückgabewerte korrekt typisiert sind. noImplicitThis: Stellt sicher, dass this in Funktionen explizit typisiert wird, um Fehler bei der Verwendung zu vermeiden. Auf der folgenden Seite kannst du dir die tsconfig-Datei und ihre jeweiligen Konfigurationsoptionen noch etwas genauer anschauen: typescriptlang.org\n","categories":"","description":"Modul #F5 - TypeScript - TsConfig\n","excerpt":"Modul #F5 - TypeScript - TsConfig\n","ref":"/de/docs/03_web/05_typescript/03_config/","tags":"","title":"tsconfig Datei"},{"body":"Aufgaben Aufgabe 1 Als Beispiel zur Verwendung von NgRx, setzen wir ein neues Angular-projekt auf und schreiben eine Anwendung mit einem Counter, der Inkrementier, Dekrementiert und Resettet werden kann.\nEinrichten Als Erstes muss man ein neues Angular Projekt aufsetzen.\nDanach NgRx installieren.\nNun erstellt man der Übersicht halber noch zwei Ordner names actions und reducers. Darin werden dann alle Actions und Reducer erstellt.\nActions erstellen Als Erstes werden die Actions definiert, welche man alle für dieses Projekt benötigt. Wie bei der Einleitung erwähnt sind das Inkrementieren, Dekrementieren und Resetten. Dazu erstellt man nun ein neues Typescript File namens counter.actions.ts. Lagere die Action Types in ein Enum aus.\nVersuche selbständig auf eine Lösung zu kommen, bevor du dir die Lösung anschaust.\nLösung (click to expand) 1 2 3 4 5 export enum ActionTypes { INCREMENT = \"[Counter Component] Increment\", DECREMENT = \"[Counter Component] Decrement\", RESET = \"[Counter Component] Reset\", } 1 2 3 4 5 import { createAction } from \"@ngrx/store\"; export const increment = createAction(ActionTypes.INCREMENT); export const decrement = createAction(ActionTypes.DECREMENT); export const reset = createAction(ActionTypes.RESET); Reducer erstellen Nun muss man eine Reducer-Funktion definieren, um Änderungen im Zählerwert basierend auf den bereitgestellten Aktionen zu verarbeiten. Erstelle dazu ein neues Typescript File namens counter.reducer.ts und setze die Funktion darin um.\nVersuche selbständig auf eine Lösung zu kommen, bevor du dir die Lösung anschaust.\nLösung (click to expand) 1 2 3 4 5 6 7 8 9 10 11 import { createReducer, on } from \"@ngrx/store\"; import { increment, decrement, reset } from \"./counter.actions\"; export const initialState = 0; export const counterReducer = createReducer( initialState, on(increment, (state) =\u003e state + 1), on(decrement, (state) =\u003e state - 1), on(reset, (state) =\u003e 0), ); Component erstellen Erstelle mittels ng-Befehl einen neuen Component namens my-counter innerhalb des app-Ordners. Das HTML soll einen Titel besitzen, drei Buttons für jede Actions und eine Anzeige für den aktuellen Counter. Im Typescript soll für jeden Button eine Methode erstellt werden, zudem ein Observable welches den aktuellen Count beinhaltet. Das Observable soll mit dem Wert des Stores verbunden sein.\nVersuche selbständig auf eine Lösung zu kommen, bevor du dir die Lösung anschaust.\nLösung (click to expand) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import { Component } from \"@angular/core\"; import { Store } from \"@ngrx/store\"; import { Observable } from \"rxjs\"; import { increment, decrement, reset } from \"../counter.actions\"; @Component({ selector: \"app-my-counter\", templateUrl: \"./my-counter.component.html\", }) export class MyCounterComponent { count$: Observable\u003cnumber\u003e; constructor(private store: Store\u003c{ count: number }\u003e) { this.count$ = store.select(\"count\"); } increment() { this.store.dispatch(increment()); } decrement() { this.store.dispatch(decrement()); } reset() { this.store.dispatch(reset()); } } 1 2 3 4 5 6 7 \u003cbutton (click)=\"increment()\"\u003eIncrement\u003c/button\u003e \u003cdiv\u003eCurrent Count: {{ count$ | async }}\u003c/div\u003e \u003cbutton (click)=\"decrement()\"\u003eDecrement\u003c/button\u003e \u003cbutton (click)=\"reset()\"\u003eReset Counter\u003c/button\u003e AppModule anpassen Das app.module.ts muss nun noch mit dem Store und Reducer ergänzt werden.\nVersuche selbständig auf eine Lösung zu kommen, bevor du dir die Lösung anschaust.\nLösung (click to expand) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import { BrowserModule } from \"@angular/platform-browser\"; import { NgModule } from \"@angular/core\"; import { AppComponent } from \"./app.component\"; import { StoreModule } from \"@ngrx/store\"; import { counterReducer } from \"./counter.reducer\"; import { MyCounterComponent } from \"./my-counter/my-counter.component\"; @NgModule({ declarations: [AppComponent, MyCounterComponent], imports: [BrowserModule, StoreModule.forRoot({ count: counterReducer })], providers: [], bootstrap: [AppComponent], }) export class AppModule {} Im AppComponent anzeigen Der neue Component soll nun mit dem app.component.html verknüpft werden, sodass der Inhalt des Components sichtbar wird.\nVersuche selbständig auf eine Lösung zu kommen, bevor du dir die Lösung anschaust.\nLösung (click to expand) 1 2 3 \u003ch1\u003eNgRx Tutorial\u003c/h1\u003e \u003capp-my-counter\u003e\u003c/app-my-counter\u003e Aufgabe 2 Entwickle eine Angular-Anwendung für einen Online-Shop mit den folgenden Funktionen und Components: Produktübersicht und Warenkorb. Die Produktdaten sollen als Mockdaten in einem Service gespeichert werden. Implementiere Routing, um zwischen den verschiedenen Ansichten zu navigieren.\nProdukt Attribute Name Preis Produktübersicht Erstelle eine Seite für die Produktübersicht, auf der alle Produkte angezeigt werden. Rufe die Produktdaten aus einem Mock-Datenservice ab und zeige sie an. Implementiere zu jedem Produkt einen Button für das Hinzufügen von Produkten in den Warenkorb. Warenkorb: Erstelle eine Seite, auf der die Produkte im Warenkorb angezeigt werden. Verwende NgRx, um den Warenkorbzustand zu verwalten. Definiere Aktionen zum Hinzufügen und Entfernen von Produkten in den Warenkorb. (Verwende Selektoren, um den Zugriff auf den NgRx-Store zu erleichtern.)) Zeige eine Liste der ausgewählten Produkte im Warenkorb an, inklusive Name und Preis. Implementiere einen Button für das Löschen von Produkten aus dem Warenkorb. Füge eine Bestellfunktion hinzu, um den Kaufprozess abzuschliessen (kann eine einfache Bestätigungsnachricht sein). Aufgabe 3 Erstelle eine Angular-Anwendung für eine TODO-Liste, die das NgRx-Modul verwendet, um den Zustand der Aufgaben zu verwalten. Die Anwendung sollte die folgenden Funktionen enthalten:\nTask Attribute ID Name Completed Übersicht Erstelle eine Seite, auf der die offene (Completed = false) Task (einfach der Name) angezeigt werden. (Verwende Selektoren, um den Zugriff auf die Tasks im NgRx-Store zu erleichtern.) Verwende NgRx, um den Taskzustand zu verwalten. Definiere Aktionen zum Hinzufügen, Entfernen und Complete von Tasks. Implementiere zu jedem Task einen Button für das Complete und Entfernen von Tasks. Taskerstellungs-Seite Erstelle auf der Seite eine Unterseite, auf der neue Task erfasst werden können. (Für die Id zu erstellen am einfachsten new Date().getTime() nehmen) Der Name des Tasks soll mittels Reactive Forms eingetragen werden. completed ist immer auf false bei 2einem neuen Task. ","categories":"","description":"Ein paar zusätzliche/optionale Aufgaben zu NgRx.\n","excerpt":"Ein paar zusätzliche/optionale Aufgaben zu NgRx.\n","ref":"/labs/03_web/05_angular-ngrx/01_ngrx/","tags":"","title":"NgRx Labs"},{"body":"Aufgaben Aufgabe 1 Als Beispiel zur Verwendung von NgRx, setzen wir ein neues Angular-projekt auf und schreiben eine Anwendung mit einem Counter, der Inkrementier, Dekrementiert und Resettet werden kann.\nEinrichten Als Erstes muss man ein neues Angular Projekt aufsetzen.\nDanach NgRx installieren.\nNun erstellt man der Übersicht halber noch zwei Ordner names actions und reducers. Darin werden dann alle Actions und Reducer erstellt.\nActions erstellen Als Erstes werden die Actions definiert, welche man alle für dieses Projekt benötigt. Wie bei der Einleitung erwähnt sind das Inkrementieren, Dekrementieren und Resetten. Dazu erstellt man nun ein neues Typescript File namens counter.actions.ts. Lagere die Action Types in ein Enum aus.\nVersuche selbständig auf eine Lösung zu kommen, bevor du dir die Lösung anschaust.\nLösung (click to expand) 1 2 3 4 5 export enum ActionTypes { INCREMENT = \"[Counter Component] Increment\", DECREMENT = \"[Counter Component] Decrement\", RESET = \"[Counter Component] Reset\", } 1 2 3 4 5 import { createAction } from \"@ngrx/store\"; export const increment = createAction(ActionTypes.INCREMENT); export const decrement = createAction(ActionTypes.DECREMENT); export const reset = createAction(ActionTypes.RESET); Reducer erstellen Nun muss man eine Reducer-Funktion definieren, um Änderungen im Zählerwert basierend auf den bereitgestellten Aktionen zu verarbeiten. Erstelle dazu ein neues Typescript File namens counter.reducer.ts und setze die Funktion darin um.\nVersuche selbständig auf eine Lösung zu kommen, bevor du dir die Lösung anschaust.\nLösung (click to expand) 1 2 3 4 5 6 7 8 9 10 11 import { createReducer, on } from \"@ngrx/store\"; import { increment, decrement, reset } from \"./counter.actions\"; export const initialState = 0; export const counterReducer = createReducer( initialState, on(increment, (state) =\u003e state + 1), on(decrement, (state) =\u003e state - 1), on(reset, (state) =\u003e 0), ); Component erstellen Erstelle mittels ng-Befehl einen neuen Component namens my-counter innerhalb des app-Ordners. Das HTML soll einen Titel besitzen, drei Buttons für jede Actions und eine Anzeige für den aktuellen Counter. Im Typescript soll für jeden Button eine Methode erstellt werden, zudem ein Observable welches den aktuellen Count beinhaltet. Das Observable soll mit dem Wert des Stores verbunden sein.\nVersuche selbständig auf eine Lösung zu kommen, bevor du dir die Lösung anschaust.\nLösung (click to expand) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import { Component } from \"@angular/core\"; import { Store } from \"@ngrx/store\"; import { Observable } from \"rxjs\"; import { increment, decrement, reset } from \"../counter.actions\"; @Component({ selector: \"app-my-counter\", templateUrl: \"./my-counter.component.html\", }) export class MyCounterComponent { count$: Observable\u003cnumber\u003e; constructor(private store: Store\u003c{ count: number }\u003e) { this.count$ = store.select(\"count\"); } increment() { this.store.dispatch(increment()); } decrement() { this.store.dispatch(decrement()); } reset() { this.store.dispatch(reset()); } } 1 2 3 4 5 6 7 \u003cbutton (click)=\"increment()\"\u003eIncrement\u003c/button\u003e \u003cdiv\u003eCurrent Count: {{ count$ | async }}\u003c/div\u003e \u003cbutton (click)=\"decrement()\"\u003eDecrement\u003c/button\u003e \u003cbutton (click)=\"reset()\"\u003eReset Counter\u003c/button\u003e AppModule anpassen Das app.module.ts muss nun noch mit dem Store und Reducer ergänzt werden.\nVersuche selbständig auf eine Lösung zu kommen, bevor du dir die Lösung anschaust.\nLösung (click to expand) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import { BrowserModule } from \"@angular/platform-browser\"; import { NgModule } from \"@angular/core\"; import { AppComponent } from \"./app.component\"; import { StoreModule } from \"@ngrx/store\"; import { counterReducer } from \"./counter.reducer\"; import { MyCounterComponent } from \"./my-counter/my-counter.component\"; @NgModule({ declarations: [AppComponent, MyCounterComponent], imports: [BrowserModule, StoreModule.forRoot({ count: counterReducer })], providers: [], bootstrap: [AppComponent], }) export class AppModule {} Im AppComponent anzeigen Der neue Component soll nun mit dem app.component.html verknüpft werden, sodass der Inhalt des Components sichtbar wird.\nVersuche selbständig auf eine Lösung zu kommen, bevor du dir die Lösung anschaust.\nLösung (click to expand) 1 2 3 \u003ch1\u003eNgRx Tutorial\u003c/h1\u003e \u003capp-my-counter\u003e\u003c/app-my-counter\u003e Aufgabe 2 Entwickle eine Angular-Anwendung für einen Online-Shop mit den folgenden Funktionen und Components: Produktübersicht und Warenkorb. Die Produktdaten sollen als Mockdaten in einem Service gespeichert werden. Implementiere Routing, um zwischen den verschiedenen Ansichten zu navigieren.\nProdukt Attribute Name Preis Produktübersicht Erstelle eine Seite für die Produktübersicht, auf der alle Produkte angezeigt werden. Rufe die Produktdaten aus einem Mock-Datenservice ab und zeige sie an. Implementiere zu jedem Produkt einen Button für das Hinzufügen von Produkten in den Warenkorb. Warenkorb: Erstelle eine Seite, auf der die Produkte im Warenkorb angezeigt werden. Verwende NgRx, um den Warenkorbzustand zu verwalten. Definiere Aktionen zum Hinzufügen und Entfernen von Produkten in den Warenkorb. (Verwende Selektoren, um den Zugriff auf den NgRx-Store zu erleichtern.)) Zeige eine Liste der ausgewählten Produkte im Warenkorb an, inklusive Name und Preis. Implementiere einen Button für das Löschen von Produkten aus dem Warenkorb. Füge eine Bestellfunktion hinzu, um den Kaufprozess abzuschliessen (kann eine einfache Bestätigungsnachricht sein). Aufgabe 3 Erstelle eine Angular-Anwendung für eine TODO-Liste, die das NgRx-Modul verwendet, um den Zustand der Aufgaben zu verwalten. Die Anwendung sollte die folgenden Funktionen enthalten:\nTask Attribute ID Name Completed Übersicht Erstelle eine Seite, auf der die offene (Completed = false) Task (einfach der Name) angezeigt werden. (Verwende Selektoren, um den Zugriff auf die Tasks im NgRx-Store zu erleichtern.) Verwende NgRx, um den Taskzustand zu verwalten. Definiere Aktionen zum Hinzufügen, Entfernen und Complete von Tasks. Implementiere zu jedem Task einen Button für das Complete und Entfernen von Tasks. Taskerstellungs-Seite Erstelle auf der Seite eine Unterseite, auf der neue Task erfasst werden können. (Für die Id zu erstellen am einfachsten new Date().getTime() nehmen) Der Name des Tasks soll mittels Reactive Forms eingetragen werden. completed ist immer auf false bei 2einem neuen Task. ","categories":"","description":"Ein paar zusätzliche/optionale Aufgaben zu NgRx.\n","excerpt":"Ein paar zusätzliche/optionale Aufgaben zu NgRx.\n","ref":"/de/labs/03_web/05_angular-ngrx/01_ngrx/","tags":"","title":"NgRx Labs"},{"body":"Ziele Du weisst, was NgRx Reducers sind und kannst diese anwenden. Du weisst, wie und warum die Reducers beim Root registriert werden. NgRx Reducers Reducers sind Funktionen in NgRx, die den aktuellen Zustand des Stores und eine Action als Parameter entgegennehmen und den neuen Zustand des Stores zurückgeben. Sie sind dafür verantwortlich, den Zustand basierend auf den eingehenden Aktionen zu aktualisieren.\nReducers in NgRx folgen dem Redux-Muster und sollten immer eine rein funktionale Programmierung befolgen. Das bedeutet, dass sie den aktuellen Zustand nicht verändern, sondern einen neuen Zustand erstellen und zurückgeben.\nFür jeden State, der in der Applikation verwendet werden soll, wird ein Interface erstellt. Diese Interfaces werden dazu verwendet, mindestens einen weiteren State zu definieren, nämlich den initialen State. Mit dem initialen State wird vermieden, dass der State undefined sein kann.\nDa zumeist mehrere Actions vorhanden sind, müssen diese auch unterschieden werden. Dazu ist die on-Funktion , diese kann einen Fallunterschied zwischen den Actions erstellen. Durch die Verwendung der props in den Action-Creator-Funktionen kann man die relevanten Daten an die Reducer-Funktion übergeben und im Reducer-Zustand verwenden.\nSeit Angular 17 ist es so, dass es eine index.ts-Datei, innerhalb des reducer-Ordners gibt. In diese werden alle Reducers registriert, damit diese dann in die app.config.ts-Datei exportiert werden können. Das dient der neuen Struktur, welche für eine bessere allgemeine Übersicht sorgen soll.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // index.ts import { isDevMode } from \"@angular/core\"; import { ActionReducerMap, MetaReducer } from \"@ngrx/store\"; import { abilityReducer } from \"./abilityReducer.reducer\"; export interface AbilityState { abilities: string[]; } export interface AppState { ability: AbilityState; } export const reducers: ActionReducerMap\u003cAppState\u003e = { ability: abilityReducer, }; export const metaReducers: MetaReducer\u003cAppState\u003e[] = isDevMode() ? [] : []; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // abilityReducer.reducer.ts import { createReducer, on } from \"@ngrx/store\"; import { addAbility, deleteAbility, getAbilities, } from \"../actions/ability.actions\"; import { AbilityState } from \"../reducer/index.ts\"; export const initialState: AbilityState = { abilities: [], }; export const abilityReducer = createReducer( initialState, on(getAbilities, (state) =\u003e state), on(addAbility, (state, { ability }) =\u003e ({ ...state, abilities: [...state.abilities, ability], })), on(deleteAbility, (state, { ability }) =\u003e ({ ...state, abilities: state.abilities.filter( (existingAbility) =\u003e existingAbility !== ability, ), })), ); Reducers Registrieren Wichtig: die Reducers müssen im index.ts in der Konstante export const reducers angegeben werden. Diese Konstante wird dann wie bereits erwähnt in der app.config.ts-Datei innerhalb der runden Klammern von provideStore() angegeben.\n","categories":"","description":"Modul #F7 - Angular NgRx - Reducers sind\n","excerpt":"Modul #F7 - Angular NgRx - Reducers sind\n","ref":"/docs/03_web/07_angular-ngrx/03_ngrx-reducers/","tags":"","title":"NgRx Reducers"},{"body":"Ziele Du weisst, was NgRx Reducers sind und kannst diese anwenden. Du weisst, wie und warum die Reducers beim Root registriert werden. NgRx Reducers Reducers sind Funktionen in NgRx, die den aktuellen Zustand des Stores und eine Action als Parameter entgegennehmen und den neuen Zustand des Stores zurückgeben. Sie sind dafür verantwortlich, den Zustand basierend auf den eingehenden Aktionen zu aktualisieren.\nReducers in NgRx folgen dem Redux-Muster und sollten immer eine rein funktionale Programmierung befolgen. Das bedeutet, dass sie den aktuellen Zustand nicht verändern, sondern einen neuen Zustand erstellen und zurückgeben.\nFür jeden State, der in der Applikation verwendet werden soll, wird ein Interface erstellt. Diese Interfaces werden dazu verwendet, mindestens einen weiteren State zu definieren, nämlich den initialen State. Mit dem initialen State wird vermieden, dass der State undefined sein kann.\nDa zumeist mehrere Actions vorhanden sind, müssen diese auch unterschieden werden. Dazu ist die on-Funktion , diese kann einen Fallunterschied zwischen den Actions erstellen. Durch die Verwendung der props in den Action-Creator-Funktionen kann man die relevanten Daten an die Reducer-Funktion übergeben und im Reducer-Zustand verwenden.\nSeit Angular 17 ist es so, dass es eine index.ts-Datei, innerhalb des reducer-Ordners gibt. In diese werden alle Reducers registriert, damit diese dann in die app.config.ts-Datei exportiert werden können. Das dient der neuen Struktur, welche für eine bessere allgemeine Übersicht sorgen soll.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // index.ts import { isDevMode } from \"@angular/core\"; import { ActionReducerMap, MetaReducer } from \"@ngrx/store\"; import { abilityReducer } from \"./abilityReducer.reducer\"; export interface AbilityState { abilities: string[]; } export interface AppState { ability: AbilityState; } export const reducers: ActionReducerMap\u003cAppState\u003e = { ability: abilityReducer, }; export const metaReducers: MetaReducer\u003cAppState\u003e[] = isDevMode() ? [] : []; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // abilityReducer.reducer.ts import { createReducer, on } from \"@ngrx/store\"; import { addAbility, deleteAbility, getAbilities, } from \"../actions/ability.actions\"; import { AbilityState } from \"../reducer/index.ts\"; export const initialState: AbilityState = { abilities: [], }; export const abilityReducer = createReducer( initialState, on(getAbilities, (state) =\u003e state), on(addAbility, (state, { ability }) =\u003e ({ ...state, abilities: [...state.abilities, ability], })), on(deleteAbility, (state, { ability }) =\u003e ({ ...state, abilities: state.abilities.filter( (existingAbility) =\u003e existingAbility !== ability, ), })), ); Reducers Registrieren Wichtig: die Reducers müssen im index.ts in der Konstante export const reducers angegeben werden. Diese Konstante wird dann wie bereits erwähnt in der app.config.ts-Datei innerhalb der runden Klammern von provideStore() angegeben.\n","categories":"","description":"Modul #F7 - Angular NgRx - Reducers sind\n","excerpt":"Modul #F7 - Angular NgRx - Reducers sind\n","ref":"/de/docs/03_web/07_angular-ngrx/03_ngrx-reducers/","tags":"","title":"NgRx Reducers"},{"body":"Ziele Du kennst die grundlegende Struktur eines Angular-Projekts und kannst diese erläutern. Grundlegende Struktur einer Angular-Anwendung In Angular gibt es eine vordefinierte Struktur, die von Entwicklern empfohlen wird, um eine konsistente und leicht verständliche Anwendungsentwicklung sicherzustellen.\nDie grundlegende Struktur einer Angular-Anwendung besteht aus folgenden Files:\nModule: Ein Angular-Modul ist eine Sammlung von Components, Services, Directives und anderen Funktionen, die für eine bestimmte Funktionalität oder einen bestimmten Zweck zusammengefasst werden. Ein Modul wird in der Regel in einem separaten File deklariert und exportiert.\nComponent: Ein Angular-Component ist eine Klasse, die das Verhalten und das Aussehen einer Benutzeroberflächeneinheit definiert. Ein Component besteht aus TypeScript-Files und einer Vorlage, die das HTML definiert, das die Benutzeroberfläche darstellt. Ein Component kann andere Component enthalten oder sich selbst in andere Components einbetten.\nServices: Ein Angular-Service ist eine Klasse, die Funktionen und Daten bereitstellt, die von anderen Teilen der Anwendung verwendet werden können. Ein Service kann z.B. eine Datenbankabfrage durchführen, eine REST-API aufrufen oder Benutzerinformationen verwalten.\nDirectives: Eine Angular-Directive ist eine Anweisung, die auf ein HTML-Element angewendet wird, um sein Verhalten oder Aussehen zu ändern. Eine Directive kann z.B. ein Attribut oder eine Struktur sein, die das Verhalten eines HTML-Elements steuert oder ein Template-Element sein, das dynamisch in die Benutzeroberfläche eingefügt wird.\nTemplate: Ein Template ist die HTML-Datei, die ein Component darstellt. Es kann auch spezielle Angular-Directives und -Syntax verwenden, um die Interaktivität und Funktionalität der Anwendung zu verbessern.\nOrdnerstruktur Die Ordnerstruktur in Angular kann nach persönlichen Präferenzen gewählt werden. Jedoch ist die unten folgenden Struktur die gängigste Best-Practice-Variante und sollte daher auch immer so angewendet werden. Die Struktur bietet eine klare Trennung der verschiedenen Artefakte einer Angular-Anwendung und fördert die Modularität, Wiederverwendbarkeit und Testbarkeit des Codes.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 ├── e2e │ └── ... ├── src │ ├── app │ │ ├── components │ │ │ ├── component1 │ │ │ │ ├── component1.component.ts │ │ │ │ ├── component1.component.html │ │ │ │ ├── component1.component.scss │ │ │ │ └── component1.component.spec.ts │ │ │ ├── component2 │ │ │ │ ├── component2.component.ts │ │ │ │ ├── component2.component.html │ │ │ │ ├── component2.component.scss │ │ │ │ └── component2.component.spec.ts │ │ │ └── ... │ │ ├── services │ │ │ ├── service1 │ │ │ │ ├── service1.service.ts │ │ │ │ └── service1.service.spec.ts │ │ │ ├── service2 │ │ │ │ ├── service2.service.ts │ │ │ │ └── service2.service.spec.ts │ │ │ └── ... │ │ ├── directives │ │ │ ├── directive1 │ │ │ │ ├── directive1.directive.ts │ │ │ │ └── directive1.directive.spec.ts │ │ │ ├── directive2 │ │ │ │ ├── directive2.directive.ts │ │ │ │ └── directive2.directive.spec.ts │ │ │ └── ... │ │ ├── shared │ │ │ ├── shared1 │ │ │ ├── shared2 │ │ │ └── ... │ │ ├── models │ │ │ ├── model1.ts │ │ │ ├── model2.ts │ │ │ └── ... │ │ ├── pipes │ │ │ ├── pipe1 │ │ │ │ ├── pipe1.pipe.ts │ │ │ │ └── pipe1.pipe.spec.ts │ │ │ ├── pipe2 │ │ │ │ ├── pipe2.pipe.ts │ │ │ │ └── pipe2.pipe.spec.ts │ │ │ └── ... │ │ ├── guards │ │ │ ├── guard1 │ │ │ │ ├── guard1.guard.ts │ │ │ │ └── guard1.guard.spec.ts │ │ │ ├── guard2 │ │ │ │ ├── guard2.guard.ts │ │ │ │ └── guard2.guard.spec.ts │ │ │ └── ... │ │ ├── modules │ │ │ ├── module1 │ │ │ │ ├── module1.module.ts │ │ │ │ └── module1.module.spec.ts │ │ │ ├── module2 │ │ │ │ ├── module2.module.ts │ │ │ │ └── module2.module.spec.ts │ │ │ └── ... │ │ ├── utilities │ │ │ ├── utility1.ts │ │ │ ├── utility2.ts │ │ │ └── ... │ │ ├── app.component.ts │ │ ├── app.component.html │ │ ├── app.component.scss │ │ ├── app.component.spec.ts │ │ ├── app.module.ts (Wird nicht mehr ohne weiteres automatisch erstellt) │ │ └── app.routing.module.ts │ ├── assets │ │ ├── images │ │ ├── fonts │ │ └── ... │ ├── styles │ │ ├── _variables.scss │ │ ├── _mixins.scss │ │ ├── main.scss │ │ └── ... │ ├── environments │ │ ├── environment.prod.ts │ │ └── environment.ts │ ├── index.html │ ├── main.ts │ ├── polyfills.ts │ ├── styles.scss │ └── ... ├── angular.json ├── package.json ├── tsconfig.json ├── tslint.json └── ... ","categories":"","description":"Modul #F6 - Angular - Angular Strukturen\n","excerpt":"Modul #F6 - Angular - Angular Strukturen\n","ref":"/docs/03_web/06_angular/02_2_strukturen/","tags":"","title":"Angular Strukturen"},{"body":"Ziele Du kennst die grundlegende Struktur eines Angular-Projekts und kannst diese erläutern. Grundlegende Struktur einer Angular-Anwendung In Angular gibt es eine vordefinierte Struktur, die von Entwicklern empfohlen wird, um eine konsistente und leicht verständliche Anwendungsentwicklung sicherzustellen.\nDie grundlegende Struktur einer Angular-Anwendung besteht aus folgenden Files:\nModule: Ein Angular-Modul ist eine Sammlung von Components, Services, Directives und anderen Funktionen, die für eine bestimmte Funktionalität oder einen bestimmten Zweck zusammengefasst werden. Ein Modul wird in der Regel in einem separaten File deklariert und exportiert.\nComponent: Ein Angular-Component ist eine Klasse, die das Verhalten und das Aussehen einer Benutzeroberflächeneinheit definiert. Ein Component besteht aus TypeScript-Files und einer Vorlage, die das HTML definiert, das die Benutzeroberfläche darstellt. Ein Component kann andere Component enthalten oder sich selbst in andere Components einbetten.\nServices: Ein Angular-Service ist eine Klasse, die Funktionen und Daten bereitstellt, die von anderen Teilen der Anwendung verwendet werden können. Ein Service kann z.B. eine Datenbankabfrage durchführen, eine REST-API aufrufen oder Benutzerinformationen verwalten.\nDirectives: Eine Angular-Directive ist eine Anweisung, die auf ein HTML-Element angewendet wird, um sein Verhalten oder Aussehen zu ändern. Eine Directive kann z.B. ein Attribut oder eine Struktur sein, die das Verhalten eines HTML-Elements steuert oder ein Template-Element sein, das dynamisch in die Benutzeroberfläche eingefügt wird.\nTemplate: Ein Template ist die HTML-Datei, die ein Component darstellt. Es kann auch spezielle Angular-Directives und -Syntax verwenden, um die Interaktivität und Funktionalität der Anwendung zu verbessern.\nOrdnerstruktur Die Ordnerstruktur in Angular kann nach persönlichen Präferenzen gewählt werden. Jedoch ist die unten folgenden Struktur die gängigste Best-Practice-Variante und sollte daher auch immer so angewendet werden. Die Struktur bietet eine klare Trennung der verschiedenen Artefakte einer Angular-Anwendung und fördert die Modularität, Wiederverwendbarkeit und Testbarkeit des Codes.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 ├── e2e │ └── ... ├── src │ ├── app │ │ ├── components │ │ │ ├── component1 │ │ │ │ ├── component1.component.ts │ │ │ │ ├── component1.component.html │ │ │ │ ├── component1.component.scss │ │ │ │ └── component1.component.spec.ts │ │ │ ├── component2 │ │ │ │ ├── component2.component.ts │ │ │ │ ├── component2.component.html │ │ │ │ ├── component2.component.scss │ │ │ │ └── component2.component.spec.ts │ │ │ └── ... │ │ ├── services │ │ │ ├── service1 │ │ │ │ ├── service1.service.ts │ │ │ │ └── service1.service.spec.ts │ │ │ ├── service2 │ │ │ │ ├── service2.service.ts │ │ │ │ └── service2.service.spec.ts │ │ │ └── ... │ │ ├── directives │ │ │ ├── directive1 │ │ │ │ ├── directive1.directive.ts │ │ │ │ └── directive1.directive.spec.ts │ │ │ ├── directive2 │ │ │ │ ├── directive2.directive.ts │ │ │ │ └── directive2.directive.spec.ts │ │ │ └── ... │ │ ├── shared │ │ │ ├── shared1 │ │ │ ├── shared2 │ │ │ └── ... │ │ ├── models │ │ │ ├── model1.ts │ │ │ ├── model2.ts │ │ │ └── ... │ │ ├── pipes │ │ │ ├── pipe1 │ │ │ │ ├── pipe1.pipe.ts │ │ │ │ └── pipe1.pipe.spec.ts │ │ │ ├── pipe2 │ │ │ │ ├── pipe2.pipe.ts │ │ │ │ └── pipe2.pipe.spec.ts │ │ │ └── ... │ │ ├── guards │ │ │ ├── guard1 │ │ │ │ ├── guard1.guard.ts │ │ │ │ └── guard1.guard.spec.ts │ │ │ ├── guard2 │ │ │ │ ├── guard2.guard.ts │ │ │ │ └── guard2.guard.spec.ts │ │ │ └── ... │ │ ├── modules │ │ │ ├── module1 │ │ │ │ ├── module1.module.ts │ │ │ │ └── module1.module.spec.ts │ │ │ ├── module2 │ │ │ │ ├── module2.module.ts │ │ │ │ └── module2.module.spec.ts │ │ │ └── ... │ │ ├── utilities │ │ │ ├── utility1.ts │ │ │ ├── utility2.ts │ │ │ └── ... │ │ ├── app.component.ts │ │ ├── app.component.html │ │ ├── app.component.scss │ │ ├── app.component.spec.ts │ │ ├── app.module.ts (Wird nicht mehr ohne weiteres automatisch erstellt) │ │ └── app.routing.module.ts │ ├── assets │ │ ├── images │ │ ├── fonts │ │ └── ... │ ├── styles │ │ ├── _variables.scss │ │ ├── _mixins.scss │ │ ├── main.scss │ │ └── ... │ ├── environments │ │ ├── environment.prod.ts │ │ └── environment.ts │ ├── index.html │ ├── main.ts │ ├── polyfills.ts │ ├── styles.scss │ └── ... ├── angular.json ├── package.json ├── tsconfig.json ├── tslint.json └── ... ","categories":"","description":"Modul #F6 - Angular - Angular Strukturen\n","excerpt":"Modul #F6 - Angular - Angular Strukturen\n","ref":"/de/docs/03_web/06_angular/02_2_strukturen/","tags":"","title":"Angular Strukturen"},{"body":"Exam - Zeiterfassungs-Dashboard mit JavaScript ergänzen - Einzelarbeit\nBei diesem Exam geht es darum, dass du das Dashboard, welches du im HTML-CSS-Exam geschrieben hast, mit JavaScript-Logik ergänzt.\nDie Seite sollte ungefähr so aussehen:\nZeitangaben aktualisieren Oben links im Zeiterfassungstool ist die aktuelle Zeit zu finden.\nSchreibe ein JavaScript auf dieser Seite, das die aktuelle Zeit oben links anzeigt. Hinweis:\nUm auf die aktuelle Uhrzeit und auf das Datum zuzugreifen, wirst du sicher auf die Klasse Date zugreifen müssen. Hier findest du mehr Informationen darüber: https://www.w3schools.com/jsref/jsref_obj_date.asp\nDie Kalenderwoche (KW) hinzuzufügen, ist ein bisschen tricky und deswegen optional. Wenn du diese trotzdem hinzufügen möchtest, dann informiere dich bitte zuerst darüber, was genau eine Kalenderwoche ist. Soweit ich weiss, gibt es keine eingebaute Methode, mit der du die Kalenderwoche bekommst, aber du kannst sie berechnen.\nNavigation zuklappen Auf der linken Seite hast du eine Navigation. Das Element für “Abfragen” hat wiederum Elemente untergeordnet. Diese Unterelemente sollten beim Klick auf den Pfeil gegen oben (^) verschwinden/zugeklappt werden.\nSchreibe ein JavaScript, das dem User erlaubt, das \"Abfragen\"-Element zuzuklappen und wenn es zugeklappt ist, wieder aufzuklappen. Animationen Wenn du möchtest, kannst du dem Ganzen Animationen verleihen:\nder Pfleil dreht sich, jenachdem ob das Element zu- oder aufgeklappt ist das “Berichte”-Element geht langsam nach oben (bzw. der Container mit den Unterelementen wird immer kleiner) Animationen (bzw. transitions) können sehr einfach mit CSS umgesetzt werden, siehe https://www.w3schools.com/css/css3_transitions.asp.\nDamit du weniger Schwierigkeiten damit hast, hier ein kleiner Tipp: Gib allen CSS-Properties einen Default-Wert. Wenn du z.B. einen Wert ändern möchtest, füge dem Element eine genauere CSS-Klasse mit JavaScript hinzu, welche die entsprechenden Regeln überschreibt. Du kannst einem Element eine Klasse hinzufügen bzw. entfernen mit .classList.toggle(className, show?) (Beispiel: document.getElementById('abfragen').classList.toggle('show-child-elements', true)).\nDashboard-Daten dynamisch laden Im HTML-CSS-Exam hast du den Text für die Kacheln hartcodiert. Das soll sich nun ändern.\nSchreibe nun ein JavaScript, dass den Inhalt der Kacheln dynamisch befüllt. Dein Script soll die Daten von hier laden: https://raw.githubusercontent.com/it-ninjas/labs/master/static/files/json/dashboard.json https://raw.githubusercontent.com/it-ninjas/labs/master/static/files/json/dashboard2.json Stelle sicher, dass beide Dateien funktionieren. Personen für den Chat dynamisch laden Auf der rechten Seite hast du eine Liste mit Personen für einen Chat. Nun geht es darum, auch diese Liste anhand eines JSONs zu generieren.\nErgänze dein JavaScript so, dass die Namen für die Chat-Liste von hier geladen werden: https://raw.githubusercontent.com/it-ninjas/labs/master/static/files/json/chat.json Zeige die Personen dann zeitlich versetzt an: Füge zuerst die erste Person ein, warte dann ca. 0.3 Sekunden, zeige dann die zweite Person an usw. Suchfunktion Oben rechts hast du eine “Suche”.\nImplementiere eine Suchfunktion, die nur noch diejenigen Chat-Kontakte anzeigt, wenn der Suchbegriff in deren Namen vorkommt. Implementiere die Suche so, dass die Liste beim Tippen aktualisiert wird. Refresh-Button Oben rechts gibt es einen Refresh-Button.\nVerändere dein HTML und JavaScript so, dass die Daten neu geladen werden, wenn der User auf diesen Refresh-Button klickt. Neu geladen werden sollen die Zeitangaben, die Kacheln und der Chat Achte darauf, dass du möglichst keine Code-Duplikation hast. ","categories":"","description":"Erweitere dein eigenes Zeiterfassungs-Dashboard - mit JavaScript.\n","excerpt":"Erweitere dein eigenes Zeiterfassungs-Dashboard - mit JavaScript.\n","ref":"/exams/03_web/03_javascript/","tags":"","title":"Exam zu JavaScript"},{"body":"Exam - Zeiterfassungs-Dashboard mit JavaScript ergänzen - Einzelarbeit\nBei diesem Exam geht es darum, dass du das Dashboard, welches du im HTML-CSS-Exam geschrieben hast, mit JavaScript-Logik ergänzt.\nDie Seite sollte ungefähr so aussehen:\nZeitangaben aktualisieren Oben links im Zeiterfassungstool ist die aktuelle Zeit zu finden.\nSchreibe ein JavaScript auf dieser Seite, das die aktuelle Zeit oben links anzeigt. Hinweis:\nUm auf die aktuelle Uhrzeit und auf das Datum zuzugreifen, wirst du sicher auf die Klasse Date zugreifen müssen. Hier findest du mehr Informationen darüber: https://www.w3schools.com/jsref/jsref_obj_date.asp\nDie Kalenderwoche (KW) hinzuzufügen, ist ein bisschen tricky und deswegen optional. Wenn du diese trotzdem hinzufügen möchtest, dann informiere dich bitte zuerst darüber, was genau eine Kalenderwoche ist. Soweit ich weiss, gibt es keine eingebaute Methode, mit der du die Kalenderwoche bekommst, aber du kannst sie berechnen.\nNavigation zuklappen Auf der linken Seite hast du eine Navigation. Das Element für “Abfragen” hat wiederum Elemente untergeordnet. Diese Unterelemente sollten beim Klick auf den Pfeil gegen oben (^) verschwinden/zugeklappt werden.\nSchreibe ein JavaScript, das dem User erlaubt, das \"Abfragen\"-Element zuzuklappen und wenn es zugeklappt ist, wieder aufzuklappen. Animationen Wenn du möchtest, kannst du dem Ganzen Animationen verleihen:\nder Pfleil dreht sich, jenachdem ob das Element zu- oder aufgeklappt ist das “Berichte”-Element geht langsam nach oben (bzw. der Container mit den Unterelementen wird immer kleiner) Animationen (bzw. transitions) können sehr einfach mit CSS umgesetzt werden, siehe https://www.w3schools.com/css/css3_transitions.asp.\nDamit du weniger Schwierigkeiten damit hast, hier ein kleiner Tipp: Gib allen CSS-Properties einen Default-Wert. Wenn du z.B. einen Wert ändern möchtest, füge dem Element eine genauere CSS-Klasse mit JavaScript hinzu, welche die entsprechenden Regeln überschreibt. Du kannst einem Element eine Klasse hinzufügen bzw. entfernen mit .classList.toggle(className, show?) (Beispiel: document.getElementById('abfragen').classList.toggle('show-child-elements', true)).\nDashboard-Daten dynamisch laden Im HTML-CSS-Exam hast du den Text für die Kacheln hartcodiert. Das soll sich nun ändern.\nSchreibe nun ein JavaScript, dass den Inhalt der Kacheln dynamisch befüllt. Dein Script soll die Daten von hier laden: https://raw.githubusercontent.com/it-ninjas/labs/master/static/files/json/dashboard.json https://raw.githubusercontent.com/it-ninjas/labs/master/static/files/json/dashboard2.json Stelle sicher, dass beide Dateien funktionieren. Personen für den Chat dynamisch laden Auf der rechten Seite hast du eine Liste mit Personen für einen Chat. Nun geht es darum, auch diese Liste anhand eines JSONs zu generieren.\nErgänze dein JavaScript so, dass die Namen für die Chat-Liste von hier geladen werden: https://raw.githubusercontent.com/it-ninjas/labs/master/static/files/json/chat.json Zeige die Personen dann zeitlich versetzt an: Füge zuerst die erste Person ein, warte dann ca. 0.3 Sekunden, zeige dann die zweite Person an usw. Suchfunktion Oben rechts hast du eine “Suche”.\nImplementiere eine Suchfunktion, die nur noch diejenigen Chat-Kontakte anzeigt, wenn der Suchbegriff in deren Namen vorkommt. Implementiere die Suche so, dass die Liste beim Tippen aktualisiert wird. Refresh-Button Oben rechts gibt es einen Refresh-Button.\nVerändere dein HTML und JavaScript so, dass die Daten neu geladen werden, wenn der User auf diesen Refresh-Button klickt. Neu geladen werden sollen die Zeitangaben, die Kacheln und der Chat Achte darauf, dass du möglichst keine Code-Duplikation hast. ","categories":"","description":"Erweitere dein eigenes Zeiterfassungs-Dashboard - mit JavaScript.\n","excerpt":"Erweitere dein eigenes Zeiterfassungs-Dashboard - mit JavaScript.\n","ref":"/de/exams/03_web/03_javascript/","tags":"","title":"Exam zu JavaScript"},{"body":"Auf DOM-Elemente zugreifen Eines der häufigsten Anwendungszwecke von JavaScript ist, mit Elementen auf einer Website zu interagieren.\nNehmen wir folgenden Codeausschnitt als Beispiel:\n1 2 3 4 \u003cdiv id=\"message-div\"\u003e\u003c/div\u003e \u003cp\u003eThis page has \u003cspan id=\"likes-count\"\u003e0\u003c/span\u003e likes.\u003c/p\u003e \u003cbutton type=\"button\"\u003e+1\u003c/button\u003e Wir möchten mit Javascript bewerkstelligen, dass sich die Zahl im \u003cspan\u003e erhöht. In einem ersten Schritt versuchen wir, direkt auf das \u003cspan\u003e-Element selbst zuzugreifen und eine andere Zahl als Wert zu übergeben. Probiere das direkt in der Konsole deines Browsers aus:\n1 2 let span = document.getElementById(\"likes-count\"); span.textContent = 999; Du wirst sehen, dass sich die Zahl im \u003cspan\u003e-Element tatsächlich verändert hat. Probieren wir mal zu verstehen, was im Code passiert:\nErläuterung (click to expand) document ist ein Objekt, welches uns im Browser zur Verfügung steht. Dieses Objekt repräsentiert das DOM. Mit diesem document-Objekt können wir in Javascript auf die einzelnen Elemente im Browser zugreifen. getElementById(...) ist eine Methode dieses document-Objekts. Diese Methode sucht auf der aktuellen Seite das Element, welches die als Parameter übergebene id besitzt. Das gefundene Element möchten wir in einer Variable namens span zwischenspeichern. textContent ist ein Attribut auf dem gesuchten \u003cspan\u003e-Element, welches den Inhalt des Elements in textform repräsentiert. Mithilfe dieses Codeausschnitts konnten wir die Anzahl Likes auf einen anderen Zahlenwert setzen. Nun möchten wir aber, dass sich diese Anzahl um genau 1 erhöht. Dazu müssen wir die folgenden Schritte durchführen:\nDie aktuelle Zahl auslesen Diese Zahl von einem String in eine Nummer konvertieren Die inkrementierte Zahl ins \u003cspan\u003e schreiben. Versuch einmal, das selbst zu implementieren, bevor du dir die Lösung dazu ansiehst.\nLösung (click to expand) Eine Lösung für die gegebenen Anforderungen könnte wie folgt aussehen: 1 2 3 4 let span = document.getElementById(\"likes-count\"); let likes = parseInt(span.textContent); likes++; span.textContent = likes; In diesem Codeausschnitt kannst du einige neue Kontrollstrukturen erkennen:\nDer Aufruf von parseInt(...). Diese Methode ist standardmässig global verfügbar und kann somit ohne zusätzliche Imports verwendet werden. Diese Methode wird verwendet, um den als Parameter übergebenen Wert in eine Ganzzahl (Integer) zu konvertieren. likes++ ist gleichzusetzen mit dem Ausdruck likes = likes + 1. Damit erhöhen wir die likes-Variable also um 1. Diesen Vorgang beschreibt man meistens als Inkrementierung. Mit der Zeile span.textContent = likes setzen wir den Text des spans neu. Eine explizite Umwandlung des Werts in einen String ist nicht notwendig. Versuche jetzt den obenstehenden Codeausschnitt mal aus, ohne die parseInt-Methode zu verwenden. Du wirst sehen, dass der Code trotzdem funktioniert. Das liegt daran, dass JS keine “starken” typen (strong types) kennt. Das heisst konkret, dass der JS-Interpreter versucht, den String auch als Zahl zu verwenden. Wenn es sich wirklich um eine Zahl handelt, funktioniert das auch:\n1 2 3 4 5 6 function onLikeClick() { let span = document.getElementById(\"likes-count\"); let likes = span.textContent; likes++; span.textContent = likes; } Dieses Vorgehen ist aber ziemlich fragil, weshalb es grundsätzlich immer empfehlenswert ist, die verwendeten Werten dennoch immer in die korrekten Typen umzuwandeln.\nManipulation beim Button-Klick ausführen lassen Als Letztes wollen wir jetzt noch, dass die Funktionalität, welche wir vorher programmiert haben, dann ausgeführt wird, wenn der User auf den Button klickt. Ändere das HTML-Dokument daher wie folgt ab:\n1 2 3 4 5 6 7 8 9 10 11 12 ... \u003cbutton type=\"button\" onclick=\"onLikeClick()\"\u003e+1\u003c/button\u003e \u003cscript\u003e function onLikeClick() { let span = document.getElementById(\"likes-count\"); let likes = parseInt(span.textContent); likes++; span.textContent = likes; } \u003c/script\u003e ... Was passiert hier genau? Im button-Element haben wir das Attribut onclick= hinzugefügt, welches jeweils darauf wartet, dass auf dem Knopf aus ein Klick-Event passiert. Wenn also der Nutzer auf den Knopf drückt und somit das onclick-Event getriggert wird, wird der Teil innerhalb von onclick ausgeführt, in diesem Fall ein Aufruf auf die onLikeClick()-Funktion. Indem wir innerhalb des \u003cscript\u003e-Tags unseren Code als Funktion onLikeClick zusammengefasst haben, wird nun bei jedem Klick auf den Knopf diese ausgeführt und somit der Wert von likes um 1 erhöht.\nEin neues Element hinzufügen Manchmal möchtest du über Javascript ein neues Element auf deiner Website generieren lassen.\nIm kommenden Beispiel möchten wir eine der Anzahl Likes entsprechende Anzahl Instanzen eines “ThumbsUp”-Bilds (also 👍) anzeigen.\nUm das zu erzielen, kannst du die onLikeClick-Funktion mit dem folgenden Codeausschnitt erweitern:\n1 2 3 4 5 6 7 8 9 // draw a thumb up for every like: const imgHtml = '\u003cimg src=\"https://upload.wikimedia.org/wikipedia/commons/c/ce/Emoji_u1f44d.svg\" alt=\"like\" height=\"25\"\u003e'; let insertHtml = \"\"; for (let i = 0; i \u003c likes; i++) { insertHtml += imgHtml; } const messageDiv = document.querySelector(\"div#message-div\"); messageDiv.innerHTML = insertHtml; In diesem Abschnitt passiert das Folgende:\nfür jeden Like wird im \u003cdiv id=\"message-div\"\u003e folgendes \u003cimg\u003e-Element hinzugefügt: \u003cimg src=\"https://upload.wikimedia.org/wikipedia/commons/c/ce/Emoji_u1f44d.svg\" alt=\"like\" height=\"25\"\u003e Das HTML-Element dieses Bilds haben wir zuerst in einer Konstante (const) gespeichert. const ist prinzipiell dasselbe wie let, nur mit dem Unterschied, dass sich dieser Wert nach der Initialisierung nie verändern darf. Die String-Variable insertHtml brauchen wir als Zwischenspeicher, in welcher wir den HTML-String zusammensetzen, welchen wir später in das DOM einspeisen möchten. Die Anzahl der Durchläufe der for-Schlaufe entspricht der Anzahl Likes. Das bedeutet, dass pro Like ein Bild in insertHtml kopiert wird. Anschliessend holen wir uns das \u003cdiv id=\"message-div\"\u003e-Element via JavaScript. Wir hätten hier auch document.getElementById('message-div') verwenden können, querySelector funktioniert hier aber auch. Die querySelector-Funktion akzeptiert als Argument einen CSS-Selektor und gibt dann das entsprechende Element zurück, das damit angesprochen wird. In diesem Beispiel war div#message-div ein möglicher CSS-Selektor (wie #message-div auch), der das \u003cdiv id=\"message-div\" anspricht. Als Letztes verändern wir das HTML dieses \u003cdiv\u003e-Elements, indem wir das innerHTML-Feld neu populieren. Elemente können nicht nur mit dem querySelector hinzugefügt werden, sondern auch mit document.createElement(). Mit der document.createElement()-Methode kann man neue HTML-Elemente dynamisch erstellen und diese im DOM hinzufügen.\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u003c!doctype html\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eJavaScript Create Element\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eJavaScript Create Element\u003c/h1\u003e \u003cdiv id=\"container\"\u003e \u003c!-- Hier werden die neuen Elemente hinzugefügt --\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e 1 2 3 4 5 6 7 var container = document.getElementById(\"container\"); // Erstelle ein neues \u003cp\u003e-Element var paragraph = document.createElement(\"p\"); paragraph.textContent = \"Dies ist ein neuer Absatz.\"; // Füge das \u003cp\u003e-Element dem \u003cdiv\u003e-Element hinzu container.appendChild(paragraph); Nun hast du schon ein paar Dinge auf deiner Seite mit JavaScript dynamisch verändert.\nBitte denke dran, dass das Verwenden von .innerHTML als eine Art “Holzfäller-Methode” angesehen wird. JavaScript bietet hierfür elegantere Möglichkeiten, die aber oft umständlicher sind. Schaue dir diese trotzdem kurz an: https://www.w3schools.com/js/js_htmldom_nodes.asp\n","categories":"","description":"Modul #F4 - JavaScript - Website mithilfe von JavaScript manipulieren.\n","excerpt":"Modul #F4 - JavaScript - Website mithilfe von JavaScript manipulieren. …","ref":"/docs/03_web/03_javascript/03_dom-manipulation/","tags":"","title":"Mit JavaScript das DOM verändern"},{"body":"Auf DOM-Elemente zugreifen Eines der häufigsten Anwendungszwecke von JavaScript ist, mit Elementen auf einer Website zu interagieren.\nNehmen wir folgenden Codeausschnitt als Beispiel:\n1 2 3 4 \u003cdiv id=\"message-div\"\u003e\u003c/div\u003e \u003cp\u003eThis page has \u003cspan id=\"likes-count\"\u003e0\u003c/span\u003e likes.\u003c/p\u003e \u003cbutton type=\"button\"\u003e+1\u003c/button\u003e Wir möchten mit Javascript bewerkstelligen, dass sich die Zahl im \u003cspan\u003e erhöht. In einem ersten Schritt versuchen wir, direkt auf das \u003cspan\u003e-Element selbst zuzugreifen und eine andere Zahl als Wert zu übergeben. Probiere das direkt in der Konsole deines Browsers aus:\n1 2 let span = document.getElementById(\"likes-count\"); span.textContent = 999; Du wirst sehen, dass sich die Zahl im \u003cspan\u003e-Element tatsächlich verändert hat. Probieren wir mal zu verstehen, was im Code passiert:\nErläuterung (click to expand) document ist ein Objekt, welches uns im Browser zur Verfügung steht. Dieses Objekt repräsentiert das DOM. Mit diesem document-Objekt können wir in Javascript auf die einzelnen Elemente im Browser zugreifen. getElementById(...) ist eine Methode dieses document-Objekts. Diese Methode sucht auf der aktuellen Seite das Element, welches die als Parameter übergebene id besitzt. Das gefundene Element möchten wir in einer Variable namens span zwischenspeichern. textContent ist ein Attribut auf dem gesuchten \u003cspan\u003e-Element, welches den Inhalt des Elements in textform repräsentiert. Mithilfe dieses Codeausschnitts konnten wir die Anzahl Likes auf einen anderen Zahlenwert setzen. Nun möchten wir aber, dass sich diese Anzahl um genau 1 erhöht. Dazu müssen wir die folgenden Schritte durchführen:\nDie aktuelle Zahl auslesen Diese Zahl von einem String in eine Nummer konvertieren Die inkrementierte Zahl ins \u003cspan\u003e schreiben. Versuch einmal, das selbst zu implementieren, bevor du dir die Lösung dazu ansiehst.\nLösung (click to expand) Eine Lösung für die gegebenen Anforderungen könnte wie folgt aussehen: 1 2 3 4 let span = document.getElementById(\"likes-count\"); let likes = parseInt(span.textContent); likes++; span.textContent = likes; In diesem Codeausschnitt kannst du einige neue Kontrollstrukturen erkennen:\nDer Aufruf von parseInt(...). Diese Methode ist standardmässig global verfügbar und kann somit ohne zusätzliche Imports verwendet werden. Diese Methode wird verwendet, um den als Parameter übergebenen Wert in eine Ganzzahl (Integer) zu konvertieren. likes++ ist gleichzusetzen mit dem Ausdruck likes = likes + 1. Damit erhöhen wir die likes-Variable also um 1. Diesen Vorgang beschreibt man meistens als Inkrementierung. Mit der Zeile span.textContent = likes setzen wir den Text des spans neu. Eine explizite Umwandlung des Werts in einen String ist nicht notwendig. Versuche jetzt den obenstehenden Codeausschnitt mal aus, ohne die parseInt-Methode zu verwenden. Du wirst sehen, dass der Code trotzdem funktioniert. Das liegt daran, dass JS keine “starken” typen (strong types) kennt. Das heisst konkret, dass der JS-Interpreter versucht, den String auch als Zahl zu verwenden. Wenn es sich wirklich um eine Zahl handelt, funktioniert das auch:\n1 2 3 4 5 6 function onLikeClick() { let span = document.getElementById(\"likes-count\"); let likes = span.textContent; likes++; span.textContent = likes; } Dieses Vorgehen ist aber ziemlich fragil, weshalb es grundsätzlich immer empfehlenswert ist, die verwendeten Werten dennoch immer in die korrekten Typen umzuwandeln.\nManipulation beim Button-Klick ausführen lassen Als Letztes wollen wir jetzt noch, dass die Funktionalität, welche wir vorher programmiert haben, dann ausgeführt wird, wenn der User auf den Button klickt. Ändere das HTML-Dokument daher wie folgt ab:\n1 2 3 4 5 6 7 8 9 10 11 12 ... \u003cbutton type=\"button\" onclick=\"onLikeClick()\"\u003e+1\u003c/button\u003e \u003cscript\u003e function onLikeClick() { let span = document.getElementById(\"likes-count\"); let likes = parseInt(span.textContent); likes++; span.textContent = likes; } \u003c/script\u003e ... Was passiert hier genau? Im button-Element haben wir das Attribut onclick= hinzugefügt, welches jeweils darauf wartet, dass auf dem Knopf aus ein Klick-Event passiert. Wenn also der Nutzer auf den Knopf drückt und somit das onclick-Event getriggert wird, wird der Teil innerhalb von onclick ausgeführt, in diesem Fall ein Aufruf auf die onLikeClick()-Funktion. Indem wir innerhalb des \u003cscript\u003e-Tags unseren Code als Funktion onLikeClick zusammengefasst haben, wird nun bei jedem Klick auf den Knopf diese ausgeführt und somit der Wert von likes um 1 erhöht.\nEin neues Element hinzufügen Manchmal möchtest du über Javascript ein neues Element auf deiner Website generieren lassen.\nIm kommenden Beispiel möchten wir eine der Anzahl Likes entsprechende Anzahl Instanzen eines “ThumbsUp”-Bilds (also 👍) anzeigen.\nUm das zu erzielen, kannst du die onLikeClick-Funktion mit dem folgenden Codeausschnitt erweitern:\n1 2 3 4 5 6 7 8 9 // draw a thumb up for every like: const imgHtml = '\u003cimg src=\"https://upload.wikimedia.org/wikipedia/commons/c/ce/Emoji_u1f44d.svg\" alt=\"like\" height=\"25\"\u003e'; let insertHtml = \"\"; for (let i = 0; i \u003c likes; i++) { insertHtml += imgHtml; } const messageDiv = document.querySelector(\"div#message-div\"); messageDiv.innerHTML = insertHtml; In diesem Abschnitt passiert das Folgende:\nfür jeden Like wird im \u003cdiv id=\"message-div\"\u003e folgendes \u003cimg\u003e-Element hinzugefügt: \u003cimg src=\"https://upload.wikimedia.org/wikipedia/commons/c/ce/Emoji_u1f44d.svg\" alt=\"like\" height=\"25\"\u003e Das HTML-Element dieses Bilds haben wir zuerst in einer Konstante (const) gespeichert. const ist prinzipiell dasselbe wie let, nur mit dem Unterschied, dass sich dieser Wert nach der Initialisierung nie verändern darf. Die String-Variable insertHtml brauchen wir als Zwischenspeicher, in welcher wir den HTML-String zusammensetzen, welchen wir später in das DOM einspeisen möchten. Die Anzahl der Durchläufe der for-Schlaufe entspricht der Anzahl Likes. Das bedeutet, dass pro Like ein Bild in insertHtml kopiert wird. Anschliessend holen wir uns das \u003cdiv id=\"message-div\"\u003e-Element via JavaScript. Wir hätten hier auch document.getElementById('message-div') verwenden können, querySelector funktioniert hier aber auch. Die querySelector-Funktion akzeptiert als Argument einen CSS-Selektor und gibt dann das entsprechende Element zurück, das damit angesprochen wird. In diesem Beispiel war div#message-div ein möglicher CSS-Selektor (wie #message-div auch), der das \u003cdiv id=\"message-div\" anspricht. Als Letztes verändern wir das HTML dieses \u003cdiv\u003e-Elements, indem wir das innerHTML-Feld neu populieren. Elemente können nicht nur mit dem querySelector hinzugefügt werden, sondern auch mit document.createElement(). Mit der document.createElement()-Methode kann man neue HTML-Elemente dynamisch erstellen und diese im DOM hinzufügen.\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u003c!doctype html\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eJavaScript Create Element\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eJavaScript Create Element\u003c/h1\u003e \u003cdiv id=\"container\"\u003e \u003c!-- Hier werden die neuen Elemente hinzugefügt --\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e 1 2 3 4 5 6 7 var container = document.getElementById(\"container\"); // Erstelle ein neues \u003cp\u003e-Element var paragraph = document.createElement(\"p\"); paragraph.textContent = \"Dies ist ein neuer Absatz.\"; // Füge das \u003cp\u003e-Element dem \u003cdiv\u003e-Element hinzu container.appendChild(paragraph); Nun hast du schon ein paar Dinge auf deiner Seite mit JavaScript dynamisch verändert.\nBitte denke dran, dass das Verwenden von .innerHTML als eine Art “Holzfäller-Methode” angesehen wird. JavaScript bietet hierfür elegantere Möglichkeiten, die aber oft umständlicher sind. Schaue dir diese trotzdem kurz an: https://www.w3schools.com/js/js_htmldom_nodes.asp\n","categories":"","description":"Modul #F4 - JavaScript - Website mithilfe von JavaScript manipulieren.\n","excerpt":"Modul #F4 - JavaScript - Website mithilfe von JavaScript manipulieren. …","ref":"/de/docs/03_web/03_javascript/03_dom-manipulation/","tags":"","title":"Mit JavaScript das DOM verändern"},{"body":"Einführung Javascript ist eine interpretierte (nicht kompilierte) “cross-platform” Sprache. Sie kann Client- wie auch Server-seitig eingesetzt werden.\n","categories":"","description":"Die Programmiersprache jedes Browsers kennenlernen.\n","excerpt":"Die Programmiersprache jedes Browsers kennenlernen.\n","ref":"/docs/03_web/03_javascript/","tags":"","title":"JavaScript"},{"body":"Einführung Javascript ist eine interpretierte (nicht kompilierte) “cross-platform” Sprache. Sie kann Client- wie auch Server-seitig eingesetzt werden.\n","categories":"","description":"Die Programmiersprache jedes Browsers kennenlernen.\n","excerpt":"Die Programmiersprache jedes Browsers kennenlernen.\n","ref":"/de/docs/03_web/03_javascript/","tags":"","title":"JavaScript"},{"body":"","categories":"","description":"Exams zu Web-Technologien\n","excerpt":"Exams zu Web-Technologien\n","ref":"/exams/03_web/","tags":"","title":"Web Exams"},{"body":"","categories":"","description":"Exams zu Web-Technologien\n","excerpt":"Exams zu Web-Technologien\n","ref":"/de/exams/03_web/","tags":"","title":"Web Exams"},{"body":"Inhalt In diesem Kapitel lernst du alles rund um die Frontend-Entwicklung. Zuerst setzt du eine passende IDE auf, gefolgt von Basics zu HTML, CSS und JavaScript. Anschliessend geht es weiter mit TypeScript und Angular. Zum Schluss gibt es noch (optionale) Module zu Angular NgRx.\n","categories":"","description":"Web Technologie lernen\n","excerpt":"Web Technologie lernen\n","ref":"/docs/03_web/","tags":"","title":"Web"},{"body":"Inhalt In diesem Kapitel lernst du alles rund um die Frontend-Entwicklung. Zuerst setzt du eine passende IDE auf, gefolgt von Basics zu HTML, CSS und JavaScript. Anschliessend geht es weiter mit TypeScript und Angular. Zum Schluss gibt es noch (optionale) Module zu Angular NgRx.\n","categories":"","description":"Web Technologie lernen\n","excerpt":"Web Technologie lernen\n","ref":"/de/docs/03_web/","tags":"","title":"Web"},{"body":"","categories":"","description":"Labs zu Web\n","excerpt":"Labs zu Web\n","ref":"/labs/03_web/","tags":"","title":"Web Labs"},{"body":"","categories":"","description":"Labs zu Web\n","excerpt":"Labs zu Web\n","ref":"/de/labs/03_web/","tags":"","title":"Web Labs"},{"body":"Hallo Ninja!\nEs freut uns, dass du git kennenlernen willst!\nWir haben hier ein Lab für dich zusammengestellt, damit du in dieses Thema eintauchen kannst. Finde für dich heraus, warum git eine Zeitmaschine ist und was es mit den Paralleluniversen auf sich hat.\nZiele Du kannst …\ngit konfigurieren Repositories auschecken Branches erstellen und auschecken Commits erstellen und Commit Messages nach gegebenen Richtlinien formulieren Änderungen vom Server pullen Merge-/Pullrequests erstellen (z.B. auf Github, Bitbucket, Gitlab) Änderungen anhand der Git History nachvollziehen Branches mergen und rebasen Vielleicht sogar …\nCommits squashen Tags erstellen und pushen Aliasse einrichten Blame anwenden Schwerpunkte Dieses Lab unterteilt sich in folgende Themenbereiche:\nWas ist dieses Git? Git installieren Git Basics Git Branches GitHub Bitbucket Git Erweitert Nachdem du die Docs gelesen hast, solltest du in der Lage sein die Labs zu lösen.\nLet’s play! Meisterst du diese Challenges?\noh my git! learn git branching git immersion ","categories":"","description":"Verteilte Versionsverwaltung mit Git","excerpt":"Verteilte Versionsverwaltung mit Git","ref":"/docs/04_git/01_grundwissen/","tags":"","title":"Git Grundwissen"},{"body":"Hallo Ninja!\nEs freut uns, dass du git kennenlernen willst!\nWir haben hier ein Lab für dich zusammengestellt, damit du in dieses Thema eintauchen kannst. Finde für dich heraus, warum git eine Zeitmaschine ist und was es mit den Paralleluniversen auf sich hat.\nZiele Du kannst …\ngit konfigurieren Repositories auschecken Branches erstellen und auschecken Commits erstellen und Commit Messages nach gegebenen Richtlinien formulieren Änderungen vom Server pullen Merge-/Pullrequests erstellen (z.B. auf Github, Bitbucket, Gitlab) Änderungen anhand der Git History nachvollziehen Branches mergen und rebasen Vielleicht sogar …\nCommits squashen Tags erstellen und pushen Aliasse einrichten Blame anwenden Schwerpunkte Dieses Lab unterteilt sich in folgende Themenbereiche:\nWas ist dieses Git? Git installieren Git Basics Git Branches GitHub Bitbucket Git Erweitert Nachdem du die Docs gelesen hast, solltest du in der Lage sein die Labs zu lösen.\nLet’s play! Meisterst du diese Challenges?\noh my git! learn git branching git immersion ","categories":"","description":"Verteilte Versionsverwaltung mit Git","excerpt":"Verteilte Versionsverwaltung mit Git","ref":"/de/docs/04_git/01_grundwissen/","tags":"","title":"Git Grundwissen"},{"body":"Schreibe ein Programm, welches ein Adressbuch implementiert. Die Anwendung soll die einzelnen Kontakte der Personen in ein Adressbuch eintragen, wenn die entsprechende Methode aufgerufen wurde.\nEine Person besitzt\neinen Namen eine Email-Adresse eine Telefonnummer Das Adressbuch soll\ndie Anzahl der Kontakte im Adressbuch zurückliefern können einen neuen Kontakt in das Adressbuch einfügen einen Kontakt im Adressbuch durch den Namen finden einen Kontakt aus dem Adressbuch über die E-Mail-Adresse entfernen Generell gilt die Regel, dass jeder Kontakt einzigartig sein muss. Schreibe dazu eine eigene equals() Methode und verwende diese für die Überprüfung.\nWichtiger Hinweis In den OOP-Aufgaben sollen in den main-Methoden nur noch Objekte instanziert werden. Sämtliche Logik wie oben beschieben muss in den Klassen definiert werden. Du brauchst also eine Klasse Person und eine Klasse Adressbuch, welche alle Funktionen anbietet.\nEs soll kein Scanner eingesetzt werden.\nHier kannst du zurück zur Theorie.\n","categories":"","description":"Aufgabe zu Modul #J2 - OOP - Adressbuch\n","excerpt":"Aufgabe zu Modul #J2 - OOP - Adressbuch\n","ref":"/labs/02_java/04_java-oop/03_adressbuch/","tags":"","title":"Adressbuch"},{"body":"Schreibe ein Programm, welches ein Adressbuch implementiert. Die Anwendung soll die einzelnen Kontakte der Personen in ein Adressbuch eintragen, wenn die entsprechende Methode aufgerufen wurde.\nEine Person besitzt\neinen Namen eine Email-Adresse eine Telefonnummer Das Adressbuch soll\ndie Anzahl der Kontakte im Adressbuch zurückliefern können einen neuen Kontakt in das Adressbuch einfügen einen Kontakt im Adressbuch durch den Namen finden einen Kontakt aus dem Adressbuch über die E-Mail-Adresse entfernen Generell gilt die Regel, dass jeder Kontakt einzigartig sein muss. Schreibe dazu eine eigene equals() Methode und verwende diese für die Überprüfung.\nWichtiger Hinweis In den OOP-Aufgaben sollen in den main-Methoden nur noch Objekte instanziert werden. Sämtliche Logik wie oben beschieben muss in den Klassen definiert werden. Du brauchst also eine Klasse Person und eine Klasse Adressbuch, welche alle Funktionen anbietet.\nEs soll kein Scanner eingesetzt werden.\nHier kannst du zurück zur Theorie.\n","categories":"","description":"Aufgabe zu Modul #J2 - OOP - Adressbuch\n","excerpt":"Aufgabe zu Modul #J2 - OOP - Adressbuch\n","ref":"/de/labs/02_java/04_java-oop/03_adressbuch/","tags":"","title":"Adressbuch"},{"body":"Ziele Ich kenne die HTML-Tags \u003ch1\u003e und \u003cp\u003e und weiss, wofür ich diese verwende. Ich kenne die allgemeine Struktur und den Aufbau von HTML-Tags. Erklärung zum vorherigen Beispiel Im vorherigen Beispiel hatten wir diesen Code:\n1 2 3 4 5 6 7 \u003ch1\u003eKleiner Witz\u003c/h1\u003e \u003cp\u003e Wie viele Softwareentwickler braucht man, um eine Glühbirne auszuwechseln? \u003c/p\u003e \u003cp\u003eKeinen, das ist ein Hardware-Problem!\u003c/p\u003e Du hast gesehen, dass der Teil zwischen \u003ch1\u003e und \u003c/h1\u003e wie eine Überschrift formatiert wurde, und dass die jeweiligen Texte zwischen \u003cp\u003e und \u003c/p\u003e in eigenen Abschnitten dargestellt wurden.\nHTML Tags Damit hast du bereits die ersten “HTML Tags” kennengelernt: \u003ch1\u003e und \u003cp\u003e. \u003ch1\u003e wird für Überschriften und \u003cp\u003e für Absätze verwendet.\nHTML Tags sind wie Keywords (Schlüsselbegriffe), die beschreiben, wie der Browser deren Inhalt (Content) interpretiert.\nDie Tags inklusive deren Inhalt nennen wir “Element”. Das Element ist wie folgt aufgebaut:\nJedes Element beginnt mit einem “Opening Tag”. Zwischen diesem und dem Closing Tag befindet sich der Content, der auf Grundlage des Tags formatiert wird. Der Content wird oft “InnerText” oder “InnerHtml” genannt. Das Closing Tag hat immer vor dem Tag-Namen ein “/”, das symbolisiert, dass es sich um ein Closing Tag handelt.\nIm Opening Tag können Attribute vorkommen, die den Tag “konfigurieren”. Eine solche Konfiguration beinhaltet in den meisten Fällen einen Attribut-Key und -Value, welche mit einem Gleichzeichen verbunden werden. Der Attribut-Value (Wert) beginnt und endet in jedem Fall mit einem Anführungs- beziehungsweise Schlusszeichen, auch wenn der Wert eine Zahl oder true/false ist.\n","categories":"","description":"Modul #F3 - HTML und CSS - Der Aufbau eines HTML-Tags\n","excerpt":"Modul #F3 - HTML und CSS - Der Aufbau eines HTML-Tags\n","ref":"/docs/03_web/02_html_css/03_html-basics/","tags":"","title":"Basics zu HTML"},{"body":"Ziele Ich kenne die HTML-Tags \u003ch1\u003e und \u003cp\u003e und weiss, wofür ich diese verwende. Ich kenne die allgemeine Struktur und den Aufbau von HTML-Tags. Erklärung zum vorherigen Beispiel Im vorherigen Beispiel hatten wir diesen Code:\n1 2 3 4 5 6 7 \u003ch1\u003eKleiner Witz\u003c/h1\u003e \u003cp\u003e Wie viele Softwareentwickler braucht man, um eine Glühbirne auszuwechseln? \u003c/p\u003e \u003cp\u003eKeinen, das ist ein Hardware-Problem!\u003c/p\u003e Du hast gesehen, dass der Teil zwischen \u003ch1\u003e und \u003c/h1\u003e wie eine Überschrift formatiert wurde, und dass die jeweiligen Texte zwischen \u003cp\u003e und \u003c/p\u003e in eigenen Abschnitten dargestellt wurden.\nHTML Tags Damit hast du bereits die ersten “HTML Tags” kennengelernt: \u003ch1\u003e und \u003cp\u003e. \u003ch1\u003e wird für Überschriften und \u003cp\u003e für Absätze verwendet.\nHTML Tags sind wie Keywords (Schlüsselbegriffe), die beschreiben, wie der Browser deren Inhalt (Content) interpretiert.\nDie Tags inklusive deren Inhalt nennen wir “Element”. Das Element ist wie folgt aufgebaut:\nJedes Element beginnt mit einem “Opening Tag”. Zwischen diesem und dem Closing Tag befindet sich der Content, der auf Grundlage des Tags formatiert wird. Der Content wird oft “InnerText” oder “InnerHtml” genannt. Das Closing Tag hat immer vor dem Tag-Namen ein “/”, das symbolisiert, dass es sich um ein Closing Tag handelt.\nIm Opening Tag können Attribute vorkommen, die den Tag “konfigurieren”. Eine solche Konfiguration beinhaltet in den meisten Fällen einen Attribut-Key und -Value, welche mit einem Gleichzeichen verbunden werden. Der Attribut-Value (Wert) beginnt und endet in jedem Fall mit einem Anführungs- beziehungsweise Schlusszeichen, auch wenn der Wert eine Zahl oder true/false ist.\n","categories":"","description":"Modul #F3 - HTML und CSS - Der Aufbau eines HTML-Tags\n","excerpt":"Modul #F3 - HTML und CSS - Der Aufbau eines HTML-Tags\n","ref":"/de/docs/03_web/02_html_css/03_html-basics/","tags":"","title":"Basics zu HTML"},{"body":"Voraussetzungen Du hast Zugriff auf das Git-Tool Bitbucket\nGit (inkl. Git-Bash) ist auf deinem Computer installiert. Falls nicht, siehe: Git installieren\nDu hast die Grundeinstellungen für Git vorgenommen:\nKopieren git config --global user.name \"u123456\" git config --global user.email \"u123456@sbb.ch\" # Für Windows zusätzlich: git config --global core.autocrlf true git config --global core.longpaths true 1 2 3 4 5 6 7 git config --global user.name \"u123456\" git config --global user.email \"u123456@sbb.ch\" # Für Windows zusätzlich: git config --global core.autocrlf true git config --global core.longpaths true Wende dich an deinen Praxisbildner, falls du nicht bei der SBB arbeitest (und falls Du bei SBB arbeitest, kannst du in der !*Konfiguartion die spezifischen Anleitungen und Informationen freischalten -\u003e Wahl der Ausbildungsstätte).\nSchritt-für-Schritt Anleitung 1. Öffne Bitbucket Öffne !Bitbucket Logge dich ggf. ein 2. SSH-Schlüssel erstellen Öffne eine CMD Shell und gib den folgenden Befehl ein: In früheren Versionen von diesem Modul wurden RSA-Keys eingesetzt. Da diese Keys nicht mehr als sehr sicher gelten wechseln wir zu den besseren ed25519-Keys. Existiert die Datei bereits, dann überschreibe sie nicht!\nDer ssh-key ist ein Schlüssel um sich mit anderen Rechnern zu verbinden. Ändert man diesen Schlüssel, muss man auf den anderen Rechnern, wo man bisher Zugang hatte, überall den öffentlichen Teil (das Schlüsselloch) anpassen.\n1 ssh-keygen -t ed25519 -C \"deine.email@sbb.ch\" Drücke Enter für den Standardspeicherort\nOptional: Passphrase setzen\nDa sich der Schlüssel auf deinem Rechner in deinem persönlichen Ordner befindet, ist es ok, den Schlüssel nicht durch ein Passwort zu schützen. Die Schlüssel befinden sich in C:\\Users\\[username]\\.ssh\\: id_ed25519 (privat, niemals weitergeben) id_ed25519.pub (öffentlich) 3. SSH-Schlüssel zu Bitbucket hinzufügen Zeige den Öffentlichen Schlüssel an:\n1 type C:\\Users\\u123456\\.ssh\\id_ed25519.pub In Windows kannst du die Datei auch einfach mit notepad.exe öffnen und den Inhalt kopieren.\nKopiere den Inhalt und füge ihn unter SSH-Key hinzufügen ein.\n4. Erstelle ein Repository und klone es Öffne dein Bitbucket Konto\nKlicke auf Repository erstellen\nVergib einen Namen (z. B. it-ninja-[deinName]) und klicke auf Repository erstellen\nÖffne auf deinem Rechner den Ordner, wo Repositories abgelegt werden sollen\nWie Word-Dokumente unter Dokumente abgelegt werden, legen wir unseren Quellcode in einem seperaten Ordner ab. In der Talent Factory haben wir uns für C:\\Users\\u123456\\local_repos entschieden. Falls der Ordner noch nicht existiert, muss er zuerst erstellt werden:\nKopieren mkdir C:\\Users\\u123456\\local_repos 1 mkdir C:\\Users\\u123456\\local_repos Öffne ihn:\nKopieren cd C:\\Users\\u123456\\local_repos 1 cd C:\\Users\\u123456\\local_repos Clone das Repository. Den Befehl dazu findest du auf der Seite von deinem Projekt. Er sollte in etwa so aussehen: Kopieren git clone ssh://git@codessh.sbb.ch:7999/~u123456/it-ninja-[deinName].git 1 git clone ssh://git@codessh.sbb.ch:7999/~u123456/it-ninja-[deinName].git 5. Erstelle ein README.md und pushe es Mit diesem Schritt wird sichergestellt, dass es keinen leeren Master Branch gibt. Führe die folgenden Befehle aus:\nKopieren cd C:\\Users\\u123456\\local_repos\\it-ninja-[deinName] echo it-ninja repository \u003e ./README.md git add . git commit -m \"Initial Commit\" git push 1 2 3 4 5 cd C:\\Users\\u123456\\local_repos\\it-ninja-[deinName] echo it-ninja repository \u003e ./README.md git add . git commit -m \"Initial Commit\" git push 6. Praxisbildner berechtigen Repository in Bitbucket öffnen Zu Repository Settings → Repository Permissions navigieren Add user or group klicken Praxisbildner als Administratoren hinzufügen ","categories":"","description":"Praktische Anleitung zur Einrichtung eines Git-Repositories in Bitbucket\n","excerpt":"Praktische Anleitung zur Einrichtung eines Git-Repositories in …","ref":"/docs/99_tools/zusammenarbeit/source-repositories/personal-bitbucket/","tags":"","title":"Bitbucket Repository einrichten"},{"body":"Du hast bereits das springboottesting-Repository kennengelernt. In diesem hat es diverse Tests, welche mit mvn clean verify ausgeführt werden können. Nun wollen wir das die Tests bei jedem git push automatisch ausgeführt werden.\nAufgabe Für diese Aufgabe brauchst du einen Account bei GitHub.\nMache als erstes ein Fork, eine Kopie, des springboottesting-Repositories auf deinen GitHub-Account.\nÖffne das springboottesting-Repository Klicke oben rechts auf “Fork” Klicke auf den grünen Button “Create Fork” Nun solltest du ein springboottesting-Repository in deinem GitHub-Profil haben, welches eine 1:1 Kopie des Originals ist.\nIn diesem Repository soll mithilfe von GH Actions eine CI-Pipeline umgesetzt werden.\nAnforderungen Die Pipeline wird bei jedem git push ausgeführt Die Pipeline führt die Tests mit mvn clean verify aus Die Pipeline schlägt fehl, wenn ein Test fehlschlägt Die Pipeline hat am Anfang immer eine Message, welche den User angibt der die Pipeline ausgelöst hat Hier kannst du zurück zur Theorie.\n","categories":"","description":"Aufgaben zu CI-Pipeline\n","excerpt":"Aufgaben zu CI-Pipeline\n","ref":"/labs/02_java/08_java-testing/03_ci/","tags":"","title":"CI-Pipeline - Aufgaben (optional)"},{"body":"Du hast bereits das springboottesting-Repository kennengelernt. In diesem hat es diverse Tests, welche mit mvn clean verify ausgeführt werden können. Nun wollen wir das die Tests bei jedem git push automatisch ausgeführt werden.\nAufgabe Für diese Aufgabe brauchst du einen Account bei GitHub.\nMache als erstes ein Fork, eine Kopie, des springboottesting-Repositories auf deinen GitHub-Account.\nÖffne das springboottesting-Repository Klicke oben rechts auf “Fork” Klicke auf den grünen Button “Create Fork” Nun solltest du ein springboottesting-Repository in deinem GitHub-Profil haben, welches eine 1:1 Kopie des Originals ist.\nIn diesem Repository soll mithilfe von GH Actions eine CI-Pipeline umgesetzt werden.\nAnforderungen Die Pipeline wird bei jedem git push ausgeführt Die Pipeline führt die Tests mit mvn clean verify aus Die Pipeline schlägt fehl, wenn ein Test fehlschlägt Die Pipeline hat am Anfang immer eine Message, welche den User angibt der die Pipeline ausgelöst hat Hier kannst du zurück zur Theorie.\n","categories":"","description":"Aufgaben zu CI-Pipeline\n","excerpt":"Aufgaben zu CI-Pipeline\n","ref":"/de/labs/02_java/08_java-testing/03_ci/","tags":"","title":"CI-Pipeline - Aufgaben (optional)"},{"body":"Ziele Du weisst wofür Constraints verwendet werden Du kennst die wichtigsten Constraints Du kannst ein Constraint erstellen Was ist ein Constraint? Ein Constraint in SQL ist dazu da den Inhalt eines Attributs weiter zu beschränken. Theoretisch ist die Angabe des Datentyps bereits eine Art Constraint, da bestimmt wird was für ein Wertebereich eingefügt werden darf. Ein Constraint kann entweder beim Erstellen der Tabelle oder mit einem ALTER-Statement hinzugefügt werden. Constraints können sich auf eine Tabelle oder eine einzelne Spalte beziehen. Ebenso können mehrere Constraints, sowohl bei Tabellen als auch bei Spalten, gleichzeitig angewendet werden.\nNot Null Das Not Null Constraint legt fest, dass ein Attribut nicht Null, spricht nicht leer sein darf. Das kann beispielsweise bei einer Id, die zum Verbinden von Tabellen verwendet wird, eingesetzt werden, damit es immer einen Wert gibt. Hier ein Beispiel wie ein Not Null Constraint erstellt wird:\n1 CREATE TABLE person(personen_id number NOT NULL, vorname varchar(255), nachname varchar(255)); 1 2 3 4 5 6 7 8 -- Funktioniert nicht, da die Id nicht null sein darf. INSERT INTO person VALUES (null, null, null); -- Funktioniert nicht, da keine Id hinzugefügt wird. INSERT INTO person(vorname, nachname) VALUES (\"Peter\", \"Fischer\"); -- Funktioniert, da die Id angegeben wird und die anderen Attribute null sein dürfen. INSERT INTO person VALUES (1, null, null); Unique Das Unique Constraint bedingt, dass jeder eingefügte Wert einzigartig, also noch nicht in der Spalte oder in der Tabelle, vorhanden. So können beispielsweise duplikationen von Ids verhindert werden. Hier ein Beispiel zum Unique Constraint:\n1 CREATE TABLE person(personen_id number UNIQUE, vorname varchar(255), nachname varchar(255)); Beispieldaten Person:\npersonen_id vorname nachname 1 Hans Peterson 2 Peter Fritschi 3 Fritz Hansen 1 2 3 4 5 -- Funktioniert nicht, da bereits eine Person mit der personen_id 2 besteht. INSERT INTO person VALUES (2, \"Ueli\", \"Mueli\"); -- Funktioniert, da keine Person mit der personen_id 4 besteht. INSERT INTO person VALUES (4, \"Karl\", \"Karlsen\"); Primary Key Das Primary Key Constraint kombiniert prinzipiell die Constraints Unique und Not Null zu einem. Gerade für Ids ist dieses Constraint praktisch, da in eigentlich jedem Fall eine Id bestehen sollte und sie auch eindeutig sein sollte. Hier ein beispiel zum Primary Key:\n1 CREATE TABLE person(personen_id number PRIMARY KEY, vorname varchar(255), nachname varchar(255)); Beispieldaten Person:\npersonen_id vorname nachname 1 Hans Peterson 2 Peter Fritschi 3 Fritz Hansen 1 2 3 4 5 6 7 8 -- Funktioniert nicht, da keine personen_id angegeben wurde. INSERT INTO person VALUES (null, \"Philippe\", \"Pfister\"); -- Funktioniert nicht, da bereits eine Person mit der personen_id 2 besteht. INSERT INTO person VALUES (2, \"Ueli\", \"Mueli\"); -- Funktioniert, da keine Person mit der personen_id 4 besteht. INSERT INTO person VALUES (4, \"Karl\", \"Karlsen\"); Foreign Key Das Foreign Key Constraint stellt sicher, dass der Wert in einer Spalte einer Tabelle auf einen existierenden Wert in einer anderen Tabelle verweist. Das bedeutet, dass die Beziehungen zwischen den Tabellen beibehalten werden und Datenkonsistenz gewährleistet wird. Ein Fremdschlüssel wird durch das Verknüpfen von Spalten in verschiedenen Tabellen erstellt. Dazu wird im CREATE das Keyword REFERENCES verwendet. Dort wird angegeben, auf welche Spalte der Fremdschlüssel verweist. Hier ein Beispiel dazu:\n1 2 3 4 CREATE TABLE adresse(id number PRIMARY KEY, strasse varchar(255), hausnummer number, plz number, ort varchar(255)); CREATE TABLE person(id number PRIMARY KEY, vorname varchar(255), nachname varchar(255), alter number, adresse_id number FOREIGN KEY REFERENCES adresse(id)); Info: Die Benennung des Fremdschlüssels wurde in diesem Beispiel der Einfachheit halber nicht korrekt gemacht. Je nach Naming Convention im Projekt muss der Fremdschüssel anders benannt werden. Hier ein Link mit weiteren Infos: Naming Conventions SQL Server\nBeispiel Daten Person:\nid vorname nachname alter adresse_id 1 Christoph Spycher 45 1 2 Sepp Blatter 87 2 3 Gianni Infantion 53 2 4 Nilo Nashorn 2 3 Beispiel Daten Adresse:\nid strasse hausnummer plz ort 1 Papeiermuehlestrasse 71 3014 Bern 2 Seestrasse 27 8002 Zuerich 3 Binningerstrasse 30 3054 Basel 1 2 3 4 5 6 7 8 -- Funktioniert nicht, da in der Tabelle Adresse keine Adresse mit der Id 27 besteht. INSERT INTO person VALUES (5, \"Boris\", \"Biberratte\", 4, 27); -- Funktioniert, da die Id 3 in der Tabelle Adresse vergeben ist. INSERT INTO person VALUES (5, \"Hans\", \"Hecht\", 4, 3); -- Funktioniert, da der Foreign Key auch null sein darf. INSERT INTO person VALUES (5, \"Silvia\", \"Stachelschwein\", 4, null); ","categories":"","description":"","excerpt":"Ziele Du weisst wofür Constraints verwendet werden Du kennst die …","ref":"/docs/05_database/03_constraints/","tags":"","title":"Constraints"},{"body":"Ziele Du weisst wofür Constraints verwendet werden Du kennst die wichtigsten Constraints Du kannst ein Constraint erstellen Was ist ein Constraint? Ein Constraint in SQL ist dazu da den Inhalt eines Attributs weiter zu beschränken. Theoretisch ist die Angabe des Datentyps bereits eine Art Constraint, da bestimmt wird was für ein Wertebereich eingefügt werden darf. Ein Constraint kann entweder beim Erstellen der Tabelle oder mit einem ALTER-Statement hinzugefügt werden. Constraints können sich auf eine Tabelle oder eine einzelne Spalte beziehen. Ebenso können mehrere Constraints, sowohl bei Tabellen als auch bei Spalten, gleichzeitig angewendet werden.\nNot Null Das Not Null Constraint legt fest, dass ein Attribut nicht Null, spricht nicht leer sein darf. Das kann beispielsweise bei einer Id, die zum Verbinden von Tabellen verwendet wird, eingesetzt werden, damit es immer einen Wert gibt. Hier ein Beispiel wie ein Not Null Constraint erstellt wird:\n1 CREATE TABLE person(personen_id number NOT NULL, vorname varchar(255), nachname varchar(255)); 1 2 3 4 5 6 7 8 -- Funktioniert nicht, da die Id nicht null sein darf. INSERT INTO person VALUES (null, null, null); -- Funktioniert nicht, da keine Id hinzugefügt wird. INSERT INTO person(vorname, nachname) VALUES (\"Peter\", \"Fischer\"); -- Funktioniert, da die Id angegeben wird und die anderen Attribute null sein dürfen. INSERT INTO person VALUES (1, null, null); Unique Das Unique Constraint bedingt, dass jeder eingefügte Wert einzigartig, also noch nicht in der Spalte oder in der Tabelle, vorhanden. So können beispielsweise duplikationen von Ids verhindert werden. Hier ein Beispiel zum Unique Constraint:\n1 CREATE TABLE person(personen_id number UNIQUE, vorname varchar(255), nachname varchar(255)); Beispieldaten Person:\npersonen_id vorname nachname 1 Hans Peterson 2 Peter Fritschi 3 Fritz Hansen 1 2 3 4 5 -- Funktioniert nicht, da bereits eine Person mit der personen_id 2 besteht. INSERT INTO person VALUES (2, \"Ueli\", \"Mueli\"); -- Funktioniert, da keine Person mit der personen_id 4 besteht. INSERT INTO person VALUES (4, \"Karl\", \"Karlsen\"); Primary Key Das Primary Key Constraint kombiniert prinzipiell die Constraints Unique und Not Null zu einem. Gerade für Ids ist dieses Constraint praktisch, da in eigentlich jedem Fall eine Id bestehen sollte und sie auch eindeutig sein sollte. Hier ein beispiel zum Primary Key:\n1 CREATE TABLE person(personen_id number PRIMARY KEY, vorname varchar(255), nachname varchar(255)); Beispieldaten Person:\npersonen_id vorname nachname 1 Hans Peterson 2 Peter Fritschi 3 Fritz Hansen 1 2 3 4 5 6 7 8 -- Funktioniert nicht, da keine personen_id angegeben wurde. INSERT INTO person VALUES (null, \"Philippe\", \"Pfister\"); -- Funktioniert nicht, da bereits eine Person mit der personen_id 2 besteht. INSERT INTO person VALUES (2, \"Ueli\", \"Mueli\"); -- Funktioniert, da keine Person mit der personen_id 4 besteht. INSERT INTO person VALUES (4, \"Karl\", \"Karlsen\"); Foreign Key Das Foreign Key Constraint stellt sicher, dass der Wert in einer Spalte einer Tabelle auf einen existierenden Wert in einer anderen Tabelle verweist. Das bedeutet, dass die Beziehungen zwischen den Tabellen beibehalten werden und Datenkonsistenz gewährleistet wird. Ein Fremdschlüssel wird durch das Verknüpfen von Spalten in verschiedenen Tabellen erstellt. Dazu wird im CREATE das Keyword REFERENCES verwendet. Dort wird angegeben, auf welche Spalte der Fremdschlüssel verweist. Hier ein Beispiel dazu:\n1 2 3 4 CREATE TABLE adresse(id number PRIMARY KEY, strasse varchar(255), hausnummer number, plz number, ort varchar(255)); CREATE TABLE person(id number PRIMARY KEY, vorname varchar(255), nachname varchar(255), alter number, adresse_id number FOREIGN KEY REFERENCES adresse(id)); Info: Die Benennung des Fremdschlüssels wurde in diesem Beispiel der Einfachheit halber nicht korrekt gemacht. Je nach Naming Convention im Projekt muss der Fremdschüssel anders benannt werden. Hier ein Link mit weiteren Infos: Naming Conventions SQL Server\nBeispiel Daten Person:\nid vorname nachname alter adresse_id 1 Christoph Spycher 45 1 2 Sepp Blatter 87 2 3 Gianni Infantion 53 2 4 Nilo Nashorn 2 3 Beispiel Daten Adresse:\nid strasse hausnummer plz ort 1 Papeiermuehlestrasse 71 3014 Bern 2 Seestrasse 27 8002 Zuerich 3 Binningerstrasse 30 3054 Basel 1 2 3 4 5 6 7 8 -- Funktioniert nicht, da in der Tabelle Adresse keine Adresse mit der Id 27 besteht. INSERT INTO person VALUES (5, \"Boris\", \"Biberratte\", 4, 27); -- Funktioniert, da die Id 3 in der Tabelle Adresse vergeben ist. INSERT INTO person VALUES (5, \"Hans\", \"Hecht\", 4, 3); -- Funktioniert, da der Foreign Key auch null sein darf. INSERT INTO person VALUES (5, \"Silvia\", \"Stachelschwein\", 4, null); ","categories":"","description":"","excerpt":"Ziele Du weisst wofür Constraints verwendet werden Du kennst die …","ref":"/de/docs/05_database/03_constraints/","tags":"","title":"Constraints"},{"body":"Ziele Ich kann den Begriff Continuous Deployment erklären. Continuous Deployment Continuous Deployment, was verwirrenderweise ebenfalls gleich wie Continuous Delivery abgekürzt wird, treibt das Prinzip auf die Spitze. Jede Änderung wird sofort produktiv gesetzt, vorausgesetzt es gibt keinen Fehler in den automatisierten Tests.\nDas hat verschiedene Vorteile. Man kriegt sehr schnell Feedback von Kunden und es gibt keinen stressigen “Release-Day” mehr. Wenn man jedoch eine schlechte CI-Pipeline und/oder ungenügende Code-Reviews hat, führt das Verfahren zu mehr Problemen, als dass es nützt.\n","categories":"","description":"Fortlaufende Deployments\n","excerpt":"Fortlaufende Deployments\n","ref":"/docs/08_cicd/03_continuous-deployment/","tags":"","title":"Continuous Deployment"},{"body":"Ziele Ich kann den Begriff Continuous Deployment erklären. Continuous Deployment Continuous Deployment, was verwirrenderweise ebenfalls gleich wie Continuous Delivery abgekürzt wird, treibt das Prinzip auf die Spitze. Jede Änderung wird sofort produktiv gesetzt, vorausgesetzt es gibt keinen Fehler in den automatisierten Tests.\nDas hat verschiedene Vorteile. Man kriegt sehr schnell Feedback von Kunden und es gibt keinen stressigen “Release-Day” mehr. Wenn man jedoch eine schlechte CI-Pipeline und/oder ungenügende Code-Reviews hat, führt das Verfahren zu mehr Problemen, als dass es nützt.\n","categories":"","description":"Fortlaufende Deployments\n","excerpt":"Fortlaufende Deployments\n","ref":"/de/docs/08_cicd/03_continuous-deployment/","tags":"","title":"Continuous Deployment"},{"body":" Dieses Kapitel gehört zum Modul #J1 des Ausbildungsplans Ziele Ich weiss, was Datentypen sind. ⏱️ Geschätzte Lesezeit: 10 Minuten Datentypen In Java sind Variablen stark typisiert. Das bedeutet, dass jede Variable beim Erstellen mit einem Datentyp versehen werden muss. Damit wird sichergestellt, dass das Programm jederzeit weiss, um was für einen Typ es sich bei einer Variablen handelt.\nStell dir einen Gewürzschrank vor. Beim Kochen ist es sehr wichtig, dass man die richtigen Gewürze nimmt und weiss, welches Gewürz sich in welchem Gefäss befindet. Was würde passieren, wenn in einem Rezept steht, dass du Salz und Pfeffer nehmen sollst, die Gefässe aber nicht oder sogar falsch angeschrieben sind – und du zum ersten Mal vor dem Schrank stehst und auch nicht probieren kannst, was in welchem Gefäss drin ist? Um die Zahl 3 als ganzzahligen (Integer) Wert in der Variable sum zu speichern, schreibst du:\n1 int sum = 3; Seit Java 10 gibt es eine vereinfachte Schreibweise mit Typinferenz. Du kannst den Datentyp bei lokalen Variablen weglassen – Java erkennt den Typ automatisch. Verwende dazu das Schlüsselwort var:\n1 var sum = 20; Auch wenn du var verwendest, bleibt die Variable stark typisiert. Der Unterschied ist nur: Du schreibst den Typ nicht selbst hin – Java erkennt ihn automatisch anhand des zugewiesenen Werts. Zwei Arten von Datentypen In Java unterscheidet man zwischen:\nPrimitiven Datentypen Referenztypen Der Unterschied ist grundlegend:\nEin primitiver Typ speichert direkt den Wert (z. B. 3 oder true). Ein Referenztyp speichert eine Adresse – also den Ort im Speicher, wo das eigentliche Objekt liegt. Das hängt mit dem Java Memory Model zusammen. Die folgende Grafik zeigt das vereinfacht:\nStack und Heap Java arbeitet intern mit zwei Speicherbereichen:\nStack Memory: Hier liegen primitive Werte und Referenzen. Heap Space: Hier werden alle Objekte gespeichert, z. B. ein Car-Objekt. Im Bild siehst du: Die Variable car liegt auf dem Stack und zeigt auf ein Objekt im Heap.\nDer Grund für diese Aufteilung liegt darin, wie ein Programm Daten verarbeitet:\nWenn eine Methode aufgerufen wird, werden die Parameter, die du ihr übergibst, auf den Stack kopiert. Danach „springt“ das Programm in die Methode. Dort greift es auf die Werte auf dem Stack zu.\nBei primitiven Werten geht das sehr schnell – sie sind klein (nur ein paar Bytes) und lassen sich effizient kopieren.\nObjekte hingegen können viel Speicher benötigen – oft hunderte oder tausende Bytes. Wenn bei jedem Methodenaufruf das ganze Objekt kopiert würde, würde das das Programm stark verlangsamen. Deshalb wird das Objekt im Heap abgelegt, und nur eine Referenz (also die Adresse im Speicher) wird über den Stack an die Methode übergeben.\nDas spart Zeit und Speicher – und ist der Grund, warum Java primitive Typen und Referenztypen unterschiedlich behandelt.\nVergleiche von Werten Dieser Unterschied ist entscheidend, wenn du zwei Werte vergleichst:\nMit == vergleichst du Stack-Inhalte. Bei primitiven Typen also den Wert selbst. Bei Referenzen hingegen die Speicheradresse – also ob es dasselbe Objekt ist. Um den Inhalt zweier Objekte zu vergleichen, brauchst du die Methode equals(): 1 car1.equals(car2) Das prüft, ob die Objekte inhaltlich gleich sind, nicht ob sie identisch im Speicher sind.\nStell dir vor, du kommst zu deinem Auto zurück – und gleich daneben steht ein Auto vom exakt gleichen Modell, gleicher Farbe, gleicher Ausstattung. Eine fremde Person könnte nicht sagen, welches dein Auto ist, weil sie es nur oberflächlich betrachtet. Man müsste also bewusst festlegen, was genau verglichen wird: Die Farbe reicht vielleicht nicht aus. Eindeutig wird es mit der Fahrgestellnummer – oder, falls es keine Wechselnummer ist, mit dem Kennzeichen. Zeigen zwei Referenzen auf dasselbe Objekt, ist ein Vergleich mit equals() nicht nötig – == genügt in diesem Fall, da es sich garantiert um exakt dasselbe Objekt handelt.\nDu wirst später lernen, dass Java beim Vergleichen von Objekten standardmässig prüft, ob es sich um dieselben handelt – also ob beide genau auf dasselbe Objekt im Speicher zeigen.\nWenn man aber prüfen möchte, ob zwei Objekte inhaltlich gleich sind (z. B. zwei Autos mit gleicher Farbe und gleichem Modell), muss man in Java definieren, wie dieser Vergleich aussehen soll – zum Beispiel, worauf genau geachtet werden soll.\n","categories":"","description":"In diesem Module lernst du was Datentypen sind und was der Unterschied zwischen primitiven Datentypen und Referenztypen ist.\n","excerpt":"In diesem Module lernst du was Datentypen sind und was der Unterschied …","ref":"/docs/02_java/03_java-grundlagen/03_data_types/","tags":"","title":"Datentypen"},{"body":"Ziele Ich weiss, was Datentypen sind. Datentypen In Java sind Variablen stark typisiert. Das heisst, dass alle Variablen bei ihrer Erstellung mit einem Datentyp versehen werden müssen.\nUm z.B. eine Zahl wie 3 vom Typ int in eine Variable sum zu speichern, tun wir folgendes:\n1 int sum = 3; Seit Java 10 gibt es Typinferenz für lokale Variablen, das heisst, eine lokale Variable kann deklariert und initialisiert werden (muss gleichzeitig geschehen), ohne dass ein Datentyp angegeben werden muss - anstelle des Datentyps kann var verwendet werden:\n1 var sum = 20; Es gibt zwei Arten von Datentypen:\nPrimitive Datentypen und Referenztypen. Der grundlegende Unterschied besteht darin, dass eine primitive Variable den tatsächlichen Wert speichert, während eine Referenzvariable die Adresse des Objekts speichert, auf welches sie sich bezieht.\nDies hat mit dem Java Memory Modell zu tun. Das nachfolgende Bild zeigt das Java Memory Modell als einfache Darstellung:\nEs besteht grundsätzlich aus dem Stack Memory und dem Heap Space. Primitive Datentypen (wird im nächsten Kapitel erklärt) werden nur auf dem Stack angelegt. Objekte, wie das im Bild gezeigte Auto (Car), sind im Heap abgelegt. Die Referenz auf das Objekt wird auf dem Stack angelegt. Die Referenz “zeigt” also auf das Objekt im Heap.\nDieser fundamentale Unterschied ist relevant beim Vergleich von Werten und Referenzen. Später wirst du lernen, dass der Vergleichs-Operator == stets die Werte auf dem Stack miteinander vergleicht. Bei Referenzen wird dort also überprüft, ob sie auf dasselbe Objekt zeigen. Wenn der Inhalt von Objekten verglichen werden soll, so muss dies mit der Methode equals() gemacht werden.\n","categories":"","description":"Modul #J1\n","excerpt":"Modul #J1\n","ref":"/de/docs/02_java/03_java-grundlagen/03_data_types/","tags":"","title":"Datentypen"},{"body":"","categories":"","description":"Tools zur Erstellung und Pflege technischer Inhalte.\n","excerpt":"Tools zur Erstellung und Pflege technischer Inhalte.\n","ref":"/docs/99_tools/documentation/","tags":"","title":"Dokumentation"},{"body":"Git kann auf unterschiedliche Arten eingesetzt werden, es gibt graphische Oberflächen und die meisten Git-Server Software bieten Weboberflächen, welche das interagieren mit Git Repositories kinderleicht gestalten. Da diese Oberflächen meist sehr Produktspezifisch sind und oft auch nicht alle Funktionen beinhaltet werden hier nur die Kommandozeilen Befehle angeschaut. Ausserdem empfiehlt es sich mit git auf der Kommandozeile zu starten da es so viel verständlicher ist.\nInhalt Konfiguration von Git Hilfe Ein Git Repository anlegen Änderungen verfolgen und im Repository speichern Anzeigen der Commit Historie Änderungen rückgängig machen Mit Remotes arbeiten Ziele Ich weiss wie ich ein eigenes Git-Repository anlege. Ich verstehe wie und warum eine .gitignore Datei genutzt wird. Ich kann git commit, push, fetch und pull in den richtigen Situationen anwenden. Konfiguration von Git Git kann, wie viele Softwares unter Linux, auf unterschiedlichen Levels konfiguriert werden:\n/etc/gitconfig enthält die Werte, welche für alle Benutzer auf dem System gelten. Die Datei kann mit git config --system gelesen oder editiert werden. Man braucht Administrator- oder Superuser-Rechte um die Datei zu editieren. ~/.gitconfig oder ~/.config/git/config enthält die Werte, welche für den aktuellen Benutzer konfiguriert sind. Mit git config --global können Werte gesetzt oder ausgelesen werden. Die Datei config im .git Verzeichnis innerhalb eines Repositories enthält die Konfiguration, welche nur für dieses Repository zählt. Das Flag für git config ist in diesem Fall --local, ist jedoch in der Regel die Standardoption und kann weggelassen werden. Jede dieser Konfiguration wird von der nächsten überschrieben, sodass die Repository-bezogene Konfiguration den höchsten Wert hat. Um die aktuelle Konfiguration und ihren Ursprung anzusehen kann folgender Befehl ausgeführt werden:\n1 2 3 4 5 6 7 8 9 10 11 12 13 $ git config --list --show-origin file:/home/lehrling/.gitconfig user.email=lehrling@puzzle.ch file:/home/lehrling/.gitconfig user.name=Lehrling Puzzle file:/home/lehrling/.gitconfig push.default=simple file:/home/lehrling/.gitconfig merge.tool=meld file:.git/config core.repositoryformatversion=0 file:.git/config core.filemode=true file:.git/config core.bare=false file:.git/config core.logallrefupdates=true file:.git/config remote.origin.url=git@github.com:puzzle-bbt/training-sbb-puzzle.git file:.git/config remote.origin.fetch=+refs/heads/*:refs/remotes/origin/* file:.git/config branch.master.remote=origin file:.git/config branch.master.merge=refs/heads/master Konfigurationsbeispiele Nach der Installation von Git sollte als erstes der Name und die Email Adresse konfiguriert werden, da diese beiden Angaben bei jedem Commit benötigt werden:\n1 2 $ git config --global user.name \"John Doe\" $ git config --global user.email johndoe@example.com Wie wir bereits gelernt haben, schreiben wir mit dem --global Flag in die Konfiguration in unserem home Verzeichnis und sie gilt somit für alle Repositories, welche wir mit unserem User bearbeiten. Wollen wir dies für ein bestimmtes Repo übersteuern, haben wir immer noch die Möglichkeit dies mit --local zu machen.\nEine weitere Konfiguration, die evtl. hilfreich sein kann, ist core.editor. Mit dieser kann der Texteditor konfiguriert werden kann. Git benutzt, falls hier nichts definiert ist, den standard Editor des Systems.\nHilfe Git bietet mehrere Möglichkeiten, wie man an Hilfe gelangt, wenn mal einmal nicht weiter weiss:\n1 2 3 4 5 $ git help \u003cverb\u003e $ git \u003cverb\u003e --help $ man git-\u003cverb\u003e # Kurzversion: $ git \u003cverb\u003e -h Wenn man also nicht mehr genau weiss, wie dies mit der Konfiguration von Git funktioniert kann man sich folgendermassen weiterhelfen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 $ git help config #ruft die Manpage auf [..] $ git config -h usage: git config [\u003coptions\u003e] Config file location --global use global config file --system use system config file --local use repository config file --worktree use per-worktree config file -f, --file \u003cfile\u003e use given config file --blob \u003cblob-id\u003e read config from given blob object Action --get get value: name [value-regex] --get-all get all values: key [value-regex] --get-regexp get values for regexp: name-regex [value-regex] --get-urlmatch get value specific for the URL: section[.var] URL --replace-all replace all matching variables: name value [value_regex] --add add a new variable: name value --unset remove a variable: name [value-regex] --unset-all remove all matches: name [value-regex] --rename-section rename section: old-name new-name --remove-section remove a section: name -l, --list list all -e, --edit open an editor --get-color find the color configured: slot [default] --get-colorbool find the color setting: slot [stdout-is-tty] Type -t, --type \u003c\u003e value is given this type --bool value is \"true\" or \"false\" --int value is decimal number --bool-or-int value is --bool or --int --path value is a path (file or directory name) --expiry-date value is an expiry date Other -z, --null terminate values with NUL byte --name-only show variable names only --includes respect include directives on lookup --show-origin show origin of config (file, standard input, blob, command line) --show-scope show scope of config (worktree, local, global, system, command) --default \u003cvalue\u003e with --get, use default value when missing entry Ein Git Repository anlegen Um lokal ein neues Git Repository anzulegen gibt es zwei Varianten:\nUmwandeln eines Verzeichnis, welches (noch) nicht mit Git verwaltet wird zu einem Git Repository. Klonen eines existierenden Repositories von einem anderen Ort. Ein Verzeichnis zu einem Git Repository verwandeln Um aus einem Ordner ein Git Repository zu erstellen, muss man zuerst in den Ordner wechseln und anschliessend das Repository initialisieren:\n1 2 $ cd ~/path/to/folder $ git init Der zweite Befehl erzeugt ein .git Unterverzeichnis, welches die Repository-Daten beinhaltet. Im Moment werden noch keine Dateien von Git verwaltet, sondern die müssen zuerst hinzugefügt werden (git add) und committed werden (git commit). Wenn wir von einem leeren Ordner ausgehen, müssen die Dateien natürlich zuerst noch erstellt werden:\n1 2 3 $ vim README.md $ git add README.md $ git commit -m 'Initial Commit' Ein bestehendes Repository klonen Um ein Repository zu klonen wird der Befehl git clone verwendet:\n1 2 3 $ git clone git@github.com:libgit2/libgit2.git $ ls libgit2 Git legt dann automatisch ein Verzeichnis libgit2 an mit allen Dateien und initialisiert das Repository mit einem .git Verzeichnis im Hauptverzeichnis. Wird hinter der URL noch etwas angegeben, wird dies als Name des Zielverzeichnisses interpretiert:\n1 2 3 $ git clone https://github.com/libgit2/libgit2 mylibgit $ ls mylibgit Änderungen verfolgen und im Repository speichern Zur Erinnerung, eine Datei in einem Git Folder kann vier Zustände haben:\nUntracked: Die Datei liegt im Ordner, wird aber nicht von Git versioniert. Unmodified: Die Datei wird von Git versioniert, sie ist seit dem letzten Commit unverändert. Modified: Die Datei wurde seit dem letzten Commit verändert. Staged: eine neue oder editierte Datei wurde für den nächsten Commit vorgemerkt. Der Befehl zum Überprüfen, ob man Dateien in einem anderen Zustand als unmodified hat, ist git status:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 $ git status On branch feature/git-basics Your branch is up to date with 'origin/feature/git-basics'. Changes to be committed: (use \"git restore --staged \u003cfile\u003e...\" to unstage) modified: content/en/docs/02.0/02.md Changes not staged for commit: (use \"git add \u003cfile\u003e...\" to update what will be committed) (use \"git restore \u003cfile\u003e...\" to discard changes in working directory) modified: content/en/docs/02.0/02.md Untracked files: (use \"git add \u003cfile\u003e...\" to include in what will be committed) .gitignore Wollen wir nun die Änderungen der Datei content/en/docs/02.0/02.md (oder die Datei .gitignore) zum nächsten Commit hinzufügen, können wir dies mit git add \u003cpfad/zur/datei\u003e. Im Beispiel oben sehen wir, dass die Datei content/en/docs/02.0/02.md bereits gestaged ist. Ändern wir diese Datei erneut, wird die Datei sowohl bei Changes to be committed: wie auch bei Changes not staged for commit: auftauchen. Einmal mit den Änderungen, welche wir bereits gestaged haben und einmal mit den Änderungen, welche wir nach dem Stagen (git add) gemacht haben. Wollen wir beide Änderungen im gleichen Commit, können wir die Datei einfach wieder mit git add stagen und anschliessend commiten, wollen wir die Änderungen in separaten Commit, commiten wir zuerst die gestagten Änderungen und stagen anschliessend die zweite Änderungen und commiten erneut.\n.gitignore Bevor wir lernen, wie man seine Änderungen committed, wollen wir noch kurz die spezielle Datei .gitignore anschauen. In dieser Datei können Dateien erfasst werden, welche Git nicht als untracked aufzählen soll, respektive ignorieren soll. Die Datei wird ganz normal wie jede andere auch ins Repo eingecheckt.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 $ cat .gitignore # ignore all .a files *.a # but do track lib.a, even though you're ignoring .a files above !lib.a # only ignore the TODO file in the current directory, not subdir/TODO /TODO # ignore all files in any directory named build build/ # ignore doc/notes.txt, but not doc/server/arch.txt doc/*.txt # ignore all .pdf files in the doc/ directory and any of its subdirectories doc/**/*.pdf Weitere Informationen bekommt man mit man gitignore oder unter https://github.com/github/gitignore findet man nützliche Beispiele.\nÜberprüfen der Änderungen Bevor man seine Änderungen commited, empfiehlt es sich diese nochmals zu überprüfen. Mit git status sieht man, welche Dateien geändert wurden, jedoch nicht, was sich geändert hat. Dafür gibt es den Befehl git diff:\n1 2 3 4 5 6 7 8 9 10 diff --git a/content/en/docs/02.0/02.md b/content/en/docs/02.0/02.md index 1e6db46..dd7161b 100644 --- a/content/en/docs/02.0/02.md +++ b/content/en/docs/02.0/02.md @@ -145,3 +145,60 @@ mylibgit ## Änderungen verfolgen und im Repository speichern +Zur Erinnerung, eine Datei in einem Git Folder kann vier Zustände haben: -Zur Erinnerung, eine Datei in einem Git Folder kann vier Zustaende haben git diff vergleicht die Änderungen, welche noch nicht gestaged wurden, will man bereits gestagte Änderungen überprüfen braucht es zusätzlich das Flag --staged oder --cached (die beiden Flags sind Synonyme).\nAnders als git diff funktioniert git diff-tool mit einem externen Tool, welches dir die Änderungen anzeigt. Beispiele dafür sind ‘P4Merge’ oder auch ‘Beyond Compare’. Sie versuchen die Bearbeitungen besser zu visualisieren und es dem Benutzer einfacher zu machen, diese in einer Datei / im Code einzusehen. Jetzt bleibt die Frage: Wann brauchen wir was? Grundsätzlich wird git diff bei folgenden Situationen gebraucht:\nWenn wir kein GUI haben und nur mit dem Output des Terminals arbeiten Falls wir gar kein externes Tool zur Verfügung haben Wenn du keine ‘schweren’ externen Tools starten möchtest, sondern so schnell wie möglich zum Ergebnis kommen willst. git diff-tool kann man dann überall dort einsetzen, bei denen die oben erwähnten Situationen nicht zutreffen. Zu Beachten ist aber, dass es noch viele weitere Situationen gibt, in welchen man auf git diff-tool verzichten kann. Zur genaueren Einsicht ist Google immer eine gute Anlaufstelle.\nCommitten Ist man sicher, dass man nur die Änderungen gestaged hat, welche man auch committen will, kann man dies mit dem Befehl git commit bewerkstelligen. Dadurch wird ein Editor geöffnet und man wird gebeten eine Beschreibung für die Änderungen anzugeben. Wie solche Beschreibungen gestaltet werden sollen und was alles in eine “Commit Message” gehört, darüber gibt es ganz unterschiedliche Meinungen. Idealerweise probiert man sich vorzustellen, was man an zusätzlichen Informationen braucht, wenn man die Änderungen in zwei Jahren wieder anschaut, um zu verstehen, was und warum das geändert wurde.\nOft gibt es pro Projekt Konventionen, wie eine Commit-Message aussehen soll. Falls dies nicht existiert gibt es ein paar wenige Punkte welche die Messages einiges lesbarer und verständlicher machen:\nSprache: Englisch Kurze und prägnante Message, idealerweise unter 50 Zeichen Details Mit Grossbuchstaben beginnen Details Kein Punkt am Schluss Details Den imperative mood (Befehlsform) verwenden, also «Fix bug with X» statt «Fixed bug with X» oder «More fixes for broken stuff» Details Wenn vorhanden das Ticket referenzieren: Bei Gitlab/Github Issues: «Add X #12345» Weitere Quellen dazu:\nhttps://chris.beams.io/posts/git-commit/ https://www.conventionalcommits.org/en/v1.0.0/ Ein paar hilfreiche Flags zu git commit:\n-m um eine Message gleich anzugeben und nicht den Editor zu öffnen (kann je nach Commit Message Guideline hinderlich sein, da es keine Multiline Kommentare erlaubt): 1 2 3 4 git commit -m \"Story 182: added important Information to Readme\" [master 463dc4f] Story 182: added important Information to Readme 2 files changed, 2 insertions(+) create mode 100644 README -a um alle editierten Dateien gleich mitzustagen. (Kurzform von git add --all \u0026\u0026 git commit) !ACHTUNG! kann gefährlich sein da so schnell Änderungen in einen Commit rutschen die nicht rein gehören!\n-v um ein git diff --staged im Editor angezeigt zu bekommen. So muss man sich nicht merken, was man eigentlich geändert hat und bekommt es beim schreiben der Commit Message noch einmal präsentiert.\nWICHTIG: Es ist einiges einfacher, Fehler vor dem Committen als nach dem Committen zu beheben. Ein zweites Mal über die Änderungen schauen ist sehr empfehlenswert!\nDateien löschen Um eine Datei zu löschen, muss diese zuerst entfernt und dann gestaged werden, damit dies in der Git Datenbank ankommt. Um nicht zuerst rm foo und dann git add foo eingeben zu müssen, gibt es den Befehl git rm foo. Will man eine bereits gestagte Datei aus der Versionsverwaltung jedoch nicht vom Filesystem löschen, weil man diese zum Beispiel im .gitignore ergänzen möchte, dann kann man dies mit git rm --cached foo erledigen.\nWICHTIG: Jede Datei, die irgendwann mal committed wurde, ist für immer in der Git-Geschichte und kann nur durch neu schreiben der selbigen wieder entfernt werden. Wer also zum Beispiel sein Passwort committed, weil dies in einer secret.yml Datei steht, der sollte sich sofort bei einem 10x-Git-Profi-Engineer Hilfe holen.\nDateien Verschieben Genauso wie das Löschen, muss auch beim Verschieben die Änderung Git mitgeteilt werden: mv README.md README \u0026\u0026 git rm README.md \u0026\u0026 git add README oder in kurz und hübsch: git mv README.md README.\nAnzeigen der Commit Historie Um die Geschichte eines Git Repositories anzuzeigen, gibt es den Befehl git log. Ohne Argumente zeigt git log die Commits in umgekehrter chronologischer Reihenfolge, sprich jüngster Commit zuoberst. Pro Commit wird jeweils der Commit-Hash, der Name und die Email-Adresse des Autors, das Datum und die Commit-Message angezeigt. Um die effektiven Änderungen anzuzeigen, gibt es das -p oder --patch Flag verwendet werden. Da der Output schnell gross wird und man wahrscheinlich auch nicht bis an den Ursprung der Geschichte zurück will, empfiehlt es sich die Anzahl Commits anzugeben. Will man zum Beispiel die letzten drei Commits anschauen, macht man dies mit -3. Oder man schränkt die Änderungen basierend auf der Zeit ein mit --since= und --until= ein (es werden die unterschiedlichsten Zeitangaben akzeptiert, am besten probiert man etwas aus. Bsp: --since=2.weeks oder --until=\"2020-06-03\"). Auch mit --grep oder --author kann man die Resultate einschränken. Weitere Information liefert die Manpage man git log und die Hilfefunktion git log -h.\nÄnderungen rückgängig machen Wo gehobelt wird fallen Späne. Die meisten Schnitzer kann man jedoch selber wieder ausglätten. Am häufigsten committed man wohl zu schnell, hat eine Datei vergessen dazuzufügen oder hat sich bei der Commit Message vertan. Hier kann man ganz einfach die Änderungen noch vornehmen und an den letzten Commit berichtigen mit git commit --amend (Wichtig, man editiert nicht den letzten Commit, sondern man löscht ihn und erstellt eine korrigierte neue Version davon. Dies kann dazuführen, dass ein Remote den Commit nicht mehr annimmt, da die History nicht mehr übereinstimmt. Aber mehr dazu später.)\nUm eine gestagte Datei wieder zu modified (aber eben nicht gestaged) zu verschieben kann man git reset HEAD \u003cfile\u003e verwenden. Um die Änderungen einer Datei rückgängig zu machen (also modified zu unmodified) kann sie neu ausgecheckt werden mit git checkout -- \u003cfile\u003e. Achtung: Alle Änderungen seit dem letzte Commit gehen damit verloren!!! Wenn man sich an die beiden Befehle gerade mal nicht erinnern kann, dann kann man einfach ein git status eingeben und den Hilfetext studieren 😉.\nMit Remotes arbeiten Um mit anderen an einem Git-Projekt mitarbeiten zu können, braucht es Remotes, sprich eine Version des Projekts im Netzwerk, wo alle Beteiligten ihre Änderungen hin pushen und die Änderungen der anderen pullen können.\nNachdem man ein Repo gecloned hat, sieht man ein Remote, der verbunden ist. Man kann jedoch auch weitere definieren:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 $ git clone https://code.sbb.ch/scm/~u245517/ausbildungsprogramm.git Cloning into 'ausbildungsprogramm'... remote: Enumerating objects: 8485, done. remote: Counting objects: 100% (8485/8485), done. remote: Compressing objects: 100% (5276/5276), done. remote: Total 8485 (delta 3095), reused 8456 (delta 3079), pack-reused 0 Receiving objects: 100% (8485/8485), 17.06 MiB | 5.11 MiB/s, done. Resolving deltas: 100% (3095/3095), done. $ cd ausbildungsprogramm $ git remote origin $ git remote -v origin https://code.sbb.ch/scm/~u245517/ausbildungsprogramm.git (fetch) origin https://code.sbb.ch/scm/~u245517/ausbildungsprogramm.git (push) Fetching und Pulling Es gibt zwei Arten, wie man Daten von einem Remote abholen kann, nachdem man das Repo gecloned hat.\ngit fetch \u003cremote\u003e: holt alle Änderungen vom Remote seit dem letzten abholen und speichert die lokal. Wichtig zu beachten ist, dass git fetch die Änderungen nicht mit den lokalen Änderungen zusammenfügt, sondern dies manuell ausgeführt werden muss.\ngit pull: Wenn der lokale Branch mit einem remote Branch verknüpft ist, holt git pull die Änderungen dieses Remotes und fügt sie gleich mit den Änderungen im lokalen Branch zusammen (merge). Was Branches sind und wie ein Merge funktioniert, schauen wir uns in Kürze an. Nur soviel: Wird ein Repo gecloned, wird der lokale sogenannte master (oder auch main genannt) Branch mit dem master Branch des origin Remotes verknüpft.\nFalls korrekt gecloned wurde, muss bei `git fetch der remote nicht angegeben werden. Das Gleiche gilt für die Angabe des Branches bei einem Pull, sie kann weggelassen werden.\nPushen Wenn man seine Änderungen soweit hat, dass man sie mit dem Rest vom Team teilen will, dann kann man diese mit git push \u003cremote\u003e \u003cbranch\u003e auf den Server laden. Dies funktioniert jedoch nur, wenn man auf dem Server auch Schreibrechte hat und niemand anderes vor einem gepusht hat (Merge-Konflikte!).\nAuch hier muss, falls korrekt gecloned wurde, der remote nicht angegeben werden.\n","categories":"","description":"","excerpt":"Git kann auf unterschiedliche Arten eingesetzt werden, es gibt …","ref":"/docs/04_git/01_grundwissen/03_git-basics/","tags":"","title":"Git Basics"},{"body":"Git kann auf unterschiedliche Arten eingesetzt werden, es gibt graphische Oberflächen und die meisten Git-Server Software bieten Weboberflächen, welche das interagieren mit Git Repositories kinderleicht gestalten. Da diese Oberflächen meist sehr Produktspezifisch sind und oft auch nicht alle Funktionen beinhaltet werden hier nur die Kommandozeilen Befehle angeschaut. Ausserdem empfiehlt es sich mit git auf der Kommandozeile zu starten da es so viel verständlicher ist.\nInhalt Konfiguration von Git Hilfe Ein Git Repository anlegen Änderungen verfolgen und im Repository speichern Anzeigen der Commit Historie Änderungen rückgängig machen Mit Remotes arbeiten Ziele Ich weiss wie ich ein eigenes Git-Repository anlege. Ich verstehe wie und warum eine .gitignore Datei genutzt wird. Ich kann git commit, push, fetch und pull in den richtigen Situationen anwenden. Konfiguration von Git Git kann, wie viele Softwares unter Linux, auf unterschiedlichen Levels konfiguriert werden:\n/etc/gitconfig enthält die Werte, welche für alle Benutzer auf dem System gelten. Die Datei kann mit git config --system gelesen oder editiert werden. Man braucht Administrator- oder Superuser-Rechte um die Datei zu editieren. ~/.gitconfig oder ~/.config/git/config enthält die Werte, welche für den aktuellen Benutzer konfiguriert sind. Mit git config --global können Werte gesetzt oder ausgelesen werden. Die Datei config im .git Verzeichnis innerhalb eines Repositories enthält die Konfiguration, welche nur für dieses Repository zählt. Das Flag für git config ist in diesem Fall --local, ist jedoch in der Regel die Standardoption und kann weggelassen werden. Jede dieser Konfiguration wird von der nächsten überschrieben, sodass die Repository-bezogene Konfiguration den höchsten Wert hat. Um die aktuelle Konfiguration und ihren Ursprung anzusehen kann folgender Befehl ausgeführt werden:\n1 2 3 4 5 6 7 8 9 10 11 12 13 $ git config --list --show-origin file:/home/lehrling/.gitconfig user.email=lehrling@puzzle.ch file:/home/lehrling/.gitconfig user.name=Lehrling Puzzle file:/home/lehrling/.gitconfig push.default=simple file:/home/lehrling/.gitconfig merge.tool=meld file:.git/config core.repositoryformatversion=0 file:.git/config core.filemode=true file:.git/config core.bare=false file:.git/config core.logallrefupdates=true file:.git/config remote.origin.url=git@github.com:puzzle-bbt/training-sbb-puzzle.git file:.git/config remote.origin.fetch=+refs/heads/*:refs/remotes/origin/* file:.git/config branch.master.remote=origin file:.git/config branch.master.merge=refs/heads/master Konfigurationsbeispiele Nach der Installation von Git sollte als erstes der Name und die Email Adresse konfiguriert werden, da diese beiden Angaben bei jedem Commit benötigt werden:\n1 2 $ git config --global user.name \"John Doe\" $ git config --global user.email johndoe@example.com Wie wir bereits gelernt haben, schreiben wir mit dem --global Flag in die Konfiguration in unserem home Verzeichnis und sie gilt somit für alle Repositories, welche wir mit unserem User bearbeiten. Wollen wir dies für ein bestimmtes Repo übersteuern, haben wir immer noch die Möglichkeit dies mit --local zu machen.\nEine weitere Konfiguration, die evtl. hilfreich sein kann, ist core.editor. Mit dieser kann der Texteditor konfiguriert werden kann. Git benutzt, falls hier nichts definiert ist, den standard Editor des Systems.\nHilfe Git bietet mehrere Möglichkeiten, wie man an Hilfe gelangt, wenn mal einmal nicht weiter weiss:\n1 2 3 4 5 $ git help \u003cverb\u003e $ git \u003cverb\u003e --help $ man git-\u003cverb\u003e # Kurzversion: $ git \u003cverb\u003e -h Wenn man also nicht mehr genau weiss, wie dies mit der Konfiguration von Git funktioniert kann man sich folgendermassen weiterhelfen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 $ git help config #ruft die Manpage auf [..] $ git config -h usage: git config [\u003coptions\u003e] Config file location --global use global config file --system use system config file --local use repository config file --worktree use per-worktree config file -f, --file \u003cfile\u003e use given config file --blob \u003cblob-id\u003e read config from given blob object Action --get get value: name [value-regex] --get-all get all values: key [value-regex] --get-regexp get values for regexp: name-regex [value-regex] --get-urlmatch get value specific for the URL: section[.var] URL --replace-all replace all matching variables: name value [value_regex] --add add a new variable: name value --unset remove a variable: name [value-regex] --unset-all remove all matches: name [value-regex] --rename-section rename section: old-name new-name --remove-section remove a section: name -l, --list list all -e, --edit open an editor --get-color find the color configured: slot [default] --get-colorbool find the color setting: slot [stdout-is-tty] Type -t, --type \u003c\u003e value is given this type --bool value is \"true\" or \"false\" --int value is decimal number --bool-or-int value is --bool or --int --path value is a path (file or directory name) --expiry-date value is an expiry date Other -z, --null terminate values with NUL byte --name-only show variable names only --includes respect include directives on lookup --show-origin show origin of config (file, standard input, blob, command line) --show-scope show scope of config (worktree, local, global, system, command) --default \u003cvalue\u003e with --get, use default value when missing entry Ein Git Repository anlegen Um lokal ein neues Git Repository anzulegen gibt es zwei Varianten:\nUmwandeln eines Verzeichnis, welches (noch) nicht mit Git verwaltet wird zu einem Git Repository. Klonen eines existierenden Repositories von einem anderen Ort. Ein Verzeichnis zu einem Git Repository verwandeln Um aus einem Ordner ein Git Repository zu erstellen, muss man zuerst in den Ordner wechseln und anschliessend das Repository initialisieren:\n1 2 $ cd ~/path/to/folder $ git init Der zweite Befehl erzeugt ein .git Unterverzeichnis, welches die Repository-Daten beinhaltet. Im Moment werden noch keine Dateien von Git verwaltet, sondern die müssen zuerst hinzugefügt werden (git add) und committed werden (git commit). Wenn wir von einem leeren Ordner ausgehen, müssen die Dateien natürlich zuerst noch erstellt werden:\n1 2 3 $ vim README.md $ git add README.md $ git commit -m 'Initial Commit' Ein bestehendes Repository klonen Um ein Repository zu klonen wird der Befehl git clone verwendet:\n1 2 3 $ git clone git@github.com:libgit2/libgit2.git $ ls libgit2 Git legt dann automatisch ein Verzeichnis libgit2 an mit allen Dateien und initialisiert das Repository mit einem .git Verzeichnis im Hauptverzeichnis. Wird hinter der URL noch etwas angegeben, wird dies als Name des Zielverzeichnisses interpretiert:\n1 2 3 $ git clone https://github.com/libgit2/libgit2 mylibgit $ ls mylibgit Änderungen verfolgen und im Repository speichern Zur Erinnerung, eine Datei in einem Git Folder kann vier Zustände haben:\nUntracked: Die Datei liegt im Ordner, wird aber nicht von Git versioniert. Unmodified: Die Datei wird von Git versioniert, sie ist seit dem letzten Commit unverändert. Modified: Die Datei wurde seit dem letzten Commit verändert. Staged: eine neue oder editierte Datei wurde für den nächsten Commit vorgemerkt. Der Befehl zum Überprüfen, ob man Dateien in einem anderen Zustand als unmodified hat, ist git status:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 $ git status On branch feature/git-basics Your branch is up to date with 'origin/feature/git-basics'. Changes to be committed: (use \"git restore --staged \u003cfile\u003e...\" to unstage) modified: content/en/docs/02.0/02.md Changes not staged for commit: (use \"git add \u003cfile\u003e...\" to update what will be committed) (use \"git restore \u003cfile\u003e...\" to discard changes in working directory) modified: content/en/docs/02.0/02.md Untracked files: (use \"git add \u003cfile\u003e...\" to include in what will be committed) .gitignore Wollen wir nun die Änderungen der Datei content/en/docs/02.0/02.md (oder die Datei .gitignore) zum nächsten Commit hinzufügen, können wir dies mit git add \u003cpfad/zur/datei\u003e. Im Beispiel oben sehen wir, dass die Datei content/en/docs/02.0/02.md bereits gestaged ist. Ändern wir diese Datei erneut, wird die Datei sowohl bei Changes to be committed: wie auch bei Changes not staged for commit: auftauchen. Einmal mit den Änderungen, welche wir bereits gestaged haben und einmal mit den Änderungen, welche wir nach dem Stagen (git add) gemacht haben. Wollen wir beide Änderungen im gleichen Commit, können wir die Datei einfach wieder mit git add stagen und anschliessend commiten, wollen wir die Änderungen in separaten Commit, commiten wir zuerst die gestagten Änderungen und stagen anschliessend die zweite Änderungen und commiten erneut.\n.gitignore Bevor wir lernen, wie man seine Änderungen committed, wollen wir noch kurz die spezielle Datei .gitignore anschauen. In dieser Datei können Dateien erfasst werden, welche Git nicht als untracked aufzählen soll, respektive ignorieren soll. Die Datei wird ganz normal wie jede andere auch ins Repo eingecheckt.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 $ cat .gitignore # ignore all .a files *.a # but do track lib.a, even though you're ignoring .a files above !lib.a # only ignore the TODO file in the current directory, not subdir/TODO /TODO # ignore all files in any directory named build build/ # ignore doc/notes.txt, but not doc/server/arch.txt doc/*.txt # ignore all .pdf files in the doc/ directory and any of its subdirectories doc/**/*.pdf Weitere Informationen bekommt man mit man gitignore oder unter https://github.com/github/gitignore findet man nützliche Beispiele.\nÜberprüfen der Änderungen Bevor man seine Änderungen commited, empfiehlt es sich diese nochmals zu überprüfen. Mit git status sieht man, welche Dateien geändert wurden, jedoch nicht, was sich geändert hat. Dafür gibt es den Befehl git diff:\n1 2 3 4 5 6 7 8 9 10 diff --git a/content/en/docs/02.0/02.md b/content/en/docs/02.0/02.md index 1e6db46..dd7161b 100644 --- a/content/en/docs/02.0/02.md +++ b/content/en/docs/02.0/02.md @@ -145,3 +145,60 @@ mylibgit ## Änderungen verfolgen und im Repository speichern +Zur Erinnerung, eine Datei in einem Git Folder kann vier Zustände haben: -Zur Erinnerung, eine Datei in einem Git Folder kann vier Zustaende haben git diff vergleicht die Änderungen, welche noch nicht gestaged wurden, will man bereits gestagte Änderungen überprüfen braucht es zusätzlich das Flag --staged oder --cached (die beiden Flags sind Synonyme).\nAnders als git diff funktioniert git diff-tool mit einem externen Tool, welches dir die Änderungen anzeigt. Beispiele dafür sind ‘P4Merge’ oder auch ‘Beyond Compare’. Sie versuchen die Bearbeitungen besser zu visualisieren und es dem Benutzer einfacher zu machen, diese in einer Datei / im Code einzusehen. Jetzt bleibt die Frage: Wann brauchen wir was? Grundsätzlich wird git diff bei folgenden Situationen gebraucht:\nWenn wir kein GUI haben und nur mit dem Output des Terminals arbeiten Falls wir gar kein externes Tool zur Verfügung haben Wenn du keine ‘schweren’ externen Tools starten möchtest, sondern so schnell wie möglich zum Ergebnis kommen willst. git diff-tool kann man dann überall dort einsetzen, bei denen die oben erwähnten Situationen nicht zutreffen. Zu Beachten ist aber, dass es noch viele weitere Situationen gibt, in welchen man auf git diff-tool verzichten kann. Zur genaueren Einsicht ist Google immer eine gute Anlaufstelle.\nCommitten Ist man sicher, dass man nur die Änderungen gestaged hat, welche man auch committen will, kann man dies mit dem Befehl git commit bewerkstelligen. Dadurch wird ein Editor geöffnet und man wird gebeten eine Beschreibung für die Änderungen anzugeben. Wie solche Beschreibungen gestaltet werden sollen und was alles in eine “Commit Message” gehört, darüber gibt es ganz unterschiedliche Meinungen. Idealerweise probiert man sich vorzustellen, was man an zusätzlichen Informationen braucht, wenn man die Änderungen in zwei Jahren wieder anschaut, um zu verstehen, was und warum das geändert wurde.\nOft gibt es pro Projekt Konventionen, wie eine Commit-Message aussehen soll. Falls dies nicht existiert gibt es ein paar wenige Punkte welche die Messages einiges lesbarer und verständlicher machen:\nSprache: Englisch Kurze und prägnante Message, idealerweise unter 50 Zeichen Details Mit Grossbuchstaben beginnen Details Kein Punkt am Schluss Details Den imperative mood (Befehlsform) verwenden, also «Fix bug with X» statt «Fixed bug with X» oder «More fixes for broken stuff» Details Wenn vorhanden das Ticket referenzieren: Bei Gitlab/Github Issues: «Add X #12345» Weitere Quellen dazu:\nhttps://chris.beams.io/posts/git-commit/ https://www.conventionalcommits.org/en/v1.0.0/ Ein paar hilfreiche Flags zu git commit:\n-m um eine Message gleich anzugeben und nicht den Editor zu öffnen (kann je nach Commit Message Guideline hinderlich sein, da es keine Multiline Kommentare erlaubt): 1 2 3 4 git commit -m \"Story 182: added important Information to Readme\" [master 463dc4f] Story 182: added important Information to Readme 2 files changed, 2 insertions(+) create mode 100644 README -a um alle editierten Dateien gleich mitzustagen. (Kurzform von git add --all \u0026\u0026 git commit) !ACHTUNG! kann gefährlich sein da so schnell Änderungen in einen Commit rutschen die nicht rein gehören!\n-v um ein git diff --staged im Editor angezeigt zu bekommen. So muss man sich nicht merken, was man eigentlich geändert hat und bekommt es beim schreiben der Commit Message noch einmal präsentiert.\nWICHTIG: Es ist einiges einfacher, Fehler vor dem Committen als nach dem Committen zu beheben. Ein zweites Mal über die Änderungen schauen ist sehr empfehlenswert!\nDateien löschen Um eine Datei zu löschen, muss diese zuerst entfernt und dann gestaged werden, damit dies in der Git Datenbank ankommt. Um nicht zuerst rm foo und dann git add foo eingeben zu müssen, gibt es den Befehl git rm foo. Will man eine bereits gestagte Datei aus der Versionsverwaltung jedoch nicht vom Filesystem löschen, weil man diese zum Beispiel im .gitignore ergänzen möchte, dann kann man dies mit git rm --cached foo erledigen.\nWICHTIG: Jede Datei, die irgendwann mal committed wurde, ist für immer in der Git-Geschichte und kann nur durch neu schreiben der selbigen wieder entfernt werden. Wer also zum Beispiel sein Passwort committed, weil dies in einer secret.yml Datei steht, der sollte sich sofort bei einem 10x-Git-Profi-Engineer Hilfe holen.\nDateien Verschieben Genauso wie das Löschen, muss auch beim Verschieben die Änderung Git mitgeteilt werden: mv README.md README \u0026\u0026 git rm README.md \u0026\u0026 git add README oder in kurz und hübsch: git mv README.md README.\nAnzeigen der Commit Historie Um die Geschichte eines Git Repositories anzuzeigen, gibt es den Befehl git log. Ohne Argumente zeigt git log die Commits in umgekehrter chronologischer Reihenfolge, sprich jüngster Commit zuoberst. Pro Commit wird jeweils der Commit-Hash, der Name und die Email-Adresse des Autors, das Datum und die Commit-Message angezeigt. Um die effektiven Änderungen anzuzeigen, gibt es das -p oder --patch Flag verwendet werden. Da der Output schnell gross wird und man wahrscheinlich auch nicht bis an den Ursprung der Geschichte zurück will, empfiehlt es sich die Anzahl Commits anzugeben. Will man zum Beispiel die letzten drei Commits anschauen, macht man dies mit -3. Oder man schränkt die Änderungen basierend auf der Zeit ein mit --since= und --until= ein (es werden die unterschiedlichsten Zeitangaben akzeptiert, am besten probiert man etwas aus. Bsp: --since=2.weeks oder --until=\"2020-06-03\"). Auch mit --grep oder --author kann man die Resultate einschränken. Weitere Information liefert die Manpage man git log und die Hilfefunktion git log -h.\nÄnderungen rückgängig machen Wo gehobelt wird fallen Späne. Die meisten Schnitzer kann man jedoch selber wieder ausglätten. Am häufigsten committed man wohl zu schnell, hat eine Datei vergessen dazuzufügen oder hat sich bei der Commit Message vertan. Hier kann man ganz einfach die Änderungen noch vornehmen und an den letzten Commit berichtigen mit git commit --amend (Wichtig, man editiert nicht den letzten Commit, sondern man löscht ihn und erstellt eine korrigierte neue Version davon. Dies kann dazuführen, dass ein Remote den Commit nicht mehr annimmt, da die History nicht mehr übereinstimmt. Aber mehr dazu später.)\nUm eine gestagte Datei wieder zu modified (aber eben nicht gestaged) zu verschieben kann man git reset HEAD \u003cfile\u003e verwenden. Um die Änderungen einer Datei rückgängig zu machen (also modified zu unmodified) kann sie neu ausgecheckt werden mit git checkout -- \u003cfile\u003e. Achtung: Alle Änderungen seit dem letzte Commit gehen damit verloren!!! Wenn man sich an die beiden Befehle gerade mal nicht erinnern kann, dann kann man einfach ein git status eingeben und den Hilfetext studieren 😉.\nMit Remotes arbeiten Um mit anderen an einem Git-Projekt mitarbeiten zu können, braucht es Remotes, sprich eine Version des Projekts im Netzwerk, wo alle Beteiligten ihre Änderungen hin pushen und die Änderungen der anderen pullen können.\nNachdem man ein Repo gecloned hat, sieht man ein Remote, der verbunden ist. Man kann jedoch auch weitere definieren:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 $ git clone https://code.sbb.ch/scm/~u245517/ausbildungsprogramm.git Cloning into 'ausbildungsprogramm'... remote: Enumerating objects: 8485, done. remote: Counting objects: 100% (8485/8485), done. remote: Compressing objects: 100% (5276/5276), done. remote: Total 8485 (delta 3095), reused 8456 (delta 3079), pack-reused 0 Receiving objects: 100% (8485/8485), 17.06 MiB | 5.11 MiB/s, done. Resolving deltas: 100% (3095/3095), done. $ cd ausbildungsprogramm $ git remote origin $ git remote -v origin https://code.sbb.ch/scm/~u245517/ausbildungsprogramm.git (fetch) origin https://code.sbb.ch/scm/~u245517/ausbildungsprogramm.git (push) Fetching und Pulling Es gibt zwei Arten, wie man Daten von einem Remote abholen kann, nachdem man das Repo gecloned hat.\ngit fetch \u003cremote\u003e: holt alle Änderungen vom Remote seit dem letzten abholen und speichert die lokal. Wichtig zu beachten ist, dass git fetch die Änderungen nicht mit den lokalen Änderungen zusammenfügt, sondern dies manuell ausgeführt werden muss.\ngit pull: Wenn der lokale Branch mit einem remote Branch verknüpft ist, holt git pull die Änderungen dieses Remotes und fügt sie gleich mit den Änderungen im lokalen Branch zusammen (merge). Was Branches sind und wie ein Merge funktioniert, schauen wir uns in Kürze an. Nur soviel: Wird ein Repo gecloned, wird der lokale sogenannte master (oder auch main genannt) Branch mit dem master Branch des origin Remotes verknüpft.\nFalls korrekt gecloned wurde, muss bei `git fetch der remote nicht angegeben werden. Das Gleiche gilt für die Angabe des Branches bei einem Pull, sie kann weggelassen werden.\nPushen Wenn man seine Änderungen soweit hat, dass man sie mit dem Rest vom Team teilen will, dann kann man diese mit git push \u003cremote\u003e \u003cbranch\u003e auf den Server laden. Dies funktioniert jedoch nur, wenn man auf dem Server auch Schreibrechte hat und niemand anderes vor einem gepusht hat (Merge-Konflikte!).\nAuch hier muss, falls korrekt gecloned wurde, der remote nicht angegeben werden.\n","categories":"","description":"","excerpt":"Git kann auf unterschiedliche Arten eingesetzt werden, es gibt …","ref":"/de/docs/04_git/01_grundwissen/03_git-basics/","tags":"","title":"Git Basics"},{"body":"java.util.Set Eine Set verwendet man, um eine Menge von Elemente zu speichern. Dabei werden keine Duplikate gespeichert. Die java.util.HashSet ist die gebräuchlichste Implementierung eines Sets. Man könnte zum Beispiel in einem Set alle Wörter eines Texts speichern. Tritt ein Wort mehrmals auf, so wird dieses Wort nur bei ersten Male gespeichert. Im Set sind so alle auftretenden Wörter gespeichert und die size() Methode liefert die Anzahl unterschiedlicher Wörter zurück.\nEin Set hat keine Duplikate! Dabei ist der Schlüssel immer eindeutig. Speichert man zwei Zuweisungen mit dem gleichen Schlüssel, so wird die erste Zuweisung überschrieben.\nDie Benennung eines Sets sollte der Inhalt beschreiben.\nZum Beispiel:\nnameSet –\u003e ein Set mit Namen names –\u003e mehrere Namen Methodenübersicht 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Set\u003cString\u003e nameSet = new HashSet\u003c\u003e(); nameSet.add(\"Peter\"); nameSet.add(\"Anna\"); nameSet.add(\"Kurt\"); nameSet.add(\"Anna\"); nameSet.add(\"Petra\"); System.out.println(nameSet.size()); // Output: 4 System.out.println(nameSet.contains(\"Peter\")); // Output: true System.out.println(nameSet.remove(\"Emil\")); // Output: false System.out.println(nameSet.remove(\"Anna\")); // Output: true System.out.println(nameSet.size()); // Output: 3 nameSet.clear(); System.out.println(nameSet.isEmpty()); // Output: true Die Elemente eines Set kann man mit den Collection Methoden abrufen:\niterator(): Ein Iterator über die Elemente stream(): Ein sequentieller Stream über die Elemente forEach(): Führt eine bestimmte Aktion über alle Elemente aus Die Reihenfolge der Elemente ist nicht garantiert. Es existieren Implementierung wie das SortedSet, welche eine bestimmte Reihenfolge sicherstellt.\nBeispiel Beispiel Für die Beispiele verwenden wir die folgende initialisierte HashMap:\n1 2 3 4 5 6 Set\u003cString\u003e nameSet = new HashSet\u003c\u003e(); nameSet.add(\"Peter\"); nameSet.add(\"Anna\"); nameSet.add(\"Kurt\"); nameSet.add(\"Anna\"); nameSet.add(\"Petra\"); Beispiel 1 - Set erstellen 1 2 3 4 5 6 7 8 // mit Konstruktor Set\u003cString\u003e nameSet = new HashSet\u003c\u003e(); nameSet.add(\"Peter\"); nameSet.add(\"Emil\"); // mit statischer of() Methode Set\u003cString\u003e nameSet = Set.of(\"Peter\", \"Emil\"); // of() liefert ein unmodifizierbares Set zurück. Kein HashSet! Beispiel 2 - Auslesen der Elemente 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // Abfrage der Elemente mit einem Iterator: Iterator\u003cString\u003e iterator = nameSet.iterator(); while(iterator.hasNext()) { System.out.println(iterator.next()); } // Abfrage der Elemente mit einer for Schleife: for (String name : nameSet){ System.out.println(name); } // Abfrage der Elemente mit einem Stream: nameSet.stream().forEach(name -\u003e System.out.println(name)); // Abfrage der Elemente mit einem forEach: nameSet.forEach(name -\u003e System.out.println(name)); Aufgaben Aufgaben Aufgaben zu Modul #J6 - Java Collections - Set\n","categories":"","description":"Die gebräuchlichste Umsetzung eines Set: HashSet.\n","excerpt":"Die gebräuchlichste Umsetzung eines Set: HashSet.\n","ref":"/docs/02_java/10_java-collections/03_set/","tags":"","title":"HashSet"},{"body":"java.util.Set Eine Set verwendet man, um eine Menge von Elemente zu speichern. Dabei werden keine Duplikate gespeichert. Die java.util.HashSet ist die gebräuchlichste Implementierung eines Sets. Man könnte zum Beispiel in einem Set alle Wörter eines Texts speichern. Tritt ein Wort mehrmals auf, so wird dieses Wort nur bei ersten Male gespeichert. Im Set sind so alle auftretenden Wörter gespeichert und die size() Methode liefert die Anzahl unterschiedlicher Wörter zurück.\nEin Set hat keine Duplikate! Dabei ist der Schlüssel immer eindeutig. Speichert man zwei Zuweisungen mit dem gleichen Schlüssel, so wird die erste Zuweisung überschrieben.\nDie Benennung eines Sets sollte der Inhalt beschreiben.\nZum Beispiel:\nnameSet –\u003e ein Set mit Namen names –\u003e mehrere Namen Methodenübersicht 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Set\u003cString\u003e nameSet = new HashSet\u003c\u003e(); nameSet.add(\"Peter\"); nameSet.add(\"Anna\"); nameSet.add(\"Kurt\"); nameSet.add(\"Anna\"); nameSet.add(\"Petra\"); System.out.println(nameSet.size()); // Output: 4 System.out.println(nameSet.contains(\"Peter\")); // Output: true System.out.println(nameSet.remove(\"Emil\")); // Output: false System.out.println(nameSet.remove(\"Anna\")); // Output: true System.out.println(nameSet.size()); // Output: 3 nameSet.clear(); System.out.println(nameSet.isEmpty()); // Output: true Die Elemente eines Set kann man mit den Collection Methoden abrufen:\niterator(): Ein Iterator über die Elemente stream(): Ein sequentieller Stream über die Elemente forEach(): Führt eine bestimmte Aktion über alle Elemente aus Die Reihenfolge der Elemente ist nicht garantiert. Es existieren Implementierung wie das SortedSet, welche eine bestimmte Reihenfolge sicherstellt.\nBeispiel Beispiel Für die Beispiele verwenden wir die folgende initialisierte HashMap:\n1 2 3 4 5 6 Set\u003cString\u003e nameSet = new HashSet\u003c\u003e(); nameSet.add(\"Peter\"); nameSet.add(\"Anna\"); nameSet.add(\"Kurt\"); nameSet.add(\"Anna\"); nameSet.add(\"Petra\"); Beispiel 1 - Set erstellen 1 2 3 4 5 6 7 8 // mit Konstruktor Set\u003cString\u003e nameSet = new HashSet\u003c\u003e(); nameSet.add(\"Peter\"); nameSet.add(\"Emil\"); // mit statischer of() Methode Set\u003cString\u003e nameSet = Set.of(\"Peter\", \"Emil\"); // of() liefert ein unmodifizierbares Set zurück. Kein HashSet! Beispiel 2 - Auslesen der Elemente 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // Abfrage der Elemente mit einem Iterator: Iterator\u003cString\u003e iterator = nameSet.iterator(); while(iterator.hasNext()) { System.out.println(iterator.next()); } // Abfrage der Elemente mit einer for Schleife: for (String name : nameSet){ System.out.println(name); } // Abfrage der Elemente mit einem Stream: nameSet.stream().forEach(name -\u003e System.out.println(name)); // Abfrage der Elemente mit einem forEach: nameSet.forEach(name -\u003e System.out.println(name)); Aufgaben Aufgaben Aufgaben zu Modul #J6 - Java Collections - Set\n","categories":"","description":"Die gebräuchlichste Umsetzung eines Set: HashSet.\n","excerpt":"Die gebräuchlichste Umsetzung eines Set: HashSet.\n","ref":"/de/docs/02_java/10_java-collections/03_set/","tags":"","title":"HashSet"},{"body":"Ziele Ich kann Text und Zahlen auf der Konsole ausgeben. Ich kann Text und Zahlen auf der Konsole eingeben und diese wieder ausgeben. Ich kann statische Methoden schreiben, die einfache Rechnungen durchführen. Ich kann statische Methoden mit Parametern und Return-Statements schreiben. Ich verstehe und kenne die verschiedenen Conditional Statements. Ich weiss, wann und wie ich welches Conditional Statement einsetzen sollte. Ich verstehe, was Loops sind und kenne die verschiedenen Loops. Ich weiss, wann und wie ich welchen Loop brauchen soll. Ich kann mithilfe von String-Methoden Strings bearbeiten. Ich kann Arrays initialisieren, auf deren Werte zugreifen und Werte in einem Array verändern. Ich kann mein Programm zur Laufzeit mit einem Debugger untersuchen. Aufgabe 1 - Ausgaben auf die Kommandozeile Gib die folgenden Daten in der Kommandozeile aus:\nHello World Hello + \u003cDein Name\u003e Zeichne folgende Objekte mit Charakteren in der Kommandozeile:\nZeichne ein Haus, nutze dazu beliebige Zeichen Zeichne eine Schweizerfahne Falls unklar ist, was hier gemeint ist, schau dir ASCII-Art an. Hier ist eine Katze als Beispiel:\n1 2 3 /\\_/\\ ( o.o ) \u003e ^ \u003c Hier kannst du zurück zur Theorie.\nAufgabe 2 - Conditional Statements Aufgabe 2a - Die if- und else-Bedingungen Löse die folgenden Aufgaben:\nSchreibe ein Programm, das feststellen kann, ob eine Zahl grösser, kleiner oder gleich 0 ist. Schreibe ein Programm, welches dein Name in einer Variable speichert und dann eine Begrüssung ausgibt (z.B. “Hallo, IT-Ninja”). Schreibe ein Programm, das feststellt, ob ein Jahr in einer Variable ein Schaltjahr ist. Recherchiere, was die Bedingungen sind. Schreibe ein Programm, das überprüft, ob eine Zahl in einer Variable gerade oder ungerade ist. Hier kannst du zurück zur Theorie.\nAufgabe 2b - Das switch-Statement Löse die folgenden Aufgaben:\nSchreibe ein Programm, das eine Zahl zwischen 1 und 12 in einer Variable hat und dann den entsprechenden Monat ausgibt (für den Wert 2 wird dann der String \"Februar\" zurückgegeben). Schreibe ein Programm, das einen Wochentag in einer Variable hat und dann ausgibt, der wievielte Tag in der Woche er ist: Der \u003cWochentag\u003e ist der \u003cX\u003e. Tag in der Woche. Schreibe die Methode so, dass maximal 1 println() (oder ähnliches) verwendet wird. Hinweis: Hier kann dir ein switch-Assignment sehr viel Code ersparen. Debugge mindestens zwei dieser Methoden mit einem Breakpoint. Hier kannst du zurück zur Theorie.\nAufgabe 3 - Loops Löse die folgenden Aufgaben:\nSchreibe ein Programm, welches eine beliebige Ganzzahl in einer Variable hat und die Fakultät dieser Zahl berechnet. Schreibe einen Loop, welcher alle Zahlen von 1 bis 100 zusammenzählt, welche durch 8 teilbar sind. Erweitere deine Lösung mit einer Methode, welche eine Zahl als Parameter entgegennimmt und dann die Zahlen zusammenzählt, welche durch diese Zahl teilbar sind. Hier kannst du zurück zur Theorie.\nAufgabe 4 - Einfache Berechnungen Berechne die folgenden Dinge:\nFläche eines Rechtecks. Fläche eines Kreises. Umfang eines Rechtecks. Inhalt einer Pyramide mit quadratischem Grundriss und einer bestimmten Höhe. Berechne dein Alter in Monaten. Du kannst dafür von dem aktuellen Monat ausgehen. Schreibe eine Methode, welche eine beliebige Ganzzahl als Parameter übernimmt und die Vielfache von 3 zusammen mit der Vielfache von 5 dieser Zahl summiert. Hier kannst du zurück zur Theorie.\nAufgabe 5 - Methoden Löse die folgenden Aufgaben:\nSchreibe eine Methode, die zwei beliebigen Ganzzahlen als Parameter übernimmt und die Summe der beiden zurückliefert. Schreibe eine eigene Methode, die als Parameter einen Namen übernimmt. Die Methode soll dann die folgenden Daten auf die Kommandozeile ausgeben Hello + \u003cParameter-Name\u003e Hier kannst du zurück zur Theorie.\nAufgabe 6 - Strings Du hast den folgenden String:\n1 2 3 4 5 6 7 8 9 10 11 String poem = \"\"\" Ein Ninja leise wie der Wind, Seine Waffen stets geschwind. \"Shurikens\" fliegen, scharf und schnell, Klingen funkeln, furchterregend hell. \"Nunchakus\" wirbeln im Tanz, Mit jedem Schlag, im Vorteil er ganz. Seine Waffen, geheim und klug, Begleiten ihn bei jedem Zug.\"\"\"; Löse mit Hilfe dieses Strings folgende Aufgaben:\nGib in der Konsole die Anzahl Wörtern aus. Gib den Text in Grossbuchstaben aus. Gib den Text so aus, dass jedes Leerzeichen mit einem Punkt ersetzt wurde. Schneide das Wort “Shurikens” aus. Ermittle hierfür die Position des Wortes anhand des \"-Zeichens. Hinweis: Die indexOf()-Methode bietet ein optionales Argument fromIndex an. Übergibst du die Position des ersten Anführungszeichen + 1, dann wird die Position des zweiten zurückgegeben. Schreibe für jede Aufgabe eine eigene Methode, welche den String als Parameter nimmt.\nHier kannst du zurück zur Theorie.\nAufgabe 7 - Strings und Loops Löse die folgenden Aufgaben:\nSchreibe ein Programm, welches als Parameter einen beliebigen String übernimmt und dessen Zeichenfolge umkehrt. Schreibe ein Programm, welches als Parameter einen beliebigen String übernimmt und jeden zweiten Buchstaben gross schreibt (Beispiel: \"Hello World\" -\u003e \"hElLo WoRlD\"). Hier kannst du zurück zur Theorie.\nAufgabe 8 - Eingaben von der Kommandozeile Lies zuerst deinen Namen und dann dein Alter über einen Scanner von der Konsole ein und gib dann die folgenden Daten auf die Kommandozeile aus\nHello + \u003cDein Name\u003e + you are + \u003cDein Alter\u003e + years old. Next year, you will be \u003cDein Alter + 1\u003e years old. Generiere diesen Output\nmithilfe eines StringBuilders und mithilfe der String.format()-Methode. Hier kannst du zurück zur Theorie.\nAufgabe 9 - Arrays Löse die folgenden Aufgaben:\nSchreibe eine Methode, welche zwei Parameter übernimmt: einen beliebigen Zahlen-Array und eine beliebige Zahl. Die Methode gibt die Position der Zahl im Array aus. Schreibe eine Methode, welche als Parameter einen beliebigen Zahlen-Array übernimmt und die grösste Zahl im Array zurückliefert. Hier kannst du zurück zur Theorie.\n","categories":"","description":"Exercises zu Modul #J1\n","excerpt":"Exercises zu Modul #J1\n","ref":"/de/labs/02_java/03_java-grundlagen/01_basicexercises/","tags":"","title":"Java Exercises - Grundlagen"},{"body":" Dieses Kapitel gehört zum Modul #J1 des Ausbildungsplans Einführung In diesem Modul startest du mit dem Programmieren – Schritt für Schritt.\nDu wirst lernen, wie man mit Java Programme schreibt:\nAufbau eines Java Programs Ausführen eines Java Programs in IntelliJ Text auf der Konsole ausgeben Benutzereingaben verarbeiten Mathematische Operationen ausführen Bedingungen und Wiederholungen umsetzen Du arbeitest mit einer modernen Entwicklungsumgebung (IntelliJ) und lernst früh, wie ein Projekt strukturiert ist.\nRichte möglichst früh deine Entwicklungsumgebung ein – du wirst sie für die Übungen benötigen.\nAnleitung: !*IntelliJ IDEA einrichten\nAchtung: Installiere nur IntelliJ IDEA. Die anderen Module kannst du vorerst ignorieren.\nDieses Modul ist dein Einstieg ins “echte” Programmieren – ganz ohne Vorkenntnisse. Los geht’s Im nächsten Kapitel startest du mit deinem ersten Programm und lernst, wie man Variablen verwendet.\n","categories":"","description":"In diesem Modul lernst du die Grundlagen der Programmierung mit Java: Ausgaben, Variablen, Rechenoperationen, Bedingungen und Schleifen.\n","excerpt":"In diesem Modul lernst du die Grundlagen der Programmierung mit Java: …","ref":"/docs/02_java/03_java-grundlagen/","tags":"","title":"Java Grundlagen"},{"body":"Hiermit beginnt deine Reise mit Java!\nIn dem Modul #J1 mit dem Namen “Java Grundlagen” lernst du die Basics der Programmierung mit Java.\nNach diesem Modul kannst du Java-Programme schreiben, die\nText ausgeben User nach einer Eingabe fragen und diese auswerten mathematische Operationen durchführen und bestimmte Dinge nur unter bestimmten Bedingungen ausführen. Es wird spannend; also bleib unbedingt dran, hier im Ausbildungsprogramm!\nTerminologie Nachfolgend sind ein paar Begriffe aufgelistet, die du in diesem Kapitel immer wieder antreffen wirst. Diese Tabelle dient dazu, dass du die Begriffe später einfacher nachschlagen kannst. Du musst diese Begriffe jetzt noch nicht vollständig verstehen.\nBegriff Beschreibung Programm Eine Folge von Anweisungen (engl. “statement”), welche nacheinander ausgeführt werden (von oben nach unten) Anweisung (statement) Eine einzelne Aktion, wie zum Beispiel das Ausgeben eines Satzes auf der Konsole. Ein Statement wird mit einem Semikolon abgeschlossen Block Eine Gruppe von keiner, einer oder mehreren Anweisungen, die von geschweiften Klammern {…} umgeben ist Methode Eine Methode ist eine benannte Sequenz von Anweisungen, die eine bestimmte Aufgabe ausführt. Methoden gehören zu Klassen und können Parameter entgegennehmen und einen Wert zurückgeben. Sie werden aufgerufen, um eine bestimmte Funktionalität auszuführen und ermöglichen die Wiederverwendung von Code. Syntax Eine Reihe von Regeln, die definieren wie ein Programm geschrieben werden muss, um gültig zu sein. Es handelt sich um eine Art Grammatik Keyword Ein Wort, welches in der Programmiersprache eine besondere Bedeutung hat (public, class und viele andere). Diese Wörter können nicht als Variablennamen verwendet werden Bezeichner (identifier) oder Name Ein Wort, das sich auf etwas in einem Programm bezieht (z. B. eine Variable oder einen Methodennamen) Kommentar Eine Erklärung dazu, was eine bestimmte Anweisung oder Methode macht. Einzeilige Java-Kommentare beginnen mit // und mehrzeilige sind von den Zeichen /* */ umgeben Whitespace Tabulator- oder Leerzeichen dienen lediglich der Lesbarkeit, vom Compiler werden sie ignoriert ","categories":"","description":"Modul #J1\n","excerpt":"Modul #J1\n","ref":"/de/docs/02_java/03_java-grundlagen/","tags":"","title":"Java Grundlagen"},{"body":"","categories":"","description":"Exams zu Modul #J1\n","excerpt":"Exams zu Modul #J1\n","ref":"/exams/02_java/03_java-grundlagen/","tags":"","title":"Java Grundlagen Exams"},{"body":"","categories":"","description":"Exams zu Modul #J1\n","excerpt":"Exams zu Modul #J1\n","ref":"/de/exams/02_java/03_java-grundlagen/","tags":"","title":"Java Grundlagen Exams"},{"body":"Ziele Du kannst deinen Java-Code in IntelliJ ausführen Du verstehst, wie du Breakpoints setzt und deinen Code debuggen kannst Du lernst die wichtigsten Shortcuts und Funktionen für das Entwickeln mit IntelliJ kennen Um erste Erfahrungen mit IntelliJ zu machen, kannst Du das Hello World Beispiel von it-ninjas verwenden. Java-Programm ausführen Sobald dein Java-Programm eine main-Methode enthält, kannst du es direkt starten:\nÖffne die Datei mit der main-Methode. Klicke links neben die Zeilennummer (dort erscheint ein grünes Dreieck). Wähle Run ‘Dateiname.main()’ aus. Alternativ kannst du über das Menü oben auf den Play-Button klicken oder Shift + F10 drücken.\nDu kannst mehrere Run-Konfigurationen definieren – zum Beispiel für verschiedene Klassen oder Tests. Projekt kompilieren IntelliJ kompiliert deinen Code automatisch im Hintergrund, sobald du speicherst.\nManuelles Kompilieren geht so:\nÜber das Menü: Build → Build Project Tastenkürzel: Ctrl + F9 Wenn du Fehler machst, werden sie sofort hervorgehoben – das spart dir viel Zeit.\nDebugging in IntelliJ Fehler finden geht einfacher, wenn du den Debugger verwendest.\nBreakpoint setzen Klicke links neben eine Zeilennummer → roter Punkt erscheint. Starte das Programm im Debug-Modus: Shift + F9 oder Rechtsklick auf das grüne Dreieck → Debug ‘…’. Debugger-Ansicht Sobald der Code anhält:\nDu siehst aktuelle Variablen und deren Werte Du kannst mit den Buttons Step Over, Step Into oder Resume den Code durchgehen Im Debug-Fenster kannst du sogar Variablen ändern oder Ausdrücke live auswerten – perfekt zum Testen von Vermutungen! Häufige Shortcuts Aktion Shortcut Programm ausführen Shift + F10 Debug starten Shift + F9 Projekt kompilieren Ctrl + F9 Nächste Zeile (Debug) F8 In Methode springen (Debug) F7 Fazit IntelliJ unterstützt dich bei jedem Schritt – vom ersten Ausführen bis zum systematischen Debugging.\nMit ein paar Handgriffen kannst du effizient Fehler finden und verstehen, wie dein Programm wirklich funktioniert.\nNutze den Debugger regelmässig – das verbessert nicht nur deinen Code, sondern auch dein Verständnis für Programmabläufe. ","categories":"","description":"Wie kann ich meinen erstellten Java-Code kompilieren, ausführen und debuggen.\n","excerpt":"Wie kann ich meinen erstellten Java-Code kompilieren, ausführen und …","ref":"/docs/99_tools/ide/intellij/03_run-and-debug/","tags":"","title":"Mit IntelliJ Java Code kompilieren, ausführen und debuggen"},{"body":"Aufgabe 1 Postleitzahlen einlesen und verarbeiten:\nSchreibe ein Programm, welches Postleitzahlen aus einer CSV-Datei herausliest und in einer HashMap speichert. Nach dem Speichern schreibt das Programm verschiedene Informationen zu den Daten in die Konsole (siehe Ausgabe). Verwendet wieder die kleine Hilfsklasse OutputValidation zum Verifizieren von eurem Konsole-Output. Ein eigenes Testing (wie in J4 Testing gelernt) soll umgesetzt werden. Input PLZ (UTF8 Format) PLZ (ISO-8859-1 Format) Ausgabe Die Ausgabe muss das folgende Format aufweisen:\n1 2 3 4 5 6 7 8 9 10 11 - Anzahl PLZ: [anzahl] - Kleinste PLZ der Gemeinde Bern: [PLZ] [Ort] - Grösste PLZ der Gemeinde Bern: [PLZ] [Ort] - Anzahl Gemeinden mit mehr als 10 Buchstaben: [anzahl] - Anzahl Gemeinden mit 7 Buchstaben: [anzahl] - Anzahl Gemeinden mit der Buchstabenfolge 'ent': [anzahl] - Gemeinden mit 3 Buchstaben: [Ort], [Ort], [Ort] - Anzahl Buchstaben der kleinsten Gemeinden: [anzahl] - Kleinsten Gemeinden: [Ort], [Ort], [Ort] - Anzahl Buchstaben der grössten Gemeinden: [anzahl] - Grössten Gemeinden: [Ort], [Ort], [Ort] Beachte, dass die Aufzählungen der Ortschaften sortiert sind. Die Ausgabe könnte Beispielsweise so aussehen:\n1 2 3 4 5 6 7 8 9 10 11 - Anzahl PLZ: 3197 - Kleinste PLZ der Gemeinde Bern: 3000 Bern - Grösste PLZ der Gemeinde Bern: 3032 Bern - Anzahl Gemeinden mit mehr als 10 Buchstaben: 1986 - Anzahl Gemeinden mit 7 Buchstaben: 232 - Anzahl Gemeinden mit der Buchstabenfolge 'ent': 45 - Gemeinden mit 3 Buchstaben: Auw, Ins, Vex, Vex, Zug, Zug - Anzahl Buchstaben der kleinsten Gemeinden: 3 - Kleinsten Gemeinden: Ins - Anzahl Buchstaben der grössten Gemeinden: 89 - Grössten Gemeinden: Deisswil bei Münchenbuchsee, Rapperswil (BE), Wiggiswil Ausgabe überprüfen\nDer Konsole-Output Hash für diese Aufgabe ist: 494931922\nAufgabe 2 (Optional) Wir programmieren eine eigene Map-Klasse MyMap, welche noch keinen Hash-Code verwendet:\nEs dürfen keine Klassen aus dem Collection-Framework verwendet werden. Die Klasse muss das Interface MyMapInterface implementieren. Die Klasse weiss nicht, wie viele Elemente man speichert. Sie muss die Grösse internen Datenstruktur dynamische anpassen. Die toString() der java.lang.Object Klasse soll von der MyMap so überschrieben werden, dass die Elemente kommasepariert ausgegeben werden. Ein eigenes Testing (wie in J4 Testing gelernt) soll umgesetzt werden. Inferface MyMapInterface 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 package com.examples.list; public interface MyMapInterface\u003cK, V\u003e { /** * Associates the specified value with the specified key in this map. * @param key key with which the specified value is to be associated * @param value value to be associated with the specified key * @return the previous value associated with {@code key}, or * {@code null} if there was no mapping for {@code key}. */ V put(K key, V value); /** * Returns the value to which the specified key is mapped, * or {@code null} if this map contains no mapping for the key. * @param key the key whose associated value is to be returned * @return the value to which the specified key is mapped, or * {@code null} if this map contains no mapping for the key */ V get(Object key); /** * Returns the number of key-value mappings in this map. * @return the number of key-value mappings in this map */ int size(); /** * Removes all the mappings from this map. * The map will be empty after this call returns. */ void clear(); /** * Removes the mapping for a key from this map if it is present. * @param key key whose mapping is to be removed from the map * @return the previous value associated with {@code key}, or * {@code null} if there was no mapping for {@code key}. */ V remove(Object key); /** * Returns {@code true} if this map contains a mapping for the specified * key. * @param key key whose presence in this map is to be tested * @return {@code true} if this map contains a mapping for the specified * key */ boolean containsKey(Object key); /** * Returns {@code true} if this map maps one or more keys to the * specified value. * @param value value whose presence in this map is to be tested * @return {@code true} if this map maps one or more keys to the * specified value */ boolean containsValue(Object value); } Aufgabe 3 (Optional) Wir Kopieren unsere MyMap Klasse zu der Klasse MyHashMap und erweitern diese, damit sie Hash Funktionalität verwendet:\nBeim Hinzufügen von Zuweisungen wird der Hash-Code vom Schlüssel berechnet und ebenfalls abgespeichert. Die Schlüsselsuche wird anschliessend über die gespeicherten Hash-Code der Schlüssel durchgeführt statt über die Schlüssel selbst. Ein eigenes Testing (wie in J4 Testing gelernt) soll umgesetzt werden. ","categories":"","description":"Aufgaben zu [Java Collections - Map](../../../docs/02_java/10_java-collections/04_map)\n","excerpt":"Aufgaben zu [Java Collections - …","ref":"/labs/02_java/10_java-collections/03_map/","tags":"","title":"Map - Aufgaben"},{"body":"Aufgabe 1 Postleitzahlen einlesen und verarbeiten:\nSchreibe ein Programm, welches Postleitzahlen aus einer CSV-Datei herausliest und in einer HashMap speichert. Nach dem Speichern schreibt das Programm verschiedene Informationen zu den Daten in die Konsole (siehe Ausgabe). Verwendet wieder die kleine Hilfsklasse OutputValidation zum Verifizieren von eurem Konsole-Output. Ein eigenes Testing (wie in J4 Testing gelernt) soll umgesetzt werden. Input PLZ (UTF8 Format) PLZ (ISO-8859-1 Format) Ausgabe Die Ausgabe muss das folgende Format aufweisen:\n1 2 3 4 5 6 7 8 9 10 11 - Anzahl PLZ: [anzahl] - Kleinste PLZ der Gemeinde Bern: [PLZ] [Ort] - Grösste PLZ der Gemeinde Bern: [PLZ] [Ort] - Anzahl Gemeinden mit mehr als 10 Buchstaben: [anzahl] - Anzahl Gemeinden mit 7 Buchstaben: [anzahl] - Anzahl Gemeinden mit der Buchstabenfolge 'ent': [anzahl] - Gemeinden mit 3 Buchstaben: [Ort], [Ort], [Ort] - Anzahl Buchstaben der kleinsten Gemeinden: [anzahl] - Kleinsten Gemeinden: [Ort], [Ort], [Ort] - Anzahl Buchstaben der grössten Gemeinden: [anzahl] - Grössten Gemeinden: [Ort], [Ort], [Ort] Beachte, dass die Aufzählungen der Ortschaften sortiert sind. Die Ausgabe könnte Beispielsweise so aussehen:\n1 2 3 4 5 6 7 8 9 10 11 - Anzahl PLZ: 3197 - Kleinste PLZ der Gemeinde Bern: 3000 Bern - Grösste PLZ der Gemeinde Bern: 3032 Bern - Anzahl Gemeinden mit mehr als 10 Buchstaben: 1986 - Anzahl Gemeinden mit 7 Buchstaben: 232 - Anzahl Gemeinden mit der Buchstabenfolge 'ent': 45 - Gemeinden mit 3 Buchstaben: Auw, Ins, Vex, Vex, Zug, Zug - Anzahl Buchstaben der kleinsten Gemeinden: 3 - Kleinsten Gemeinden: Ins - Anzahl Buchstaben der grössten Gemeinden: 89 - Grössten Gemeinden: Deisswil bei Münchenbuchsee, Rapperswil (BE), Wiggiswil Ausgabe überprüfen\nDer Konsole-Output Hash für diese Aufgabe ist: 494931922\nAufgabe 2 (Optional) Wir programmieren eine eigene Map-Klasse MyMap, welche noch keinen Hash-Code verwendet:\nEs dürfen keine Klassen aus dem Collection-Framework verwendet werden. Die Klasse muss das Interface MyMapInterface implementieren. Die Klasse weiss nicht, wie viele Elemente man speichert. Sie muss die Grösse internen Datenstruktur dynamische anpassen. Die toString() der java.lang.Object Klasse soll von der MyMap so überschrieben werden, dass die Elemente kommasepariert ausgegeben werden. Ein eigenes Testing (wie in J4 Testing gelernt) soll umgesetzt werden. Inferface MyMapInterface 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 package com.examples.list; public interface MyMapInterface\u003cK, V\u003e { /** * Associates the specified value with the specified key in this map. * @param key key with which the specified value is to be associated * @param value value to be associated with the specified key * @return the previous value associated with {@code key}, or * {@code null} if there was no mapping for {@code key}. */ V put(K key, V value); /** * Returns the value to which the specified key is mapped, * or {@code null} if this map contains no mapping for the key. * @param key the key whose associated value is to be returned * @return the value to which the specified key is mapped, or * {@code null} if this map contains no mapping for the key */ V get(Object key); /** * Returns the number of key-value mappings in this map. * @return the number of key-value mappings in this map */ int size(); /** * Removes all the mappings from this map. * The map will be empty after this call returns. */ void clear(); /** * Removes the mapping for a key from this map if it is present. * @param key key whose mapping is to be removed from the map * @return the previous value associated with {@code key}, or * {@code null} if there was no mapping for {@code key}. */ V remove(Object key); /** * Returns {@code true} if this map contains a mapping for the specified * key. * @param key key whose presence in this map is to be tested * @return {@code true} if this map contains a mapping for the specified * key */ boolean containsKey(Object key); /** * Returns {@code true} if this map maps one or more keys to the * specified value. * @param value value whose presence in this map is to be tested * @return {@code true} if this map maps one or more keys to the * specified value */ boolean containsValue(Object value); } Aufgabe 3 (Optional) Wir Kopieren unsere MyMap Klasse zu der Klasse MyHashMap und erweitern diese, damit sie Hash Funktionalität verwendet:\nBeim Hinzufügen von Zuweisungen wird der Hash-Code vom Schlüssel berechnet und ebenfalls abgespeichert. Die Schlüsselsuche wird anschliessend über die gespeicherten Hash-Code der Schlüssel durchgeführt statt über die Schlüssel selbst. Ein eigenes Testing (wie in J4 Testing gelernt) soll umgesetzt werden. ","categories":"","description":"Aufgaben zu [Java Collections - Map](../../../docs/02_java/10_java-collections/04_map)\n","excerpt":"Aufgaben zu [Java Collections - …","ref":"/de/labs/02_java/10_java-collections/03_map/","tags":"","title":"Map - Aufgaben"},{"body":"Ziele Ich weiss, was Markdown ist und welche Vorteile es hat Ich weiss, wie man mit Markdown eine einfache Dokumentation erstellt Ich weiss, wie man verschiedene Titel erstellt Ich weiss, wie man Paragraphen und Zeilenumbrüche erstellt Ich weiss, wie man fett und kursiv schreibt oder die beiden kombiniert Ich weiss, wie man Texte hervorheben kann Ich weiss, wie man Listen erstellt Ich weiss, wie man Code-Blöcke mit entsprechender Syntax erstellt Ich weiss, wie man Bilder und Links einfügen kann Ich weiss, wie man Tabellen erstellt Einführung Lies den Markdown-Guide zur Einführung Markdown - Getting started durch. Das IntelliJ enthält per Default die Möglichkeit Markdown-Dateien zu bearbeiten und ihr finales Aussehen anzuzeigen. Um eine Markdown-Datei anzusehen gibt es auch die Möglichkeit den Online Markdown Editor Dillinger zu verwenden.\nAndere Markdown-Editoren sind:\nGhostwriter Markdown Monster Für Linux und Mac stehen jeweils andere Editoren zur Verfügung.\nBasic Syntax Lies die Dokumentation zur Basic Syntax durch. Dort erfährst du, wie man die wichtigsten Elemente im Markdown anlegen kann, um eine Dokumentation zu erstellen.\nExtended Syntax In der Erweiterung lernst du Tabellen und weitere nützliche Funktionen kennen. Lies das Kapitel durch und mach dich mit den Tabellen und dem Hervorheben von Code vertraut.\nHacks Wenn du noch mehr wissen willst, bringt dich das Kapitel Hacks noch tiefer in nicht offizielle Funktionen von Markdown hinein.\nCheat Sheet Das Cheat-Sheet mit den wichtigsten Teilen der Markdown-Syntax findest du hier\n","categories":"","description":"Tools - Markdown\n","excerpt":"Tools - Markdown\n","ref":"/de/docs/01_tools/03_markdown/","tags":"","title":"Markdown"},{"body":"Was ist REST REST (Representational State Transfer) ist ein Architekturstil für die Kommunikation zwischen Computern in Netzwerken, insbesondere im World Wide Web. Es basiert auf einer einfachen Idee: Ressourcen, wie z.B. Daten oder Dienste, werden durch eindeutige URLs (Uniform Resource Locators) identifiziert. Um auf diese Ressourcen zuzugreifen oder sie zu manipulieren, verwendet man standardisierte HTTP-Methoden wie GET (zum Abrufen von Daten), POST (zum Erstellen neuer Daten), PUT (zum Aktualisieren von Daten) und DELETE (zum Löschen von Daten).\nEin zentrales Konzept von REST ist die Zustandslosigkeit (Statelessness). Das bedeutet, dass jede Anfrage vom Client an den Server alle Informationen enthalten muss, die der Server benötigt, um sie zu verstehen und zu verarbeiten, ohne den Zustand von vorherigen Anfragen zu speichern. Dadurch wird die Skalierbarkeit und Zuverlässigkeit der Kommunikation verbessert.\nRESTful APIs (Application Programming Interfaces) sind weit verbreitet, weil sie einfach zu verstehen und zu implementieren sind. Sie ermöglichen es verschiedenen Systemen, unabhängig von ihrer Plattform oder Technologie, miteinander zu interagieren. Ein Beispiel für eine RESTful API könnte ein Online-Dienst sein, der Wetterdaten bereitstellt: Durch eine einfache HTTP-Anfrage kann ein Client aktuelle Wetterinformationen für eine bestimmte Stadt abrufen.\nVerschiedene Request-Arten Wir schauen uns ein Beispiel eines Controllers an, welcher verschiedene Endpoints definiert.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 @RestController @RequestMapping(\"/orders\") public class OrderResource { private final OrderService orderService; public OrderResource(OrderService orderService) { this.orderService = orderService; } @GetMapping public List\u003cOrder\u003e findAll() { return orderService.findAll(); } @GetMapping(\"/{id}\") public Order findById(@PathVariable Long id) { return orderService.findById(id).orElseThrow(EntityNotFoundException::new); } @PostMapping public Order save(@RequestBody Order order) { return orderService.save(order); } @PutMapping(\"/{id}\") public Order update(@PathVariable Long id, @RequestBody Order order) { return orderService.update(id, order); } @DeleteMapping(\"/{id}\") public ResponseEntity delete(@PathVariable Long id) { orderService.delete(id); return ResponseEntity.ok().build(); } } Dies ist eine Rest-Resource und sie wird definiert mit der Annotation @RestController. Die Annotation @RequestMapping(\"/orders\") legt fest, dass alle Aufrufe, deren URL mit \"/orders\" beginnen, diesen Rest-Controller verwenden sollen.\nSchauen wir uns die verschiedenen, in diesem File definierten Endpoints doch genauer an.\nGet Get wird generell genutzt, um Daten von einem bestimmten Ort abzurufen. Beispielsweise das Abrufen von Informationen über Benutzerprofile einer Social-Media-Plattform.\n1 2 3 4 @GetMapping(\"/{id}\") public Order findById(@PathVariable Long id){ return orderService.findById(id).orElseThrow(EntityNotFoundException::new); } Mit der @GetMapping Annotation bestimmen wir, dass alle Anfragen auf dem orders/id Pfad von der annotierten Methode gehandelt werden, wenn die HTTP-Methode GET verwendet wurde. @PathVariable bestimmt, dass die ID als Path-Variable (also in der URL) angegeben wird. Das bedeutet, dass ein Aufruf auf /orders/12 das gleiche Ergebnis hat wie der Methodenaufruf findByID(12).\nPut Put wird fürs Aktualisieren von bestehenden Ressourcen verwendet, indem neue Daten an einen bestimmten Ort gesendet werden.\n1 2 3 4 @PutMapping(\"/{id}\") public Order update(@PathVariable Long id,@RequestBody Order order){ return orderService.update(id,order); } Hier wird mit der @PutMapping Annotation ein Put-Endpoint auf dem Pfad orders/id definiert. Man kann verschiedene Endpoints für denselben Pfad definieren. Wichtig ist jedoch, dass sie sich in der Request-Methoden(Get, Put, Post, Delete) unterscheiden. Die Annotation @RequestBody wird verwendet, um anzugeben, dass der Parameter order aus dem Request-Body des HTTP-Requests gelesen werden soll.\nPost Post wird verwendet, um neue Daten an den Server zu senden, beispielsweise beim Ausfüllen eines Formulars und Absenden der Informationen.\n1 2 3 4 @PostMapping public Order save(@RequestBody Order order) { return orderService.save(order); } Mit der @PostMapping Annotation bestimmen wir, dass alle (Post-)Anfragen auf dem orders/ Pfad von der annotierten Methode behandelt werden. Mithilfe der Annotation @RequestBody werden die mitgeschickten Daten (im JSON Format) in ein order-Objekt umgewandelt. Im Body der Methode wird nun das order-Objekt anhand des Services gespeichert und das Ergebnis zurückgegeben.\nDelete Delete wird genutzt, um eine spezifische Ressource auf dem Server zu entfernen. Wie beispielsweise das Löschen eines Benutzerkontos von einer Plattform.\n1 2 3 4 5 @DeleteMapping(\"/{id}\") public ResponseEntity delete(@PathVariable Long id) { orderService.delete(id); return ResponseEntity.ok().build(); } Mit der @DeleteMapping Annotation bestimmen wir, dass alle Anfragen auf dem orders/id Pfad von diesem Endpoint behandelt werden, wenn die HTTP-Methode Delete verwendet wurde. Dank der @PathVariable Annotation wird die ID des zu löschenden Objektes aus der URL genommen und als Long-Wert gespeichert. Anschliessend wird im Body mithilfe des Services die Order mit der entsprechenden ID gelöscht. Nach dem Löschen wird eine erfolgreiche Antwort (HTTP 200 OK) zurückgegeben.\nMehr Informationen zu den verschiedenen Annotationen findest du hier.\n","categories":"","description":"Modul #J8 - Spring Framework - REST-Endpoints\n","excerpt":"Modul #J8 - Spring Framework - REST-Endpoints\n","ref":"/docs/02_java/12_spring-framework/03_rest/","tags":"","title":"REST-Endpoints"},{"body":"Was ist REST REST (Representational State Transfer) ist ein Architekturstil für die Kommunikation zwischen Computern in Netzwerken, insbesondere im World Wide Web. Es basiert auf einer einfachen Idee: Ressourcen, wie z.B. Daten oder Dienste, werden durch eindeutige URLs (Uniform Resource Locators) identifiziert. Um auf diese Ressourcen zuzugreifen oder sie zu manipulieren, verwendet man standardisierte HTTP-Methoden wie GET (zum Abrufen von Daten), POST (zum Erstellen neuer Daten), PUT (zum Aktualisieren von Daten) und DELETE (zum Löschen von Daten).\nEin zentrales Konzept von REST ist die Zustandslosigkeit (Statelessness). Das bedeutet, dass jede Anfrage vom Client an den Server alle Informationen enthalten muss, die der Server benötigt, um sie zu verstehen und zu verarbeiten, ohne den Zustand von vorherigen Anfragen zu speichern. Dadurch wird die Skalierbarkeit und Zuverlässigkeit der Kommunikation verbessert.\nRESTful APIs (Application Programming Interfaces) sind weit verbreitet, weil sie einfach zu verstehen und zu implementieren sind. Sie ermöglichen es verschiedenen Systemen, unabhängig von ihrer Plattform oder Technologie, miteinander zu interagieren. Ein Beispiel für eine RESTful API könnte ein Online-Dienst sein, der Wetterdaten bereitstellt: Durch eine einfache HTTP-Anfrage kann ein Client aktuelle Wetterinformationen für eine bestimmte Stadt abrufen.\nVerschiedene Request-Arten Wir schauen uns ein Beispiel eines Controllers an, welcher verschiedene Endpoints definiert.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 @RestController @RequestMapping(\"/orders\") public class OrderResource { private final OrderService orderService; public OrderResource(OrderService orderService) { this.orderService = orderService; } @GetMapping public List\u003cOrder\u003e findAll() { return orderService.findAll(); } @GetMapping(\"/{id}\") public Order findById(@PathVariable Long id) { return orderService.findById(id).orElseThrow(EntityNotFoundException::new); } @PostMapping public Order save(@RequestBody Order order) { return orderService.save(order); } @PutMapping(\"/{id}\") public Order update(@PathVariable Long id, @RequestBody Order order) { return orderService.update(id, order); } @DeleteMapping(\"/{id}\") public ResponseEntity delete(@PathVariable Long id) { orderService.delete(id); return ResponseEntity.ok().build(); } } Dies ist eine Rest-Resource und sie wird definiert mit der Annotation @RestController. Die Annotation @RequestMapping(\"/orders\") legt fest, dass alle Aufrufe, deren URL mit \"/orders\" beginnen, diesen Rest-Controller verwenden sollen.\nSchauen wir uns die verschiedenen, in diesem File definierten Endpoints doch genauer an.\nGet Get wird generell genutzt, um Daten von einem bestimmten Ort abzurufen. Beispielsweise das Abrufen von Informationen über Benutzerprofile einer Social-Media-Plattform.\n1 2 3 4 @GetMapping(\"/{id}\") public Order findById(@PathVariable Long id){ return orderService.findById(id).orElseThrow(EntityNotFoundException::new); } Mit der @GetMapping Annotation bestimmen wir, dass alle Anfragen auf dem orders/id Pfad von der annotierten Methode gehandelt werden, wenn die HTTP-Methode GET verwendet wurde. @PathVariable bestimmt, dass die ID als Path-Variable (also in der URL) angegeben wird. Das bedeutet, dass ein Aufruf auf /orders/12 das gleiche Ergebnis hat wie der Methodenaufruf findByID(12).\nPut Put wird fürs Aktualisieren von bestehenden Ressourcen verwendet, indem neue Daten an einen bestimmten Ort gesendet werden.\n1 2 3 4 @PutMapping(\"/{id}\") public Order update(@PathVariable Long id,@RequestBody Order order){ return orderService.update(id,order); } Hier wird mit der @PutMapping Annotation ein Put-Endpoint auf dem Pfad orders/id definiert. Man kann verschiedene Endpoints für denselben Pfad definieren. Wichtig ist jedoch, dass sie sich in der Request-Methoden(Get, Put, Post, Delete) unterscheiden. Die Annotation @RequestBody wird verwendet, um anzugeben, dass der Parameter order aus dem Request-Body des HTTP-Requests gelesen werden soll.\nPost Post wird verwendet, um neue Daten an den Server zu senden, beispielsweise beim Ausfüllen eines Formulars und Absenden der Informationen.\n1 2 3 4 @PostMapping public Order save(@RequestBody Order order) { return orderService.save(order); } Mit der @PostMapping Annotation bestimmen wir, dass alle (Post-)Anfragen auf dem orders/ Pfad von der annotierten Methode behandelt werden. Mithilfe der Annotation @RequestBody werden die mitgeschickten Daten (im JSON Format) in ein order-Objekt umgewandelt. Im Body der Methode wird nun das order-Objekt anhand des Services gespeichert und das Ergebnis zurückgegeben.\nDelete Delete wird genutzt, um eine spezifische Ressource auf dem Server zu entfernen. Wie beispielsweise das Löschen eines Benutzerkontos von einer Plattform.\n1 2 3 4 5 @DeleteMapping(\"/{id}\") public ResponseEntity delete(@PathVariable Long id) { orderService.delete(id); return ResponseEntity.ok().build(); } Mit der @DeleteMapping Annotation bestimmen wir, dass alle Anfragen auf dem orders/id Pfad von diesem Endpoint behandelt werden, wenn die HTTP-Methode Delete verwendet wurde. Dank der @PathVariable Annotation wird die ID des zu löschenden Objektes aus der URL genommen und als Long-Wert gespeichert. Anschliessend wird im Body mithilfe des Services die Order mit der entsprechenden ID gelöscht. Nach dem Löschen wird eine erfolgreiche Antwort (HTTP 200 OK) zurückgegeben.\nMehr Informationen zu den verschiedenen Annotationen findest du hier.\n","categories":"","description":"Modul #J8 - Spring Framework - REST-Endpoints\n","excerpt":"Modul #J8 - Spring Framework - REST-Endpoints\n","ref":"/de/docs/02_java/12_spring-framework/03_rest/","tags":"","title":"REST-Endpoints"},{"body":"Dies ist einen Gemeinschaftsaufgabe, die gemeinsam von allen Beteiligten und nur einmal ausgeführt werden muss.\nSchritt 1: Teambildung Finde ein bis vier Ninjas, die das Modul Git abgeschlossen haben und zusammen mit dir die praktische Anwendung von Git/Bitbucket im Team erlernen wollen oder schliesse dich einem bestehenden Team an.\nSchritt 2: Rollenverteilung Legt einen Lead-Developer für euer Team fest. Der Lead-Developer verteilt die Aufgaben im Team, d.h. er/sie legt fest, wer an welchem Projekt arbeitet und welche “Verbesserung” jeweils umgesetzt wird.\nSchritt 3: Vorbereitung der Repositories Wählt die zwei Projekte aus, mit denen euer Team arbeiten soll. Nutzt dazu die folgende Liste:\nStreamingdienst\nImmobilienfirma\nNinja Cups\nWeltmeisterschaft\nRollenspiel\nFür jedes der zwei Projekte wird der vorhandene Code eines beliebigen Teammitglieds genutzt.\nFür die Aufgabe wird der Code in ein neues Repository übernommen (fork).\nDer jeweilige Originalstand wird im Branch master gehalten.\nVom master wird ein Standard-Arbeitsbranch develop erzeugt.\nDie Repositories sind für alle Teammitglieder freizugeben (schreibender Zugriff).\nHinweise Die neuen Repositories können wahlweise über die Bitbucket Weboberfläche oder via Git Kommando erstellt werden. Die Branches sollten über die Weboberfläche erstellt werden. Schritt 4: Festlegen des Repositories für die Aufgabe “Zusammenarbeit” Legt gemeinsam fest, welches Repository für die gemeinsame Arbeit an einem Projekt genutzt werden soll. Dieses wird in den nachfolgenden Aufgaben immer als erstes Repository bezeichnet.\n","categories":"","description":"Aufgabe ein temporäres Team bilden für [Git Vertiefung](../../../../docs/04_git/02_vertiefung/01_voraussetzungen)\n","excerpt":"Aufgabe ein temporäres Team bilden für [Git …","ref":"/labs/04_git/02_vertiefung/01_team/","tags":"","title":"Aufgabe: Teambildung"},{"body":"Dies ist einen Gemeinschaftsaufgabe, die gemeinsam von allen Beteiligten und nur einmal ausgeführt werden muss.\nSchritt 1: Teambildung Finde ein bis vier Ninjas, die das Modul Git abgeschlossen haben und zusammen mit dir die praktische Anwendung von Git/Bitbucket im Team erlernen wollen oder schliesse dich einem bestehenden Team an.\nSchritt 2: Rollenverteilung Legt einen Lead-Developer für euer Team fest. Der Lead-Developer verteilt die Aufgaben im Team, d.h. er/sie legt fest, wer an welchem Projekt arbeitet und welche “Verbesserung” jeweils umgesetzt wird.\nSchritt 3: Vorbereitung der Repositories Wählt die zwei Projekte aus, mit denen euer Team arbeiten soll. Nutzt dazu die folgende Liste:\nStreamingdienst\nImmobilienfirma\nNinja Cups\nWeltmeisterschaft\nRollenspiel\nFür jedes der zwei Projekte wird der vorhandene Code eines beliebigen Teammitglieds genutzt.\nFür die Aufgabe wird der Code in ein neues Repository übernommen (fork).\nDer jeweilige Originalstand wird im Branch master gehalten.\nVom master wird ein Standard-Arbeitsbranch develop erzeugt.\nDie Repositories sind für alle Teammitglieder freizugeben (schreibender Zugriff).\nHinweise Die neuen Repositories können wahlweise über die Bitbucket Weboberfläche oder via Git Kommando erstellt werden. Die Branches sollten über die Weboberfläche erstellt werden. Schritt 4: Festlegen des Repositories für die Aufgabe “Zusammenarbeit” Legt gemeinsam fest, welches Repository für die gemeinsame Arbeit an einem Projekt genutzt werden soll. Dieses wird in den nachfolgenden Aufgaben immer als erstes Repository bezeichnet.\n","categories":"","description":"Aufgabe ein temporäres Team bilden für [Git Vertiefung](../../../../docs/04_git/02_vertiefung/01_voraussetzungen)\n","excerpt":"Aufgabe ein temporäres Team bilden für [Git …","ref":"/de/labs/04_git/02_vertiefung/01_team/","tags":"","title":"Aufgabe: Teambildung"},{"body":"Diese Aufgabe ist von jedem Teilnehmer auf seinem Rechner auszuführen.\nSchritt 1: Klonen des ersten Repository Starte deinen Browser. Rufe die Bitbucketseite mit dem ersten Repository auf. Wähle “Klonen” in der Navigationsleiste (links) aus und kopiere die URL. Starte IntelliJ. Wähle im Menu Git -\u003e Clone… aus. Füge die kopierte URL in der ersten Zeile ein. Wähle dein Arbeitsverzeichnis für das neue Repository aus. Klicke auf “Clone”. Schritt 2: Klonen des zweiten Repository Wiederhole die Punkte 2, 3 und 5 - 8 aus Schritt 4 für das zweite Repository. Schritt 3: Branch für die Aufgabe “Zusammenarbeit” erstellen Starte deinen Browser. Rufe die Bitbucketseite mit dem ersten Repository auf. Klicke auf Branch erstellen. Wähle den Branch-Typ “Feature” aus. Wähle unter Branch von “develop” aus. Trage als Branch-Name “Modul-S3-‹dein Vorname›-collaboration” ein (ohne Anführungszeichen). Klicke auf Branch erstellen. ","categories":"","description":"Aufgabe lokale Umgebung vorbereiten für [Git Vertiefung](../../../../docs/04_git/02_vertiefung/01_voraussetzungen)\n","excerpt":"Aufgabe lokale Umgebung vorbereiten für [Git …","ref":"/labs/04_git/02_vertiefung/02_preparing/","tags":"","title":"Aufgabe: Vorbereiten der IDE"},{"body":"Diese Aufgabe ist von jedem Teilnehmer auf seinem Rechner auszuführen.\nSchritt 1: Klonen des ersten Repository Starte deinen Browser. Rufe die Bitbucketseite mit dem ersten Repository auf. Wähle “Klonen” in der Navigationsleiste (links) aus und kopiere die URL. Starte IntelliJ. Wähle im Menu Git -\u003e Clone… aus. Füge die kopierte URL in der ersten Zeile ein. Wähle dein Arbeitsverzeichnis für das neue Repository aus. Klicke auf “Clone”. Schritt 2: Klonen des zweiten Repository Wiederhole die Punkte 2, 3 und 5 - 8 aus Schritt 4 für das zweite Repository. Schritt 3: Branch für die Aufgabe “Zusammenarbeit” erstellen Starte deinen Browser. Rufe die Bitbucketseite mit dem ersten Repository auf. Klicke auf Branch erstellen. Wähle den Branch-Typ “Feature” aus. Wähle unter Branch von “develop” aus. Trage als Branch-Name “Modul-S3-‹dein Vorname›-collaboration” ein (ohne Anführungszeichen). Klicke auf Branch erstellen. ","categories":"","description":"Aufgabe lokale Umgebung vorbereiten für [Git Vertiefung](../../../../docs/04_git/02_vertiefung/01_voraussetzungen)\n","excerpt":"Aufgabe lokale Umgebung vorbereiten für [Git …","ref":"/de/labs/04_git/02_vertiefung/02_preparing/","tags":"","title":"Aufgabe: Vorbereiten der IDE"},{"body":"Modelliere einen Klassenaufbau für einen Zoo. Folgende Klassen sollen enthalten sein:\nPersonen Gehege Tiere Jede dieser Klassen soll mehrere Spezialisierungen enthalten.\nBei den Personen unterscheidet man zwischen Mitarbeitern und Mitgliedern. Ein Mitarbeiter hat beispielsweise einen Lohn, den ein Mitglied nicht hat. Die folgenden Attribute sollen vorhanden sein:\nLohn Beschreibung des Jobs Telefonnummer Mitglied seit Nummer der Mitglied-Karte Verteile die Attribute also korrekt auf die Generalisierung und die Spezialisierungen.\nBei den Gehegen wird unterschieden zwischen Gelände, Terrarium, Aquarium und Käfig. Die einzigartigen Eigenschaften der verschiedenen Gehege sollen wie folgt modelliert werden:\nGehege-Nummer Grösse in Quadratmeter Temperatur Feuchtigkeit Süss- / Salzwasser Fassungsvermögen Zaunhöhe Wassergraben vorhanden Verteile die Attribute also korrekt auf die Generalisierung und die Spezialisierung. Selbstverständlich kann ein Gehege auch von einem anderen abgeleitet werden.\nBei den Tieren ist es festgelegt, dass es Land-, Wasser- und Flugtiere geben soll. Jede dieser Gruppen hat bestimmte Fähigkeiten:\nLandtiere können sich zu Fuss bewegen (z.B. walk()). Wassertiere können schwimmen (z.B. swim()). Flugtiere können fliegen (z.B. fly()). Zusätzlich soll jedes Tier eine Methode besitzen, um einen spezifischen Laut von sich zu geben (z.B. makeNoise()). Das Standardverhalten ist, dass ein Tier kein Ton macht. Bei den Tieren, bei denen das nicht zutrifft, muss dieses Verhalten entsprechend angepasst werden.\nFühre Tiere ein, die in mehr als einem dieser Bereiche agieren können (z.B. ein Tier, das sowohl an Land als auch im Wasser leben kann.). Stelle sicher, dass du mindestens ein Tier hast, welches keinen Laut macht. Achte darauf, diese Kombinationen korrekt zu modellieren.\nDu kannst frei wählen, welche konkreten Tiere dein Zoo enthalten soll und wie diese auf die Gehege verteilt werden. Beispiele wären:\nKrokodil (Land- und Wassertier) Adler (Land- und Flugtier) Pinguin (Land- und Wassertier) Qualle (Wassertier) Der Zoo hat also Mitarbeiter und Mitglieder sowie verschiedene Tiere, die in verschiedenen Gehegen leben. Die Beziehungen zwischen den Klassen, wie Zoo, Gehegen und Tieren, sollten den realen Verhältnissen in einem Zoo nachempfunden sein.\nInfo: Bei dieser Aufgabe darf man NICHT Gebrauch von Lombok machen.\nHier kannst du zurück zur Theorie.\n","categories":"","description":"Aufgabe zu Modul #J3 - [OOD](../../../../docs/02_java/07_java-ood) - Zoo\n","excerpt":"Aufgabe zu Modul #J3 - [OOD](../../../../docs/02_java/07_java-ood) - …","ref":"/labs/02_java/07_java-ood/03_zoo/","tags":"","title":"Zoo"},{"body":"Modelliere einen Klassenaufbau für einen Zoo. Folgende Klassen sollen enthalten sein:\nPersonen Gehege Tiere Jede dieser Klassen soll mehrere Spezialisierungen enthalten.\nBei den Personen unterscheidet man zwischen Mitarbeitern und Mitgliedern. Ein Mitarbeiter hat beispielsweise einen Lohn, den ein Mitglied nicht hat. Die folgenden Attribute sollen vorhanden sein:\nLohn Beschreibung des Jobs Telefonnummer Mitglied seit Nummer der Mitglied-Karte Verteile die Attribute also korrekt auf die Generalisierung und die Spezialisierungen.\nBei den Gehegen wird unterschieden zwischen Gelände, Terrarium, Aquarium und Käfig. Die einzigartigen Eigenschaften der verschiedenen Gehege sollen wie folgt modelliert werden:\nGehege-Nummer Grösse in Quadratmeter Temperatur Feuchtigkeit Süss- / Salzwasser Fassungsvermögen Zaunhöhe Wassergraben vorhanden Verteile die Attribute also korrekt auf die Generalisierung und die Spezialisierung. Selbstverständlich kann ein Gehege auch von einem anderen abgeleitet werden.\nBei den Tieren ist es festgelegt, dass es Land-, Wasser- und Flugtiere geben soll. Jede dieser Gruppen hat bestimmte Fähigkeiten:\nLandtiere können sich zu Fuss bewegen (z.B. walk()). Wassertiere können schwimmen (z.B. swim()). Flugtiere können fliegen (z.B. fly()). Zusätzlich soll jedes Tier eine Methode besitzen, um einen spezifischen Laut von sich zu geben (z.B. makeNoise()). Das Standardverhalten ist, dass ein Tier kein Ton macht. Bei den Tieren, bei denen das nicht zutrifft, muss dieses Verhalten entsprechend angepasst werden.\nFühre Tiere ein, die in mehr als einem dieser Bereiche agieren können (z.B. ein Tier, das sowohl an Land als auch im Wasser leben kann.). Stelle sicher, dass du mindestens ein Tier hast, welches keinen Laut macht. Achte darauf, diese Kombinationen korrekt zu modellieren.\nDu kannst frei wählen, welche konkreten Tiere dein Zoo enthalten soll und wie diese auf die Gehege verteilt werden. Beispiele wären:\nKrokodil (Land- und Wassertier) Adler (Land- und Flugtier) Pinguin (Land- und Wassertier) Qualle (Wassertier) Der Zoo hat also Mitarbeiter und Mitglieder sowie verschiedene Tiere, die in verschiedenen Gehegen leben. Die Beziehungen zwischen den Klassen, wie Zoo, Gehegen und Tieren, sollten den realen Verhältnissen in einem Zoo nachempfunden sein.\nInfo: Bei dieser Aufgabe darf man NICHT Gebrauch von Lombok machen.\nHier kannst du zurück zur Theorie.\n","categories":"","description":"Aufgabe zu Modul #J3 - [OOD](../../../../docs/02_java/07_java-ood) - Zoo\n","excerpt":"Aufgabe zu Modul #J3 - [OOD](../../../../docs/02_java/07_java-ood) - …","ref":"/de/labs/02_java/07_java-ood/03_zoo/","tags":"","title":"Zoo"},{"body":"Ziele Ich kann ohne Hilfsmittel alle Zugriffsmodifikatoren beschreiben. Ich kann die Auswirkungen von allen Zugriffsmodifikatoren auf Klassen-, Felder- und Methoden-Ebene beschreiben. Ich kann erklären, warum Felder (Instanzvariablen) immer mit dem Schlüsselwort private deklariert werden sollten. Zugriffsmodifikatoren In Java können wir Klassen, Feldern und Methoden Zugriffsbeschränkungen auferlegen. Diese Einschränkungen werden durch Zugriffsmodifikatoren festgelegt. Zugriffsmodifikatoren bestimmen die Sichtbarkeit von Klassen, Feldern und Methoden und damit deren Verwendbarkeit aus anderen Programmteilen. Es gibt vier Zugriffsmodifikatoren.\nPrivate Auf eine private Instanzvariable oder -methode kann von ausserhalb der Klasse nicht zugegriffen werden. Es ist eine gängige Praxis, Instanzvariablen privat zu halten. Wir möchten schliesslich nicht, dass jemand unsere Daten direkt manipuliert. Dieses Prinzip nennt man auch Kapselung.\n1 2 3 class Person { private String name; } Klassen, welche als private deklariert werden sind immer sog. innere oder nested Klassen. Auf diese Klassen kann nur innerhalb der umhüllenden Klasse zugegriffen werden.\n1 2 3 4 5 6 7 class Person { private class NestedPerson { //NestedPerson ist nur für die Klasse Person sichtbar } private String name; } UML-Symbol: -\nPublic Auf Klassen, Felder und Methoden, die mit dem Schlüsselwort public deklariert sind, kann von einem beliebigen Ort des Programms zugegriffen werden. Sie sind also öffentlich.\n1 2 3 4 5 6 7 public class Person { private String name; public String getName() { return name; } } Auf öffentliche Methoden und Felder kann ein Objekt über den Punkt-Operator zugreifen.\n1 2 Person p = new Person(); p.getName(); UML-Symbol: +\nProtected Wenn ein Feld oder eine Methode mit protected deklariert ist, dann kann nur vom gleichen Package oder von Unterklassen darauf zugegriffen werden (Unterklassen folgen später im Modul Objektorientiertes Design).\nWichtig zu beachten ist, dass Subpackages von Java wie separate Packages behandelt werden. Dementsprechend kann die Klasse AccessClass.java, wenn die Struktur wie folgt aussieht, nicht auf Protected Members der Klasse ParentClass.java zugreifen.\n1 2 3 4 5 6 src └── ch └── sbb ├── ParentClass.java └── subpackage └── AccessClass.java UML-Symbol: #\nPackage-Private Wenn eine Klasse, ein Feld oder eine Methode keinen Zugriffsmodifikator hat, so besitzt sie trotzdem einen. Dieser wird Package-Private genannt. Die Sichtbarkeit ist grundsätzlich private, wird aber auf Klasse im gleichen Package ausgeweitet. Das bedeutet, dass andere Klassen innerhalb derselben Package, Zugriff auf diese Klasse, Felder und Methoden haben. Für Subpackages gilt das Gleiche wie bei Protected.\nZusammenfassung Modifikator Eigene Klasse Klasse im gleichen Package / innere-Klassen Unterklassen Sonstige Klassen private ja nein nein nein public ja ja ja ja protected ja ja ja nein Keinen (package-private) ja ja nur im gleichen Package nein ","categories":"","description":"Modul #J2\n","excerpt":"Modul #J2\n","ref":"/docs/02_java/04_java-oop/03_access-modifier/","tags":"","title":"Zugriffsmodifikatoren"},{"body":"Ziele Ich kann ohne Hilfsmittel alle Zugriffsmodifikatoren beschreiben. Ich kann die Auswirkungen von allen Zugriffsmodifikatoren auf Klassen-, Felder- und Methoden-Ebene beschreiben. Ich kann erklären, warum Felder (Instanzvariablen) immer mit dem Schlüsselwort private deklariert werden sollten. Zugriffsmodifikatoren In Java können wir Klassen, Feldern und Methoden Zugriffsbeschränkungen auferlegen. Diese Einschränkungen werden durch Zugriffsmodifikatoren festgelegt. Zugriffsmodifikatoren bestimmen die Sichtbarkeit von Klassen, Feldern und Methoden und damit deren Verwendbarkeit aus anderen Programmteilen. Es gibt vier Zugriffsmodifikatoren.\nPrivate Auf eine private Instanzvariable oder -methode kann von ausserhalb der Klasse nicht zugegriffen werden. Es ist eine gängige Praxis, Instanzvariablen privat zu halten. Wir möchten schliesslich nicht, dass jemand unsere Daten direkt manipuliert. Dieses Prinzip nennt man auch Kapselung.\n1 2 3 class Person { private String name; } Klassen, welche als private deklariert werden sind immer sog. innere oder nested Klassen. Auf diese Klassen kann nur innerhalb der umhüllenden Klasse zugegriffen werden.\n1 2 3 4 5 6 7 class Person { private class NestedPerson { //NestedPerson ist nur für die Klasse Person sichtbar } private String name; } UML-Symbol: -\nPublic Auf Klassen, Felder und Methoden, die mit dem Schlüsselwort public deklariert sind, kann von einem beliebigen Ort des Programms zugegriffen werden. Sie sind also öffentlich.\n1 2 3 4 5 6 7 public class Person { private String name; public String getName() { return name; } } Auf öffentliche Methoden und Felder kann ein Objekt über den Punkt-Operator zugreifen.\n1 2 Person p = new Person(); p.getName(); UML-Symbol: +\nProtected Wenn ein Feld oder eine Methode mit protected deklariert ist, dann kann nur vom gleichen Package oder von Unterklassen darauf zugegriffen werden (Unterklassen folgen später im Modul Objektorientiertes Design).\nWichtig zu beachten ist, dass Subpackages von Java wie separate Packages behandelt werden. Dementsprechend kann die Klasse AccessClass.java, wenn die Struktur wie folgt aussieht, nicht auf Protected Members der Klasse ParentClass.java zugreifen.\n1 2 3 4 5 6 src └── ch └── sbb ├── ParentClass.java └── subpackage └── AccessClass.java UML-Symbol: #\nPackage-Private Wenn eine Klasse, ein Feld oder eine Methode keinen Zugriffsmodifikator hat, so besitzt sie trotzdem einen. Dieser wird Package-Private genannt. Die Sichtbarkeit ist grundsätzlich private, wird aber auf Klasse im gleichen Package ausgeweitet. Das bedeutet, dass andere Klassen innerhalb derselben Package, Zugriff auf diese Klasse, Felder und Methoden haben. Für Subpackages gilt das Gleiche wie bei Protected.\nZusammenfassung Modifikator Eigene Klasse Klasse im gleichen Package / innere-Klassen Unterklassen Sonstige Klassen private ja nein nein nein public ja ja ja ja protected ja ja ja nein Keinen (package-private) ja ja nur im gleichen Package nein ","categories":"","description":"Modul #J2\n","excerpt":"Modul #J2\n","ref":"/de/docs/02_java/04_java-oop/03_access-modifier/","tags":"","title":"Zugriffsmodifikatoren"},{"body":"Voraussetzungen Die Vorbereitungen aus Aufgabe 1 sind umgesetzt. Insbesondere sind erledigt:\nZwei neue Repositories mit vorhandenen Projekten wurden erstellt. Es sind jeweils die Branches master und develop vorhanden. Alle Team-Mitglieder haben diese Repositories geklont. Simulieren einer realen Projektarbeit Ein realistisches Szenario beinhaltet die konkurrierende Arbeit mehrerer Team-Mitglieder auf demselben Repository, die Arbeit mit mehreren Projekten und die Notwendigkeit schnell zwischen den Projekten und einzelnen Versionsständen wechseln zu können.\nIm ersten Abschnitt wird die Zusammenarbeit an einem Projekt simuliert, um die Kenntnisse zum Anlegen, Aktualisieren,Vergleichen und Mergen von Branches aufzufrischen. Hierzu werden die Git Befehle\nbranch, checkout, push, diff, branch -merged, merge, rebase verwendet/wiederholt. In den Labs zu diesem Modul werden die Git-Aktionen hauptsächlich innerhalb von IntelliJ oder über die Weboberfläche von Bitbucket ausgeführt, da dies das in den Projekten übliche Vorgehen ist.\nBitbucket Hauptansicht Die Standardanzeige von Bitbucket ist die Auflistung der vorhandenen Branches. Wichtige Elemente auf der Bitbucket Weboberfläche, die in diesem Modul benutzt werden, sind durch rote Markierungen hervorgehoben.\nEin Pull Request kann durch einen Klick auf den Branch in der Branch-Übersicht oder auf der Übersichtsseite der Pull Requests über den Button Pull-Anfrage erstellen (oben rechts) erstellt werden. (siehe nächstes Bild)\nPull Request Übersicht aller Pull Requests. Hier werden alle im Repository erstellt Pull Requests aufgelistet. Dabei kann ausgewählt werden, ob nur die offenen Pull Requests (Standardeinstellung), die zusammengeführten, abgelehnten oder alle Pull Requests angezeigt werden sollen.\nWird ein neuer Pull Request erstellt, sind Ausgangs- und Zielbranch bereits vorbelegt. Beide können geändert oder auch die Richtung der Zusammenführung umgekehrt werden. Bei der Erstellung eines neuen Pull Request ist besonders darauf zu achten, dass der richtige Zielbranch (rote Markierung) ausgewählt ist. Für die Übungen in diesem Modul wird das immer develop sein.\nWill man einen Pull Request überprüfen, so gibt es verschiedene Informationen und Aktionen, die dabei helfen können.\nFügt den aktuellen User als Prüfer hinzu. Zeigt die Aktionen an die erforderlich sind, bevor der Pull Request gemergt werden kann. Dazu gehören neben den erforderlichen Freigaben durch den/die Prüfer, auch erfoderliche Builds und eventuell zu lösende Konflikte. Startet die Überprüfung (nur nötig, wenn eine Protokollierung gefordert ist). Ausserdem werden die Kommentare des Erstellers und anderer Prüfer in der Übersicht angezeigt. Diff führt die Unterschiede zwischen Ausgangs- und Zielbranch auf. Dabei werden entfernte Zeilen rot und hinzugefügte Zeilen grün hinterlegt. Jede Änderung an einer Zeile, und sei es auch nur ein einzelnes Zeichen, wird immer als Entfernen der alten Zeile und Einfügen der neuen Zeile dargestellt. Alle zu diesem Pull Request gehörenden Commits und auch alle Builds können einzeln angeschaut werden.\nIDEA IntelliJ Einige der Git-Befehle werden auch in IntelliJ ausgeführt. Die in den Labs verwendeten Menueinträge sind farbig markiert.\nWill man die Änderungen vom Arbeitsbereich in das Repository übertragen, wird git commit verwendet. In IntelliJ kann dazu der Menu-Eintrag Commit… oder auch Push aus dem Kontextmenu des Projekts aufgerufen werden. Die Ansicht wechselt nun auf die Commit-View:\nAnzeige der geänderten Dateien; hier können einzelne oder alle Dateien ausgewählt werden, die bei Ausführung von commit im Repository aktualisiert werden. Die Commit-Message ist erforderlich und beschreibt die übertragenen Änderungen in Kurzfassung. Mit dem Button Commit werden die Änderungen in das lokale Repository übernommen, mit Commit and Push.. werden sie anschliessend auch auf das remote Repository übertragen, wo sie dann allen zugänglich sind. Collaboration In der Praxis ist es üblich, dass in grossen Projekten mehrere Entwickler an der gleichen Codebasis arbeiten, aber für unterschiedliche fachliche Features zuständig sind. Diese Änderungen müssen regelmässig zusammengeführt werden, damit alle Entwickler auf dem aktuellen Stand arbeiten können. Dabei kommt es immer wieder auch vor, dass Änderungen an einer Klasse in unterschiedlichen Branches zusammen geführt werden müssen. Im Regelfall erledigt Git diese Zusammenführung (merge) automatisch. Wenn jedoch Konflikte auftreten, d.h. eine Zeile in beiden Branches, die zusammengeführt werden sollen, geändert wurde, kann Git nicht entscheiden, welches die “richtige” Version ist. Hier muss der Entwickler entscheiden.\nDieses Szenario kann leicht nachgestellt werden, indem mehrere Team-Mitglieder einen Feature-Branch von develop erstellen und auf diesem arbeiten.\nIn einer ersten Aufgabe sollen kleine Änderungen ohne Merge-Konflikte vorgenommen und zusammegeführt werden. Dazu werden in den Feature-Branches unterschiediche Dateien bzw. Codestellen bearbeitet und anschliessend auf develop zusammengeführt.\nDer zweite Teil stellt Merge-Konflikte und deren Auflösung durch den Entwickler nach. Hier sollen jeweils mehrere kleine Änderungen am Code vorgenommen werden. Dabei wird mindestens eine Zeile einer bestimmten Datei von allen beteiligten Entwicklern geändert. Die Änderungen werden auf den Feature-Branch gepusht und dann nacheinander auf develop zusammengeführt. Jetzt sollte es zu merge-Konflikten kommen, die es zu lösen gilt.\nDie passenden Aufgaben sind in den Labs unter\nVorbereiten der IDE Gemeinsames Arbeiten an einem Projekt (ohne Konflikte) und Gemeinsames Arbeitane an einem Projekt (mit Merge-Konflikten) zu finden.\n","categories":"","description":"","excerpt":"Voraussetzungen Die Vorbereitungen aus Aufgabe 1 sind umgesetzt. …","ref":"/docs/04_git/02_vertiefung/02_zusammenarbeit/","tags":"","title":"Zusammenarbeit im Projekt"},{"body":"Voraussetzungen Die Vorbereitungen aus Aufgabe 1 sind umgesetzt. Insbesondere sind erledigt:\nZwei neue Repositories mit vorhandenen Projekten wurden erstellt. Es sind jeweils die Branches master und develop vorhanden. Alle Team-Mitglieder haben diese Repositories geklont. Simulieren einer realen Projektarbeit Ein realistisches Szenario beinhaltet die konkurrierende Arbeit mehrerer Team-Mitglieder auf demselben Repository, die Arbeit mit mehreren Projekten und die Notwendigkeit schnell zwischen den Projekten und einzelnen Versionsständen wechseln zu können.\nIm ersten Abschnitt wird die Zusammenarbeit an einem Projekt simuliert, um die Kenntnisse zum Anlegen, Aktualisieren,Vergleichen und Mergen von Branches aufzufrischen. Hierzu werden die Git Befehle\nbranch, checkout, push, diff, branch -merged, merge, rebase verwendet/wiederholt. In den Labs zu diesem Modul werden die Git-Aktionen hauptsächlich innerhalb von IntelliJ oder über die Weboberfläche von Bitbucket ausgeführt, da dies das in den Projekten übliche Vorgehen ist.\nBitbucket Hauptansicht Die Standardanzeige von Bitbucket ist die Auflistung der vorhandenen Branches. Wichtige Elemente auf der Bitbucket Weboberfläche, die in diesem Modul benutzt werden, sind durch rote Markierungen hervorgehoben.\nEin Pull Request kann durch einen Klick auf den Branch in der Branch-Übersicht oder auf der Übersichtsseite der Pull Requests über den Button Pull-Anfrage erstellen (oben rechts) erstellt werden. (siehe nächstes Bild)\nPull Request Übersicht aller Pull Requests. Hier werden alle im Repository erstellt Pull Requests aufgelistet. Dabei kann ausgewählt werden, ob nur die offenen Pull Requests (Standardeinstellung), die zusammengeführten, abgelehnten oder alle Pull Requests angezeigt werden sollen.\nWird ein neuer Pull Request erstellt, sind Ausgangs- und Zielbranch bereits vorbelegt. Beide können geändert oder auch die Richtung der Zusammenführung umgekehrt werden. Bei der Erstellung eines neuen Pull Request ist besonders darauf zu achten, dass der richtige Zielbranch (rote Markierung) ausgewählt ist. Für die Übungen in diesem Modul wird das immer develop sein.\nWill man einen Pull Request überprüfen, so gibt es verschiedene Informationen und Aktionen, die dabei helfen können.\nFügt den aktuellen User als Prüfer hinzu. Zeigt die Aktionen an die erforderlich sind, bevor der Pull Request gemergt werden kann. Dazu gehören neben den erforderlichen Freigaben durch den/die Prüfer, auch erfoderliche Builds und eventuell zu lösende Konflikte. Startet die Überprüfung (nur nötig, wenn eine Protokollierung gefordert ist). Ausserdem werden die Kommentare des Erstellers und anderer Prüfer in der Übersicht angezeigt. Diff führt die Unterschiede zwischen Ausgangs- und Zielbranch auf. Dabei werden entfernte Zeilen rot und hinzugefügte Zeilen grün hinterlegt. Jede Änderung an einer Zeile, und sei es auch nur ein einzelnes Zeichen, wird immer als Entfernen der alten Zeile und Einfügen der neuen Zeile dargestellt. Alle zu diesem Pull Request gehörenden Commits und auch alle Builds können einzeln angeschaut werden.\nIDEA IntelliJ Einige der Git-Befehle werden auch in IntelliJ ausgeführt. Die in den Labs verwendeten Menueinträge sind farbig markiert.\nWill man die Änderungen vom Arbeitsbereich in das Repository übertragen, wird git commit verwendet. In IntelliJ kann dazu der Menu-Eintrag Commit… oder auch Push aus dem Kontextmenu des Projekts aufgerufen werden. Die Ansicht wechselt nun auf die Commit-View:\nAnzeige der geänderten Dateien; hier können einzelne oder alle Dateien ausgewählt werden, die bei Ausführung von commit im Repository aktualisiert werden. Die Commit-Message ist erforderlich und beschreibt die übertragenen Änderungen in Kurzfassung. Mit dem Button Commit werden die Änderungen in das lokale Repository übernommen, mit Commit and Push.. werden sie anschliessend auch auf das remote Repository übertragen, wo sie dann allen zugänglich sind. Collaboration In der Praxis ist es üblich, dass in grossen Projekten mehrere Entwickler an der gleichen Codebasis arbeiten, aber für unterschiedliche fachliche Features zuständig sind. Diese Änderungen müssen regelmässig zusammengeführt werden, damit alle Entwickler auf dem aktuellen Stand arbeiten können. Dabei kommt es immer wieder auch vor, dass Änderungen an einer Klasse in unterschiedlichen Branches zusammen geführt werden müssen. Im Regelfall erledigt Git diese Zusammenführung (merge) automatisch. Wenn jedoch Konflikte auftreten, d.h. eine Zeile in beiden Branches, die zusammengeführt werden sollen, geändert wurde, kann Git nicht entscheiden, welches die “richtige” Version ist. Hier muss der Entwickler entscheiden.\nDieses Szenario kann leicht nachgestellt werden, indem mehrere Team-Mitglieder einen Feature-Branch von develop erstellen und auf diesem arbeiten.\nIn einer ersten Aufgabe sollen kleine Änderungen ohne Merge-Konflikte vorgenommen und zusammegeführt werden. Dazu werden in den Feature-Branches unterschiediche Dateien bzw. Codestellen bearbeitet und anschliessend auf develop zusammengeführt.\nDer zweite Teil stellt Merge-Konflikte und deren Auflösung durch den Entwickler nach. Hier sollen jeweils mehrere kleine Änderungen am Code vorgenommen werden. Dabei wird mindestens eine Zeile einer bestimmten Datei von allen beteiligten Entwicklern geändert. Die Änderungen werden auf den Feature-Branch gepusht und dann nacheinander auf develop zusammengeführt. Jetzt sollte es zu merge-Konflikten kommen, die es zu lösen gilt.\nDie passenden Aufgaben sind in den Labs unter\nVorbereiten der IDE Gemeinsames Arbeiten an einem Projekt (ohne Konflikte) und Gemeinsames Arbeitane an einem Projekt (mit Merge-Konflikten) zu finden.\n","categories":"","description":"","excerpt":"Voraussetzungen Die Vorbereitungen aus Aufgabe 1 sind umgesetzt. …","ref":"/de/docs/04_git/02_vertiefung/02_zusammenarbeit/","tags":"","title":"Zusammenarbeit im Projekt"},{"body":"","categories":"","description":"Entwickungsumgebung aufsetzen für das Arbeiten mit Angular.\n","excerpt":"Entwickungsumgebung aufsetzen für das Arbeiten mit Angular.\n","ref":"/docs/03_web/04_ide-advanced/","tags":"","title":"Frontend IDE Advanced"},{"body":"","categories":"","description":"Entwickungsumgebung aufsetzen für das Arbeiten mit Angular.\n","excerpt":"Entwickungsumgebung aufsetzen für das Arbeiten mit Angular.\n","ref":"/de/docs/03_web/04_ide-advanced/","tags":"","title":"Frontend IDE Advanced"},{"body":"Ziele Du kannst eine Typescript-Datei erstellen und ausführen lassen. Du bist in der Lage, eine Typescript-Datei in eine Javascript-Datei zu transpilieren. Hello World Da Node.js bereits installiert wurde, kann nun anhand des Node Package Manager mühelos Typescript installiert werden. Dazu öffnet man eine Konsole und gibt den folgenden Befehl ein:\n1 npm install -g typescript Sobald die Installation abgeschlossen ist, erstellt man eine Datei und nennt diese hello-world.ts. Nun die Datei mit einer IDE öffnen und die folgende Codezeile reinschreiben:\n1 console.log(\"Hello World\"); Somit wurde das erste Typescript “Projekt” erstellt. Um dieses auszuführen, muss der Quellcode zu JS transpiliert werden. Dazu eine Konsole öffnen und sich in das Verzeichnis, indem sich die Datei befindet, begeben.\nDanach folgenden Befehl in der Konsole eingeben:\n1 tsc hello-world.ts Wie nun zu sehen ist, befindet sich im Verzeichnis eine gleichnamige JS Datei.\nDiese kann nun mit Node ausgeführt werden:\n1 node hello-world.js Falls alles funktioniert hat, gibt die Konsole Hello World aus.\n","categories":"","description":"Modul #F5 - TypeScript - TypeScript in Projekten\n","excerpt":"Modul #F5 - TypeScript - TypeScript in Projekten\n","ref":"/docs/03_web/05_typescript/04_projekt-aufsetzen/","tags":"","title":"Projekt aufsetzen in TypeScript"},{"body":"Ziele Du kannst eine Typescript-Datei erstellen und ausführen lassen. Du bist in der Lage, eine Typescript-Datei in eine Javascript-Datei zu transpilieren. Hello World Da Node.js bereits installiert wurde, kann nun anhand des Node Package Manager mühelos Typescript installiert werden. Dazu öffnet man eine Konsole und gibt den folgenden Befehl ein:\n1 npm install -g typescript Sobald die Installation abgeschlossen ist, erstellt man eine Datei und nennt diese hello-world.ts. Nun die Datei mit einer IDE öffnen und die folgende Codezeile reinschreiben:\n1 console.log(\"Hello World\"); Somit wurde das erste Typescript “Projekt” erstellt. Um dieses auszuführen, muss der Quellcode zu JS transpiliert werden. Dazu eine Konsole öffnen und sich in das Verzeichnis, indem sich die Datei befindet, begeben.\nDanach folgenden Befehl in der Konsole eingeben:\n1 tsc hello-world.ts Wie nun zu sehen ist, befindet sich im Verzeichnis eine gleichnamige JS Datei.\nDiese kann nun mit Node ausgeführt werden:\n1 node hello-world.js Falls alles funktioniert hat, gibt die Konsole Hello World aus.\n","categories":"","description":"Modul #F5 - TypeScript - TypeScript in Projekten\n","excerpt":"Modul #F5 - TypeScript - TypeScript in Projekten\n","ref":"/de/docs/03_web/05_typescript/04_projekt-aufsetzen/","tags":"","title":"Projekt aufsetzen in TypeScript"},{"body":"Ziele Du weisst, was NgRx Selectors sind und kannst diese anwenden. Du weisst, was der AppState ist. AppState In einer typischen NgRx-Anwendung kann die AppState-Datei verwendet werden, um den gesamten Anwendungsstatus zu definieren und zu typisieren. Sie enthält normalerweise eine Schnittstelle oder ein Interface, das alle Teilzustände oder Slices des Anwendungsstatus definiert und zu einem Gesamtzustand kombiniert. Diesen findet man im index.ts, wo man auch Erweiterungen umsetzen kann.\n1 2 3 4 5 6 7 export interface AbilityState { abilities: string[]; } export interface AppState { ability: AbilityState; } NgRx Selectors Selectors sind Funktionen, die dazu dienen, bestimmte Teile des Zustands aus dem Store abzurufen. Sie ermöglichen es, den Zustand zu filtern, zu transformieren und zu kombinieren, um spezifische Daten abzurufen, die von den Components verwendet werden.\nIn unserem Beispiel vereinfachen wir das Beispiel aus den Actions, da man dort nur mühsam zu den abilities gekommen ist.\n1 2 3 4 5 6 7 8 9 import { createSelector } from \"@ngrx/store\"; import { AppState } from \"../reducer/index.ts\"; export const selectAbilityState = (state: AppState) =\u003e state.ability; export const getAbilities = createSelector( selectAbilityState, (state) =\u003e state.abilities, ); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import { Component, OnInit } from \"@angular/core\"; import { Store, select } from \"@ngrx/store\"; import { addAbility, deleteAbility } from \"src/app/actions/ability.actions\"; import { AppState } from \"src/app/reducer/index.ts\"; import { getAbilities } from \"src/app/selectors/ability.selectors\"; @Component({ // .. }) export class AbilityComponent implements OnInit { abilities$: Observable\u003cstring[]\u003e = new Observable\u003cstring[]\u003e(); private store = inject(Store\u003c{ ability: { abilities: string[] } }\u003e); constructor() {} ngOnInit(): void { this.abilities$ = this.store.select(getAbilities); } // .. } ","categories":"","description":"Modul #F7 - Angular NgRx - Selectors\n","excerpt":"Modul #F7 - Angular NgRx - Selectors\n","ref":"/docs/03_web/07_angular-ngrx/04_ngrx-selectors/","tags":"","title":"NgRx Selectors"},{"body":"Ziele Du weisst, was NgRx Selectors sind und kannst diese anwenden. Du weisst, was der AppState ist. AppState In einer typischen NgRx-Anwendung kann die AppState-Datei verwendet werden, um den gesamten Anwendungsstatus zu definieren und zu typisieren. Sie enthält normalerweise eine Schnittstelle oder ein Interface, das alle Teilzustände oder Slices des Anwendungsstatus definiert und zu einem Gesamtzustand kombiniert. Diesen findet man im index.ts, wo man auch Erweiterungen umsetzen kann.\n1 2 3 4 5 6 7 export interface AbilityState { abilities: string[]; } export interface AppState { ability: AbilityState; } NgRx Selectors Selectors sind Funktionen, die dazu dienen, bestimmte Teile des Zustands aus dem Store abzurufen. Sie ermöglichen es, den Zustand zu filtern, zu transformieren und zu kombinieren, um spezifische Daten abzurufen, die von den Components verwendet werden.\nIn unserem Beispiel vereinfachen wir das Beispiel aus den Actions, da man dort nur mühsam zu den abilities gekommen ist.\n1 2 3 4 5 6 7 8 9 import { createSelector } from \"@ngrx/store\"; import { AppState } from \"../reducer/index.ts\"; export const selectAbilityState = (state: AppState) =\u003e state.ability; export const getAbilities = createSelector( selectAbilityState, (state) =\u003e state.abilities, ); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import { Component, OnInit } from \"@angular/core\"; import { Store, select } from \"@ngrx/store\"; import { addAbility, deleteAbility } from \"src/app/actions/ability.actions\"; import { AppState } from \"src/app/reducer/index.ts\"; import { getAbilities } from \"src/app/selectors/ability.selectors\"; @Component({ // .. }) export class AbilityComponent implements OnInit { abilities$: Observable\u003cstring[]\u003e = new Observable\u003cstring[]\u003e(); private store = inject(Store\u003c{ ability: { abilities: string[] } }\u003e); constructor() {} ngOnInit(): void { this.abilities$ = this.store.select(getAbilities); } // .. } ","categories":"","description":"Modul #F7 - Angular NgRx - Selectors\n","excerpt":"Modul #F7 - Angular NgRx - Selectors\n","ref":"/de/docs/03_web/07_angular-ngrx/04_ngrx-selectors/","tags":"","title":"NgRx Selectors"},{"body":"Ziele Du weisst, was ein Angular Component ist. Du weisst, welche vier Dateien zu einem Component gehören. Du kannst einen Component ins Template einbinden. Ein Angular Component setzt sich aus 4 Dateien zusammen:\nTemplate Unit Test File Stylesheet Component (Class) Components Components sind wie Grundbausteine in einer Angular-Applikation. Components werden mit dem @Component Decorator definiert.\nComponents sind TypeScript Klassen, die die Daten und Kontrollstrukturen zum Verhalten der Templates beinhalten. Metadaten teilen Angular mit, wie die Components verarbeitet werden sollen (selector, template, style), das kann im Kapitel Component Decorator genauer nachgelesen werden. Ein Component hat einen von Angular verwalteten Lifecycle. Angular erstellt und rendert Components zusammen mit ihren Children. Überprüft, wann sich ihre Properties ändern, und zerstört sie, bevor sie aus dem DOM entfernt werden. Angular bietet sogenannte Lifecycle-Hooks an, mit denen wir handeln können, sobald ein bestimmter Teils des Lifecycles auftrtitt.\nComponents im Template aufrufen In Angular kann man Components im Template aufrufen, indem man ihren Selektor verwendet.\nDurch das Aufrufen von Components im Template kann man wiederverwendbare Teile der Benutzeroberfläche erstellen und sie in verschiedenen Teilen der Anwendung verwenden, um Code-Duplikation zu vermeiden, aber auch, um die Lesbarkeit und Wartbarkeit des Codes zu verbessern.\nAls erstes muss man den Component erstellen, das geht mit dem CLI Command ng generate component greeting oder kürzer ng g c greeting:\n1 2 3 4 5 6 7 8 9 10 import { Component } from \"@angular/core\"; @Component({ selector: \"app-greeting\", templateUrl: \"./app-greeting.html\", styleUrls: [\"./app-greeting.scss\"], }) export class GreetingComponent { name: string = \"Dragon Warrior\"; } 1 2 \u003c!--app-greeting.html--\u003e \u003ch1\u003eHello, {{ name }}!\u003c/h1\u003e Nachdem man den Component erstellt hat, kann man ihn im Template eines anderen Components aufrufen, dazu kann man den Selektor verwenden.\n1 2 3 \u003cdiv\u003e \u003capp-greeting\u003e\u003c/app-greeting\u003e \u003c/div\u003e Das Ergebnis ist, dass die \u003capp-greeting\u003e\u003c/app-greeting\u003e Tags durch das gerenderte Template des GreetingComponent ersetzt werden. In diesem Fall wird eine Überschrift “Hello, John!” angezeigt, weil name im Typescript auf “John” gesetzt ist.\n","categories":"","description":"Modul #F6 - Angular - Components\n","excerpt":"Modul #F6 - Angular - Components\n","ref":"/docs/03_web/06_angular/02_3_components/","tags":"","title":"Components"},{"body":"Ziele Du weisst, was ein Angular Component ist. Du weisst, welche vier Dateien zu einem Component gehören. Du kannst einen Component ins Template einbinden. Ein Angular Component setzt sich aus 4 Dateien zusammen:\nTemplate Unit Test File Stylesheet Component (Class) Components Components sind wie Grundbausteine in einer Angular-Applikation. Components werden mit dem @Component Decorator definiert.\nComponents sind TypeScript Klassen, die die Daten und Kontrollstrukturen zum Verhalten der Templates beinhalten. Metadaten teilen Angular mit, wie die Components verarbeitet werden sollen (selector, template, style), das kann im Kapitel Component Decorator genauer nachgelesen werden. Ein Component hat einen von Angular verwalteten Lifecycle. Angular erstellt und rendert Components zusammen mit ihren Children. Überprüft, wann sich ihre Properties ändern, und zerstört sie, bevor sie aus dem DOM entfernt werden. Angular bietet sogenannte Lifecycle-Hooks an, mit denen wir handeln können, sobald ein bestimmter Teils des Lifecycles auftrtitt.\nComponents im Template aufrufen In Angular kann man Components im Template aufrufen, indem man ihren Selektor verwendet.\nDurch das Aufrufen von Components im Template kann man wiederverwendbare Teile der Benutzeroberfläche erstellen und sie in verschiedenen Teilen der Anwendung verwenden, um Code-Duplikation zu vermeiden, aber auch, um die Lesbarkeit und Wartbarkeit des Codes zu verbessern.\nAls erstes muss man den Component erstellen, das geht mit dem CLI Command ng generate component greeting oder kürzer ng g c greeting:\n1 2 3 4 5 6 7 8 9 10 import { Component } from \"@angular/core\"; @Component({ selector: \"app-greeting\", templateUrl: \"./app-greeting.html\", styleUrls: [\"./app-greeting.scss\"], }) export class GreetingComponent { name: string = \"Dragon Warrior\"; } 1 2 \u003c!--app-greeting.html--\u003e \u003ch1\u003eHello, {{ name }}!\u003c/h1\u003e Nachdem man den Component erstellt hat, kann man ihn im Template eines anderen Components aufrufen, dazu kann man den Selektor verwenden.\n1 2 3 \u003cdiv\u003e \u003capp-greeting\u003e\u003c/app-greeting\u003e \u003c/div\u003e Das Ergebnis ist, dass die \u003capp-greeting\u003e\u003c/app-greeting\u003e Tags durch das gerenderte Template des GreetingComponent ersetzt werden. In diesem Fall wird eine Überschrift “Hello, John!” angezeigt, weil name im Typescript auf “John” gesetzt ist.\n","categories":"","description":"Modul #F6 - Angular - Components\n","excerpt":"Modul #F6 - Angular - Components\n","ref":"/de/docs/03_web/06_angular/02_3_components/","tags":"","title":"Components"},{"body":"Übung macht den Meister Bevor wir mit fortgeschrittenen JavaScript-Themen weiterfahren, sollst du die Basics von JavaScript verstanden haben.\nHierfür empfehlen wir dir folgenden Online-Kurs: https://www.codecademy.com/learn/introduction-to-javascript\nUm diesen Kurs durchführen zu können, musst du einen Account erstellen. Dafür kannst du deine eigene E-Mail-Adresse benutzen.\nDieser Kurs ist grundlegend. Da die Syntax in JavaScript und Java relativ ähnlich sind, sollte einiges für dich mehr oder weniger eine Repetition des Java-Teils sein.\nMöchtest du beispielsweise zur nächsten Aufgabe ohne die aktuelle lösen zu müssen, dann kannst du zweimal auf “Run” klicken, dann auf “View Solution” und anschliessend auf “Replace with Solution”.\nEine Übersicht über die Themen erhältst du oben links via Klick auf “Course Menu”.\nBeachte, dass du mindestens die folgenden Themen verstanden hast und anwenden kannst:\nKapitel Das musst du anwenden können Bemerkungen Introduction Variablen definieren, Unterschied zwischen var, let und const, mathematische Operationen, typeof-Operator, String-Methoden wie trim, startsWith, … Prüfe dein Wissen mit dem “Introduction to JavaScript”-Quiz Conditionals if-/else-/switch-statements, Vergleichsoperatoren, truthy- und falsy-Werte Löse auch ein paar Aufgaben und den Test zum Thema “Conditional Statements” solltest du fehlerfrei abschliessen können. Functions Funktions-Definition, -Aufruf, Default-Parameter, Arrow Functions, Function Expressions, Globaler und Block-Scope Die Tests sind leider nicht mehr in der kostenlosen Version inbegriffen. Arrays Arrays und Listen erstellen, updaten, Länge bestimmen, durch Array iterieren Loops Du kannst for-, while- und do while-Schlaufen benutzen und mit break kontrolliert abbrechen. Iterators Functions as Data and Parameters, Iteratoren wie .forEach, .map, .filter, .reduce anwenden können Objects Objekte erstellen mit Properties und Methoden, Pass By Reference verstehen, durch Objekte iterieren, Advanced Objects mit dem this-Keyword, Getter und Setter ","categories":"","description":"Modul #F4 - JavaScript - Trainiere deine Fähigkeiten mit JavaScript.\n","excerpt":"Modul #F4 - JavaScript - Trainiere deine Fähigkeiten mit JavaScript.\n","ref":"/docs/03_web/03_javascript/04_training/","tags":"","title":"JavaScript trainieren"},{"body":"Übung macht den Meister Bevor wir mit fortgeschrittenen JavaScript-Themen weiterfahren, sollst du die Basics von JavaScript verstanden haben.\nHierfür empfehlen wir dir folgenden Online-Kurs: https://www.codecademy.com/learn/introduction-to-javascript\nUm diesen Kurs durchführen zu können, musst du einen Account erstellen. Dafür kannst du deine eigene E-Mail-Adresse benutzen.\nDieser Kurs ist grundlegend. Da die Syntax in JavaScript und Java relativ ähnlich sind, sollte einiges für dich mehr oder weniger eine Repetition des Java-Teils sein.\nMöchtest du beispielsweise zur nächsten Aufgabe ohne die aktuelle lösen zu müssen, dann kannst du zweimal auf “Run” klicken, dann auf “View Solution” und anschliessend auf “Replace with Solution”.\nEine Übersicht über die Themen erhältst du oben links via Klick auf “Course Menu”.\nBeachte, dass du mindestens die folgenden Themen verstanden hast und anwenden kannst:\nKapitel Das musst du anwenden können Bemerkungen Introduction Variablen definieren, Unterschied zwischen var, let und const, mathematische Operationen, typeof-Operator, String-Methoden wie trim, startsWith, … Prüfe dein Wissen mit dem “Introduction to JavaScript”-Quiz Conditionals if-/else-/switch-statements, Vergleichsoperatoren, truthy- und falsy-Werte Löse auch ein paar Aufgaben und den Test zum Thema “Conditional Statements” solltest du fehlerfrei abschliessen können. Functions Funktions-Definition, -Aufruf, Default-Parameter, Arrow Functions, Function Expressions, Globaler und Block-Scope Die Tests sind leider nicht mehr in der kostenlosen Version inbegriffen. Arrays Arrays und Listen erstellen, updaten, Länge bestimmen, durch Array iterieren Loops Du kannst for-, while- und do while-Schlaufen benutzen und mit break kontrolliert abbrechen. Iterators Functions as Data and Parameters, Iteratoren wie .forEach, .map, .filter, .reduce anwenden können Objects Objekte erstellen mit Properties und Methoden, Pass By Reference verstehen, durch Objekte iterieren, Advanced Objects mit dem this-Keyword, Getter und Setter ","categories":"","description":"Modul #F4 - JavaScript - Trainiere deine Fähigkeiten mit JavaScript.\n","excerpt":"Modul #F4 - JavaScript - Trainiere deine Fähigkeiten mit JavaScript.\n","ref":"/de/docs/03_web/03_javascript/04_training/","tags":"","title":"JavaScript trainieren"},{"body":"","categories":"","description":"Labs zu Angular\n","excerpt":"Labs zu Angular\n","ref":"/labs/03_web/04_angular/","tags":"","title":"Angular Labs"},{"body":"","categories":"","description":"Labs zu Angular\n","excerpt":"Labs zu Angular\n","ref":"/de/labs/03_web/04_angular/","tags":"","title":"Angular Labs"},{"body":"Ziele Du weisst was Normalisierung ist und wieso sie wichtig ist. Du kannst die ersten drei Normalformen in eigenen Worten erklären. Du kennst den Unterschied zwischen den Begriffen ERM und ERD. Du kennst die verschiedenen Beziehungstypen im Bereich der Kardinalität. Normalisierung Die Normalisierung in SQL ist ein Prozess, bei dem Datenbanktabellen in bestimmte Normalformen überführt werden, um die Datenintegrität und -konsistenz zu gewährleisten sowie Redundanzen zu minimieren. Das Ziel ist es, Daten effizient, konsistent und strukturiert zu speichern, zu verwalten und abzufragen.\nWas bedeutet das genau? Wir wollen zum Beispiel doppelte (redundante) Daten in der Datenbank vermeiden. Das spart einerseits Speicherplatz, stellt aber andererseits auch sicher, das die Integrität gewährleistet ist. Was passiert, wenn ich den gleichen User zweimal in einer Datenbank habe, und dann nur einen Eintrag davon bearbeite? Dadurch kann es zu Anomalien (Fehler, unerwartetes Verhalten) kommen, die man im Design verhindern kann.\nEin Datenbankschema kann in unterschiedlichem Mass gegen Anomalien wie Inkonsistenzen oder Redundanzen geschützt werden. Diese Abstufungen werden als Normalformen bezeichnet. In den folgenden Abschnitten wirst du die erste, zweite und dritte Normalform kennenlernen.\nErste Normalform (1NF) Angenommen, wir haben eine Tabelle mit Kundendaten, die den Namen, die Adresse und die Telefonnummer enthält:\nKundennummer Kundenname Adresse Telefonnummer 1 Max Hauptstr. 1, 123 123456789 2 Lisa Nebenstr. 5, 987 987654321 Du bekommst den Auftrag, alle Kunde von einer bestimmten Strasse oder einer bestimmten Postleihzahl aufzulisten. Jetzt musst du immer die Adresse auslesen und splitten. Das geht einfacher.\nDie erste Normalform (1NF) ist eine grundlegende Regel in der Datenbankentwicklung. Sie stellt sicher, dass eine Tabelle nur atomare (nicht weiter teilbare) Werte enthält und keine wiederholten Gruppen von Attributen aufweist. Das Ziel der 1NF ist es, Daten in ihre einfachsten, nicht weiter unterteilbaren Bestandteile zu zerlegen.\nIn der ersten Normalform muss jede Zelle einer Tabelle genau einen einzigen Wert enthalten. Mehrwertige Attribute oder Attribute mit wiederholten Gruppen von Werten sind nicht erlaubt. Falls mehrere Werte zu einem Attribut gehören, müssen diese in separate Zeilen oder Tabellen ausgelagert werden.\nBeispiel 1: Adressaufteilung\nHier nochmal die gleiche Tabelle.\nKundennummer Kundenname Adresse Telefonnummer 1 Max Hauptstr. 1, 123 123456789 2 Lisa Nebenstr. 5, 987 987654321 Diese Tabelle ist nicht in der ersten Normalform, weil die Adresse nicht in ihre einzelnen Bestandteile zerlegt ist.\nNach der Normalisierung in die 1NF sieht die Tabelle so aus:\nKundennummer Kundenname Strasse Hausnummer PLZ Ort Telefonnummer 1 Max Hauptstr. 1 123 Musterort 123456789 2 Lisa Nebenstr. 5 987 Beispielort 987654321 Beispiel 2: Liste in einer Spalte\nAngenommen, wir speichern die Lieblingsfarben von Kunden in einer Tabelle:\nKundennummer Kundenname Lieblingsfarben 1 Max Blau, Rot 2 Lisa Grün, Gelb, Blau Du kennst ja Listen aus Java: Eine List\u003cString\u003e kann mehrere Werte in einer einzigen Variable speichern. Doch in relationalen Datenbanken sollten Werte nicht als Listen innerhalb einer Spalte gespeichert werden. Was ist, wenn du gerne alle Kunden auflisten möchtest, welche die Lieblingsfarbe Rot haben? Nun muss du wieder alle Lieblingsfarben auslesen und splitten, bevor du eine Analyse machen kannst.\nStattdessen sollten sie auf mehrere Zeilen oder Tabellen aufgeteilt werden. Die Spalte Lieblingsfarben enthält mehrere Werte in einer einzigen Zelle. Dies verstösst gegen die 1NF, da die Werte nicht atomar sind.\nLösung: Wir normalisieren die Tabelle, indem wir jede Lieblingsfarbe in eine eigene Zeile auslagern:\nKundennummer Kundenname Lieblingsfarbe 1 Max Blau 1 Max Rot 2 Lisa Grün 2 Lisa Gelb 2 Lisa Blau Nun entspricht die Tabelle der ersten Normalform (1NF), da jede Zelle genau einen einzigen Wert enthält. Jetzt kannst du mit einem simplen SELECT und WHERE alle Benutzer auflisten, welche eine bestimmte Lieblingsfarbe haben.\nAber: Diese Tabelle entspricht noch nicht der zweiten Normalform (2NF). Dazu gleich mehr.\nFazit\nDie erste Normalform (1NF) sorgt dafür, dass alle Daten atomar sind, also nicht weiter unterteilt werden können, und dass keine wiederholten Gruppen von Attributen existieren. Dies verbessert die Datenstruktur, minimiert Redundanzen und erhöht die Datenintegrität. Zudem wird das Abfragen mit SQL vereinfacht.\nZweite Normalform (2NF) Die zweite Normalform (2NF) stellt sicher, dass eine Tabelle keine funktionalen Abhängigkeiten von einem Teil eines Primärschlüssels enthält. Das bedeutet, dass alle nicht-schlüsselbezogenen Attribute von einem vollständigen Primärschlüssel abhängig sein müssen. Dadurch wird verhindert, dass in einer Tabelle Daten wiederholt gespeichert werden, die nicht direkt zur eigentlichen Entität gehören.\nEine Tabelle ist in der 2NF, wenn:\nSie bereits in der 1NF ist (alle Attribute enthalten atomare Werte und es gibt keine Wiederholungen von Gruppen). Alle nicht-schlüsselbezogenen Attribute vollständig vom gesamten Primärschlüssel abhängen und nicht nur von einem Teil davon. Beispiel 1: Bestellungen in einer Tabelle (Nicht in 2NF)\nAngenommen, wir haben eine Tabelle mit Kundendaten, die den Namen und die Telefonnummer enthält. Zusätzlich speichern wir für jeden Kunden die bestellten Produkte und die jeweilige Menge in derselben Tabelle:\nKundennummer Kundenname Telefonnummer Produkt Menge 1 Max 123456789 Schuhe 2 1 Max 123456789 Hemd 1 2 Lisa 987654321 Hose 3 2 Lisa 987654321 Jacke 2 Problem:\nDie Kundennummer ist der Primärschlüssel, aber die Kundenname und Telefonnummer hängen nicht von Produkt oder Menge ab. Sie sind ausschliesslich von der Kundennummer abhängig. Wenn ein Kunde mehrere Produkte bestellt, werden seine Daten mehrfach gespeichert → Redundanz. Änderungen an Kundendaten müssen an mehreren Stellen vorgenommen werden → Anomalien. Lösung: Um die 2NF zu erreichen, müssen wir die Daten in separate Tabellen aufteilen:\nKundentabelle:\nKundennummer Kundenname Telefonnummer 1 Max 123456789 2 Lisa 987654321 Bestellungstabelle:\nBestellnummer Kundennummer Produkt Menge 1 1 Schuhe 2 2 1 Hemd 1 3 2 Hose 3 4 2 Jacke 2 Jetzt sind die Kundendaten in einer separaten Tabelle gespeichert und müssen nicht mehr für jede Bestellung wiederholt werden. Die Bestellungen sind über die Kundennummer mit den Kundendaten verknüpft.\nBeispiel 2: Lieblingsfarben aus der 1NF (Nicht in 2NF)\nIm vorherigen Abschnitt zur 1NF hatten wir eine Tabelle mit Lieblingsfarben:\nKundennummer Kundenname Lieblingsfarbe 1 Max Blau 1 Max Rot 2 Lisa Grün 2 Lisa Gelb 2 Lisa Blau Problem: Kundenname hängt nur von der Kundennummer ab und hat keine direkte Verbindung zu Farben. Wenn ein Kunde mehrere Farben bevorzugt, wird der Name mehrfach gespeichert → Redundanz. Lösung: Wir teilen die Tabelle in Kundendaten und Lieblingsfarben auf:\nKundentabelle:\nKundennummer Kundenname 1 Max 2 Lisa Lieblingsfarben-Tabelle:\nKundenfarbeID Kundennummer Lieblingsfarbe 1 1 Blau 2 1 Rot 3 2 Grün 4 2 Gelb 5 2 Blau Nun entspricht die Datenstruktur der 2NF, da sich die Lieblingsfarben und Kunden in separaten Tabellen befinden und alle Attribute vollständig von ihrem jeweiligen Schlüssel abhängig sind.\nFazit\nDie zweite Normalform (2NF) verbessert die Struktur der Datenbank, indem sie sicherstellt, dass alle nicht-schlüsselbezogenen Attribute vollständig vom gesamten Primärschlüssel abhängen. Dies reduziert Redundanzen, vermeidet Änderungsanomalien und erleichtert die Datenpflege.\nDritte Normalform (3NF) Die dritte Normalform (3NF) baut auf der zweiten Normalform (2NF) auf und stellt eine weitere Anforderung an die Strukturierung der Daten.\nDas Ziel der 3NF ist es sicherzustellen, dass keine funktionalen Abhängigkeiten zwischen Nicht-Schlüsselattributen bestehen. Das bedeutet, dass alle Nicht-Schlüsselattribute ausschliesslich vom Primärschlüssel abhängig sein müssen und nicht von anderen Nicht-Schlüsselattributen. Also: Alle Nicht-Schlüsselattribute hängen nur von dem PK ab und nicht untereinander. Nicht-Schlüsselattribute dürfen keinen Einfluss auf andere Nicht-Schlüsselattribute haben.\nEine Tabelle ist in der 3NF, wenn:\nSie bereits in der 2NF ist. Jedes Nicht-Schlüsselattribut vollständig vom Primärschlüssel abhängt (keine Abhängigkeiten zwischen Nicht-Schlüsselattributen bestehen). Um die 3NF zu erreichen, müssen die Daten weiter aufgeteilt und in separate Tabellen organisiert werden. Jede Tabelle sollte dabei einen spezifischen Informationsaspekt abbilden. Die Tabellen sind über Fremdschlüssel miteinander verknüpft.\nBeispiel 1: Online-Shop (Nicht in 3NF)\nWir haben eine Ausgangstabelle, die alle Informationen eines Online-Shops speichert. Diese ist jedoch noch nicht normalisiert:\nKundenummer Name Telefonnummer ProduktId Produktname Bestellmenge Gesamtpreis 1 Max 123456789 101 Schuhe 2 50.00 1 Max 123456789 102 Hemd 1 30.00 2 Lisa 987654321 103 Hose 4 80.00 2 Lisa 987654321 104 Jacke 3 75.00 Probleme: Produktname und Gesamtpreis sind nicht direkt vom Primärschlüssel abhängig. Der Gesamtpreis kann aus der Bestellmenge und dem Produktpreis berechnet werden, weshalb er nicht direkt gespeichert werden sollte. Produktname hängt von der Produkt-ID ab, nicht von der Bestellnummer → Diese Daten sollten ausgelagert werden. Lösung: Um die 2NF zu erreichen, trennen wir die Daten in drei Tabellen:\nKundentabelle:\nKundenummer Name Telefonnummer 1 Max 123456789 2 Lisa 987654321 Produkttabelle:\nProduktId Produktname Produktpreis 101 Schuhe 25.00 102 Hemd 30.00 103 Hose 20.00 104 Jacke 25.00 Bestellungstabelle (2NF erreicht, aber noch nicht 3NF):\nKundenummer ProduktId Bestellmenge Gesamtpreis 1 101 2 50.00 1 102 1 30.00 2 103 4 80.00 2 104 3 75.00 Nach dieser Aufteilung ist die zweite Normalform erreicht, aber noch nicht die dritte, da der Gesamtpreis von Produktpreis und Bestellmenge abhängt, nicht vom Primärschlüssel.\nUm die 3NF zu erreichen, müssen wir den Gesamtpreis entfernen, da dieser berechnet werden kann:\nBestellungstabelle (Jetzt in 3NF):\nKundenummer ProduktId Bestellmenge 1 101 2 1 102 1 2 103 4 2 104 3 Nun entspricht die Datenbank der dritten Normalform (3NF), da alle Nicht-Schlüsselattribute nur vom Primärschlüssel abhängig sind.\nFazit\nDie dritte Normalform (3NF) stellt sicher, dass alle Nicht-Schlüsselattribute ausschliesslich vom Primärschlüssel abhängig sind und keine funktionalen Abhängigkeiten zwischen Nicht-Schlüsselattributen bestehen. Dadurch werden:\nDatenredundanzen weiter reduziert. Änderungsanomalien vermieden. Datenbankabfragen effizienter. Für den Einstieg reichen die ersten drei Normalformen meist aus. Höhere Normalformen wie die Boyce-Codd-Normalform (BCNF) oder die vierte Normalform (4NF) sind komplexer und werden in speziellen Anwendungsfällen eingesetzt.\nDatenbankdesign In diesem Abschnitt betrachten wir die beiden Begriffe ERM (Entity-Relationship-Modell) und ERD (Entity-Relationship-Diagramm). Es ist wichtig, den Unterschied zwischen den beiden zu verstehen.\nEntity-Relationship-Modell (ERM) Ein ERM ist eine Modellierungstechnik, die verwendet wird, um die Beziehungen zwischen verschiedenen Entitäten in einem System zu beschreiben. Dabei wird das Datenbanksystem in Textform dokumentiert, bevor es visuell dargestellt wird. Ziel ist es, die Datenbank so einfach und klar wie möglich zu beschreiben, um später ein ERD daraus abzuleiten.\nEin ERM besteht aus:\nEntitäten (Tabellen): Die zentralen Objekte des Systems, die Daten speichern. Beziehungen (Relations): Die Verknüpfungen zwischen den Entitäten. Beispiel eines einfachen ERMs: Entitäten:\nEntität-Name Beschreibung Student Jeder Student hat eine eindeutige ID, einen Namen, ein Geburtsdatum und Kontaktdaten. Kurs Jeder Kurs hat eine eindeutige ID, einen Titel, eine Anzahl von Kreditpunkten und einen zugeordneten Dozenten. Beziehungen:\nBeziehungs-Name Beschreibung Einschreibung Diese Beziehung zeigt die Verbindung zwischen Studenten und Kursen an. Jede Einschreibung hat eine eindeutige ID und ist mit einem bestimmten Studenten und einem bestimmten Kurs verknüpft. Entity-Relationship-Diagramm (ERD) Ein ERD ist eine grafische Darstellung eines ERM, die die Beziehungen zwischen Entitäten und deren Attributen visualisiert. Es stellt die Struktur und das Verhalten eines Systems formal dar.\nHauptbestandteile eines ERD: Entitäten (Tabellen), dargestellt als Rechtecke. Attribute, dargestellt als Ovale. Beziehungen, dargestellt als Rauten mit Verbindungslinien. Kardinalitäten, die angeben, wie viele Entitäten miteinander verknüpft sind (z. B. 1:1, 1:n, m:n). Durch ein ERD wird klar definiert, welche Daten in der Datenbank benötigt werden und wie sie strukturiert sind.\nERD-Erstellung mit draw.io Es gibt viele verschiedene Zeichenprogramme zur Erstellung von ERDs. Eine besonders empfehlenswerte Web-Applikation ist draw.io, da:\nKein Download erforderlich ist. Diagramme online gespeichert und geteilt werden können. Es eine intuitive Benutzeroberfläche für ERD-Erstellungen bietet. Das spätere ERD in diesem Kurs wird ebenfalls mit draw.io erstellt.\nEin besonders wichtiger Aspekt beim Erstellen eines ERD sind die Kardinalitäten. Diese zeigen an, wie viele Entitäten miteinander in Beziehung stehen.\nLassen uns diese nun genauer betrachten.\nKardinalität Die Kardinalität in einem Entity-Relationship-Modell (ERM) beschreibt die Beziehung zwischen zwei Entitäten und gibt an, wie viele Instanzen einer Entität mit einer oder mehreren Instanzen einer anderen Entität in Verbindung stehen können.\nEs gibt verschiedene Methoden, um die Kardinalität einer Beziehung darzustellen. In diesem Kurs verwenden wir hauptsächlich die Chen-Notation. Alternativ kann auch die Martin-Notation genutzt werden.\nKardinalitätsarten in der Chen-Notation: Notation Beschreibung 1:1 (1 zu 1) Jede Entität der ersten Entitätsmenge steht mit genau einer Entität der zweiten Entitätsmenge in Beziehung – und umgekehrt. 1:c (1 zu [0 oder 1]) Jede Entität der ersten Entitätsmenge kann mit höchstens einer Entität der zweiten Entitätsmenge in Beziehung stehen. Jede Entität der zweiten Entitätsmenge steht jedoch mit genau einer Entität der ersten Entitätsmenge in Beziehung. 1:m (1 zu [mindestens 1]) Jede Entität der ersten Entitätsmenge steht mit mindestens einer Entität der zweiten Entitätsmenge in Beziehung. Jede Entität der zweiten Entitätsmenge steht mit genau einer Entität der ersten Entitätsmenge in Beziehung. 1:mc (1 zu [beliebig vielen]) Jede Entität der ersten Entitätsmenge kann mit beliebig vielen Entitäten der zweiten Entitätsmenge in Beziehung stehen. Jede Entität der zweiten Entitätsmenge steht jedoch mit genau einer Entität der ersten Entitätsmenge in Beziehung. c:c ([0 oder 1] zu [0 oder 1]) Jede Entität der ersten Entitätsmenge kann mit höchstens einer Entität der zweiten Entitätsmenge in Beziehung stehen – und umgekehrt. c:m ([0 oder 1] zu [mindestens 1]) Jede Entität der ersten Entitätsmenge steht mit mindestens einer Entität der zweiten Entitätsmenge in Beziehung. Jede Entität der zweiten Entitätsmenge kann jedoch mit höchstens einer Entität der ersten Entitätsmenge in Beziehung stehen. c:mc ([0 oder 1] zu [beliebig vielen]) Jede Entität der ersten Entitätsmenge kann mit beliebig vielen Entitäten der zweiten Entitätsmenge in Beziehung stehen. Jede Entität der zweiten Entitätsmenge kann jedoch mit höchstens einer Entität der ersten Entitätsmenge in Beziehung stehen. m:m ([mindestens 1] zu [mindestens 1]) Jede Entität der ersten Entitätsmenge steht mit mindestens einer Entität der zweiten Entitätsmenge in Beziehung – und umgekehrt. m:mc ([mindestens 1] zu [beliebig vielen]) Jede Entität der ersten Entitätsmenge kann mit beliebig vielen Entitäten der zweiten Entitätsmenge in Beziehung stehen. Jede Entität der zweiten Entitätsmenge steht mit mindestens einer Entität der ersten Entitätsmenge in Beziehung. mc:mc ([beliebig viele] zu [beliebig vielen]) Jede Entität der ersten Entitätsmenge kann mit beliebig vielen Entitäten der zweiten Entitätsmenge in Beziehung stehen – und umgekehrt. Beispiel: Kardinalitäten in einem ERD Ein klassisches Beispiel für Kardinalitäten ist eine Buchdatenbank, die Bücher und Autoren verwaltet.\nHier sind einige typische Beziehungen:\nEin Buch kann von mehreren Autoren geschrieben werden. (m:m-Beziehung) Ein Autor kann mehrere Bücher geschrieben haben. (m:m-Beziehung) Für die Kardinalitäten in diesem Beispiel gäbe es auch weitere Möglichkeiten.\nWas ist, wenn ein Autor kein Buch geschrieben hat? Die Beziehung müsste m:mc sein, aber kann jemand ein Autor sein, wenn er kein Buch hat?\nDas hängt ganz von den Anforderungen ab, vielleicht möchte man bestimmte Autoren erfassen, aber ihre Bücher nicht.\nBeim Buch gilt natürlich das genau gleich. Was ist, wenn wir ein Buch haben, für das der Autor unbekannt ist oder nicht in der DB? Du als Softwareentwickler musst entscheiden, ob diese Fälle in deiner Applikation abgedeckt werden.\nWichtiger Hinweis zu m:n-Beziehungen: Viele-zu-Viele-Beziehungen (m:m, mc:m, …) benötigen normalerweise eine Zwischentabelle, da ansonsten keine eindeutige Verbindung zwischen den Tabellen hergestellt werden kann. Diese Zwischentabelle enthält die Fremdschlüssel der beiden verknüpften Tabellen und kann zusätzlich eigene Attribute wie das Erstellungsdatum der Beziehung enthalten.\nBeispiel einer Zwischentabelle für die Buchdatenbank: BuchID AutorID 1 101 1 102 2 101 3 103 Diese zusätzliche Tabelle ermöglicht eine eindeutige Zuordnung zwischen Büchern und Autoren.\nFazit Die Kardinalität ist ein wichtiger Bestandteil des Entity-Relationship-Modells (ERM) und beschreibt, wie Entitäten miteinander verknüpft sind. Das Verständnis der Kardinalitäten hilft, eine optimale Datenbankstruktur zu entwickeln, die Redundanzen vermeidet und Datenkonsistenz sicherstellt.\nJetzt bist du dran. Löse bitte die Aufgaben zu Datenbanken in den Labs.\n","categories":"","description":"","excerpt":"Ziele Du weisst was Normalisierung ist und wieso sie wichtig ist. Du …","ref":"/docs/05_database/04_datenbank-design/","tags":"","title":"Datenbank Design"},{"body":"Ziele Du weisst was Normalisierung ist und wieso sie wichtig ist. Du kannst die ersten drei Normalformen in eigenen Worten erklären. Du kennst den Unterschied zwischen den Begriffen ERM und ERD. Du kennst die verschiedenen Beziehungstypen im Bereich der Kardinalität. Normalisierung Die Normalisierung in SQL ist ein Prozess, bei dem Datenbanktabellen in bestimmte Normalformen überführt werden, um die Datenintegrität und -konsistenz zu gewährleisten sowie Redundanzen zu minimieren. Das Ziel ist es, Daten effizient, konsistent und strukturiert zu speichern, zu verwalten und abzufragen.\nWas bedeutet das genau? Wir wollen zum Beispiel doppelte (redundante) Daten in der Datenbank vermeiden. Das spart einerseits Speicherplatz, stellt aber andererseits auch sicher, das die Integrität gewährleistet ist. Was passiert, wenn ich den gleichen User zweimal in einer Datenbank habe, und dann nur einen Eintrag davon bearbeite? Dadurch kann es zu Anomalien (Fehler, unerwartetes Verhalten) kommen, die man im Design verhindern kann.\nEin Datenbankschema kann in unterschiedlichem Mass gegen Anomalien wie Inkonsistenzen oder Redundanzen geschützt werden. Diese Abstufungen werden als Normalformen bezeichnet. In den folgenden Abschnitten wirst du die erste, zweite und dritte Normalform kennenlernen.\nErste Normalform (1NF) Angenommen, wir haben eine Tabelle mit Kundendaten, die den Namen, die Adresse und die Telefonnummer enthält:\nKundennummer Kundenname Adresse Telefonnummer 1 Max Hauptstr. 1, 123 123456789 2 Lisa Nebenstr. 5, 987 987654321 Du bekommst den Auftrag, alle Kunde von einer bestimmten Strasse oder einer bestimmten Postleihzahl aufzulisten. Jetzt musst du immer die Adresse auslesen und splitten. Das geht einfacher.\nDie erste Normalform (1NF) ist eine grundlegende Regel in der Datenbankentwicklung. Sie stellt sicher, dass eine Tabelle nur atomare (nicht weiter teilbare) Werte enthält und keine wiederholten Gruppen von Attributen aufweist. Das Ziel der 1NF ist es, Daten in ihre einfachsten, nicht weiter unterteilbaren Bestandteile zu zerlegen.\nIn der ersten Normalform muss jede Zelle einer Tabelle genau einen einzigen Wert enthalten. Mehrwertige Attribute oder Attribute mit wiederholten Gruppen von Werten sind nicht erlaubt. Falls mehrere Werte zu einem Attribut gehören, müssen diese in separate Zeilen oder Tabellen ausgelagert werden.\nBeispiel 1: Adressaufteilung\nHier nochmal die gleiche Tabelle.\nKundennummer Kundenname Adresse Telefonnummer 1 Max Hauptstr. 1, 123 123456789 2 Lisa Nebenstr. 5, 987 987654321 Diese Tabelle ist nicht in der ersten Normalform, weil die Adresse nicht in ihre einzelnen Bestandteile zerlegt ist.\nNach der Normalisierung in die 1NF sieht die Tabelle so aus:\nKundennummer Kundenname Strasse Hausnummer PLZ Ort Telefonnummer 1 Max Hauptstr. 1 123 Musterort 123456789 2 Lisa Nebenstr. 5 987 Beispielort 987654321 Beispiel 2: Liste in einer Spalte\nAngenommen, wir speichern die Lieblingsfarben von Kunden in einer Tabelle:\nKundennummer Kundenname Lieblingsfarben 1 Max Blau, Rot 2 Lisa Grün, Gelb, Blau Du kennst ja Listen aus Java: Eine List\u003cString\u003e kann mehrere Werte in einer einzigen Variable speichern. Doch in relationalen Datenbanken sollten Werte nicht als Listen innerhalb einer Spalte gespeichert werden. Was ist, wenn du gerne alle Kunden auflisten möchtest, welche die Lieblingsfarbe Rot haben? Nun muss du wieder alle Lieblingsfarben auslesen und splitten, bevor du eine Analyse machen kannst.\nStattdessen sollten sie auf mehrere Zeilen oder Tabellen aufgeteilt werden. Die Spalte Lieblingsfarben enthält mehrere Werte in einer einzigen Zelle. Dies verstösst gegen die 1NF, da die Werte nicht atomar sind.\nLösung: Wir normalisieren die Tabelle, indem wir jede Lieblingsfarbe in eine eigene Zeile auslagern:\nKundennummer Kundenname Lieblingsfarbe 1 Max Blau 1 Max Rot 2 Lisa Grün 2 Lisa Gelb 2 Lisa Blau Nun entspricht die Tabelle der ersten Normalform (1NF), da jede Zelle genau einen einzigen Wert enthält. Jetzt kannst du mit einem simplen SELECT und WHERE alle Benutzer auflisten, welche eine bestimmte Lieblingsfarbe haben.\nAber: Diese Tabelle entspricht noch nicht der zweiten Normalform (2NF). Dazu gleich mehr.\nFazit\nDie erste Normalform (1NF) sorgt dafür, dass alle Daten atomar sind, also nicht weiter unterteilt werden können, und dass keine wiederholten Gruppen von Attributen existieren. Dies verbessert die Datenstruktur, minimiert Redundanzen und erhöht die Datenintegrität. Zudem wird das Abfragen mit SQL vereinfacht.\nZweite Normalform (2NF) Die zweite Normalform (2NF) stellt sicher, dass eine Tabelle keine funktionalen Abhängigkeiten von einem Teil eines Primärschlüssels enthält. Das bedeutet, dass alle nicht-schlüsselbezogenen Attribute von einem vollständigen Primärschlüssel abhängig sein müssen. Dadurch wird verhindert, dass in einer Tabelle Daten wiederholt gespeichert werden, die nicht direkt zur eigentlichen Entität gehören.\nEine Tabelle ist in der 2NF, wenn:\nSie bereits in der 1NF ist (alle Attribute enthalten atomare Werte und es gibt keine Wiederholungen von Gruppen). Alle nicht-schlüsselbezogenen Attribute vollständig vom gesamten Primärschlüssel abhängen und nicht nur von einem Teil davon. Beispiel 1: Bestellungen in einer Tabelle (Nicht in 2NF)\nAngenommen, wir haben eine Tabelle mit Kundendaten, die den Namen und die Telefonnummer enthält. Zusätzlich speichern wir für jeden Kunden die bestellten Produkte und die jeweilige Menge in derselben Tabelle:\nKundennummer Kundenname Telefonnummer Produkt Menge 1 Max 123456789 Schuhe 2 1 Max 123456789 Hemd 1 2 Lisa 987654321 Hose 3 2 Lisa 987654321 Jacke 2 Problem:\nDie Kundennummer ist der Primärschlüssel, aber die Kundenname und Telefonnummer hängen nicht von Produkt oder Menge ab. Sie sind ausschliesslich von der Kundennummer abhängig. Wenn ein Kunde mehrere Produkte bestellt, werden seine Daten mehrfach gespeichert → Redundanz. Änderungen an Kundendaten müssen an mehreren Stellen vorgenommen werden → Anomalien. Lösung: Um die 2NF zu erreichen, müssen wir die Daten in separate Tabellen aufteilen:\nKundentabelle:\nKundennummer Kundenname Telefonnummer 1 Max 123456789 2 Lisa 987654321 Bestellungstabelle:\nBestellnummer Kundennummer Produkt Menge 1 1 Schuhe 2 2 1 Hemd 1 3 2 Hose 3 4 2 Jacke 2 Jetzt sind die Kundendaten in einer separaten Tabelle gespeichert und müssen nicht mehr für jede Bestellung wiederholt werden. Die Bestellungen sind über die Kundennummer mit den Kundendaten verknüpft.\nBeispiel 2: Lieblingsfarben aus der 1NF (Nicht in 2NF)\nIm vorherigen Abschnitt zur 1NF hatten wir eine Tabelle mit Lieblingsfarben:\nKundennummer Kundenname Lieblingsfarbe 1 Max Blau 1 Max Rot 2 Lisa Grün 2 Lisa Gelb 2 Lisa Blau Problem: Kundenname hängt nur von der Kundennummer ab und hat keine direkte Verbindung zu Farben. Wenn ein Kunde mehrere Farben bevorzugt, wird der Name mehrfach gespeichert → Redundanz. Lösung: Wir teilen die Tabelle in Kundendaten und Lieblingsfarben auf:\nKundentabelle:\nKundennummer Kundenname 1 Max 2 Lisa Lieblingsfarben-Tabelle:\nKundenfarbeID Kundennummer Lieblingsfarbe 1 1 Blau 2 1 Rot 3 2 Grün 4 2 Gelb 5 2 Blau Nun entspricht die Datenstruktur der 2NF, da sich die Lieblingsfarben und Kunden in separaten Tabellen befinden und alle Attribute vollständig von ihrem jeweiligen Schlüssel abhängig sind.\nFazit\nDie zweite Normalform (2NF) verbessert die Struktur der Datenbank, indem sie sicherstellt, dass alle nicht-schlüsselbezogenen Attribute vollständig vom gesamten Primärschlüssel abhängen. Dies reduziert Redundanzen, vermeidet Änderungsanomalien und erleichtert die Datenpflege.\nDritte Normalform (3NF) Die dritte Normalform (3NF) baut auf der zweiten Normalform (2NF) auf und stellt eine weitere Anforderung an die Strukturierung der Daten.\nDas Ziel der 3NF ist es sicherzustellen, dass keine funktionalen Abhängigkeiten zwischen Nicht-Schlüsselattributen bestehen. Das bedeutet, dass alle Nicht-Schlüsselattribute ausschliesslich vom Primärschlüssel abhängig sein müssen und nicht von anderen Nicht-Schlüsselattributen. Also: Alle Nicht-Schlüsselattribute hängen nur von dem PK ab und nicht untereinander. Nicht-Schlüsselattribute dürfen keinen Einfluss auf andere Nicht-Schlüsselattribute haben.\nEine Tabelle ist in der 3NF, wenn:\nSie bereits in der 2NF ist. Jedes Nicht-Schlüsselattribut vollständig vom Primärschlüssel abhängt (keine Abhängigkeiten zwischen Nicht-Schlüsselattributen bestehen). Um die 3NF zu erreichen, müssen die Daten weiter aufgeteilt und in separate Tabellen organisiert werden. Jede Tabelle sollte dabei einen spezifischen Informationsaspekt abbilden. Die Tabellen sind über Fremdschlüssel miteinander verknüpft.\nBeispiel 1: Online-Shop (Nicht in 3NF)\nWir haben eine Ausgangstabelle, die alle Informationen eines Online-Shops speichert. Diese ist jedoch noch nicht normalisiert:\nKundenummer Name Telefonnummer ProduktId Produktname Bestellmenge Gesamtpreis 1 Max 123456789 101 Schuhe 2 50.00 1 Max 123456789 102 Hemd 1 30.00 2 Lisa 987654321 103 Hose 4 80.00 2 Lisa 987654321 104 Jacke 3 75.00 Probleme: Produktname und Gesamtpreis sind nicht direkt vom Primärschlüssel abhängig. Der Gesamtpreis kann aus der Bestellmenge und dem Produktpreis berechnet werden, weshalb er nicht direkt gespeichert werden sollte. Produktname hängt von der Produkt-ID ab, nicht von der Bestellnummer → Diese Daten sollten ausgelagert werden. Lösung: Um die 2NF zu erreichen, trennen wir die Daten in drei Tabellen:\nKundentabelle:\nKundenummer Name Telefonnummer 1 Max 123456789 2 Lisa 987654321 Produkttabelle:\nProduktId Produktname Produktpreis 101 Schuhe 25.00 102 Hemd 30.00 103 Hose 20.00 104 Jacke 25.00 Bestellungstabelle (2NF erreicht, aber noch nicht 3NF):\nKundenummer ProduktId Bestellmenge Gesamtpreis 1 101 2 50.00 1 102 1 30.00 2 103 4 80.00 2 104 3 75.00 Nach dieser Aufteilung ist die zweite Normalform erreicht, aber noch nicht die dritte, da der Gesamtpreis von Produktpreis und Bestellmenge abhängt, nicht vom Primärschlüssel.\nUm die 3NF zu erreichen, müssen wir den Gesamtpreis entfernen, da dieser berechnet werden kann:\nBestellungstabelle (Jetzt in 3NF):\nKundenummer ProduktId Bestellmenge 1 101 2 1 102 1 2 103 4 2 104 3 Nun entspricht die Datenbank der dritten Normalform (3NF), da alle Nicht-Schlüsselattribute nur vom Primärschlüssel abhängig sind.\nFazit\nDie dritte Normalform (3NF) stellt sicher, dass alle Nicht-Schlüsselattribute ausschliesslich vom Primärschlüssel abhängig sind und keine funktionalen Abhängigkeiten zwischen Nicht-Schlüsselattributen bestehen. Dadurch werden:\nDatenredundanzen weiter reduziert. Änderungsanomalien vermieden. Datenbankabfragen effizienter. Für den Einstieg reichen die ersten drei Normalformen meist aus. Höhere Normalformen wie die Boyce-Codd-Normalform (BCNF) oder die vierte Normalform (4NF) sind komplexer und werden in speziellen Anwendungsfällen eingesetzt.\nDatenbankdesign In diesem Abschnitt betrachten wir die beiden Begriffe ERM (Entity-Relationship-Modell) und ERD (Entity-Relationship-Diagramm). Es ist wichtig, den Unterschied zwischen den beiden zu verstehen.\nEntity-Relationship-Modell (ERM) Ein ERM ist eine Modellierungstechnik, die verwendet wird, um die Beziehungen zwischen verschiedenen Entitäten in einem System zu beschreiben. Dabei wird das Datenbanksystem in Textform dokumentiert, bevor es visuell dargestellt wird. Ziel ist es, die Datenbank so einfach und klar wie möglich zu beschreiben, um später ein ERD daraus abzuleiten.\nEin ERM besteht aus:\nEntitäten (Tabellen): Die zentralen Objekte des Systems, die Daten speichern. Beziehungen (Relations): Die Verknüpfungen zwischen den Entitäten. Beispiel eines einfachen ERMs: Entitäten:\nEntität-Name Beschreibung Student Jeder Student hat eine eindeutige ID, einen Namen, ein Geburtsdatum und Kontaktdaten. Kurs Jeder Kurs hat eine eindeutige ID, einen Titel, eine Anzahl von Kreditpunkten und einen zugeordneten Dozenten. Beziehungen:\nBeziehungs-Name Beschreibung Einschreibung Diese Beziehung zeigt die Verbindung zwischen Studenten und Kursen an. Jede Einschreibung hat eine eindeutige ID und ist mit einem bestimmten Studenten und einem bestimmten Kurs verknüpft. Entity-Relationship-Diagramm (ERD) Ein ERD ist eine grafische Darstellung eines ERM, die die Beziehungen zwischen Entitäten und deren Attributen visualisiert. Es stellt die Struktur und das Verhalten eines Systems formal dar.\nHauptbestandteile eines ERD: Entitäten (Tabellen), dargestellt als Rechtecke. Attribute, dargestellt als Ovale. Beziehungen, dargestellt als Rauten mit Verbindungslinien. Kardinalitäten, die angeben, wie viele Entitäten miteinander verknüpft sind (z. B. 1:1, 1:n, m:n). Durch ein ERD wird klar definiert, welche Daten in der Datenbank benötigt werden und wie sie strukturiert sind.\nERD-Erstellung mit draw.io Es gibt viele verschiedene Zeichenprogramme zur Erstellung von ERDs. Eine besonders empfehlenswerte Web-Applikation ist draw.io, da:\nKein Download erforderlich ist. Diagramme online gespeichert und geteilt werden können. Es eine intuitive Benutzeroberfläche für ERD-Erstellungen bietet. Das spätere ERD in diesem Kurs wird ebenfalls mit draw.io erstellt.\nEin besonders wichtiger Aspekt beim Erstellen eines ERD sind die Kardinalitäten. Diese zeigen an, wie viele Entitäten miteinander in Beziehung stehen.\nLassen uns diese nun genauer betrachten.\nKardinalität Die Kardinalität in einem Entity-Relationship-Modell (ERM) beschreibt die Beziehung zwischen zwei Entitäten und gibt an, wie viele Instanzen einer Entität mit einer oder mehreren Instanzen einer anderen Entität in Verbindung stehen können.\nEs gibt verschiedene Methoden, um die Kardinalität einer Beziehung darzustellen. In diesem Kurs verwenden wir hauptsächlich die Chen-Notation. Alternativ kann auch die Martin-Notation genutzt werden.\nKardinalitätsarten in der Chen-Notation: Notation Beschreibung 1:1 (1 zu 1) Jede Entität der ersten Entitätsmenge steht mit genau einer Entität der zweiten Entitätsmenge in Beziehung – und umgekehrt. 1:c (1 zu [0 oder 1]) Jede Entität der ersten Entitätsmenge kann mit höchstens einer Entität der zweiten Entitätsmenge in Beziehung stehen. Jede Entität der zweiten Entitätsmenge steht jedoch mit genau einer Entität der ersten Entitätsmenge in Beziehung. 1:m (1 zu [mindestens 1]) Jede Entität der ersten Entitätsmenge steht mit mindestens einer Entität der zweiten Entitätsmenge in Beziehung. Jede Entität der zweiten Entitätsmenge steht mit genau einer Entität der ersten Entitätsmenge in Beziehung. 1:mc (1 zu [beliebig vielen]) Jede Entität der ersten Entitätsmenge kann mit beliebig vielen Entitäten der zweiten Entitätsmenge in Beziehung stehen. Jede Entität der zweiten Entitätsmenge steht jedoch mit genau einer Entität der ersten Entitätsmenge in Beziehung. c:c ([0 oder 1] zu [0 oder 1]) Jede Entität der ersten Entitätsmenge kann mit höchstens einer Entität der zweiten Entitätsmenge in Beziehung stehen – und umgekehrt. c:m ([0 oder 1] zu [mindestens 1]) Jede Entität der ersten Entitätsmenge steht mit mindestens einer Entität der zweiten Entitätsmenge in Beziehung. Jede Entität der zweiten Entitätsmenge kann jedoch mit höchstens einer Entität der ersten Entitätsmenge in Beziehung stehen. c:mc ([0 oder 1] zu [beliebig vielen]) Jede Entität der ersten Entitätsmenge kann mit beliebig vielen Entitäten der zweiten Entitätsmenge in Beziehung stehen. Jede Entität der zweiten Entitätsmenge kann jedoch mit höchstens einer Entität der ersten Entitätsmenge in Beziehung stehen. m:m ([mindestens 1] zu [mindestens 1]) Jede Entität der ersten Entitätsmenge steht mit mindestens einer Entität der zweiten Entitätsmenge in Beziehung – und umgekehrt. m:mc ([mindestens 1] zu [beliebig vielen]) Jede Entität der ersten Entitätsmenge kann mit beliebig vielen Entitäten der zweiten Entitätsmenge in Beziehung stehen. Jede Entität der zweiten Entitätsmenge steht mit mindestens einer Entität der ersten Entitätsmenge in Beziehung. mc:mc ([beliebig viele] zu [beliebig vielen]) Jede Entität der ersten Entitätsmenge kann mit beliebig vielen Entitäten der zweiten Entitätsmenge in Beziehung stehen – und umgekehrt. Beispiel: Kardinalitäten in einem ERD Ein klassisches Beispiel für Kardinalitäten ist eine Buchdatenbank, die Bücher und Autoren verwaltet.\nHier sind einige typische Beziehungen:\nEin Buch kann von mehreren Autoren geschrieben werden. (m:m-Beziehung) Ein Autor kann mehrere Bücher geschrieben haben. (m:m-Beziehung) Für die Kardinalitäten in diesem Beispiel gäbe es auch weitere Möglichkeiten.\nWas ist, wenn ein Autor kein Buch geschrieben hat? Die Beziehung müsste m:mc sein, aber kann jemand ein Autor sein, wenn er kein Buch hat?\nDas hängt ganz von den Anforderungen ab, vielleicht möchte man bestimmte Autoren erfassen, aber ihre Bücher nicht.\nBeim Buch gilt natürlich das genau gleich. Was ist, wenn wir ein Buch haben, für das der Autor unbekannt ist oder nicht in der DB? Du als Softwareentwickler musst entscheiden, ob diese Fälle in deiner Applikation abgedeckt werden.\nWichtiger Hinweis zu m:n-Beziehungen: Viele-zu-Viele-Beziehungen (m:m, mc:m, …) benötigen normalerweise eine Zwischentabelle, da ansonsten keine eindeutige Verbindung zwischen den Tabellen hergestellt werden kann. Diese Zwischentabelle enthält die Fremdschlüssel der beiden verknüpften Tabellen und kann zusätzlich eigene Attribute wie das Erstellungsdatum der Beziehung enthalten.\nBeispiel einer Zwischentabelle für die Buchdatenbank: BuchID AutorID 1 101 1 102 2 101 3 103 Diese zusätzliche Tabelle ermöglicht eine eindeutige Zuordnung zwischen Büchern und Autoren.\nFazit Die Kardinalität ist ein wichtiger Bestandteil des Entity-Relationship-Modells (ERM) und beschreibt, wie Entitäten miteinander verknüpft sind. Das Verständnis der Kardinalitäten hilft, eine optimale Datenbankstruktur zu entwickeln, die Redundanzen vermeidet und Datenkonsistenz sicherstellt.\nJetzt bist du dran. Löse bitte die Aufgaben zu Datenbanken in den Labs.\n","categories":"","description":"","excerpt":"Ziele Du weisst was Normalisierung ist und wieso sie wichtig ist. Du …","ref":"/de/docs/05_database/04_datenbank-design/","tags":"","title":"Datenbank Design"},{"body":"Design-Pattern Design-Patterns sind wiederverwendbare Vorlagen für die Anwendungsentwicklung und sind nicht spezifisch für eine Programmiersprache. Es gibt verschiedene Arten, z. B. Kreationsmuster, Strukturmuster und Verhaltensmuster, die auch in Spring genutzt werden.\nInversion of Control (IoC) Inversion of Control (IoC) ist ein Prinzip, das vereinfacht gesagt den Kontroll-Fluss umkehrt. Das Ziel dabei ist es eine lose Kopplung zu erreichen, wodurch der Code eine bessere Testbarkeit, Wartbarkeit und Erweiterbarkeit erreicht.\nIoC wird in Spring durch “Dependency Injection” geregelt, was im nächsten Kapitel vorgestellt wird. Dabei werden Abhängigkeiten wie Variablen von einer anderen Klasse durch Spring automatisch erstellt und “injiziert” (eingefügt). Dadurch erspart man sich die Mühe, die Objekte selbst zu erstellen sowie auch wieder aufzuräumen, da diese automatisch aufgeräumt werden. Zudem werden Zuständigkeiten dadurch getrennt. Spring nutzt dieses Prinzip.\nDependency Injection (DI) DI bezeichnet die Weitergabe einer Abhängigkeit an ein Objekt. Spring verwendet einen Inversion-of-Control-Container, um zu bestimmen, wie und wo die Injektion erfolgt. Es gibt verschiedene Orte im Code, wo DI eingesetzt werden kann. Es gibt die Konstruktor-, Setter- und Feld-basierte Injection.\nKonstruktor Injection Bei einer Konstruktor-Injection fungiert jedes Argument als eine Abhängigkeit.\nEin Beispiel sieht so aus:\n1 2 3 4 5 6 7 8 9 10 11 12 @Component public class Store { private final ProductCatalog catalog; private final PricingService pricing; public Store(ProductCatalog catalog, PricingService pricing) { this.catalog = catalog; this.pricing = pricing; } } In diesem Beispiel werden die Beans catalog und pricing injektiert. Spring sucht sich die passenden Beans selbst heraus, wenn diese zuvor als solche gekennzeichnet wurden, siehe hier.\nFelder Injection Bei der Felder Injection werden die Abhängigkeiten direkt in die Felder Injected. Hier ein Beispiel:\n1 2 3 4 public class Store { @Autowired private Item item; } Ein Nachteil der Field-Injection ist, dass es im Gegensatz zur Konstruktor-Injection nicht möglich ist, alle Instanzvariablen mit final zu deklarieren. Mehr Informationen zu der @Autowired-Annotation findest du auf dieser Seite.\nSingleton Das Singleton Design Pattern stellt sicher, dass von einer Klasse nur eine Instanz existiert. Im Kontext von Spring können Singleton-Beans erstellt werden, aber es ist wichtig zu beachten, das dies nur innerhalb des Spring-Containers gilt und nicht systemweit.\nBeans Ein Bean im Spring Framework ist ein Objekt, das vom Spring IoC (Inversion of Control) Container verwaltet wird. Der IoC Container ist verantwortlich dafür, die Beans zu instanziieren, ihre Abhängigkeiten zu verwalten und sie bei Bedarf bereitzustellen. Beans sind die grundlegenden Bausteine einer Spring-Anwendung und repräsentieren in der Regel Dienste, Komponenten oder andere zentrale Teile der Anwendung.\nEinfach ausgedrückt, wenn du eine Klasse hast, die du von Spring verwalten lassen möchtest, deklarierst du sie als Bean. Der Spring Container kümmert sich dann um die Erstellung und Verwaltung dieses Objekts, sodass du dich nicht um die Details der Instanziierung oder der Verwaltung von Abhängigkeiten kümmern musst. Dies erleichtert die Entwicklung und Wartung von Anwendungen, da Spring viele dieser Aufgaben für dich übernimmt.\nErstellung von Beans Beans können auf verschiedene Weisen erstellt werden:\nXML-Konfiguration: Historisch gesehen wurden Beans oft in XML-Dateien definiert. Hier wird beschrieben, wie der Container diese Instanzen erstellt und verwaltet.\n1 2 3 \u003cbean id=\"exampleBean\" class=\"com.example.ExampleClass\"\u003e \u003cproperty name=\"someProperty\" value=\"Wert\"/\u003e \u003c/bean\u003e Java-Konfiguration: Mit Annotationen und Java-Klassen kann die Konfiguration von Beans lesbarer und flexibler gestaltet werden.\n1 2 3 4 5 6 7 @Configuration public class AppConfig { @Bean public ExampleClass exampleBean() { return new ExampleClass(); } } Verwendung von Beans Beans werden normalerweise über Injektionen verwendet, um Abhängigkeiten zwischen verschiedenen Komponenten einer Anwendung zu verwalten. Dies geschieht via Dependency Injection (hier wieder Konstruktor Injection):\n1 2 3 4 5 6 7 8 9 10 @Component public class ExampleService { private final ExampleRepository repository; public ExampleService(ExampleRepository repository) { this.repository = repository; } // ... } Hier wird ExampleRepository als Abhängigkeit von ExampleService injiziert. Die @Component-Annotation wird für dieses Beispiel verwendet, damit die Abhängigkeiten via Dependency Injection eingefügt werden.\nBeans sind flexibel, wiederverwendbar und ermöglichen die Modularität von Anwendungen.\nIn der folgenden offiziellen Dokumentation zu der @Bean-Annotation findest du weitere Beispiele, wie Beans erzeugt werden:\nUsing the Bean Annotation Und wie sie verwendet werden können:\nDependency Injection Scope Der Scope eines Beans besagt, wann und wie ein Bean erstellt wird. Zudem sagt der Scope auch, wie lange ein Bean “lebt”.\nHier eine Liste der Scopes:\nScope Beschreibung singleton (Standard) Singleton besagt, dass es immer nur eine Instanz eines Beans gibt, welche dann geteilt wird. Es wird daher nur eine Bean-Instanz in jedem IoC-Container. Mehr hier. prototype Erstellt bei jeder Abhängigkeit eine neue Bean Instanz. request Erstellt für jeden HTTP Request eine Bean Instanz. session Erstellt für jede HTTP Session eine Bean Instanz. application Erstellt für jeden ServletContext eine Bean Instanz. websocket Erstellt für jeden WebSocket eine Bean Instanz. Die beiden wichtigsten Scopes sind singleton und prototype.\nDer Scope wird durch die @Scope Annotation festgelegt.\nHier ein Beispiel:\n1 2 3 4 5 6 7 8 @Configuration public class MyConfiguration { @Bean @Scope(\"prototype\") public Encryptor encryptor() { // ... } } ","categories":"","description":"Modul #J8 - Spring Framework - Wie sieht das Design-Pattern aus?\n","excerpt":"Modul #J8 - Spring Framework - Wie sieht das Design-Pattern aus?\n","ref":"/docs/02_java/12_spring-framework/04_design-pattern/","tags":"","title":"Design-Pattern"},{"body":"Design-Pattern Design-Patterns sind wiederverwendbare Vorlagen für die Anwendungsentwicklung und sind nicht spezifisch für eine Programmiersprache. Es gibt verschiedene Arten, z. B. Kreationsmuster, Strukturmuster und Verhaltensmuster, die auch in Spring genutzt werden.\nInversion of Control (IoC) Inversion of Control (IoC) ist ein Prinzip, das vereinfacht gesagt den Kontroll-Fluss umkehrt. Das Ziel dabei ist es eine lose Kopplung zu erreichen, wodurch der Code eine bessere Testbarkeit, Wartbarkeit und Erweiterbarkeit erreicht.\nIoC wird in Spring durch “Dependency Injection” geregelt, was im nächsten Kapitel vorgestellt wird. Dabei werden Abhängigkeiten wie Variablen von einer anderen Klasse durch Spring automatisch erstellt und “injiziert” (eingefügt). Dadurch erspart man sich die Mühe, die Objekte selbst zu erstellen sowie auch wieder aufzuräumen, da diese automatisch aufgeräumt werden. Zudem werden Zuständigkeiten dadurch getrennt. Spring nutzt dieses Prinzip.\nDependency Injection (DI) DI bezeichnet die Weitergabe einer Abhängigkeit an ein Objekt. Spring verwendet einen Inversion-of-Control-Container, um zu bestimmen, wie und wo die Injektion erfolgt. Es gibt verschiedene Orte im Code, wo DI eingesetzt werden kann. Es gibt die Konstruktor-, Setter- und Feld-basierte Injection.\nKonstruktor Injection Bei einer Konstruktor-Injection fungiert jedes Argument als eine Abhängigkeit.\nEin Beispiel sieht so aus:\n1 2 3 4 5 6 7 8 9 10 11 12 @Component public class Store { private final ProductCatalog catalog; private final PricingService pricing; public Store(ProductCatalog catalog, PricingService pricing) { this.catalog = catalog; this.pricing = pricing; } } In diesem Beispiel werden die Beans catalog und pricing injektiert. Spring sucht sich die passenden Beans selbst heraus, wenn diese zuvor als solche gekennzeichnet wurden, siehe hier.\nFelder Injection Bei der Felder Injection werden die Abhängigkeiten direkt in die Felder Injected. Hier ein Beispiel:\n1 2 3 4 public class Store { @Autowired private Item item; } Ein Nachteil der Field-Injection ist, dass es im Gegensatz zur Konstruktor-Injection nicht möglich ist, alle Instanzvariablen mit final zu deklarieren. Mehr Informationen zu der @Autowired-Annotation findest du auf dieser Seite.\nSingleton Das Singleton Design Pattern stellt sicher, dass von einer Klasse nur eine Instanz existiert. Im Kontext von Spring können Singleton-Beans erstellt werden, aber es ist wichtig zu beachten, das dies nur innerhalb des Spring-Containers gilt und nicht systemweit.\nBeans Ein Bean im Spring Framework ist ein Objekt, das vom Spring IoC (Inversion of Control) Container verwaltet wird. Der IoC Container ist verantwortlich dafür, die Beans zu instanziieren, ihre Abhängigkeiten zu verwalten und sie bei Bedarf bereitzustellen. Beans sind die grundlegenden Bausteine einer Spring-Anwendung und repräsentieren in der Regel Dienste, Komponenten oder andere zentrale Teile der Anwendung.\nEinfach ausgedrückt, wenn du eine Klasse hast, die du von Spring verwalten lassen möchtest, deklarierst du sie als Bean. Der Spring Container kümmert sich dann um die Erstellung und Verwaltung dieses Objekts, sodass du dich nicht um die Details der Instanziierung oder der Verwaltung von Abhängigkeiten kümmern musst. Dies erleichtert die Entwicklung und Wartung von Anwendungen, da Spring viele dieser Aufgaben für dich übernimmt.\nErstellung von Beans Beans können auf verschiedene Weisen erstellt werden:\nXML-Konfiguration: Historisch gesehen wurden Beans oft in XML-Dateien definiert. Hier wird beschrieben, wie der Container diese Instanzen erstellt und verwaltet.\n1 2 3 \u003cbean id=\"exampleBean\" class=\"com.example.ExampleClass\"\u003e \u003cproperty name=\"someProperty\" value=\"Wert\"/\u003e \u003c/bean\u003e Java-Konfiguration: Mit Annotationen und Java-Klassen kann die Konfiguration von Beans lesbarer und flexibler gestaltet werden.\n1 2 3 4 5 6 7 @Configuration public class AppConfig { @Bean public ExampleClass exampleBean() { return new ExampleClass(); } } Verwendung von Beans Beans werden normalerweise über Injektionen verwendet, um Abhängigkeiten zwischen verschiedenen Komponenten einer Anwendung zu verwalten. Dies geschieht via Dependency Injection (hier wieder Konstruktor Injection):\n1 2 3 4 5 6 7 8 9 10 @Component public class ExampleService { private final ExampleRepository repository; public ExampleService(ExampleRepository repository) { this.repository = repository; } // ... } Hier wird ExampleRepository als Abhängigkeit von ExampleService injiziert. Die @Component-Annotation wird für dieses Beispiel verwendet, damit die Abhängigkeiten via Dependency Injection eingefügt werden.\nBeans sind flexibel, wiederverwendbar und ermöglichen die Modularität von Anwendungen.\nIn der folgenden offiziellen Dokumentation zu der @Bean-Annotation findest du weitere Beispiele, wie Beans erzeugt werden:\nUsing the Bean Annotation Und wie sie verwendet werden können:\nDependency Injection Scope Der Scope eines Beans besagt, wann und wie ein Bean erstellt wird. Zudem sagt der Scope auch, wie lange ein Bean “lebt”.\nHier eine Liste der Scopes:\nScope Beschreibung singleton (Standard) Singleton besagt, dass es immer nur eine Instanz eines Beans gibt, welche dann geteilt wird. Es wird daher nur eine Bean-Instanz in jedem IoC-Container. Mehr hier. prototype Erstellt bei jeder Abhängigkeit eine neue Bean Instanz. request Erstellt für jeden HTTP Request eine Bean Instanz. session Erstellt für jede HTTP Session eine Bean Instanz. application Erstellt für jeden ServletContext eine Bean Instanz. websocket Erstellt für jeden WebSocket eine Bean Instanz. Die beiden wichtigsten Scopes sind singleton und prototype.\nDer Scope wird durch die @Scope Annotation festgelegt.\nHier ein Beispiel:\n1 2 3 4 5 6 7 8 @Configuration public class MyConfiguration { @Bean @Scope(\"prototype\") public Encryptor encryptor() { // ... } } ","categories":"","description":"Modul #J8 - Spring Framework - Wie sieht das Design-Pattern aus?\n","excerpt":"Modul #J8 - Spring Framework - Wie sieht das Design-Pattern aus?\n","ref":"/de/docs/02_java/12_spring-framework/04_design-pattern/","tags":"","title":"Design-Pattern"},{"body":"Ziele Ich kann ohne Hilfsmittel die 3 verschiedenen Arten von Variablen auflisten (in welchem Kontext werden die Variablen wie genannt?). Ich schreibe eine Definition eines statische Feldes selbstständig und korrekt. Ich kann in eigenen Worten erklären, wozu statische Felder benutzt werden. Ich kann in eigenen Worten den Unterschied zwischen statischen und nicht-statischen Feldern erklären. Felder Wir haben bereits verschiedene Arten von Variablen kennengelernt:\nVariablen in einer Methode oder einem Codeblock - diese werden als lokale Variablen bezeichnet Variablen in Methodendeklarationen oder Konstruktoren - diese werden als Parameter bezeichnet Mitgliedsvariablen (member variables) in einer Klasse - diese werden als Felder oder Instanzvariablen bezeichnet Wir werden uns nun den Feldern widmen. Felder sind Variablen, die innerhalb einer Klasse, aber ausserhalb aller Methoden deklariert werden. Wir definieren sie üblicherweise am Anfang einer Klasse (vor den Methoden). Es gibt zwei verschiedene Typen von Feldern, statische und nicht-statische.\nStatische Felder - Klassenvariablen / Konstanten Manchmal brauchen wir eine Variable, die allen Objekten einer Klasse gemeinsam ist. Dann verwenden wir eine Variable, die mit dem Schlüsselwort static deklariert ist. Diese Variable bezeichnen wir als statisches Feld oder Klassenvariable. Ein statisches Feld ist der Klasse selbst zugeordnet und nicht den Instanzen (=Objekten) dieser Klasse. Denn jede Instanz (= jedes Objekt) der Klasse teilt sich diese Klassenvariable, die sich an einem festen Ort im Speicher befindet. Egal wie viele Objekte dieser Klasse existieren, der Wert des statischen Feldes ist für alle exakt gleich. Jedes Objekt kann den Wert einer Klassenvariablen lesen und verändern.\n1 2 3 4 5 6 7 8 9 10 11 public class Counter { private static int count = 0; public static void main(String[] args) { Counter counter = new Counter(); counter.count++; // Erhöhen der Klassenvariable count über ein Objekt System.out.println(count); // Output: 1 Counter.count++; // Erhöhen des statischen Feldes count über den Klassennamen (ohne Objekt!) System.out.println(count); // Output: 2 } } Angenommen, wir möchten eine Reihe von Bicycle-Objekten erstellen und jedem eine Seriennummer zuweisen, beginnend mit 1 für das erste Objekt. Diese ID-Nummer ist für jedes Objekt eindeutig und daher eine Instanzvariable (was Instanzvariablen sind, dazu kommen wir gleich). Um das zu realisieren, benötigen wir eine Variable, die die Anzahl Fahrräder (Anzahl erzeugter Bicycle-Instanzen) zählt. Vorsicht, diese Art von Implementation ist für mehrere Threads nicht geeignet. Da wir noch nichts von Multithreading wissen, genügt es zu wissen, dass diese Art der Implementation nicht thread-sicher ist (Man spricht von Multithreading bei einem Programm, wenn es mehrere Dinge gleichzeitig parallel ausführt, je nach dem sogar auf mehreren Prozessoren gleichzeitig).\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Bicycle { private int cadence; private int gear; private int speed; private int id; private static int numberOfBicycles = 0; // Klassenvariable, die zählt, wieviele Objekte erzeugt werden // Diese spezielle Methode, Konstruktor genannt, wird benötigt, um Objekte zu instanzieren --\u003e siehe Kapitel Konstruktoren public Bicycle(int startCadence, int startSpeed, int startGear) { this.gear = startGear; // (aktueller Gang) this.cadence = startCadence; // (Umdrehungen / min bei den Pedalen) this.speed = startSpeed; // (km/h) this.id = ++numberOfBicycles; // inkrementiere die Anzahl Fahrräder und weise den Wert der Instanzvariablen id zu } } Manchmal verwenden wir statische Felder, um Konstanten zu definieren. Eine Konstante ist eine Variable, deren Wert nicht mehr verändert werden kann, sobald man ihr einmal einen Wert zugewiesen hat. Um eine Variable als Konstante zu kennzeichnen, verwenden wir zusätzlich das Keyword final. Der Name der Konstante wird zudem per Konvention immer in Grossbuchstaben geschrieben. Um mehrere Wörter abzutrennen verwenden wir Underscores _. Zum Beispiel definiert die folgende Variablendeklaration eine Konstante mit dem Namen PI:\n1 static final double PI = 3.141592653589793; Nicht-statische Felder - Instanzvariablen Unter einer Instanzvariablen versteht man eine Variable, die einer Instanz einer Klasse, also einem Objekt, zugeordnet ist. Wenn eine neue Instanz erzeugt wird, werden Kopien der Instanzvariablen angelegt. Im Fall der Bicycle-Klasse sind die Instanzvariablen cadence, gear, speed und id. Jedes Bicycle-Objekt hat seine eigenen Werte für diese Variablen, d.h. sie werden an unterschiedlichen Orten gespeichert.\n","categories":"","description":"Modul #J2\n","excerpt":"Modul #J2\n","ref":"/docs/02_java/04_java-oop/04_fields/","tags":"","title":"Felder"},{"body":"Ziele Ich kann ohne Hilfsmittel die 3 verschiedenen Arten von Variablen auflisten (in welchem Kontext werden die Variablen wie genannt?). Ich schreibe eine Definition eines statische Feldes selbstständig und korrekt. Ich kann in eigenen Worten erklären, wozu statische Felder benutzt werden. Ich kann in eigenen Worten den Unterschied zwischen statischen und nicht-statischen Feldern erklären. Felder Wir haben bereits verschiedene Arten von Variablen kennengelernt:\nVariablen in einer Methode oder einem Codeblock - diese werden als lokale Variablen bezeichnet Variablen in Methodendeklarationen oder Konstruktoren - diese werden als Parameter bezeichnet Mitgliedsvariablen (member variables) in einer Klasse - diese werden als Felder oder Instanzvariablen bezeichnet Wir werden uns nun den Feldern widmen. Felder sind Variablen, die innerhalb einer Klasse, aber ausserhalb aller Methoden deklariert werden. Wir definieren sie üblicherweise am Anfang einer Klasse (vor den Methoden). Es gibt zwei verschiedene Typen von Feldern, statische und nicht-statische.\nStatische Felder - Klassenvariablen / Konstanten Manchmal brauchen wir eine Variable, die allen Objekten einer Klasse gemeinsam ist. Dann verwenden wir eine Variable, die mit dem Schlüsselwort static deklariert ist. Diese Variable bezeichnen wir als statisches Feld oder Klassenvariable. Ein statisches Feld ist der Klasse selbst zugeordnet und nicht den Instanzen (=Objekten) dieser Klasse. Denn jede Instanz (= jedes Objekt) der Klasse teilt sich diese Klassenvariable, die sich an einem festen Ort im Speicher befindet. Egal wie viele Objekte dieser Klasse existieren, der Wert des statischen Feldes ist für alle exakt gleich. Jedes Objekt kann den Wert einer Klassenvariablen lesen und verändern.\n1 2 3 4 5 6 7 8 9 10 11 public class Counter { private static int count = 0; public static void main(String[] args) { Counter counter = new Counter(); counter.count++; // Erhöhen der Klassenvariable count über ein Objekt System.out.println(count); // Output: 1 Counter.count++; // Erhöhen des statischen Feldes count über den Klassennamen (ohne Objekt!) System.out.println(count); // Output: 2 } } Angenommen, wir möchten eine Reihe von Bicycle-Objekten erstellen und jedem eine Seriennummer zuweisen, beginnend mit 1 für das erste Objekt. Diese ID-Nummer ist für jedes Objekt eindeutig und daher eine Instanzvariable (was Instanzvariablen sind, dazu kommen wir gleich). Um das zu realisieren, benötigen wir eine Variable, die die Anzahl Fahrräder (Anzahl erzeugter Bicycle-Instanzen) zählt. Vorsicht, diese Art von Implementation ist für mehrere Threads nicht geeignet. Da wir noch nichts von Multithreading wissen, genügt es zu wissen, dass diese Art der Implementation nicht thread-sicher ist (Man spricht von Multithreading bei einem Programm, wenn es mehrere Dinge gleichzeitig parallel ausführt, je nach dem sogar auf mehreren Prozessoren gleichzeitig).\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Bicycle { private int cadence; private int gear; private int speed; private int id; private static int numberOfBicycles = 0; // Klassenvariable, die zählt, wieviele Objekte erzeugt werden // Diese spezielle Methode, Konstruktor genannt, wird benötigt, um Objekte zu instanzieren --\u003e siehe Kapitel Konstruktoren public Bicycle(int startCadence, int startSpeed, int startGear) { this.gear = startGear; // (aktueller Gang) this.cadence = startCadence; // (Umdrehungen / min bei den Pedalen) this.speed = startSpeed; // (km/h) this.id = ++numberOfBicycles; // inkrementiere die Anzahl Fahrräder und weise den Wert der Instanzvariablen id zu } } Manchmal verwenden wir statische Felder, um Konstanten zu definieren. Eine Konstante ist eine Variable, deren Wert nicht mehr verändert werden kann, sobald man ihr einmal einen Wert zugewiesen hat. Um eine Variable als Konstante zu kennzeichnen, verwenden wir zusätzlich das Keyword final. Der Name der Konstante wird zudem per Konvention immer in Grossbuchstaben geschrieben. Um mehrere Wörter abzutrennen verwenden wir Underscores _. Zum Beispiel definiert die folgende Variablendeklaration eine Konstante mit dem Namen PI:\n1 static final double PI = 3.141592653589793; Nicht-statische Felder - Instanzvariablen Unter einer Instanzvariablen versteht man eine Variable, die einer Instanz einer Klasse, also einem Objekt, zugeordnet ist. Wenn eine neue Instanz erzeugt wird, werden Kopien der Instanzvariablen angelegt. Im Fall der Bicycle-Klasse sind die Instanzvariablen cadence, gear, speed und id. Jedes Bicycle-Objekt hat seine eigenen Werte für diese Variablen, d.h. sie werden an unterschiedlichen Orten gespeichert.\n","categories":"","description":"Modul #J2\n","excerpt":"Modul #J2\n","ref":"/de/docs/02_java/04_java-oop/04_fields/","tags":"","title":"Felder"},{"body":"Inhalt Dieser Bereich ermöglicht dir das Versionskontrollsystem git kennenzulernen. Du lernst die Aufgaben von Git kennen, erlernst die Anwendung der Git-Befehle auf der Kommandozeile und deren Entsprechung in IDEA IntelliJ. In einem zweiten, fakultativen Modul erlernst du, wie Git für die Zusammenarbeit in einem Team genutzt werden kann.\n","categories":"","description":"Arbeiten mit Git\n","excerpt":"Arbeiten mit Git\n","ref":"/docs/04_git/","tags":"","title":"Git"},{"body":"Inhalt Dieser Bereich ermöglicht dir das Versionskontrollsystem git kennenzulernen. Du lernst die Aufgaben von Git kennen, erlernst die Anwendung der Git-Befehle auf der Kommandozeile und deren Entsprechung in IDEA IntelliJ. In einem zweiten, fakultativen Modul erlernst du, wie Git für die Zusammenarbeit in einem Team genutzt werden kann.\n","categories":"","description":"Arbeiten mit Git\n","excerpt":"Arbeiten mit Git\n","ref":"/de/docs/04_git/","tags":"","title":"Git"},{"body":"","categories":"","description":"Labs zu Git\n","excerpt":"Labs zu Git\n","ref":"/labs/04_git/","tags":"","title":"Git Labs"},{"body":"","categories":"","description":"Labs zu Git\n","excerpt":"Labs zu Git\n","ref":"/de/labs/04_git/","tags":"","title":"Git Labs"},{"body":"Nachdem du die Basics von git gelernt hast, ist es Zeit dich weiter zu vertiefen.\nInhalt Stash Cherry Pick Tag Alias Ziele Ich verstehe, was ein Stash ist und wie er funktioniert. Ich weiss, wie ich einen Pull-Request in meiner IDE, wie auch im Web erstelle. Ich kenne Tags und kann sie über die Kommando-Zeile erstellen. Ich kann Git-Blame in der Kommando-Zeile anwenden. Stash Was ist stash? Mit git stash ist es möglich Änderungen zwischenzuspeichern und diese später abzurufen. Nach dem Stash-Vorgang kannst du an anderen Dateien (auch in anderen Branches) arbeiten, bis du die zwischengespeicherten Daten wieder abrufen kannst.\nWie funktioniert stash? Um Dateien zu stashen wird der folgende Befehl verwendet:\n1 git stash Um Dateien im Anschluss abzurufen wird der folgende Befehl verwendet:\n1 git stash pop Mit git stash pop werden alle Änderungen des Stashes gelöscht und der ursprünglichen Datei hinzugefügt.\nDie Alternative dazu ist:\n1 git stash apply Mit git stash apply werden die Änderungen ebenfalls übernommen, der Unterschied zu git stash pop liegt darin das stash apply die Dateien nicht aus dem Stash löscht, dies kann nützlich sein, wenn dieselbe Änderung mehreren Branches hinzugefügt werden soll.\nSquash Was ist Squash squash in Git meint, mehrere Commits zu vereinen. Squash wird meistens benutzt, wenn Branches gemerged werden. An dieser Stelle ist es jedoch wichtig zu erwähnen das es keinen git squash Befehl gibt.\nWie funktioniert squash? Es gibt verschiedene Wege, um Commits zu squashen. Zum Beispiel gibt es die Methode des manuellen Squashens, dazu wird das Interactive Rebase Feature von Git genutzt. Um die Interactive Rebase Session zu starten wird der folgende Befehl verwendet:\n1 git rebase -i HEAD~3 Danach öffnet sich ein Editor, der die letzten n Commits anzeigt, n wird durch die Zahl nach dem “~” definiert. Um jetzt die Commits zu squashen muss das Pick zu Beginn der Zeile mit squash ersetzt werden. Jetzt werden alle Commits mit dem squash Schlüsselwort an den obersten Commit hinzugefügt.\nWieso sollte man Squashen: Angenommen, du beendest die Arbeit an einem Feature-Branch und willst diese in den Main-Branch mergen. Der Feature-Branch enthält aber viele Commits, die nicht zwingend im Main-Branch aufgeführt werden sollen, in diesem Fall eignet sich das Squashen, um diese Commits zusammenzufassen.\nMerge/Pull Requests Was ist der Unterschied zwischen einer Merge Request und einer Pull Request? Beide Begriffe meinen dasselbe, werden jedoch mit einer anderen Plattform assoziiert. Der Begriff Merge Request wird im Zusammenhang mit GitLab verwendet. Im Zusammenhang mit GitHub oder Bitbucket wird jedoch der Begriff Pull Request verwendet. Der Einfachheit halber wird im folgenden Text nur von Pull Request gesprochen.\nWas ist ein Pull Request bzw. ein Merge Request? In ihrer einfachsten Form sind Pull-Requests eine Funktion für Entwickler, die andere Teammitglieder darüber informiert, dass ein Feature fertiggestellt wurde. Dies lässt alle Beteiligten wissen, dass der Code bereit für eine Überprüfung ist und danach in einen anderen Zweig gemerged werden kann.\nWie kann ein Pull Request erstellt werden (IntelliJ) Um einen Pull Request direkt aus IntelliJ zu erstellen, muss zuerst sichergestellt werden, dass man selbst berechtigt ist, einen Pull Request zu erstellen. Sind diese Berechtigungen vorhanden, kann der Pull Request in wenigen Schritten erstellt werden. Oben Links in IntelliJ befindet sich einen Button der mit Pull Request beschriftet ist. Danach öffnet sich ein Fenster in dem ausgewählt werden kann, welchen der lokalen Branches in das Ziel Repo gemerged werden soll. Danach muss noch ein Titel festgelegt werden. Es besteht ebenfalls die Möglichkeit, eine Beschreibung hinzuzufügen, dies ist jedoch optional. Im Anschluss besteht die Möglichkeit einen Reviewer hinzuzufügen. Jetzt kann der Pull Request erstellt werden.\nFunktioniert nur für GitHub, um Pull Requests in Bitbucket zu erstellen ist die folgende Anleitung zu beachten.\nWie kann eine Pull Request erstellt werden (Github) Um einen Pull Request direkt von GitHub aus zu erstellen, muss zuerst der Reiter Pull Request ausgewählt werden. Jetzt stehen verschiedene Möglichkeiten zu Auswahl, in unserem Fall wollen wir aber nur einen neuen Pull Request erstellen. Im Anschluss erscheint ein neues Panel, das Wichtigste dabei ist die Wahl der richtigen Source und Target Branches. Danach kann noch ein Name und eine Beschreibung für den Pull Request gesetzt werden. Wie in IntelliJ besteht auch hier die Möglichkeit einen Reviewer hinzuzufügen. Der Button dazu befindet sich mittig auf der linken Seite. Da nun alle Einstellungen vorgenommen wurden, kann der Pull Request erstellt werden.\nWie kann eine Pull Request erstellt werden (Bitbucket) Um einen Pull Request in Bitbucket zu erstellen, muss im Web in der linken Navigationsleiste unter ACTIONS die Option Create pull request ausgewählt werden. Hier hat man nun die Möglichkeit einen Branch welcher Änderungen hat (Source Branch) und den Ziel Branch (Destination Branch), dort wo die Änderungen hinzugefügt werden sollen, auszuwählen. Auf der folgenden Seite kann ein Titel und eine Beschreibung für den Pull Request gesetzt werden. Ebenfalls können hier Reviewers hinzugefügt werden. Da nun alle Einstellungen vorgenommen wurden, kann der Pull Request erstellt werden.\nCherry Pick Was ist Cherry-Pick? git cherry-pick ist ein Befehl, welcher es ermöglicht, beliebige Git-Commits (auch von anderen Branches) per Referenz anzusprechen und diese an den momentanen Arbeitskopf (HEAD) anzuheften. git cherry-pick kann sehr nützlich sein, um Änderungen rückgängig zu machen.\nZum Beispiel: Ein Commit wurde aus Versehen im falschen Branch durchgeführt. Nun kannst du zum korrekten Branch wechseln und git cherry-pick nutzen, um den Commit am richtigen Ort zu befestigen.\nWie funktioniert Cherry-Pick? Um Cherry Pick anzuwenden, gibt man folgenden Befehl ein:\n1 git cherry-pick \u003ccommit-hash\u003e Der muss natürlich noch mit dem korrekten Hash des Commits ersetzt werden, welchen man verschieben will. Anschliessend wird der Commit an den Branch angeheftet, auf dem man sich gerade befindet. Darum Achtung!: Immer zuerst kontrollieren, ob man derzeit auch wirklich auf dem korrekten Branch ist.\nTag Was sind Tags? Tags sind Referenzen, welche an einen bestimmten Punkt der History zeigen. Tagging wird üblicherweise benutzt, um wichtige Ereignisse wie z.B. den Release einer Applikation festzuhalten. Ein Tag ist etwas ähnliches wie ein Branch, nur das ein Tag sich nicht verändert. Anders als ein Branch, kann ein Tag nach dem Erstellen keine weiteren Commits beinhalten.\nWie funktionieren Tags? Um ein Tag zu erstellen wird folgender Befehl benötigt:\n1 git tag \u003ctagname\u003e Wobei der auch wieder durch den gewünschten String ersetzt werden muss. Will man zusätzlich zum Tag eine Beschriftung hinzufügen, macht man das mit:\n1 git tag \u003ctagname\u003e -a Damit wird ein Annotated Tag erstellt. Diese Tags werden im Gegensatz zu normalen Tags für einen Release verwendet.\nAuch wichtig anzumerken: Wenn du normal auf den Branch pushst, werden die Tags nicht standardmässig mitgepusht. Dazu brauchst du dann:\n1 git push origin --tags Willst du nur ein einzelnes Tag pushen, brauche:\n1 git push origin \u003ctag\u003e Alias Was sind Aliasse? Ein Git-Alias ist zu vergleichen mit einem Shortcut. Aliase werden z.B. auch beim Arbeiten mit der Bash-Konsole eingesetzt. Aliase werden gebraucht um kürzere Befehle zu realisieren. Sie ermöglichen effizienteres Programmieren.\nNehmen wir zum Beispiel den git-checkout Befehl. Dieser Befehl wird häufig verwendet und muss immer wieder neu eingetippt werden. Mit den Git-Aliassen jedoch kann man git-checkout z.B. in git.co verwandeln. Dies spart enorme Schreibarbeit über längere Zeit und verliert dennoch nicht an Wirksamkeit.\nWie funktionieren Aliasse? Um Aliasse festzulegen, müssen wir diese in der gitconfig-Datei definieren. Dort erstellen wir das Stichwort [alias]. Das könnte in etwa so aussehen:\n1 2 3 [alias] st = status ci = commit -v Die Aliasse können beliebig definiert werden, Ziel davon soll nur sein, die Schreibarbeit zu minimieren und das eigene Programmieren praktischer zu machen.\nGit Blame Was ist Git-Blame? Ist ein Befehl, welcher dazu dient den Autor der letzten Änderung anzuzeigen. Deswegen auch git “blame”. Man “blamed” den Verfasser der letzten Änderung für seinen Fehler (falls er einen gemacht hat).\nWie funktioniert Git-Blame? Um git blame anzuwenden brauchen wir den folgenden Befehl:\n1 git blame \u003cfilename\u003e Und schon haben wir den Verantwortlichen für die letzte Änderung an einer Datei ausfindig gemacht. Jedoch bietet git blame auch andere Anwendungsmöglichkeiten:\n1 git blame -L 1,5 \u003cfilename\u003e Hier zum Beispiel definieren wir eine Range von der Zeile 1 bis zur Zeile 5. Oder hier, noch eine weitere Variante:\n1 git blame -e \u003cfilename\u003e Die Option -e zeigt uns anstatt des Benutzernamen des Autors, direkt die E-Mail-Adresse von ihm, so dass wir gerade Kontakt aufnehmen können.\nZum Schluss haben wir noch die -w Option\n1 git blame -w \u003cfilename\u003e Dieser Befehl ignoriert, wenn ein Autor nur Leerschläge geändert hat. Das hat den Vorteil, dass wir nur die Autoren bekommen, welche auch wirklich etwas am Code selbst geändert und ihn nicht nur formatiert haben.\n","categories":"","description":"","excerpt":"Nachdem du die Basics von git gelernt hast, ist es Zeit dich weiter zu …","ref":"/docs/04_git/01_grundwissen/04_git-erweitert/","tags":"","title":"Git Erweitert"},{"body":"Nachdem du die Basics von git gelernt hast, ist es Zeit dich weiter zu vertiefen.\nInhalt Stash Cherry Pick Tag Alias Ziele Ich verstehe, was ein Stash ist und wie er funktioniert. Ich weiss, wie ich einen Pull-Request in meiner IDE, wie auch im Web erstelle. Ich kenne Tags und kann sie über die Kommando-Zeile erstellen. Ich kann Git-Blame in der Kommando-Zeile anwenden. Stash Was ist stash? Mit git stash ist es möglich Änderungen zwischenzuspeichern und diese später abzurufen. Nach dem Stash-Vorgang kannst du an anderen Dateien (auch in anderen Branches) arbeiten, bis du die zwischengespeicherten Daten wieder abrufen kannst.\nWie funktioniert stash? Um Dateien zu stashen wird der folgende Befehl verwendet:\n1 git stash Um Dateien im Anschluss abzurufen wird der folgende Befehl verwendet:\n1 git stash pop Mit git stash pop werden alle Änderungen des Stashes gelöscht und der ursprünglichen Datei hinzugefügt.\nDie Alternative dazu ist:\n1 git stash apply Mit git stash apply werden die Änderungen ebenfalls übernommen, der Unterschied zu git stash pop liegt darin das stash apply die Dateien nicht aus dem Stash löscht, dies kann nützlich sein, wenn dieselbe Änderung mehreren Branches hinzugefügt werden soll.\nSquash Was ist Squash squash in Git meint, mehrere Commits zu vereinen. Squash wird meistens benutzt, wenn Branches gemerged werden. An dieser Stelle ist es jedoch wichtig zu erwähnen das es keinen git squash Befehl gibt.\nWie funktioniert squash? Es gibt verschiedene Wege, um Commits zu squashen. Zum Beispiel gibt es die Methode des manuellen Squashens, dazu wird das Interactive Rebase Feature von Git genutzt. Um die Interactive Rebase Session zu starten wird der folgende Befehl verwendet:\n1 git rebase -i HEAD~3 Danach öffnet sich ein Editor, der die letzten n Commits anzeigt, n wird durch die Zahl nach dem “~” definiert. Um jetzt die Commits zu squashen muss das Pick zu Beginn der Zeile mit squash ersetzt werden. Jetzt werden alle Commits mit dem squash Schlüsselwort an den obersten Commit hinzugefügt.\nWieso sollte man Squashen: Angenommen, du beendest die Arbeit an einem Feature-Branch und willst diese in den Main-Branch mergen. Der Feature-Branch enthält aber viele Commits, die nicht zwingend im Main-Branch aufgeführt werden sollen, in diesem Fall eignet sich das Squashen, um diese Commits zusammenzufassen.\nMerge/Pull Requests Was ist der Unterschied zwischen einer Merge Request und einer Pull Request? Beide Begriffe meinen dasselbe, werden jedoch mit einer anderen Plattform assoziiert. Der Begriff Merge Request wird im Zusammenhang mit GitLab verwendet. Im Zusammenhang mit GitHub oder Bitbucket wird jedoch der Begriff Pull Request verwendet. Der Einfachheit halber wird im folgenden Text nur von Pull Request gesprochen.\nWas ist ein Pull Request bzw. ein Merge Request? In ihrer einfachsten Form sind Pull-Requests eine Funktion für Entwickler, die andere Teammitglieder darüber informiert, dass ein Feature fertiggestellt wurde. Dies lässt alle Beteiligten wissen, dass der Code bereit für eine Überprüfung ist und danach in einen anderen Zweig gemerged werden kann.\nWie kann ein Pull Request erstellt werden (IntelliJ) Um einen Pull Request direkt aus IntelliJ zu erstellen, muss zuerst sichergestellt werden, dass man selbst berechtigt ist, einen Pull Request zu erstellen. Sind diese Berechtigungen vorhanden, kann der Pull Request in wenigen Schritten erstellt werden. Oben Links in IntelliJ befindet sich einen Button der mit Pull Request beschriftet ist. Danach öffnet sich ein Fenster in dem ausgewählt werden kann, welchen der lokalen Branches in das Ziel Repo gemerged werden soll. Danach muss noch ein Titel festgelegt werden. Es besteht ebenfalls die Möglichkeit, eine Beschreibung hinzuzufügen, dies ist jedoch optional. Im Anschluss besteht die Möglichkeit einen Reviewer hinzuzufügen. Jetzt kann der Pull Request erstellt werden.\nFunktioniert nur für GitHub, um Pull Requests in Bitbucket zu erstellen ist die folgende Anleitung zu beachten.\nWie kann eine Pull Request erstellt werden (Github) Um einen Pull Request direkt von GitHub aus zu erstellen, muss zuerst der Reiter Pull Request ausgewählt werden. Jetzt stehen verschiedene Möglichkeiten zu Auswahl, in unserem Fall wollen wir aber nur einen neuen Pull Request erstellen. Im Anschluss erscheint ein neues Panel, das Wichtigste dabei ist die Wahl der richtigen Source und Target Branches. Danach kann noch ein Name und eine Beschreibung für den Pull Request gesetzt werden. Wie in IntelliJ besteht auch hier die Möglichkeit einen Reviewer hinzuzufügen. Der Button dazu befindet sich mittig auf der linken Seite. Da nun alle Einstellungen vorgenommen wurden, kann der Pull Request erstellt werden.\nWie kann eine Pull Request erstellt werden (Bitbucket) Um einen Pull Request in Bitbucket zu erstellen, muss im Web in der linken Navigationsleiste unter ACTIONS die Option Create pull request ausgewählt werden. Hier hat man nun die Möglichkeit einen Branch welcher Änderungen hat (Source Branch) und den Ziel Branch (Destination Branch), dort wo die Änderungen hinzugefügt werden sollen, auszuwählen. Auf der folgenden Seite kann ein Titel und eine Beschreibung für den Pull Request gesetzt werden. Ebenfalls können hier Reviewers hinzugefügt werden. Da nun alle Einstellungen vorgenommen wurden, kann der Pull Request erstellt werden.\nCherry Pick Was ist Cherry-Pick? git cherry-pick ist ein Befehl, welcher es ermöglicht, beliebige Git-Commits (auch von anderen Branches) per Referenz anzusprechen und diese an den momentanen Arbeitskopf (HEAD) anzuheften. git cherry-pick kann sehr nützlich sein, um Änderungen rückgängig zu machen.\nZum Beispiel: Ein Commit wurde aus Versehen im falschen Branch durchgeführt. Nun kannst du zum korrekten Branch wechseln und git cherry-pick nutzen, um den Commit am richtigen Ort zu befestigen.\nWie funktioniert Cherry-Pick? Um Cherry Pick anzuwenden, gibt man folgenden Befehl ein:\n1 git cherry-pick \u003ccommit-hash\u003e Der muss natürlich noch mit dem korrekten Hash des Commits ersetzt werden, welchen man verschieben will. Anschliessend wird der Commit an den Branch angeheftet, auf dem man sich gerade befindet. Darum Achtung!: Immer zuerst kontrollieren, ob man derzeit auch wirklich auf dem korrekten Branch ist.\nTag Was sind Tags? Tags sind Referenzen, welche an einen bestimmten Punkt der History zeigen. Tagging wird üblicherweise benutzt, um wichtige Ereignisse wie z.B. den Release einer Applikation festzuhalten. Ein Tag ist etwas ähnliches wie ein Branch, nur das ein Tag sich nicht verändert. Anders als ein Branch, kann ein Tag nach dem Erstellen keine weiteren Commits beinhalten.\nWie funktionieren Tags? Um ein Tag zu erstellen wird folgender Befehl benötigt:\n1 git tag \u003ctagname\u003e Wobei der auch wieder durch den gewünschten String ersetzt werden muss. Will man zusätzlich zum Tag eine Beschriftung hinzufügen, macht man das mit:\n1 git tag \u003ctagname\u003e -a Damit wird ein Annotated Tag erstellt. Diese Tags werden im Gegensatz zu normalen Tags für einen Release verwendet.\nAuch wichtig anzumerken: Wenn du normal auf den Branch pushst, werden die Tags nicht standardmässig mitgepusht. Dazu brauchst du dann:\n1 git push origin --tags Willst du nur ein einzelnes Tag pushen, brauche:\n1 git push origin \u003ctag\u003e Alias Was sind Aliasse? Ein Git-Alias ist zu vergleichen mit einem Shortcut. Aliase werden z.B. auch beim Arbeiten mit der Bash-Konsole eingesetzt. Aliase werden gebraucht um kürzere Befehle zu realisieren. Sie ermöglichen effizienteres Programmieren.\nNehmen wir zum Beispiel den git-checkout Befehl. Dieser Befehl wird häufig verwendet und muss immer wieder neu eingetippt werden. Mit den Git-Aliassen jedoch kann man git-checkout z.B. in git.co verwandeln. Dies spart enorme Schreibarbeit über längere Zeit und verliert dennoch nicht an Wirksamkeit.\nWie funktionieren Aliasse? Um Aliasse festzulegen, müssen wir diese in der gitconfig-Datei definieren. Dort erstellen wir das Stichwort [alias]. Das könnte in etwa so aussehen:\n1 2 3 [alias] st = status ci = commit -v Die Aliasse können beliebig definiert werden, Ziel davon soll nur sein, die Schreibarbeit zu minimieren und das eigene Programmieren praktischer zu machen.\nGit Blame Was ist Git-Blame? Ist ein Befehl, welcher dazu dient den Autor der letzten Änderung anzuzeigen. Deswegen auch git “blame”. Man “blamed” den Verfasser der letzten Änderung für seinen Fehler (falls er einen gemacht hat).\nWie funktioniert Git-Blame? Um git blame anzuwenden brauchen wir den folgenden Befehl:\n1 git blame \u003cfilename\u003e Und schon haben wir den Verantwortlichen für die letzte Änderung an einer Datei ausfindig gemacht. Jedoch bietet git blame auch andere Anwendungsmöglichkeiten:\n1 git blame -L 1,5 \u003cfilename\u003e Hier zum Beispiel definieren wir eine Range von der Zeile 1 bis zur Zeile 5. Oder hier, noch eine weitere Variante:\n1 git blame -e \u003cfilename\u003e Die Option -e zeigt uns anstatt des Benutzernamen des Autors, direkt die E-Mail-Adresse von ihm, so dass wir gerade Kontakt aufnehmen können.\nZum Schluss haben wir noch die -w Option\n1 git blame -w \u003cfilename\u003e Dieser Befehl ignoriert, wenn ein Autor nur Leerschläge geändert hat. Das hat den Vorteil, dass wir nur die Autoren bekommen, welche auch wirklich etwas am Code selbst geändert und ihn nicht nur formatiert haben.\n","categories":"","description":"","excerpt":"Nachdem du die Basics von git gelernt hast, ist es Zeit dich weiter zu …","ref":"/de/docs/04_git/01_grundwissen/04_git-erweitert/","tags":"","title":"Git Erweitert"},{"body":"Ziele Ich kann Git direkt in IntelliJ IDEA nutzen, ohne das Terminal öffnen zu müssen. Ich verstehe die wichtigsten Funktionen von Git in IntelliJ. Ich weiss, wie ich meine Änderungen kontrolliere, zurücknehme und veröffentliche. Voraussetzungen Damit du Git in IntelliJ nutzen kannst:\nGit ist auf deinem System installiert (kann bei Bedarf über IntelliJ automatisch installiert werden). Ein Projekt ist als Git-Repository initialisiert oder bereits mit einem Repository verbunden. Git Repository erstellen / initialisieren Falls du noch kein Git-Repository erstellt hast, kannst du das direkt in IntelliJ IDEA tun.\nGehe dazu oben im Projektfenster auf Version Control (beim Fenstertitel) und wähle Create Git Repository… aus.\nWähle danach das Projektverzeichnis aus, das versioniert werden soll.\nNach dem Erstellen siehst du unten den neuen Git-Tab und kannst mit dem ersten Commit starten. Git Repository mit einem Remote Repository (Server) verbinden Wenn Du ein Git Repository selber erstellt hast, ist dieses nur lokal vorhanden. Beim ersten Push wirst du darum von IntelliJ nach der URL für das Remote Repository gefragt. Wie du die URL für dein Remote Repository bekommst erfährst du unter Source Repositories.\nEntschuldige, da fehlt noch was...\n--\u003e Screenshot Remote Repository hinzufügen… .gitignore anpassen IntelliJ erstellt im Projektverzeichnis eigene Dateien, welche nichts mit dem eigentlichen Projekt zu tun haben und deshalb im Git Repository nichts verloren haben. Aus diesem Grund empfiehlt es sich, gleich am Anfang eine .gitignore Datei zu erstellen, welche Verzeichnisse und Dateien enthält, welche ignoriert werden sollen.\nDie .gitignore Datei selber muss zum Git Repository hinzugefügt werden, damit Git sich daran erinnern kann.\nÖffne die Datei .gitignore und füge folgende Zeilen hinzu (.idea/ sollte schon vorhanden sein):\n1 2 3 4 5 *.iml .idea/ out/ target/ build/ Die Verzeichnisse target/ und build/ haben nichts mit IntelliJ zu tun sondern sind Verzeichnisse welche erstellt werden, wenn man Maven oder Gradle nutzt (das sind Build-Mamangement Tools, mehr über Maven erfährst Du hier). Die Datei sollte am ende etwa so aussehen:\nIntelliJ Run Configurations Mit den Run Configurations kann das Starten des Java-Programms vereinfacht werden. Wenn du hauptsächlich mit IntelliJ arbeitest, kann es sinnvoll sein, diese Einstellungen ebenfalls im Git-Repository zu speichern.\nPasse dazu die .gitignore wie folgt an:\n1 2 3 4 5 6 7 8 9 # IntelliJ *.iml .idea/* !.idea/runConfigurations/ # Build-Output out/ target/ build/ Git-Funktionen in IntelliJ IDEA Die folgenden Funktionen sind direkt in die Oberfläche von IntelliJ integriert und erleichtern dir die tägliche Arbeit mit Git:\n2. Änderungen verfolgen Ansicht öffnen: View → Tool Windows → Commit oder Alt+0\nOder über die linke Leiste: Commit\nDu siehst sofort, welche Dateien geändert wurden.\n3. Commits erstellen Ansicht öffnen: View → Tool Windows → Commit… oder Alt+0\nDu gibst deine Commit-Nachricht direkt im Dialog ein.\nOptional kannst du Tests ausführen oder eine Code-Analyse aktivieren.\nDu kannst einzelne Änderungen (sogenannte Hunks) selektiv in den Commit übernehmen.\nDu kannst das Häkchen bei Dateien nutzen, um gezielt auszuwählen, was du aus der Datei committen möchtest (git selbst commited immer die ganze Datei). 4. Änderungen rückgängig machen Rechtsklick auf eine Datei → Git → Rollback\nOder über die linke Leiste: Commit und dort Rechtsclick auf Datei und Rollback\nSolange die Datei nicht ‘commited ’ ist, kannst du Änderungen zurücknehmen. Auch gelöschte Dateien lassen sich so wiederherstellen.\n„Revert“ in IntelliJ betrifft lokale Änderungen – nicht zu verwechseln mit git revert, das einen Commit rückgängig macht. 5. Branches verwalten Ansicht öffnen: View → Tool Windows → Git oder Alt+9\nOder über die linke Leiste: Git\nAuf den Branch-Namen mit rechter Maustaste klicken oder Git → Branches\nWeitere Funktionen stehen dir Oben im Projektfenster zur Verfügung. Dort siehst du den jeweils aktuellen Branch und kannst Du unter anderem:\nEbenfalls neue Branches erstellen Zwischen Branches wechseln Branches zusammenführen (merge) oder löschen Konflikte visuell auflösen 6. Push und Pull Oben im Projektfenster beim Branch Update Project... / Push...\nPush: Lokale Commits zum Remote-Server übertragen Update Project: Änderungen vom Remote-Server abrufen (Pull) 7. Log und History Git → Show Git Log oder Alt+9 → Log\nDu siehst alle bisherigen Commits, Autoren und Änderungen.\nPerfekt, um gezielt frühere Versionen anzuschauen oder zurückzusetzen.\n8. Konflikte lösen Bei Merge-Konflikten öffnet IntelliJ automatisch den Vergleichsdialog:\nLeft = deine Änderungen Right = Änderungen vom Remote oder anderen Branch Result = zusammengeführte Datei Du kannst Zeilen einzeln übernehmen.\nWas du nicht vergessen solltest Auch wenn vieles visuell möglich ist: Ein Grundverständnis von Git hilft, Probleme besser zu erkennen und zu lösen.\nIm Git-Modul lernst du die Befehle und Konzepte im Detail.\nDie Console im Git-Tab zeigt dir oft auch den einer Aktion zugrunde liegenden Git-Befehl – ideal zum Lernen.\n","categories":"","description":"Wie kann ich Git sinnvoll in IntelliJ nutzen.\n","excerpt":"Wie kann ich Git sinnvoll in IntelliJ nutzen.\n","ref":"/docs/99_tools/ide/intellij/04_git/","tags":"","title":"Git mit IntelliJ nutzen"},{"body":"java.util.HashMap Eine Map verwendet man, um Zuweisungen zu speichern. Die java.util.HashMap ist die gebräuchlichste Map. Man könnte zum Beispiel ein Register mit Postleitzahlen (PLZ) und den dazugehörigen Orten speichern. Die PLZ ist der Schlüssel und der Ort ist der zugewiesene Wert.\nEine Zuweisung besteht aus einem Schlüssel (Key) und einem Wert (Value). Dabei ist der Schlüssel immer eindeutig. Speichert man zwei Zuweisungen mit dem gleichen Schlüssel, so wird die erste Zuweisung überschrieben.\nBei der Benennung eine Map versucht man die Zuweisung zu beschreiben:\nplzToCityMap –\u003e PLZ zu City Zuweisung\nMethodenübersicht 1 2 3 4 5 6 7 8 9 10 11 12 Map\u003cInteger, String\u003e plzToCityMap = new HashMap\u003c\u003e(); plzToCityMap.put(3000, \"Zürich\"); plzToCityMap.put(3000, \"Bern\"); plzToCityMap.put(3011, \"Bern\"); plzToCityMap.put(1234, \"Vessy\"); plzToCityMap.put(3920, \"Zermatt\"); System.out.println(plzToCityMap.size()); // Output: 4 System.out.println(plzToCityMap.get(3000)); // Output: Bern System.out.println(plzToCityMap.containsKey(1234)); // Output: true System.out.println(plzToCityMap.containsValue(\"Zürich\")); // Output: false System.out.println(plzToCityMap.containsValue(\"Zermatt\")); // Output: true Die Map offeriert drei Collection Ansichten auf den gespeicherten Inhalt:\nkeySet(): Set auf alle Schlüssel values(): Collection auf alle Werte entrySet(): Set auf alle Schlüssel-Werte Zuweisungen forEach(): Führt eine bestimmte Aktion über alle Elemente aus Die Reihenfolge des Inhalts hängt von der Implementierung der Iteratoren ab, welche eine konkrete Map Klasse für die einzelnen Collection-Ansichten verwendet. Manche Implementation wie die TreeMap garantiert eine bestimmte Reihenfolge, andere wie die HashMap keine.\nBeispiel Beispiel Für die Beispiele verwenden wir folgende HashMap:\n1 2 3 4 5 6 Map\u003cInteger, String\u003e plzToCityMap = new HashMap\u003c\u003e(); plzToCityMap.put(3000, \"Zürich\"); plzToCityMap.put(3000, \"Bern\"); plzToCityMap.put(3011, \"Bern\"); plzToCityMap.put(1234, \"Vessy\"); plzToCityMap.put(3920, \"Zermatt\"); Beispiel 1 - Auslesen der Schlüssel, Werte und Zuweisungen Mit der Methode keySet() kann man alle Schlüssel einer Map abfragen. Der Rückgabewert ist ein Set, welches wir bestens kennen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Abfrage der Schlüssel mit einem Iterator: Iterator\u003cInteger\u003e plzIterator = plzToCityMap.keySet().iterator(); while(plzIterator.hasNext()) { System.out.println(plzIterator.next()); } // Abfrage der Schlüssel mit einer FOR Schleife: for (Integer plz : plzToCityMap.keySet()) { System.out.println(plz); } // Abfrage der Schlüssel mit einem Stream: plzToCityMap.keySet().stream() .forEach(plz -\u003e System.out.println(plz)); } Ebenso kann man die Werte der Zuweisungen mit der Methode values() abfragen. Als Resultat erhält man eine Collection.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // Abfrage der Werte mit einem Iterator: Iterator\u003cString\u003e nameIterator = plzToCityMap.values().iterator(); while(nameIterator.hasNext()) { System.out.println(nameIterator.next()); } // Abfrage der Werte mit einer FOR Schleife: for (String name : plzToCityMap.values()){ System.out.println(name); } // Abfrage der Werte mit einem Stream: plzToCityMap.values().stream() .forEach(name -\u003e System.out.println(name)); } // Abfrage der Werte mit einem forEach: plzToCityMap.values().forEach(name -\u003e System.out.println(name)) Es besteht auch die Möglichkeit mit der Methode entrySet() die Zuweisungen mit Schlüssel und Wert abzufragen. Man erhält wieder ein Set.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // Abfrage der Zuweisungen mit einem Iterator: Iterator\u003cMap.Entry\u003cInteger, String\u003e\u003e plzCityIterator = plzToCityMap.entrySet().iterator(); while(plzCityIterator.hasNext()) { Map.Entry\u003cInteger, String\u003e entry = plzCityIterator.next(); System.out.println(entry.getKey() + \" : \" + entry.getValue()); } // Abfrage der Zuweisungen mit einer FOR Schleife: for (Map.Entry entry : plzToCityMap.entrySet()) { System.out.println(entry.getKey() + \" : \" + entry.getValue()); } // Abfrage der Zuweisungen mit einem Stream: plzToCityMap.entrySet().stream() .forEach(plzCity -\u003e System.out.println(plzCity.getKey() + \" : \" + plzCity.getValue())); // Abfrage der Zuweisungen mit einem forEach: plzToCityMap.forEach((plz, city) -\u003e System.out.println(plz + \" : \" + city)); Aufgaben Aufgaben Aufgaben zu Modul #J6 - Java Collections - Map\n","categories":"","description":"Die gebräuchlichste Umsetzung einer Map: HashMap.\n","excerpt":"Die gebräuchlichste Umsetzung einer Map: HashMap.\n","ref":"/docs/02_java/10_java-collections/04_map/","tags":"","title":"HashMap"},{"body":"java.util.HashMap Eine Map verwendet man, um Zuweisungen zu speichern. Die java.util.HashMap ist die gebräuchlichste Map. Man könnte zum Beispiel ein Register mit Postleitzahlen (PLZ) und den dazugehörigen Orten speichern. Die PLZ ist der Schlüssel und der Ort ist der zugewiesene Wert.\nEine Zuweisung besteht aus einem Schlüssel (Key) und einem Wert (Value). Dabei ist der Schlüssel immer eindeutig. Speichert man zwei Zuweisungen mit dem gleichen Schlüssel, so wird die erste Zuweisung überschrieben.\nBei der Benennung eine Map versucht man die Zuweisung zu beschreiben:\nplzToCityMap –\u003e PLZ zu City Zuweisung\nMethodenübersicht 1 2 3 4 5 6 7 8 9 10 11 12 Map\u003cInteger, String\u003e plzToCityMap = new HashMap\u003c\u003e(); plzToCityMap.put(3000, \"Zürich\"); plzToCityMap.put(3000, \"Bern\"); plzToCityMap.put(3011, \"Bern\"); plzToCityMap.put(1234, \"Vessy\"); plzToCityMap.put(3920, \"Zermatt\"); System.out.println(plzToCityMap.size()); // Output: 4 System.out.println(plzToCityMap.get(3000)); // Output: Bern System.out.println(plzToCityMap.containsKey(1234)); // Output: true System.out.println(plzToCityMap.containsValue(\"Zürich\")); // Output: false System.out.println(plzToCityMap.containsValue(\"Zermatt\")); // Output: true Die Map offeriert drei Collection Ansichten auf den gespeicherten Inhalt:\nkeySet(): Set auf alle Schlüssel values(): Collection auf alle Werte entrySet(): Set auf alle Schlüssel-Werte Zuweisungen forEach(): Führt eine bestimmte Aktion über alle Elemente aus Die Reihenfolge des Inhalts hängt von der Implementierung der Iteratoren ab, welche eine konkrete Map Klasse für die einzelnen Collection-Ansichten verwendet. Manche Implementation wie die TreeMap garantiert eine bestimmte Reihenfolge, andere wie die HashMap keine.\nBeispiel Beispiel Für die Beispiele verwenden wir folgende HashMap:\n1 2 3 4 5 6 Map\u003cInteger, String\u003e plzToCityMap = new HashMap\u003c\u003e(); plzToCityMap.put(3000, \"Zürich\"); plzToCityMap.put(3000, \"Bern\"); plzToCityMap.put(3011, \"Bern\"); plzToCityMap.put(1234, \"Vessy\"); plzToCityMap.put(3920, \"Zermatt\"); Beispiel 1 - Auslesen der Schlüssel, Werte und Zuweisungen Mit der Methode keySet() kann man alle Schlüssel einer Map abfragen. Der Rückgabewert ist ein Set, welches wir bestens kennen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Abfrage der Schlüssel mit einem Iterator: Iterator\u003cInteger\u003e plzIterator = plzToCityMap.keySet().iterator(); while(plzIterator.hasNext()) { System.out.println(plzIterator.next()); } // Abfrage der Schlüssel mit einer FOR Schleife: for (Integer plz : plzToCityMap.keySet()) { System.out.println(plz); } // Abfrage der Schlüssel mit einem Stream: plzToCityMap.keySet().stream() .forEach(plz -\u003e System.out.println(plz)); } Ebenso kann man die Werte der Zuweisungen mit der Methode values() abfragen. Als Resultat erhält man eine Collection.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // Abfrage der Werte mit einem Iterator: Iterator\u003cString\u003e nameIterator = plzToCityMap.values().iterator(); while(nameIterator.hasNext()) { System.out.println(nameIterator.next()); } // Abfrage der Werte mit einer FOR Schleife: for (String name : plzToCityMap.values()){ System.out.println(name); } // Abfrage der Werte mit einem Stream: plzToCityMap.values().stream() .forEach(name -\u003e System.out.println(name)); } // Abfrage der Werte mit einem forEach: plzToCityMap.values().forEach(name -\u003e System.out.println(name)) Es besteht auch die Möglichkeit mit der Methode entrySet() die Zuweisungen mit Schlüssel und Wert abzufragen. Man erhält wieder ein Set.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // Abfrage der Zuweisungen mit einem Iterator: Iterator\u003cMap.Entry\u003cInteger, String\u003e\u003e plzCityIterator = plzToCityMap.entrySet().iterator(); while(plzCityIterator.hasNext()) { Map.Entry\u003cInteger, String\u003e entry = plzCityIterator.next(); System.out.println(entry.getKey() + \" : \" + entry.getValue()); } // Abfrage der Zuweisungen mit einer FOR Schleife: for (Map.Entry entry : plzToCityMap.entrySet()) { System.out.println(entry.getKey() + \" : \" + entry.getValue()); } // Abfrage der Zuweisungen mit einem Stream: plzToCityMap.entrySet().stream() .forEach(plzCity -\u003e System.out.println(plzCity.getKey() + \" : \" + plzCity.getValue())); // Abfrage der Zuweisungen mit einem forEach: plzToCityMap.forEach((plz, city) -\u003e System.out.println(plz + \" : \" + city)); Aufgaben Aufgaben Aufgaben zu Modul #J6 - Java Collections - Map\n","categories":"","description":"Die gebräuchlichste Umsetzung einer Map: HashMap.\n","excerpt":"Die gebräuchlichste Umsetzung einer Map: HashMap.\n","ref":"/de/docs/02_java/10_java-collections/04_map/","tags":"","title":"HashMap"},{"body":"","categories":"","description":"Exercises zu Modul #J2 - OOP\n","excerpt":"Exercises zu Modul #J2 - OOP\n","ref":"/labs/02_java/04_java-oop/","tags":"","title":"Java Exercises - OOP"},{"body":"","categories":"","description":"Exercises zu Modul #J2 - OOP\n","excerpt":"Exercises zu Modul #J2 - OOP\n","ref":"/de/labs/02_java/04_java-oop/","tags":"","title":"Java Exercises - OOP"},{"body":"","categories":"","description":"Modul #J2\n","excerpt":"Modul #J2\n","ref":"/docs/02_java/04_java-oop/","tags":"","title":"Objektorientierte Programmierung in Java"},{"body":"","categories":"","description":"Modul #J2\n","excerpt":"Modul #J2\n","ref":"/de/docs/02_java/04_java-oop/","tags":"","title":"Objektorientierte Programmierung in Java"},{"body":"","categories":"","description":"Werkzeuge zur Zusammenarbeit und Quellcode-Verwaltung.\n","excerpt":"Werkzeuge zur Zusammenarbeit und Quellcode-Verwaltung.\n","ref":"/docs/99_tools/zusammenarbeit/","tags":"","title":"Kollaboration \u0026 Versionskontrolle"},{"body":"Ziele Ich weiss, wie man mit Microsoft Word eine einfache Dokumentation erstellt Ich weiss, wie man ein Deckblatt einfügt Ich weiss, wie man eine Kopf- und Fusszeile einfügt und bearbeitet Ich weiss, wie man Bilder einfügt und bearbeitet Ich weiss, wie man die Formatvorlagen benutzt Ich weiss, wie man ein Inhaltsverzeichnis generieren und aktualisieren kann Deckblatt einfügen Um einen guten Einstieg in eine Dokumentation zu erhalten, kann man ein Deckblatt einfügen. Dies geht ganz simpel über das Register Einfügen und dann die Option Deckblatt auswählen. Dort gibt es einige Vorlagen, welche man aber auch anpassen kann. Es dient als gute Vorlage um wichtige Informationen wie den Autor oder den Titel des Dokuments darzustellen.\nKopf- und Fusszeile In den Kopf- und Fusszeilen werden Texte eingegeben (oder auch Bilder eingefügt), die im gesamten Dokument oder einem gewissen Bereich des Dokuments am oberen oder unteren Seitenrand dargestellt werden. Typische Anwendungen sind zum Beispiel ein Firmenlogo in der Kopfzeile und die Seitenzahl oder der Dateiname in der Fusszeile.\nUm für das Dokument Kopf- und Fusszeile zu erstellen kann man in der Menüleiste auf das Register Einfügen wechseln. Im Abschnitt Kopfzeile oder Fusszeile können wir nun diese einfügen. Word hat schon einige Vorlagen, die wir benutzen können, aber es ist auch möglich eigene Formatvorlagen zu erstellen. Sobald man eine Kopf- oder Fusszeile erstellt hat, wechselt Word automatisch das Register. Nun können wir einige Einstellungen anpassen.\nDie wichtigsten Anpassungen sind folgende:\nSeitenzahl\nUm die Seitenzahl automatisch generieren zu lassen, kann man diese direkt einfügen lassen. Auch dort ist uns Word sehr behilflich und bietet uns einige Vorlagen an.\nOptionen\nIn den meisten Fällen ist die erste Seite eines Dokuments ein Titelblatt. Dort werden die Kopf- und Fusszeilen nicht dargestellt. Um das einzustellen, kann man unter Optionen den Punkt Erste Seite anders auswählen. Damit bekommt die erste Seite eine eigene Kopf- und Fusszeile.\nBilder einfügen Um ein Bild einzufügen, kann man entweder über das Register Einfügen ein Bild über einen Dateipfad einfügen oder man kann das Bild auch direkt in das Dokument kopieren. Das Bild können wir nun bearbeiten. Zum Beispiel können wir es zuschneiden, die Grösse anpassen, eine Formatvorlage hinzufügen oder verschiedene Effekte hinzufügen.\nDamit man in einer Dokumentation die Bilder zusammen mit Text darstellen kann, gibt es für die Bilder Layoutoptionen. Mit diesen Optionen kann man den Textumbruch verändern und somit das Bild in den Text integrieren.\nFormatvorlagen Formatvorlagen vereinheitlichen das Dokument und lassen es professioneller wirken. Diese sind direkt im Register Start zu finden. Die verschiedenen Formatvorlagen kann man anpassen oder auch selbst neue Formatvorlagen erstellen. Um eine Vorlage zu bearbeiten, macht man einfach einen Rechtsklick auf die Vorlage und wählt dort Ändern aus. Nun kann man alle Optionen individuell anpassen.\nInhaltsverzeichnis Um eine Übersicht über das Dokument zu erhalten, kann man ein Inhaltsverzeichnis generieren lassen. Dafür ist unter dem Register Referenzen die Option Inhaltsverzeichnis. Dort finden wir Vorlagen für integrierte Inhaltsverzeichnisse, die von Word selber bearbeitet werden. Wenn wir mit Inhaltsverzeichnissen arbeiten, müssen wir auch mit dem Formatvorlagen für die Titel arbeiten. So können Titel und Untertitel im Inhaltsverzeichnis erkannt und abgebildet werden. Zum Beispiel die Formatvorlage Überschrift 2 wird im Inhaltsverzeichnis eingerückt, da sie als Untertitel verwendet wird.\nNimmt man nach dem Einfügen vom Inhaltsverzeichnis noch weitere Änderungen am Dokument vor, muss man das Verzeichnis aktualisieren. Dafür klickt man einfach auf das Inhaltsverzeichnis im Dokument und kann dann oberhalb vom Verzeichnis auf Inhaltsverzeichnis aktualisieren klicken. Damit werden die Titel und Seitenzahlen aktualisiert.\n","categories":"","description":"Tools - Microsoft Word\n","excerpt":"Tools - Microsoft Word\n","ref":"/de/docs/01_tools/04_ms-word/","tags":"","title":"Microsoft Word"},{"body":"Voraussetzungen Die Vorbereitungen aus Aufgabe 1 sind umgesetzt. Insbesondere sind erledigt:\nZwei neue Repositories mit vorhandenen Projekten wurden erstellt. Es sind jeweils die Branches master und develop vorhanden. Alle Teammember haben diese Repositories geklont. Simulieren einer realen Projektarbeit Ein realistisches Szenario beinhaltet die konkurrierende Arbeit mehrerer Team-Mitglieder auf demselben Repository, die Arbeit mit mehreren Projekten und die Notwendigkeit schnell zwischen den Projekten und einzelnen Versionsständen wechseln zu können.\nIm zweiten Abschnitt wird die parallele Arbeit mit mehreren Projekten bzw. Repositories simuliert. Hier sollen die Kenntnisse zu den nachfolgenden Git Befehlen aufgefrischt werden.\nbranch checkout stash pull push In den Labs zu diesem Modul werden die Git-Aktionen hauptsächlich innerhalb von IntelliJ oder über die Weboberfläche von Bitbucket ausgeführt, da dies das in den Projekten übliche Vorgehen ist.\nArbeit mit mehreren Repositories In diesem Abschnitt werdet ihr mit den gleichen Menueinträgen arbeiten, wie im vorigen. Wenn ihr nicht sicher seid, welche das sind, schaut einfach noch einmal auf der vorigen Seite nach.\nNach Abschluss der Aufgaben solltet ihr in der Lage sein, zwischen unterschiedlichen Projekten und zwischen verschiedenen Versionsständen eines Projektes zu wechseln ohne, dass eure lokalen Änderungen verloren gehen.\nWir werden in diesem Abschnitt mit beiden Projekten arbeiten, wobei auf nur dem zweiten Projekt geändert wird. In einer ersten Aufgabe wird die parallele Arbeit an mehreren Projekten demonstriert. Dabei werden die beiden möglichen Arbeitsweisen vorgestellt.\nDie zweite Aufgabe thematisiert den Wechsel zwischen Branches oder Commits des gleichen Projekts. Kleinere Änderungen werden auf mehrere Commits verteilt. Anschliessend wird zwischen diesen Commits gewechselt, korrigiert, erneut committed oder mit stash zwischengespeichert.\nNach den Übungen könnt ihr zwischen Projekten oder zwischen verschiedenen Branches desselben Projekts wechseln, wisst, wann stash eingesetzt wird und seid mit checkout, rebase, push und pull vertraut.\nZu den Labs:\nSimultanes Arbeiten an mehreren Projekten Wechseln zwischen Branches desselben Projekts ","categories":"","description":"","excerpt":"Voraussetzungen Die Vorbereitungen aus Aufgabe 1 sind umgesetzt. …","ref":"/docs/04_git/02_vertiefung/03_mehrere-repositories/","tags":"","title":"Mit mehreren Repositories arbeiten"},{"body":"Voraussetzungen Die Vorbereitungen aus Aufgabe 1 sind umgesetzt. Insbesondere sind erledigt:\nZwei neue Repositories mit vorhandenen Projekten wurden erstellt. Es sind jeweils die Branches master und develop vorhanden. Alle Teammember haben diese Repositories geklont. Simulieren einer realen Projektarbeit Ein realistisches Szenario beinhaltet die konkurrierende Arbeit mehrerer Team-Mitglieder auf demselben Repository, die Arbeit mit mehreren Projekten und die Notwendigkeit schnell zwischen den Projekten und einzelnen Versionsständen wechseln zu können.\nIm zweiten Abschnitt wird die parallele Arbeit mit mehreren Projekten bzw. Repositories simuliert. Hier sollen die Kenntnisse zu den nachfolgenden Git Befehlen aufgefrischt werden.\nbranch checkout stash pull push In den Labs zu diesem Modul werden die Git-Aktionen hauptsächlich innerhalb von IntelliJ oder über die Weboberfläche von Bitbucket ausgeführt, da dies das in den Projekten übliche Vorgehen ist.\nArbeit mit mehreren Repositories In diesem Abschnitt werdet ihr mit den gleichen Menueinträgen arbeiten, wie im vorigen. Wenn ihr nicht sicher seid, welche das sind, schaut einfach noch einmal auf der vorigen Seite nach.\nNach Abschluss der Aufgaben solltet ihr in der Lage sein, zwischen unterschiedlichen Projekten und zwischen verschiedenen Versionsständen eines Projektes zu wechseln ohne, dass eure lokalen Änderungen verloren gehen.\nWir werden in diesem Abschnitt mit beiden Projekten arbeiten, wobei auf nur dem zweiten Projekt geändert wird. In einer ersten Aufgabe wird die parallele Arbeit an mehreren Projekten demonstriert. Dabei werden die beiden möglichen Arbeitsweisen vorgestellt.\nDie zweite Aufgabe thematisiert den Wechsel zwischen Branches oder Commits des gleichen Projekts. Kleinere Änderungen werden auf mehrere Commits verteilt. Anschliessend wird zwischen diesen Commits gewechselt, korrigiert, erneut committed oder mit stash zwischengespeichert.\nNach den Übungen könnt ihr zwischen Projekten oder zwischen verschiedenen Branches desselben Projekts wechseln, wisst, wann stash eingesetzt wird und seid mit checkout, rebase, push und pull vertraut.\nZu den Labs:\nSimultanes Arbeiten an mehreren Projekten Wechseln zwischen Branches desselben Projekts ","categories":"","description":"","excerpt":"Voraussetzungen Die Vorbereitungen aus Aufgabe 1 sind umgesetzt. …","ref":"/de/docs/04_git/02_vertiefung/03_mehrere-repositories/","tags":"","title":"Mit mehreren Repositories arbeiten"},{"body":"","categories":"","description":"Exams zu Modul #J2\n","excerpt":"Exams zu Modul #J2\n","ref":"/exams/02_java/04_java-oop/","tags":"","title":"Objektorientierte Programmierung Exam"},{"body":"","categories":"","description":"Exams zu Modul #J2\n","excerpt":"Exams zu Modul #J2\n","ref":"/de/exams/02_java/04_java-oop/","tags":"","title":"Objektorientierte Programmierung Exam"},{"body":"Ziele Ich kenne die primitiven Datentypen in Java: boolean, byte, short, int, long, double, float, char. Ich weiss, wie ich primitive Datentypen (formatiert) auf der Konsole ausgeben kann. ⏱️ Geschätzte Lesezeit: 30 Minuten Primitive Datentypen Bei primitiven Datentypen wird der Wert direkt in der Variable gespeichert. Wird die Variable gelöscht, verschwindet auch ihr Inhalt. Du erkennst primitive Datentypen daran, dass sie klein geschrieben werden. Ein String ist daher kein primitiver Datentyp.\nDie primitiven Datentypen sind:\nbyte (Ganzzahl) short (Ganzzahl) int (Ganzzahl) long (Ganzzahl) float (Kommazahl) double (Kommazahl) boolean (true oder false) char (ein einzelnes Zeichen) Integrale Datentypen Integrale Datentypen speichern ganze Zahlen ohne Nachkommastellen. Sie unterscheiden sich im Speicherbedarf:\nDatentyp Speicherbedarf Bereich byte 8 Bit -128 bis 127 short 16 Bit -32_768 bis 32_767 int 32 Bit -2_147_483_648 bis 2_147_483_647 (-2³¹ bis 2³¹−1) long 64 Bit -2⁶³ bis 2⁶³−1 Zur besseren Lesbarkeit darfst du Unterstriche (_) innerhalb von Zahlen verwenden (sogenannte Underscores):\n1 2 int count = 0; int million = 1_000_000; Gleitkomma-Datentypen Gleitkommazahlen enthalten Nachkommastellen, sind aber nicht exakt – es können Rundungsfehler auftreten.\nDatentyp Speicherbedarf Bereich Darstellung float 32 Bit ±1.4E−45 bis ±3.4E+38 Gleitkommazahl (32 Bit) double 64 Bit ±4.9E−324 bis ±1.7E+308 Gleitkommazahl (64 Bit) Beispiele:\n1 2 3 float radius = 8.5f; double area = 16.48739d; double pi = 3.141592653589793; Beachte: float-Werte benötigen das Suffix f.\nFür exakte Berechnungen (z. B. Geldbeträge) verwende BigDecimal. Warum BigDecimal statt double? Der Typ double speichert Gleitkommazahlen im Binärformat. Viele Dezimalzahlen wie 0.1 oder 0.2 lassen sich im Binärsystem nicht exakt darstellen – ähnlich wie 1/3 in Dezimal als 0.333... unendlich lang ist.\nDas führt zu kleinen Rundungsfehlern, die unter anderem in Finanzanwendungen problematisch sind.\nBeispiel: 1 2 3 double x = 0.1; double y = 0.2; System.out.println(x + y); // gives 0.30000000000000004 Auch wenn das nach wenig aussieht: Bei vielen Transaktionen oder Rundungen summieren sich diese Fehler.\nDie Lösung: BigDecimal BigDecimal speichert Zahlen exakt als Dezimalwerte und bietet:\nExakte Rechengenauigkeit Kontrollierte Rundung Präzise Ausgabe 1 2 3 4 5 6 7 import java.math.BigDecimal; BigDecimal a = new BigDecimal(\"0.1\"); BigDecimal b = new BigDecimal(\"0.2\"); BigDecimal result = a.add(b); System.out.println(result); // gives 0.3 Übergib Werte mit Nachkommastellen immer als String (new BigDecimal(\"0.1\")), sonst übernimmst du den ungenauen double-Wert.\nGanzzahlen kannst Du direkt übergeben (new BigDecimal(22)).\nZeichen-Datentyp Ein char steht für genau ein Zeichen: Buchstabe, Zahl oder Symbol.\nDatentyp Speicherbedarf Bereich char 16 Bit Unicode-Zeichen gemäss UTF-16 1 2 3 char letter = 'a'; char point = '.'; letter++; // gives 'b' Warum ergibt letter++ im Beispiel oben den Buchstaben 'b'?\nEin Computer kennt keine Zeichen, sondern nur Zahlen. Auch ein char wird intern als 16-Bit-Zahlenwert gespeichert.\nJava verwendet für Zeichen die Unicode-Codierung nach UTF-16. In der Unicode-Tabelle ist genau definiert,\nwelche Zahl welchem Zeichen entspricht. Ein char deckt dabei die Zeichen aus der Basic Multilingual Plane (BMP) ab.\nWenn man nun letter++ schreibt (das ist das gleiche wie letter = letter + 1), wird der Zahlenwert um eins erhöht.\nDadurch ergibt sich automatisch das nächste Zeichen in der Unicode-Tabelle: Aus 'a' wird 'b', aus '9' wird ':', usw.\n→ Zur !Unicode-Tabelle\nDarum wird aus '3' + 7 nicht 10 sondern 58 -\u003e ':' (Java zeigt auch keinen Fehler, da char auch als Zahl gespeichert wird).\nInitialisierungsmöglichkeiten:\nBeschreibung Beispiel Zeichen in einfachen Anführungszeichen char a = 'A'; Unicode-Zahl (Dezimal, Oktal, Hexadezimal) char a = 65; Unicode-Schreibweise \\uXXXX (vierstellige Hex-Zahl) char a = '\\u0041'; Zeichen vs. Zahlen vs. Strings 123 ist eine Zahl (int), \"123\" ein String 'A' ist ein Zeichen (char), \"A\" ein String '1' ist ein Zeichen (char), 1 eine Zahl Logischer Datentyp Ein boolean kann nur zwei Zustände annehmen:\ntrue (wahr) false (falsch) Beispiel:\n1 2 3 4 5 6 boolean done = false; boolean isBigger = true; if (done) { System.out.println(\"You're done\"); } Der if-Block mit System.out.println(\"You're done\"); wird nur ausgeführt, wenn done den Wert true hat. Du wirst in kürze mehr dazu erfahren, was es mit dem if auf sich hat.\nAusgabe von Datentypen Um Werte auf der Konsole auszugeben, hast du bisher System.out.println(...) verwendet. Das funktioniert auch mit allen primitiven Datentypen:\n1 2 3 4 5 6 7 int number = 42; double temperature = 36.6; boolean isDone = true; System.out.println(number); // Output: 42 System.out.println(temperature); // Output: 36.6 System.out.println(isDone); // Output: true Formatierte Ausgabe mit printf Wenn du mehr Kontrolle über die Ausgabe haben möchtest – z. B. nur 2 Nachkommastellen bei einem double –, verwendest du System.out.printf(...).\n1 2 3 double value = 3.14159265; System.out.printf(\"Wert auf 2 Stellen: %.2f%n\", value); // Gibt: Wert auf 2 Stellen: 3.14 Als ersten Parameter übergibst du einen String mit dem Text und Platzhaltern, welche dann durch die nachfolgenden Parameter ersetzt werden sollen.\nWichtige Platzhalter bei printf Platzhalter Bedeutung Beispielausgabe %d Ganzzahl (int, long, …) 42 %f Gleitkommazahl (float, double) 3.14 %.2f Gleitkommazahl mit 2 Nachkommastellen 3.14 %c Zeichen (char) A %b Wahrheitswert (boolean) true %s String Hallo %n Neue Zeile (plattformunabhängig) Weitere Optionen bei den Platzhaltern Format Bedeutung Beispiel %5d Zahl mit mindestens 5 Stellen (rechtsbündig) 42 %-5d Zahl mit mindestens 5 Stellen (linksbündig) 42 %05d Mit Nullen auffüllen 00042 %,d Tausender-Trennzeichen (je nach Locale) 1,000,000 %10.2f Gleitkommazahl: mind. 10 Stellen, 2 Nachkommastellen 123.45 %010.2f Gleitkommazahl, mind. 10 Stellen mit führenden Nullen 0000123.45 Beispiel: Alle Typen formatiert ausgeben 1 2 3 4 5 6 7 8 9 int count = 12; double price = 5.6789; char symbol = 'Z'; boolean isActive = true; System.out.printf(\"Zahl: %d%n\", count); System.out.printf(\"Preis: %.2f CHF%n\", price); System.out.printf(\"Zeichen: %c%n\", symbol); System.out.printf(\"Status: %b%n\", isActive); Ausgabe:\n1 2 3 4 Zahl: 12 Preis: 5.68 CHF Zeichen: Z Status: true Es können beliebig viele Platzhalter definiert werden.\n1 2 3 4 int count = 12; double price = 5.6789; System.out.printf(\"%d Artikel kosten %.2f CHF%n\", count, price); Ausgabe:\n1 12 Artikel kosten 5.68 CHF Wenn du printf verwendest, wird nichts automatisch umgebrochen. Du musst \\n oder %n selbst angeben, damit der Text in einer neuen Zeile weitergeht. Java zeigt nur eine Warnung, aber keinen Fehler, wenn:\nmehr Platzhalter als Variablen angegeben sind, eine Variable nicht in das gewünschte Format umgewandelt werden kann. Solche Warnungen sollten nicht ignoriert werden – sie können zur Laufzeit zu unerwartetem Verhalten oder Fehlern führen.\nLernvideo Wenn du dir die Erklärung noch mit einem Video anschauen möchtest, empfehlen wir dir dieses Video. Jetzt bist du dran. Löse bitte die folgende !*Aufgabe in den Labs. ","categories":"","description":"In diesem Modul lernst du die primitiven Datentypen in Java kennen – also Werte wie Zahlen, Zeichen oder Wahrheitswerte.\n","excerpt":"In diesem Modul lernst du die primitiven Datentypen in Java kennen – …","ref":"/docs/02_java/03_java-grundlagen/04_primitive_types/","tags":"","title":"Primitive Datentypen"},{"body":"Ziele Ich kenne die primitiven Datentypen in Java: boolean, byte, short, int, long, double, float, char. Primitive Datentypen Bei Variablen primitiver Datentypen werden die Werte der Variable direkt in der Variable gespeichert. Aus diesem Grund wird dann der Wert der Variable auch dann gelöscht, wenn die Variable gelöscht wird. Du erkennst primitive Datentypen auch daran, dass sie klein geschrieben werden. Ein String ist daher kein primitiver Datentyp.\nDie primitiven Datentypen sind die folgenden:\nbyte (Ganzzahl) short (Ganzzahl) int (Ganzzahl) long (Ganzzahl) float (Kommazahl) double (Kommazahl) boolean (entweder true oder false) char (ein Zeichen wie ein Buchstabe) Integraler Datentyp Integrale Datentypen sind ganze Zahlen, sie besitzen also keine Nachkommastellen. Die folgenden Datentypen speichern ganzzahlige Werte, sie unterscheiden sich nur in ihrem Speicherbedarf:\nDatentyp Speicherbedarf Bereich byte 8 Bit -128 … 127 short 16 Bit -32768 … 32767 int 32 Bit -2 147 483 648 … 2 147 483 647 (-2^31 … 2^31-1) long 64 Bit -2^63 … 2^63-1 Ausserdem sind in den Werten von integralen Datentypen Underscores erlaubt, um die Lesbarkeit zu erhöhen (1_000_000).\nBeispiele:\n1 2 int count = 0; int million = 1_000_000; Gleitkomma-Datentyp Gleitkomma-Datentypen speichern wie der Name bereits sagt, Zahlen mit Nachkommastellen. Diese Zahlen besitzen nur eine bestimmte Genauigkeit, sie dürfen nicht als völlig exakt betrachtet werden.\nDie folgenden Datentypen speichern Zahlen mit Nachkommastellen, sie unterscheiden sich in ihrem Speicherbedarf und der Art und Weise wie sie innerhalb von Java abgelegt werden:\nDatentyp Speicherbedarf Bereich Interne Ablage float 32 Bit +/-1,4E-45 … +/-3,4E+38 Gleitkommazahl (32 Bit) double 64 Bit +/-4,9E-324 … +/-1,7E+308 Gleitkommazahl (64 Bit) Wie folgt können Gleitkommazahlen initialisiert werden:\n1 2 3 float radius = 8.5f; double area = 16.48739d; double pi = 3.141592653589793; Beachte, dass bei float-Zahlen ein f am Ende steht, da die Zahl sonst als double interpretiert wird.\nTrotz Nachkommastellen dürfen Gleitkommazahlen des Typs float und double niemals zur Berechnung von Währungen verwendet werden. Der Grund dafür sind Rundungsfehler, wenn mit diesen Datentypen gerechnet wird. Falls du exakte Berechnungen mit Gleitkommazahlen durchführen möchtest, musst du die Klasse BigDecimal verwenden. BigDecimal ist kein primitiver Datentyp.\nZeichen-Datentyp Ein char ist ein Datentyp, der ein einzelnes Zeichen darstellt.\nEin einzelnes Zeichen kann eine Ziffer, einen Buchstaben oder ein anderes Symbol sein. Um ein Zeichen zu schreiben, verwenden wir einfache Anführungszeichen wie folgt:\n1 'A', 'B', 'C', 'x', 'y', 'z', '0', '1', '2', '9' Zeichenliterale können Symbole eines Alphabets, Ziffern von ‘0’ bis ‘9’, Leerzeichen (’ ‘) oder andere Zeichen oder Symbole (’$’) darstellen. Verwechsle nicht Zeichen, die Ziffern darstellen (‘9’), mit den tatsächlichen Zahlenwerten (9). Ein Zeichen kann nicht zwei und mehr Ziffern oder Buchstaben enthalten, da es nur ein einziges Symbol darstellt.\nWir können Zeichen auf verschiedene Arten initialisieren:\nBeschreibung Code Einfache Anführungszeichen char A = 'A'; Wir können ein Char-Literal als Integral-Literal angeben, das den Unicode-Wert des Zeichens darstellt, und Integral-Literale können entweder in Dezimal-, Oktal- oder Hexadezimalform angegeben werden. Der zulässige Unicode-Bereich liegt zwischen 0 und 65535. char A = 65; In der Unicode-Darstellung '\\\\uxxxx' können Zeichenliterale angegeben werden. Hier steht xxxx für 4 Hexadezimalzahlen. char A = '\\u0041'; Auf der Unicode Zeichentabelle kannst du sehen, welche Zahl welchem Zeichen entspricht.\nBeispiele:\n1 2 3 char letter = 'a'; char point = '.'; letter++; // 'b' letter++ ist das gleiche wie letter = letter + 1. Man nennt das auch inkrementieren.\nDon’t get confused: 123 ist ein Integer, “123” ist ein String; ‘A’ ein Zeichen (char), “A” ist ein String; ‘1’ ist ein Zeichen (char), 1 ist ein Integer; Der Unterschied liegt in den verwendeten Anführungszeichen.\nLogischer Datentyp Ein boolean kann nur zwei verschiedene Werte haben:\ntrue wie wahr (bzw. zutreffend) false wie falsch/unwahr (bzw. nicht zutreffend) Ein boolean speichert, ob eine Bedingung wahr (true) oder falsch (false) ist. Dieser Wert wird häufig in Bedingungen verwendet, die wir später behandeln werden.\n1 2 boolean done = false; boolean isBigger = true; Eine mögliche Verwendung von booleans sind Bedingungen, wenn bestimmter Code nur ausgeführt werden soll, wenn z.B. ein boolean den Wert true aufweist:\n1 2 3 4 5 boolean done = false; if (done) { System.out.println(\"You're done\"); } Damit etwas ausgegeben werden würde, müsste die Variable done den Wert true haben.\nLernvideo Wenn du dir die Erklärung noch mit einem Video genauer anschauen möchtest, empfiehlt dir das Praxisbildner-Team dieses Video.\n","categories":"","description":"Modul #J1\n","excerpt":"Modul #J1\n","ref":"/de/docs/02_java/03_java-grundlagen/04_primitive_types/","tags":"","title":"Primitive Datentypen"},{"body":"Erstelle ein System für ein Online-Handelshaus, das Produkte aus verschiedenen Kategorien verkauft. Das System soll die Verwaltung von Produkten, Kunden und Bestellungen ermöglichen.\nProdukt:\neindeutige Produkt-ID Namen Preis Kategorie Verfügbarkeitsstatus. Produkte können verschiedenen Kategorien angehören, z.B. Elektronik, Kleidung, Bücher usw. Das System sollte in der Lage sein, verschiedene Arten von Produkten zu verwalten, z.B. Elektronikprodukte (Handys, Laptops), Kleidungsstücke (T-Shirts, Hosen), Bücher (Romane, Fachbücher) usw.\nKunde:\neindeutige Kunden-ID Namen E-Mail-Adresse Lieferadresse. Kunden können Produkte kaufen, indem sie Bestellungen aufgeben.\nBestellung:\neindeutige Bestellnummer die Produkte, welche gekauft wurden Gesamtpreis Kunden, welcher die Bestellung aufgegeben hat Bestellstatus. Kunden können mehrere Produkte in einer Bestellung kaufen.\nDas System sollte folgende Funktionen unterstützen:\nHinzufügen, Aktualisieren und Entfernen von Produkten. Anzeigen aller Produkte in einer bestimmten Kategorie. Hinzufügen, Aktualisieren und Entfernen von Kunden. Anzeigen aller Bestellungen eines bestimmten Kunden. Aufgeben einer neuen Bestellung für einen Kunden. Aktualisieren des Bestellstatus für eine Bestellung. Hier kannst du zurück zur Theorie.\n","categories":"","description":"Aufgabe zu Modul #J3 - [OOD](../../../../docs/02_java/07_java-ood) - Shop\n","excerpt":"Aufgabe zu Modul #J3 - [OOD](../../../../docs/02_java/07_java-ood) - …","ref":"/labs/02_java/07_java-ood/04_shop/","tags":"","title":"Shop"},{"body":"Erstelle ein System für ein Online-Handelshaus, das Produkte aus verschiedenen Kategorien verkauft. Das System soll die Verwaltung von Produkten, Kunden und Bestellungen ermöglichen.\nProdukt:\neindeutige Produkt-ID Namen Preis Kategorie Verfügbarkeitsstatus. Produkte können verschiedenen Kategorien angehören, z.B. Elektronik, Kleidung, Bücher usw. Das System sollte in der Lage sein, verschiedene Arten von Produkten zu verwalten, z.B. Elektronikprodukte (Handys, Laptops), Kleidungsstücke (T-Shirts, Hosen), Bücher (Romane, Fachbücher) usw.\nKunde:\neindeutige Kunden-ID Namen E-Mail-Adresse Lieferadresse. Kunden können Produkte kaufen, indem sie Bestellungen aufgeben.\nBestellung:\neindeutige Bestellnummer die Produkte, welche gekauft wurden Gesamtpreis Kunden, welcher die Bestellung aufgegeben hat Bestellstatus. Kunden können mehrere Produkte in einer Bestellung kaufen.\nDas System sollte folgende Funktionen unterstützen:\nHinzufügen, Aktualisieren und Entfernen von Produkten. Anzeigen aller Produkte in einer bestimmten Kategorie. Hinzufügen, Aktualisieren und Entfernen von Kunden. Anzeigen aller Bestellungen eines bestimmten Kunden. Aufgeben einer neuen Bestellung für einen Kunden. Aktualisieren des Bestellstatus für eine Bestellung. Hier kannst du zurück zur Theorie.\n","categories":"","description":"Aufgabe zu Modul #J3 - [OOD](../../../../docs/02_java/07_java-ood) - Shop\n","excerpt":"Aufgabe zu Modul #J3 - [OOD](../../../../docs/02_java/07_java-ood) - …","ref":"/de/labs/02_java/07_java-ood/04_shop/","tags":"","title":"Shop"},{"body":"Aufgabe 1 (Optional) Versuche eine eigene Stack-Klasse (MyStack\u003cE\u003e) zu implementieren mithilfe von Arrays und verwende dabei keine anderen Collections-Klassen.\nDie MyStack Klasse sollte eine dynamische Grösse haben, d.h. sie der Stack sollte beliebig wachsen können. Da der Stack mithilfe von Arrays implementiert werden soll, muss also in deiner Klasse die Kapazität des Stacks sichergestellt werden.\nImplementiere die folgenden Methoden:\npublic E push(E item) public E pop( ) (soll EmptyStackException werfen) public E peek() (soll EmptyStackException werfen) int size() public boolean empty() Beachte, dass du die toString() Methode anpasst, sodass die MyStack-Stacks beim printen übersichtlich dargestellt werden, wie im Beispiel oben: [blue, yellow, green, orange]\nZudem wird erwartet, dass ein eigenes Testing (wie in J4 Testing gelernt) zu der Umsetzung gehört.\nAufgabe 2 (Optional) Erweitere deine MyStack Klasse. Implementiere zusätzlich die folgende Methode:\npublic int search(Object o) ","categories":"","description":"Aufgaben zu [Java Collections - Stack](../../../docs/02_java/10_java-collections/05_stack)\n","excerpt":"Aufgaben zu [Java Collections - …","ref":"/labs/02_java/10_java-collections/04_stack/","tags":"","title":"Stack - Aufgaben"},{"body":"Aufgabe 1 (Optional) Versuche eine eigene Stack-Klasse (MyStack\u003cE\u003e) zu implementieren mithilfe von Arrays und verwende dabei keine anderen Collections-Klassen.\nDie MyStack Klasse sollte eine dynamische Grösse haben, d.h. sie der Stack sollte beliebig wachsen können. Da der Stack mithilfe von Arrays implementiert werden soll, muss also in deiner Klasse die Kapazität des Stacks sichergestellt werden.\nImplementiere die folgenden Methoden:\npublic E push(E item) public E pop( ) (soll EmptyStackException werfen) public E peek() (soll EmptyStackException werfen) int size() public boolean empty() Beachte, dass du die toString() Methode anpasst, sodass die MyStack-Stacks beim printen übersichtlich dargestellt werden, wie im Beispiel oben: [blue, yellow, green, orange]\nZudem wird erwartet, dass ein eigenes Testing (wie in J4 Testing gelernt) zu der Umsetzung gehört.\nAufgabe 2 (Optional) Erweitere deine MyStack Klasse. Implementiere zusätzlich die folgende Methode:\npublic int search(Object o) ","categories":"","description":"Aufgaben zu [Java Collections - Stack](../../../docs/02_java/10_java-collections/05_stack)\n","excerpt":"Aufgaben zu [Java Collections - …","ref":"/de/labs/02_java/10_java-collections/04_stack/","tags":"","title":"Stack - Aufgaben"},{"body":"Schreibe ein Programm, welches einen Streaming Dienst nachstellt. Die Anwendung soll die Filme und Serien in einem Streaming Dienst abspeichern, wenn die entsprechende Methode aufgerufen wurde. Der Streaming Dienst hat auch eine Liste an Personen, welche ein Abonnement bei dem Streaming Dienst gelöst haben.\nEine Person besitzt\neinen Namen eine Email-Adresse eine Kreditkarte Ein Film\neinen Namen eine Dauer ein Genre einen Produzenten eine oder mehrere Sprachen Eine Person kann\neinen Film als gesehen markieren (View) seine Kreditkarte ändern zwischen der Zahlungsart Monatlich oder Jährlich entscheiden Der Streaming Dienst kann\ndie Anzahl der Personen zurückliefern, welche ein Abonnement gelöst haben eine neue Person registrieren eine Person löschen nach einem Film über den Namen suchen nach Filmen eines bestimmten Genres suchen die anzahl Views auf einem Film wiedergeben alle Kreditkarten der Kunden ausgeben (println) die das Abonnemente per Monatlichen Zahlung bezahlen Generell gilt die Regel, dass jede E-Mail-Adresse und jeder Film-Name einzigartig sein muss\nFür die Sprachen soll folgende Auswahl vorhanden sein: BULGARIAN,CROATIAN,CZECH,DANISH,DUTCH,ENGLISH,ESTONIAN,FINNISH,FRENCH,GERMAN,GREEK,HUNGARIAN,IRISH,ITALIAN,SLOVENIA,LATVIAN,LITHUANIAN,MALTESE,POLISH,PORTUGUESE,ROMANIAN,SLOVAK,SLOVENE,SPANISH,SWEDISH\nDie Sprachen sollen nicht in Form eines Strings gespeichert werden!\nEs soll kein Scanner eingesetzt werden.\nHier kannst du zurück zur Theorie.\n","categories":"","description":"Aufgabe zu Modul #J2 - OOP - Streaming Dienst\n","excerpt":"Aufgabe zu Modul #J2 - OOP - Streaming Dienst\n","ref":"/labs/02_java/04_java-oop/04_streaming_dienst/","tags":"","title":"Streaming Dienst"},{"body":"Schreibe ein Programm, welches einen Streaming Dienst nachstellt. Die Anwendung soll die Filme und Serien in einem Streaming Dienst abspeichern, wenn die entsprechende Methode aufgerufen wurde. Der Streaming Dienst hat auch eine Liste an Personen, welche ein Abonnement bei dem Streaming Dienst gelöst haben.\nEine Person besitzt\neinen Namen eine Email-Adresse eine Kreditkarte Ein Film\neinen Namen eine Dauer ein Genre einen Produzenten eine oder mehrere Sprachen Eine Person kann\neinen Film als gesehen markieren (View) seine Kreditkarte ändern zwischen der Zahlungsart Monatlich oder Jährlich entscheiden Der Streaming Dienst kann\ndie Anzahl der Personen zurückliefern, welche ein Abonnement gelöst haben eine neue Person registrieren eine Person löschen nach einem Film über den Namen suchen nach Filmen eines bestimmten Genres suchen die anzahl Views auf einem Film wiedergeben alle Kreditkarten der Kunden ausgeben (println) die das Abonnemente per Monatlichen Zahlung bezahlen Generell gilt die Regel, dass jede E-Mail-Adresse und jeder Film-Name einzigartig sein muss\nFür die Sprachen soll folgende Auswahl vorhanden sein: BULGARIAN,CROATIAN,CZECH,DANISH,DUTCH,ENGLISH,ESTONIAN,FINNISH,FRENCH,GERMAN,GREEK,HUNGARIAN,IRISH,ITALIAN,SLOVENIA,LATVIAN,LITHUANIAN,MALTESE,POLISH,PORTUGUESE,ROMANIAN,SLOVAK,SLOVENE,SPANISH,SWEDISH\nDie Sprachen sollen nicht in Form eines Strings gespeichert werden!\nEs soll kein Scanner eingesetzt werden.\nHier kannst du zurück zur Theorie.\n","categories":"","description":"Aufgabe zu Modul #J2 - OOP - Streaming Dienst\n","excerpt":"Aufgabe zu Modul #J2 - OOP - Streaming Dienst\n","ref":"/de/labs/02_java/04_java-oop/04_streaming_dienst/","tags":"","title":"Streaming Dienst"},{"body":" Voraussetzung Du weisst was Variablen sind. Du kannst eine Variable deklarieren und initialisieren. Du weisst was primitive Datentypen sind. Du weisst wie man Variablen formatiert auf der Konsole ausgibt. Wir stellen dir bei den Übungen jeweils komplette Projekte zur Verfügung. Du musst grundsätzlich nur dort was anpassen, wo die folgende Kommentarzeile steht:\nKopieren // IT-Ninja: Füge hier Deinen Code ein: 1 // IT-Ninja: Füge hier Deinen Code ein: Alles andere kannst du für den Moment ignorieren. Wir erklären dir die einzelnen Zeilen Schritt für Schritt in den Modulen.\nVorbereitungsarbeiten Drücke auf den Pfeil links um eine detaillierte Anleitung zu erhalten, wie Du den Quellcode auf deinem Rechner ablegen sollst.\nDiese Schritte musst du bei jeder Übung erneut machen. Jede Übung hat ein eigenes ZIP-File, welches du bei dir an die richtige Stelle kopieren musst. Die Anleitung zeigt dir ziemlich gut, wie das geht… Liess vor allem am Anfang die detaillierte Anleitung gut durch und befolge die Schritte exakt. Sie helfen dir, deinen Quellcode gut organisiert, strukturiert und sicher zu verwalten. Falls du die Anleitung schon auswendig kennst, findest du den Quellcode zur Übung direkt hier: Download | Online anschauen\nNeu bei it-ninja?\nDie Anleitung enthält einige Befehle und Fachbegriffe, die dir möglicherweise noch nichts sagen. Mach dir deswegen keine Sorgen – in den kommenden Modulen erklären wir dir alles Schritt für Schritt. Schon bald wirst auch du ein it-ninja sein. Um die folgenden Aufgaben erfolgreich umzusetzen, führe diese Schritte aus:\nBeim ersten Mal:\nIntelliJ IDEA installieren → !*IntelliJ IDEA einrichten Git-Repository einrichten → !*Persönliches Git-Repository Öffne eine !*CMD-Shell und wechsle ins Verzeichnis deines Git-Repositories:\nKopieren cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git status 1 2 cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git status Kopieren cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git status 1 2 cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git status Stelle sicher, dass alle Dateien im Git-Repository committed sind. Mit git status erhältst du eine Übersicht: Kopieren git status 1 git status Falls du bei diesem Befehl einen roten Text siehst, musst du zuerst die aktuellen Dateien sichern:\nKopieren git add . git commit -m \"[gescheiter Kommentar]\" 1 2 git add . git commit -m \"[gescheiter Kommentar]\" Erstelle oder wechsle in den Template Branch:\nBeim ersten Mal musst du einen Template Branch erstellen:\nKopieren git checkout -b \"templates\" 1 git checkout -b \"templates\" Falls er bereits existiert, kannst du einfach switchen:\nKopieren git switch \"templates\" 1 git switch \"templates\" Lade den Source-Code zu den Übungen herunter und entpacke ihn im Root-Verzeichnis deines lokalen Repositories:\n[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\nDen Source-Code findest du hier: Download | Online anschauen\nCommitte den originalen Source-Code, damit er sicher im Repository gespeichert ist:\nKopieren git add . git commit -m \"Add it-ninja_02_java_03_java-grundlagen_04_variables-and-types\" git push 1 2 3 git add . git commit -m \"Add it-ninja_02_java_03_java-grundlagen_04_variables-and-types\" git push Erstelle einen neuen Branch, um deine Lösung zu implementieren: Kopieren git checkout -b \"labs/it-ninja_02_java_03_java-grundlagen_04_variables-and-types\" 1 git checkout -b \"labs/it-ninja_02_java_03_java-grundlagen_04_variables-and-types\" Hier kannst du auch einen kürzeren Namen wählen. Verwende labs am Anfang des Branch-Namens für Branches, die deinen eigenen Code enthalten.\nStelle dir einen Branch vorerst als Ordner vor. Jeder Ordner enthält eine Version oder einen Stand von deinem Quellcode. Du kannst dann mit git zwischen diesen Ordern hin und her wechseln, sie vergleichen aber später auch zusammenführen.\nPro-Tipp:\nDu kannst jederzeit einen weiteren Branch erstellen – z. B. wenn du etwas ausprobieren möchtest. Alternativ kannst du auch in der Git-History einen alten Stand wiederherstellen, was aber weniger flexibel ist. Starte IntelliJ und öffne mit File → Open das Verzeichnis mit dem Source-Code. Du musst mit IntelliJ den Ordner suchen, welches einen Ordner src oder die Datei pom.xml enthält. Ansonsten wird IntelliJ Mühe haben, dir das Programm zu kompilieren. Wenn du alles korrekt gemacht hast, findest du das Projekt hier:\nKopieren `[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\\02_java\\03_java-grundlagen\\04_variables-and-types` 1 `[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\\02_java\\03_java-grundlagen\\04_variables-and-types` Kopieren `[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\\02_java/03_java-grundlagen/04_variables-and-types` 1 `[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\\02_java/03_java-grundlagen/04_variables-and-types` Falls du zum ersten Mal mit IntelliJ arbeitest, findest du !*hier eine Anleitung, wie man ein Programm startet. Um das Programm zu starten musst du jeweils die Datei Main.java öffenen. Dann sollte in IntelliJ oben rechts ein grünes Dreieck vorhanden sein, welches das Programm startet. Nun bist du bereit, die untenstehenden Aufgaben zu lösen.\nWenn du alle Änderungen gemacht hast und mit der Übung fertig bist, oder einen ‘Zwischenstand’ festhalten willst, führe die folgenden Befehle aus um das Repository auf dem Server zu speichern (von wo du es geklont hast):\nKopieren cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git add --all git commit -m \"Kurzer Kommentar\" 1 2 3 cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git add --all git commit -m \"Kurzer Kommentar\" Kopieren cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git add . git commit -m \"Kurzer Kommentar\" 1 2 3 cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git add . git commit -m \"Kurzer Kommentar\" Wenn du deine Änderungen auf dem Git-Server sichern willst, musst du das mit einem push machen.\nBeim ersten mal musst du git noch mitteilen, wie der Branch auf dem Git-Server heissen soll:\nKopieren git push --set-upstream origin labs/it-ninja_02_java_03_java-grundlagen_04_variables-and-types 1 git push --set-upstream origin labs/it-ninja_02_java_03_java-grundlagen_04_variables-and-types Bei weiteren pushes wird es dann einfacher:\nKopieren git push 1 git push Die meisten Übungen sind professionell strukturiert – so wie in echten Softwareprojekten. Zu gutem Code gehören auch Tests, die sicherstellen, dass dein Code wie erwartet funktioniert. Sofern nicht anders erwähnt, kannst du mit folgendem Befehl im Root-Verzeichnis des Projekts (dort, wo sich auch die pom.xml befindet) überprüfen, ob du die Aufgabe korrekt gelöst hast:\n1 mvn test Viel Erfolg!\nAufgabe 1 - Hello It-Ninja Erstelle eine Variable, welche deinen Namen beinhaltet. Gib Hello [name] auf der Konsole aus.\nIm zur Übung gehörendem Source kannst Du die Änderung an folgender Stelle machen:\nsrc\\main\\java\\ch\\itninja\\labs\\basicexercises\\HelloName.java:\n1 2 3 4 5 public static void printHelloName(){ // IT-Ninja: Füge hier Deinen Code ein: } Beispielausgabe:\n1 Hello It-Ninja Aufgabe 2 - Reise Report Gib den folgenden Text mit System.out.printf(...) aus. Ersetze die kursiv, fett dargestellten Werte im Logbuch durch Variablen, welche du selber definieren musst.\nReise Report – Takeshi, Codename ShadowFox\nDatum der Abreise: 26. Juli 2025\nMission: Code-Review\nStartpunkt: Lausanne\nZielort: St. Gallen\nAbfahrt: 06:14 Uhr\nAnkunft: 09:07 Uhr\nZwischenhalte: 5\nReisekosten: 51.80 CHF\nShadowFox nutzte die 1. Klasse am 26. Juli 2025, um sich auf den anstehenden Code-Review vorzubereiten. Mit einem Akku-Ladestand von 92% und 2 mitgeführten Laptops war er bestens gerüstet. Die Mission wurde erfolgreich abgeschlossen. Die Reisekosten sind in CHF.\nAnforderungen:\nVerwende sinnvolle Datentypen (String, int, double, boolean) Nutze printf mit Formatangaben wie %.2f, %d, %s, %% Achte auf Lesbarkeit und saubere Struktur Im zur Übung gehörendem Source kannst Du die Änderung an folgender Stelle machen:\nsrc\\main\\java\\ch\\itninja\\labs\\basicexercises\\TravelReport.java:\n1 2 3 4 public static void printTravelReport() { // IT-Ninja: Füge hier Deinen Code ein: } Beispiel:\nEingabe:\n1 TravelReport.printTravelReport(); Ausgabe:\n1 2 3 4 5 6 7 8 9 10 11 Reise Report – Takeshi, Codename ShadowFox Datum der Abreise: 26. Juli 2025 Mission: Code-Review Startpunkt: Lausanne Zielort: St. Gallen Abfahrt: 06:14 Uhr Ankunft: 09:07 Uhr Zwischenhalte: 5 Reisekosten: 51.80 CHF ShadowFox nutzte die 1. Klasse am 26. Juli 2025, um sich auf die anstehende Code-Review vorzubereiten. Mit einem Akku-Ladestand von 92% und 2 mitgeführten Laptops war er bestens gerüstet. Die Mission wurde erfolgreich abgeschlossen. Die Reisekosten sind in CHF. ","categories":"","description":"Mit diesen Übungen kannst du dein Wissen über Variablen und primitive Datentypen vertiefen.\n","excerpt":"Mit diesen Übungen kannst du dein Wissen über Variablen und primitive …","ref":"/labs/02_java/03_java-grundlagen/04_variables-and-types/","tags":"","title":"Java Exercises - Variablen und primitive Datentypen"},{"body":"Ziele Ich weiss, wie ich HTML-Dokumente strukturieren kann. Ich weiss, wie ich mit HTML Texte formatieren kann. Ich weiss, wie ich Links und Bilder in eine Webseite einbetten kann. Ich weiss, wie ich geordnete/sortierte Listen erstellen kann. Ich weiss, wie ich ungeordnete/unsortierte Listen erstellen kann. Ich weiss, was Definitionslisten sind und wie und wozu ich sie einsetzen kann. Überschrift (Heading) Du hast bereits gelernt, dass du \u003ch1\u003e für Überschriften verwenden kannst. Oft hast du aber eine Überschrift für die Seite und danach weitere Überschriften, die diesem Titel untergeordnet sind. Wie in einem Word-Dokument kannst du auch in HTML Überschriften hierarchisch verschachteln. Das geht so:\n1 2 3 4 5 6 7 8 \u003ch1\u003eHeading 1\u003c/h1\u003e \u003cp\u003eHello\u003c/p\u003e \u003ch2\u003eHeading 2\u003c/h2\u003e \u003ch3\u003eHeading 3\u003c/h3\u003e \u003ch4\u003eHeading 4\u003c/h4\u003e \u003ch5\u003eHeading 5\u003c/h5\u003e \u003ch6\u003eHeading 6\u003c/h6\u003e \u003cp\u003eHello\u003c/p\u003e Dies führt zu folgendem Ergebnis:\nEs gibt also Tags für Überschriften erster bis sechste Stufe. Grundsätzlich gilt; je kleiner die Zahl, desto grösser wird die Überschrift dargestellt. Das obige Ergebnis zeigt, wie Überschriften per Default formatiert werden. Du kannst das Styling dieser Überschriften selbstverständlich anpassen (kommt im CSS-Teil).\nAbsätze (Paragraf) Du hast bereits erfahren, dass Zeilenumbrüche in HTML keine Wirkung haben. Möchtest du eine neue Zeile einfügen, könnte dir das \u003cbr/\u003e-Tag weiterhelfen. Besser ist aber, wenn du den Text, der zusammengehört, auch entsprechend gruppierst: Das kannst du mit dem \u003cp\u003e-Tag bewerkstelligen. Der Text, der innerhalb dieses Tags steht, wird im gleichen Abschnitt dargestellt. Wenn ein weiteres p-Element hinzugefügt wird, wird dieses mit einem Leerschlag vom vorherigen getrennt. Das lässt sich im folgenden Beispiel gut sehen:\n1 2 3 4 5 \u003ch2\u003eTitle\u003c/h2\u003e This is one line. This the second one. \u003cbr /\u003e And the third one. \u003cp\u003eAnd this is inside a paragraph.\u003c/p\u003e \u003cp\u003eThis too.\u003c/p\u003e Title This is one line. This the second one. And the third one.\nAnd this is inside a paragraph.\nThis too.\nBeachte hierbei, dass aufeinanderfolgende \u003cp\u003e-Tags mehr Leerraum erzeugen als \u003cbr/\u003e-Tags.\nText formatieren Du wirst in die Situation kommen, in der du einen bestimmten Teil eines Textes fett oder kursiv formatieren musst.\nDas kannst du mit HTML sehr einfach bewerkstelligen, dafür gibt es nämlich spezielle Tags:\n1 2 \u003cp\u003e\u003cstrong\u003eHeard\u003c/strong\u003e about the new restaurant called\u003cem\u003eKarma?\u003c/em\u003e\u003c/p\u003e \u003cp\u003eThere's \u003cb\u003eno menu\u003c/b\u003e: You get what you \u003ci\u003edeserve\u003c/i\u003e.\u003c/p\u003e Um also einen bestimmten Text fett darzustellen, kannst du diesen in ein \u003cstrong\u003e- oder \u003cb\u003e-Element einbinden. Beide Tags bezwecken im Prinzip genau das Gleiche, bedeuten aber nicht das Gleiche: \u003cb\u003e-Elemente sind einfach fett-gedruckt, während \u003cstrong\u003e-Elemente betont sein sollen. \u003cstrong\u003e soll dem fett-gedruckten Wort also mehr Ausdruck verleihen. Dieser Unterschied ist vor allem für den Einsatz von Screenreadern wichtig. Mit einem eigenen Styling (kommt im CSS-Teil) könntest du \u003cstrong\u003e-Elemente z.B. auch grösser oder rot darstellen. Mit einem \u003cb\u003e-Element sagt man im Prinzip nur, dass der Text fett-gedruckt sein soll.\nEinen Text kursiv darstellen kannst du mit \u003ci\u003e beziehungsweise \u003cem\u003e. Das Pendant zu \u003cb\u003e ist \u003ci\u003e (italic), wobei das von \u003cstrong\u003e \u003cem\u003e (emphasis = Betonung) ist.\nDas obige Beispiel wird gerendert wie folgt:\nHeard about the new restaurant called Karma? There's no menu: You get what you deserve. Bitte beachte: Text zu formatieren ist Styling. Styling wiederum wird normalerweise durch CSS bewerkstelligt, nicht von HTML.\nLinks und Bilder Eines der wichtigsten Konzepte in HTML sind Links auf andere Seiten. Links werden mit a-Elementen (anchor) realisiert. Ein Link kann wie folgt erstellt werden:\n1 \u003ca href=\"https://labs.it-ninjas.ch/\"\u003eHome\u003c/a\u003e Probier das einmal aus.\nDu wirst einen blauen und unterstrichenen Text “Home” sehen. \u003ca\u003e ist der Tag, der generell für Hyperlinks verwendet wird. href ist ein Attribut des a-Tags, mit dem die URL des Links spezifiziert wird. In unserem Fall ist https://labs.it-ninjas.ch/ die URL, die beim Klick aufgerufen wird. Home ist der Text, der dem User angezeigt wird.\nÄhnlich lässt sich auch ein Bild aus dem Internet einbinden:\n1 2 3 4 5 \u003cimg src=\"https://it-ninjas.ch/img/png/Ninja%20Elements_ninja_phone.png\" alt=\"IT Ninjas\" width=\"300\" /\u003e Für die Einbindung von Bildern wird das \u003cimg/\u003e-Tag verwendet. Das \u003cimg/\u003e-Tag ist ein Tag, welches keinen Inhalt zwischen Opening- und Closing-Tag hat. HTML bietet auch die Möglichkeit einer verkürzten Schreibweise: Statt \u003cimg src=\"\"\u003e\u003c/img\u003e kann man auch \u003cimg src=\"...\"/\u003e schreiben. Das gilt für alle Elemente, die per default keinen Inhalt haben.\nDas wichtigste Attribut im img-Tag ist src (source = Quelle). Als src wird ein relativer oder absoluter Pfad zu einem Bild erwartet, welcher sowohl auf ein Bild auf dem eigenen PC als auch im Internet zeigen kann. Vergiss nicht, bei absoluten Pfaden auch das Protokoll (also https://) anzugeben. Nicht zwingend aber erwartet wird das alt-Attribut (alternative). Dieser Text wird angezeigt, wenn das Bild nicht geladen werden konnte. Völlig optional sind hingegen Attribute wie width oder height, welche die Breite und Höhe des Bildes festlegen. Diese Grössen werden aber besser mit CSS spezifiziert, da CSS genauere Spezifikationen zulässt (also nicht nur in ‘Pixel’ sondern auch anderen Einheiten).\nWenn du möchtest, dass man beim Klick auf ein Bild weitergeleitet wird, kannst du dein Bild in ein \u003ca\u003e-Element einbinden:\n1 2 3 4 5 6 \u003ca href=\"https://it-ninjas.ch/\"\u003e \u003cimg src=\"https://it-ninjas.ch/img/png/Ninja%20Elements_ninja_phone.png\" alt=\"IT Ninjas\" /\u003e \u003c/a\u003e Listen In HTML gibt es verschiedene Arten, um Aufzählungen darzustellen. Wir schauen uns die folgenden Listenarten an:\nungeordnete Liste (unordered lists, Bullet Point-Listen), geordnete Listen (ordered lists, nummerierte Listen) und Definitionslisten (definition list) Eine Bullet-Point-Liste kann man mit einer unsortierten Liste (unordered list) kreieren:\n1 2 3 4 5 6 7 8 9 \u003ch4\u003eWhat do you do in case of emergency?\u003c/h4\u003e \u003cul\u003e \u003cli\u003egit commit -m \"message\"\u003c/li\u003e \u003cli\u003egit push\u003c/li\u003e \u003cli\u003eLeave the building.\u003c/li\u003e \u003c/ul\u003e Möchtest du hingegen eine Nummerierung, musst du eine sortierte Liste (ordered list) verwenden:\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u003ch4\u003eMost Difficult Programming Languages\u003c/h4\u003e \u003col\u003e \u003cli\u003eBrainf*ck\u003c/li\u003e \u003cli\u003eCow\u003c/li\u003e \u003cli\u003eIntercal\u003c/li\u003e \u003cli\u003eMalbolge\u003c/li\u003e \u003cli\u003eWhitespace\u003c/li\u003e \u003c/ol\u003e Die obigen Beispiele würden in der Praxis aussehen wie folgt:\nWhat do you do in case of emergency? git commit -m “message” git push Leave the building Most Difficult Programming Languages Brainf*ck Cow Intercal Malbolge Whitespace Definitionslisten sind eine weitere Art der Aufzählung. Diese Art von Liste wird zwar nicht oft verwendet, kann aber hilfreich für ein Glossar oder Ähnliches sein. Schaue dir hierfür folgendes Beispiel an:\n1 2 3 4 5 6 7 8 \u003ch2\u003eGlossary\u003c/h4\u003e \u003cdl\u003e \u003cdt\u003ebuffoonish\u003c/dt\u003e \u003cdd\u003elike a clown \u003c/dd\u003e \u003cdt\u003eheyday\u003c/dt\u003e \u003cdd\u003ethe period of greatest prosperity or productivity\u003c/dd\u003e \u003c/dl\u003e Glossary buffoonish like a clown heyday the period of greatest prosperity or productivity ","categories":"","description":"Modul #F3 - HTML und CSS - Nützliche HTML-Tags\n","excerpt":"Modul #F3 - HTML und CSS - Nützliche HTML-Tags\n","ref":"/docs/03_web/02_html_css/04_weitere-tags/","tags":"","title":"Weitere HTML-Tags"},{"body":"Ziele Ich weiss, wie ich HTML-Dokumente strukturieren kann. Ich weiss, wie ich mit HTML Texte formatieren kann. Ich weiss, wie ich Links und Bilder in eine Webseite einbetten kann. Ich weiss, wie ich geordnete/sortierte Listen erstellen kann. Ich weiss, wie ich ungeordnete/unsortierte Listen erstellen kann. Ich weiss, was Definitionslisten sind und wie und wozu ich sie einsetzen kann. Überschrift (Heading) Du hast bereits gelernt, dass du \u003ch1\u003e für Überschriften verwenden kannst. Oft hast du aber eine Überschrift für die Seite und danach weitere Überschriften, die diesem Titel untergeordnet sind. Wie in einem Word-Dokument kannst du auch in HTML Überschriften hierarchisch verschachteln. Das geht so:\n1 2 3 4 5 6 7 8 \u003ch1\u003eHeading 1\u003c/h1\u003e \u003cp\u003eHello\u003c/p\u003e \u003ch2\u003eHeading 2\u003c/h2\u003e \u003ch3\u003eHeading 3\u003c/h3\u003e \u003ch4\u003eHeading 4\u003c/h4\u003e \u003ch5\u003eHeading 5\u003c/h5\u003e \u003ch6\u003eHeading 6\u003c/h6\u003e \u003cp\u003eHello\u003c/p\u003e Dies führt zu folgendem Ergebnis:\nEs gibt also Tags für Überschriften erster bis sechste Stufe. Grundsätzlich gilt; je kleiner die Zahl, desto grösser wird die Überschrift dargestellt. Das obige Ergebnis zeigt, wie Überschriften per Default formatiert werden. Du kannst das Styling dieser Überschriften selbstverständlich anpassen (kommt im CSS-Teil).\nAbsätze (Paragraf) Du hast bereits erfahren, dass Zeilenumbrüche in HTML keine Wirkung haben. Möchtest du eine neue Zeile einfügen, könnte dir das \u003cbr/\u003e-Tag weiterhelfen. Besser ist aber, wenn du den Text, der zusammengehört, auch entsprechend gruppierst: Das kannst du mit dem \u003cp\u003e-Tag bewerkstelligen. Der Text, der innerhalb dieses Tags steht, wird im gleichen Abschnitt dargestellt. Wenn ein weiteres p-Element hinzugefügt wird, wird dieses mit einem Leerschlag vom vorherigen getrennt. Das lässt sich im folgenden Beispiel gut sehen:\n1 2 3 4 5 \u003ch2\u003eTitle\u003c/h2\u003e This is one line. This the second one. \u003cbr /\u003e And the third one. \u003cp\u003eAnd this is inside a paragraph.\u003c/p\u003e \u003cp\u003eThis too.\u003c/p\u003e Title This is one line. This the second one. And the third one.\nAnd this is inside a paragraph.\nThis too.\nBeachte hierbei, dass aufeinanderfolgende \u003cp\u003e-Tags mehr Leerraum erzeugen als \u003cbr/\u003e-Tags.\nText formatieren Du wirst in die Situation kommen, in der du einen bestimmten Teil eines Textes fett oder kursiv formatieren musst.\nDas kannst du mit HTML sehr einfach bewerkstelligen, dafür gibt es nämlich spezielle Tags:\n1 2 \u003cp\u003e\u003cstrong\u003eHeard\u003c/strong\u003e about the new restaurant called\u003cem\u003eKarma?\u003c/em\u003e\u003c/p\u003e \u003cp\u003eThere's \u003cb\u003eno menu\u003c/b\u003e: You get what you \u003ci\u003edeserve\u003c/i\u003e.\u003c/p\u003e Um also einen bestimmten Text fett darzustellen, kannst du diesen in ein \u003cstrong\u003e- oder \u003cb\u003e-Element einbinden. Beide Tags bezwecken im Prinzip genau das Gleiche, bedeuten aber nicht das Gleiche: \u003cb\u003e-Elemente sind einfach fett-gedruckt, während \u003cstrong\u003e-Elemente betont sein sollen. \u003cstrong\u003e soll dem fett-gedruckten Wort also mehr Ausdruck verleihen. Dieser Unterschied ist vor allem für den Einsatz von Screenreadern wichtig. Mit einem eigenen Styling (kommt im CSS-Teil) könntest du \u003cstrong\u003e-Elemente z.B. auch grösser oder rot darstellen. Mit einem \u003cb\u003e-Element sagt man im Prinzip nur, dass der Text fett-gedruckt sein soll.\nEinen Text kursiv darstellen kannst du mit \u003ci\u003e beziehungsweise \u003cem\u003e. Das Pendant zu \u003cb\u003e ist \u003ci\u003e (italic), wobei das von \u003cstrong\u003e \u003cem\u003e (emphasis = Betonung) ist.\nDas obige Beispiel wird gerendert wie folgt:\nHeard about the new restaurant called Karma? There's no menu: You get what you deserve. Bitte beachte: Text zu formatieren ist Styling. Styling wiederum wird normalerweise durch CSS bewerkstelligt, nicht von HTML.\nLinks und Bilder Eines der wichtigsten Konzepte in HTML sind Links auf andere Seiten. Links werden mit a-Elementen (anchor) realisiert. Ein Link kann wie folgt erstellt werden:\n1 \u003ca href=\"https://labs.it-ninjas.ch/\"\u003eHome\u003c/a\u003e Probier das einmal aus.\nDu wirst einen blauen und unterstrichenen Text “Home” sehen. \u003ca\u003e ist der Tag, der generell für Hyperlinks verwendet wird. href ist ein Attribut des a-Tags, mit dem die URL des Links spezifiziert wird. In unserem Fall ist https://labs.it-ninjas.ch/ die URL, die beim Klick aufgerufen wird. Home ist der Text, der dem User angezeigt wird.\nÄhnlich lässt sich auch ein Bild aus dem Internet einbinden:\n1 2 3 4 5 \u003cimg src=\"https://it-ninjas.ch/img/png/Ninja%20Elements_ninja_phone.png\" alt=\"IT Ninjas\" width=\"300\" /\u003e Für die Einbindung von Bildern wird das \u003cimg/\u003e-Tag verwendet. Das \u003cimg/\u003e-Tag ist ein Tag, welches keinen Inhalt zwischen Opening- und Closing-Tag hat. HTML bietet auch die Möglichkeit einer verkürzten Schreibweise: Statt \u003cimg src=\"\"\u003e\u003c/img\u003e kann man auch \u003cimg src=\"...\"/\u003e schreiben. Das gilt für alle Elemente, die per default keinen Inhalt haben.\nDas wichtigste Attribut im img-Tag ist src (source = Quelle). Als src wird ein relativer oder absoluter Pfad zu einem Bild erwartet, welcher sowohl auf ein Bild auf dem eigenen PC als auch im Internet zeigen kann. Vergiss nicht, bei absoluten Pfaden auch das Protokoll (also https://) anzugeben. Nicht zwingend aber erwartet wird das alt-Attribut (alternative). Dieser Text wird angezeigt, wenn das Bild nicht geladen werden konnte. Völlig optional sind hingegen Attribute wie width oder height, welche die Breite und Höhe des Bildes festlegen. Diese Grössen werden aber besser mit CSS spezifiziert, da CSS genauere Spezifikationen zulässt (also nicht nur in ‘Pixel’ sondern auch anderen Einheiten).\nWenn du möchtest, dass man beim Klick auf ein Bild weitergeleitet wird, kannst du dein Bild in ein \u003ca\u003e-Element einbinden:\n1 2 3 4 5 6 \u003ca href=\"https://it-ninjas.ch/\"\u003e \u003cimg src=\"https://it-ninjas.ch/img/png/Ninja%20Elements_ninja_phone.png\" alt=\"IT Ninjas\" /\u003e \u003c/a\u003e Listen In HTML gibt es verschiedene Arten, um Aufzählungen darzustellen. Wir schauen uns die folgenden Listenarten an:\nungeordnete Liste (unordered lists, Bullet Point-Listen), geordnete Listen (ordered lists, nummerierte Listen) und Definitionslisten (definition list) Eine Bullet-Point-Liste kann man mit einer unsortierten Liste (unordered list) kreieren:\n1 2 3 4 5 6 7 8 9 \u003ch4\u003eWhat do you do in case of emergency?\u003c/h4\u003e \u003cul\u003e \u003cli\u003egit commit -m \"message\"\u003c/li\u003e \u003cli\u003egit push\u003c/li\u003e \u003cli\u003eLeave the building.\u003c/li\u003e \u003c/ul\u003e Möchtest du hingegen eine Nummerierung, musst du eine sortierte Liste (ordered list) verwenden:\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u003ch4\u003eMost Difficult Programming Languages\u003c/h4\u003e \u003col\u003e \u003cli\u003eBrainf*ck\u003c/li\u003e \u003cli\u003eCow\u003c/li\u003e \u003cli\u003eIntercal\u003c/li\u003e \u003cli\u003eMalbolge\u003c/li\u003e \u003cli\u003eWhitespace\u003c/li\u003e \u003c/ol\u003e Die obigen Beispiele würden in der Praxis aussehen wie folgt:\nWhat do you do in case of emergency? git commit -m “message” git push Leave the building Most Difficult Programming Languages Brainf*ck Cow Intercal Malbolge Whitespace Definitionslisten sind eine weitere Art der Aufzählung. Diese Art von Liste wird zwar nicht oft verwendet, kann aber hilfreich für ein Glossar oder Ähnliches sein. Schaue dir hierfür folgendes Beispiel an:\n1 2 3 4 5 6 7 8 \u003ch2\u003eGlossary\u003c/h4\u003e \u003cdl\u003e \u003cdt\u003ebuffoonish\u003c/dt\u003e \u003cdd\u003elike a clown \u003c/dd\u003e \u003cdt\u003eheyday\u003c/dt\u003e \u003cdd\u003ethe period of greatest prosperity or productivity\u003c/dd\u003e \u003c/dl\u003e Glossary buffoonish like a clown heyday the period of greatest prosperity or productivity ","categories":"","description":"Modul #F3 - HTML und CSS - Nützliche HTML-Tags\n","excerpt":"Modul #F3 - HTML und CSS - Nützliche HTML-Tags\n","ref":"/de/docs/03_web/02_html_css/04_weitere-tags/","tags":"","title":"Weitere HTML-Tags"},{"body":"In dieser Aufgabe wird die Zusammenarbeit an einem gemeinsamen Projekt ohne Merge-Konflikte simuliert. Dazu führt jedes Team-Mitglied die nachfolgenden Aktionen auf seinem Rechner aus. Der Lead Developer legt fest, wer welchen Teil in welcher Datei ändern soll.\nDie Schritte 1 bis 5 sind Einzelaufgaben, die jeder Ninja selbständig lösen muss/kann. Schritt 6 ist eine Teamaufgabe und muss ebenfalls für jeden Feature-Branch ausgeführt werden.\nSchritt 1: Neuen Branch auschecken Starte IntelliJ. Wechsle zum ersten Projekt (Menu › File › Recent Projects). Aktualisiere den lokalen Stand von Git (Menu › Git › Fetch). Checke den oben erstellten Branch aus (Menu › Git › Branches…). Schritt 2: Dateien mit ausschliessen Das Verzeichnis .idea soll von der Versionsverwaltung ausgeschlossen werden. Nutze dazu den passenden Eintrag aus dem Git-Menu.\nSchritt 3: Unterschiedliche Dateien bearbeiten Jedes Teammitglied bekommt vom Lead-Developer eine andere Datei für Änderungen zugewiesen bzw. wählt eine Datei aus. Es werden nur kleine Änderungen vorgenommen, wie z.B.\nzusätzliche Ausgabe über System.out.println, Auslagern von Code in eine eigene Methode, oder kleinere Verbesserungen. Durch die Änderungen sollten keine zusätzlichen Fehler im Programm eingebaut werden, es können aber bekannte Fehler behoben werden. Für die Änderungen sollte nicht mehr als eine halbe Stunde Zeit benötigt werden.\nSchritt 4: Änderungen auf den Branch pushen Nun sollen die Änderungen committed und auf den remote Feature-Branch gepusht werden. Gehe dazu in IntelliJ auf\nGit › Commit im Menu oder Git › Push über das Kontextmenu auf dem Projekt. Wähle unter Changes die geänderten Dateien aus und übertrage sie mit Commit and Push… in das lokale und remote Git-Repository.\nSchritt 5: Pull Request erstellen Gehe in Bitbucket (Browser) auf den FeatureBranch und\nerstelle einen Pull Request (Pull Requests oder Pull-Anfragen in der Seitenleiste), achte dabei darauf, das du develop als Zielbranch ausgewählt hast und kontrolliere den Pull Request auf Konflikte. Schritt 6: Zusammenführen Dieser Schritt muss mindestens vom Besitzer des Feature-Branches und vom Lead Developer gemeinsam bearbeitet werden. Es wird aber empfohlen, dass jeweils alle Team-Mitglied teilnehmen, um den Merge-Vorgang in Bitbucket zu üben.\nRuft den Pull Request in Bitbucket auf. Vergleicht die Codeänderungen des aktuellen Pull Requests zum Stand von develop via diff. Fügt mindestens ein Team-Mitglied als Prüfer hinzu. (Achtung das kann nicht der Ersteller des Pull Requests sein!) Genehmigt nun als Prüfer den Pull Request (grüner Button). Mergt den Pull Request (sofern dies nicht automatisch startet). ","categories":"","description":"Aufgabe Zusammenarbeit an einem Projekt ohne Merge-Konflikte [Git Vertiefung](../../../../docs/04_git/02_vertiefung/02_zusammenarbeit)\n","excerpt":"Aufgabe Zusammenarbeit an einem Projekt ohne Merge-Konflikte [Git …","ref":"/labs/04_git/02_vertiefung/03_collaboration/","tags":"","title":"Aufgabe: Arbeiten im Team an einem Projekt"},{"body":"In dieser Aufgabe wird die Zusammenarbeit an einem gemeinsamen Projekt ohne Merge-Konflikte simuliert. Dazu führt jedes Team-Mitglied die nachfolgenden Aktionen auf seinem Rechner aus. Der Lead Developer legt fest, wer welchen Teil in welcher Datei ändern soll.\nDie Schritte 1 bis 5 sind Einzelaufgaben, die jeder Ninja selbständig lösen muss/kann. Schritt 6 ist eine Teamaufgabe und muss ebenfalls für jeden Feature-Branch ausgeführt werden.\nSchritt 1: Neuen Branch auschecken Starte IntelliJ. Wechsle zum ersten Projekt (Menu › File › Recent Projects). Aktualisiere den lokalen Stand von Git (Menu › Git › Fetch). Checke den oben erstellten Branch aus (Menu › Git › Branches…). Schritt 2: Dateien mit ausschliessen Das Verzeichnis .idea soll von der Versionsverwaltung ausgeschlossen werden. Nutze dazu den passenden Eintrag aus dem Git-Menu.\nSchritt 3: Unterschiedliche Dateien bearbeiten Jedes Teammitglied bekommt vom Lead-Developer eine andere Datei für Änderungen zugewiesen bzw. wählt eine Datei aus. Es werden nur kleine Änderungen vorgenommen, wie z.B.\nzusätzliche Ausgabe über System.out.println, Auslagern von Code in eine eigene Methode, oder kleinere Verbesserungen. Durch die Änderungen sollten keine zusätzlichen Fehler im Programm eingebaut werden, es können aber bekannte Fehler behoben werden. Für die Änderungen sollte nicht mehr als eine halbe Stunde Zeit benötigt werden.\nSchritt 4: Änderungen auf den Branch pushen Nun sollen die Änderungen committed und auf den remote Feature-Branch gepusht werden. Gehe dazu in IntelliJ auf\nGit › Commit im Menu oder Git › Push über das Kontextmenu auf dem Projekt. Wähle unter Changes die geänderten Dateien aus und übertrage sie mit Commit and Push… in das lokale und remote Git-Repository.\nSchritt 5: Pull Request erstellen Gehe in Bitbucket (Browser) auf den FeatureBranch und\nerstelle einen Pull Request (Pull Requests oder Pull-Anfragen in der Seitenleiste), achte dabei darauf, das du develop als Zielbranch ausgewählt hast und kontrolliere den Pull Request auf Konflikte. Schritt 6: Zusammenführen Dieser Schritt muss mindestens vom Besitzer des Feature-Branches und vom Lead Developer gemeinsam bearbeitet werden. Es wird aber empfohlen, dass jeweils alle Team-Mitglied teilnehmen, um den Merge-Vorgang in Bitbucket zu üben.\nRuft den Pull Request in Bitbucket auf. Vergleicht die Codeänderungen des aktuellen Pull Requests zum Stand von develop via diff. Fügt mindestens ein Team-Mitglied als Prüfer hinzu. (Achtung das kann nicht der Ersteller des Pull Requests sein!) Genehmigt nun als Prüfer den Pull Request (grüner Button). Mergt den Pull Request (sofern dies nicht automatisch startet). ","categories":"","description":"Aufgabe Zusammenarbeit an einem Projekt ohne Merge-Konflikte [Git Vertiefung](../../../../docs/04_git/02_vertiefung/02_zusammenarbeit)\n","excerpt":"Aufgabe Zusammenarbeit an einem Projekt ohne Merge-Konflikte [Git …","ref":"/de/labs/04_git/02_vertiefung/03_collaboration/","tags":"","title":"Aufgabe: Arbeiten im Team an einem Projekt"},{"body":"Ziele in diesem Abschnitt sollen die Lösungen zu den (optionalen) NgRx-Labs genauer beleuchtet werden. Wenn du die Labs zu NgRx noch nicht gemacht hast, musst du dir diese Dokumentation nicht anschauen.\nWir gehen hier Schritt für Schritt die Aufgaben des NgRx-Labs durch, um zum Einen den Weg der Lösungsfindung genauer anzuschauen, zum Anderen aber auch, um potenzielle Unklarheiten aus dem Weg zu räumen, die bei der Erarbeitung der Aufgabe aufgekommen sein könnten.\nAufgabe 1 - Aufgabenstellung Im Rahmen der ersten Aufgabe des Labs galt es, in einer neuen Angular-Applikation mit NgRx einen Counter zu erstellen, mit dem man:\nDen Wert des Counters inkrementieren kann (Wert + 1) Den Wert des Counters dekrementieren kann (Wert - 1) Den Wert des Counters zurücksetzen kann (Wert auf 0) Die Umsetzung dieser Anforderungen gehen wir nun Stück für Stück durch. Wir beginnen mit den Actions.\nAufgabe 1- Actions erstellen Als erstes gilt es, die jeweiligen Actions für die drei oben beschriebenen Anwendungsfälle zu definieren. Für die Actions solltest du eine Datei counter.actions.ts erstellen, in der du die Actions definieren kannst. Die fertigen Actions sehen aus wie folgt:\n1 2 3 4 5 6 7 8 9 10 11 import { createAction } from \"@ngrx/store\"; export enum ActionTypes { INCREMENT = \"[Counter Component] Increment\", DECREMENT = \"[Counter Component] Decrement\", RESET = \"[Counter Component] Reset\", } export const increment = createAction(ActionTypes.INCREMENT); export const decrement = createAction(ActionTypes.DECREMENT); export const reset = createAction(ActionTypes.RESET); Gehen wir das einmal durch: In der Aufgabenstellung war es vorgesehen, dass die verschiedenen Actions in ein Enum ausgelagert werden. So sind diese direkt alle über die Variable ActionTypes verfügbar. Dafür kannst du einfach die einzelnen Actions in ein Enum wrappen, wie es im Code oben gemacht wurde. Der String nach dem = wird jeweils hinzugefügt, um die Action in Kontext zur Applikation zu stellen. In diesem Fall sagen die Strings also aus, dass im CounterComponent der Wert entweder inkrementiert, dekrementiert oder resettet wurde.\nNun haben wir bereits das Grundgerüst für die Actions, diese können aber noch nicht verwendet werden. Um das zu ändern, müssen wir diese zu exportierbaren Actions machen, was im zweiten Abschnitt des Codebeispiels oben passiert. Für jede Action, die wir definieren wollen, müssen wir eine entsprechende exportierbare Konstante erstellen. Relevant ist hierbei das Keyword createAction, welches die Actions erst wirklich als solche definiert.\nHaben wir nun für jede Action eine entsprechende Definition vorgenommen, können wir mit dem nächsten Schritt fortfahren; den Reducers.\nAufgabe 1 - Reducers erstellen Damit nun beim Aufrufen der Actions, die wir definiert haben, auch etwas passiert, müssen wir die für die Actions entsprechenden Reducers erstellen. Der dazugehörige Code-Block in der Datei counter.reducer.ts, die du erstellt haben solltest, sieht aus wie folgt:\n1 2 3 4 5 6 7 8 9 10 11 import { createReducer, on } from \"@ngrx/store\"; import { increment, decrement, reset } from \"./counter.actions\"; export const initialState = 0; export const counterReducer = createReducer( initialState, on(increment, (state) =\u003e state + 1), on(decrement, (state) =\u003e state - 1), on(reset, (state) =\u003e 0), ); Gehen wir das mal Schritt für Schritt durch: Auf der vierten Zeile wird eine exportierbare Konstante initialState definiert. Diese gibt den Ausgangswert unseres Counters an, in diesem Fall 0. Interessant wird es aber ab Zeile 6: Hier wird eine exportierbare Konstante counterReducer definiert, welche dann die eigentlichen Reducer mit der Funktion createReducer() erstellt. Die Funktion nimmt (in unserem Fall) insgesamt 4 Argumente entgegen:\nDen initialen Zustand Den Reducer für das Inkrementieren des Counters Den Reducer für das Dekrementieren des Counters Den Reducer für das Resetten des Counters Der initialState wird hierbei als Ausgangswert für den Counter mitgegeben. Die jeweiligen Reducer entsprechen jeweils den Actions, die wir in der Datei counter.actions.ts definiert haben. Die Definition funktioniert jeweils wie folgt: Der Reducer wird in die Funktion on() verpackt. Als erstes Argument wird hierbei die Action angegeben, die als Auslöser für den Reducer fungiert. (Wie du auf Zeile 1 sehen kannst, werden die jeweiligen Actions direkt aus counter.actions importiert.) Insofern also eine der Actions getriggert wird, wird als nächstes der state ausgelesen. Dieser beschreibt den derzeitigen Zustand des Counters, den wir mit den Reducers mutieren wollen. Zuletzt wird dann auch schon die entsprechende Mutation durchgeführt; Im Falle der Inkrementierung wird der state um 1 erhöht, im Falle der Dekrementierung um 1 verringert und im Falle des Zurücksetzens auf 0 gesetzt.\nDas heisst also: Prinzipiell wartet der Reducer ab, bis eine bestimmte Action aufgerufen wird und mutiert dann entsprechend den state.\nAufgabe 1 - Component Der nächste Schritt nach dem Erstellen der Reducers ist es, den entsprechenden Component zu erstellen, von dem aus die Logik für den Counter ausgelöst werden kann. Der Component, den du im Rahmen der Aufgabe erstellt haben solltest, sollte aussehen wie folgt:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import { Component } from \"@angular/core\"; import { Store } from \"@ngrx/store\"; import { Observable } from \"rxjs\"; import { increment, decrement, reset } from \"../counter.actions\"; import { AsyncPipe } from \"@angular/common\"; @Component({ selector: \"app-my-counter\", templateUrl: \"./my-counter.component.html\", imports: [AsyncPipe], }) export class MyCounterComponent { count$: Observable\u003cnumber\u003e; constructor(private store: Store\u003c{ count: number }\u003e) { this.count$ = store.select(\"count\"); } increment() { this.store.dispatch(increment()); } decrement() { this.store.dispatch(decrement()); } reset() { this.store.dispatch(reset()); } } 1 2 3 4 5 6 7 \u003cbutton (click)=\"increment()\"\u003eIncrement\u003c/button\u003e \u003cdiv\u003eCurrent Count: {{ count$ | async }}\u003c/div\u003e \u003cbutton (click)=\"decrement()\"\u003eDecrement\u003c/button\u003e \u003cbutton (click)=\"reset()\"\u003eReset Counter\u003c/button\u003e Gehen wir auch diesen Code mal Schritt für Schritt durch: Der Component ist grundsätzlich aufgebaut wie jeder andere. Er besteht aus einer html-Datei, einer (s)css-Datei, einer ts-Datei und einer spec.ts-Datei und beinhält einen Constructor. Interessant wird es ab Zeile 11: Dort wird ein Obvservable count$ (achte hierbei auf das $ am Ende der Variable =\u003e Best Practice bei der Benennung von Observables!) definiert, welches uns anschliessend zur Darstellung des Counts innerhalb des Templates nutzen wird. Im Constructor auf Zeile 13 wird eine private Variable store instanziert, welche die Zahlen-Variable count in diesem erstellt.\nDer Store dient in NgRx als “Eimer” für die States und ist applikationsweit zugänglich. Diese States werden dann auf Befehl der Actions von den Reducern mutiert.\nAuf Zeile 14 wird dann direkt beim Erstellen des Components dem Observable count$ der derzeitige Zustand der Variable count aus dem Store zugeschrieben, welcher zu diesem Zeitpunkt beim initalState, also bei 0 liegen sollte. Hiermit ist die Vorbereitung auch schon erledigt, womit wir nun zur Component-Logik weiterkönnen. In unserem Fall mussten 3 Funktionen definiert werden:\nincrement() decrement() reset() Die Logik in diesen gehen wir nun ebenfalls kurz durch. Innerhalb der Funktionen wird der im Constructor instanzierte Store genutzt und dessen Methode dispatch() aufgerufen. Diese Methode wird verwendet, um im Store eine Action auszulösen. In unseren 3 Fällen wären das die Actions increment(), decrement() und reset().\nAlles was nun noch bleibt, ist das Template (siehe oben). Dieses besteht aus 4 Bestandteilen:\nJeweils ein button-Element pro Funktion Ein div-Element, welches den derzeitigen Zustand des Counters anzeigt. In den jeweiligen Buttons muss jeweils lediglich das (click)-Event abgehört werden, woraufhin die jeweilige Funktion aufgerufen wird.\nAufgabe 1 - app.config.ts anpassen Seit in Angular standardmässig standalone-Components verwendet werden und somit normalerweise kein AppModule mehr exisitert, muss für das korrekte Funktionieren der Reducer eine Anpassung in der app.config.ts-Datei gemacht werden, nämlich die folgende:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import { ApplicationConfig, importProvidersFrom, provideZoneChangeDetection, } from \"@angular/core\"; import { provideRouter } from \"@angular/router\"; import { routes } from \"./app.routes\"; import { provideStore, StoreModule } from \"@ngrx/store\"; import { counterReducer } from \"./aufgabe-1/counter.reducers\"; export const appConfig: ApplicationConfig = { providers: [ provideZoneChangeDetection({ eventCoalescing: true }), provideRouter(routes), provideStore(), importProvidersFrom(StoreModule.forRoot({ count: counterReducer })), ], }; Für uns relevant sind die beiden letzten provider in der appConfig. Zum einen muss der Store provided werden, zum anderen müssen aber auch Provider für die Reducer importiert werden. Auf der letzten Zeile innerhalb forRoot müssen also alle Reducer hinzugefügt werden, ansonsten funktioniert die Applikation nicht. Hast du das alles gemacht (und natürlich den MyCounterComponent im app.component.html hinzugefügt, damit dieser angezeigt wird) dürfte der Counter wie gewünscht funktionieren.\nAufgabe 2 - Aufgabenstellung Gehen wir nun weiter zur zweiten Aufgabe. Das Ziel der Aufgabe ist es, einen Online-Shop mit einer Produkübersicht und einem Warenkorb zu erstellen. Dabei sollen die Produktdaten als Mockdaten über einen Service bereitgestellt werden. Zudem soll es möglich sein, mithilfe von Routing zwischen den beiden Ansichten hin- und herzuwechseln.\nEin Produkt besteht aus 2 Attributen:\nName Preis In der Produktübersicht sollen alle Produkte angezeigt werden, indem Sie aus dem angesprochenen Service geholt werden. Für jedes Produkt soll ein Button bestehen, mit welchem man dieses zum Warenkorb hinzufügen kann. Der Warenkorb soll alle Produkte anzeigen, welche in der Produktübersicht zu diesem hinzugefügt wurden. Der Warenkorbzustand soll hierbei mithilfe von NgRx verwaltet werden. Die folgenden Aktionen sollen im Kontext des Warenkorbs ausgeführt werden können:\nHinzufügen von Produkten in den Warenkorb Entfernen von Produkten aus dem Warenkorb Ausgabe einer Liste aller Produkte im Warenkorb Zudem soll es ebenfalls möglich sein, den Kaufprozess per Knopfdruck abzuschliessen (und somit den Warenkorb zu leeren), womit ebenfalls die folgende Funktionalität dazukommt:\nLeeren des Warenkorbs Wir gehen die Lösung, gleich wie bei der ersten Aufgabe, nun Schritt für Schritt durch:\nAufgabe 2 - Actions Wie bei der ersten Aufgabe gilt es als erstes, die jeweiligen nötigen Actions zu definieren. Aus der Aufgabenstellung konnten wir die folgenden 4 Anwendungsfälle auslesen:\nHinzufügen eines Produkts in den Warenkorb Entfernen eines Produkts aus dem Warenkorb Leeren des Warenkorbs Abschliessen einer Bestellung Da das Leeren des Warenkorbs und das Abschliessen einer Bestellung grundsätzlich dasselbe Verhalten zur Folge haben, nämlich einen leeren Warenkorb, könnte man die Anzahl der Actions auf 3 reduzieren und beim Abschliessen einer Bestellung einfach die Action für das leeren des Warenkorbs nutzen, der Vollständigkeit halber wird in diesem Beispiel aber mit einer separaten Action für den Abschluss einer Bestellung gearbeitet. Die 4 Actions sähen umgesetzt aus wie folgt (in diesem Fall heisst die Datei shopping-cart.actions.ts):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import { createAction, props } from \"@ngrx/store\"; import { ProductModel } from \"../models/product-model\"; export enum ActionTypes { ADDPRODUCT = \"[ShoppingCart Component] add product\", REMOVEPRODUCT = \"[ShoppingCart Component] remove product\", EMPTYSHOPPINGCART = \"[ShoppingCart Component] empty shopping cart\", COMPLETEORDER = \"[ShoppingCart Component] complete order\", } export const addProduct = createAction( ActionTypes.ADDPRODUCT, props\u003c{ product: ProductModel }\u003e(), ); export const removeProduct = createAction( ActionTypes.REMOVEPRODUCT, props\u003c{ name: string }\u003e(), ); export const emptyShoppingCart = createAction(ActionTypes.EMPTYSHOPPINGCART); export const completeOrder = createAction(ActionTypes.COMPLETEORDER); Die Actions für das Leeren des Warenkorbs und das Abschliessen der Bestellung sind wie oben erwähnt identisch und unterscheiden sich nicht von den Actions, die wir bisher umgesetzt haben. Interessant wird es bei der Action für das Hinzufügen eines Produkts; Dort nutzen wir nämlich die props-Funktion. In diesem Fall beschreibt props die Parameter, die wir der Action beifügen wollen. Im Falle von addProduct entspricht das einer Instanz des ProductModel (schauen wir gleich noch an), im Falle von removeProduct einem String, welcher den Namen des zu entfernenden Produkts enthält. Das ist bereits alles, was wir in den Actions machen müssen.\nAufgabe 2 - Model Oben haben wir bereits das ProductModel verwendet. Dieses ist eine Klasse, welches wir der Einfachheit halber verwenden, um die nötigen Attribute name und preis zum jeweiligen Produkt zu speichern. Das Model sieht aus wie folgt und befindet sich in diesem Beispiel in der Datei product-model.ts:\n1 2 3 4 5 6 7 8 9 export class ProductModel { name: string; price: number; constructor(name: string, price: number) { this.name = name; this.price = price; } } Dieses Model werden wir durch die Aufgabenstellung immer wieder verwenden.\nAufgabe 2 - interfaces Um uns die Handhabung der jeweiligen States, insbesondere für den Fall, dass mehrere in einer Applikation verwendet werden, einfacher zu gestalten und die spätere Nutzung von selectors zu ermöglichen, können wir jeweils eigene definieren. Der eigene State für die Produkte, die später im Warenkorb angezeigt werden, sieht im Beispiel aus wie folgt und befindet sich in der (eigens dazu erstellten) Datei index.ts:\n1 2 3 4 5 6 7 8 9 import { ProductModel } from \"../models/product-model\"; export interface ProductState { products: ProductModel[]; } export const initalState: ProductState = { products: [], }; Der Ablauf hier ist relativ simpel: Wir definieren ein exportierbares interface ProductState, welches ein Array von ProductModels enthält. Zudem definieren wir einen initialen Zustand für den Inhalt des States, in diesem Fall einfach ein leeres Array.\nAufgabe 2 - Reducers Wie bereits bei der ersten Aufgabe folgt auf die Definition der Actions die Definition der jeweils dazugehörigen Reducers. Diese sehen aus wie folgt und befinden sich in diesem Beispiel in der Datei shopping-cart.reducers.ts:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import { createReducer, on } from \"@ngrx/store\"; import { addProduct, completeOrder, emptyShoppingCart, removeProduct, } from \"./shopping-cart.actions\"; import { initalState } from \"./index\"; export const shoppingCartReducer = createReducer( initalState, on(addProduct, (state, { product }) =\u003e ({ ...state, products: [...state.products, product], })), on(removeProduct, (state, { name }) =\u003e ({ ...state, products: state.products.filter((product) =\u003e product.name !== name), })), on(emptyShoppingCart, (state) =\u003e ({ ...state, products: [], })), on(completeOrder, (state) =\u003e ({ ...state, products: [], })), ); Hier wird es interessant: Da wir mit einem Array arbeiten, können wir nicht, wie beispielsweise in der ersten Aufgabe, einfach den state nehmen und diesen mutieren. Schauen wir uns dazu mal den ersten Reducer an:\n1 2 3 4 on(addProduct, (state, { product }) =\u003e ({ ...state, products: [...state.products, product], })); Als erstes definieren wir wieder zu Beginn mit on(), wann der Reducer ausgeführt werden soll. In diesem Fall passiert das, sobald die Action addProduct aufgerufen wird. Danach wird es spannend: In den runden Klammern geben wir als zweites Argument state, {product}an. Der state erklärt sich von selbst, den brauchen wir immer. {product} hingegen stellt den Parameter dar, der mit der Action geliefert wird. Innerhalb der Arrow-Function passieren dann zwei Dinge:\nEs wird eine shallow-copy des states gemacht. Das Attribut products wird mit den bisherigen products plus dem neu hinzuzufügenden product gespeichert. Auf diese Art und Weise garantieren wir, dass beim Hinzufügen eines neuen Produkts alle bisherigen Werte ebenfalls übernommen werden.\nAuch interessant ist der zweite Reducer, der zum Entfernen eines Produkts aus dem state verwendet wird:\n1 2 3 4 on(removeProduct, (state, { name }) =\u003e ({ ...state, products: state.products.filter((product) =\u003e product.name !== name), })); Der Ablauf bis zur Anpassung des products-Arrays ist derselbe, ausser dass hier nur der name des Produkts und nicht die ganze Struktur als Parameter erwartet wird. In der Definition des products-Arrays wird dann der aktuelle Zustand des Arrays genommen und alle darin enthaltenen Produkte mit dem entsprechenden Namen, der geliefert wurde, werden entfernt.\nWichtig: Diese Lösung ist eher unschön, es werden nämlich alle Instanzen eines Produkts aus dem Array entfernt, wenn mehrere vorhanden sind. Wenn beispielsweise 2 Fussbälle im Array sind, werden beide entfernt, da sie ja denselben Namen haben. Hätten wir eine ID für die jeweiligen Produkte verwendet, hätte man mit dieser auch einzelne Instanzen mehrfach vorkommender Produkte entfernen können. Da in der Aufgabenstellung aber keine ID vorgesehen ist, können wir in diesem Fall dieses Verhalten akzeptieren. Es ist aber auch möglich, den Filter so anzupassen, dass nach einer Entfernung eines Elements, das mehrfach vorkommt, die Filtrierung gestoppt wird. Wenn du möchtest, kannst du probieren, den Filter entsprechend anzupassen.\nDie beiden Reducer für das Leeren des Warenkorbs und das Abschliessen der Bestellung sind hierbei nicht gross erwähnenswert, da einfach das Array products auf einen leeren Zustand zurückgesetzt wird.\nAufgabe 2 - Selectors Im Vergleich zu der ersten Aufgabe gibt es hier ein neues Konzept, welches wir verwenden, nämlich die sogenannten Selectors. In der ersten Aufgabe haben wir den Inhalt des Stores direkt im Component mit store.select() ausgelesen und dabei einfach den entsprechenden Key aus dem Store verwendet. Um die Auslese der Daten aus dem Store aber ein wenig zu verschönern und applikationsweit zu vereinheitlichen, können wir mit Selektoren arbeiten. Der Selektor für diese Aufgabe sieht aus wie folgt und befindet sich in der Datei shopping-cart.selectors.ts:\n1 2 3 4 5 6 7 8 9 10 import { ProductState } from \"./index\"; import { createFeatureSelector, createSelector } from \"@ngrx/store\"; export const selectShoppingCartState = createFeatureSelector\u003cProductState\u003e(\"products\"); export const getShoppingCartProducts = createSelector( selectShoppingCartState, (state) =\u003e state.products, ); Hier kommt der ProductState zum Tragen, den wir zu Beginn in der index.ts-Datei definiert haben. Mit diesem erstellen wir zuerst eine exportierbare Konstante selectShoppingCartState, die einen sogenannten FeatureSelector darstellt, die den ProductState ausliest. Daraufhin müssen wir erneut eine exportierbare Konstante getShoppingCartProducts erstellen, welche wir dann jeweils in den Components aufrufen können. Dieser nimmt innerhalb der Funktion createSelector den vorher erstellten FeatureSelector selectShoppingCartState als Parameter entgegen und gibt darauf aus dem state heraus die products aus. Das wäre bereits alles, was wir im Rahmen der Selectors machen müssen.\nAufgabe 2 - app.config.ts Damit unsere Reducer und Selektoren korrekt funktionieren, müssen wir, wie in der ersten Aufgabe, Anpassungen in der app.config.ts-Datei machen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import { ApplicationConfig, importProvidersFrom, provideZoneChangeDetection, } from \"@angular/core\"; import { provideRouter } from \"@angular/router\"; import { routes } from \"./app.routes\"; import { provideStore, StoreModule } from \"@ngrx/store\"; import { shoppingCartReducer } from \"./aufgabe-2/ngrx/shopping-cart.reducers\"; import { provideStoreDevtools } from \"@ngrx/store-devtools\"; export const appConfig: ApplicationConfig = { providers: [ provideZoneChangeDetection({ eventCoalescing: true }), provideRouter(routes), provideStore(), importProvidersFrom(StoreModule.forRoot({ products: shoppingCartReducer })), ], }; Relevant sind für uns diese beiden Auszüge aus dem providers-Array:\n1 provideStore(), importProvidersFrom(StoreModule.forRoot({ products: shoppingCartReducer }) provideStore benötigen wir, um überhaupt erst den Store nutzen zu können, den zweiten Teil benötigen wir wiederum, damit die Reducer funktionieren und der State mit state.select(\"products\") im Selektor ausgelesen werden kann.\nAufgabe 2 - Service Im Rahmen der Aufgabe solltest du einen Service erstellen, mit dem du gemockte Daten an den Übersichts-Component senden kannst. Einen neuen Service für die Produkte kannst du einfach mit dem Befehl ng g s product in der Konsole generieren lassen. Der Inhalt des Services bleibt dabei relativ simpel: Wir müssen zum einen die Produkte mocken (dafür können wir direkt das Model nutzen, das wir bisher auch schon gebraucht haben) und eine Methode bereitstellen, die diese an den entsprechenden Component liefern kann. Der Service sähe dann in etwa so aus:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import { Injectable } from \"@angular/core\"; import { ProductModel } from \"../models/product-model\"; @Injectable({ providedIn: \"root\", }) export class ProductService { private products: ProductModel[] = []; constructor() { this.products = [ { name: \"Federball 🏸\", price: 100 }, { name: \"Fussball ⚽\", price: 1000 }, { name: \"Basketball 🏀\", price: 500 }, { name: \"Volleyball 🏐\", price: 800 }, { name: \"Skateboard 🛹\", price: 900 }, { name: \"Tennisball 🎾\", price: 2 }, { name: \"Bowlingkugel 🎳\", price: 600 }, { name: \"Tischtennisball 🏓\", price: 800 }, { name: \"Hockeyball 🏑\", price: 700 }, { name: \"Abschlussball 🕺\", price: 800 }, ]; } getAllProducts() { return this.products; } } Aufgabe 2 - Components erstellen / Routing Wir brauchen in dieser Aufgabe 2 Components:\nEin Component als Startseite mit allen Produkten Ein Component als Warenkorb mit allen ausgewählten Produkten Diese beiden Components kannst du wieder einfach per Konsole mit dem Befehl ng g c {name} generieren lassen. Wie die Components genau aussehen, schauen wir gleich genauer an. Vorher definieren wir aber direkt das Routing zwischen den jeweiligen Komponenten. Als erstes muss direkt das router-outlet-Tag im AppComponent hinzugefügt werden, damit das Routing überhaupt funktioniert. Das ist auch schon alles, was in die Datei app.component.html rein muss:\n1 \u003crouter-outlet\u003e\u003c/router-outlet\u003e Danach können wir die Routen bereits in der app.routes.ts-Datei definieren. In diesem Beispiel heissen die Components OverviewComponent und ShoppingCartComponent. Wenn du deine Components anders bezeichnet hast, musst du lediglich die Definition nach component: entsprechend anpassen. Für das Beispiel sähen die Routen aber aus wie folgt:\n1 2 3 4 5 6 7 8 import { Routes } from \"@angular/router\"; import { OverviewComponent } from \"./aufgabe-2/components/overview/overview.component\"; import { ShoppingCartComponent } from \"./aufgabe-2/components/shopping-cart/shopping-cart.component\"; export const routes: Routes = [ { path: \"\", component: OverviewComponent }, { path: \"shopping-cart\", component: ShoppingCartComponent }, ]; Als Ausgangscomponent nehmen wir (logischerweise) den Component mit der Übersicht, dafür geben wir ihm einfach einen leeren Path an. Nun bleiben nur noch die Components, dann haben wir die Übung bereits geschafft.\nAufgabe 2 - Übersichts-Component Im Übersichts-Component wollen wir als erstes die Mock-Daten aus dem Service holen. Dazu müssen wir lediglich im Constructor die getAllProducts() aus dem Service aufrufen und einer entsprechenden Variable zuweisen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import { Component } from \"@angular/core\"; import { ProductService } from \"../../services/product.service\"; import { ProductModel } from \"../../models/product-model\"; import { Store } from \"@ngrx/store\"; import { addProduct } from \"../../ngrx/shopping-cart.actions\"; import { RouterLink } from \"@angular/router\"; @Component({ selector: \"app-overview\", imports: [RouterLink], templateUrl: \"./overview.component.html\", styleUrl: \"./overview.component.scss\", }) export class OverviewComponent { protected products: ProductModel[] = []; constructor( private store: Store\u003c{ products: ProductModel[] }\u003e, private productService: ProductService, ) { this.products = this.productService.getAllProducts(); } } Nachdem wir die Daten für die Anzeige vorbereitet haben, können wir auch schon die Funktion für das Hinzufügen eines Produkts definieren:\n1 2 3 4 addProduct(product:ProductModel) { this.store.dispatch(addProduct({ product: product })); } Da wir das jeweilige Product aus dem Template erhalten, geben wir dieses hier als Parameter für die Funktion an. Die action für das Hinzufügen des Produkts lösen wir entsprechend mit this.store.dispatch(addProduct())) aus. Neu ist hier die Nutzung eines Parameters innerhalb der Action. Parameter für actions werden jeweils in geschweiften Klammern als key-value-Paar angegeben. Da wir in der entsprechenden Action den Parameter als product definiert haben, ist das hier auch der key. Als value geben wir dann noch das aus dem Template gelieferte product an. Das ist bereits alles, was wir auf der Seite der Logik machen müssen.\nAls nächstes schauen wir das Template und somit die Anzeige der Daten an:\n1 2 3 4 5 6 7 8 9 10 11 12 \u003cdiv class=\"title-container\"\u003e \u003ca routerLink=\"\"\u003eÜbersicht\u003c/a\u003e \u003ca routerLink=\"shopping-cart\"\u003eWarenkorb\u003c/a\u003e \u003c/div\u003e @for (product of products; track product.name){ \u003cdiv class=\"product-container\"\u003e \u003cp\u003eName: {{product.name}}\u003c/p\u003e \u003cp\u003ePreis: {{product.price}}\u003c/p\u003e \u003cbutton (click)=\"this.addProduct(product)\"\u003e🛒\u003c/button\u003e \u003c/div\u003e } Hier fallen direkt einige Dinge auf: Zuoberst haben wir die Navigation, die zwischen den beiden Components stattfindet. Die jeweiligen Links befinden sich standardmässig in a-Tags. Hierbei aber ganz wichtig: Es muss routerLink statt href für die Angabe des Paths verwendet werden. Wenn in Angular per href navigiert wird, wird in NgRx der Store auf den Ausgangswert zurückgesetzt. Unter Vewendung von routerLink tritt dieses Verhalten hingegen nicht auf.\nDer Rest ist eigentlich relativ simpel. Wir iterieren mit @for über die Elemente des products -Arrays und generieren für jedes Element eine Anzeige des Namens und des Preises und einen Button, der für das jeweilige Element die addProduct-action auslöst. In der Erarbeitung dieser Lösung wurde zusätzlich ein wenig SCSS verwendet, um die Seite einigermassen anschaulich zu gestalten. Du musst das jeweils nicht machen, bei Interesse kannst du dir aber dennoch das SCSS anschauen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 .title-container { font-size: 2rem; display: flex; justify-content: space-around; } .product-container { text-align: center; width: 49%; float: left; display: inline-block; font-size: 1.5rem; margin: 0 0 2% 0; } Die Seite sieht, wenn sie so umgesetzt und gestylt wird wie hier, schlussendlich so aus: Aufgabe 2 - Warenkorb-Component Zum Schluss müssen wir nun noch einen Component für den Warenkorb erstellen, in welchem die jeweiligen zum Warenkorb hinzugefügten Produkte angezeigt werden. Zur Erinnerung; Im Warenkorb müssen die folgenden Funktionalitäten umgesetzt sein:\nEntfernen eines Produkts aus dem Warenkorb Leeren des Warenkorbs Abschliessen der Bestellung Beginnen wir wieder in der Typescript-Datei:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import { Component } from \"@angular/core\"; import { Observable } from \"rxjs\"; import { Store } from \"@ngrx/store\"; import { ProductModel } from \"../../models/product-model\"; import { AsyncPipe } from \"@angular/common\"; import { getShoppingCartProducts } from \"../../ngrx/shopping-cart.selectors\"; import { RouterLink } from \"@angular/router\"; import { completeOrder, emptyShoppingCart, removeProduct, } from \"../../ngrx/shopping-cart.actions\"; @Component({ selector: \"app-shopping-cart\", imports: [RouterLink, AsyncPipe], templateUrl: \"./shopping-cart.component.html\", styleUrl: \"./shopping-cart.component.scss\", }) export class ShoppingCartComponent { products$: Observable\u003cProductModel[]\u003e = new Observable\u003cProductModel[]\u003e(); constructor(private store: Store\u003c{ products: ProductModel[] }\u003e) { this.products$ = this.store.select(getShoppingCartProducts); } removeProduct(productName: string) { this.store.dispatch(removeProduct({ name: productName })); } emptyShoppingCart() { this.store.dispatch(emptyShoppingCart()); } completeOrder() { this.store.dispatch(completeOrder()); alert(\"Bestellung abgeschlossen!\"); } } Hier passiert direkt einiges:\nEs werden die Produkte in einem Observable gespeichert, da die Daten unter Auslesung aus dem Store diese Form annehmen. Der Typ des Observables ist dabei ProductModel[]. Wir definieren im Constructor einen privaten store, über den wir die actions ausführen. Mit {products: ProductModel[]} spezifizieren wir dabei, welche Form die ausgelesenen Daten haben. Wir lesen die Daten aus dem Store mit dem zu Beginn von uns definierten selector getShoppingCartProducts und übergeben diese an products$. Wir definieren die jeweiligen Funktionen für das Entfernen eines Produkts, das Leeren des Warenkorbs und das Abschliessen einer Bestellung. Den logischen Teil im Component haben wir nun bereits abgeschlossen. Nun bleibt nur noch das Template:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u003cdiv class=\"title-container\"\u003e \u003ca routerLink=\"\"\u003eÜbersicht\u003c/a\u003e \u003ca routerLink=\"shopping-cart\"\u003eWarenkorb\u003c/a\u003e \u003c/div\u003e @for (product of products$ | async; track product) { \u003cdiv class=\"product-container\"\u003e \u003cp\u003e{{ product.name }}\u003c/p\u003e \u003cp\u003e{{ product.price }}\u003c/p\u003e \u003cbutton class=\"remove-product\" (click)=\"removeProduct(product.name)\"\u003e 🗑 \u003c/button\u003e \u003c/div\u003e } @empty { \u003cdiv class=\"no-products-container\"\u003e \u003cp class=\"no-products-text\"\u003eNo Products in shopping cart\u003c/p\u003e \u003c/div\u003e } \u003cdiv class=\"empty-shopping-cart-container\"\u003e \u003cbutton class=\"empty-shopping-cart-button\" (click)=\"emptyShoppingCart()\"\u003e Empty Shopping Cart \u003c/button\u003e \u003c/div\u003e \u003cdiv class=\"complete-order-container\"\u003e \u003cbutton class=\"complete-order-button\" (click)=\"completeOrder()\"\u003e Complete Order \u003c/button\u003e \u003c/div\u003e Wie im Overview-Component hat es zuoberst als erstes die jeweilige Navigation zwischen den Components. Darauf wird wieder mit @for über die Produkte iteriert. Ein wichtiger Unterschied ist hierbei die |async-Pipe. Diese wird benötigt, da nur asynchron über Observables iteriert werden kann. Innerhalb des Loops hat es wieder eine Darstellung mit dem jeweligen Namen und Preis und einen Button für das Entfernen eines Produkts aus dem Warenkorb. Mit @empty nach dem Loop wird beschrieben, was passieren soll, wenn products$ keinen Wert enthält. In diesem Fall wird einfach der Text “No Products in shopping cart” angezeigt.\nSchlussendlich hat es dann noch 2 Buttons, welche jeweils die Funktionen für das Leeren des Warenkorbs und das Abschliessen einer Bestellung aufrufen.\nHier noch das SCSS-File für die Interessierten:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 .title-container { font-size: 2rem; display: flex; justify-content: space-around; } .product-container { text-align: center; width: 24%; float: left; display: inline-block; font-size: 1.5rem; margin: 5% 0 2% 0; .remove-product { font-size: 1.2rem; } } .no-products-container { width: 100%; text-align: center; .no-products-text { text-align: center; font-size: 50px; } } .empty-shopping-cart-container, .complete-order-container { width: 47%; display: inline-block; text-align: center; .empty-shopping-cart-button, .complete-order-button { width: 90%; margin: 2% 2% 0 2%; font-size: 50px; } } Die fertige Seite sieht mit dem obenstehenden Design dann aus wie folgt:\nAufgabe 3 - Aufgabenstellung Nun bleibt uns noch die dritte Aufgabe. Diese sieht es vor, eine TODO-Liste mithilfe von NgRx umzusetzen. Eine Task in dieser Liste beinhält jeweils die folgenden 3 Attribute:\nID Name Completed Es sollen, ähnlich wie bei der zweiten Aufgabe, 2 Seiten erstellt werden:\nEine, auf der alle offenen Tasks angezeigt werden. (Also alle, die im Attribut completed einen Wert von false innehaben.) Hier sollen Tasks hinzugefügt, entfernt und komplettiert werden können. Zudem sollen wie bei Aufgabe 2 Selektoren für das Auslesen der Tasks verwendet werden. Eine, auf der neue Tasks erstellt werden können. Hierbei soll der Name mittels eines Reactive Forms eingetragen werden können und der Wert completed immer mit false instanziert werden. Um sicherzugehen, dass die IDs jeweils einzigartig sind, nutzen wir für die Definition dieser new Date().getTime() (aktuelle Uhrzeit). Gehen wir also nun wie gehabt die einzelnen Schritte durch:\nAufgabe 3 - Actions Als Erstes kommen wieder die Actions, die wir anhand der vorgegebenen Anwendungsfälle definieren müssen. In dieser Aufgabe gibt es drei Funktionalitäten, die wir mithilfe von Actions bereitstellen müssen:\nEs muss möglich sein, eine neue Task zu erstellen Es muss möglich sein, eine Task zu entfernen Es muss möglich sein, eine Task abzuschliessen Aus dieser Aufgabenstellung ergeben sich dann die folgenden 3 Actions:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import { createAction, props } from \"@ngrx/store\"; import { TaskModel } from \"../models/task-model\"; export enum ActionTypes { ADDTASK = \"[Task Component] add task\", REMOVETASK = \"[Task Component] remove task\", COMPLETETASK = \"[Task Component] complete task\", } export const addTask = createAction( ActionTypes.ADDTASK, props\u003c{ task: TaskModel }\u003e(), ); export const removeTask = createAction( ActionTypes.REMOVETASK, props\u003c{ id: number }\u003e(), ); export const completeTask = createAction( ActionTypes.COMPLETETASK, props\u003c{ id: number }\u003e(), ); Hier gibt es im Vergleich zu Aufgabe 2 eigentlich nichts Neues. Wie gewohnt erstellen wir zuerst die jeweliigen ActionTypes, die die actions jeweils nachvollziehbar machen. Darauf folgt dann die effektive Definition der actions. Dabei wird wie immer zuerst der jewelige ActionType zugewiesen. In unserem Fall benötigen alle actions jeweils noch props (Paramater). addTask braucht eine ganze Task (da ja eine neue erstellt werden soll), wohingegen removeTask und completeTask jeweils nur die id der betroffenen Task brauchen.\nAufgabe 3 - Model Wie auch schon in Aufgabe 2 benutzen wir in dieser Lösung ein Model für die Tasks, um das Ganze übersichtlich zu gestalten. Das Model wurde in den Actions bereits in den props von addTask verwendet und sieht so aus:\n1 2 3 4 5 6 7 8 9 10 11 export class TaskModel { id: number; name: string; completed: boolean; constructor(id: number, name: string) { this.id = id; this.name = name; this.completed = false; } } Achte hierbei darauf, dass das completed-Attribut nicht als Parameter im Constructor geliefert wird, sondern direkt auf false gesetzt wird. In der Aufgabenstellung steht als Anforderung, dass Tasks zum Zeitpunkt der Erstellung immer nicht completed sein sollen, daher können wir uns so jeweils einen Parameter beim Erstellen einer neuen Task sparen.\nAufgabe 3 - Interfaces Wie auch in Aufgabe 2 macht es in diesem Fall Sinn, einen separaten State für die Tasks zu erstellen. Dazu wurde hier wieder eine Datei index.ts erstellt, um das Interface für den State und den intialState für den Reducer unterzubringen. Die Datei sieht aus wie folgt:\n1 2 3 4 5 6 7 8 9 import { TaskModel } from \"../models/task-model\"; export interface TaskState { tasks: TaskModel[]; } export const initalState: TaskState = { tasks: [], }; Da wir mit mehreren Tasks arbeiten, geben wir im TaskState an, dass wir ein Array an TaskModels speichern möchten. Als initalState geben wir einfach ein leeres Array an.\nAufgabe 3 - Reducers Nun kommen wir auch schon zu den Reducers; Wie bisher auch müssen wir für jede Action, die wir definiert haben, einen entsprechenden Reducer schreiben, der die effektiv ausgeführte Logik beinhält. Die task.reducers.ts-Datei sollte dabei aussehen wie folgt:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import { createReducer, on } from \"@ngrx/store\"; import { initalState } from \"./index\"; import { addTask, completeTask, removeTask } from \"./task.actions\"; export const taskReducer = createReducer( initalState, on(addTask, (state, { task }) =\u003e ({ ...state, tasks: [...state.tasks, task], })), on(removeTask, (state, { id }) =\u003e ({ ...state, tasks: state.tasks.filter((task) =\u003e task.id !== id), })), on(completeTask, (state, { id }) =\u003e ({ ...state, tasks: state.tasks.map((task) =\u003e task.id === id ? { ...task, completed: true } : task, ), })), ); Als erstes wird in der createReducer Funktion der initialState aus der index.ts als Parameter mitgegeben, worauf dann die jeweiligen Reducer folgen. Der Reducer für die addTask-action ist hierbei praktisch gleich wie der addProduct-Reducer aus Aufgabe 2; Es wird eine Shallow-Copy des derzeitigen state gemacht und die neue task wird angehängt.\nDer Reducer für removeTask funktioniert ebenfalls praktisch gleich wie der removeProduct-Reducer aus Aufgabe 2; Es wird eine Shallow-Copy des derzeitigen state gemacht, wonach der Eintrag im Array mit der mitgegebenen id aus dem Array gefiltert wird. Denken wir nochmal kurz zu Aufgabe 2 zurück: Dort war das Problem bei removeProduct ja, dass alle Einträge mit demselben Namen aus dem Array entfernt wurden, da wir anhand des name-Attributs des Produkts gefiltert haben. Dieses Problem gibt es hier nicht mehr, da wir mit der id gefiltert haben, die einzigartig ist (da sie basierend auf der derzeitigen Uhrzeit generiert wird, die Umsetzung dazu folgt noch).\nDer Reducer für completeTask ist hierbei der spannendenste. Wir können nicht einfach eine neue Task anfügen oder herausfiltern. Wir müssen stattdessen anhand der gelieferten id den entsprechenden Eintrag aus dem Array herauspicken und dessen completed-Attribut verändern. Dazu können wir auf dem tasks-Array die map-Methode nutzen, um auf die einzelnen Tasks zugreifen zu können. Bei den einzelnen Tasks prüfen wir daraufhin, ob deren id mit der gelieferten übereinstimmt. Ist das der Fall, wird für die jeweilige Task das completed-Attribut auf true gesetzt, ansonsten passiert nichts.\nAufgabe 3 - Selectors Wie auch schon in Aufgabe 2 sieht die Aufgabenstellung vor, dass wir Selectors nutzen, um die Tasks aus dem Store auszulesen. Der Code dazu sieht aus wie folgt:\n1 2 3 4 5 6 import { createFeatureSelector, createSelector } from \"@ngrx/store\"; import { TaskState } from \"./index\"; export const selectTaskState = createFeatureSelector\u003cTaskState\u003e(\"tasks\"); export const getTasks = createSelector(selectTaskState, (state) =\u003e state.tasks); Der Aufbau des Selectors ist genau derselbe wie bei Aufgabe 2; Als erstes definieren wir eine exportierbare Konstante selectTaskState, die einen FeatureSelector erstellt, der die tasks aus dem TaskState ausliest. Danach definieren wir eine exportierbare Konstante getTasks, welche einen Selector beinhält, der den TaskState mit selectTaskState ausliest und darauf basierend die tasks zurückgibt.\nAufgabe 3 - app.config.ts Wie immer müssen wir die Datei app.config.ts anpassen, damit unsere Reducer und Selectors funktionieren. Die Datei sollte angepasst so aussehen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import { ApplicationConfig, importProvidersFrom, provideZoneChangeDetection, } from \"@angular/core\"; import { provideRouter } from \"@angular/router\"; import { routes } from \"./app.routes\"; import { provideStore, StoreModule } from \"@ngrx/store\"; import { provideStoreDevtools } from \"@ngrx/store-devtools\"; import { taskReducer } from \"./aufgabe-3/ngrx/task.reducers\"; export const appConfig: ApplicationConfig = { providers: [ provideZoneChangeDetection({ eventCoalescing: true }), provideRouter(routes), provideStore(), importProvidersFrom(StoreModule.forRoot({ tasks: taskReducer })), ], }; Aufgabe 3 - Components erstellen / Routing Die Aufgabenstellung sieht zwei Views vor: Einmal eine Übersicht mit allen offenen Tasks und einmal eine Seite, auf der die Tasks erstellt werden können. Dazu können wir einfach mit dem Befehl ng g c {name} die beiden Components in der Konsole erstellen. Nach der Erstellung können wir direkt das Routing für die beiden Components vorbereiten, damit wir nachher nur noch in den Components selbst arbeiten müssen. Die app.routes.ts-Datei sollte daher aussehen wie folgt:\n1 2 3 4 5 6 7 8 import { Routes } from \"@angular/router\"; import { OverviewComponent } from \"./aufgabe-3/components/overview/overview.component\"; import { CreateTaskComponent } from \"./aufgabe-3/components/create-task/create-task.component\"; export const routes: Routes = [ { path: \"\", component: OverviewComponent }, { path: \"create-task\", component: CreateTaskComponent }, ]; Da der OverviewComponent als Ausgangscomponent dienen soll, geben wir diesem einen leeren Path.\nAufgabe 3 - Component für die Task-Erstellung Nun bleibt uns nur noch die Umsetzung der beiden Components. Wir fangen hierbei mit dem Component für die Erstellung der Tasks an, da wir ansonsten Daten für die Umsetzung des Übersichts-Components mocken müssten. Beginnen wir beim ts-File des Components:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import { Component } from \"@angular/core\"; import { FormControl, ReactiveFormsModule } from \"@angular/forms\"; import { TaskModel } from \"../../models/task-model\"; import { Store } from \"@ngrx/store\"; import { addTask } from \"../../ngrx/task.actions\"; import { RouterLink } from \"@angular/router\"; @Component({ selector: \"app-create-task\", imports: [ReactiveFormsModule, RouterLink], templateUrl: \"./create-task.component.html\", styleUrl: \"./create-task.component.scss\", }) export class CreateTaskComponent { name = new FormControl(\"\"); constructor(private store: Store\u003c{ tasks: TaskModel[] }\u003e) {} addTask() { let task = new TaskModel( Date.now(), this.name.value ? this.name.value : \"\", ); this.store.dispatch(addTask({ task })); this.name = new FormControl(\"\"); } } Als erstes bereiten wir in der Datei die FormControl für die Eingabe des Namens vor (die Aufgabenstellung sieht vor, dass der Name der zu erstellenden Task mit einem Reactive Form eingetragen wird). Im Constructor instanzieren wir darauf direkt den Store, um anschliessend die Actions aufrufen zu können.\nZuletzt bereiten wir auch schon direkt die Funktion für das Erstellen einer neuen Task vor. Dazu erstellen wir zuerst ein neues Objekt vom Typ TaskModel. Als Parameter geben wir dabei zuerst die id in Form von Date.now() mit, da wir so garantieren können, dass das id-Attribut über alle Tasks einzigartig ist. Als zweiten Parameter geben wir dann, insofern der value der FormControl für den Namen nicht null oder undefined entspricht, den Inhalt der FormControl mit. Entspricht dieser null oder undefined geben wir einen leeren String als Namen mit.\nZuletzt instanzieren wir die FormControl für den Namen neu, um die das Textfeld für den Nutzer wieder zu leeren.\nAls Nächstes muss das entsprechende Template für die Erstellung der Task umgesetzt werden. Das sieht in diesem Fall aus wie folgt:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u003cdiv class=\"header\"\u003e \u003ca class=\"header-link\" routerLink=\"\"\u003eÜbersicht\u003c/a\u003e \u003ca class=\"header-link\" routerLink=\"/create-task\"\u003eTask erstellen\u003c/a\u003e \u003c/div\u003e \u003cdiv class=\"create-task-container\"\u003e \u003clabel class=\"create-task-label\" for=\"name\"\u003eName: \u003c/label\u003e \u003cinput class=\"create-task-input\" id=\"name\" type=\"text\" [formControl]=\"name\" /\u003e \u003cbutton class=\"create-task-button\" (click)=\"addTask()\" [disabled]=\"name.value === ''\" \u003e Create \u003c/button\u003e \u003c/div\u003e Das Template ist in diesem Fall relativ überschaubar. Als erstes haben wir einen kleinen Header, mit dem wir zwischen der Übersicht und der Task-Erstellung hin- und herwechseln können.\nDarunter befindet sich dann schon die Eingabe für die Task-Erstellung. Wir verbinden einen Input mit der FormControl und einen Knopf mit der addTask()-Funktion, die wir vorher erstellt haben. Wie auch schon in Aufgabe 2 wurde für diese Lösung ein rudimentäres Styling umgesetzt, welches ihr aber nicht zwingend umsetzen müsst. Für die Interessierten folgt noch der Inhalt das SCSS-Files:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 .header { width: 100vw; text-align: center; .header-link { margin: 0 5% 0 5%; font-size: 2rem; } } .create-task-container { width: 100vw; margin: 5% 0 0 0; } Die fertige Seite für die Erstellung der Tasks sieht schlussendlich aus wie folgt: Aufgabe 3 - Übersicht Da wir nun die Erstellung der Tasks ermöglicht haben, können wir nun zum Schluss noch die Seite für die Übersicht aller offenen Tasks umsetzten. Die fertige Version der ts-Datei für diesen Component sieht aus wie folgt:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import { Component } from \"@angular/core\"; import { RouterLink } from \"@angular/router\"; import { TaskModel } from \"../../models/task-model\"; import { Observable } from \"rxjs\"; import { getTasks } from \"../../ngrx/task.selectors\"; import { Store } from \"@ngrx/store\"; import { AsyncPipe } from \"@angular/common\"; import { completeTask, removeTask } from \"../../ngrx/task.actions\"; @Component({ selector: \"app-overview\", imports: [RouterLink, AsyncPipe], templateUrl: \"./overview.component.html\", styleUrl: \"./overview.component.scss\", }) export class OverviewComponent { tasks$ = new Observable\u003cTaskModel[]\u003e(); constructor(private store: Store\u003cTaskModel[]\u003e) { this.tasks$ = this.store.select(getTasks); } completeTask(id: number) { this.store.dispatch(completeTask({ id })); } removeTask(id: number) { this.store.dispatch(removeTask({ id })); } } Als Erstes erstellen wir ein Observable vom Typ Observable\u003cTaskModel[]\u003e, in dem wir anschliessend die Tasks aus dem Store ablegen können. Im Constructor instanzieren wir daraufhin den Store, um die Ausführung von Actions und die Nutzung von Selectors zu ermöglichen. Innerhalb des Constructors befüllen wir zudem direkt das vorher erstellte Observable mit den Tasks, indem wir den Selector ausführen.\nZuletzt definieren wir direkt die beiden Funktionen für das Komplettieren und Entfernen der Tasks. Beide Funktionen nehmen jeweils die id der jeweiligen Task entgegen und rufen mit this.store.dispatch() die entsprechende action auf.\nAnschliessend können wir das Template umsetzen, das im Falle dieser Lösung aussieht wie folgt:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u003cdiv class=\"header\"\u003e \u003ca class=\"header-link\" routerLink=\"\"\u003eÜbersicht\u003c/a\u003e \u003ca class=\"header-link\" routerLink=\"/create-task\"\u003eTask erstellen\u003c/a\u003e \u003c/div\u003e @for (task of tasks$ | async; track task.id) { @if (!task.completed) { \u003cdiv class=\"task-container\"\u003e \u003cp class=\"task-text\"\u003eID: {{ task.id }}\u003c/p\u003e \u003cp class=\"task-text\"\u003eName: {{ task.name }}\u003c/p\u003e \u003cp\u003e{{task.completed}}\u003c/p\u003e \u003cdiv class=\"task-button-container\"\u003e \u003cbutton (click)=\"completeTask(task.id)\"\u003eTask abschliessen\u003c/button\u003e \u003cbutton (click)=\"removeTask(task.id)\"\u003eTask entfernen\u003c/button\u003e \u003c/div\u003e \u003c/div\u003e } } @empty { \u003cp class=\"task-text\"\u003eKeine Tasks vorhanden\u003c/p\u003e } Zuoberst haben wir den exakt selben Header wie im Component für die Erstellung der Tasks.\nSpannend wird es aber ab Zeile 6. Dort iterieren wir übr das tasks$-Observable. (|async-Pipe nicht vergessen!) Darauf prüfen wir, bevor etwas angezeigt wird, für jede Task, ob das completed-Attribut auf false gesetzt ist. Die Task wird nur angezeigt, solange das der Fall ist. Insofern completed auf false gesetzt ist, wird anschliessend die id und der name der Task angezeigt. Für jede Task werden zudem zwei Knöpfe angezeigt, über die man sie jeweils abschliessen oder entfernen kann. Für den Fall, dass tasks$ keinen Inhalt hat, definieren wir mit @empty den Text “Keine Tasks vorhanden” als Platzhalter, damit nicht einfach nichts angezeigt wird.\nFür die Interessierten folgt noch das SCSS-File zum Component:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 .header { width: 100vw; text-align: center; .header-link { margin: 0 5% 0 5%; font-size: 2rem; } } .task-container { width: 45%; display: inline-block; background: blueviolet; border: 2px black solid; margin: 5% 1% 0 1%; .task-text { font-size: 2rem; } .task-button-container { width: 100%; display: flex; } } Der fertige Component sollte dann aussehen wie folgt: ","categories":"","description":"In diesem Abschnitt sollen die Lösungen aus dem zusätzlichen Labs für NgRx nochmal genauer beleuchtet werden.\n","excerpt":"In diesem Abschnitt sollen die Lösungen aus dem zusätzlichen Labs für …","ref":"/docs/03_web/07_angular-ngrx/05_ngrx-applied/","tags":"","title":"NgRx angwendet (Erst nach der Durchführung der NgRx-Labs anschauen)"},{"body":"Ziele in diesem Abschnitt sollen die Lösungen zu den (optionalen) NgRx-Labs genauer beleuchtet werden. Wenn du die Labs zu NgRx noch nicht gemacht hast, musst du dir diese Dokumentation nicht anschauen.\nWir gehen hier Schritt für Schritt die Aufgaben des NgRx-Labs durch, um zum Einen den Weg der Lösungsfindung genauer anzuschauen, zum Anderen aber auch, um potenzielle Unklarheiten aus dem Weg zu räumen, die bei der Erarbeitung der Aufgabe aufgekommen sein könnten.\nAufgabe 1 - Aufgabenstellung Im Rahmen der ersten Aufgabe des Labs galt es, in einer neuen Angular-Applikation mit NgRx einen Counter zu erstellen, mit dem man:\nDen Wert des Counters inkrementieren kann (Wert + 1) Den Wert des Counters dekrementieren kann (Wert - 1) Den Wert des Counters zurücksetzen kann (Wert auf 0) Die Umsetzung dieser Anforderungen gehen wir nun Stück für Stück durch. Wir beginnen mit den Actions.\nAufgabe 1- Actions erstellen Als erstes gilt es, die jeweiligen Actions für die drei oben beschriebenen Anwendungsfälle zu definieren. Für die Actions solltest du eine Datei counter.actions.ts erstellen, in der du die Actions definieren kannst. Die fertigen Actions sehen aus wie folgt:\n1 2 3 4 5 6 7 8 9 10 11 import { createAction } from \"@ngrx/store\"; export enum ActionTypes { INCREMENT = \"[Counter Component] Increment\", DECREMENT = \"[Counter Component] Decrement\", RESET = \"[Counter Component] Reset\", } export const increment = createAction(ActionTypes.INCREMENT); export const decrement = createAction(ActionTypes.DECREMENT); export const reset = createAction(ActionTypes.RESET); Gehen wir das einmal durch: In der Aufgabenstellung war es vorgesehen, dass die verschiedenen Actions in ein Enum ausgelagert werden. So sind diese direkt alle über die Variable ActionTypes verfügbar. Dafür kannst du einfach die einzelnen Actions in ein Enum wrappen, wie es im Code oben gemacht wurde. Der String nach dem = wird jeweils hinzugefügt, um die Action in Kontext zur Applikation zu stellen. In diesem Fall sagen die Strings also aus, dass im CounterComponent der Wert entweder inkrementiert, dekrementiert oder resettet wurde.\nNun haben wir bereits das Grundgerüst für die Actions, diese können aber noch nicht verwendet werden. Um das zu ändern, müssen wir diese zu exportierbaren Actions machen, was im zweiten Abschnitt des Codebeispiels oben passiert. Für jede Action, die wir definieren wollen, müssen wir eine entsprechende exportierbare Konstante erstellen. Relevant ist hierbei das Keyword createAction, welches die Actions erst wirklich als solche definiert.\nHaben wir nun für jede Action eine entsprechende Definition vorgenommen, können wir mit dem nächsten Schritt fortfahren; den Reducers.\nAufgabe 1 - Reducers erstellen Damit nun beim Aufrufen der Actions, die wir definiert haben, auch etwas passiert, müssen wir die für die Actions entsprechenden Reducers erstellen. Der dazugehörige Code-Block in der Datei counter.reducer.ts, die du erstellt haben solltest, sieht aus wie folgt:\n1 2 3 4 5 6 7 8 9 10 11 import { createReducer, on } from \"@ngrx/store\"; import { increment, decrement, reset } from \"./counter.actions\"; export const initialState = 0; export const counterReducer = createReducer( initialState, on(increment, (state) =\u003e state + 1), on(decrement, (state) =\u003e state - 1), on(reset, (state) =\u003e 0), ); Gehen wir das mal Schritt für Schritt durch: Auf der vierten Zeile wird eine exportierbare Konstante initialState definiert. Diese gibt den Ausgangswert unseres Counters an, in diesem Fall 0. Interessant wird es aber ab Zeile 6: Hier wird eine exportierbare Konstante counterReducer definiert, welche dann die eigentlichen Reducer mit der Funktion createReducer() erstellt. Die Funktion nimmt (in unserem Fall) insgesamt 4 Argumente entgegen:\nDen initialen Zustand Den Reducer für das Inkrementieren des Counters Den Reducer für das Dekrementieren des Counters Den Reducer für das Resetten des Counters Der initialState wird hierbei als Ausgangswert für den Counter mitgegeben. Die jeweiligen Reducer entsprechen jeweils den Actions, die wir in der Datei counter.actions.ts definiert haben. Die Definition funktioniert jeweils wie folgt: Der Reducer wird in die Funktion on() verpackt. Als erstes Argument wird hierbei die Action angegeben, die als Auslöser für den Reducer fungiert. (Wie du auf Zeile 1 sehen kannst, werden die jeweiligen Actions direkt aus counter.actions importiert.) Insofern also eine der Actions getriggert wird, wird als nächstes der state ausgelesen. Dieser beschreibt den derzeitigen Zustand des Counters, den wir mit den Reducers mutieren wollen. Zuletzt wird dann auch schon die entsprechende Mutation durchgeführt; Im Falle der Inkrementierung wird der state um 1 erhöht, im Falle der Dekrementierung um 1 verringert und im Falle des Zurücksetzens auf 0 gesetzt.\nDas heisst also: Prinzipiell wartet der Reducer ab, bis eine bestimmte Action aufgerufen wird und mutiert dann entsprechend den state.\nAufgabe 1 - Component Der nächste Schritt nach dem Erstellen der Reducers ist es, den entsprechenden Component zu erstellen, von dem aus die Logik für den Counter ausgelöst werden kann. Der Component, den du im Rahmen der Aufgabe erstellt haben solltest, sollte aussehen wie folgt:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import { Component } from \"@angular/core\"; import { Store } from \"@ngrx/store\"; import { Observable } from \"rxjs\"; import { increment, decrement, reset } from \"../counter.actions\"; import { AsyncPipe } from \"@angular/common\"; @Component({ selector: \"app-my-counter\", templateUrl: \"./my-counter.component.html\", imports: [AsyncPipe], }) export class MyCounterComponent { count$: Observable\u003cnumber\u003e; constructor(private store: Store\u003c{ count: number }\u003e) { this.count$ = store.select(\"count\"); } increment() { this.store.dispatch(increment()); } decrement() { this.store.dispatch(decrement()); } reset() { this.store.dispatch(reset()); } } 1 2 3 4 5 6 7 \u003cbutton (click)=\"increment()\"\u003eIncrement\u003c/button\u003e \u003cdiv\u003eCurrent Count: {{ count$ | async }}\u003c/div\u003e \u003cbutton (click)=\"decrement()\"\u003eDecrement\u003c/button\u003e \u003cbutton (click)=\"reset()\"\u003eReset Counter\u003c/button\u003e Gehen wir auch diesen Code mal Schritt für Schritt durch: Der Component ist grundsätzlich aufgebaut wie jeder andere. Er besteht aus einer html-Datei, einer (s)css-Datei, einer ts-Datei und einer spec.ts-Datei und beinhält einen Constructor. Interessant wird es ab Zeile 11: Dort wird ein Obvservable count$ (achte hierbei auf das $ am Ende der Variable =\u003e Best Practice bei der Benennung von Observables!) definiert, welches uns anschliessend zur Darstellung des Counts innerhalb des Templates nutzen wird. Im Constructor auf Zeile 13 wird eine private Variable store instanziert, welche die Zahlen-Variable count in diesem erstellt.\nDer Store dient in NgRx als “Eimer” für die States und ist applikationsweit zugänglich. Diese States werden dann auf Befehl der Actions von den Reducern mutiert.\nAuf Zeile 14 wird dann direkt beim Erstellen des Components dem Observable count$ der derzeitige Zustand der Variable count aus dem Store zugeschrieben, welcher zu diesem Zeitpunkt beim initalState, also bei 0 liegen sollte. Hiermit ist die Vorbereitung auch schon erledigt, womit wir nun zur Component-Logik weiterkönnen. In unserem Fall mussten 3 Funktionen definiert werden:\nincrement() decrement() reset() Die Logik in diesen gehen wir nun ebenfalls kurz durch. Innerhalb der Funktionen wird der im Constructor instanzierte Store genutzt und dessen Methode dispatch() aufgerufen. Diese Methode wird verwendet, um im Store eine Action auszulösen. In unseren 3 Fällen wären das die Actions increment(), decrement() und reset().\nAlles was nun noch bleibt, ist das Template (siehe oben). Dieses besteht aus 4 Bestandteilen:\nJeweils ein button-Element pro Funktion Ein div-Element, welches den derzeitigen Zustand des Counters anzeigt. In den jeweiligen Buttons muss jeweils lediglich das (click)-Event abgehört werden, woraufhin die jeweilige Funktion aufgerufen wird.\nAufgabe 1 - app.config.ts anpassen Seit in Angular standardmässig standalone-Components verwendet werden und somit normalerweise kein AppModule mehr exisitert, muss für das korrekte Funktionieren der Reducer eine Anpassung in der app.config.ts-Datei gemacht werden, nämlich die folgende:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import { ApplicationConfig, importProvidersFrom, provideZoneChangeDetection, } from \"@angular/core\"; import { provideRouter } from \"@angular/router\"; import { routes } from \"./app.routes\"; import { provideStore, StoreModule } from \"@ngrx/store\"; import { counterReducer } from \"./aufgabe-1/counter.reducers\"; export const appConfig: ApplicationConfig = { providers: [ provideZoneChangeDetection({ eventCoalescing: true }), provideRouter(routes), provideStore(), importProvidersFrom(StoreModule.forRoot({ count: counterReducer })), ], }; Für uns relevant sind die beiden letzten provider in der appConfig. Zum einen muss der Store provided werden, zum anderen müssen aber auch Provider für die Reducer importiert werden. Auf der letzten Zeile innerhalb forRoot müssen also alle Reducer hinzugefügt werden, ansonsten funktioniert die Applikation nicht. Hast du das alles gemacht (und natürlich den MyCounterComponent im app.component.html hinzugefügt, damit dieser angezeigt wird) dürfte der Counter wie gewünscht funktionieren.\nAufgabe 2 - Aufgabenstellung Gehen wir nun weiter zur zweiten Aufgabe. Das Ziel der Aufgabe ist es, einen Online-Shop mit einer Produkübersicht und einem Warenkorb zu erstellen. Dabei sollen die Produktdaten als Mockdaten über einen Service bereitgestellt werden. Zudem soll es möglich sein, mithilfe von Routing zwischen den beiden Ansichten hin- und herzuwechseln.\nEin Produkt besteht aus 2 Attributen:\nName Preis In der Produktübersicht sollen alle Produkte angezeigt werden, indem Sie aus dem angesprochenen Service geholt werden. Für jedes Produkt soll ein Button bestehen, mit welchem man dieses zum Warenkorb hinzufügen kann. Der Warenkorb soll alle Produkte anzeigen, welche in der Produktübersicht zu diesem hinzugefügt wurden. Der Warenkorbzustand soll hierbei mithilfe von NgRx verwaltet werden. Die folgenden Aktionen sollen im Kontext des Warenkorbs ausgeführt werden können:\nHinzufügen von Produkten in den Warenkorb Entfernen von Produkten aus dem Warenkorb Ausgabe einer Liste aller Produkte im Warenkorb Zudem soll es ebenfalls möglich sein, den Kaufprozess per Knopfdruck abzuschliessen (und somit den Warenkorb zu leeren), womit ebenfalls die folgende Funktionalität dazukommt:\nLeeren des Warenkorbs Wir gehen die Lösung, gleich wie bei der ersten Aufgabe, nun Schritt für Schritt durch:\nAufgabe 2 - Actions Wie bei der ersten Aufgabe gilt es als erstes, die jeweiligen nötigen Actions zu definieren. Aus der Aufgabenstellung konnten wir die folgenden 4 Anwendungsfälle auslesen:\nHinzufügen eines Produkts in den Warenkorb Entfernen eines Produkts aus dem Warenkorb Leeren des Warenkorbs Abschliessen einer Bestellung Da das Leeren des Warenkorbs und das Abschliessen einer Bestellung grundsätzlich dasselbe Verhalten zur Folge haben, nämlich einen leeren Warenkorb, könnte man die Anzahl der Actions auf 3 reduzieren und beim Abschliessen einer Bestellung einfach die Action für das leeren des Warenkorbs nutzen, der Vollständigkeit halber wird in diesem Beispiel aber mit einer separaten Action für den Abschluss einer Bestellung gearbeitet. Die 4 Actions sähen umgesetzt aus wie folgt (in diesem Fall heisst die Datei shopping-cart.actions.ts):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import { createAction, props } from \"@ngrx/store\"; import { ProductModel } from \"../models/product-model\"; export enum ActionTypes { ADDPRODUCT = \"[ShoppingCart Component] add product\", REMOVEPRODUCT = \"[ShoppingCart Component] remove product\", EMPTYSHOPPINGCART = \"[ShoppingCart Component] empty shopping cart\", COMPLETEORDER = \"[ShoppingCart Component] complete order\", } export const addProduct = createAction( ActionTypes.ADDPRODUCT, props\u003c{ product: ProductModel }\u003e(), ); export const removeProduct = createAction( ActionTypes.REMOVEPRODUCT, props\u003c{ name: string }\u003e(), ); export const emptyShoppingCart = createAction(ActionTypes.EMPTYSHOPPINGCART); export const completeOrder = createAction(ActionTypes.COMPLETEORDER); Die Actions für das Leeren des Warenkorbs und das Abschliessen der Bestellung sind wie oben erwähnt identisch und unterscheiden sich nicht von den Actions, die wir bisher umgesetzt haben. Interessant wird es bei der Action für das Hinzufügen eines Produkts; Dort nutzen wir nämlich die props-Funktion. In diesem Fall beschreibt props die Parameter, die wir der Action beifügen wollen. Im Falle von addProduct entspricht das einer Instanz des ProductModel (schauen wir gleich noch an), im Falle von removeProduct einem String, welcher den Namen des zu entfernenden Produkts enthält. Das ist bereits alles, was wir in den Actions machen müssen.\nAufgabe 2 - Model Oben haben wir bereits das ProductModel verwendet. Dieses ist eine Klasse, welches wir der Einfachheit halber verwenden, um die nötigen Attribute name und preis zum jeweiligen Produkt zu speichern. Das Model sieht aus wie folgt und befindet sich in diesem Beispiel in der Datei product-model.ts:\n1 2 3 4 5 6 7 8 9 export class ProductModel { name: string; price: number; constructor(name: string, price: number) { this.name = name; this.price = price; } } Dieses Model werden wir durch die Aufgabenstellung immer wieder verwenden.\nAufgabe 2 - interfaces Um uns die Handhabung der jeweiligen States, insbesondere für den Fall, dass mehrere in einer Applikation verwendet werden, einfacher zu gestalten und die spätere Nutzung von selectors zu ermöglichen, können wir jeweils eigene definieren. Der eigene State für die Produkte, die später im Warenkorb angezeigt werden, sieht im Beispiel aus wie folgt und befindet sich in der (eigens dazu erstellten) Datei index.ts:\n1 2 3 4 5 6 7 8 9 import { ProductModel } from \"../models/product-model\"; export interface ProductState { products: ProductModel[]; } export const initalState: ProductState = { products: [], }; Der Ablauf hier ist relativ simpel: Wir definieren ein exportierbares interface ProductState, welches ein Array von ProductModels enthält. Zudem definieren wir einen initialen Zustand für den Inhalt des States, in diesem Fall einfach ein leeres Array.\nAufgabe 2 - Reducers Wie bereits bei der ersten Aufgabe folgt auf die Definition der Actions die Definition der jeweils dazugehörigen Reducers. Diese sehen aus wie folgt und befinden sich in diesem Beispiel in der Datei shopping-cart.reducers.ts:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import { createReducer, on } from \"@ngrx/store\"; import { addProduct, completeOrder, emptyShoppingCart, removeProduct, } from \"./shopping-cart.actions\"; import { initalState } from \"./index\"; export const shoppingCartReducer = createReducer( initalState, on(addProduct, (state, { product }) =\u003e ({ ...state, products: [...state.products, product], })), on(removeProduct, (state, { name }) =\u003e ({ ...state, products: state.products.filter((product) =\u003e product.name !== name), })), on(emptyShoppingCart, (state) =\u003e ({ ...state, products: [], })), on(completeOrder, (state) =\u003e ({ ...state, products: [], })), ); Hier wird es interessant: Da wir mit einem Array arbeiten, können wir nicht, wie beispielsweise in der ersten Aufgabe, einfach den state nehmen und diesen mutieren. Schauen wir uns dazu mal den ersten Reducer an:\n1 2 3 4 on(addProduct, (state, { product }) =\u003e ({ ...state, products: [...state.products, product], })); Als erstes definieren wir wieder zu Beginn mit on(), wann der Reducer ausgeführt werden soll. In diesem Fall passiert das, sobald die Action addProduct aufgerufen wird. Danach wird es spannend: In den runden Klammern geben wir als zweites Argument state, {product}an. Der state erklärt sich von selbst, den brauchen wir immer. {product} hingegen stellt den Parameter dar, der mit der Action geliefert wird. Innerhalb der Arrow-Function passieren dann zwei Dinge:\nEs wird eine shallow-copy des states gemacht. Das Attribut products wird mit den bisherigen products plus dem neu hinzuzufügenden product gespeichert. Auf diese Art und Weise garantieren wir, dass beim Hinzufügen eines neuen Produkts alle bisherigen Werte ebenfalls übernommen werden.\nAuch interessant ist der zweite Reducer, der zum Entfernen eines Produkts aus dem state verwendet wird:\n1 2 3 4 on(removeProduct, (state, { name }) =\u003e ({ ...state, products: state.products.filter((product) =\u003e product.name !== name), })); Der Ablauf bis zur Anpassung des products-Arrays ist derselbe, ausser dass hier nur der name des Produkts und nicht die ganze Struktur als Parameter erwartet wird. In der Definition des products-Arrays wird dann der aktuelle Zustand des Arrays genommen und alle darin enthaltenen Produkte mit dem entsprechenden Namen, der geliefert wurde, werden entfernt.\nWichtig: Diese Lösung ist eher unschön, es werden nämlich alle Instanzen eines Produkts aus dem Array entfernt, wenn mehrere vorhanden sind. Wenn beispielsweise 2 Fussbälle im Array sind, werden beide entfernt, da sie ja denselben Namen haben. Hätten wir eine ID für die jeweiligen Produkte verwendet, hätte man mit dieser auch einzelne Instanzen mehrfach vorkommender Produkte entfernen können. Da in der Aufgabenstellung aber keine ID vorgesehen ist, können wir in diesem Fall dieses Verhalten akzeptieren. Es ist aber auch möglich, den Filter so anzupassen, dass nach einer Entfernung eines Elements, das mehrfach vorkommt, die Filtrierung gestoppt wird. Wenn du möchtest, kannst du probieren, den Filter entsprechend anzupassen.\nDie beiden Reducer für das Leeren des Warenkorbs und das Abschliessen der Bestellung sind hierbei nicht gross erwähnenswert, da einfach das Array products auf einen leeren Zustand zurückgesetzt wird.\nAufgabe 2 - Selectors Im Vergleich zu der ersten Aufgabe gibt es hier ein neues Konzept, welches wir verwenden, nämlich die sogenannten Selectors. In der ersten Aufgabe haben wir den Inhalt des Stores direkt im Component mit store.select() ausgelesen und dabei einfach den entsprechenden Key aus dem Store verwendet. Um die Auslese der Daten aus dem Store aber ein wenig zu verschönern und applikationsweit zu vereinheitlichen, können wir mit Selektoren arbeiten. Der Selektor für diese Aufgabe sieht aus wie folgt und befindet sich in der Datei shopping-cart.selectors.ts:\n1 2 3 4 5 6 7 8 9 10 import { ProductState } from \"./index\"; import { createFeatureSelector, createSelector } from \"@ngrx/store\"; export const selectShoppingCartState = createFeatureSelector\u003cProductState\u003e(\"products\"); export const getShoppingCartProducts = createSelector( selectShoppingCartState, (state) =\u003e state.products, ); Hier kommt der ProductState zum Tragen, den wir zu Beginn in der index.ts-Datei definiert haben. Mit diesem erstellen wir zuerst eine exportierbare Konstante selectShoppingCartState, die einen sogenannten FeatureSelector darstellt, die den ProductState ausliest. Daraufhin müssen wir erneut eine exportierbare Konstante getShoppingCartProducts erstellen, welche wir dann jeweils in den Components aufrufen können. Dieser nimmt innerhalb der Funktion createSelector den vorher erstellten FeatureSelector selectShoppingCartState als Parameter entgegen und gibt darauf aus dem state heraus die products aus. Das wäre bereits alles, was wir im Rahmen der Selectors machen müssen.\nAufgabe 2 - app.config.ts Damit unsere Reducer und Selektoren korrekt funktionieren, müssen wir, wie in der ersten Aufgabe, Anpassungen in der app.config.ts-Datei machen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import { ApplicationConfig, importProvidersFrom, provideZoneChangeDetection, } from \"@angular/core\"; import { provideRouter } from \"@angular/router\"; import { routes } from \"./app.routes\"; import { provideStore, StoreModule } from \"@ngrx/store\"; import { shoppingCartReducer } from \"./aufgabe-2/ngrx/shopping-cart.reducers\"; import { provideStoreDevtools } from \"@ngrx/store-devtools\"; export const appConfig: ApplicationConfig = { providers: [ provideZoneChangeDetection({ eventCoalescing: true }), provideRouter(routes), provideStore(), importProvidersFrom(StoreModule.forRoot({ products: shoppingCartReducer })), ], }; Relevant sind für uns diese beiden Auszüge aus dem providers-Array:\n1 provideStore(), importProvidersFrom(StoreModule.forRoot({ products: shoppingCartReducer }) provideStore benötigen wir, um überhaupt erst den Store nutzen zu können, den zweiten Teil benötigen wir wiederum, damit die Reducer funktionieren und der State mit state.select(\"products\") im Selektor ausgelesen werden kann.\nAufgabe 2 - Service Im Rahmen der Aufgabe solltest du einen Service erstellen, mit dem du gemockte Daten an den Übersichts-Component senden kannst. Einen neuen Service für die Produkte kannst du einfach mit dem Befehl ng g s product in der Konsole generieren lassen. Der Inhalt des Services bleibt dabei relativ simpel: Wir müssen zum einen die Produkte mocken (dafür können wir direkt das Model nutzen, das wir bisher auch schon gebraucht haben) und eine Methode bereitstellen, die diese an den entsprechenden Component liefern kann. Der Service sähe dann in etwa so aus:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import { Injectable } from \"@angular/core\"; import { ProductModel } from \"../models/product-model\"; @Injectable({ providedIn: \"root\", }) export class ProductService { private products: ProductModel[] = []; constructor() { this.products = [ { name: \"Federball 🏸\", price: 100 }, { name: \"Fussball ⚽\", price: 1000 }, { name: \"Basketball 🏀\", price: 500 }, { name: \"Volleyball 🏐\", price: 800 }, { name: \"Skateboard 🛹\", price: 900 }, { name: \"Tennisball 🎾\", price: 2 }, { name: \"Bowlingkugel 🎳\", price: 600 }, { name: \"Tischtennisball 🏓\", price: 800 }, { name: \"Hockeyball 🏑\", price: 700 }, { name: \"Abschlussball 🕺\", price: 800 }, ]; } getAllProducts() { return this.products; } } Aufgabe 2 - Components erstellen / Routing Wir brauchen in dieser Aufgabe 2 Components:\nEin Component als Startseite mit allen Produkten Ein Component als Warenkorb mit allen ausgewählten Produkten Diese beiden Components kannst du wieder einfach per Konsole mit dem Befehl ng g c {name} generieren lassen. Wie die Components genau aussehen, schauen wir gleich genauer an. Vorher definieren wir aber direkt das Routing zwischen den jeweiligen Komponenten. Als erstes muss direkt das router-outlet-Tag im AppComponent hinzugefügt werden, damit das Routing überhaupt funktioniert. Das ist auch schon alles, was in die Datei app.component.html rein muss:\n1 \u003crouter-outlet\u003e\u003c/router-outlet\u003e Danach können wir die Routen bereits in der app.routes.ts-Datei definieren. In diesem Beispiel heissen die Components OverviewComponent und ShoppingCartComponent. Wenn du deine Components anders bezeichnet hast, musst du lediglich die Definition nach component: entsprechend anpassen. Für das Beispiel sähen die Routen aber aus wie folgt:\n1 2 3 4 5 6 7 8 import { Routes } from \"@angular/router\"; import { OverviewComponent } from \"./aufgabe-2/components/overview/overview.component\"; import { ShoppingCartComponent } from \"./aufgabe-2/components/shopping-cart/shopping-cart.component\"; export const routes: Routes = [ { path: \"\", component: OverviewComponent }, { path: \"shopping-cart\", component: ShoppingCartComponent }, ]; Als Ausgangscomponent nehmen wir (logischerweise) den Component mit der Übersicht, dafür geben wir ihm einfach einen leeren Path an. Nun bleiben nur noch die Components, dann haben wir die Übung bereits geschafft.\nAufgabe 2 - Übersichts-Component Im Übersichts-Component wollen wir als erstes die Mock-Daten aus dem Service holen. Dazu müssen wir lediglich im Constructor die getAllProducts() aus dem Service aufrufen und einer entsprechenden Variable zuweisen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import { Component } from \"@angular/core\"; import { ProductService } from \"../../services/product.service\"; import { ProductModel } from \"../../models/product-model\"; import { Store } from \"@ngrx/store\"; import { addProduct } from \"../../ngrx/shopping-cart.actions\"; import { RouterLink } from \"@angular/router\"; @Component({ selector: \"app-overview\", imports: [RouterLink], templateUrl: \"./overview.component.html\", styleUrl: \"./overview.component.scss\", }) export class OverviewComponent { protected products: ProductModel[] = []; constructor( private store: Store\u003c{ products: ProductModel[] }\u003e, private productService: ProductService, ) { this.products = this.productService.getAllProducts(); } } Nachdem wir die Daten für die Anzeige vorbereitet haben, können wir auch schon die Funktion für das Hinzufügen eines Produkts definieren:\n1 2 3 4 addProduct(product:ProductModel) { this.store.dispatch(addProduct({ product: product })); } Da wir das jeweilige Product aus dem Template erhalten, geben wir dieses hier als Parameter für die Funktion an. Die action für das Hinzufügen des Produkts lösen wir entsprechend mit this.store.dispatch(addProduct())) aus. Neu ist hier die Nutzung eines Parameters innerhalb der Action. Parameter für actions werden jeweils in geschweiften Klammern als key-value-Paar angegeben. Da wir in der entsprechenden Action den Parameter als product definiert haben, ist das hier auch der key. Als value geben wir dann noch das aus dem Template gelieferte product an. Das ist bereits alles, was wir auf der Seite der Logik machen müssen.\nAls nächstes schauen wir das Template und somit die Anzeige der Daten an:\n1 2 3 4 5 6 7 8 9 10 11 12 \u003cdiv class=\"title-container\"\u003e \u003ca routerLink=\"\"\u003eÜbersicht\u003c/a\u003e \u003ca routerLink=\"shopping-cart\"\u003eWarenkorb\u003c/a\u003e \u003c/div\u003e @for (product of products; track product.name){ \u003cdiv class=\"product-container\"\u003e \u003cp\u003eName: {{product.name}}\u003c/p\u003e \u003cp\u003ePreis: {{product.price}}\u003c/p\u003e \u003cbutton (click)=\"this.addProduct(product)\"\u003e🛒\u003c/button\u003e \u003c/div\u003e } Hier fallen direkt einige Dinge auf: Zuoberst haben wir die Navigation, die zwischen den beiden Components stattfindet. Die jeweiligen Links befinden sich standardmässig in a-Tags. Hierbei aber ganz wichtig: Es muss routerLink statt href für die Angabe des Paths verwendet werden. Wenn in Angular per href navigiert wird, wird in NgRx der Store auf den Ausgangswert zurückgesetzt. Unter Vewendung von routerLink tritt dieses Verhalten hingegen nicht auf.\nDer Rest ist eigentlich relativ simpel. Wir iterieren mit @for über die Elemente des products -Arrays und generieren für jedes Element eine Anzeige des Namens und des Preises und einen Button, der für das jeweilige Element die addProduct-action auslöst. In der Erarbeitung dieser Lösung wurde zusätzlich ein wenig SCSS verwendet, um die Seite einigermassen anschaulich zu gestalten. Du musst das jeweils nicht machen, bei Interesse kannst du dir aber dennoch das SCSS anschauen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 .title-container { font-size: 2rem; display: flex; justify-content: space-around; } .product-container { text-align: center; width: 49%; float: left; display: inline-block; font-size: 1.5rem; margin: 0 0 2% 0; } Die Seite sieht, wenn sie so umgesetzt und gestylt wird wie hier, schlussendlich so aus: Aufgabe 2 - Warenkorb-Component Zum Schluss müssen wir nun noch einen Component für den Warenkorb erstellen, in welchem die jeweiligen zum Warenkorb hinzugefügten Produkte angezeigt werden. Zur Erinnerung; Im Warenkorb müssen die folgenden Funktionalitäten umgesetzt sein:\nEntfernen eines Produkts aus dem Warenkorb Leeren des Warenkorbs Abschliessen der Bestellung Beginnen wir wieder in der Typescript-Datei:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import { Component } from \"@angular/core\"; import { Observable } from \"rxjs\"; import { Store } from \"@ngrx/store\"; import { ProductModel } from \"../../models/product-model\"; import { AsyncPipe } from \"@angular/common\"; import { getShoppingCartProducts } from \"../../ngrx/shopping-cart.selectors\"; import { RouterLink } from \"@angular/router\"; import { completeOrder, emptyShoppingCart, removeProduct, } from \"../../ngrx/shopping-cart.actions\"; @Component({ selector: \"app-shopping-cart\", imports: [RouterLink, AsyncPipe], templateUrl: \"./shopping-cart.component.html\", styleUrl: \"./shopping-cart.component.scss\", }) export class ShoppingCartComponent { products$: Observable\u003cProductModel[]\u003e = new Observable\u003cProductModel[]\u003e(); constructor(private store: Store\u003c{ products: ProductModel[] }\u003e) { this.products$ = this.store.select(getShoppingCartProducts); } removeProduct(productName: string) { this.store.dispatch(removeProduct({ name: productName })); } emptyShoppingCart() { this.store.dispatch(emptyShoppingCart()); } completeOrder() { this.store.dispatch(completeOrder()); alert(\"Bestellung abgeschlossen!\"); } } Hier passiert direkt einiges:\nEs werden die Produkte in einem Observable gespeichert, da die Daten unter Auslesung aus dem Store diese Form annehmen. Der Typ des Observables ist dabei ProductModel[]. Wir definieren im Constructor einen privaten store, über den wir die actions ausführen. Mit {products: ProductModel[]} spezifizieren wir dabei, welche Form die ausgelesenen Daten haben. Wir lesen die Daten aus dem Store mit dem zu Beginn von uns definierten selector getShoppingCartProducts und übergeben diese an products$. Wir definieren die jeweiligen Funktionen für das Entfernen eines Produkts, das Leeren des Warenkorbs und das Abschliessen einer Bestellung. Den logischen Teil im Component haben wir nun bereits abgeschlossen. Nun bleibt nur noch das Template:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u003cdiv class=\"title-container\"\u003e \u003ca routerLink=\"\"\u003eÜbersicht\u003c/a\u003e \u003ca routerLink=\"shopping-cart\"\u003eWarenkorb\u003c/a\u003e \u003c/div\u003e @for (product of products$ | async; track product) { \u003cdiv class=\"product-container\"\u003e \u003cp\u003e{{ product.name }}\u003c/p\u003e \u003cp\u003e{{ product.price }}\u003c/p\u003e \u003cbutton class=\"remove-product\" (click)=\"removeProduct(product.name)\"\u003e 🗑 \u003c/button\u003e \u003c/div\u003e } @empty { \u003cdiv class=\"no-products-container\"\u003e \u003cp class=\"no-products-text\"\u003eNo Products in shopping cart\u003c/p\u003e \u003c/div\u003e } \u003cdiv class=\"empty-shopping-cart-container\"\u003e \u003cbutton class=\"empty-shopping-cart-button\" (click)=\"emptyShoppingCart()\"\u003e Empty Shopping Cart \u003c/button\u003e \u003c/div\u003e \u003cdiv class=\"complete-order-container\"\u003e \u003cbutton class=\"complete-order-button\" (click)=\"completeOrder()\"\u003e Complete Order \u003c/button\u003e \u003c/div\u003e Wie im Overview-Component hat es zuoberst als erstes die jeweilige Navigation zwischen den Components. Darauf wird wieder mit @for über die Produkte iteriert. Ein wichtiger Unterschied ist hierbei die |async-Pipe. Diese wird benötigt, da nur asynchron über Observables iteriert werden kann. Innerhalb des Loops hat es wieder eine Darstellung mit dem jeweligen Namen und Preis und einen Button für das Entfernen eines Produkts aus dem Warenkorb. Mit @empty nach dem Loop wird beschrieben, was passieren soll, wenn products$ keinen Wert enthält. In diesem Fall wird einfach der Text “No Products in shopping cart” angezeigt.\nSchlussendlich hat es dann noch 2 Buttons, welche jeweils die Funktionen für das Leeren des Warenkorbs und das Abschliessen einer Bestellung aufrufen.\nHier noch das SCSS-File für die Interessierten:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 .title-container { font-size: 2rem; display: flex; justify-content: space-around; } .product-container { text-align: center; width: 24%; float: left; display: inline-block; font-size: 1.5rem; margin: 5% 0 2% 0; .remove-product { font-size: 1.2rem; } } .no-products-container { width: 100%; text-align: center; .no-products-text { text-align: center; font-size: 50px; } } .empty-shopping-cart-container, .complete-order-container { width: 47%; display: inline-block; text-align: center; .empty-shopping-cart-button, .complete-order-button { width: 90%; margin: 2% 2% 0 2%; font-size: 50px; } } Die fertige Seite sieht mit dem obenstehenden Design dann aus wie folgt:\nAufgabe 3 - Aufgabenstellung Nun bleibt uns noch die dritte Aufgabe. Diese sieht es vor, eine TODO-Liste mithilfe von NgRx umzusetzen. Eine Task in dieser Liste beinhält jeweils die folgenden 3 Attribute:\nID Name Completed Es sollen, ähnlich wie bei der zweiten Aufgabe, 2 Seiten erstellt werden:\nEine, auf der alle offenen Tasks angezeigt werden. (Also alle, die im Attribut completed einen Wert von false innehaben.) Hier sollen Tasks hinzugefügt, entfernt und komplettiert werden können. Zudem sollen wie bei Aufgabe 2 Selektoren für das Auslesen der Tasks verwendet werden. Eine, auf der neue Tasks erstellt werden können. Hierbei soll der Name mittels eines Reactive Forms eingetragen werden können und der Wert completed immer mit false instanziert werden. Um sicherzugehen, dass die IDs jeweils einzigartig sind, nutzen wir für die Definition dieser new Date().getTime() (aktuelle Uhrzeit). Gehen wir also nun wie gehabt die einzelnen Schritte durch:\nAufgabe 3 - Actions Als Erstes kommen wieder die Actions, die wir anhand der vorgegebenen Anwendungsfälle definieren müssen. In dieser Aufgabe gibt es drei Funktionalitäten, die wir mithilfe von Actions bereitstellen müssen:\nEs muss möglich sein, eine neue Task zu erstellen Es muss möglich sein, eine Task zu entfernen Es muss möglich sein, eine Task abzuschliessen Aus dieser Aufgabenstellung ergeben sich dann die folgenden 3 Actions:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import { createAction, props } from \"@ngrx/store\"; import { TaskModel } from \"../models/task-model\"; export enum ActionTypes { ADDTASK = \"[Task Component] add task\", REMOVETASK = \"[Task Component] remove task\", COMPLETETASK = \"[Task Component] complete task\", } export const addTask = createAction( ActionTypes.ADDTASK, props\u003c{ task: TaskModel }\u003e(), ); export const removeTask = createAction( ActionTypes.REMOVETASK, props\u003c{ id: number }\u003e(), ); export const completeTask = createAction( ActionTypes.COMPLETETASK, props\u003c{ id: number }\u003e(), ); Hier gibt es im Vergleich zu Aufgabe 2 eigentlich nichts Neues. Wie gewohnt erstellen wir zuerst die jeweliigen ActionTypes, die die actions jeweils nachvollziehbar machen. Darauf folgt dann die effektive Definition der actions. Dabei wird wie immer zuerst der jewelige ActionType zugewiesen. In unserem Fall benötigen alle actions jeweils noch props (Paramater). addTask braucht eine ganze Task (da ja eine neue erstellt werden soll), wohingegen removeTask und completeTask jeweils nur die id der betroffenen Task brauchen.\nAufgabe 3 - Model Wie auch schon in Aufgabe 2 benutzen wir in dieser Lösung ein Model für die Tasks, um das Ganze übersichtlich zu gestalten. Das Model wurde in den Actions bereits in den props von addTask verwendet und sieht so aus:\n1 2 3 4 5 6 7 8 9 10 11 export class TaskModel { id: number; name: string; completed: boolean; constructor(id: number, name: string) { this.id = id; this.name = name; this.completed = false; } } Achte hierbei darauf, dass das completed-Attribut nicht als Parameter im Constructor geliefert wird, sondern direkt auf false gesetzt wird. In der Aufgabenstellung steht als Anforderung, dass Tasks zum Zeitpunkt der Erstellung immer nicht completed sein sollen, daher können wir uns so jeweils einen Parameter beim Erstellen einer neuen Task sparen.\nAufgabe 3 - Interfaces Wie auch in Aufgabe 2 macht es in diesem Fall Sinn, einen separaten State für die Tasks zu erstellen. Dazu wurde hier wieder eine Datei index.ts erstellt, um das Interface für den State und den intialState für den Reducer unterzubringen. Die Datei sieht aus wie folgt:\n1 2 3 4 5 6 7 8 9 import { TaskModel } from \"../models/task-model\"; export interface TaskState { tasks: TaskModel[]; } export const initalState: TaskState = { tasks: [], }; Da wir mit mehreren Tasks arbeiten, geben wir im TaskState an, dass wir ein Array an TaskModels speichern möchten. Als initalState geben wir einfach ein leeres Array an.\nAufgabe 3 - Reducers Nun kommen wir auch schon zu den Reducers; Wie bisher auch müssen wir für jede Action, die wir definiert haben, einen entsprechenden Reducer schreiben, der die effektiv ausgeführte Logik beinhält. Die task.reducers.ts-Datei sollte dabei aussehen wie folgt:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import { createReducer, on } from \"@ngrx/store\"; import { initalState } from \"./index\"; import { addTask, completeTask, removeTask } from \"./task.actions\"; export const taskReducer = createReducer( initalState, on(addTask, (state, { task }) =\u003e ({ ...state, tasks: [...state.tasks, task], })), on(removeTask, (state, { id }) =\u003e ({ ...state, tasks: state.tasks.filter((task) =\u003e task.id !== id), })), on(completeTask, (state, { id }) =\u003e ({ ...state, tasks: state.tasks.map((task) =\u003e task.id === id ? { ...task, completed: true } : task, ), })), ); Als erstes wird in der createReducer Funktion der initialState aus der index.ts als Parameter mitgegeben, worauf dann die jeweiligen Reducer folgen. Der Reducer für die addTask-action ist hierbei praktisch gleich wie der addProduct-Reducer aus Aufgabe 2; Es wird eine Shallow-Copy des derzeitigen state gemacht und die neue task wird angehängt.\nDer Reducer für removeTask funktioniert ebenfalls praktisch gleich wie der removeProduct-Reducer aus Aufgabe 2; Es wird eine Shallow-Copy des derzeitigen state gemacht, wonach der Eintrag im Array mit der mitgegebenen id aus dem Array gefiltert wird. Denken wir nochmal kurz zu Aufgabe 2 zurück: Dort war das Problem bei removeProduct ja, dass alle Einträge mit demselben Namen aus dem Array entfernt wurden, da wir anhand des name-Attributs des Produkts gefiltert haben. Dieses Problem gibt es hier nicht mehr, da wir mit der id gefiltert haben, die einzigartig ist (da sie basierend auf der derzeitigen Uhrzeit generiert wird, die Umsetzung dazu folgt noch).\nDer Reducer für completeTask ist hierbei der spannendenste. Wir können nicht einfach eine neue Task anfügen oder herausfiltern. Wir müssen stattdessen anhand der gelieferten id den entsprechenden Eintrag aus dem Array herauspicken und dessen completed-Attribut verändern. Dazu können wir auf dem tasks-Array die map-Methode nutzen, um auf die einzelnen Tasks zugreifen zu können. Bei den einzelnen Tasks prüfen wir daraufhin, ob deren id mit der gelieferten übereinstimmt. Ist das der Fall, wird für die jeweilige Task das completed-Attribut auf true gesetzt, ansonsten passiert nichts.\nAufgabe 3 - Selectors Wie auch schon in Aufgabe 2 sieht die Aufgabenstellung vor, dass wir Selectors nutzen, um die Tasks aus dem Store auszulesen. Der Code dazu sieht aus wie folgt:\n1 2 3 4 5 6 import { createFeatureSelector, createSelector } from \"@ngrx/store\"; import { TaskState } from \"./index\"; export const selectTaskState = createFeatureSelector\u003cTaskState\u003e(\"tasks\"); export const getTasks = createSelector(selectTaskState, (state) =\u003e state.tasks); Der Aufbau des Selectors ist genau derselbe wie bei Aufgabe 2; Als erstes definieren wir eine exportierbare Konstante selectTaskState, die einen FeatureSelector erstellt, der die tasks aus dem TaskState ausliest. Danach definieren wir eine exportierbare Konstante getTasks, welche einen Selector beinhält, der den TaskState mit selectTaskState ausliest und darauf basierend die tasks zurückgibt.\nAufgabe 3 - app.config.ts Wie immer müssen wir die Datei app.config.ts anpassen, damit unsere Reducer und Selectors funktionieren. Die Datei sollte angepasst so aussehen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import { ApplicationConfig, importProvidersFrom, provideZoneChangeDetection, } from \"@angular/core\"; import { provideRouter } from \"@angular/router\"; import { routes } from \"./app.routes\"; import { provideStore, StoreModule } from \"@ngrx/store\"; import { provideStoreDevtools } from \"@ngrx/store-devtools\"; import { taskReducer } from \"./aufgabe-3/ngrx/task.reducers\"; export const appConfig: ApplicationConfig = { providers: [ provideZoneChangeDetection({ eventCoalescing: true }), provideRouter(routes), provideStore(), importProvidersFrom(StoreModule.forRoot({ tasks: taskReducer })), ], }; Aufgabe 3 - Components erstellen / Routing Die Aufgabenstellung sieht zwei Views vor: Einmal eine Übersicht mit allen offenen Tasks und einmal eine Seite, auf der die Tasks erstellt werden können. Dazu können wir einfach mit dem Befehl ng g c {name} die beiden Components in der Konsole erstellen. Nach der Erstellung können wir direkt das Routing für die beiden Components vorbereiten, damit wir nachher nur noch in den Components selbst arbeiten müssen. Die app.routes.ts-Datei sollte daher aussehen wie folgt:\n1 2 3 4 5 6 7 8 import { Routes } from \"@angular/router\"; import { OverviewComponent } from \"./aufgabe-3/components/overview/overview.component\"; import { CreateTaskComponent } from \"./aufgabe-3/components/create-task/create-task.component\"; export const routes: Routes = [ { path: \"\", component: OverviewComponent }, { path: \"create-task\", component: CreateTaskComponent }, ]; Da der OverviewComponent als Ausgangscomponent dienen soll, geben wir diesem einen leeren Path.\nAufgabe 3 - Component für die Task-Erstellung Nun bleibt uns nur noch die Umsetzung der beiden Components. Wir fangen hierbei mit dem Component für die Erstellung der Tasks an, da wir ansonsten Daten für die Umsetzung des Übersichts-Components mocken müssten. Beginnen wir beim ts-File des Components:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import { Component } from \"@angular/core\"; import { FormControl, ReactiveFormsModule } from \"@angular/forms\"; import { TaskModel } from \"../../models/task-model\"; import { Store } from \"@ngrx/store\"; import { addTask } from \"../../ngrx/task.actions\"; import { RouterLink } from \"@angular/router\"; @Component({ selector: \"app-create-task\", imports: [ReactiveFormsModule, RouterLink], templateUrl: \"./create-task.component.html\", styleUrl: \"./create-task.component.scss\", }) export class CreateTaskComponent { name = new FormControl(\"\"); constructor(private store: Store\u003c{ tasks: TaskModel[] }\u003e) {} addTask() { let task = new TaskModel( Date.now(), this.name.value ? this.name.value : \"\", ); this.store.dispatch(addTask({ task })); this.name = new FormControl(\"\"); } } Als erstes bereiten wir in der Datei die FormControl für die Eingabe des Namens vor (die Aufgabenstellung sieht vor, dass der Name der zu erstellenden Task mit einem Reactive Form eingetragen wird). Im Constructor instanzieren wir darauf direkt den Store, um anschliessend die Actions aufrufen zu können.\nZuletzt bereiten wir auch schon direkt die Funktion für das Erstellen einer neuen Task vor. Dazu erstellen wir zuerst ein neues Objekt vom Typ TaskModel. Als Parameter geben wir dabei zuerst die id in Form von Date.now() mit, da wir so garantieren können, dass das id-Attribut über alle Tasks einzigartig ist. Als zweiten Parameter geben wir dann, insofern der value der FormControl für den Namen nicht null oder undefined entspricht, den Inhalt der FormControl mit. Entspricht dieser null oder undefined geben wir einen leeren String als Namen mit.\nZuletzt instanzieren wir die FormControl für den Namen neu, um die das Textfeld für den Nutzer wieder zu leeren.\nAls Nächstes muss das entsprechende Template für die Erstellung der Task umgesetzt werden. Das sieht in diesem Fall aus wie folgt:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u003cdiv class=\"header\"\u003e \u003ca class=\"header-link\" routerLink=\"\"\u003eÜbersicht\u003c/a\u003e \u003ca class=\"header-link\" routerLink=\"/create-task\"\u003eTask erstellen\u003c/a\u003e \u003c/div\u003e \u003cdiv class=\"create-task-container\"\u003e \u003clabel class=\"create-task-label\" for=\"name\"\u003eName: \u003c/label\u003e \u003cinput class=\"create-task-input\" id=\"name\" type=\"text\" [formControl]=\"name\" /\u003e \u003cbutton class=\"create-task-button\" (click)=\"addTask()\" [disabled]=\"name.value === ''\" \u003e Create \u003c/button\u003e \u003c/div\u003e Das Template ist in diesem Fall relativ überschaubar. Als erstes haben wir einen kleinen Header, mit dem wir zwischen der Übersicht und der Task-Erstellung hin- und herwechseln können.\nDarunter befindet sich dann schon die Eingabe für die Task-Erstellung. Wir verbinden einen Input mit der FormControl und einen Knopf mit der addTask()-Funktion, die wir vorher erstellt haben. Wie auch schon in Aufgabe 2 wurde für diese Lösung ein rudimentäres Styling umgesetzt, welches ihr aber nicht zwingend umsetzen müsst. Für die Interessierten folgt noch der Inhalt das SCSS-Files:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 .header { width: 100vw; text-align: center; .header-link { margin: 0 5% 0 5%; font-size: 2rem; } } .create-task-container { width: 100vw; margin: 5% 0 0 0; } Die fertige Seite für die Erstellung der Tasks sieht schlussendlich aus wie folgt: Aufgabe 3 - Übersicht Da wir nun die Erstellung der Tasks ermöglicht haben, können wir nun zum Schluss noch die Seite für die Übersicht aller offenen Tasks umsetzten. Die fertige Version der ts-Datei für diesen Component sieht aus wie folgt:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import { Component } from \"@angular/core\"; import { RouterLink } from \"@angular/router\"; import { TaskModel } from \"../../models/task-model\"; import { Observable } from \"rxjs\"; import { getTasks } from \"../../ngrx/task.selectors\"; import { Store } from \"@ngrx/store\"; import { AsyncPipe } from \"@angular/common\"; import { completeTask, removeTask } from \"../../ngrx/task.actions\"; @Component({ selector: \"app-overview\", imports: [RouterLink, AsyncPipe], templateUrl: \"./overview.component.html\", styleUrl: \"./overview.component.scss\", }) export class OverviewComponent { tasks$ = new Observable\u003cTaskModel[]\u003e(); constructor(private store: Store\u003cTaskModel[]\u003e) { this.tasks$ = this.store.select(getTasks); } completeTask(id: number) { this.store.dispatch(completeTask({ id })); } removeTask(id: number) { this.store.dispatch(removeTask({ id })); } } Als Erstes erstellen wir ein Observable vom Typ Observable\u003cTaskModel[]\u003e, in dem wir anschliessend die Tasks aus dem Store ablegen können. Im Constructor instanzieren wir daraufhin den Store, um die Ausführung von Actions und die Nutzung von Selectors zu ermöglichen. Innerhalb des Constructors befüllen wir zudem direkt das vorher erstellte Observable mit den Tasks, indem wir den Selector ausführen.\nZuletzt definieren wir direkt die beiden Funktionen für das Komplettieren und Entfernen der Tasks. Beide Funktionen nehmen jeweils die id der jeweiligen Task entgegen und rufen mit this.store.dispatch() die entsprechende action auf.\nAnschliessend können wir das Template umsetzen, das im Falle dieser Lösung aussieht wie folgt:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u003cdiv class=\"header\"\u003e \u003ca class=\"header-link\" routerLink=\"\"\u003eÜbersicht\u003c/a\u003e \u003ca class=\"header-link\" routerLink=\"/create-task\"\u003eTask erstellen\u003c/a\u003e \u003c/div\u003e @for (task of tasks$ | async; track task.id) { @if (!task.completed) { \u003cdiv class=\"task-container\"\u003e \u003cp class=\"task-text\"\u003eID: {{ task.id }}\u003c/p\u003e \u003cp class=\"task-text\"\u003eName: {{ task.name }}\u003c/p\u003e \u003cp\u003e{{task.completed}}\u003c/p\u003e \u003cdiv class=\"task-button-container\"\u003e \u003cbutton (click)=\"completeTask(task.id)\"\u003eTask abschliessen\u003c/button\u003e \u003cbutton (click)=\"removeTask(task.id)\"\u003eTask entfernen\u003c/button\u003e \u003c/div\u003e \u003c/div\u003e } } @empty { \u003cp class=\"task-text\"\u003eKeine Tasks vorhanden\u003c/p\u003e } Zuoberst haben wir den exakt selben Header wie im Component für die Erstellung der Tasks.\nSpannend wird es aber ab Zeile 6. Dort iterieren wir übr das tasks$-Observable. (|async-Pipe nicht vergessen!) Darauf prüfen wir, bevor etwas angezeigt wird, für jede Task, ob das completed-Attribut auf false gesetzt ist. Die Task wird nur angezeigt, solange das der Fall ist. Insofern completed auf false gesetzt ist, wird anschliessend die id und der name der Task angezeigt. Für jede Task werden zudem zwei Knöpfe angezeigt, über die man sie jeweils abschliessen oder entfernen kann. Für den Fall, dass tasks$ keinen Inhalt hat, definieren wir mit @empty den Text “Keine Tasks vorhanden” als Platzhalter, damit nicht einfach nichts angezeigt wird.\nFür die Interessierten folgt noch das SCSS-File zum Component:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 .header { width: 100vw; text-align: center; .header-link { margin: 0 5% 0 5%; font-size: 2rem; } } .task-container { width: 45%; display: inline-block; background: blueviolet; border: 2px black solid; margin: 5% 1% 0 1%; .task-text { font-size: 2rem; } .task-button-container { width: 100%; display: flex; } } Der fertige Component sollte dann aussehen wie folgt: ","categories":"","description":"In diesem Abschnitt sollen die Lösungen aus dem zusätzlichen Labs für NgRx nochmal genauer beleuchtet werden.\n","excerpt":"In diesem Abschnitt sollen die Lösungen aus dem zusätzlichen Labs für …","ref":"/de/docs/03_web/07_angular-ngrx/05_ngrx-applied/","tags":"","title":"NgRx angwendet (Erst nach der Durchführung der NgRx-Labs anschauen)"},{"body":"Hallo Ninja!\nNachdem du Git und Bitbucket bereits kennengelernt und etwas über die wichtigsten Kommandos gelernt hast, erhältst du hier die Möglichkeit dein Wissen zu Git und Bitbucket zu vertiefen.\nDieses Modul ist fakultativ und gehört nicht zum normalen Ausbildungsplan. Es wird kein komplett neues Wissen vermittelt, sondern nur das bereits erlernte in einer realistischen Team-Umgebung angewandt. Dazu ist es erforderlich, dass das Modul von mindestens zwei Lernenden (mehr ist besser) gemeinsam bearbeitet wird.\nZiele Du kannst …\nin einem Team an mehreren gemeinsamen Projekten arbeiten. die lokalen Versionsstände mit den den Änderungen der Anderen zusammenführen. zwischen Projekten wechseln, ohne deine Änderungen zu verlieren. alle Git-Aktionen auch über IntelliJ ausführen. Peer-Reviews durchführen. Dazu wirst du bereits bekannte Themen wiederholen und …\nein existierendes Repository klonen. ein neues Repository erstellen. ein Repository in den Arbeitsbereich holen. Branches anlegen und mergen. erkennen, ob ein Branch bereits gemergt wurde. Dateien und Verzeichnisse zu einem Repository hinzufügen. Dateien und Verzeichnisse von der Versionsverwaltung ausschliessen. die Weboberfläche von Bitbucket bedienen. Schwerpunkte Das Lab ist in die folgende Aufgabenbereiche unterteilt:\nVoraussetzungen schaffen (Team bilden) Zusammenarbeit in einem Projekt Paralleles Arbeiten mit mehreren Repositories Hinweise Zu diesem fakultativen Modul gibt es kein Exam. Um dieses Modul erfolgreich zu bearbeiten ist Teamarbeit erforderlich. Die geplante Bearbeitungszeit liegt bei 1 - 2 Tagen. Hinweise zum Review Das Review zum Modul wird mit dem gesamten Team geführt. Das Team erläutert das Vorgehen und schildert auch aufgetretene Probleme. Ein Beispiel-Projekt soll im Vorfeld zu einem releasefähigen Stand gebracht worden sein, der die Änderungen aller Teammitglieder beinhaltet. Ein weiteres Beispielprojekt befindet sich noch in der Entwicklung. ","categories":"","description":"Gemeinsame Nutzung von Git in einem Team","excerpt":"Gemeinsame Nutzung von Git in einem Team","ref":"/docs/04_git/02_vertiefung/","tags":"","title":"Git Vertiefung"},{"body":"Hallo Ninja!\nNachdem du Git und Bitbucket bereits kennengelernt und etwas über die wichtigsten Kommandos gelernt hast, erhältst du hier die Möglichkeit dein Wissen zu Git und Bitbucket zu vertiefen.\nDieses Modul ist fakultativ und gehört nicht zum normalen Ausbildungsplan. Es wird kein komplett neues Wissen vermittelt, sondern nur das bereits erlernte in einer realistischen Team-Umgebung angewandt. Dazu ist es erforderlich, dass das Modul von mindestens zwei Lernenden (mehr ist besser) gemeinsam bearbeitet wird.\nZiele Du kannst …\nin einem Team an mehreren gemeinsamen Projekten arbeiten. die lokalen Versionsstände mit den den Änderungen der Anderen zusammenführen. zwischen Projekten wechseln, ohne deine Änderungen zu verlieren. alle Git-Aktionen auch über IntelliJ ausführen. Peer-Reviews durchführen. Dazu wirst du bereits bekannte Themen wiederholen und …\nein existierendes Repository klonen. ein neues Repository erstellen. ein Repository in den Arbeitsbereich holen. Branches anlegen und mergen. erkennen, ob ein Branch bereits gemergt wurde. Dateien und Verzeichnisse zu einem Repository hinzufügen. Dateien und Verzeichnisse von der Versionsverwaltung ausschliessen. die Weboberfläche von Bitbucket bedienen. Schwerpunkte Das Lab ist in die folgende Aufgabenbereiche unterteilt:\nVoraussetzungen schaffen (Team bilden) Zusammenarbeit in einem Projekt Paralleles Arbeiten mit mehreren Repositories Hinweise Zu diesem fakultativen Modul gibt es kein Exam. Um dieses Modul erfolgreich zu bearbeiten ist Teamarbeit erforderlich. Die geplante Bearbeitungszeit liegt bei 1 - 2 Tagen. Hinweise zum Review Das Review zum Modul wird mit dem gesamten Team geführt. Das Team erläutert das Vorgehen und schildert auch aufgetretene Probleme. Ein Beispiel-Projekt soll im Vorfeld zu einem releasefähigen Stand gebracht worden sein, der die Änderungen aller Teammitglieder beinhaltet. Ein weiteres Beispielprojekt befindet sich noch in der Entwicklung. ","categories":"","description":"Gemeinsame Nutzung von Git in einem Team","excerpt":"Gemeinsame Nutzung von Git in einem Team","ref":"/de/docs/04_git/02_vertiefung/","tags":"","title":"Git Vertiefung"},{"body":"Ziele Du weisst, was Standalone Components sind. Du kennst die Unterschiede zwischen standalone Components und regulären Components. Standalone Components Seit Angular 16 gibt es eine neue Art von Components, die erstellt und vewendet werden kann. Diese Standalone Components unterscheiden sich beim Grundaufbau nur gering von den traditionellen Components, die du bereits kennengelernt hat. Jedoch verbirgt sich dahinter ein neuer Weg, wie du deine Applikation strukturieren kannst.\nWas bedeutet Standalone Standalone Components sind anders als traditionelle Components Module unabhängig. Das bedeutet, dass sie zum einen nicht in einem Module definiert werden müssen und zum anderen, dass sie keine Imports aus einem Module erhalten. Durch diesen Aufbau können Standalone Components in jedem Kontext verwendet werden, ohne sie noch speziell deklarieren zu müssen.\nStandalone vs. Regular Reguläre Komponenten Im Gegensatz zu Standalone-Komponenten sind reguläre Komponenten modulabhängig. Sie müssen in einem Modul definiert und deklariert werden, um verwendet werden zu können. Sie können auch Imports aus ihrem Modul erhalten, was ihre Verwendung je nach Kontext einschränken kann.\nVergleich Modulabhängigkeit: Während reguläre Komponenten in einem Modul definiert werden müssen, sind Standalone-Komponenten modulunabhängig. Diese Tatsache gibt Standalone-Komponenten mehr Flexibilität, da sie in jedem Kontext verwendet werden können. Imports: Reguläre Komponenten können Imports aus ihrem Modul erhalten, während Standalone-Komponenten dies nicht tun. Dies kann die Wiederverwendbarkeit von Standalone-Komponenten erhöhen. Verwendung: Seit Angular 17 sind Standalone-Komponenten per Default aktiviert und eingesetzt, was ihre Verwendung fördert. Reguläre Komponenten hingegen erfordern eine spezifische Deklaration in ihrem Modul, um verwendet werden zu können. Insgesamt bieten Standalone-Komponenten also eine grössere Flexibilität und Wiederverwendbarkeit im Vergleich zu regulären Komponenten, was sie zu einer attraktiven Option für die Strukturierung von Angular-Anwendungen macht.\nappConfig Seit Angular 17 wird das AppModule nicht mehr automatisch beim Erstellen eines neuen Projekts generiert, da nun die Components default mässig Standalone sind. Jedoch wird trotzdem noch eine Datei benötigt, um externe Abhängigkeiten anzugeben. Die ist in diesem Fall die Datei app.config.ts, dort werden zum Beispiel die Abhängigkeiten wie die Angular Routes angegeben. Diese kann man einrichten, indem man provideRouter(routes) im providers-Array aufruft.\n1 2 3 4 5 6 7 8 import { ApplicationConfig } from \"@angular/core\"; import { provideRouter } from \"@angular/router\"; import { routes } from \"./app.routes\"; export const appConfig: ApplicationConfig = { providers: [provideRouter(routes)], }; ","categories":"","description":"Modul #F6 - Angular - Was sind Standalone Components?\n","excerpt":"Modul #F6 - Angular - Was sind Standalone Components?\n","ref":"/docs/03_web/06_angular/02_4_standalone-components/","tags":"","title":"Standalone Components"},{"body":"Ziele Du weisst, was Standalone Components sind. Du kennst die Unterschiede zwischen standalone Components und regulären Components. Standalone Components Seit Angular 16 gibt es eine neue Art von Components, die erstellt und vewendet werden kann. Diese Standalone Components unterscheiden sich beim Grundaufbau nur gering von den traditionellen Components, die du bereits kennengelernt hat. Jedoch verbirgt sich dahinter ein neuer Weg, wie du deine Applikation strukturieren kannst.\nWas bedeutet Standalone Standalone Components sind anders als traditionelle Components Module unabhängig. Das bedeutet, dass sie zum einen nicht in einem Module definiert werden müssen und zum anderen, dass sie keine Imports aus einem Module erhalten. Durch diesen Aufbau können Standalone Components in jedem Kontext verwendet werden, ohne sie noch speziell deklarieren zu müssen.\nStandalone vs. Regular Reguläre Komponenten Im Gegensatz zu Standalone-Komponenten sind reguläre Komponenten modulabhängig. Sie müssen in einem Modul definiert und deklariert werden, um verwendet werden zu können. Sie können auch Imports aus ihrem Modul erhalten, was ihre Verwendung je nach Kontext einschränken kann.\nVergleich Modulabhängigkeit: Während reguläre Komponenten in einem Modul definiert werden müssen, sind Standalone-Komponenten modulunabhängig. Diese Tatsache gibt Standalone-Komponenten mehr Flexibilität, da sie in jedem Kontext verwendet werden können. Imports: Reguläre Komponenten können Imports aus ihrem Modul erhalten, während Standalone-Komponenten dies nicht tun. Dies kann die Wiederverwendbarkeit von Standalone-Komponenten erhöhen. Verwendung: Seit Angular 17 sind Standalone-Komponenten per Default aktiviert und eingesetzt, was ihre Verwendung fördert. Reguläre Komponenten hingegen erfordern eine spezifische Deklaration in ihrem Modul, um verwendet werden zu können. Insgesamt bieten Standalone-Komponenten also eine grössere Flexibilität und Wiederverwendbarkeit im Vergleich zu regulären Komponenten, was sie zu einer attraktiven Option für die Strukturierung von Angular-Anwendungen macht.\nappConfig Seit Angular 17 wird das AppModule nicht mehr automatisch beim Erstellen eines neuen Projekts generiert, da nun die Components default mässig Standalone sind. Jedoch wird trotzdem noch eine Datei benötigt, um externe Abhängigkeiten anzugeben. Die ist in diesem Fall die Datei app.config.ts, dort werden zum Beispiel die Abhängigkeiten wie die Angular Routes angegeben. Diese kann man einrichten, indem man provideRouter(routes) im providers-Array aufruft.\n1 2 3 4 5 6 7 8 import { ApplicationConfig } from \"@angular/core\"; import { provideRouter } from \"@angular/router\"; import { routes } from \"./app.routes\"; export const appConfig: ApplicationConfig = { providers: [provideRouter(routes)], }; ","categories":"","description":"Modul #F6 - Angular - Was sind Standalone Components?\n","excerpt":"Modul #F6 - Angular - Was sind Standalone Components?\n","ref":"/de/docs/03_web/06_angular/02_4_standalone-components/","tags":"","title":"Standalone Components"},{"body":"","categories":"","description":"Typisierte Webprogrammierung.\n","excerpt":"Typisierte Webprogrammierung.\n","ref":"/docs/03_web/05_typescript/","tags":"","title":"TypeScript"},{"body":"","categories":"","description":"Typisierte Webprogrammierung.\n","excerpt":"Typisierte Webprogrammierung.\n","ref":"/de/docs/03_web/05_typescript/","tags":"","title":"TypeScript"},{"body":"Ziele Du weisst, welche verschiedenen Conditionals es gibt. Du kennst die Vorteile von einem Switch-Statement und weisst, wie es angewandt wird. Du weisst, was truthy und falsy Werte sind und welche es gibt. Conditionals Conditional Statements oder auch Bedingungsanweisungen sind ein grundlegendes Konzept in JavaScript und anderen Programmiersprachen. Sie ermöglichen es dem Programm, verschiedene Aktionen je nach Erfüllung der Bedingungen auszuführen. In JavaScript gibt es hauptsächlich zwei Arten von Conditionals: if/else-Statements und switch-Statements.\nif/else-Statement If-Statements überprüfen, ob eine Bedingung dem Wert true entspricht. Ist das der Fall, wird der darauf folgende Codeblock ausgeführt.\n1 2 3 4 5 const condition = true; if (condition) { // condition ist true } Wenn man nun jedoch einen anderen Codeblock ausführen möchte, falls die Bedingung dem Wert false entspricht, kann man dafür direkt auf den if-Block folgend das else-Statement verwenden.\n1 2 3 4 5 6 7 const condition = false; if (condition) { // condition ist true } else { // condition ist false } Es ist ebenfalls möglich, mehrere spezifische Bedingungen zu prüfen, bevor der else-Block ausgelöst wird. Dazu verwendet man die else if-Kontrollstruktur, welche ebenfalls direkt auf den if-Block folgt.\n1 2 3 4 5 6 7 8 9 10 const condition1 = false; const condition2 = true; if (condition1) { // condition1 ist true } else if (condition2) { // condition2 ist true } else { // keine der conditions ist true } In einem If-Statement kann man beliebig komplexe Bedingungen schreiben. Hier wird geprüft, ob eine Variable einen bestimmten Wert hat:\n1 2 3 4 5 6 7 const variable = 1; if (variable == 1) { // Condition ist true, da die variable den Wert 1 hat. } else { // Condition ist false } Das Gleiche funktioniert natürlich auch mit Strings:\n1 2 3 4 5 6 7 const variable = \"js\"; if (variable == \"js\") { // Condition ist true, da die Variable den Wert 'js' hat. } else { // Condition ist false } switch-Statement switch-Statements in JavaScript ermöglichen es, verschiedene Codeblöcke basierend auf verschiedenen Bedingungen auszuführen. Das ist aus Übersichtlichkeitsgründen besser, als mehrere else if zu verwenden, da mehrere else if-Blöcke und eine switch-Kondition grundsätzlich dasselbe machen, ein switch-Ausdruck aber insbesondere bei vielen Konditionen besser lesbar ist.\nEin switch-Statement besitzt immer einen default Case. Dieser gibt einen “Ausweg” an, wenn keiner der gegebenen Cases erfüllt wird.\n1 2 3 4 5 6 7 8 9 10 11 12 13 const expression = \"Auto\"; switch (expression) { case \"Bus\": // Code, der ausgeführt wird, wenn Ausdruck gleich 'Bus' ist break; case \"Auto\": // Code, der ausgeführt wird, wenn Ausdruck gleich 'Auto' ist break; default: // Code, der ausgeführt wird, wenn keine der Bedingungen zutrifft break; } Die break-Keywords in den Cases werden verwendet, um das switch-Statement abzubrechen, wenn die Bedingung des Cases zugetroffen hat und der vor dem Keyword kommende Codeblock ausgeführt wurde. Wenn kein break im Case vorhanden ist, wird der Switch weiter ausgeführt.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 const expression = \"Auto\"; switch (expression) { case \"Bus\": // Code, der ausgeführt wird, wenn der Ausdruck gleich 'Bus' ist break; case \"Auto\": // Code, der ausgeführt wird, wenn der Ausdruck gleich 'Auto' ist // break; das break wurde nicht gesetzt oder auskommentiert default: // Code, der ausgeführt wird, wenn keine der Bedingungen zutrifft // oder Auto zutrifft (da im case Auto das break fehlt.). break; } Switch Expressions Oft kommt es vor, dass du mithilfe eines Switch-Statements je nach Case eine Variable zuweisen möchtest. In Java 14 und anderen modernen Programmiersprachen ist das möglich wie folgt:\n1 2 3 4 5 int variable = switch (expression) { case \"Bus\" -\u003e 1; case \"Auto\" -\u003e 2; default -\u003e 0; }; Wenn die Variable expression hier den Wert “Bus” hätte, dann würde der Variable variable der Wert 1 zugeschrieben werden, bei “Auto” 2, und in jedem anderen Case 0.\nIn JavaScript kannst du mit einem kleinen Trick das Gleiche bewerkstelligen:\n1 2 3 4 const variable = { Bus: 1, Auto: 2, }[expression]; Wenn wir den default-Wert berücksichtigen möchten, können wir diesen mit dem ??-Operator ergänzen. Das ist keine “offizielle” Syntax, funktioniert aber:\n1 2 3 4 5 const variable = { Bus: 1, Auto: 2, }[expression] ?? 0; Ohne den ??-Operator würden wir als default-Wert undefined erhalten. Der ??-Operator tauscht den Wert mit dem Wert rechts davon aus, falls der resultierende Wert undefined oder null entspräche. Du wirst den Operator und JavaScript-Objekte in einem anderen Kapitel genauer kennenlernen.\ntruthy und falsy In JavaScript gibt es die Konzepte von truthy- und falsy-Werten. Truthy bezieht sich auf einen Wert, der im booleschen Kontext als true interpretiert wird, während falsy sich auf einen Wert bezieht, der als false interpretiert wird.\nEs existieren die folgenden falsy-Werte:\nWert Typ Beschreibung null Null Das Keyword null beschreibt die Absenz eines Werts - also eine leere Menge undefined Undefined Einer der primitiven Werte in Javascript. Eine Variable, welcher kein Wert zugeschrieben ist, nimmt diesen wert an. false Boolean Das Keyword false ist einer der beiden Grundwerte eines Booleans. NaN Number Ein Wert, der beschreibt, dass ein gegebener Wert keine Number ist (Not A Number). 0 Number Die Zahl 0. Beinhält ebenfalls Werte wie 0.0, 0x0 etc. -0 Number Die Zahl -0. Beinhält auch Werte wie -0.0, -0x0 etc. 0n BigInt Die Zahl 0 im Datentyp BigInt. Beinhält ebenfalls 0x0n etc. \"\" String Ein leerer String-Wert. Beinhält ebenfalls die anderen Schreibweisen für Strings, beispielsweise ''. documment.all Object document.all ist das einzige Objekt in Javascript, welches als falsy validiert wird. Alle Werte, die keinem der in der oberen Tabelle beschriebenen Werte entsprechen, werden in Javascript als truthy behandelt.\n","categories":"","description":"Modul #F4 - JavaScript - Basics und nützliche Eigenschaften von Bedingungen.\n","excerpt":"Modul #F4 - JavaScript - Basics und nützliche Eigenschaften von …","ref":"/docs/03_web/03_javascript/05_conditionals/","tags":"","title":"Conditionals"},{"body":"Ziele Du weisst, welche verschiedenen Conditionals es gibt. Du kennst die Vorteile von einem Switch-Statement und weisst, wie es angewandt wird. Du weisst, was truthy und falsy Werte sind und welche es gibt. Conditionals Conditional Statements oder auch Bedingungsanweisungen sind ein grundlegendes Konzept in JavaScript und anderen Programmiersprachen. Sie ermöglichen es dem Programm, verschiedene Aktionen je nach Erfüllung der Bedingungen auszuführen. In JavaScript gibt es hauptsächlich zwei Arten von Conditionals: if/else-Statements und switch-Statements.\nif/else-Statement If-Statements überprüfen, ob eine Bedingung dem Wert true entspricht. Ist das der Fall, wird der darauf folgende Codeblock ausgeführt.\n1 2 3 4 5 const condition = true; if (condition) { // condition ist true } Wenn man nun jedoch einen anderen Codeblock ausführen möchte, falls die Bedingung dem Wert false entspricht, kann man dafür direkt auf den if-Block folgend das else-Statement verwenden.\n1 2 3 4 5 6 7 const condition = false; if (condition) { // condition ist true } else { // condition ist false } Es ist ebenfalls möglich, mehrere spezifische Bedingungen zu prüfen, bevor der else-Block ausgelöst wird. Dazu verwendet man die else if-Kontrollstruktur, welche ebenfalls direkt auf den if-Block folgt.\n1 2 3 4 5 6 7 8 9 10 const condition1 = false; const condition2 = true; if (condition1) { // condition1 ist true } else if (condition2) { // condition2 ist true } else { // keine der conditions ist true } In einem If-Statement kann man beliebig komplexe Bedingungen schreiben. Hier wird geprüft, ob eine Variable einen bestimmten Wert hat:\n1 2 3 4 5 6 7 const variable = 1; if (variable == 1) { // Condition ist true, da die variable den Wert 1 hat. } else { // Condition ist false } Das Gleiche funktioniert natürlich auch mit Strings:\n1 2 3 4 5 6 7 const variable = \"js\"; if (variable == \"js\") { // Condition ist true, da die Variable den Wert 'js' hat. } else { // Condition ist false } switch-Statement switch-Statements in JavaScript ermöglichen es, verschiedene Codeblöcke basierend auf verschiedenen Bedingungen auszuführen. Das ist aus Übersichtlichkeitsgründen besser, als mehrere else if zu verwenden, da mehrere else if-Blöcke und eine switch-Kondition grundsätzlich dasselbe machen, ein switch-Ausdruck aber insbesondere bei vielen Konditionen besser lesbar ist.\nEin switch-Statement besitzt immer einen default Case. Dieser gibt einen “Ausweg” an, wenn keiner der gegebenen Cases erfüllt wird.\n1 2 3 4 5 6 7 8 9 10 11 12 13 const expression = \"Auto\"; switch (expression) { case \"Bus\": // Code, der ausgeführt wird, wenn Ausdruck gleich 'Bus' ist break; case \"Auto\": // Code, der ausgeführt wird, wenn Ausdruck gleich 'Auto' ist break; default: // Code, der ausgeführt wird, wenn keine der Bedingungen zutrifft break; } Die break-Keywords in den Cases werden verwendet, um das switch-Statement abzubrechen, wenn die Bedingung des Cases zugetroffen hat und der vor dem Keyword kommende Codeblock ausgeführt wurde. Wenn kein break im Case vorhanden ist, wird der Switch weiter ausgeführt.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 const expression = \"Auto\"; switch (expression) { case \"Bus\": // Code, der ausgeführt wird, wenn der Ausdruck gleich 'Bus' ist break; case \"Auto\": // Code, der ausgeführt wird, wenn der Ausdruck gleich 'Auto' ist // break; das break wurde nicht gesetzt oder auskommentiert default: // Code, der ausgeführt wird, wenn keine der Bedingungen zutrifft // oder Auto zutrifft (da im case Auto das break fehlt.). break; } Switch Expressions Oft kommt es vor, dass du mithilfe eines Switch-Statements je nach Case eine Variable zuweisen möchtest. In Java 14 und anderen modernen Programmiersprachen ist das möglich wie folgt:\n1 2 3 4 5 int variable = switch (expression) { case \"Bus\" -\u003e 1; case \"Auto\" -\u003e 2; default -\u003e 0; }; Wenn die Variable expression hier den Wert “Bus” hätte, dann würde der Variable variable der Wert 1 zugeschrieben werden, bei “Auto” 2, und in jedem anderen Case 0.\nIn JavaScript kannst du mit einem kleinen Trick das Gleiche bewerkstelligen:\n1 2 3 4 const variable = { Bus: 1, Auto: 2, }[expression]; Wenn wir den default-Wert berücksichtigen möchten, können wir diesen mit dem ??-Operator ergänzen. Das ist keine “offizielle” Syntax, funktioniert aber:\n1 2 3 4 5 const variable = { Bus: 1, Auto: 2, }[expression] ?? 0; Ohne den ??-Operator würden wir als default-Wert undefined erhalten. Der ??-Operator tauscht den Wert mit dem Wert rechts davon aus, falls der resultierende Wert undefined oder null entspräche. Du wirst den Operator und JavaScript-Objekte in einem anderen Kapitel genauer kennenlernen.\ntruthy und falsy In JavaScript gibt es die Konzepte von truthy- und falsy-Werten. Truthy bezieht sich auf einen Wert, der im booleschen Kontext als true interpretiert wird, während falsy sich auf einen Wert bezieht, der als false interpretiert wird.\nEs existieren die folgenden falsy-Werte:\nWert Typ Beschreibung null Null Das Keyword null beschreibt die Absenz eines Werts - also eine leere Menge undefined Undefined Einer der primitiven Werte in Javascript. Eine Variable, welcher kein Wert zugeschrieben ist, nimmt diesen wert an. false Boolean Das Keyword false ist einer der beiden Grundwerte eines Booleans. NaN Number Ein Wert, der beschreibt, dass ein gegebener Wert keine Number ist (Not A Number). 0 Number Die Zahl 0. Beinhält ebenfalls Werte wie 0.0, 0x0 etc. -0 Number Die Zahl -0. Beinhält auch Werte wie -0.0, -0x0 etc. 0n BigInt Die Zahl 0 im Datentyp BigInt. Beinhält ebenfalls 0x0n etc. \"\" String Ein leerer String-Wert. Beinhält ebenfalls die anderen Schreibweisen für Strings, beispielsweise ''. documment.all Object document.all ist das einzige Objekt in Javascript, welches als falsy validiert wird. Alle Werte, die keinem der in der oberen Tabelle beschriebenen Werte entsprechen, werden in Javascript als truthy behandelt.\n","categories":"","description":"Modul #F4 - JavaScript - Basics und nützliche Eigenschaften von Bedingungen.\n","excerpt":"Modul #F4 - JavaScript - Basics und nützliche Eigenschaften von …","ref":"/de/docs/03_web/03_javascript/05_conditionals/","tags":"","title":"Conditionals"},{"body":"","categories":"","description":"Labs zu Angular NgRx (Optional)\n","excerpt":"Labs zu Angular NgRx (Optional)\n","ref":"/labs/03_web/05_angular-ngrx/","tags":"","title":"Angular NgRx Labs (optional)"},{"body":"","categories":"","description":"Labs zu Angular NgRx (Optional)\n","excerpt":"Labs zu Angular NgRx (Optional)\n","ref":"/de/labs/03_web/05_angular-ngrx/","tags":"","title":"Angular NgRx Labs (optional)"},{"body":"Inhalt In diesem Kapitel lernst du, wofür eine Datenbank ist und wie du sie benutzen kannst. Dir werden die Datentypen und verschiedenen Statements näher gebracht, um diese später selbstständig verwenden zu können. Ziel ist auch, dass du Datenbankdiagramme verstehen und erstellen kannst.\n","categories":"","description":"Grundlagen für die Verwendung von Datenbanken\n","excerpt":"Grundlagen für die Verwendung von Datenbanken\n","ref":"/docs/05_database/","tags":"","title":"Datenbanken"},{"body":"Inhalt In diesem Kapitel lernst du, wofür eine Datenbank ist und wie du sie benutzen kannst. Dir werden die Datentypen und verschiedenen Statements näher gebracht, um diese später selbstständig verwenden zu können. Ziel ist auch, dass du Datenbankdiagramme verstehen und erstellen kannst.\n","categories":"","description":"Grundlagen für die Verwendung von Datenbanken\n","excerpt":"Grundlagen für die Verwendung von Datenbanken\n","ref":"/de/docs/05_database/","tags":"","title":"Datenbanken"},{"body":"Ziele Du kannst anhand von Text ein ERD erstellen. Du kannst anhand eines ERDs eine Datenbank erstellen. Du kannst die grundlegenden Statements von SQL anwenden. ","categories":"","description":"Grundlagen für die Verwendung von Datenbanken\n","excerpt":"Grundlagen für die Verwendung von Datenbanken\n","ref":"/labs/05_database/","tags":"","title":"Datenbanken"},{"body":"Ziele Du kannst anhand von Text ein ERD erstellen. Du kannst anhand eines ERDs eine Datenbank erstellen. Du kannst die grundlegenden Statements von SQL anwenden. ","categories":"","description":"Grundlagen für die Verwendung von Datenbanken\n","excerpt":"Grundlagen für die Verwendung von Datenbanken\n","ref":"/de/labs/05_database/","tags":"","title":"Datenbanken"},{"body":" Voraussetzung Du weisst, wie man in Java mit Zahlen rechnet. Wir stellen dir bei den Übungen jeweils komplette Projekte zur Verfügung. Du musst grundsätzlich nur dort was anpassen, wo die folgende Kommentarzeile steht:\nKopieren // IT-Ninja: Füge hier Deinen Code ein: 1 // IT-Ninja: Füge hier Deinen Code ein: Alles andere kannst du für den Moment ignorieren. Wir erklären dir die einzelnen Zeilen Schritt für Schritt in den Modulen.\nVorbereitungsarbeiten Drücke auf den Pfeil links um eine detaillierte Anleitung zu erhalten, wie Du den Quellcode auf deinem Rechner ablegen sollst.\nDiese Schritte musst du bei jeder Übung erneut machen. Jede Übung hat ein eigenes ZIP-File, welches du bei dir an die richtige Stelle kopieren musst. Die Anleitung zeigt dir ziemlich gut, wie das geht… Liess vor allem am Anfang die detaillierte Anleitung gut durch und befolge die Schritte exakt. Sie helfen dir, deinen Quellcode gut organisiert, strukturiert und sicher zu verwalten. Falls du die Anleitung schon auswendig kennst, findest du den Quellcode zur Übung direkt hier: Download | Online anschauen\nNeu bei it-ninja?\nDie Anleitung enthält einige Befehle und Fachbegriffe, die dir möglicherweise noch nichts sagen. Mach dir deswegen keine Sorgen – in den kommenden Modulen erklären wir dir alles Schritt für Schritt. Schon bald wirst auch du ein it-ninja sein. Um die folgenden Aufgaben erfolgreich umzusetzen, führe diese Schritte aus:\nBeim ersten Mal:\nIntelliJ IDEA installieren → !*IntelliJ IDEA einrichten Git-Repository einrichten → !*Persönliches Git-Repository Öffne eine !*CMD-Shell und wechsle ins Verzeichnis deines Git-Repositories:\nKopieren cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git status 1 2 cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git status Kopieren cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git status 1 2 cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git status Stelle sicher, dass alle Dateien im Git-Repository committed sind. Mit git status erhältst du eine Übersicht: Kopieren git status 1 git status Falls du bei diesem Befehl einen roten Text siehst, musst du zuerst die aktuellen Dateien sichern:\nKopieren git add . git commit -m \"[gescheiter Kommentar]\" 1 2 git add . git commit -m \"[gescheiter Kommentar]\" Erstelle oder wechsle in den Template Branch:\nBeim ersten Mal musst du einen Template Branch erstellen:\nKopieren git checkout -b \"templates\" 1 git checkout -b \"templates\" Falls er bereits existiert, kannst du einfach switchen:\nKopieren git switch \"templates\" 1 git switch \"templates\" Lade den Source-Code zu den Übungen herunter und entpacke ihn im Root-Verzeichnis deines lokalen Repositories:\n[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\nDen Source-Code findest du hier: Download | Online anschauen\nCommitte den originalen Source-Code, damit er sicher im Repository gespeichert ist:\nKopieren git add . git commit -m \"Add it-ninja_02_java_03_java-grundlagen_05_logic\" git push 1 2 3 git add . git commit -m \"Add it-ninja_02_java_03_java-grundlagen_05_logic\" git push Erstelle einen neuen Branch, um deine Lösung zu implementieren: Kopieren git checkout -b \"labs/it-ninja_02_java_03_java-grundlagen_05_logic\" 1 git checkout -b \"labs/it-ninja_02_java_03_java-grundlagen_05_logic\" Hier kannst du auch einen kürzeren Namen wählen. Verwende labs am Anfang des Branch-Namens für Branches, die deinen eigenen Code enthalten.\nStelle dir einen Branch vorerst als Ordner vor. Jeder Ordner enthält eine Version oder einen Stand von deinem Quellcode. Du kannst dann mit git zwischen diesen Ordern hin und her wechseln, sie vergleichen aber später auch zusammenführen.\nPro-Tipp:\nDu kannst jederzeit einen weiteren Branch erstellen – z. B. wenn du etwas ausprobieren möchtest. Alternativ kannst du auch in der Git-History einen alten Stand wiederherstellen, was aber weniger flexibel ist. Starte IntelliJ und öffne mit File → Open das Verzeichnis mit dem Source-Code. Du musst mit IntelliJ den Ordner suchen, welches einen Ordner src oder die Datei pom.xml enthält. Ansonsten wird IntelliJ Mühe haben, dir das Programm zu kompilieren. Wenn du alles korrekt gemacht hast, findest du das Projekt hier:\nKopieren `[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\\02_java\\03_java-grundlagen\\05_logic` 1 `[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\\02_java\\03_java-grundlagen\\05_logic` Kopieren `[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\\02_java/03_java-grundlagen/05_logic` 1 `[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\\02_java/03_java-grundlagen/05_logic` Falls du zum ersten Mal mit IntelliJ arbeitest, findest du !*hier eine Anleitung, wie man ein Programm startet. Um das Programm zu starten musst du jeweils die Datei Main.java öffenen. Dann sollte in IntelliJ oben rechts ein grünes Dreieck vorhanden sein, welches das Programm startet. Nun bist du bereit, die untenstehenden Aufgaben zu lösen.\nWenn du alle Änderungen gemacht hast und mit der Übung fertig bist, oder einen ‘Zwischenstand’ festhalten willst, führe die folgenden Befehle aus um das Repository auf dem Server zu speichern (von wo du es geklont hast):\nKopieren cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git add --all git commit -m \"Kurzer Kommentar\" 1 2 3 cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git add --all git commit -m \"Kurzer Kommentar\" Kopieren cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git add . git commit -m \"Kurzer Kommentar\" 1 2 3 cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git add . git commit -m \"Kurzer Kommentar\" Wenn du deine Änderungen auf dem Git-Server sichern willst, musst du das mit einem push machen.\nBeim ersten mal musst du git noch mitteilen, wie der Branch auf dem Git-Server heissen soll:\nKopieren git push --set-upstream origin labs/it-ninja_02_java_03_java-grundlagen_05_logic 1 git push --set-upstream origin labs/it-ninja_02_java_03_java-grundlagen_05_logic Bei weiteren pushes wird es dann einfacher:\nKopieren git push 1 git push Die meisten Übungen sind professionell strukturiert – so wie in echten Softwareprojekten. Zu gutem Code gehören auch Tests, die sicherstellen, dass dein Code wie erwartet funktioniert. Sofern nicht anders erwähnt, kannst du mit folgendem Befehl im Root-Verzeichnis des Projekts (dort, wo sich auch die pom.xml befindet) überprüfen, ob du die Aufgabe korrekt gelöst hast:\n1 mvn test Viel Erfolg!\nAufgabe 1 - geometrische Berechnungen Passe die folgenden Methoden an. Berechne Flächen, Umfang und Volumen und gib das Resultat auf der Konsole aus:\nDas Rechteck mit a=[value1]cm und b=[value2]cm hat eine Fläche von [result]cm2. Das Dreieck mit g=[value1]cm und h=[value2]cm hat eine Fläche von [result]cm2. Der Kreis mit dem Radius [value]cm hat eine Fläche von [result]cm2. Das Rechteck mit a=[value1]cm und b=[value2]cm hat einen Umfang von [result]cm. Wobei in der Ausgabe die Platzhalter mit den eckigen Klammern durch die entsprechenden Zahlen ersetzt werden sollen. Ganzzahlen sollen ohne ‘.’ und Nachkommastellen angezeigt werden, Dezimalzahlen mit 2 Stellen hinter dem Punkt.\nIm zur Übung gehörendem Source kannst Du die Änderung an folgender Stelle machen:\nsrc\\main\\java\\ch\\itninja\\labs\\basicexercises\\CalculateForms.java:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public static void printRectArea(int sideA, int sideB) { // IT-Ninja: Füge hier Deinen Code ein: } public static void printTriangleArea(int sideC, int heightC) { // IT-Ninja: Füge hier Deinen Code ein: } public static void printCircleArea(int radius) { // IT-Ninja: Füge hier Deinen Code ein: } public static void printRectPerimeter(int sideA, int sideB) { // IT-Ninja: Füge hier Deinen Code ein: } Rechteck Flächenberechnung Beispiel 1:\nEingabe:\n1 CalculateForms.printRectArea(4, 5); Ausgabe:\n1 Das Rechteck mit a=4cm und b=5cm hat eine Fläche von 20cm2. Beispiel 2:\nEingabe:\n1 CalculateForms.printRectArea(3, 7); Ausgabe:\n1 Das Rechteck mit a=3cm und b=7cm hat eine Fläche von 21cm2. Beispiel 3:\nEingabe:\n1 CalculateForms.printRectArea(6, 4); Ausgabe:\n1 Das Rechteck mit a=6cm und b=4cm hat eine Fläche von 24cm2. Beispiel 4:\nEingabe:\n1 CalculateForms.printRectArea(0, 0); Ausgabe:\n1 Das Rechteck mit a=0cm und b=0cm hat eine Fläche von 0cm2. Dreieck Flächenberechnung Beispiel 1:\nEingabe:\n1 CalculateForms.printTriangleArea(4, 5); Ausgabe:\n1 Das Dreieck mit c=4cm und h=5cm hat eine Fläche von 10cm2. Beispiel 2:\nEingabe:\n1 CalculateForms.printTriangleArea(3, 12); Ausgabe:\n1 Das Dreieck mit c=3cm und h=12cm hat eine Fläche von 18cm2. Beispiel 3:\nEingabe:\n1 CalculateForms.printTriangleArea(6, 4); Ausgabe:\n1 Das Dreieck mit c=6cm und h=4cm hat eine Fläche von 12cm2. Beispiel 4:\nEingabe:\n1 CalculateForms.printTriangleArea(0, 0); Ausgabe:\n1 Das Dreieck mit c=0cm und h=0cm hat eine Fläche von 0cm2. Kreis Flächenberechnung Beispiel 1:\nEingabe:\n1 CalculateForms.printCircleArea(4); Ausgabe:\n1 Der Kreis mit r=4cm hat eine Fläche von 50.27cm2. Beispiel 2:\nEingabe:\n1 CalculateForms.printCircleArea(3); Ausgabe:\n1 Der Kreis mit r=3cm hat eine Fläche von 28.27cm2. Beispiel 3:\nEingabe:\n1 CalculateForms.printCircleArea(6); Ausgabe:\n1 Der Kreis mit r=6cm hat eine Fläche von 113.10cm2. Beispiel 4:\nEingabe:\n1 CalculateForms.printCircleArea(0); Ausgabe:\n1 Der Kreis mit r=0cm hat eine Fläche von 0.00cm2. Rechteck Umfangberechnung Beispiel 1:\nEingabe:\n1 CalculateForms.printRectPerimeter(4, 5); Ausgabe:\n1 Das Rechteck mit a=4cm und b=5cm hat einen Umfang von 18cm. Beispiel 2:\nEingabe:\n1 CalculateForms.printRectPerimeter(3, 12); Ausgabe:\n1 Das Rechteck mit a=3cm und b=12cm hat einen Umfang von 30cm. Beispiel 3:\nEingabe:\n1 CalculateForms.printRectPerimeter(6, 4); Ausgabe:\n1 Das Rechteck mit a=6cm und b=4cm hat einen Umfang von 20cm. Beispiel 4:\nEingabe:\n1 CalculateForms.printRectPerimeter(0, 0); Ausgabe:\n1 Das Rechteck mit a=0cm und b=0cm hat einen Umfang von 0cm. Aufgabe 2 - Checkout Passe die folgenden Methoden an. Nutze in einer Methode nur double, in der anderen BigDecimal. Erstelle für die untenstehende Einkaufsliste für jeden Artikel eine Variable und weise der Variable den entsprechenden Wert zu:\nApfel: CHF 0.10 Brot: CHF 1.10 Milch: CHF 2.20 Ei: CHF 0.20 Butter: CHF 2.10 Erstelle ebenfalls eine Variable totalExpected mit dem zu erwartenden Total und berechne es (im Kopf oder Taschenrechner).\nZähle die Preise der Produkte mittels Java-Code zusammen und speichere sie in der Variable total. Der darauf folgende Code wird dann die beiden Werte vergleichen und eine entsprechende Ausgabe machen (was der Code macht wirst du im nächsten Modul kennenlernen).\nDenke beim Erstellen der Variablen daran, dass bei it-ninja der Code immer in englisch sein sollte, nur die Ausgabe auf den Bildschirm soll auf deutsch sein.\nIm zur Übung gehörendem Source kannst Du die Änderung an folgender Stelle machen:\nsrc\\main\\java\\ch\\itninja\\labs\\basicexercises\\Basket.java:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 public static void printTotalBigDecimal(){ BigDecimal totalExpected = new BigDecimal(\"0.0\"); // Expected total price (your calculation) BigDecimal total = new BigDecimal(0); // Actual total price (computed) // to add 2 BigDecimal you can use total = big1.add(big2).add(big3) // IT-Ninja: Füge hier Deinen Code ein: String expectedResult; if(total.compareTo(totalExpected) == 0){ expectedResult = \"wie erwartet\"; } else if(total.compareTo(totalExpected) \u003e 0){ expectedResult = \"zu hoch\"; } else { expectedResult = \"zu tief\"; } System.out.println(\"Alle Artikel zusammen kosten CHF \" + total + \". Der Preis ist \" + expectedResult + \".\"); } public static void printTotalDouble(){ double totalExpected = 0; // Expected total price (your calculation) double total = 0; // Actual total price (computed) // IT-Ninja: Füge hier Deinen Code ein: String expectedResult; if(total == totalExpected){ expectedResult = \"wie erwartet\"; } else if(total \u003e totalExpected){ expectedResult = \"zu hoch\"; } else { expectedResult = \"zu tief\"; } System.out.printf(\"Alle Artikel zusammen kosten CHF %.2f. Der Preis ist %s.%n\", total, expectedResult); } Wenn du beide Methoden angepasst hat, vergleiche die Ausgabe. Du solltest folgende Ausgabe erhalten:\nBeispielausgabe:\n1 Alle Artikel zusammen kosten CHF 5.70. Der Preis ist wie erwartet. Aufgabe 3 - Alter in Monaten Passe die folgende Methode an. Berechne dein Alter in ganzen Monaten. Zähle den Monat wo du geboren wurdest und den aktuellen als ganzen Monat dazu. Gib Dein Alter auf der Konsole aus:\nIch bin am dd.mm.yyyy geboren und heute am dd.mm.yyyy z Monate alt. Wobei in der Ausgabe dd.mm.yyyy durch das tatsächliche Datum von Deinem Geburtstag resp. dem heutigen Datum ersetzt werden soll und z durch die Anzahl Monate.\nIm Quellcode findest du auch statische Variablen (dayOfBirth, monthOfBirth, yearOfBirth, dayOfToday, monthOfToday, yearOfToday). Passe diese Variablen an und nutze sie in in deinem Code. Es wird erwartet, dass sich eine Änderung einer dieser Variablen auf die Berechnung aber auch auf die Ausgabe in der Konsole auswirkt. Was es genau mit static auf sich hat lernst du bald.\nIm zur Übung gehörendem Source kannst Du die Änderung an folgender Stelle machen:\nsrc\\main\\java\\ch\\itninja\\labs\\basicexercises\\AgeCalculator.java:\n1 2 3 4 public static void ageInMonths() { // IT-Ninja: Füge hier Deinen Code ein: } Beispiel 1:\nEingabe:\n1 2 3 4 5 6 7 8 AgeCalculator.dayOfBirth = 1; AgeCalculator.monthOfBirth = 9; AgeCalculator.yearOfBirth = 1973; AgeCalculator.dayOfToday = 22; AgeCalculator.monthOfToday = 7; AgeCalculator.yearOfToday = 2025; AgeCalculator.ageInMonths(); Ausgabe:\n1 Ich bin am 01.09.1973 geboren und heute am 22.07.2025 623 Monate alt. Beispiel 2:\nEingabe:\n1 2 3 4 5 6 7 8 AgeCalculator.dayOfBirth = 15; AgeCalculator.monthOfBirth = 4; AgeCalculator.yearOfBirth = 2008; AgeCalculator.dayOfToday = 8; AgeCalculator.monthOfToday = 8; AgeCalculator.yearOfToday = 2025; AgeCalculator.ageInMonths(); Ausgabe:\n1 Ich bin am 15.04.2008 geboren und heute am 08.08.2025 209 Monate alt. ","categories":"","description":"Mit diesen Übungen kannst du dein Wissen über einfache Berechnungen vertiefen.\n","excerpt":"Mit diesen Übungen kannst du dein Wissen über einfache Berechnungen …","ref":"/labs/02_java/03_java-grundlagen/05_logic/","tags":"","title":"Java Exercises - Einfache Berechnungen"},{"body":"Ziele Du verstehst, was API-Schlüssel und Passwörter im Code bedeuten. Du erkennst die Risiken bei falscher Handhabung. Du lernst, wie man sensible Daten sicher speichert. Du kennst die gängigen Formate und Methoden zur Trennung von Code und Konfiguration. ⏱️ Geschätzte Lesezeit: 5 Minuten Warum überhaupt schützen? Viele moderne Anwendungen greifen auf externe Dienste zu – z. B. Google, OpenAI oder Wetterdaten-Anbieter.\nDamit diese Dienste erkennen, wer du bist, brauchst du:\nPasswörter: zum Schutz persönlicher Konten oder Serverzugänge. API-Keys (Application Programming Interface Keys): Zugangsschlüssel, die automatisch mitgeschickt werden, wenn dein Programm eine API verwendet. Ein API-Key ist wie ein digitaler Ausweis für deine Software. Er identifiziert deine Anwendung gegenüber dem Dienst – und ist oft mit Zugriffsrechten, Kosten oder Nutzungslimits verbunden.\nWer deinen API-Key oder dein Passwort kennt, kann auf Dienste in deinem Namen zugreifen – im schlimmsten Fall auf deine Kosten. Gute Praxis: Trennung von Code und Konfiguration Sensibler Inhalt wie API-Schlüssel, Passwörter oder geheime Tokens gehört nicht in den Quellcode.\nStattdessen verwendest du Umgebungsvariablen oder .env-Dateien – sie sind lokal, einfach zu nutzen und sicher (wenn man sie nicht aus Versehen committed).\nDie konkrete Umsetzung hängt davon ab, ob du mit Java, Node.js, Python oder einer anderen Sprache arbeitest.\nWähle nun die passende Anleitung:\n","categories":"","description":"Warum Passwörter und API-Keys nicht in den Code gehören – und wie du sie schützt.\n","excerpt":"Warum Passwörter und API-Keys nicht in den Code gehören – und wie du …","ref":"/docs/99_tools/ide/intellij/05_secrets/","tags":"","title":"Geheimnisse schützen"},{"body":"Inhalt Beispiel für Branching, Merging und Rebasing Einfache Mergekonflikte Ziele Ich kann mit Mergekonflikten umgehen. Ich kann ein Rebase eines Branches vornehmen. Ich kenne die zwei wichtigsten Flows und kann sie voneinander unterscheiden. Im vorherigen Kapitel haben wir gelernt, dass man nur dann seine Änderungen pushen kann, wenn einem niemand anders zuvorkam. Um diesem Problem aus dem Weg zu gehen, kann ein Branch (engl. für Ast/Zweig) verwendet werden, welcher zu einem späteren Zeitpunkt wieder auf den Hauptpfad gemerged wird.\nIm ersten Kapitel haben wir gelernt, dass Git mit jedem Commit ein Snapshot der Daten und eine Referenz auf den vorgehenden Commit speichert. Ein Branch ist nichts anderes als ein Zeiger auf einen spezifischen Snapshot.\nErzeugen wir mit git branch testing einen neuen Branch namens “testing” so wird ein Zeiger erstellt, welcher auf denselben Commit zeigt, auf dem man sich im Moment befindet. Damit Git weiss, wo man sich im Moment gerade befindet gibt es einen speziellen Zeiger namens HEAD:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 +----------+ | HEAD | +----+-----+ | v +----+-----+ | master | +----+-----+ | v +----------+ +----------+ +----+-----+ | Commit 1 +\u003c-------+ Commit 2 +\u003c-------+ Commit 3 | +----------+ +----------+ +----+-----+ ^ | +----+-----+ | testing | +----------+ Wie man auf der Skizze erkennen kann, wurde der neue Branch “testing” erstellt, wir befinden uns aber immer noch auf dem “master” Branch (HEAD). Um nun auf den neuen Branch zu wechseln können wir den Befehl git checkout testing verwenden. Protipp: Um einen neuen Branch zu erstellen und gleich auf diesen zu wechseln, kann der Befehl git checkout -b \u003cbranchname\u003e verwendet werden.\nErstellen wir nun einen Commit auf dem “testing” Branch, dann zeigt sich folgendes Bild:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 +----+-----+ | master | +----+-----+ | v +----------+ +----------+ +----------+ +----------+ | Commit 1 +\u003c-------+ Commit 2 +\u003c-------+ Commit 3 |\u003c-------+ Commit 4 | +----------+ +----------+ +----------+ +----------+ ^ | +----------+ | testing | +----+-----+ ^ | +----------+ | HEAD | +----+-----+ Beispiel für Branching, Merging und Rebasing In diesem Abschnitt wird davon ausgegangen, dass es einen Fehler im aktuellen master-Branch gibt, der unter testing nicht behoben wurde, da er zur Entwicklung neuer Funktionen verwendet wird. Um den Fehler zu beheben, wird ein neuer Branch mit dem Namen bugfix erstellt, der mit der gleichen Revision wie master beginnt.\n1 2 3 4 $ git checkout master Switched to branch 'master' $ git checkout -b bugfix Switched to a new branch 'bugfix' git commit Nachdem der Branch bugfix erstellt und ausgecheckt wurde, wird die Korrektur entwickelt und übertragen.\n1 2 3 4 5 6 7 8 9 10 11 $ git diff diff --git a/first-file.txt b/first-file.txt index 4c5fd91..aa24abd 100644 --- a/first-file.txt +++ b/first-file.txt @@ -1 +1 @@ -First file +First file with bugfix $ git commit -a -m \"Bugfix for first file\" [bugfix a27a927] Bugfix for first file 1 file changed, 1 insertion(+), 1 deletion(-) Die erste Zeile in first-file.txt wurde geändert, indem with bugfix zur ersten Zeile hinzugefügt wurde. Mit der neuen Übergabe an bugfix fangen die Branches an auseinanderzulaufen.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 +----------+ | testing | +----------+ +----+-----+ | master | | +----+-----+ v | +----+-----+ v + Commit 4 | +----------+ +----------+ +----+-----+\u003c-------+----------+ | Commit 1 +\u003c-------| Commit 2 +\u003c-------+ Commit 3 + +----------+ +----------+ +----------+\u003c-------+----------+ + commit 5 | +----+-----+ ^ | +----+-----+ | bugfix | +----+-----+ ^ | +----+-----+ | HEAD | +----+-----+ Mergen der Branches Nach der Fehlerbehebung ist es nun an der Zeit, sie wieder in den Master-Branch einzubinden, damit andere Benutzer sie ebenfalls verwenden können.\ngit merge Merge ist eine Wiederholung der Änderungen eines benannten Commits (auch Branch genannt) in einen anderen Branch, da diese voneinander abwichen. Damit dies funktioniert, ändert man zuerst den Zielbranch. In diesem Fall ist das bugfix. Die Änderungen sollen nach master zurückgespielt werden. Da das Ziel master ist, ist der erste Schritt, zu diesem Branch zu wechseln.\n1 2 3 4 5 6 7 8 9 10 11 $ git checkout master Switched to branch 'master' $ git branch * master testing bugfix $ git merge bugfix Updating e303af7..a27a927 Fast-forward first-file.txt | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) Wechsle zum Zielbranch (master).\nBestätige, dass du dich im Zielbranch befindest. Dieser Schritt ist optional.\nFühre die Änderungen von bugfix mit master zusammen.\nNach der Zusammenführung zeigen bugfix und master auf dieselbe Revision.!\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 +----+-----+ | HEAD | +----+-----+ +----------+ | | testing | v +----+-----+ +----------+ | | master | v +----+-----+ +----+-----+ | + Commit 4 | v +----------+ +----------+ +----+-----+\u003c-------+----------+ +----+-----+ | Commit 1 +\u003c-------| Commit 2 +\u003c-------+ Commit 3 +\u003c--------------------------+ commit 5 | +----------+ +----------+ +----------+ +----+-----+ ^ | +----+-----+ | bugfix | +----+-----+ git branch -d Es gibt keinen Grund mehr, den bugfix-Branch beizubehalten, da die Änderungen nun in master eingearbeitet wurden. Mit dem Befehl branch -d \u003cbranchname\u003e wird der Branch gelöscht.\n1 2 3 4 5 6 7 8 $ git branch bugfix * master testing $ git branch -d bugfix Deleted branch bugfix (was a27a927). $ git log --oneline -n 1 a27a927 (HEAD -\u003e master) Bugfix for first file Der Branch kann beim Auschecken nicht gelöscht werden. Der aktive Branch ist master, der für die Löschung von bugfix funktioniert.\nDer Branch wird gelöscht und die Ausgabe enthält den kurzen SHA1-Hash.\nDie Überprüfung mit git log bestätigt, dass master auf denselben Hash zeigt wie bugfix.\nNachdem der Branch bugfix gelöscht wurde, bleiben nur noch master und testing übrig.\nRebasing Branches Nachdem die Fehlerkorrektur in den Branch master eingebracht wurde, ist der nächste logische Schritt, die Änderungen in den Branch testing einzubringen, um sicherzustellen, dass der nächste Release die korrigierte Version enthält. Wenn man mit mehreren Branches arbeitet, ist diese Operation notwendig, um nicht zu weit in den master zurückzufallen und viele Merge-Konflikte zu vermeiden.\ngit rebase Beim Rebase wird der Basis-Commit eines Branches verschoben und dessen Änderungen an den aktuellen Stand eines anderen Branches oder Commits angehängt, der als Argument in der Befehlszeile angegeben wird.\nIn unserem Beispielszenario entwickeln wir kurz vor den Ferien ein neues Feature. Dazu erstellen wir einen Branch, welcher sich vom Master abzweigt und commiten unsere Änderungen. Die Ausgangslage vor den Ferien würde also wie folgt aussehen:\nNun kommen wir zwei Wochen später - nach unseren Ferien - wieder ins Office und die Situation sieht wie folgt aus:\nWie wir sehen, hat sich einiges auf master getan und unser Branch ist nicht mehr auf dem aktuellen Stand. Wir wollen, dass feature aktuell ist, wollen aber nicht git merge nutzen, da wir keinen Merge-Commit im Branch haben möchten, sondern jeden einzelnen Commit aus master auch auf unserem Feature-Branch appliziert haben möchten. So sind alle Änderungen Schritt für Schritt nachvolliehbar. Deswegen entscheiden wir uns für einen rebase.\nAls Erstes stellen wir also sicher, dass wir auf dem korrekten Branch sind und machen anschliessend ein git rebase master. Hierbei sollte angemerkt werden, dass man auf master niemals ein rebase machen sollte, da dies die History verändert mit zusätzlichen Commits und andere Entwickler:innen dadurch verwirrt werden könnten.\nWenn man master updaten möchte, sollte dies über ein git merge erfolgen.\n1 2 3 4 5 6 7 $ git branch * master feature $ git checkout feature Switched to branch 'feature' $ git rebase master Successfully rebased and updated refs/heads/feature. Nun ist der letzte Commit auf Master die neue Base des Branches feature und alle Änderungen wurden nachgespielt.\nDie Situation sieht also wie folgt aus:\nHinweis\nDie Durchführung eines rebase zwischen zwei Branches erfordert einen gemeinsamen Vorfahren im Tree.\nEinfache Mergekonflikte Im oben erwähnten Beispiel ist alles automatisch gegangen beim Mergen, es gibt jedoch Fälle, bei denen Git nicht mehr in der Lage ist automatisch die Dateien Zusammenzuführen, wenn zum Beispiel eine Änderung an der gleichen Stelle einer Datei in beiden Branches vorgenommen wird. Gehen wir vom Beispiel oben aus, die Story die man da umsetzt macht auch etwas mit dem Dashboard welches wir kurzum anpassen mussten:\n1 2 3 4 $ git merge bugfix Auto-merging first-file.txt CONFLICT (content): Merge conflict in first-file.txt Automatic merge failed; fix conflicts and then commit the result. Git konnte nicht automatisch mergen und hat somit keinen commit erstellt, wir müssen den Mergekonflikt von Hand lösen, bevor wir weiter arbeiten können. Weitere Infos liefert git status:\n1 2 3 4 5 6 7 8 9 10 11 $ git status On branch master You have unmerged paths. (fix conflicts and run \"git commit\") (use \"git merge --abort\" to abort the merge) Unmerged paths: (use \"git add \u003cfile\u003e...\" to mark resolution) both modified: first-file.txt no changes added to commit (use \"git add\" and/or \"git commit -a\") Git fügt automatisch eine Markierung in die Dateien ein, welche gmerged werden müssen:\n1 2 3 4 5 \u003c\u003c\u003c\u003c\u003c\u003c\u003c HEAD first line from master ======= first line from bugfix \u003e\u003e\u003e\u003e\u003e\u003e\u003e bugfix Das bedeutet, dass der HEAD (also der Masterbranch, weil auf den haben wir vor dem Mergen gewechselt) den oberen Teil (also immer alles auf Grün) und unsere neuen Änderungen den unteren Teil auf dieser Zeile hatten. Man kann den Konflikt nun lösen, indem man den ganzen Block, mit der gewünschten Änderung ersetzt. Ist der Konflikt gelöst, können wir die Datei ganz normal stagen und commiten. Gerade bei grösseren Mergekonflikten kann es praktisch sein mit tools zu Arbeiten, welche einem die Unterschiede zwischen den beiden Branches Grafisch darstellen, dafür gibt es den Befehl git mergetool.\nIn der Regel können viele Merge-Konflikte verhindert oder minimiert werden, indem:\nRegelmässige Kommunikation von Änderungen zwischen Teammitgliedern.\nRegelmässige Rebases mit dem Merge-Zielbranch.\nErstellen kleiner und atomarer Commits.\nFlows Flows sind standardisierte Abläufe, wie Branches erzeugt und später Releases erstellt werden. Wir zeigen hier die zwei am weitesten verbreiteten Flows.\nFeature Branch Flow Der Feature Branch Flow besagt, dass man für jede neue Funktion oder Verbesserung (Feature) einen eigenen Branch erstellt. Auf diesem Branch kann die Funktion entwickelt werden, ohne den Main-Branch zu beeinflussen. Sobald die Arbeit abgeschlossen und getestet ist, wird der Feature-Branch wieder in den Hauptbranch (main) integriert.\nVertiefende Informationen zum Feature Branch Flow können auf dieser Seite gelesen werden.\nGitflow Der Gitflow unterscheidet sich primär vom Feature Branch Flow indem, dass zwei Hauptbranches verwendet werden: main für den stabilen Code und development für die laufende Entwicklung. So werden Feature-Branches nicht direkt vom main-, sondern vom development-Branch (Name kann abweichen) abzweigen. So werden fertiggestellte Änderungen auch nicht gleich in den Main integriert, sondern zurück in den Development-Branch. Zudem wird ein release-Branch verwendet, auf welchen Änderungen vom Development-Branch gepusht werden, um dort vor einem Release getestet zu werden. Anschließend wird der release-Branch, und nur dieser, in den main gemerged. Nebst Feature Branches können auch Branches für Releases und Hotfixes (hier nicht abgebildet) erstellt werden.\nDer Flow ermöglicht eine strukturierte Vorgehensweise für die Entwicklung und Veröffentlichung von Software, indem Entwicklungs- und Produktionscode getrennt werden. Änderungen sind einfach und schnell nachvollziehbar und es ist jederzeit möglich, schnell auf eine releaste-Version zurückzugreifen.\nVertiefende Informationen zum Gitflow können auf dieser Seite gelesen werden.\nHands On https://learngitbranching.js.org/\n","categories":"","description":"","excerpt":"Inhalt Beispiel für Branching, Merging und Rebasing Einfache …","ref":"/docs/04_git/01_grundwissen/05_git-branches/","tags":"","title":"Git Branches"},{"body":"Inhalt Beispiel für Branching, Merging und Rebasing Einfache Mergekonflikte Ziele Ich kann mit Mergekonflikten umgehen. Ich kann ein Rebase eines Branches vornehmen. Ich kenne die zwei wichtigsten Flows und kann sie voneinander unterscheiden. Im vorherigen Kapitel haben wir gelernt, dass man nur dann seine Änderungen pushen kann, wenn einem niemand anders zuvorkam. Um diesem Problem aus dem Weg zu gehen, kann ein Branch (engl. für Ast/Zweig) verwendet werden, welcher zu einem späteren Zeitpunkt wieder auf den Hauptpfad gemerged wird.\nIm ersten Kapitel haben wir gelernt, dass Git mit jedem Commit ein Snapshot der Daten und eine Referenz auf den vorgehenden Commit speichert. Ein Branch ist nichts anderes als ein Zeiger auf einen spezifischen Snapshot.\nErzeugen wir mit git branch testing einen neuen Branch namens “testing” so wird ein Zeiger erstellt, welcher auf denselben Commit zeigt, auf dem man sich im Moment befindet. Damit Git weiss, wo man sich im Moment gerade befindet gibt es einen speziellen Zeiger namens HEAD:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 +----------+ | HEAD | +----+-----+ | v +----+-----+ | master | +----+-----+ | v +----------+ +----------+ +----+-----+ | Commit 1 +\u003c-------+ Commit 2 +\u003c-------+ Commit 3 | +----------+ +----------+ +----+-----+ ^ | +----+-----+ | testing | +----------+ Wie man auf der Skizze erkennen kann, wurde der neue Branch “testing” erstellt, wir befinden uns aber immer noch auf dem “master” Branch (HEAD). Um nun auf den neuen Branch zu wechseln können wir den Befehl git checkout testing verwenden. Protipp: Um einen neuen Branch zu erstellen und gleich auf diesen zu wechseln, kann der Befehl git checkout -b \u003cbranchname\u003e verwendet werden.\nErstellen wir nun einen Commit auf dem “testing” Branch, dann zeigt sich folgendes Bild:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 +----+-----+ | master | +----+-----+ | v +----------+ +----------+ +----------+ +----------+ | Commit 1 +\u003c-------+ Commit 2 +\u003c-------+ Commit 3 |\u003c-------+ Commit 4 | +----------+ +----------+ +----------+ +----------+ ^ | +----------+ | testing | +----+-----+ ^ | +----------+ | HEAD | +----+-----+ Beispiel für Branching, Merging und Rebasing In diesem Abschnitt wird davon ausgegangen, dass es einen Fehler im aktuellen master-Branch gibt, der unter testing nicht behoben wurde, da er zur Entwicklung neuer Funktionen verwendet wird. Um den Fehler zu beheben, wird ein neuer Branch mit dem Namen bugfix erstellt, der mit der gleichen Revision wie master beginnt.\n1 2 3 4 $ git checkout master Switched to branch 'master' $ git checkout -b bugfix Switched to a new branch 'bugfix' git commit Nachdem der Branch bugfix erstellt und ausgecheckt wurde, wird die Korrektur entwickelt und übertragen.\n1 2 3 4 5 6 7 8 9 10 11 $ git diff diff --git a/first-file.txt b/first-file.txt index 4c5fd91..aa24abd 100644 --- a/first-file.txt +++ b/first-file.txt @@ -1 +1 @@ -First file +First file with bugfix $ git commit -a -m \"Bugfix for first file\" [bugfix a27a927] Bugfix for first file 1 file changed, 1 insertion(+), 1 deletion(-) Die erste Zeile in first-file.txt wurde geändert, indem with bugfix zur ersten Zeile hinzugefügt wurde. Mit der neuen Übergabe an bugfix fangen die Branches an auseinanderzulaufen.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 +----------+ | testing | +----------+ +----+-----+ | master | | +----+-----+ v | +----+-----+ v + Commit 4 | +----------+ +----------+ +----+-----+\u003c-------+----------+ | Commit 1 +\u003c-------| Commit 2 +\u003c-------+ Commit 3 + +----------+ +----------+ +----------+\u003c-------+----------+ + commit 5 | +----+-----+ ^ | +----+-----+ | bugfix | +----+-----+ ^ | +----+-----+ | HEAD | +----+-----+ Mergen der Branches Nach der Fehlerbehebung ist es nun an der Zeit, sie wieder in den Master-Branch einzubinden, damit andere Benutzer sie ebenfalls verwenden können.\ngit merge Merge ist eine Wiederholung der Änderungen eines benannten Commits (auch Branch genannt) in einen anderen Branch, da diese voneinander abwichen. Damit dies funktioniert, ändert man zuerst den Zielbranch. In diesem Fall ist das bugfix. Die Änderungen sollen nach master zurückgespielt werden. Da das Ziel master ist, ist der erste Schritt, zu diesem Branch zu wechseln.\n1 2 3 4 5 6 7 8 9 10 11 $ git checkout master Switched to branch 'master' $ git branch * master testing bugfix $ git merge bugfix Updating e303af7..a27a927 Fast-forward first-file.txt | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) Wechsle zum Zielbranch (master).\nBestätige, dass du dich im Zielbranch befindest. Dieser Schritt ist optional.\nFühre die Änderungen von bugfix mit master zusammen.\nNach der Zusammenführung zeigen bugfix und master auf dieselbe Revision.!\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 +----+-----+ | HEAD | +----+-----+ +----------+ | | testing | v +----+-----+ +----------+ | | master | v +----+-----+ +----+-----+ | + Commit 4 | v +----------+ +----------+ +----+-----+\u003c-------+----------+ +----+-----+ | Commit 1 +\u003c-------| Commit 2 +\u003c-------+ Commit 3 +\u003c--------------------------+ commit 5 | +----------+ +----------+ +----------+ +----+-----+ ^ | +----+-----+ | bugfix | +----+-----+ git branch -d Es gibt keinen Grund mehr, den bugfix-Branch beizubehalten, da die Änderungen nun in master eingearbeitet wurden. Mit dem Befehl branch -d \u003cbranchname\u003e wird der Branch gelöscht.\n1 2 3 4 5 6 7 8 $ git branch bugfix * master testing $ git branch -d bugfix Deleted branch bugfix (was a27a927). $ git log --oneline -n 1 a27a927 (HEAD -\u003e master) Bugfix for first file Der Branch kann beim Auschecken nicht gelöscht werden. Der aktive Branch ist master, der für die Löschung von bugfix funktioniert.\nDer Branch wird gelöscht und die Ausgabe enthält den kurzen SHA1-Hash.\nDie Überprüfung mit git log bestätigt, dass master auf denselben Hash zeigt wie bugfix.\nNachdem der Branch bugfix gelöscht wurde, bleiben nur noch master und testing übrig.\nRebasing Branches Nachdem die Fehlerkorrektur in den Branch master eingebracht wurde, ist der nächste logische Schritt, die Änderungen in den Branch testing einzubringen, um sicherzustellen, dass der nächste Release die korrigierte Version enthält. Wenn man mit mehreren Branches arbeitet, ist diese Operation notwendig, um nicht zu weit in den master zurückzufallen und viele Merge-Konflikte zu vermeiden.\ngit rebase Beim Rebase wird der Basis-Commit eines Branches verschoben und dessen Änderungen an den aktuellen Stand eines anderen Branches oder Commits angehängt, der als Argument in der Befehlszeile angegeben wird.\nIn unserem Beispielszenario entwickeln wir kurz vor den Ferien ein neues Feature. Dazu erstellen wir einen Branch, welcher sich vom Master abzweigt und commiten unsere Änderungen. Die Ausgangslage vor den Ferien würde also wie folgt aussehen:\nNun kommen wir zwei Wochen später - nach unseren Ferien - wieder ins Office und die Situation sieht wie folgt aus:\nWie wir sehen, hat sich einiges auf master getan und unser Branch ist nicht mehr auf dem aktuellen Stand. Wir wollen, dass feature aktuell ist, wollen aber nicht git merge nutzen, da wir keinen Merge-Commit im Branch haben möchten, sondern jeden einzelnen Commit aus master auch auf unserem Feature-Branch appliziert haben möchten. So sind alle Änderungen Schritt für Schritt nachvolliehbar. Deswegen entscheiden wir uns für einen rebase.\nAls Erstes stellen wir also sicher, dass wir auf dem korrekten Branch sind und machen anschliessend ein git rebase master. Hierbei sollte angemerkt werden, dass man auf master niemals ein rebase machen sollte, da dies die History verändert mit zusätzlichen Commits und andere Entwickler:innen dadurch verwirrt werden könnten.\nWenn man master updaten möchte, sollte dies über ein git merge erfolgen.\n1 2 3 4 5 6 7 $ git branch * master feature $ git checkout feature Switched to branch 'feature' $ git rebase master Successfully rebased and updated refs/heads/feature. Nun ist der letzte Commit auf Master die neue Base des Branches feature und alle Änderungen wurden nachgespielt.\nDie Situation sieht also wie folgt aus:\nHinweis\nDie Durchführung eines rebase zwischen zwei Branches erfordert einen gemeinsamen Vorfahren im Tree.\nEinfache Mergekonflikte Im oben erwähnten Beispiel ist alles automatisch gegangen beim Mergen, es gibt jedoch Fälle, bei denen Git nicht mehr in der Lage ist automatisch die Dateien Zusammenzuführen, wenn zum Beispiel eine Änderung an der gleichen Stelle einer Datei in beiden Branches vorgenommen wird. Gehen wir vom Beispiel oben aus, die Story die man da umsetzt macht auch etwas mit dem Dashboard welches wir kurzum anpassen mussten:\n1 2 3 4 $ git merge bugfix Auto-merging first-file.txt CONFLICT (content): Merge conflict in first-file.txt Automatic merge failed; fix conflicts and then commit the result. Git konnte nicht automatisch mergen und hat somit keinen commit erstellt, wir müssen den Mergekonflikt von Hand lösen, bevor wir weiter arbeiten können. Weitere Infos liefert git status:\n1 2 3 4 5 6 7 8 9 10 11 $ git status On branch master You have unmerged paths. (fix conflicts and run \"git commit\") (use \"git merge --abort\" to abort the merge) Unmerged paths: (use \"git add \u003cfile\u003e...\" to mark resolution) both modified: first-file.txt no changes added to commit (use \"git add\" and/or \"git commit -a\") Git fügt automatisch eine Markierung in die Dateien ein, welche gmerged werden müssen:\n1 2 3 4 5 \u003c\u003c\u003c\u003c\u003c\u003c\u003c HEAD first line from master ======= first line from bugfix \u003e\u003e\u003e\u003e\u003e\u003e\u003e bugfix Das bedeutet, dass der HEAD (also der Masterbranch, weil auf den haben wir vor dem Mergen gewechselt) den oberen Teil (also immer alles auf Grün) und unsere neuen Änderungen den unteren Teil auf dieser Zeile hatten. Man kann den Konflikt nun lösen, indem man den ganzen Block, mit der gewünschten Änderung ersetzt. Ist der Konflikt gelöst, können wir die Datei ganz normal stagen und commiten. Gerade bei grösseren Mergekonflikten kann es praktisch sein mit tools zu Arbeiten, welche einem die Unterschiede zwischen den beiden Branches Grafisch darstellen, dafür gibt es den Befehl git mergetool.\nIn der Regel können viele Merge-Konflikte verhindert oder minimiert werden, indem:\nRegelmässige Kommunikation von Änderungen zwischen Teammitgliedern.\nRegelmässige Rebases mit dem Merge-Zielbranch.\nErstellen kleiner und atomarer Commits.\nFlows Flows sind standardisierte Abläufe, wie Branches erzeugt und später Releases erstellt werden. Wir zeigen hier die zwei am weitesten verbreiteten Flows.\nFeature Branch Flow Der Feature Branch Flow besagt, dass man für jede neue Funktion oder Verbesserung (Feature) einen eigenen Branch erstellt. Auf diesem Branch kann die Funktion entwickelt werden, ohne den Main-Branch zu beeinflussen. Sobald die Arbeit abgeschlossen und getestet ist, wird der Feature-Branch wieder in den Hauptbranch (main) integriert.\nVertiefende Informationen zum Feature Branch Flow können auf dieser Seite gelesen werden.\nGitflow Der Gitflow unterscheidet sich primär vom Feature Branch Flow indem, dass zwei Hauptbranches verwendet werden: main für den stabilen Code und development für die laufende Entwicklung. So werden Feature-Branches nicht direkt vom main-, sondern vom development-Branch (Name kann abweichen) abzweigen. So werden fertiggestellte Änderungen auch nicht gleich in den Main integriert, sondern zurück in den Development-Branch. Zudem wird ein release-Branch verwendet, auf welchen Änderungen vom Development-Branch gepusht werden, um dort vor einem Release getestet zu werden. Anschließend wird der release-Branch, und nur dieser, in den main gemerged. Nebst Feature Branches können auch Branches für Releases und Hotfixes (hier nicht abgebildet) erstellt werden.\nDer Flow ermöglicht eine strukturierte Vorgehensweise für die Entwicklung und Veröffentlichung von Software, indem Entwicklungs- und Produktionscode getrennt werden. Änderungen sind einfach und schnell nachvollziehbar und es ist jederzeit möglich, schnell auf eine releaste-Version zurückzugreifen.\nVertiefende Informationen zum Gitflow können auf dieser Seite gelesen werden.\nHands On https://learngitbranching.js.org/\n","categories":"","description":"","excerpt":"Inhalt Beispiel für Branching, Merging und Rebasing Einfache …","ref":"/de/docs/04_git/01_grundwissen/05_git-branches/","tags":"","title":"Git Branches"},{"body":"Ziele Ich weiss, wozu HTML-Formulare benutzt werden. Ich kenne die folgenden HTML-Formular-Elemente und weiss wie ich sie benutzen kann: input label button checkbox date email file hidden number password radio Ich kann ein HTML-Formular erstellen und die Werte aus dem Formulare an ein Backend verschicken. Wieso HTML-Formulare? Die Benutzer deiner Webseite möchten oder sollen Daten eingeben können, beispielsweise in einem Kontakt-Formular, auf einer Login-Seite oder beim Tätigen von Bestellungen. HTML-Formulare ermöglichen genau das, auch ohne die Verwendung von JavaScript.\nHTML-Input-Element Bevor wir uns HTML-Formulare genauer ansehen, werfen wir zuerst einen Blick auf die Input-Elemente, die die Eingabe von Daten überhaupt ermöglichen.\nBeginnen wir mit einer einfachen TextBox:\n1 Wie lautet dein Vorname? \u003cinput type=\"text\" name=\"firstname\" /\u003e Probiere alle Beispiele immer selbst aus. Der obenstehende Code reicht bereits aus, um eine simple Texteingabe in HTML einzubinden.\nDas type-Attribut definiert, um was für eine Art von Input-Element es sich handelt. text definiert hierbei ein Texteingabefeld. Das zweite Attribut kannst du im Moment noch ignorieren.\nLabel für Input-Elemente Vor einem Input-Element steht zumeist ein Text, der beschreibt, was im \u003cinput/\u003e-Element als Eingabe erwartet wird (“Wie lautet dein Vorname”). Dieser Text wird auch “Label” genannt. Bei einer guten Webseite wird zudem auch das Textfeld ausgewählt, wenn der User auf das Label klickt (nicht nur beim Klick auf das Textfeld). Diese Funktionalität wollen wir hinzufügen:\n1 \u003clabel\u003eWie lautet dein Vorname?\u003cinput type=\"text\" name=\"firstname\" /\u003e\u003c/label\u003e Die gewünschte Funktionalität hat sich dadurch bereits hinzufügen lassen. Aber was genau haben wir hier gemacht?\nWir haben den vorhergehenden Text als Label definiert (da es sich in einem label-Element befindet). Wenn wir ein Input-Element in einem Label hinzufügen, dann wird bei einem Klick auf dieses Label automatisch dieses Input-Element fokussiert.\nNun sieht das aber noch ein bisschen unübersichtlich aus. Das können wir besser! Zum Beispiel so:\n1 2 \u003clabel for=\"firstname\"\u003eWas ist dein Vorname?\u003c/label\u003e \u003cinput id=\"firstname\" type=\"text\" name=\"firstname\" /\u003e Abgesehen davon, dass das Input-Element nicht mehr im Label ist, ist der grosse Unterschied:\ndass das Input-Element nun ein id-Attribut hat und dass das Label mit dem for-Attribut darauf referenziert und damit mit dem Input-Element verbunden ist. Fassen wir also zusammen, weshalb wir das label-Element verwenden:\nBeim Klick auf das Label wird das entsprechende Input-Element ausgewählt. Beim Klick in das entsprechende Input-Element würde ein Screenreader den Namen des Labels vorlesen, wenn ein solcher verwendet wird. Zuletzt können die Labels auf diese Weise auch einfacher gestylt werden. Weitere Input-Elemente In HTML gibt es viele weitere Input-Elemente. Eine vollständige Liste findest du hier: https://www.w3schools.com/html/html_form_input_types.asp\nKennen solltest du sicher die folgenden:\nbutton checkbox date email tel file hidden number password radio Schaue dir diese Elemente auf der obengenannten Seite an. Du solltest wissen, welche Elemente es gibt und wie diese aussehen.\nFormulare Nun solltest du imstande sein, UI-Elemente (UI = User Interface -\u003e Benutzerschnittstelle) mit HTML auf einer Seite anzuzeigen. Jetzt wäre es schön, wenn diese Daten auch weitergehend verwendet werden könnten.\nTheoretisch könntest du mit der Programmiersprache JavaScript direkt darauf zugreifen. Im Moment wollen wir aber bei HTML bleiben. Was mit reinem HTML möglich ist, ist, die Werte an ein Backend (=Server) zu schicken.\nAls Backend verwenden wir die folgende URL: https://www.w3schools.com/action_page.php. Das ist eine spezielle von w3schools gehostete Seite, welche die Daten, die wir ihr senden, anzeigen kann.\nFolgender Code erzeugt ein Formular, welches eine E-Mail und einen Boolean-Wert beim Klick auf “Übermitteln” an das Backend schickt\n1 2 3 4 5 6 7 8 9 \u003cform action=\"https://www.w3schools.com/action_page.php\" method=\"get\"\u003e \u003clabel for=\"email\"\u003eEmail:\u003c/label \u003e\u003cinput type=\"email\" name=\"email\" id=\"email\" required /\u003e \u003cbr /\u003e \u003cinput type=\"checkbox\" name=\"interested\" id=\"interested\" /\u003e \u003clabel for=\"interested\"\u003eNewsletter abonnieren\u003c/label\u003e \u003cbr /\u003e \u003cinput type=\"submit\" value=\"Übermitteln\" /\u003e \u003c/form\u003e Entscheidend ist hier das \u003cform\u003e-Tag. Das action-Attribut legt fest, wo die Daten hingeschickt werden. Die method legt fest, welche HTTP Request Method verwendet wird (GET oder POST). Bist du dir nicht mehr sicher, welche Methode was bedeutet, dann schaue dir das “REST”-Kapitel noch einmal an.\nBei Formularen verwendet man meistens entweder GET oder POST. Obwohl beide zum selben Resultat führen können, unterscheiden die beiden Methoden sich trotzdem grundlegend voneinander. Die zu verwendende Methode wird meistens vom Backend festgelegt. Unser Backend unterstützt in diesem Fall aber beide Methoden.\nGET Unter Verwendung der GET-Methode werden die Daten, die an den Server gesendet werden sollen, direkt in die URL geschrieben. Sie können in der Adresszeile des Browsers als Klartext angesehen werden. Das könnte für unser Beispiel aussehen wie folgt:\nhttps://www.w3schools.com/action_page.php?email=hello@world.com\u0026interested=on\nVorteile\nDa die Parameter in die URL eingebettet werden, lassen sich für bestimmte Abfragen auch Lesezeichen (Bookmarks) anlegen und die Seite kann über den Browserverlauf “zurückgeholt” werden.\nNachteile\nDer Hauptnachteil ist der mangelnde Datenschutz. Die mitgesendeten URL-Parameter werden im Klartext im Cache und im Logfile des Servers abgelegt. Deshalb sollten die Login-Daten, also insbesondere Passwörter, grundsätzlich mit POST übertragen werden. Ein weiterer Nachteil besteht in der beschränkten Kapazität, je nach Webserver und Browser ist die maximale Länge der URL auf 2.000 Zeichen begrenzt. Das reicht meistens nicht, um zum Beispiel Dateien wie Bilder oder Videos zu übertragen.\nPOST Die POST-Methode schreibt die Parameter direkt in den generierten HTTP-Request, womit die Parameter für den Benutzer nicht direkt einsehbar sind. Der Umfang der POST-Anfragen ist unbeschränkt.\nVorteile\nWenn sensible Daten wie beispielsweise Benutzername und Passwort an den Server übermittelt werden sollen, bietet die POST-Methode die erforderliche Diskretion. Die Daten werden weder im Cache gespeichert, noch erscheinen sie im Browserverlauf. Mit der POST-Methode können nicht nur kurze Texte, sondern Daten jeglichen Umfangs und Typs übermittelt werden, wie etwa Bilder oder Videos.\nNachteile\nWenn eine Webseite mit einem Formular im Browser aktualisiert wird, müssen die Formulardaten nochmals übermittelt werden. Dabei besteht die Gefahr, dass die Daten versehentlich mehrmals gesendet werden, was zum Beispiel bei einem Bestellformular unerwünschte Doppelaufträge auslösen kann. Ebenso können die Daten, die mit der POST-Methode übermittelt werden, nicht zusammen mit der URL als Lesezeichen gespeichert werden.\nWann sollte welche Methode verwendet werden? POST wird fast durchwegs bevorzugt, wenn der Anwender Daten oder Dateien an den Server übermitteln muss, beispielsweise bei Formularen mit vielen Daten oder beim Hochladen von Bildern.\nGET eignet sich besonders gut für das Personalisieren von Websites: Die Sucheingaben, Filter-Einstellungen und Listensortierungen des Anwenders können zusammen mit der URL als Lesezeichen gespeichert werden, sodass beim nächsten Aufruf die Website exakt so aussieht, wie man es sich wünscht.\nWichtig für das Formular ist, dass es einen submit-Button besitzt. Dieser Submit-Button löst das Senden der Daten an die angegebene URL (action) mit der entsprechenden HTTP Request Method (method) aus. Probiere dieses Formular einmal aus. Du wirst sehen, dass etwas im folgenden Stil an den Server übermittelt wird:\n1 email=hello@world.com\u0026interested=on Die Daten werden also als Text übermittelt. Die einzelnen Felder werden jeweils mit\n1 key=value übermittelt und mit einem “\u0026” miteinander kombiniert. Der key stammt jeweils vom name-Attribut der Input-Elemente.\nIm oben gezeigten Beispiel haben wir bereits eine kleine Validierung (Überprüfung der Eingaben) integriert:\nEinerseits haben wir mit dem required-Attribut festgelegt, dass die E-Mail-Box nicht leer sein darf, bevor Daten übermittelt werden. Anderseits verbietet type=\"email\" das Senden, wenn etwas anderes als eine E-Mail-Adresse eingegeben wird. Aus diesem Grund verwenden wir eher type=\"email\" als type=\"text\" für E-Mail-Adressen, type=\"tel\" für Telefonnummern und type=\"date\" für ein Datum. Ein komplexeres Beispiel Um zu zeigen, wie einfach Input-Elemente verwendet werden können, kannst du folgendes Beispiel ausprobieren:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u003ch2\u003eLogin\u003c/h2\u003e \u003cform action=\"https://www.w3schools.com/action_page.php\" method=\"get\"\u003e \u003clabel\u003eemail: \u003cinput type=\"email\" name=\"your-email\" /\u003e\u003c/label\u003e \u003cbr /\u003e \u003clabel for=\"pw\"\u003epassword:\u003c/label\u003e \u003cinput type=\"password\" name=\"your-password\" id=\"pw\" /\u003e \u003cbr /\u003e \u003clabel \u003e\u003cinput type=\"checkbox\" name=\"stay\" value=\"yes\" /\u003eStay logged in.\u003c/label \u003e \u003ch4\u003eFavorite Language?\u003c/h4\u003e \u003cp\u003e \u003cinput type=\"radio\" id=\"html\" name=\"fav_language\" value=\"HTML\" /\u003e \u003clabel for=\"html\"\u003eHTML\u003c/label\u003e\u003cbr /\u003e \u003cinput type=\"radio\" id=\"css\" name=\"fav_language\" value=\"CSS\" /\u003e \u003clabel for=\"css\"\u003eCSS\u003c/label\u003e\u003cbr /\u003e \u003c/p\u003e \u003cinput type=\"submit\" /\u003e \u003c/form\u003e Jetzt bist du dran. Löse die Aufgabe 1 in den Labs.\n","categories":"","description":"Modul #F3 - HTML und CSS - Formular-Daten mit HTML verschicken.\n","excerpt":"Modul #F3 - HTML und CSS - Formular-Daten mit HTML verschicken.\n","ref":"/docs/03_web/02_html_css/05_forms/","tags":"","title":"HTML Formulare"},{"body":"Ziele Ich weiss, wozu HTML-Formulare benutzt werden. Ich kenne die folgenden HTML-Formular-Elemente und weiss wie ich sie benutzen kann: input label button checkbox date email file hidden number password radio Ich kann ein HTML-Formular erstellen und die Werte aus dem Formulare an ein Backend verschicken. Wieso HTML-Formulare? Die Benutzer deiner Webseite möchten oder sollen Daten eingeben können, beispielsweise in einem Kontakt-Formular, auf einer Login-Seite oder beim Tätigen von Bestellungen. HTML-Formulare ermöglichen genau das, auch ohne die Verwendung von JavaScript.\nHTML-Input-Element Bevor wir uns HTML-Formulare genauer ansehen, werfen wir zuerst einen Blick auf die Input-Elemente, die die Eingabe von Daten überhaupt ermöglichen.\nBeginnen wir mit einer einfachen TextBox:\n1 Wie lautet dein Vorname? \u003cinput type=\"text\" name=\"firstname\" /\u003e Probiere alle Beispiele immer selbst aus. Der obenstehende Code reicht bereits aus, um eine simple Texteingabe in HTML einzubinden.\nDas type-Attribut definiert, um was für eine Art von Input-Element es sich handelt. text definiert hierbei ein Texteingabefeld. Das zweite Attribut kannst du im Moment noch ignorieren.\nLabel für Input-Elemente Vor einem Input-Element steht zumeist ein Text, der beschreibt, was im \u003cinput/\u003e-Element als Eingabe erwartet wird (“Wie lautet dein Vorname”). Dieser Text wird auch “Label” genannt. Bei einer guten Webseite wird zudem auch das Textfeld ausgewählt, wenn der User auf das Label klickt (nicht nur beim Klick auf das Textfeld). Diese Funktionalität wollen wir hinzufügen:\n1 \u003clabel\u003eWie lautet dein Vorname?\u003cinput type=\"text\" name=\"firstname\" /\u003e\u003c/label\u003e Die gewünschte Funktionalität hat sich dadurch bereits hinzufügen lassen. Aber was genau haben wir hier gemacht?\nWir haben den vorhergehenden Text als Label definiert (da es sich in einem label-Element befindet). Wenn wir ein Input-Element in einem Label hinzufügen, dann wird bei einem Klick auf dieses Label automatisch dieses Input-Element fokussiert.\nNun sieht das aber noch ein bisschen unübersichtlich aus. Das können wir besser! Zum Beispiel so:\n1 2 \u003clabel for=\"firstname\"\u003eWas ist dein Vorname?\u003c/label\u003e \u003cinput id=\"firstname\" type=\"text\" name=\"firstname\" /\u003e Abgesehen davon, dass das Input-Element nicht mehr im Label ist, ist der grosse Unterschied:\ndass das Input-Element nun ein id-Attribut hat und dass das Label mit dem for-Attribut darauf referenziert und damit mit dem Input-Element verbunden ist. Fassen wir also zusammen, weshalb wir das label-Element verwenden:\nBeim Klick auf das Label wird das entsprechende Input-Element ausgewählt. Beim Klick in das entsprechende Input-Element würde ein Screenreader den Namen des Labels vorlesen, wenn ein solcher verwendet wird. Zuletzt können die Labels auf diese Weise auch einfacher gestylt werden. Weitere Input-Elemente In HTML gibt es viele weitere Input-Elemente. Eine vollständige Liste findest du hier: https://www.w3schools.com/html/html_form_input_types.asp\nKennen solltest du sicher die folgenden:\nbutton checkbox date email tel file hidden number password radio Schaue dir diese Elemente auf der obengenannten Seite an. Du solltest wissen, welche Elemente es gibt und wie diese aussehen.\nFormulare Nun solltest du imstande sein, UI-Elemente (UI = User Interface -\u003e Benutzerschnittstelle) mit HTML auf einer Seite anzuzeigen. Jetzt wäre es schön, wenn diese Daten auch weitergehend verwendet werden könnten.\nTheoretisch könntest du mit der Programmiersprache JavaScript direkt darauf zugreifen. Im Moment wollen wir aber bei HTML bleiben. Was mit reinem HTML möglich ist, ist, die Werte an ein Backend (=Server) zu schicken.\nAls Backend verwenden wir die folgende URL: https://www.w3schools.com/action_page.php. Das ist eine spezielle von w3schools gehostete Seite, welche die Daten, die wir ihr senden, anzeigen kann.\nFolgender Code erzeugt ein Formular, welches eine E-Mail und einen Boolean-Wert beim Klick auf “Übermitteln” an das Backend schickt\n1 2 3 4 5 6 7 8 9 \u003cform action=\"https://www.w3schools.com/action_page.php\" method=\"get\"\u003e \u003clabel for=\"email\"\u003eEmail:\u003c/label \u003e\u003cinput type=\"email\" name=\"email\" id=\"email\" required /\u003e \u003cbr /\u003e \u003cinput type=\"checkbox\" name=\"interested\" id=\"interested\" /\u003e \u003clabel for=\"interested\"\u003eNewsletter abonnieren\u003c/label\u003e \u003cbr /\u003e \u003cinput type=\"submit\" value=\"Übermitteln\" /\u003e \u003c/form\u003e Entscheidend ist hier das \u003cform\u003e-Tag. Das action-Attribut legt fest, wo die Daten hingeschickt werden. Die method legt fest, welche HTTP Request Method verwendet wird (GET oder POST). Bist du dir nicht mehr sicher, welche Methode was bedeutet, dann schaue dir das “REST”-Kapitel noch einmal an.\nBei Formularen verwendet man meistens entweder GET oder POST. Obwohl beide zum selben Resultat führen können, unterscheiden die beiden Methoden sich trotzdem grundlegend voneinander. Die zu verwendende Methode wird meistens vom Backend festgelegt. Unser Backend unterstützt in diesem Fall aber beide Methoden.\nGET Unter Verwendung der GET-Methode werden die Daten, die an den Server gesendet werden sollen, direkt in die URL geschrieben. Sie können in der Adresszeile des Browsers als Klartext angesehen werden. Das könnte für unser Beispiel aussehen wie folgt:\nhttps://www.w3schools.com/action_page.php?email=hello@world.com\u0026interested=on\nVorteile\nDa die Parameter in die URL eingebettet werden, lassen sich für bestimmte Abfragen auch Lesezeichen (Bookmarks) anlegen und die Seite kann über den Browserverlauf “zurückgeholt” werden.\nNachteile\nDer Hauptnachteil ist der mangelnde Datenschutz. Die mitgesendeten URL-Parameter werden im Klartext im Cache und im Logfile des Servers abgelegt. Deshalb sollten die Login-Daten, also insbesondere Passwörter, grundsätzlich mit POST übertragen werden. Ein weiterer Nachteil besteht in der beschränkten Kapazität, je nach Webserver und Browser ist die maximale Länge der URL auf 2.000 Zeichen begrenzt. Das reicht meistens nicht, um zum Beispiel Dateien wie Bilder oder Videos zu übertragen.\nPOST Die POST-Methode schreibt die Parameter direkt in den generierten HTTP-Request, womit die Parameter für den Benutzer nicht direkt einsehbar sind. Der Umfang der POST-Anfragen ist unbeschränkt.\nVorteile\nWenn sensible Daten wie beispielsweise Benutzername und Passwort an den Server übermittelt werden sollen, bietet die POST-Methode die erforderliche Diskretion. Die Daten werden weder im Cache gespeichert, noch erscheinen sie im Browserverlauf. Mit der POST-Methode können nicht nur kurze Texte, sondern Daten jeglichen Umfangs und Typs übermittelt werden, wie etwa Bilder oder Videos.\nNachteile\nWenn eine Webseite mit einem Formular im Browser aktualisiert wird, müssen die Formulardaten nochmals übermittelt werden. Dabei besteht die Gefahr, dass die Daten versehentlich mehrmals gesendet werden, was zum Beispiel bei einem Bestellformular unerwünschte Doppelaufträge auslösen kann. Ebenso können die Daten, die mit der POST-Methode übermittelt werden, nicht zusammen mit der URL als Lesezeichen gespeichert werden.\nWann sollte welche Methode verwendet werden? POST wird fast durchwegs bevorzugt, wenn der Anwender Daten oder Dateien an den Server übermitteln muss, beispielsweise bei Formularen mit vielen Daten oder beim Hochladen von Bildern.\nGET eignet sich besonders gut für das Personalisieren von Websites: Die Sucheingaben, Filter-Einstellungen und Listensortierungen des Anwenders können zusammen mit der URL als Lesezeichen gespeichert werden, sodass beim nächsten Aufruf die Website exakt so aussieht, wie man es sich wünscht.\nWichtig für das Formular ist, dass es einen submit-Button besitzt. Dieser Submit-Button löst das Senden der Daten an die angegebene URL (action) mit der entsprechenden HTTP Request Method (method) aus. Probiere dieses Formular einmal aus. Du wirst sehen, dass etwas im folgenden Stil an den Server übermittelt wird:\n1 email=hello@world.com\u0026interested=on Die Daten werden also als Text übermittelt. Die einzelnen Felder werden jeweils mit\n1 key=value übermittelt und mit einem “\u0026” miteinander kombiniert. Der key stammt jeweils vom name-Attribut der Input-Elemente.\nIm oben gezeigten Beispiel haben wir bereits eine kleine Validierung (Überprüfung der Eingaben) integriert:\nEinerseits haben wir mit dem required-Attribut festgelegt, dass die E-Mail-Box nicht leer sein darf, bevor Daten übermittelt werden. Anderseits verbietet type=\"email\" das Senden, wenn etwas anderes als eine E-Mail-Adresse eingegeben wird. Aus diesem Grund verwenden wir eher type=\"email\" als type=\"text\" für E-Mail-Adressen, type=\"tel\" für Telefonnummern und type=\"date\" für ein Datum. Ein komplexeres Beispiel Um zu zeigen, wie einfach Input-Elemente verwendet werden können, kannst du folgendes Beispiel ausprobieren:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u003ch2\u003eLogin\u003c/h2\u003e \u003cform action=\"https://www.w3schools.com/action_page.php\" method=\"get\"\u003e \u003clabel\u003eemail: \u003cinput type=\"email\" name=\"your-email\" /\u003e\u003c/label\u003e \u003cbr /\u003e \u003clabel for=\"pw\"\u003epassword:\u003c/label\u003e \u003cinput type=\"password\" name=\"your-password\" id=\"pw\" /\u003e \u003cbr /\u003e \u003clabel \u003e\u003cinput type=\"checkbox\" name=\"stay\" value=\"yes\" /\u003eStay logged in.\u003c/label \u003e \u003ch4\u003eFavorite Language?\u003c/h4\u003e \u003cp\u003e \u003cinput type=\"radio\" id=\"html\" name=\"fav_language\" value=\"HTML\" /\u003e \u003clabel for=\"html\"\u003eHTML\u003c/label\u003e\u003cbr /\u003e \u003cinput type=\"radio\" id=\"css\" name=\"fav_language\" value=\"CSS\" /\u003e \u003clabel for=\"css\"\u003eCSS\u003c/label\u003e\u003cbr /\u003e \u003c/p\u003e \u003cinput type=\"submit\" /\u003e \u003c/form\u003e Jetzt bist du dran. Löse die Aufgabe 1 in den Labs.\n","categories":"","description":"Modul #F3 - HTML und CSS - Formular-Daten mit HTML verschicken.\n","excerpt":"Modul #F3 - HTML und CSS - Formular-Daten mit HTML verschicken.\n","ref":"/de/docs/03_web/02_html_css/05_forms/","tags":"","title":"HTML Formulare"},{"body":"Ziele Ich kann Namen für Objekte in einem Text identifizieren Ich kann gute Namen für Attribute und Methoden wählen Ich kann Objekte erstellen und ihnen entsprechende Eigenschaften geben Ich kann Objekte untereinander verknüpfen Immobilienfirma In dieser Aufgabe soll eine Immobilienfirma mit Objekten abgebildet werden. Eine solche Firma besitzt beliebige Immobilien und hat einen Firmensitz an einer bestimmten Adresse. Die Firma hat diverse Angestellte und einen Namen. Eine Immobilie kann aus diversen Wohnungen bestehen, welche vermietet werden. Eine Immobilie hat eine bestimmte Adresse und ein Angestellter der Firma ist der Immobilie als Abwart zugeteilt. Ein Angestellter der Firma ist zudem der Verwalter einer solchen Immobilie. Eine Wohnung befindet sich in einem bestimmten Stockwerk, besitzt eine Wohnungsnummer und eine Beschreibung. Wenn ein Mieter in eine Wohnung einzieht, so gibt es zwischen Firma und Mieter einen Vertrag für eine bestimmte Wohnung. Jeder Vertrag hat ein Start- und ein End-Datum, zudem regelt der Vertrag den monatlichen Preis für eine Wohnung. Die Standardangaben für eine Person werden durch ein Geburtsdatum und ein Geschlecht ergänzt.\nTeil 1 Ermittle aus dem Text oben die verschiedenen Objekte und ihre Eigenschaften. Verknüpfe dann die Objekte miteinander, zum Beispiel hat eine Immobilienfirma eine Adresse als Firmensitz.\nTeil 2 Erstelle für deine Firma mindestens zwei Immobilien mit unterschiedlichen Wohnungen. Definiere Angestellte und Abwarte. Erstelle Mieter und Verträge.\nTeil 3 Erstelle für die Firma die folgenden Funktionen:\nErmittle die total Anzahl an Wohnungen von allen Immobilien Ermittle den Abwart für eine bestimmte Wohnung Ermittle die Verträge für eine bestimmte Immobilie Ermittle die leeren Wohnungen für eine bestimmte Immobilie Ermittle die Verträge, die im nächsten Monat ablaufen Ermittle alle Verträge sortiert nach Personen (eine Person kann mehrere Wohnungen mieten) Ermittle das monatliche Einkommen pro Immobilie Ermittle das jährliche Einkommen der Firma (ein Vertrag kann während dem Jahr ablaufen) Es soll kein Scanner eingesetzt werden.\nHier kannst du zurück zur Theorie.\n","categories":"","description":"Aufgabe zu Modul #J2 - OOP - Immobilienfirma\n","excerpt":"Aufgabe zu Modul #J2 - OOP - Immobilienfirma\n","ref":"/labs/02_java/04_java-oop/05_immofirma/","tags":"","title":"Immobilienfirma"},{"body":"Ziele Ich kann Namen für Objekte in einem Text identifizieren Ich kann gute Namen für Attribute und Methoden wählen Ich kann Objekte erstellen und ihnen entsprechende Eigenschaften geben Ich kann Objekte untereinander verknüpfen Immobilienfirma In dieser Aufgabe soll eine Immobilienfirma mit Objekten abgebildet werden. Eine solche Firma besitzt beliebige Immobilien und hat einen Firmensitz an einer bestimmten Adresse. Die Firma hat diverse Angestellte und einen Namen. Eine Immobilie kann aus diversen Wohnungen bestehen, welche vermietet werden. Eine Immobilie hat eine bestimmte Adresse und ein Angestellter der Firma ist der Immobilie als Abwart zugeteilt. Ein Angestellter der Firma ist zudem der Verwalter einer solchen Immobilie. Eine Wohnung befindet sich in einem bestimmten Stockwerk, besitzt eine Wohnungsnummer und eine Beschreibung. Wenn ein Mieter in eine Wohnung einzieht, so gibt es zwischen Firma und Mieter einen Vertrag für eine bestimmte Wohnung. Jeder Vertrag hat ein Start- und ein End-Datum, zudem regelt der Vertrag den monatlichen Preis für eine Wohnung. Die Standardangaben für eine Person werden durch ein Geburtsdatum und ein Geschlecht ergänzt.\nTeil 1 Ermittle aus dem Text oben die verschiedenen Objekte und ihre Eigenschaften. Verknüpfe dann die Objekte miteinander, zum Beispiel hat eine Immobilienfirma eine Adresse als Firmensitz.\nTeil 2 Erstelle für deine Firma mindestens zwei Immobilien mit unterschiedlichen Wohnungen. Definiere Angestellte und Abwarte. Erstelle Mieter und Verträge.\nTeil 3 Erstelle für die Firma die folgenden Funktionen:\nErmittle die total Anzahl an Wohnungen von allen Immobilien Ermittle den Abwart für eine bestimmte Wohnung Ermittle die Verträge für eine bestimmte Immobilie Ermittle die leeren Wohnungen für eine bestimmte Immobilie Ermittle die Verträge, die im nächsten Monat ablaufen Ermittle alle Verträge sortiert nach Personen (eine Person kann mehrere Wohnungen mieten) Ermittle das monatliche Einkommen pro Immobilie Ermittle das jährliche Einkommen der Firma (ein Vertrag kann während dem Jahr ablaufen) Es soll kein Scanner eingesetzt werden.\nHier kannst du zurück zur Theorie.\n","categories":"","description":"Aufgabe zu Modul #J2 - OOP - Immobilienfirma\n","excerpt":"Aufgabe zu Modul #J2 - OOP - Immobilienfirma\n","ref":"/de/labs/02_java/04_java-oop/05_immofirma/","tags":"","title":"Immobilienfirma"},{"body":"","categories":"","description":"Exercises zu Modul #S2 - [Maven](../../../../docs/02_java/05_maven)\n","excerpt":"Exercises zu Modul #S2 - [Maven](../../../../docs/02_java/05_maven)\n","ref":"/labs/02_java/05_maven/","tags":"","title":"Java Exercises - Maven"},{"body":"","categories":"","description":"Exercises zu Modul #S2 - [Maven](../../../../docs/02_java/05_maven)\n","excerpt":"Exercises zu Modul #S2 - [Maven](../../../../docs/02_java/05_maven)\n","ref":"/de/labs/02_java/05_maven/","tags":"","title":"Java Exercises - Maven"},{"body":"Ziele Ich weiss, was eine bedingte Anweisung ist und kann sie korrekt anwenden. Ich kann eine Schleife programmieren: for, foreach, while und do-while. Ich kenne die switch-Anweisung. Kontrollstrukturen Kontrollstrukturen dienen dazu, den Ablauf eines Programms zu steuern. Damit bietet eine Kontrollstruktur die Möglichkeit, Programmteile nur unter gewissen Bedingungen ( → bedingte Anweisungen) auszuführen oder Programmteile zu wiederholen ( → Schleifen).\nBedingte Anweisungen Eine bedingte Anweisung ist eine Konstruktion, mit der ein Programm abhängig vom Wert eines boolschen Ausdrucks (true oder false) unterschiedliche Wege geht.\nIf-Statement Die einfachste Form der bedingten Anweisung besteht aus dem Schlüsselwort if, einem boolschen Ausdruck und einem Block.\n1 2 3 if (expression) { } Wenn der Ausdruck true ist, werden die Anweisungen im Codeblock ausgeführt. Andernfalls werden sie übersprungen.\nIf-Else Statement Der obige if-Fall kann mit dem Schlüsselwort else erweitert werden, um alternative Aktionen auszuführen, wenn der Ausdruck false ist.\n1 2 3 4 5 if (expression) { // do something } else { // do something else } Im folgenden Beispiel gibt das Programm je nach Wert von num (gerade oder ungerade) unterschiedlichen Text aus.\n1 2 3 4 5 6 int num = ...; // the num is initialized by some value if (num % 2 == 0) { System.out.println(\"It's an even number\"); } else { System.out.println(\"It's an odd number\"); } Da eine Zahl nur gerade oder ungerade sein kann, wird nur eine der beiden Ausgaben gemacht.\nElse-If-Statements Ein Else-Statement kann durch ein If-Statement erweitert werden.\n1 2 3 4 5 6 7 8 9 if (expression0) { // do something } else if (expression1) { // do something else 1 } else if (expressionN) { // do something else N } else { // in all other cases: do this… } Wenn also der erste Ausdruck false ist, wird der zweite Ausdruck überprüft, usw.\nBeispiel:\n1 2 3 4 5 6 7 8 9 10 long dollars = ...; // your budget if (dollars \u003c 1000) { System.out.println(\"Buy a laptop\"); } else if (dollars \u003c 2000) { System.out.println(\"Buy a personal computer\"); } else if (dollars \u003c 100_000) { System.out.println(\"Buy a server\"); } else { System.out.println(\"Buy a data center or a quantum computer\"); } Lernvideo Wenn du dir die Erklärung noch mit einem Video genauer anschauen möchtest, empfiehlt dir das Praxisbildner-Team dieses Video.\nJetzt bist du dran. Löse bitte die Aufgabe 2a zu den if-else-Bedingungen in den Labs.\nSwitch-Statement Die Switch-Anweisung bietet eine Möglichkeit, basierend auf dem Wert einer einzelnen Variablen (kein Ausdruck!) zwischen mehreren Fällen zu wählen. Die Variable kann eine Ganzzahl, ein Zeichen, eine Zeichenfolge oder eine Aufzählung sein.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 switch (variable) { case value1: // do something here break; case value2: // do something here break; //... other cases case valueN: // do something here break; default: // do something by default break; // it can be omitted } Die Schlüsselwörter switch und case werden hier immer benötigt. Die Schlüsselwörter break und default sind optional. Das Schlüsselwort break verlässt die Switch-Anweisung. Wenn ein Fall nicht über das Keyword break verfügt, wird auch der darauffolgende Fall ausgewertet. Dies ist spannend, um die einzelnen Auswertungen verketten zu können. Der Default-Fall wird ausgewertet, wenn kein Fall mit dem Variablenwert übereinstimmt.\nSeit Java 12 kann das switch-Statement kürzer geschrieben werden, indem statt einem Doppelpunkt der Pfeil-Operator -\u003e verwendet wird und dadurch die break-Zeile entfällt:\n1 2 3 4 5 6 7 8 String mood = \"happy\"; switch (mood) { case \"happy\" -\u003e System.out.println(\"Keep smiling.\"); case \"sad\" -\u003e System.out.println(\"Don't be sad!\"); case \"angry\" -\u003e System.out.println(\"Take a deep breath!\"); default -\u003e System.out.println(\"I'm sorry, I don't recognize that mood.\"); } Ausserdem ist es nun direkt möglich, eine Variable direkt mittels switch-Assignment zuzuweisen:\n1 2 3 4 5 6 7 8 9 10 int place = 1; String suffix = switch (place) { case 1 -\u003e \"st\"; case 2 -\u003e \"nd\"; case 3 -\u003e \"rd\"; default -\u003e \"th\"; }; System.out.println(\"You're on the \" + place + suffix + \" place.\"); Jetzt bist du dran. Löse bitte die Aufgabe 2b zum Switch-Statement in den Labs.\nSchleifen (Loops) Manchmal müssen wir einen Codeblock für eine bestimmte Anzahl wiederholen. Zu diesem Zweck stellt Java die Schleife bereit. Diese Schleife wird häufig verwendet, um über einen Wertebereich oder durch ein Array zu iterieren. For-Loops arbeiten mit einem Schleifenzähler, welcher sehr gut für Indizes von Arrays verwendet werden kann. Bei allen Schleifen ist Vorsicht geboten, da es rasch zu einer unendlichen Anzahl von Ausführungen kommen kann.\nWhile-Loop Die while- Schleife besteht aus einem Codeblock und einer Bedingung (einem booleschen Ausdruck). Wenn die Bedingung erfüllt ist, wird der Code innerhalb des Blocks ausgeführt. Dieser Code wird solange wiederholt, bis die Bedingung nicht mehr erfüllt ist.\n1 2 3 while (condition) { // body: do something } Innerhalb des Schleifenkörpers kann das Programm wiederum alle möglichen Java-Anweisungen ausführen. Es kann sogar andere Schleifen enthalten.\nBeispiel: Die folgende Schleife gibt Ganzzahlen aus, während eine Variable kleiner als 5 ist.\n1 2 3 4 5 6 7 int i = 0; while (i \u003c 5) { System.out.print(i + \" \"); i++; } // Output: 0 1 2 3 4 Do-While Loop Die Do-While-Schleife besteht aus einem Codeblock und einer Bedingung (einem boolschen Ausdruck) am Ende. Im Gegensatz zur While-Schleife wird die Do-While-Schleife mindestens einmal ausgeführt, da die Bedingung am Ende steht.\n1 2 3 do { // body: do something } while (condition); Lernvideo Wenn du dir die Erklärung noch mit einem Video genauer anschauen möchtest, empfiehlt dir das Praxisbildner-Team dieses Video.\nFor-Loop 1 2 3 for (initialization; condition; modification) { // do something } Bevor die Schleife beginnt, wird einmal die Initialisierungsanweisung (initialization) ausgeführt. Wir bezeichnen diese Variable als Schleifenvariable. Es sind mehrere Schleifenvariablen erlaubt, sie können durch Kommas getrennt werden. Die Bedingung (condition) ist ein boolscher Ausdruck, der die Notwendigkeit der nächsten Iteration bestimmt. Wenn die Auswertung der Bedingung false ist, wird die Schleife beendet – ansonsten folgt eine weitere Iteration Die Modifikation ist eine Anweisung, die den Wert der Schleifenvariablen verändert. Sie wird nach jeder Iteration aufgerufen. Normalerweise wird der Wert der Variable inkrementiert oder dekrementiert. Beispiel:\n1 2 3 4 5 int n = 9; for (int i = 0; i \u003c= n; i++) { System.out.print(i + \" \"); } // Output: 0 1 2 3 4 5 6 7 8 9 Innerhalb des Schleifenkörpers kann das Programm wiederum alle möglichen Java-Anweisungen ausführen. Es kann sogar andere Schleifen enthalten. Wie bei allen Blöcken sind die Schleifenvariablen nur innerhalb des Schleifenkörpers sichtbar. Die Schleifenvariable wird meistens mit einfachen Variablennamen wie i, j, k oder index benannt.\nHier ist ein weiteres Beispiel. Berechnen wir die Summe der Ganzzahlen von 1 bis 10 mit der for-Schleife.\n1 2 3 4 5 6 7 8 9 int startInclude = 1; int endExclude = 11; int sum = 0; for (int i = startInclude; i \u003c endExclude; i++) { sum += i; //ist das gleiche wie sum = sum + i } System.out.println(sum); // Output: 55 For-Each Loop Der For-Each-Loop durchläuft alle Elemente eines Arrays oder einer Collection. Die Angaben aus dem For-Loop werden durch eine Schleifenvariable und ein Doppelpunkt ersetzt. (Arrays lernst du später im Kapitel “Arrays” kennen. Daher ist dieses Beispiel hier nur zur Vollständigkeit aufgelistet - du musst dieses Beispiel hier noch nicht verstehen.)\n1 2 3 4 5 int[] numbers = { 125, 381, 98, 12, 235 }; for (int number: numbers) { System.out.print(number + \" \"); } // Output: 125 381 98 12 235 Der gezeigte Loop wird also fünfmal ausgeführt und der Wert der Variable number nimmt bei jedem Durchlauf den jeweils nächsten Wert aus dem Array an.\nLernvideo Wenn du dir die Erklärung noch mit einem Video genauer anschauen möchtest, empfiehlt dir das Praxisbildner-Team dieses Video.\nJetzt bist du dran. Löse bitte die Aufgabe 3 in den Labs.\n","categories":"","description":"Modul #J1\n","excerpt":"Modul #J1\n","ref":"/de/docs/02_java/03_java-grundlagen/05_control_structures/","tags":"","title":"Kontrollstrukturen"},{"body":"Ziele Ich kann ohne Hilfsmittel die Unterschiede zwischen Listen und Arrays in Java nennen. Ich kann mindestens drei der wichtigsten Merkmale einer Java-Liste auflisten. Ich kann mindestens 5 Methoden einer Liste korrekt und ohne Hilfsmittel nennen. Ich kann erklären, wozu die ArrayList-Klasse verwendet wird, und was sie für Vorteile mitbringt. Ich kann eine neue Liste erstellen und bei ihr Elemente hinzufügen, lesen und entfernen. Einführung Listen Für die Aufgaben des OOP-Modules #J2 wirst du effizienter arbeiten können, wenn du statt Arrays sogenannte Listen verwendest.\nAus diesem Grund schieben wir einen kleinen Crash-Kurs zu Listen vor den Einstieg ins OOP.\nWas ist eine Liste? Eine Liste ist in Java ein Behälter (Container), der Objekte in einer festen Abfolge enthält.\nIm Gegensatz zu Arrays, deren Elemente im Speicher in fortlaufender Reihenfolge abgelegt werden und deren Grösse aus diesem Grund ohne Neuinitialisierung unveränderbar ist, können Listen flexible Mengen an Objekten enthalten.\nDas List-Interface ist ein Teil des Java-Collections-Frameworks. Dieses Framework stellt einige Klassen zur Verfügung, welche das List-Interface umsetzen (mehr dazu in einem späteren Modul).\nDie wichtigsten Merkmale einer Liste Eine Liste kann nur Objekte beinhalten (es gibt also keine Liste mit primitiven Datentypen) Eine Liste kann nur Objekte eines Typs beinhalten. Dieser Typ wird zur Zeit der Definition der Liste bestimmt. Die Elemente innerhalb einer Liste haben eine feste Reihenfolge. Dies bedeutet, dass eine Iteration über eine Liste immer zu einem gleichen Ergebnis mit der gleichen Reihenfolge führt. Duplikate innerhalb einer Liste sind erlaubt (dasselbe Objekt darf mehrmals in einer Liste vorkommen) Eine Liste kann auch null-Elemente beinhalten. Die Indizes in einer Liste reichen immer von 0 bis Anzahl Elemente in der Liste minus 1. Die wichtigsten Methoden einer Liste Das List-Interface stellt mehrere Methoden zur Verfügung, welche dann von Klassen wie ArrayList oder LinkedList umgesetzt werden.\nNachfolgend werden einige Methoden und deren Zweck aufgelistet. Der Rückgabetyp “E” seht hier für einen generischen (universellen) Typ, der stellvertretend für einen spezifischen Objekttyp steht. Dieses Vorgehen wird genauer im Modul Generics behandelt.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /* * Returns: the number of elements in this list. */ int size(); /* * Appends the specified element to the end of this list. */ boolean add(E e); /** * Returns the element at the specified position in this list. */ E get(int index); /* * Removes the element at the specified position in this list. */ E remove(int index); /* * Removes the first occurrence of the specified element from * this list, if it is present. */ boolean remove(Object o); /* * Returns: true if this list contains the specified element. */ boolean contains(Object o); Die Klasse ArrayList ArrayList gehört zu der Liste der Standardsammelklassen und ist im java.util-Packet definiert.\nDie ArrayList ist eine Klasse, die zum Erstellen eines dynamischen Arrays verwendet wird. Dieses Array beinhaltet Objektreferenzen und kann bei Bedarf grösser werden.\nDie ArrayList kombiniert die Vorteile eines Arrays (z.B. schneller Zugriff auf einem bestimmten Element) mit den Vorteilen einer Liste (kann dynamisch wachsen) und ist deswegen sehr nützlich um eine Sammlung von Objekten, derer Grösse nicht bekannt ist, zu bearbeiten. Die ArrayList setzt alle Methoden (obligatorische wie auch optionale) des List-Interfaces um.\nArbeiten mit einer ArrayList - Beispiel Um mit ArrayList arbeiten zu können, muss die Klasse zuerst importiert werden.\n1 import java.util.ArrayList; Nun kann eine Variable definiert und eine ArrayList erzeugt werden. Die Syntax hier wird in späteren Modulen erklärt, hier reicht es zu wissen, dass innerhalb der spitzen Klammern - auf der linken Seite der Definition - der Typ der Objekte angegeben wird, welche dann in der Liste hinzugefügt werden dürfen.\n1 2 3 // Erstellen einer ArrayList für String-Objekte. // Ein Versuch, Objekte anderer Typ in der Liste hinzuzufügen wird in einem Kompilierfehler resultieren. List\u003cString\u003e words = new ArrayList\u003c\u003e(); Sobald eine Liste erzeugt wurde, können beliebig viel Objekte hinzugefügt oder entfernt werden.\nÜber die Liste kann mit einer Schleife iteriert werden oder auch mit einem Index direkt auf ein Element zugegriffen werden.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // Elemente hinzufügen words.add(\"Hello\"); words.add(\"World\"); words.add(\"!\"); System.out.println(words); // Output: [Hello, World, !] System.out.printf(\"There are %d words in our list\\n\", words.size()); System.out.printf(\"Our list contains \\\"!\\\". True or false? %b\\n\", words.contains(\"!\")); // Output: Our list contains \"!\". True or false? true System.out.printf(\"The second word is: %s\\n\", words.get(1)); // Output: World for (String word: words) { System.out.println(word); } words.remove(2); // Entfernt das dritte Element aus der Liste System.out.println(words); // Output: [Hello, World] System.out.printf(\"Our list contains \\\"!\\\". True or false? %b\\n\", words.contains(\"!\")); // Output: Our list contains \"!\". True or false? false Jetzt bist du dran. Löse bitte die Aufgabe 1 und 2 in den OOP-Labs.\n","categories":"","description":"Modul #J2\n","excerpt":"Modul #J2\n","ref":"/docs/02_java/04_java-oop/05_list-basics/","tags":"","title":"Java Lists Basics"},{"body":"Ziele Ich kann ohne Hilfsmittel die Unterschiede zwischen Listen und Arrays in Java nennen. Ich kann mindestens drei der wichtigsten Merkmale einer Java-Liste auflisten. Ich kann mindestens 5 Methoden einer Liste korrekt und ohne Hilfsmittel nennen. Ich kann erklären, wozu die ArrayList-Klasse verwendet wird, und was sie für Vorteile mitbringt. Ich kann eine neue Liste erstellen und bei ihr Elemente hinzufügen, lesen und entfernen. Einführung Listen Für die Aufgaben des OOP-Modules #J2 wirst du effizienter arbeiten können, wenn du statt Arrays sogenannte Listen verwendest.\nAus diesem Grund schieben wir einen kleinen Crash-Kurs zu Listen vor den Einstieg ins OOP.\nWas ist eine Liste? Eine Liste ist in Java ein Behälter (Container), der Objekte in einer festen Abfolge enthält.\nIm Gegensatz zu Arrays, deren Elemente im Speicher in fortlaufender Reihenfolge abgelegt werden und deren Grösse aus diesem Grund ohne Neuinitialisierung unveränderbar ist, können Listen flexible Mengen an Objekten enthalten.\nDas List-Interface ist ein Teil des Java-Collections-Frameworks. Dieses Framework stellt einige Klassen zur Verfügung, welche das List-Interface umsetzen (mehr dazu in einem späteren Modul).\nDie wichtigsten Merkmale einer Liste Eine Liste kann nur Objekte beinhalten (es gibt also keine Liste mit primitiven Datentypen) Eine Liste kann nur Objekte eines Typs beinhalten. Dieser Typ wird zur Zeit der Definition der Liste bestimmt. Die Elemente innerhalb einer Liste haben eine feste Reihenfolge. Dies bedeutet, dass eine Iteration über eine Liste immer zu einem gleichen Ergebnis mit der gleichen Reihenfolge führt. Duplikate innerhalb einer Liste sind erlaubt (dasselbe Objekt darf mehrmals in einer Liste vorkommen) Eine Liste kann auch null-Elemente beinhalten. Die Indizes in einer Liste reichen immer von 0 bis Anzahl Elemente in der Liste minus 1. Die wichtigsten Methoden einer Liste Das List-Interface stellt mehrere Methoden zur Verfügung, welche dann von Klassen wie ArrayList oder LinkedList umgesetzt werden.\nNachfolgend werden einige Methoden und deren Zweck aufgelistet. Der Rückgabetyp “E” seht hier für einen generischen (universellen) Typ, der stellvertretend für einen spezifischen Objekttyp steht. Dieses Vorgehen wird genauer im Modul Generics behandelt.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /* * Returns: the number of elements in this list. */ int size(); /* * Appends the specified element to the end of this list. */ boolean add(E e); /** * Returns the element at the specified position in this list. */ E get(int index); /* * Removes the element at the specified position in this list. */ E remove(int index); /* * Removes the first occurrence of the specified element from * this list, if it is present. */ boolean remove(Object o); /* * Returns: true if this list contains the specified element. */ boolean contains(Object o); Die Klasse ArrayList ArrayList gehört zu der Liste der Standardsammelklassen und ist im java.util-Packet definiert.\nDie ArrayList ist eine Klasse, die zum Erstellen eines dynamischen Arrays verwendet wird. Dieses Array beinhaltet Objektreferenzen und kann bei Bedarf grösser werden.\nDie ArrayList kombiniert die Vorteile eines Arrays (z.B. schneller Zugriff auf einem bestimmten Element) mit den Vorteilen einer Liste (kann dynamisch wachsen) und ist deswegen sehr nützlich um eine Sammlung von Objekten, derer Grösse nicht bekannt ist, zu bearbeiten. Die ArrayList setzt alle Methoden (obligatorische wie auch optionale) des List-Interfaces um.\nArbeiten mit einer ArrayList - Beispiel Um mit ArrayList arbeiten zu können, muss die Klasse zuerst importiert werden.\n1 import java.util.ArrayList; Nun kann eine Variable definiert und eine ArrayList erzeugt werden. Die Syntax hier wird in späteren Modulen erklärt, hier reicht es zu wissen, dass innerhalb der spitzen Klammern - auf der linken Seite der Definition - der Typ der Objekte angegeben wird, welche dann in der Liste hinzugefügt werden dürfen.\n1 2 3 // Erstellen einer ArrayList für String-Objekte. // Ein Versuch, Objekte anderer Typ in der Liste hinzuzufügen wird in einem Kompilierfehler resultieren. List\u003cString\u003e words = new ArrayList\u003c\u003e(); Sobald eine Liste erzeugt wurde, können beliebig viel Objekte hinzugefügt oder entfernt werden.\nÜber die Liste kann mit einer Schleife iteriert werden oder auch mit einem Index direkt auf ein Element zugegriffen werden.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // Elemente hinzufügen words.add(\"Hello\"); words.add(\"World\"); words.add(\"!\"); System.out.println(words); // Output: [Hello, World, !] System.out.printf(\"There are %d words in our list\\n\", words.size()); System.out.printf(\"Our list contains \\\"!\\\". True or false? %b\\n\", words.contains(\"!\")); // Output: Our list contains \"!\". True or false? true System.out.printf(\"The second word is: %s\\n\", words.get(1)); // Output: World for (String word: words) { System.out.println(word); } words.remove(2); // Entfernt das dritte Element aus der Liste System.out.println(words); // Output: [Hello, World] System.out.printf(\"Our list contains \\\"!\\\". True or false? %b\\n\", words.contains(\"!\")); // Output: Our list contains \"!\". True or false? false Jetzt bist du dran. Löse bitte die Aufgabe 1 und 2 in den OOP-Labs.\n","categories":"","description":"Modul #J2\n","excerpt":"Modul #J2\n","ref":"/de/docs/02_java/04_java-oop/05_list-basics/","tags":"","title":"Java Lists Basics"},{"body":" Dieses Kapitel gehört zum Modul #J1 des Ausbildungsplans Ziele Ich kann arithmetische Ausdrücke schreiben: Addition, Subtraktion, Multiplikation, Division, Modulo (Rest einer Division). Ich kenne die relationalen Operatoren: ==, \u003e=, \u003c=, \u003e, \u003c, !=. Ich kenne die booleschen Operatoren: \u0026\u0026 oder \u0026 (AND), || oder | (OR), ! (NOT), ^(XOR). Ich kenne die bitweise Operatoren: \u0026 (AND), | (OR), ~ (NOT), ^(XOR). Ich weiss, wass Lazy-Evaluation bedeutet. ⏱️ Geschätzte Lesezeit: 15 Minuten Mathematik \u0026 Logik Mathe in Java ist sehr einfach. Beachte, dass mathematische Java-Operationen einer bestimmten Reihenfolge folgen:\nPunkt-Operationen vor Strich-Operationen\nArithmetische Operatoren Symbol Operation Beispiel + Addition int sum = 2 + 3; - Subtraktion int difference = 5 - 2; / Division int quotient = 15 / 5; * Multiplikation int product = 3 * 4; % Modulo (Rest einer Division) int remainder = 7 % 3; ++ Post-/Prä-Inkrement (plus 1) count++; // count = count + 1 -- Post-/Prä-Dekrement (minus 1) count--; // count = count - 1 Kurzschreibweise: Zuweisungsoperatoren Zuweisungsoperatoren kombinieren eine Operation mit einer Zuweisung. Statt z. B. x = x + 5; kannst du einfach x += 5; schreiben.\nOperator Bedeutung Beispiel Entspricht += Addition und Zuweisung x += 5; x = x + 5; -= Subtraktion und Zuweisung x -= 3; x = x - 3; *= Multiplikation und Zuweisung x *= 2; x = x * 2; /= Division und Zuweisung x /= 4; x = x / 4; %= Modulo und Zuweisung x %= 3; x = x % 3; \u0026= Bitweises UND x \u0026= y; x = x \u0026 y; |= Bitweises ODER x |= y; x = x | y; ^= Bitweises XOR x ^= y; x = x ^ y; \u003c\u003c= Linksschieben x \u003c\u003c= 1; x = x \u003c\u003c 1; \u003e\u003e= Rechtsschieben x \u003e\u003e= 1; x = x \u003e\u003e 1; Post- und Prä-Inkrement Das Erhöhen oder Verringern eines Wertes ist häufig. Es gibt zwei Schreibweisen:\nPräfix: ++i oder --i → zuerst ändern, dann verwenden Postfix: i++ oder i-- → zuerst verwenden, dann ändern Postinkrement 1 2 int i = 5; int c = i++; // c = 5, afterwards: i = 6 Präinkrement 1 2 int i = 5; int d = ++i; // previously: i = 6, therefore d = 6 Postdekrement 1 2 int i = 5; int e = i--; // e = 5, afterwards: i = 4 Prädekrement 1 2 int i = 5; int f = --i; // previously: i = 4, therefore f = 4 Vergleichsoperatoren Das Ergebnis ist immer ein boolean (true oder false).\nSymbol Bedeutung Beispiel \u003e grösser als 5 \u003e 4 \u003c kleiner als 4 \u003c 5 \u003e= grösser gleich 3 \u003e= 3 \u003c= kleiner gleich 3 \u003c= 3 == gleich 2 == 2 != ungleich 2 != 4 Boolesche Operatoren Diese Operatoren arbeiten mit boolean-Werten (true/false).\nSymbol Operation Erklärung \u0026\u0026 logisches UND true nur wenn beide true sind. Lazy-Evaluation: 2. Ausdruck wird nur bei Bedarf geprüft || logisches ODER true wenn mindestens einer true ist. Lazy-Evaluation: 2. Ausdruck nur bei Bedarf geprüft ! logisches NICHT kehrt den Wert um: !true → false ^ exklusives ODER (XOR) true, wenn genau einer true ist \u0026 UND (nicht lazy) beide Ausdrücke werden immer ausgewertet | ODER (nicht lazy) beide Ausdrücke werden immer ausgewertet Was bedeutet Lazy-Evaluation?\nWenn zwei Ausdrücke zum Beispiel mit \u0026\u0026 verknüpft sind, wird der zweite Ausdruck nur ausgewertet, wenn der erste true zurückgibt.\nGibt der erste false zurück, ist das Gesamtergebnis ohnehin false – der zweite Ausdruck wird übersprungen.\nDas kann zu unerwartetem Verhalten führen, wenn der zweite Ausdruck nicht nur ein Ergebnis liefert, sondern auch Seiteneffekte hat (z. B. den Zustand eines Objekts verändert).\nDeshalb ist es wichtig, Ausdrücke möglichst ohne Seiteneffekte zu schreiben – ein Prinzip, das du später im Modul Clean Code unter dem Stichwort Single Responsibility kennenlernen wirst.\nMit || ist es das selbe, nur dass dort der zweite Ausdruck nur ausgewertet wird, wenn der erste Ausdruck false zurückgibt.\nBitweise Operatoren (Bitwise Operators) Bitweise Operatoren vergleichen nicht true oder false, sondern manipulieren einzelne Bits eines Zahlenwerts.\nSie funktionieren also nur mit Ganzzahlen (int, long, byte, etc.).\nSymbol Name Beschreibung \u0026 UND Bit ist 1, wenn beide Bits 1 sind | ODER Bit ist 1, wenn mindestens eines der Bits 1 ist ^ XOR (exklusives ODER) Bit ist 1, wenn genau eines der Bits 1 ist ~ NOT (Invertieren) Alle Bits werden umgekehrt (1 → 0, 0 → 1) \u003c\u003c Linksverschiebung Verschiebt alle Bits nach links (Multiplizieren mit 2) \u003e\u003e Rechtsverschiebung Verschiebt alle Bits nach rechts (Dividieren durch 2, vorzeichenbehaftet) \u003e\u003e\u003e Unsigned Shift Wie \u003e\u003e, aber füllt von links mit 0 (wichtig bei int → long) Beispiel: 1 2 3 4 5 6 7 8 9 10 11 12 int a = 0b1100; // binary: 1100 = 12 int b = 0b1010; // binary: 1010 = 10 int resultAnd = a \u0026 b; // 1000 = 8 int resultOr = a | b; // 1110 = 14 int resultXor = a ^ b; // 0110 = 6 int resultNot = ~a; // invert all bits → -13 (2's complement representation) System.out.println(\"a \u0026 b = \" + resultAnd); System.out.println(\"a | b = \" + resultOr); System.out.println(\"a ^ b = \" + resultXor); System.out.println(\"~a = \" + resultNot); Bitshift Beispiel: 1 2 3 4 5 6 int x = 4; // 0100 int left = x \u003c\u003c 1; // 1000 → 8 (shift left by 1) int right = x \u003e\u003e 1; // 0010 → 2 (shift right by 1) System.out.println(\"x \u003c\u003c 1 = \" + left); System.out.println(\"x \u003e\u003e 1 = \" + right); Bitweise Operationen sind nicht dasselbe wie boolesche Operatoren!\n\u0026 bei int ist bitweise UND, bei boolean ist es logisches UND (nicht lazy).\nDasselbe gilt für | und ^.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int x = makeSomethingAndReturnResultAsInt(); int y = makeSomethingOtherAndReturnResultAsInt(); // Error: cannot convert from int to boolean // Bitwise AND (\u0026) between two int values returns an int, not a boolean if(x \u0026 y) { ... } // → does not compile // You must use a boolean expression inside the if-statement // Correct approach using boolean expressions: boolean xIsOk = makeSomethingAndReturnResultAsInt() \u003e= 0; // -1 indicates error boolean yIsOk = makeSomethingOtherAndReturnResultAsInt() \u003e= 0; // -1 indicates error // Works: both sides are boolean, and '\u0026' performs logical AND (non-short-circuit) if(xIsOk \u0026 yIsOk) { // do something if both calls succeeded } Jetzt bist du dran. Löse bitte die folgenden !*Aufgaben in den Labs. ","categories":"","description":"Einführung in arithmetische, relationale und boolesche Operatoren in Java – mit vielen Beispielen und klaren Erklärungen.\n","excerpt":"Einführung in arithmetische, relationale und boolesche Operatoren in …","ref":"/docs/02_java/03_java-grundlagen/05_logic/","tags":"","title":"Mathematik \u0026 Logik"},{"body":"Ziele Ich kenne die Grundlagen von Maven. Ich kann Maven lokal konfigurieren. Ich kann im Artifactory Abhängigkeiten suchen und diese verwenden. Ich kenne die Grundlagen von Project Object Models (POM). Ich kenne die wichtigsten Maven Befehle und kann diese auf der Kommandozeile anwenden. Ich kann die Abhängigkeiten meiner Applikationen mit Maven verwalten. Ich kann Maven Plugins konfigurieren und damit meinen Maven-Build steuern. (Optional): Ich habe erste Erfahrungen gesammelt mit dem alternativen Build-Tool Gradle. Maven Allgemeine Informationen Apache Maven ist ein Build-Management Tool. Das heisst, Maven kann den Build eines Projekts von einer einzigen Datei aus steuern. Diese zentrale Datei ist das Project Object Model, kurz auch POM genannt. Ein Build ist der Prozess, bei dem der Quellcode eines Programms in eine ausführbare Form gebracht wird, häufig durch Kompilieren und Paketieren. Der Build eines Projekts kann dabei von einfacher Kompilierung bis zur Auslieferung einer Anwendung auf eine bestimmte Plattform reichen.\nDamit Maven funktionieren kann, benötigt ein Projekt die folgenden Dinge:\nEine Maven-Installation, entweder separat oder Built-In wie beispielsweise mit IntelliJ Eine Project Object Model Datei pro Projekt oder Modul (es handelt sich um eine XML-Datei) Ein zentrales Maven-Repository Ein lokales Maven-Repository Eine Konfigurationsdatei mit dem Namen settings.xml Installation Manuelle Installation Idealerweise wurde Apache Maven bereits mit IntelliJ installiert. Alternativ kannst du Maven auch hier herunterladen: https://maven.apache.org/download.cgi. Verwende die Binary anstelle der Source, und zwar am besten die Datei im Binary zip archive Format.\nKlicke dazu auf den folgenden Link, wie hier im Beispiel: Nachdem du die Datei heruntergeladen hast, kannst du den folgenden Ordner erstellen:\nC:\\Program Files\\Apache\\Maven\\.\nEntpacke die heruntergeladene Datei dort. Du kannst danach die Umgebungsvariablen auf dieses Verzeichnis setzen.\nIntelliJ IDEA Ist IntelliJ installiert, findet man in den allgemeinen Einstellungen auch die Einstellungen für Maven. Normalerweise sind diese Einstellungen bereits korrekt.\nDie wichtigsten Einstellungen sind:\nEinstellung Beschreibung Maven home directory Zeigt auf das Verzeichnis einer Maven-Installation. Das IntelliJ verfügt bereits über eine Maven-Installation, diese wird als “Bundled” bezeichnet. User settings file Die XML-Datei, welche bei der Installation angelegt wurde. Local repository Der Ablageort für das lokale Repository, dieser ist normalerweise unter C:\\Users\\\u003cPersonalnummer\u003e\\.m2.\\repository zu finden. Bei diesen Einstellungen muss überprüft werden, dass die Pfad-Angaben für die XML-Datei und das lokale Repository korrekt sind.\nUmgebungsvariablen setzen Damit Maven auch auf der Command-Line funktioniert, muss eine Umgebungsvariable gesetzt werden. Unter Windows muss also der Pfad zu deiner installierten Maven-Version hinzugefügt werden. Dadurch weiss Windows, wo die Binary für Maven zu finden ist, wenn du Maven aus dem Terminal ausführst. Die folgenden Schritte sind dazu notwendig:\nAnwendung “Systemumgebungsvariablen bearbeiten” aus der Systemsteuerung starten. Falls das nicht geht, musst du dir (temporär) lokale Admin-Rechte aktivieren.\nUnten rechts auf den Button “Umgebungsvariablen” klicken.\nIm unteren Teil “Benutzervariablen” die Variable “Path” suchen und anklicken.\nAuf den Button “Bearbeiten…” klicken.\nOben rechts auf den Button “Neu” klicken, es erscheint eine neue Zeile ganz unten.\nDen Pfad zu deinem installierten Maven einfügen. Hier kannst du das erstellte Verzeichnis verwenden. Der Pfad sollte auf das Verzeichnis bin zeigen, also zum Beispiel:\nmanuelle Installation: C:\\Program Files\\Apache\\Maven\\apache-maven-3.9.9\\bin IntelliJ installiert: C:\\Users\\u……\\AppData\\Local\\Programs\\IntelliJ IDEA Ultimate\\plugins\\maven\\lib\\maven3\\bin Alle offenen Windows-Fenster mit “OK” schliessen.\nUm die Installation zu überprüfen, führen den folgenden Befehl in deinem Terminal (du findest es unter Eingabeaufforderung oder cmd in der Windows Suche) aus:\nmvn -version\nFalls es korrekt installiert ist, wird dir Maven die Version liefern, also zum Beispiel:\nApache Maven 3.9.6 (bc0240f3c744dd6b6ec2920b3cd08dcc295161ae)\nDie Version muss nicht mit deiner übereinstimmen.\nJAVA_HOME Troubleshoot Es kann sein, dass du folgende Fehlermeldung siehst:\n1 2 The JAVA_HOME environment variable is not defined correctly, this environment variable is needed to run this program. Das bedeutet, dass die Java-Installation nicht gefunden werden kann. IntelliJ enthält zwar eine eigene Java-Installation, allerdings weiss Windows nicht, wo sich diese befindet. Aus diesem Grund musst du eine Umgebungsvariable setzen, die auf diese Installation zeigt. Dafür musst du zuerst herausfinden, wo sich die Installation befindet.\nUnter IntelliJ gehe zu folgendem Fenster:\n1 File \u003e Project Structure \u003e Platform Settings \u003e SDKs Kopiere den Pfad unter JDK home path.\nErstelle nun gleich wie zuvor eine neue Umgebungsvariable mit den folgenden Werten:\n1 JAVA_HOME:{JDK home path} Ersetze {JDK home path} mit deinem kopierten Wert. Öffne danach ein neues Terminal und versuche es erneut.\npom.xml Der Aufbau eines Project Object Models kann grob in folgende Abschnitte unterteilt werden, hier erklärt an einem umfangreichen Beispiel. Die einzelnen Teile werden gleich im Anschluss näher erläutert. Bitte beachte, dass dieses Project Object Model nicht alle Inhalte vollständig erklärt, sondern nur als erstes Beispiel dient.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 \u003c!-- (1) Header --\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003c!-- (2) Angaben zum Artefakt --\u003e \u003cgroupId\u003ech.sbb.interviewtool\u003c/groupId\u003e \u003cartifactId\u003einterviewtool-backend\u003c/artifactId\u003e \u003cversion\u003e0.0.1-SNAPSHOT\u003c/version\u003e \u003cpackaging\u003ejar\u003c/packaging\u003e \u003c!-- (3) Angaben zum Parent-Projekt --\u003e \u003cparent\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-parent\u003c/artifactId\u003e \u003cversion\u003e2.2.4.RELEASE\u003c/version\u003e \u003crelativePath/\u003e \u003c/parent\u003e \u003c!-- (4) Properties --\u003e \u003cproperties\u003e \u003cproject.build.sourceEncoding\u003eUTF-8\u003c/project.build.sourceEncoding\u003e \u003cjava.version\u003e1.21\u003c/java.version\u003e \u003cmaven.build.timestamp.format\u003eyyyy-MM-dd HH:mm\u003c/maven.build.timestamp.format\u003e \u003ctimestamp\u003e${maven.build.timestamp}\u003c/timestamp\u003e \u003c/properties\u003e \u003c!-- (5) Abhängigkeiten --\u003e \u003cdependencies\u003e \u003c!-- Lombok --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003cversion\u003e1.18.6\u003c/version\u003e \u003c/dependency\u003e \u003c!-- Unit- und Integrationstests --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter-engine\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c!-- (6) Build-Informationen --\u003e \u003cbuild\u003e \u003cplugins\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-maven-plugin\u003c/artifactId\u003e \u003c/plugin\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e \u003cartifactId\u003emaven-compiler-plugin\u003c/artifactId\u003e \u003cconfiguration\u003e \u003ccompilerVersion\u003e1.21\u003c/compilerVersion\u003e \u003csource\u003e1.21\u003c/source\u003e \u003ctarget\u003e1.21\u003c/target\u003e \u003c/configuration\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c/build\u003e \u003c!-- (7) Entwickler-Informationen --\u003e \u003cdevelopers\u003e \u003cdeveloper\u003e \u003cid\u003eU000000\u003c/id\u003e \u003cname\u003eVorname Name\u003c/name\u003e \u003cemail\u003evorname.name@sbb.ch\u003c/email\u003e \u003corganization\u003eSBB\u003c/organization\u003e \u003corganizationUrl\u003ehttps://www.sbb.ch\u003c/organizationUrl\u003e \u003croles\u003e \u003crole\u003eSoftware Architect\u003c/role\u003e \u003crole\u003eLead Developer\u003c/role\u003e \u003c/roles\u003e \u003c/developer\u003e \u003c/developers\u003e \u003c/project\u003e Abschnitt 1 Der Header einer Project Object Model Datei bleibt grundsätzlich so wie dargestellt. Die Angaben zum Schema sind dabei optional. Falls andere Schemas verwendet werden, so sind diese hier zu deklarieren.\nAbschnitt 2 Die Angaben zum Artefakt enthalten die folgenden Informationen:\nGruppen-ID: Die Gruppen-ID ist in Maven normalerweise als umgekehrte Domain-Name-Notation (Reverse Domain Name Notation) aufgebaut, ähnlich wie bei Java-Paketen. Diese Struktur dient dazu, Konflikte zwischen Artefakten von verschiedenen Organisationen zu vermeiden. Zum Beispiel wird die Gruppen-ID für ein Projekt der SBB oft in der Form ch.sbb beginnen, da sbb.ch die Domain der Schweizerischen Bundesbahnen ist. Beispiel: ch.sbb.interviewtool Artefakt-ID: Die Artefakt-ID ist der eindeutige Name eines Projekts oder einer Komponente, der zusammen mit der Gruppen-ID und der Version verwendet wird, um ein Artefakt im Repository eindeutig zu identifizieren. Beispiel: interviewtool-backend, mit der Gruppen-ID: ch.sbb.interviewtool:interviewtool-backend. Version: Die momentane Version des Projekts, diese wird später durch Releases verändert. Paketierung: Angabe, in welcher Form das Artefakt geliefert wird. Der Default ist Java Archive (JAR). Bei der Versionierung nutzt Maven die folgenden Standards:\nMajor-Version Minor-Version Incremental-Version Build-Number Qualifier Dazu ein paar Beispiele:\nTyp Beispiel Major-Version 1.2.1 Minor-Version 2.0 Incremental-Version 1.2-SNAPSHOT Patch 1.2.1 Build-Number 1.4.2-12 Qualifier 1.2-beta-2 Alle Versionen mit Qualifier sind dabei älter als die gleiche Version ohne Qualifier. Beispielsweise ist die Version 1.2-beta-2 älter als die Version 1.2. Gleiche Versionen mit unterschiedlichen Qualifiern werden durch den Vergleich dieser als String verglichen. So ist die Version 1.2-beta-2 neuer als die Version 1.2-alpha-6.\nDer SNAPSHOT-Qualifier wird verwendet, wenn eine Version noch nicht ausgeliefert wurde. So wird die Version 0.1.2-SNAPSHOT sehr wahrscheinlich als Version 0.1.2 ausgeliefert werden.\nAbschnitt 3 Falls das Projekt Bestandteil eines anderen Projektes ist, müssen hier die Artefakt-Angaben des sogenannten Parent-Projekts hinterlegt werden. Dies ist vor allem bei Spring-Boot Projekten wichtig.\nAbschnitt 4 Die Einstellungen in Maven sind beliebig wählbare Tags. So kann beispielsweise eine bestimmte Einstellung oder eine Version definiert werden.\nBeispiel:\n1 \u003cspecial.setting\u003eValue\u003c/special.setting\u003e Innerhalb der Project Object Model Datei kann dann mit\n1 ${special.setting} auf die Einstellung (Tag) und damit auf dessen Wert (Value) zugegriffen werden.\nAbschnitt 5 Abhängigkeiten zu Fremdbibliotheken. Diese sollten stets Gruppen-ID, Artefakt-ID und Version enthalten. Der Typ der Abhängigkeit gibt an, um welche Art von Bibliothek es sich handelt. Nicht alle Java-Bibliotheken werden als JAR ausgeliefert.\nEine Liste der möglichen Typen findest du hier: https://maven.apache.org/ref/3.6.3/maven-core/artifact-handlers.html.\nVielfach wird auch der Scope verwendet, der angibt, in welchem Umfang die Fremdbibliothek einbezogen wird. Mögliche Scopes sind unter anderem:\ncompile - Das ist der Default-Scope. Diese Bibliotheken sind in allen Klassenpfaden verfügbar (Classpath), werden also mitausgeliefert. provided - Gleich wie compile, ausser das die Bibliothek zur Laufzeit von einem Container (wie dem JDK) erwartet und bereitgestellt wird. runtime - Zeigt an, dass die Bibliothek zur Kompilierung nicht verwendet wird. Zur Laufzeit steht sie dann zur Verfügung. test - Die Bibliothek steht nur für Tests zur Verfügung und wird nur fürs Testing benötigt. system - Gleich wie provided, mit der Ausnahme, dass die Bibliothek explizit auf dem System zur Verfügung stehen muss. Das MVN Repository stellt eine Vielzahl von Fremdbibliotheken zur Verfügung. Maven versucht Abhängigkeiten über dieses Repository aufzulösen.\nBeispiel einer Abhängigkeit (junit-jupiter-engine) Die Dependency junit-jupiter-engine ist eine grundlegende Bibliothek für das Testen von Java-Anwendungen mit JUnit 5, einem weit verbreiteten Test-Framework für Java. Im Kapitel Testing wirst diese ausführlich genutzt.\nEin weiteres Beispiel für eine Abhängigkeit ist lombok. Diese Library wird im Kapitel Lombok ausführlich beschrieben.\nAbschnitt 6 Die Build-Informationen konfigurieren den Ablauf des Maven-Builds. Mit Plugins kann der Build selbst durch spezifische Erweiterungen beliebig angepasst werden. Es ist auch möglich, eigene Maven-Plugins zu entwickeln. Es stehen sehr viele Plugins für Maven zur Verfügung, eine Übersicht gibt es hier.\nAbschnitt 7 Die Entwickler-Informationen dienen dazu, an der Entwicklung beteiligte Personen zu identifizieren.\nMaven Mirror Ein Mirror in Maven ist eine alternative Quelle, von der Maven Artefakte (wie Abhängigkeiten, Plugins usw.) herunterladen kann. Mirrors werden verwendet, um die Verfügbarkeit und Geschwindigkeit des Downloads zu verbessern, insbesondere wenn das Standard-Repository (z. B. Maven Central) aus irgendeinem Grund nicht erreichbar ist oder wenn ein internes Repository bevorzugt wird.\nKonfiguration eines Mirrors Die Konfiguration eines Mirrors erfolgt in der settings.xml-Datei von Maven. Diese Datei befindet sich normalerweise im Verzeichnis ~/.m2 (bei Unix/Linux) oder %USERPROFILE%\\.m2 (bei Windows).\nHier ist ein Beispiel, wie ein Mirror in der settings.xml konfiguriert werden kann:\n1 2 3 4 5 6 7 8 9 10 \u003csettings\u003e \u003cmirrors\u003e \u003cmirror\u003e \u003cid\u003emy-internal-repo\u003c/id\u003e \u003cname\u003eMy Internal Repository\u003c/name\u003e \u003curl\u003ehttp://my.internal.repo/repository/maven-public/\u003c/url\u003e \u003cmirrorOf\u003e*\u003c/mirrorOf\u003e \u003c/mirror\u003e \u003c/mirrors\u003e \u003c/settings\u003e Repository und Deployment Artefakte, welche mit Maven gebildet werden, kommen zuerst in ein lokales Repository. Von dort können sie dann wieder verwendet werden (z.B. für Testing). Will man eine Version auch anderen Entwicklern zur Vefügung stellen, kann man das Projekt deployen. Dazu muss man aber zuerst ein Repository konfigurieren, damit Maven weiss, wohin die Artefakte sollen.\nDa das Deployment projektspezifisch ist, erfolgt die Konfiguration für das Repository im pom.xml:\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e ... \u003cdistributionManagement\u003e \u003crepository\u003e \u003cid\u003eremoteRepository\u003c/id\u003e \u003curl\u003efile:///C:/Development/Repository\u003c/url\u003e \u003c/repository\u003e \u003c/distributionManagement\u003e \u003c/project\u003e Im obigen Beispiel wurde ein lokales Repository konfiguriert. Die url kann auch auf einen Remote Server verweisen (Maven Central, JFrog Artifactery, Azure Artifacts, …).\nFalls der Zugriff auf ein Repository eine Berechtigung benötigt, wird diese im settings.xml abgelegt:\n1 2 3 4 5 6 7 8 9 10 11 12 \u003csettings xmlns=\"http://maven.apache.org/SETTINGS/1.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd\"\u003e \u003cservers\u003e \u003cserver\u003e \u003cid\u003eremoteRepository\u003c/id\u003e \u003cusername\u003eyour-username\u003c/username\u003e \u003cpassword\u003eyour-password\u003c/password\u003e \u003c/server\u003e \u003c/servers\u003e \u003c/settings\u003e Das speichern von Zugangsdaten in settings.xml stellt sicher, dass diese nicht in ein Code Repository gelangen und so in falsche Hände geraten können.\nCommands Maven lässt sich auf der Kommandozeile oder im IntelliJ-Terminal ausführen. Damit wir sehen, ob das wirklich klappt, kannst du das Terminal öffnen und den folgenden Befehl eingeben:\n1 mvn -version Das sollte nun in etwa so aussehen:\nMaven Lifecycle Bevor wir die einzelnen Befehle kurz anschauen, werfen wir einen Blick auf die einzelnen Phasen des Maven-Lebenszyklus.\nJeder in der Grafik genannte Befehl wird zusätzlich die vorangehenden Phasen ausführen. Die Ausführung des Befehls mvn package führt somit die Phasen validate, compile, test und package aus.\nhelp 1 mvn -help Das Ergebnis dürfte klar sein. Maven listet alle möglichen Befehle auf.\ndependency:tree 1 mvn dependency:tree Dieser Befehl listet alle Abhängigkeiten zu Fremdbibliotheken als Baum auf. Das ist grundsätzlich sehr praktisch, wenn man doppelte Abhängigkeiten erkennen oder vermeiden will.\nclean 1 mvn clean Dieser Befehl löscht alle vorherigen lokalen Maven-Build-Artefakte, indem er das Verzeichnis ’target’ entfernt.\ncompile 1 mvn compile Kompiliert den Sourcecode je nach Abhängigkeit von Plugins. Wenn also beispielsweise ein Maven-Compiler-Plugin verwendet wird, so wird dieses als Regelwerk für die Kompilierung herangezogen.\ntest 1 mvn test Führt alle Tests aus. In einem Java-Projekt sind dies beispielsweise alle Unit-Tests mit JUnit.\npackage 1 mvn package Führt einen lokalen Maven-Build aus, startet alle Tests und paketiert die Anwendung (normalerweise als JAR) in das Verzeichnis “target”.\nverify 1 mvn verify Prüft die Testergebnisse aller ausgeführten Integrationstests, normalerweise wird das Maven-Failsafe-Plugin für diesen Maven-Befehl vorausgesetzt.\ninstall 1 mvn install Lädt das Artefakt in dein lokales Maven-Repository (dies findest du typischerweise unter %UserProfile%.m2).\nskip tests 1 mvn install -DskipTests Mit dem Parameter -DskipTests kannst du die Ausführung der Tests während der Installation überspringen, um Zeit zu sparen. Der Parameter kann auch bei anderen Aktionen wie compile, package usw. verwendet werden.\ndeploy 1 mvn deploy Lädt das Artefakt in das Remote-Repository (Artifactory) hoch.\nDie Maven-Befehle lassen sich kombinieren. Sehr nützlich ist zum Beispiel:\n1 mvn clean install Selbstverständlich gibt es sehr viele zusätzliche Optionen für die einzelnen Maven-Befehle.\nJetzt bist du dran. Löse bitte die Aufgaben in den Labs.\n(Optional) Gradle: Als Alternative zu Maven wird oft auch das Build-System Gradle eingesetzt. Unter Building Java Applications Sample kannst du dir einen ersten Eindruck verschaffen.\n","categories":"","description":"Modul #S2\n","excerpt":"Modul #S2\n","ref":"/docs/02_java/05_maven/","tags":"","title":"Maven"},{"body":"Ziele Ich kenne die Grundlagen von Maven. Ich kann Maven lokal konfigurieren. Ich kann im Artifactory Abhängigkeiten suchen und diese verwenden. Ich kenne die Grundlagen von Project Object Models (POM). Ich kenne die wichtigsten Maven Befehle und kann diese auf der Kommandozeile anwenden. Ich kann die Abhängigkeiten meiner Applikationen mit Maven verwalten. Ich kann Maven Plugins konfigurieren und damit meinen Maven-Build steuern. (Optional): Ich habe erste Erfahrungen gesammelt mit dem alternativen Build-Tool Gradle. Maven Allgemeine Informationen Apache Maven ist ein Build-Management Tool. Das heisst, Maven kann den Build eines Projekts von einer einzigen Datei aus steuern. Diese zentrale Datei ist das Project Object Model, kurz auch POM genannt. Ein Build ist der Prozess, bei dem der Quellcode eines Programms in eine ausführbare Form gebracht wird, häufig durch Kompilieren und Paketieren. Der Build eines Projekts kann dabei von einfacher Kompilierung bis zur Auslieferung einer Anwendung auf eine bestimmte Plattform reichen.\nDamit Maven funktionieren kann, benötigt ein Projekt die folgenden Dinge:\nEine Maven-Installation, entweder separat oder Built-In wie beispielsweise mit IntelliJ Eine Project Object Model Datei pro Projekt oder Modul (es handelt sich um eine XML-Datei) Ein zentrales Maven-Repository Ein lokales Maven-Repository Eine Konfigurationsdatei mit dem Namen settings.xml Installation Manuelle Installation Idealerweise wurde Apache Maven bereits mit IntelliJ installiert. Alternativ kannst du Maven auch hier herunterladen: https://maven.apache.org/download.cgi. Verwende die Binary anstelle der Source, und zwar am besten die Datei im Binary zip archive Format.\nKlicke dazu auf den folgenden Link, wie hier im Beispiel: Nachdem du die Datei heruntergeladen hast, kannst du den folgenden Ordner erstellen:\nC:\\Program Files\\Apache\\Maven\\.\nEntpacke die heruntergeladene Datei dort. Du kannst danach die Umgebungsvariablen auf dieses Verzeichnis setzen.\nIntelliJ IDEA Ist IntelliJ installiert, findet man in den allgemeinen Einstellungen auch die Einstellungen für Maven. Normalerweise sind diese Einstellungen bereits korrekt.\nDie wichtigsten Einstellungen sind:\nEinstellung Beschreibung Maven home directory Zeigt auf das Verzeichnis einer Maven-Installation. Das IntelliJ verfügt bereits über eine Maven-Installation, diese wird als “Bundled” bezeichnet. User settings file Die XML-Datei, welche bei der Installation angelegt wurde. Local repository Der Ablageort für das lokale Repository, dieser ist normalerweise unter C:\\Users\\\u003cPersonalnummer\u003e\\.m2.\\repository zu finden. Bei diesen Einstellungen muss überprüft werden, dass die Pfad-Angaben für die XML-Datei und das lokale Repository korrekt sind.\nUmgebungsvariablen setzen Damit Maven auch auf der Command-Line funktioniert, muss eine Umgebungsvariable gesetzt werden. Unter Windows muss also der Pfad zu deiner installierten Maven-Version hinzugefügt werden. Dadurch weiss Windows, wo die Binary für Maven zu finden ist, wenn du Maven aus dem Terminal ausführst. Die folgenden Schritte sind dazu notwendig:\nAnwendung “Systemumgebungsvariablen bearbeiten” aus der Systemsteuerung starten. Falls das nicht geht, musst du dir (temporär) lokale Admin-Rechte aktivieren.\nUnten rechts auf den Button “Umgebungsvariablen” klicken.\nIm unteren Teil “Benutzervariablen” die Variable “Path” suchen und anklicken.\nAuf den Button “Bearbeiten…” klicken.\nOben rechts auf den Button “Neu” klicken, es erscheint eine neue Zeile ganz unten.\nDen Pfad zu deinem installierten Maven einfügen. Hier kannst du das erstellte Verzeichnis verwenden. Der Pfad sollte auf das Verzeichnis bin zeigen, also zum Beispiel:\nmanuelle Installation: C:\\Program Files\\Apache\\Maven\\apache-maven-3.9.9\\bin IntelliJ installiert: C:\\Users\\u……\\AppData\\Local\\Programs\\IntelliJ IDEA Ultimate\\plugins\\maven\\lib\\maven3\\bin Alle offenen Windows-Fenster mit “OK” schliessen.\nUm die Installation zu überprüfen, führen den folgenden Befehl in deinem Terminal (du findest es unter Eingabeaufforderung oder cmd in der Windows Suche) aus:\nmvn -version\nFalls es korrekt installiert ist, wird dir Maven die Version liefern, also zum Beispiel:\nApache Maven 3.9.6 (bc0240f3c744dd6b6ec2920b3cd08dcc295161ae)\nDie Version muss nicht mit deiner übereinstimmen.\nJAVA_HOME Troubleshoot Es kann sein, dass du folgende Fehlermeldung siehst:\n1 2 The JAVA_HOME environment variable is not defined correctly, this environment variable is needed to run this program. Das bedeutet, dass die Java-Installation nicht gefunden werden kann. IntelliJ enthält zwar eine eigene Java-Installation, allerdings weiss Windows nicht, wo sich diese befindet. Aus diesem Grund musst du eine Umgebungsvariable setzen, die auf diese Installation zeigt. Dafür musst du zuerst herausfinden, wo sich die Installation befindet.\nUnter IntelliJ gehe zu folgendem Fenster:\n1 File \u003e Project Structure \u003e Platform Settings \u003e SDKs Kopiere den Pfad unter JDK home path.\nErstelle nun gleich wie zuvor eine neue Umgebungsvariable mit den folgenden Werten:\n1 JAVA_HOME:{JDK home path} Ersetze {JDK home path} mit deinem kopierten Wert. Öffne danach ein neues Terminal und versuche es erneut.\npom.xml Der Aufbau eines Project Object Models kann grob in folgende Abschnitte unterteilt werden, hier erklärt an einem umfangreichen Beispiel. Die einzelnen Teile werden gleich im Anschluss näher erläutert. Bitte beachte, dass dieses Project Object Model nicht alle Inhalte vollständig erklärt, sondern nur als erstes Beispiel dient.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 \u003c!-- (1) Header --\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003c!-- (2) Angaben zum Artefakt --\u003e \u003cgroupId\u003ech.sbb.interviewtool\u003c/groupId\u003e \u003cartifactId\u003einterviewtool-backend\u003c/artifactId\u003e \u003cversion\u003e0.0.1-SNAPSHOT\u003c/version\u003e \u003cpackaging\u003ejar\u003c/packaging\u003e \u003c!-- (3) Angaben zum Parent-Projekt --\u003e \u003cparent\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-parent\u003c/artifactId\u003e \u003cversion\u003e2.2.4.RELEASE\u003c/version\u003e \u003crelativePath/\u003e \u003c/parent\u003e \u003c!-- (4) Properties --\u003e \u003cproperties\u003e \u003cproject.build.sourceEncoding\u003eUTF-8\u003c/project.build.sourceEncoding\u003e \u003cjava.version\u003e1.21\u003c/java.version\u003e \u003cmaven.build.timestamp.format\u003eyyyy-MM-dd HH:mm\u003c/maven.build.timestamp.format\u003e \u003ctimestamp\u003e${maven.build.timestamp}\u003c/timestamp\u003e \u003c/properties\u003e \u003c!-- (5) Abhängigkeiten --\u003e \u003cdependencies\u003e \u003c!-- Lombok --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003cversion\u003e1.18.6\u003c/version\u003e \u003c/dependency\u003e \u003c!-- Unit- und Integrationstests --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter-engine\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c!-- (6) Build-Informationen --\u003e \u003cbuild\u003e \u003cplugins\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-maven-plugin\u003c/artifactId\u003e \u003c/plugin\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e \u003cartifactId\u003emaven-compiler-plugin\u003c/artifactId\u003e \u003cconfiguration\u003e \u003ccompilerVersion\u003e1.21\u003c/compilerVersion\u003e \u003csource\u003e1.21\u003c/source\u003e \u003ctarget\u003e1.21\u003c/target\u003e \u003c/configuration\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c/build\u003e \u003c!-- (7) Entwickler-Informationen --\u003e \u003cdevelopers\u003e \u003cdeveloper\u003e \u003cid\u003eU000000\u003c/id\u003e \u003cname\u003eVorname Name\u003c/name\u003e \u003cemail\u003evorname.name@sbb.ch\u003c/email\u003e \u003corganization\u003eSBB\u003c/organization\u003e \u003corganizationUrl\u003ehttps://www.sbb.ch\u003c/organizationUrl\u003e \u003croles\u003e \u003crole\u003eSoftware Architect\u003c/role\u003e \u003crole\u003eLead Developer\u003c/role\u003e \u003c/roles\u003e \u003c/developer\u003e \u003c/developers\u003e \u003c/project\u003e Abschnitt 1 Der Header einer Project Object Model Datei bleibt grundsätzlich so wie dargestellt. Die Angaben zum Schema sind dabei optional. Falls andere Schemas verwendet werden, so sind diese hier zu deklarieren.\nAbschnitt 2 Die Angaben zum Artefakt enthalten die folgenden Informationen:\nGruppen-ID: Die Gruppen-ID ist in Maven normalerweise als umgekehrte Domain-Name-Notation (Reverse Domain Name Notation) aufgebaut, ähnlich wie bei Java-Paketen. Diese Struktur dient dazu, Konflikte zwischen Artefakten von verschiedenen Organisationen zu vermeiden. Zum Beispiel wird die Gruppen-ID für ein Projekt der SBB oft in der Form ch.sbb beginnen, da sbb.ch die Domain der Schweizerischen Bundesbahnen ist. Beispiel: ch.sbb.interviewtool Artefakt-ID: Die Artefakt-ID ist der eindeutige Name eines Projekts oder einer Komponente, der zusammen mit der Gruppen-ID und der Version verwendet wird, um ein Artefakt im Repository eindeutig zu identifizieren. Beispiel: interviewtool-backend, mit der Gruppen-ID: ch.sbb.interviewtool:interviewtool-backend. Version: Die momentane Version des Projekts, diese wird später durch Releases verändert. Paketierung: Angabe, in welcher Form das Artefakt geliefert wird. Der Default ist Java Archive (JAR). Bei der Versionierung nutzt Maven die folgenden Standards:\nMajor-Version Minor-Version Incremental-Version Build-Number Qualifier Dazu ein paar Beispiele:\nTyp Beispiel Major-Version 1.2.1 Minor-Version 2.0 Incremental-Version 1.2-SNAPSHOT Patch 1.2.1 Build-Number 1.4.2-12 Qualifier 1.2-beta-2 Alle Versionen mit Qualifier sind dabei älter als die gleiche Version ohne Qualifier. Beispielsweise ist die Version 1.2-beta-2 älter als die Version 1.2. Gleiche Versionen mit unterschiedlichen Qualifiern werden durch den Vergleich dieser als String verglichen. So ist die Version 1.2-beta-2 neuer als die Version 1.2-alpha-6.\nDer SNAPSHOT-Qualifier wird verwendet, wenn eine Version noch nicht ausgeliefert wurde. So wird die Version 0.1.2-SNAPSHOT sehr wahrscheinlich als Version 0.1.2 ausgeliefert werden.\nAbschnitt 3 Falls das Projekt Bestandteil eines anderen Projektes ist, müssen hier die Artefakt-Angaben des sogenannten Parent-Projekts hinterlegt werden. Dies ist vor allem bei Spring-Boot Projekten wichtig.\nAbschnitt 4 Die Einstellungen in Maven sind beliebig wählbare Tags. So kann beispielsweise eine bestimmte Einstellung oder eine Version definiert werden.\nBeispiel:\n1 \u003cspecial.setting\u003eValue\u003c/special.setting\u003e Innerhalb der Project Object Model Datei kann dann mit\n1 ${special.setting} auf die Einstellung (Tag) und damit auf dessen Wert (Value) zugegriffen werden.\nAbschnitt 5 Abhängigkeiten zu Fremdbibliotheken. Diese sollten stets Gruppen-ID, Artefakt-ID und Version enthalten. Der Typ der Abhängigkeit gibt an, um welche Art von Bibliothek es sich handelt. Nicht alle Java-Bibliotheken werden als JAR ausgeliefert.\nEine Liste der möglichen Typen findest du hier: https://maven.apache.org/ref/3.6.3/maven-core/artifact-handlers.html.\nVielfach wird auch der Scope verwendet, der angibt, in welchem Umfang die Fremdbibliothek einbezogen wird. Mögliche Scopes sind unter anderem:\ncompile - Das ist der Default-Scope. Diese Bibliotheken sind in allen Klassenpfaden verfügbar (Classpath), werden also mitausgeliefert. provided - Gleich wie compile, ausser das die Bibliothek zur Laufzeit von einem Container (wie dem JDK) erwartet und bereitgestellt wird. runtime - Zeigt an, dass die Bibliothek zur Kompilierung nicht verwendet wird. Zur Laufzeit steht sie dann zur Verfügung. test - Die Bibliothek steht nur für Tests zur Verfügung und wird nur fürs Testing benötigt. system - Gleich wie provided, mit der Ausnahme, dass die Bibliothek explizit auf dem System zur Verfügung stehen muss. Das MVN Repository stellt eine Vielzahl von Fremdbibliotheken zur Verfügung. Maven versucht Abhängigkeiten über dieses Repository aufzulösen.\nBeispiel einer Abhängigkeit (junit-jupiter-engine) Die Dependency junit-jupiter-engine ist eine grundlegende Bibliothek für das Testen von Java-Anwendungen mit JUnit 5, einem weit verbreiteten Test-Framework für Java. Im Kapitel Testing wirst diese ausführlich genutzt.\nEin weiteres Beispiel für eine Abhängigkeit ist lombok. Diese Library wird im Kapitel Lombok ausführlich beschrieben.\nAbschnitt 6 Die Build-Informationen konfigurieren den Ablauf des Maven-Builds. Mit Plugins kann der Build selbst durch spezifische Erweiterungen beliebig angepasst werden. Es ist auch möglich, eigene Maven-Plugins zu entwickeln. Es stehen sehr viele Plugins für Maven zur Verfügung, eine Übersicht gibt es hier.\nAbschnitt 7 Die Entwickler-Informationen dienen dazu, an der Entwicklung beteiligte Personen zu identifizieren.\nMaven Mirror Ein Mirror in Maven ist eine alternative Quelle, von der Maven Artefakte (wie Abhängigkeiten, Plugins usw.) herunterladen kann. Mirrors werden verwendet, um die Verfügbarkeit und Geschwindigkeit des Downloads zu verbessern, insbesondere wenn das Standard-Repository (z. B. Maven Central) aus irgendeinem Grund nicht erreichbar ist oder wenn ein internes Repository bevorzugt wird.\nKonfiguration eines Mirrors Die Konfiguration eines Mirrors erfolgt in der settings.xml-Datei von Maven. Diese Datei befindet sich normalerweise im Verzeichnis ~/.m2 (bei Unix/Linux) oder %USERPROFILE%\\.m2 (bei Windows).\nHier ist ein Beispiel, wie ein Mirror in der settings.xml konfiguriert werden kann:\n1 2 3 4 5 6 7 8 9 10 \u003csettings\u003e \u003cmirrors\u003e \u003cmirror\u003e \u003cid\u003emy-internal-repo\u003c/id\u003e \u003cname\u003eMy Internal Repository\u003c/name\u003e \u003curl\u003ehttp://my.internal.repo/repository/maven-public/\u003c/url\u003e \u003cmirrorOf\u003e*\u003c/mirrorOf\u003e \u003c/mirror\u003e \u003c/mirrors\u003e \u003c/settings\u003e Repository und Deployment Artefakte, welche mit Maven gebildet werden, kommen zuerst in ein lokales Repository. Von dort können sie dann wieder verwendet werden (z.B. für Testing). Will man eine Version auch anderen Entwicklern zur Vefügung stellen, kann man das Projekt deployen. Dazu muss man aber zuerst ein Repository konfigurieren, damit Maven weiss, wohin die Artefakte sollen.\nDa das Deployment projektspezifisch ist, erfolgt die Konfiguration für das Repository im pom.xml:\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e ... \u003cdistributionManagement\u003e \u003crepository\u003e \u003cid\u003eremoteRepository\u003c/id\u003e \u003curl\u003efile:///C:/Development/Repository\u003c/url\u003e \u003c/repository\u003e \u003c/distributionManagement\u003e \u003c/project\u003e Im obigen Beispiel wurde ein lokales Repository konfiguriert. Die url kann auch auf einen Remote Server verweisen (Maven Central, JFrog Artifactery, Azure Artifacts, …).\nFalls der Zugriff auf ein Repository eine Berechtigung benötigt, wird diese im settings.xml abgelegt:\n1 2 3 4 5 6 7 8 9 10 11 12 \u003csettings xmlns=\"http://maven.apache.org/SETTINGS/1.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd\"\u003e \u003cservers\u003e \u003cserver\u003e \u003cid\u003eremoteRepository\u003c/id\u003e \u003cusername\u003eyour-username\u003c/username\u003e \u003cpassword\u003eyour-password\u003c/password\u003e \u003c/server\u003e \u003c/servers\u003e \u003c/settings\u003e Das speichern von Zugangsdaten in settings.xml stellt sicher, dass diese nicht in ein Code Repository gelangen und so in falsche Hände geraten können.\nCommands Maven lässt sich auf der Kommandozeile oder im IntelliJ-Terminal ausführen. Damit wir sehen, ob das wirklich klappt, kannst du das Terminal öffnen und den folgenden Befehl eingeben:\n1 mvn -version Das sollte nun in etwa so aussehen:\nMaven Lifecycle Bevor wir die einzelnen Befehle kurz anschauen, werfen wir einen Blick auf die einzelnen Phasen des Maven-Lebenszyklus.\nJeder in der Grafik genannte Befehl wird zusätzlich die vorangehenden Phasen ausführen. Die Ausführung des Befehls mvn package führt somit die Phasen validate, compile, test und package aus.\nhelp 1 mvn -help Das Ergebnis dürfte klar sein. Maven listet alle möglichen Befehle auf.\ndependency:tree 1 mvn dependency:tree Dieser Befehl listet alle Abhängigkeiten zu Fremdbibliotheken als Baum auf. Das ist grundsätzlich sehr praktisch, wenn man doppelte Abhängigkeiten erkennen oder vermeiden will.\nclean 1 mvn clean Dieser Befehl löscht alle vorherigen lokalen Maven-Build-Artefakte, indem er das Verzeichnis ’target’ entfernt.\ncompile 1 mvn compile Kompiliert den Sourcecode je nach Abhängigkeit von Plugins. Wenn also beispielsweise ein Maven-Compiler-Plugin verwendet wird, so wird dieses als Regelwerk für die Kompilierung herangezogen.\ntest 1 mvn test Führt alle Tests aus. In einem Java-Projekt sind dies beispielsweise alle Unit-Tests mit JUnit.\npackage 1 mvn package Führt einen lokalen Maven-Build aus, startet alle Tests und paketiert die Anwendung (normalerweise als JAR) in das Verzeichnis “target”.\nverify 1 mvn verify Prüft die Testergebnisse aller ausgeführten Integrationstests, normalerweise wird das Maven-Failsafe-Plugin für diesen Maven-Befehl vorausgesetzt.\ninstall 1 mvn install Lädt das Artefakt in dein lokales Maven-Repository (dies findest du typischerweise unter %UserProfile%.m2).\nskip tests 1 mvn install -DskipTests Mit dem Parameter -DskipTests kannst du die Ausführung der Tests während der Installation überspringen, um Zeit zu sparen. Der Parameter kann auch bei anderen Aktionen wie compile, package usw. verwendet werden.\ndeploy 1 mvn deploy Lädt das Artefakt in das Remote-Repository (Artifactory) hoch.\nDie Maven-Befehle lassen sich kombinieren. Sehr nützlich ist zum Beispiel:\n1 mvn clean install Selbstverständlich gibt es sehr viele zusätzliche Optionen für die einzelnen Maven-Befehle.\nJetzt bist du dran. Löse bitte die Aufgaben in den Labs.\n(Optional) Gradle: Als Alternative zu Maven wird oft auch das Build-System Gradle eingesetzt. Unter Building Java Applications Sample kannst du dir einen ersten Eindruck verschaffen.\n","categories":"","description":"Modul #S2\n","excerpt":"Modul #S2\n","ref":"/de/docs/02_java/05_maven/","tags":"","title":"Maven"},{"body":"Aufgabe 1 (Optional) Wir implementieren eine einfache Job-Verarbeitung. Zwei InputWorker erstellen neue Job’s, welche parallel von einem OutputWorker abgearbeitet werden.\nJeder InputWorker erstellt eine definierte Anzahl Jobs und stoppt anschliessend. Die Anzahl könnt ihr in der Start-Klasse anpassen: Start.INPUTWORKER_NUMBER_OF_JOBS.\nNach jedem Arbeitsschritt (Job erstellen oder verarbeiten) machen die Workers eine kleine Pause. Ihr könnt die maximale zufällige Dauer über die statischen Variablen Start.INPUTWORKER_MAX_RELAX_TIME_MS und Start.OUTPUTWORKER_MAX_RELAX_TIME_MS steuern. Auch die maximal zufällige Dauer zum Abarbeiten eines Jobs kann definiert werden: Start.OUTPUTWORKER_MAX_PROCESS_TIME_MS.\nDer OutputWorker stoppt, sobald er während einer Anzahl Durchgänge (Start.OUTPUTWORKER_STOP_AFTER_EMPTY_CYCLES) keine Jobs zum Verarbeiten erhält.\nDie Worker sind mit dem ProcessingInterface entkoppelt, welches das Hinzufügen und Abholen der Jobs zur Verfügung stellt:\nInferface ProcessingInterface 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package ch.itninjas.labs.j7.queue; public interface ProcessingInterface { /** * Add a job to the system. * @return true if the job is added. */ public boolean addJob(Job job); /** * Get the next job for processing. */ public Job getNextJob(); /** * Put the unprocessed job back to the system. */ public void getJobBack(Job job); /** * Get the number of jobs in the system. */ public int getJobs(); /** * Has jobs in the system for processing? */ public boolean hasJobs(); } In der Konsole seht ihr die Arbeit der Workers:\nMögliche Konsole-Ausgabe 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 [InputWorker-1] stared successfully [InputWorker-2] stared successfully -\u003e [InputWorker-1] add job: Job{id=1, message='[InputWorker-1]: (14:52:41) It is a very hard job!', jobState=NEW} -\u003e [InputWorker-2] add job: Job{id=2, message='[InputWorker-2]: (14:52:41) It is a very hard job!', jobState=NEW} -\u003e [InputWorker-2] add job: Job{id=3, message='[InputWorker-2]: (14:52:43) It is a very hard job!', jobState=NEW} -\u003e [InputWorker-1] add job: Job{id=4, message='[InputWorker-1]: (14:52:43) It is a very hard job!', jobState=NEW} [OutputWorker-1] stared successfully \u003c- [OutputWorker-1] process job: Job{id=1, message='It is a really hard job!', jobState=IN_PROGRESS} == [OutputWorker-1] finish job: Job{id=1, message='It job is finish!', jobState=FINISH} -\u003e [InputWorker-2] add job: Job{id=5, message='[InputWorker-2]: (14:52:43) It is a very hard job!', jobState=NEW} \u003c- [OutputWorker-1] process job: Job{id=2, message='It is a really hard job!', jobState=IN_PROGRESS} -\u003e [InputWorker-1] add job: Job{id=6, message='[InputWorker-1]: (14:52:44) It is a very hard job!', jobState=NEW} == [OutputWorker-1] finish job: Job{id=2, message='It job is finish!', jobState=FINISH} \u003c- [OutputWorker-1] process job: Job{id=3, message='It is a really hard job!', jobState=IN_PROGRESS} -\u003e [InputWorker-1] add job: Job{id=7, message='[InputWorker-1]: (14:52:44) It is a very hard job!', jobState=NEW} == [OutputWorker-1] finish job: Job{id=3, message='It job is finish!', jobState=FINISH} -\u003e [InputWorker-2] add job: Job{id=8, message='[InputWorker-2]: (14:52:45) It is a very hard job!', jobState=NEW} \u003c- [OutputWorker-1] process job: Job{id=4, message='It is a really hard job!', jobState=IN_PROGRESS} == [OutputWorker-1] finish job: Job{id=4, message='It job is finish!', jobState=FINISH} \u003c- [OutputWorker-1] process job: Job{id=5, message='It is a really hard job!', jobState=IN_PROGRESS} == [OutputWorker-1] finish job: Job{id=5, message='It job is finish!', jobState=FINISH} -\u003e [InputWorker-1] add job: Job{id=9, message='[InputWorker-1]: (14:52:46) It is a very hard job!', jobState=NEW} \u003c- [OutputWorker-1] process job: Job{id=6, message='It is a really hard job!', jobState=IN_PROGRESS} -\u003e [InputWorker-2] add job: Job{id=10, message='[InputWorker-2]: (14:52:47) It is a very hard job!', jobState=NEW} == [OutputWorker-1] finish job: Job{id=6, message='It job is finish!', jobState=FINISH} \u003c- [OutputWorker-1] process job: Job{id=7, message='It is a really hard job!', jobState=IN_PROGRESS} == [OutputWorker-1] finish job: Job{id=7, message='It job is finish!', jobState=FINISH} \u003c- [OutputWorker-1] process job: Job{id=8, message='It is a really hard job!', jobState=IN_PROGRESS} == [OutputWorker-1] finish job: Job{id=8, message='It job is finish!', jobState=FINISH} \u003c- [OutputWorker-1] process job: Job{id=9, message='It is a really hard job!', jobState=IN_PROGRESS} == [OutputWorker-1] finish job: Job{id=9, message='It job is finish!', jobState=FINISH} \u003c- [OutputWorker-1] process job: Job{id=10, message='It is a really hard job!', jobState=IN_PROGRESS} == [OutputWorker-1] finish job: Job{id=10, message='It job is finish!', jobState=FINISH} ?? [OutputWorker-1] Nothing to do, I stop. Mit der Start-Klasse wird das gesamte System gestartet. Leider fehlt ein zentraler Teil des Systems: Ihr müsst das Interface ProcessingInterface implementieren.\nIhr findet den Programmcode im work Repo:\nhttps://github.com/it-ninjas/work/tree/main/labs/src/main/java/ch/itninjas/labs/j7/queue/lab1\nAufgabe 1.1 (Optional) Implementiert das ProcessingInterface mit einer Queue, damit die Jobs im FIFO-Prinzip (First-In-First-Out) verarbeitet werden. Kontrolliert die Konsole-Ausgabe: Ob alle Jobs verarbeitet wurden. Ob die Jobs in der gewünschten Reihenfolge verarbeitet wurden. Verändert die Pausen und Verarbeitungszeit der Worker und schaut euch der Einfluss in der Konsole an. Aufgabe 1.2 (Optional) Implementiert das ProcessingInterface mit einer Queue, damit die Jobs im LIFO-Prinzip (Last-In-First-Out) verarbeitet werden. Kontrolliert die Konsole-Ausgabe: Ob alle Jobs verarbeitet wurden. Ob die Jobs in der gewünschten Reihenfolge (Last-In-First-Out) verarbeitet wurden. Verändert die Pausen und Verarbeitungszeit der Worker und schaut euch der Einfluss in der Konsole an. Aufgabe 2 (Optional) Erweitert den OutputWorker so, dass er vor der Verarbeitung eines Jobs die Anzahl offener Jobs anzeigt.\nAufgabe 3 (Optional) Erweitert den OutputWorker so, dass er zufällig einzelne Jobs nicht erfolgreich bearbeiten kann und diese mit der Methode ProcessingInterface.getJobBack(Job job) zurück in die Queue stellt.\nAufgabe 4 (Optional) Erstellt ein JUnit-Test (JUnit Version 5), welcher die Schnittstelle ProcessingInterface der Klasse Processing ausführlich testet.\n","categories":"","description":"Aufgaben zu [Java Collections - Queue + Deque](../../../docs/02_java/10_java-collections//06_queue/)\n","excerpt":"Aufgaben zu [Java Collections - Queue + …","ref":"/labs/02_java/10_java-collections/05_queue/","tags":"","title":"Queue + Deque - Aufgaben"},{"body":"Aufgabe 1 (Optional) Wir implementieren eine einfache Job-Verarbeitung. Zwei InputWorker erstellen neue Job’s, welche parallel von einem OutputWorker abgearbeitet werden.\nJeder InputWorker erstellt eine definierte Anzahl Jobs und stoppt anschliessend. Die Anzahl könnt ihr in der Start-Klasse anpassen: Start.INPUTWORKER_NUMBER_OF_JOBS.\nNach jedem Arbeitsschritt (Job erstellen oder verarbeiten) machen die Workers eine kleine Pause. Ihr könnt die maximale zufällige Dauer über die statischen Variablen Start.INPUTWORKER_MAX_RELAX_TIME_MS und Start.OUTPUTWORKER_MAX_RELAX_TIME_MS steuern. Auch die maximal zufällige Dauer zum Abarbeiten eines Jobs kann definiert werden: Start.OUTPUTWORKER_MAX_PROCESS_TIME_MS.\nDer OutputWorker stoppt, sobald er während einer Anzahl Durchgänge (Start.OUTPUTWORKER_STOP_AFTER_EMPTY_CYCLES) keine Jobs zum Verarbeiten erhält.\nDie Worker sind mit dem ProcessingInterface entkoppelt, welches das Hinzufügen und Abholen der Jobs zur Verfügung stellt:\nInferface ProcessingInterface 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package ch.itninjas.labs.j7.queue; public interface ProcessingInterface { /** * Add a job to the system. * @return true if the job is added. */ public boolean addJob(Job job); /** * Get the next job for processing. */ public Job getNextJob(); /** * Put the unprocessed job back to the system. */ public void getJobBack(Job job); /** * Get the number of jobs in the system. */ public int getJobs(); /** * Has jobs in the system for processing? */ public boolean hasJobs(); } In der Konsole seht ihr die Arbeit der Workers:\nMögliche Konsole-Ausgabe 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 [InputWorker-1] stared successfully [InputWorker-2] stared successfully -\u003e [InputWorker-1] add job: Job{id=1, message='[InputWorker-1]: (14:52:41) It is a very hard job!', jobState=NEW} -\u003e [InputWorker-2] add job: Job{id=2, message='[InputWorker-2]: (14:52:41) It is a very hard job!', jobState=NEW} -\u003e [InputWorker-2] add job: Job{id=3, message='[InputWorker-2]: (14:52:43) It is a very hard job!', jobState=NEW} -\u003e [InputWorker-1] add job: Job{id=4, message='[InputWorker-1]: (14:52:43) It is a very hard job!', jobState=NEW} [OutputWorker-1] stared successfully \u003c- [OutputWorker-1] process job: Job{id=1, message='It is a really hard job!', jobState=IN_PROGRESS} == [OutputWorker-1] finish job: Job{id=1, message='It job is finish!', jobState=FINISH} -\u003e [InputWorker-2] add job: Job{id=5, message='[InputWorker-2]: (14:52:43) It is a very hard job!', jobState=NEW} \u003c- [OutputWorker-1] process job: Job{id=2, message='It is a really hard job!', jobState=IN_PROGRESS} -\u003e [InputWorker-1] add job: Job{id=6, message='[InputWorker-1]: (14:52:44) It is a very hard job!', jobState=NEW} == [OutputWorker-1] finish job: Job{id=2, message='It job is finish!', jobState=FINISH} \u003c- [OutputWorker-1] process job: Job{id=3, message='It is a really hard job!', jobState=IN_PROGRESS} -\u003e [InputWorker-1] add job: Job{id=7, message='[InputWorker-1]: (14:52:44) It is a very hard job!', jobState=NEW} == [OutputWorker-1] finish job: Job{id=3, message='It job is finish!', jobState=FINISH} -\u003e [InputWorker-2] add job: Job{id=8, message='[InputWorker-2]: (14:52:45) It is a very hard job!', jobState=NEW} \u003c- [OutputWorker-1] process job: Job{id=4, message='It is a really hard job!', jobState=IN_PROGRESS} == [OutputWorker-1] finish job: Job{id=4, message='It job is finish!', jobState=FINISH} \u003c- [OutputWorker-1] process job: Job{id=5, message='It is a really hard job!', jobState=IN_PROGRESS} == [OutputWorker-1] finish job: Job{id=5, message='It job is finish!', jobState=FINISH} -\u003e [InputWorker-1] add job: Job{id=9, message='[InputWorker-1]: (14:52:46) It is a very hard job!', jobState=NEW} \u003c- [OutputWorker-1] process job: Job{id=6, message='It is a really hard job!', jobState=IN_PROGRESS} -\u003e [InputWorker-2] add job: Job{id=10, message='[InputWorker-2]: (14:52:47) It is a very hard job!', jobState=NEW} == [OutputWorker-1] finish job: Job{id=6, message='It job is finish!', jobState=FINISH} \u003c- [OutputWorker-1] process job: Job{id=7, message='It is a really hard job!', jobState=IN_PROGRESS} == [OutputWorker-1] finish job: Job{id=7, message='It job is finish!', jobState=FINISH} \u003c- [OutputWorker-1] process job: Job{id=8, message='It is a really hard job!', jobState=IN_PROGRESS} == [OutputWorker-1] finish job: Job{id=8, message='It job is finish!', jobState=FINISH} \u003c- [OutputWorker-1] process job: Job{id=9, message='It is a really hard job!', jobState=IN_PROGRESS} == [OutputWorker-1] finish job: Job{id=9, message='It job is finish!', jobState=FINISH} \u003c- [OutputWorker-1] process job: Job{id=10, message='It is a really hard job!', jobState=IN_PROGRESS} == [OutputWorker-1] finish job: Job{id=10, message='It job is finish!', jobState=FINISH} ?? [OutputWorker-1] Nothing to do, I stop. Mit der Start-Klasse wird das gesamte System gestartet. Leider fehlt ein zentraler Teil des Systems: Ihr müsst das Interface ProcessingInterface implementieren.\nIhr findet den Programmcode im work Repo:\nhttps://github.com/it-ninjas/work/tree/main/labs/src/main/java/ch/itninjas/labs/j7/queue/lab1\nAufgabe 1.1 (Optional) Implementiert das ProcessingInterface mit einer Queue, damit die Jobs im FIFO-Prinzip (First-In-First-Out) verarbeitet werden. Kontrolliert die Konsole-Ausgabe: Ob alle Jobs verarbeitet wurden. Ob die Jobs in der gewünschten Reihenfolge verarbeitet wurden. Verändert die Pausen und Verarbeitungszeit der Worker und schaut euch der Einfluss in der Konsole an. Aufgabe 1.2 (Optional) Implementiert das ProcessingInterface mit einer Queue, damit die Jobs im LIFO-Prinzip (Last-In-First-Out) verarbeitet werden. Kontrolliert die Konsole-Ausgabe: Ob alle Jobs verarbeitet wurden. Ob die Jobs in der gewünschten Reihenfolge (Last-In-First-Out) verarbeitet wurden. Verändert die Pausen und Verarbeitungszeit der Worker und schaut euch der Einfluss in der Konsole an. Aufgabe 2 (Optional) Erweitert den OutputWorker so, dass er vor der Verarbeitung eines Jobs die Anzahl offener Jobs anzeigt.\nAufgabe 3 (Optional) Erweitert den OutputWorker so, dass er zufällig einzelne Jobs nicht erfolgreich bearbeiten kann und diese mit der Methode ProcessingInterface.getJobBack(Job job) zurück in die Queue stellt.\nAufgabe 4 (Optional) Erstellt ein JUnit-Test (JUnit Version 5), welcher die Schnittstelle ProcessingInterface der Klasse Processing ausführlich testet.\n","categories":"","description":"Aufgaben zu [Java Collections - Queue + Deque](../../../docs/02_java/10_java-collections//06_queue/)\n","excerpt":"Aufgaben zu [Java Collections - Queue + …","ref":"/de/labs/02_java/10_java-collections/05_queue/","tags":"","title":"Queue + Deque - Aufgaben"},{"body":"java.util.Stack java.util.Stack ist eine weitere Datenstruktur, bei der Elemente eingefügt und wieder entfernt werden können, wobei bei Stacks immer nur auf dasjenige Element zugegriffen werden kann, das zuletzt eingefügt wurde (Last-In-First-Out = LIFO). Auf Deutsch könnte man Stack als “Stapel” übersetzen.\nEin Stack kann leer sein oder kann beliebig wachsen. Mit der Methode push(E item) legt man das Element item auf den Stack, d.h. man fügt es zu oberst hinzu. pop() entfernt das oberste Element vom Stack und gibt es zurück.\nDie Methode peek() gibt das Element zu oberst auf dem Stack zurück, ohne den Stack zu verändern.\nFalls der Stack leer ist und man die Methode pop() oder peek() aufruft, wird die Exception EmptyStackException geworfen.\nMit der Methode search(Object o) kann man ein Element im Stack suchen, wobei die Position des Elements zurückgegeben wird. Bei den Stacks hat das oberste Element des Stacks die Position 1 und das Element darunter die Position 2, das Element darunter die Position 3, ect. Das heisst anders als bei den ArrayLists fangen wir nicht bei 0 an die Elemente zu indexieren, sondern bei 1.\nAlle Methoden der Klasse java.util.Stack 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /* * Konstruktor: Erstellt einen leeren Stack */ public Stack() /* * Fügt ein Element an die oberste Stelle dieses Stacks hinzu. */ public E push(E item) /* * Entfernt das Element an der obersten Stellen und gibt dieses Element * als Wert dieser Funktion zurück. */ public E pop() /* * Gibt das Element an der obersten Stelle des Stacks zurück, * ohne es vom Stack zu entfernen. */ public E peek() /* * Gibt true zurück, wenn der Stack keine Elemente enthält. */ public boolean empty() /* * Gibt die 1-basierte Position vom oberen Ende des Stapels zurück, * an der sich das Objekt befindet; der Rückgabewert -1 bedeutet, * dass sich das Objekt nicht auf dem Stapel befindet. */ public int search(Object o) Beispiel Beispiel 1 Im folgenden Beispiel erstellen wir zunächst ein leeres Stack mit Elementen vom Typ String und wenden die Methoden der Stack-Klasse an und sehen, wie diese funktionieren.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import java.util.Stack; public class StackExample { public static void main(String[] args) { Stack\u003cString\u003e colors = new Stack\u003c\u003e(); colors.push(\"blue\"); colors.push(\"yellow\"); colors.push(\"green\"); colors.push(\"orange\"); System.out.println(colors); // Output: [blue, yellow, green, orange] System.out.println(\"Color on top: \" + colors.peek()); // Output: Color on top: orange System.out.println(colors); // Output: [blue, yellow, green, orange] System.out.println(\"Color on top: \" + colors.pop()); // Output: Color on top: orange System.out.println(colors); // Output: [blue, yellow, green] System.out.println(\"Is stack empty? \" + colors.empty()); // Output: Is stack empty? false System.out.println(\"Size of stack: \" + colors.size()); // Output: Size of stack: 3 System.out.println(\"Position of element blue: \" + colors.search(\"blue\")); // Output: Position of element blue: 3 System.out.println(\"Position of element yellow: \" + colors.search(\"yellow\")); // Output: Position of element yellow: 2 System.out.println(\"Position of element green: \" + colors.search(\"green\")); // Output: Position of element green: 1 } } Output:\n1 2 3 4 5 6 7 8 9 10 [blue, yellow, green, orange] Color on top: orange [blue, yellow, green, orange] Color on top: orange [blue, yellow, green] Is stack empty? false Size of stack: 3 Position of element blue: 3 Position of element yellow: 2 Position of element green: 1 Im oberen Beispiel verwenden wir die Methode size(). Diese Methode ist nicht in der java.util.Stack-Klasse implementiert, wird jedoch von der Vector-Mutterklasse geerbt. Diese Vector-Klasse implementiert zusätzlich weitere Methoden des List-Interfaces, weshalb diese auch für Stacks verwendet werden können. Ein Stack bzw. die Datenstruktur des Stacks wird jedoch durch die oben aufgeführten Methoden ausgemacht.\nBeispiel 2 (EmptyStackException) In diesem Beispiel rufen wir die pop()-Methode auf einem leeren Stack auf:\n1 2 3 4 5 6 7 8 import java.util.Stack; public class StackExampleEmptyStackExceptionA { public static void main(String[] args) { Stack\u003cString\u003e colors = new Stack\u003c\u003e(); colors.pop(); // Throws: Exception in thread \"main\" java.util.EmptyStackException } } Dies führt zu folgendem Output:\n1 2 3 4 Exception in thread \"main\" java.util.EmptyStackException at java.base/java.util.Stack.peek(Stack.java:102) at java.base/java.util.Stack.pop(Stack.java:84) at ch.puzzle.stack.StackExampleEmptyStackExceptionA.main(StackExampleEmptyStackExceptionA.java:8) Das gleiche Verhalten lässt sich auch bei der peek()-Methode feststellen:\n1 2 3 4 5 6 7 8 import java.util.Stack; public class StackExampleEmptyStackExceptionB { public static void main(String[] args) { Stack\u003cString\u003e colors = new Stack\u003c\u003e(); colors.peek(); // Throws: Exception in thread \"main\" java.util.EmptyStackException } } Wie erwartet, kriegen wir folgenden Output:\n1 2 3 Exception in thread \"main\" java.util.EmptyStackException at java.base/java.util.Stack.peek(Stack.java:102) at ch.puzzle.stack.StackExampleEmptyStackExceptionB.main(StackExampleEmptyStackExceptionB.java:8) Aufgaben Aufgaben Aufgaben zu Modul #J6 - Java Collections - Stack\n","categories":"","description":"Die Datenstruktur \"Stapel\".\n","excerpt":"Die Datenstruktur \"Stapel\".\n","ref":"/docs/02_java/10_java-collections/05_stack/","tags":"","title":"Stack"},{"body":"java.util.Stack java.util.Stack ist eine weitere Datenstruktur, bei der Elemente eingefügt und wieder entfernt werden können, wobei bei Stacks immer nur auf dasjenige Element zugegriffen werden kann, das zuletzt eingefügt wurde (Last-In-First-Out = LIFO). Auf Deutsch könnte man Stack als “Stapel” übersetzen.\nEin Stack kann leer sein oder kann beliebig wachsen. Mit der Methode push(E item) legt man das Element item auf den Stack, d.h. man fügt es zu oberst hinzu. pop() entfernt das oberste Element vom Stack und gibt es zurück.\nDie Methode peek() gibt das Element zu oberst auf dem Stack zurück, ohne den Stack zu verändern.\nFalls der Stack leer ist und man die Methode pop() oder peek() aufruft, wird die Exception EmptyStackException geworfen.\nMit der Methode search(Object o) kann man ein Element im Stack suchen, wobei die Position des Elements zurückgegeben wird. Bei den Stacks hat das oberste Element des Stacks die Position 1 und das Element darunter die Position 2, das Element darunter die Position 3, ect. Das heisst anders als bei den ArrayLists fangen wir nicht bei 0 an die Elemente zu indexieren, sondern bei 1.\nAlle Methoden der Klasse java.util.Stack 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /* * Konstruktor: Erstellt einen leeren Stack */ public Stack() /* * Fügt ein Element an die oberste Stelle dieses Stacks hinzu. */ public E push(E item) /* * Entfernt das Element an der obersten Stellen und gibt dieses Element * als Wert dieser Funktion zurück. */ public E pop() /* * Gibt das Element an der obersten Stelle des Stacks zurück, * ohne es vom Stack zu entfernen. */ public E peek() /* * Gibt true zurück, wenn der Stack keine Elemente enthält. */ public boolean empty() /* * Gibt die 1-basierte Position vom oberen Ende des Stapels zurück, * an der sich das Objekt befindet; der Rückgabewert -1 bedeutet, * dass sich das Objekt nicht auf dem Stapel befindet. */ public int search(Object o) Beispiel Beispiel 1 Im folgenden Beispiel erstellen wir zunächst ein leeres Stack mit Elementen vom Typ String und wenden die Methoden der Stack-Klasse an und sehen, wie diese funktionieren.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import java.util.Stack; public class StackExample { public static void main(String[] args) { Stack\u003cString\u003e colors = new Stack\u003c\u003e(); colors.push(\"blue\"); colors.push(\"yellow\"); colors.push(\"green\"); colors.push(\"orange\"); System.out.println(colors); // Output: [blue, yellow, green, orange] System.out.println(\"Color on top: \" + colors.peek()); // Output: Color on top: orange System.out.println(colors); // Output: [blue, yellow, green, orange] System.out.println(\"Color on top: \" + colors.pop()); // Output: Color on top: orange System.out.println(colors); // Output: [blue, yellow, green] System.out.println(\"Is stack empty? \" + colors.empty()); // Output: Is stack empty? false System.out.println(\"Size of stack: \" + colors.size()); // Output: Size of stack: 3 System.out.println(\"Position of element blue: \" + colors.search(\"blue\")); // Output: Position of element blue: 3 System.out.println(\"Position of element yellow: \" + colors.search(\"yellow\")); // Output: Position of element yellow: 2 System.out.println(\"Position of element green: \" + colors.search(\"green\")); // Output: Position of element green: 1 } } Output:\n1 2 3 4 5 6 7 8 9 10 [blue, yellow, green, orange] Color on top: orange [blue, yellow, green, orange] Color on top: orange [blue, yellow, green] Is stack empty? false Size of stack: 3 Position of element blue: 3 Position of element yellow: 2 Position of element green: 1 Im oberen Beispiel verwenden wir die Methode size(). Diese Methode ist nicht in der java.util.Stack-Klasse implementiert, wird jedoch von der Vector-Mutterklasse geerbt. Diese Vector-Klasse implementiert zusätzlich weitere Methoden des List-Interfaces, weshalb diese auch für Stacks verwendet werden können. Ein Stack bzw. die Datenstruktur des Stacks wird jedoch durch die oben aufgeführten Methoden ausgemacht.\nBeispiel 2 (EmptyStackException) In diesem Beispiel rufen wir die pop()-Methode auf einem leeren Stack auf:\n1 2 3 4 5 6 7 8 import java.util.Stack; public class StackExampleEmptyStackExceptionA { public static void main(String[] args) { Stack\u003cString\u003e colors = new Stack\u003c\u003e(); colors.pop(); // Throws: Exception in thread \"main\" java.util.EmptyStackException } } Dies führt zu folgendem Output:\n1 2 3 4 Exception in thread \"main\" java.util.EmptyStackException at java.base/java.util.Stack.peek(Stack.java:102) at java.base/java.util.Stack.pop(Stack.java:84) at ch.puzzle.stack.StackExampleEmptyStackExceptionA.main(StackExampleEmptyStackExceptionA.java:8) Das gleiche Verhalten lässt sich auch bei der peek()-Methode feststellen:\n1 2 3 4 5 6 7 8 import java.util.Stack; public class StackExampleEmptyStackExceptionB { public static void main(String[] args) { Stack\u003cString\u003e colors = new Stack\u003c\u003e(); colors.peek(); // Throws: Exception in thread \"main\" java.util.EmptyStackException } } Wie erwartet, kriegen wir folgenden Output:\n1 2 3 Exception in thread \"main\" java.util.EmptyStackException at java.base/java.util.Stack.peek(Stack.java:102) at ch.puzzle.stack.StackExampleEmptyStackExceptionB.main(StackExampleEmptyStackExceptionB.java:8) Aufgaben Aufgaben Aufgaben zu Modul #J6 - Java Collections - Stack\n","categories":"","description":"Die Datenstruktur \"Stapel\".\n","excerpt":"Die Datenstruktur \"Stapel\".\n","ref":"/de/docs/02_java/10_java-collections/05_stack/","tags":"","title":"Stack"},{"body":"Spring Struktur Die Meisten modernen Webapplikationen bestehen aus 3 Schichten:\nLayer Beschreibung Boundary (Grenze) Auf dieser Schicht wird die Kommunikation mit der Aussenwelt abgewickelt. Control (Verwaltung) Auf dieser Schicht sind alle Klassen und deren Logik. Entity (Speicher) Auf dieser Schicht wird alles abgewickelt, was mit Datenspeicherung und Auslesung zu tun hat (z.B. mit Repositories). Spring hat verschiedene Annotationen für verschiedene Aufgaben. Mit der @Component Annotation wird eine generische Spring Komponente dargestellt. Alle anderen Annotationen sind ebenfalls Komponenten. Sie grenzen nur ab, was sie genau machen. Mit der @Configuration Annotation werden Komponenten für die Konfiguration definiert. Mit der @Repository Annotation werden Komponenten, welche mit der Datenspeicherung zu tun haben definiert. Mit der @Controller Annotation werden Komponenten, welche mit der Kommunikation mit der Aussenwelt zu tun haben definiert. In der @Service Annotation werden Komponenten, welche mit der Kontrolllogik zu tun haben definiert.\nMehr Informationen zu den einzelnen Annotationen findest du hier.\nDie Schichten (Layer) in Spring Boundary Layer In diesem Layer definieren wir unsere REST Ressourcen. Hier ein Beispiel einer Order-Klasse in einem Webshop:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 @RestController @RequestMapping(\"/orders\") public class OrderController { private final OrderService orderService; public OrderResource(OrderService orderService) { this.orderService = orderService; } @GetMapping public List\u003cOrder\u003e findAll() { return orderService.findAll(); } @GetMapping(\"/{id}\") public Order findById(@PathVariable Long id) { return orderService.findById(id).orElseThrow(EntityNotFoundException::new); } @PostMapping public Order save(@RequestBody Order order) { return orderService.save(order); } @PutMapping(\"/{id}\") public Order update(@PathVariable Long id, @RequestBody Order order) { return orderService.update(id, order); } @DeleteMapping(\"/{id}\") public ResponseEntity delete(@PathVariable Long id) { orderService.delete(id); return ResponseEntity.ok().build(); } } Dies ist eine Rest-Resource und sie wird definiert mit der Annotation @RestController. Die Annotation @RequestMapping(\"/orders\") legt fest, das alle Aufrufe, deren URL mit \"/orders\" beginnen, diesen Rest-Controller verwenden sollen.\nControl Layer Der Control Layer bildet den Kern aller Anwendungen und enthält die Geschäftslogiken. Auf der technischen Ebene ist der Control Layer die grundlegendste Schicht. Die Control Layer könnte wie folgt aussehen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @Service @Transactional public class OrderService { private final OrderRepository orderRepository; public OrderService(OrderRepository orderRepository) { this.orderRepository = orderRepository; } public List\u003cOrder\u003e findAll() { return (List\u003cOrder\u003e) orderRepository.findAll(); } public Optional\u003cOrder\u003e findById(Long id) { return orderRepository.findById(id); } public Order save(Order order) { return orderRepository.save(order); } public Order update(Long id, Order order) { Order toUpdate = orderRepository.findById(id).orElseThrow(EntityNotFoundException::new); toUpdate.setName(order.getName()); return toUpdate; } public void delete(Long id) { orderRepository.deleteById(id); } } Diese Klasse besitzt nur zwei Annotationen nämlich @Service und @Transactional. Die @Service Annotation markiert Beans als Holder der Businesslogik. @Transactional sagt einfach, dass alle Funktionen in der Klasse in einer einzigen Transaktion ausgeführt werden sollen. Das musst du vorläufig aber noch nicht verstehen. Durch die Constructor Injection wird hier auch noch die Bean OrderRepository injected.\nEntity Layer Der Entity Layer ist für die Datenspeicherung zuständig. Auf diesem Layer gibt es die zwei Hauptbestandteile Entity und Repository. Entities sind Klassen, die eine Datenbank-Tabelle repräsentieren. Die Repositories hingegen verwalten diese Entities.\nAuch hier wird mit Annotationen gearbeitet, um die Funktionalitäten umzusetzen. Die @Entity Annotation sagt, dass es sich bei dieser Klasse um ein Entity handelt.\nDie @Table Annotation sagt auf welcher Tabelle in der Datenbank diese Klasse gespeichert wird (Schreibweise @Table(name = \"tabellenNamen\")).\nDie @GeneratedValue Annotation besagt, dass dieser Wert in der Tabelle/Datenbank automatisch generiert wird.\nDie @Id Annotation sagt, dass dieses Feld als Primärschlüssel in der Tabelle fungiert.\nHier ist ein Beispiel:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @Entity @Table(name = \"orders\") public class Order { @Id @GeneratedValue Long id; String name; public Long getId() { return id; } public void setId(Long id) { this.id = id; } public void setName(String name) { this.name = name; } public String getName() { return this.name; } } Damit wir auf die Daten zugreifen können, brauchen wir ein Repository. Dazu können wir ein Interface implementieren, welches CrudRepository extended. Das CrudRepository sucht zur Laufzeit passende Implementierungsklassen, die wir verwenden können, deshalb müssen wir keine eigenen implementieren.\nHier ein Beispiel:\n1 2 3 @Repository public interface OrderRepository extends CrudRepository\u003cOrder, Long\u003e { } Du fragst dich vielleicht, wo die Daten gespeichert werden. Normalerweise macht Spring eine temporäre Datenbank, welche jedoch nach Abschluss des Programmes wieder gelöscht wird. Wenn man die Daten nicht jedes Mal neu schreiben will, kann man sie in einer “richtigen” Datenbank speichern. Dazu müssen wir die Spring Konfiguration ändern.\nSpring lädt die Konfiguration von einer Datei mit dem Namen application.properies bzw. application.yaml. Diese Datei befindet sich im resources-Ordner (oft im Ordner “src/main” oder “src/test”).\nFolgende 5 Konfigurationen werden oft im Zusammenhang mit Datenbanken benötigt:\nKonfiguration Beschreibung spring.datasource.url gibt die URL der Datenbank an (Format:jdbc:[datenbanktyp]://[server]:[port]/[datenbank]) spring.datasource.username gibt den Benutzername an, mit dem die Verbindung zur Datenbank aufgebaut werden soll. spring.datasource.password gibt das Passwort der Datenbank an. spring.datasource.driver-class-name gibt an, welcher Datenbanktreiber verwendet wird (muss als Maven-Dependency hinzugefügt werden) spring.jpa.hibernate.ddl-auto beschreibt, wie Spring mit der Datenbank umgehen soll. update z.B. sorgt dafür, dass fehlende Spalten oder dergleichen automatisch erstellt werden und dass nie Sachen gelöscht werden. create-drop erstellt die Datenbank und löscht die Objekte nachher. none belässt die Datenbank. Hier ist eine Beispiel-Konfiguration mit einer Mariadb Datenbank:\n1 2 3 4 5 spring.datasource.url=jdbc:mariadb://localhost:3306/order spring.datasource.username=spring spring.datasource.password=1234 spring.datasource.driver-class-name=org.mariadb.jdbc.Driver spring.jpa.hibernate.ddl-auto=update 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 spring: datasource: url: \"jdbc:mariadb://localhost:3306/order\" username: spring password: 1234 driver-class-name: org.mariadb.jdbc.Driver jpa: hibernate: ddl-auto: update `` ##### Repository Eines der am häufigsten verwendeten Design-Patterns ist das Repository Design-Pattern. Ein Repository ist eine Schnittstelle, die den Zugriff auf Daten in der Datenbank ermöglicht. Man kann es sich wie einen Bibliothekar vorstellen: Der Bibliothekar findet und bringt uns die gewünschten Bücher, ohne dass wir wissen müssen, wie er sie findet. Wir kennen nur die \"Befehle\" (Methoden) des Repositorys und welche Ergebnisse wir erwarten können. ```java public interface ArticleRepository { List\u003cArticle\u003e readAll(); List\u003cArticle\u003e readLatest(); List\u003cArticle\u003e readByTags(Tag... tags); Article readById(long id); Article create(Article article); Article update(Article article); Article delete(Article article); } Meistens wird das Interface im Hintergrund vom Framework implementiert und wir müssen nichts dafür tun, ausser den richtigen Methodennamen und Rückgabewert zu wählen, damit Spring weiss, was es implementieren soll.\nProfile In Spring kann man verschiedene Profile erstellen. Damit wird sichergestellt, dass bestimmte @Beans nur entsprechend gesetzt werden, sobald eine bestimmte Bedingung zutrifft. Die Datenbank soll zum Beispiel nur Beispieldaten laden, wenn das Dev-Profil aktiv ist, ansonsten soll eine richtige Datenbank verwendet werden.\nMit der @Profile Annotation kann man einer Klasse oder Methode (Beans) sagen, ob sie bei einem Profil läuft. Das Standardprofil ist default, sobald ein anderes Profil aktiv ist, wird das default Profil deaktiviert. Hier ist ein Beispiel:\n1 2 3 4 5 6 7 8 @Component @Profile(\"test\") public class TestString { @Bean public String test() { return \"test\"; } } Im Beispiel lädt die Komponente TestString nur, wenn das Profil test aktiv ist.\nBei der @Profile-Annotation kann man auch logische Operatoren wie “Und” (\u0026) , “Oder” (|) und “Nicht” (!) benutzen. Hier ein Beispiel:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Component public class Demo { @Bean @Profile(\"default\") public String defaultString() { return \"Standard Profil\"; } @Bean @Profile(\"test | test2\") public String testString() { return \"Test Test\"; } @Bean @Profile(\"!(default | test | test2)\") public String rewoltString() { return \"None of the above\"; } } In diesem Beispiel werden Methoden angesteuert, sobald ein Profil aktiv ist. Wenn das Profil default aktiv ist, wird die defaultString Methode geladen, wenn das Profil test oder test2 aktiv ist, wird die testString Methode geladen, wenn keines der obengenannten Profile aktiv ist, wird die rewoltString-Methode geladen.\nIn Spring kann man mehrere Profile aktivieren. Die Profile können mit dem Program gesetzt werden.\nBeispiel hier:\n1 2 3 4 AnnotationConfigApplicationContext ctx=new AnnotationConfigApplicationContext(); ctx.getEnvironment().setActiveProfiles(\"test\"); ctx.register(SomeConfig.class,StandaloneDataConfig.class,JndiDataConfig.class); ctx.refresh(); Die Profile können auch über die spring.profiles.active Property aktiviert werden. Beispiel hier:\n1 spring.profiles.active=\"test\" Bei beiden Möglichkeiten wurde das Profil test aktiviert. Weitere Informationen in der offiziellen Dokumentation oder in dieser Erklärung.\n","categories":"","description":"Modul #J8 - Spring Framework - Wie ist die Spring Struktur aufgebaut?\n","excerpt":"Modul #J8 - Spring Framework - Wie ist die Spring Struktur aufgebaut?\n","ref":"/docs/02_java/12_spring-framework/05_struktur/","tags":"","title":"Struktur"},{"body":"Spring Struktur Die Meisten modernen Webapplikationen bestehen aus 3 Schichten:\nLayer Beschreibung Boundary (Grenze) Auf dieser Schicht wird die Kommunikation mit der Aussenwelt abgewickelt. Control (Verwaltung) Auf dieser Schicht sind alle Klassen und deren Logik. Entity (Speicher) Auf dieser Schicht wird alles abgewickelt, was mit Datenspeicherung und Auslesung zu tun hat (z.B. mit Repositories). Spring hat verschiedene Annotationen für verschiedene Aufgaben. Mit der @Component Annotation wird eine generische Spring Komponente dargestellt. Alle anderen Annotationen sind ebenfalls Komponenten. Sie grenzen nur ab, was sie genau machen. Mit der @Configuration Annotation werden Komponenten für die Konfiguration definiert. Mit der @Repository Annotation werden Komponenten, welche mit der Datenspeicherung zu tun haben definiert. Mit der @Controller Annotation werden Komponenten, welche mit der Kommunikation mit der Aussenwelt zu tun haben definiert. In der @Service Annotation werden Komponenten, welche mit der Kontrolllogik zu tun haben definiert.\nMehr Informationen zu den einzelnen Annotationen findest du hier.\nDie Schichten (Layer) in Spring Boundary Layer In diesem Layer definieren wir unsere REST Ressourcen. Hier ein Beispiel einer Order-Klasse in einem Webshop:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 @RestController @RequestMapping(\"/orders\") public class OrderController { private final OrderService orderService; public OrderResource(OrderService orderService) { this.orderService = orderService; } @GetMapping public List\u003cOrder\u003e findAll() { return orderService.findAll(); } @GetMapping(\"/{id}\") public Order findById(@PathVariable Long id) { return orderService.findById(id).orElseThrow(EntityNotFoundException::new); } @PostMapping public Order save(@RequestBody Order order) { return orderService.save(order); } @PutMapping(\"/{id}\") public Order update(@PathVariable Long id, @RequestBody Order order) { return orderService.update(id, order); } @DeleteMapping(\"/{id}\") public ResponseEntity delete(@PathVariable Long id) { orderService.delete(id); return ResponseEntity.ok().build(); } } Dies ist eine Rest-Resource und sie wird definiert mit der Annotation @RestController. Die Annotation @RequestMapping(\"/orders\") legt fest, das alle Aufrufe, deren URL mit \"/orders\" beginnen, diesen Rest-Controller verwenden sollen.\nControl Layer Der Control Layer bildet den Kern aller Anwendungen und enthält die Geschäftslogiken. Auf der technischen Ebene ist der Control Layer die grundlegendste Schicht. Die Control Layer könnte wie folgt aussehen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @Service @Transactional public class OrderService { private final OrderRepository orderRepository; public OrderService(OrderRepository orderRepository) { this.orderRepository = orderRepository; } public List\u003cOrder\u003e findAll() { return (List\u003cOrder\u003e) orderRepository.findAll(); } public Optional\u003cOrder\u003e findById(Long id) { return orderRepository.findById(id); } public Order save(Order order) { return orderRepository.save(order); } public Order update(Long id, Order order) { Order toUpdate = orderRepository.findById(id).orElseThrow(EntityNotFoundException::new); toUpdate.setName(order.getName()); return toUpdate; } public void delete(Long id) { orderRepository.deleteById(id); } } Diese Klasse besitzt nur zwei Annotationen nämlich @Service und @Transactional. Die @Service Annotation markiert Beans als Holder der Businesslogik. @Transactional sagt einfach, dass alle Funktionen in der Klasse in einer einzigen Transaktion ausgeführt werden sollen. Das musst du vorläufig aber noch nicht verstehen. Durch die Constructor Injection wird hier auch noch die Bean OrderRepository injected.\nEntity Layer Der Entity Layer ist für die Datenspeicherung zuständig. Auf diesem Layer gibt es die zwei Hauptbestandteile Entity und Repository. Entities sind Klassen, die eine Datenbank-Tabelle repräsentieren. Die Repositories hingegen verwalten diese Entities.\nAuch hier wird mit Annotationen gearbeitet, um die Funktionalitäten umzusetzen. Die @Entity Annotation sagt, dass es sich bei dieser Klasse um ein Entity handelt.\nDie @Table Annotation sagt auf welcher Tabelle in der Datenbank diese Klasse gespeichert wird (Schreibweise @Table(name = \"tabellenNamen\")).\nDie @GeneratedValue Annotation besagt, dass dieser Wert in der Tabelle/Datenbank automatisch generiert wird.\nDie @Id Annotation sagt, dass dieses Feld als Primärschlüssel in der Tabelle fungiert.\nHier ist ein Beispiel:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @Entity @Table(name = \"orders\") public class Order { @Id @GeneratedValue Long id; String name; public Long getId() { return id; } public void setId(Long id) { this.id = id; } public void setName(String name) { this.name = name; } public String getName() { return this.name; } } Damit wir auf die Daten zugreifen können, brauchen wir ein Repository. Dazu können wir ein Interface implementieren, welches CrudRepository extended. Das CrudRepository sucht zur Laufzeit passende Implementierungsklassen, die wir verwenden können, deshalb müssen wir keine eigenen implementieren.\nHier ein Beispiel:\n1 2 3 @Repository public interface OrderRepository extends CrudRepository\u003cOrder, Long\u003e { } Du fragst dich vielleicht, wo die Daten gespeichert werden. Normalerweise macht Spring eine temporäre Datenbank, welche jedoch nach Abschluss des Programmes wieder gelöscht wird. Wenn man die Daten nicht jedes Mal neu schreiben will, kann man sie in einer “richtigen” Datenbank speichern. Dazu müssen wir die Spring Konfiguration ändern.\nSpring lädt die Konfiguration von einer Datei mit dem Namen application.properies bzw. application.yaml. Diese Datei befindet sich im resources-Ordner (oft im Ordner “src/main” oder “src/test”).\nFolgende 5 Konfigurationen werden oft im Zusammenhang mit Datenbanken benötigt:\nKonfiguration Beschreibung spring.datasource.url gibt die URL der Datenbank an (Format:jdbc:[datenbanktyp]://[server]:[port]/[datenbank]) spring.datasource.username gibt den Benutzername an, mit dem die Verbindung zur Datenbank aufgebaut werden soll. spring.datasource.password gibt das Passwort der Datenbank an. spring.datasource.driver-class-name gibt an, welcher Datenbanktreiber verwendet wird (muss als Maven-Dependency hinzugefügt werden) spring.jpa.hibernate.ddl-auto beschreibt, wie Spring mit der Datenbank umgehen soll. update z.B. sorgt dafür, dass fehlende Spalten oder dergleichen automatisch erstellt werden und dass nie Sachen gelöscht werden. create-drop erstellt die Datenbank und löscht die Objekte nachher. none belässt die Datenbank. Hier ist eine Beispiel-Konfiguration mit einer Mariadb Datenbank:\n1 2 3 4 5 spring.datasource.url=jdbc:mariadb://localhost:3306/order spring.datasource.username=spring spring.datasource.password=1234 spring.datasource.driver-class-name=org.mariadb.jdbc.Driver spring.jpa.hibernate.ddl-auto=update 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 spring: datasource: url: \"jdbc:mariadb://localhost:3306/order\" username: spring password: 1234 driver-class-name: org.mariadb.jdbc.Driver jpa: hibernate: ddl-auto: update `` ##### Repository Eines der am häufigsten verwendeten Design-Patterns ist das Repository Design-Pattern. Ein Repository ist eine Schnittstelle, die den Zugriff auf Daten in der Datenbank ermöglicht. Man kann es sich wie einen Bibliothekar vorstellen: Der Bibliothekar findet und bringt uns die gewünschten Bücher, ohne dass wir wissen müssen, wie er sie findet. Wir kennen nur die \"Befehle\" (Methoden) des Repositorys und welche Ergebnisse wir erwarten können. ```java public interface ArticleRepository { List\u003cArticle\u003e readAll(); List\u003cArticle\u003e readLatest(); List\u003cArticle\u003e readByTags(Tag... tags); Article readById(long id); Article create(Article article); Article update(Article article); Article delete(Article article); } Meistens wird das Interface im Hintergrund vom Framework implementiert und wir müssen nichts dafür tun, ausser den richtigen Methodennamen und Rückgabewert zu wählen, damit Spring weiss, was es implementieren soll.\nProfile In Spring kann man verschiedene Profile erstellen. Damit wird sichergestellt, dass bestimmte @Beans nur entsprechend gesetzt werden, sobald eine bestimmte Bedingung zutrifft. Die Datenbank soll zum Beispiel nur Beispieldaten laden, wenn das Dev-Profil aktiv ist, ansonsten soll eine richtige Datenbank verwendet werden.\nMit der @Profile Annotation kann man einer Klasse oder Methode (Beans) sagen, ob sie bei einem Profil läuft. Das Standardprofil ist default, sobald ein anderes Profil aktiv ist, wird das default Profil deaktiviert. Hier ist ein Beispiel:\n1 2 3 4 5 6 7 8 @Component @Profile(\"test\") public class TestString { @Bean public String test() { return \"test\"; } } Im Beispiel lädt die Komponente TestString nur, wenn das Profil test aktiv ist.\nBei der @Profile-Annotation kann man auch logische Operatoren wie “Und” (\u0026) , “Oder” (|) und “Nicht” (!) benutzen. Hier ein Beispiel:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Component public class Demo { @Bean @Profile(\"default\") public String defaultString() { return \"Standard Profil\"; } @Bean @Profile(\"test | test2\") public String testString() { return \"Test Test\"; } @Bean @Profile(\"!(default | test | test2)\") public String rewoltString() { return \"None of the above\"; } } In diesem Beispiel werden Methoden angesteuert, sobald ein Profil aktiv ist. Wenn das Profil default aktiv ist, wird die defaultString Methode geladen, wenn das Profil test oder test2 aktiv ist, wird die testString Methode geladen, wenn keines der obengenannten Profile aktiv ist, wird die rewoltString-Methode geladen.\nIn Spring kann man mehrere Profile aktivieren. Die Profile können mit dem Program gesetzt werden.\nBeispiel hier:\n1 2 3 4 AnnotationConfigApplicationContext ctx=new AnnotationConfigApplicationContext(); ctx.getEnvironment().setActiveProfiles(\"test\"); ctx.register(SomeConfig.class,StandaloneDataConfig.class,JndiDataConfig.class); ctx.refresh(); Die Profile können auch über die spring.profiles.active Property aktiviert werden. Beispiel hier:\n1 spring.profiles.active=\"test\" Bei beiden Möglichkeiten wurde das Profil test aktiviert. Weitere Informationen in der offiziellen Dokumentation oder in dieser Erklärung.\n","categories":"","description":"Modul #J8 - Spring Framework - Wie ist die Spring Struktur aufgebaut?\n","excerpt":"Modul #J8 - Spring Framework - Wie ist die Spring Struktur aufgebaut?\n","ref":"/de/docs/02_java/12_spring-framework/05_struktur/","tags":"","title":"Struktur"},{"body":"","categories":"","description":"Kleine Tools, Tipps und Anleitungen für die Praxis.\n","excerpt":"Kleine Tools, Tipps und Anleitungen für die Praxis.\n","ref":"/docs/99_tools/diverses/","tags":"","title":"Nützliche Tips, Tricks und Anleitungen"},{"body":"In dieser Aufgabe wird die Zusammenarbeit an einem gemeinsamen Projekt mit Merge-Konflikte und deren Lösung simuliert. Dazu führt jedes Team-Mitglied die nachfolgenden Aktionen auf seinem Rechner aus. Der Lead Developer legt fest, welche Datei geändert werden soll.\nDie Schritte 1 bis 4 sind Einzelaufgaben, die jeder Ninja selbständig lösen muss/kann. Die Schritte 5 bis 7 sind Teamaufgaben.\nSchritt 1: Feature-Branch aktualisieren Diese Aufgabe kann erst gestartet werden, wenn alle Feature-Branches aus dem vorherigen Lab erfolgreich gemergt wurden.\nStarte IntelliJ. Wechsle zum ersten Projekt (Menu › File › Recent Projects). Achte darauf, dass du auf deinem Feature-branch arbeitest. Aktualisiere den lokalen Stand von Git (Menu › Git › Fetch). Aktualisiere den Stand des Feature-Branch mit Git › rebase von develop. Schritt 2: Bearbeiten der gleichen Codestelle Jedes Teammitglied führt Änderungen an der Methode/Datei aus, die vorher gemeinsam festlegt wurde. Achte darauf, dass die Änderungen auf den einzelnen Feature-Branches zwar die gleichen Codezeilen betreffen, aber nicht identisch sind.\nDie Änderungen sollten nicht mehr als eine halbe Stunde Zeit benötigen.\nSchritt 3: Änderungen auf den Branch pushen Anschliessend werden die Änderungen committet und auf den remote Feature-Branch gepusht. Gehe dazu in IntelliJ auf\nGit › Commit… im Menu oder Git › Push… über das Kontextmenu auf dem Projekt. Wähle unter Changes die geänderten Dateien aus und übertrage sie mit Commit and Push… in das lokale und remote Git-Repository.\nSchritt 4: Pull Request erstellen und überprüfen Gehe in Bitbucket (Browser) auf den Feature-Branch und\nErstelle einen Pull Request (Pull Requests oder Pull-Anfragen in der Seitenleiste). Achte dabei darauf, das du develop als Zielbranch ausgewählt hast. Kontrolliere den Pull Request auf Konflikte. (Solange noch kein Pull Request gemergt wurde, sollten hier keine Konflikte auftreten.) Schritt 5: Mergen des ersten Feature-Branch Legt ein Team-Mitglied fest, welches seinen Feature-Branch als erstes auf develop mergt. Bei dieser Aktion sollte es noch nicht zu Konflikten kommen.\nSchritt 6: Mergen der übrigen Feature-Branches Legt nun die Reihenfolge fest, in der die übrigen Feature-Branches auf develop gemergt werden sollen. Führt die folgenden Schritte jeweils vollständig aus, bevor ihr mit dem nächsten Branch startet.\nWechselt auf den Pull Request. Kontrolliert den aktuellen Zusatnd (es sollten Konflikte vorhanden sein). Überprüft den Code mit diff. Löst den Konflikt manuell oder folgt den Empfehlungen von Bitbucket. Genehmigt den Pull Request, wenn der Konflikt gelöst ist. (Achtung, das kann nicht der Ersteller des Pull Requests machen!) Führt Merge auf develop aus. Wiederholt Punkt 1 bis 6 für den nächsten Pull Request. Schritt 7: Überprüfen des finalen Standes Geht nun zum develop Branch und überprüft, ob alle Änderungen korrekt übernommen wurden. In der Praxis sollten Tests (Unittests und/oder integrative Tests) existieren, die ohne Fehler ausführbar sein müssen.\n","categories":"","description":"Aufgabe Zusammenarbeit an einem Projekt mit Merge-Konflikten [Git Vertiefung](../../../../docs/04_git/02_vertiefung/02_zusammenarbeit)\n","excerpt":"Aufgabe Zusammenarbeit an einem Projekt mit Merge-Konflikten [Git …","ref":"/labs/04_git/02_vertiefung/04_merge-conflict/","tags":"","title":"Aufgabe: Arbeiten im Team an einem Projekt"},{"body":"In dieser Aufgabe wird die Zusammenarbeit an einem gemeinsamen Projekt mit Merge-Konflikte und deren Lösung simuliert. Dazu führt jedes Team-Mitglied die nachfolgenden Aktionen auf seinem Rechner aus. Der Lead Developer legt fest, welche Datei geändert werden soll.\nDie Schritte 1 bis 4 sind Einzelaufgaben, die jeder Ninja selbständig lösen muss/kann. Die Schritte 5 bis 7 sind Teamaufgaben.\nSchritt 1: Feature-Branch aktualisieren Diese Aufgabe kann erst gestartet werden, wenn alle Feature-Branches aus dem vorherigen Lab erfolgreich gemergt wurden.\nStarte IntelliJ. Wechsle zum ersten Projekt (Menu › File › Recent Projects). Achte darauf, dass du auf deinem Feature-branch arbeitest. Aktualisiere den lokalen Stand von Git (Menu › Git › Fetch). Aktualisiere den Stand des Feature-Branch mit Git › rebase von develop. Schritt 2: Bearbeiten der gleichen Codestelle Jedes Teammitglied führt Änderungen an der Methode/Datei aus, die vorher gemeinsam festlegt wurde. Achte darauf, dass die Änderungen auf den einzelnen Feature-Branches zwar die gleichen Codezeilen betreffen, aber nicht identisch sind.\nDie Änderungen sollten nicht mehr als eine halbe Stunde Zeit benötigen.\nSchritt 3: Änderungen auf den Branch pushen Anschliessend werden die Änderungen committet und auf den remote Feature-Branch gepusht. Gehe dazu in IntelliJ auf\nGit › Commit… im Menu oder Git › Push… über das Kontextmenu auf dem Projekt. Wähle unter Changes die geänderten Dateien aus und übertrage sie mit Commit and Push… in das lokale und remote Git-Repository.\nSchritt 4: Pull Request erstellen und überprüfen Gehe in Bitbucket (Browser) auf den Feature-Branch und\nErstelle einen Pull Request (Pull Requests oder Pull-Anfragen in der Seitenleiste). Achte dabei darauf, das du develop als Zielbranch ausgewählt hast. Kontrolliere den Pull Request auf Konflikte. (Solange noch kein Pull Request gemergt wurde, sollten hier keine Konflikte auftreten.) Schritt 5: Mergen des ersten Feature-Branch Legt ein Team-Mitglied fest, welches seinen Feature-Branch als erstes auf develop mergt. Bei dieser Aktion sollte es noch nicht zu Konflikten kommen.\nSchritt 6: Mergen der übrigen Feature-Branches Legt nun die Reihenfolge fest, in der die übrigen Feature-Branches auf develop gemergt werden sollen. Führt die folgenden Schritte jeweils vollständig aus, bevor ihr mit dem nächsten Branch startet.\nWechselt auf den Pull Request. Kontrolliert den aktuellen Zusatnd (es sollten Konflikte vorhanden sein). Überprüft den Code mit diff. Löst den Konflikt manuell oder folgt den Empfehlungen von Bitbucket. Genehmigt den Pull Request, wenn der Konflikt gelöst ist. (Achtung, das kann nicht der Ersteller des Pull Requests machen!) Führt Merge auf develop aus. Wiederholt Punkt 1 bis 6 für den nächsten Pull Request. Schritt 7: Überprüfen des finalen Standes Geht nun zum develop Branch und überprüft, ob alle Änderungen korrekt übernommen wurden. In der Praxis sollten Tests (Unittests und/oder integrative Tests) existieren, die ohne Fehler ausführbar sein müssen.\n","categories":"","description":"Aufgabe Zusammenarbeit an einem Projekt mit Merge-Konflikten [Git Vertiefung](../../../../docs/04_git/02_vertiefung/02_zusammenarbeit)\n","excerpt":"Aufgabe Zusammenarbeit an einem Projekt mit Merge-Konflikten [Git …","ref":"/de/labs/04_git/02_vertiefung/04_merge-conflict/","tags":"","title":"Aufgabe: Arbeiten im Team an einem Projekt"},{"body":"Ziele Du weisst, was ein Template ist. Du weisst, für was ng-container und ng-template verwendet werden und kannst diese anwenden. Was ist ein Template? In Angular ist das Template der Teil eines Components, der die Benutzeroberfläche definiert. Es ist im Wesentlichen das HTML, das vom Component angezeigt wird und mit dem der Benutzer interagieren kann.\nDas Template kann jedoch mehr als nur HTML enthalten. Es kann auch angularspezifische Syntax wie Template Styling, Directives, Pipes, Interpolationen und Bindings enthalten, die die Funktionalität und das Verhalten des Components bestimmen.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u003cdiv\u003e \u003ch1\u003eHello, {{ name }}!\u003c/h1\u003e \u003cdiv *ngIf=\"name === 'Dragon Warrior'; else otherName\"\u003e \u003cp\u003eWelcome to the battle against the enemy Angular!\u003c/p\u003e \u003cp\u003eMay your path be filled with glory and triumph!\u003c/p\u003e \u003c/div\u003e \u003cng-template #otherName\u003e \u003cp\u003e You are not the true Dragon Warrior. You are not worthy of this battle. \u003c/p\u003e \u003c/ng-template\u003e \u003cp\u003eAdditional content specific to all warriors...\u003c/p\u003e \u003cp\u003eFace your fears and embrace the challenges!\u003c/p\u003e \u003c/div\u003e Was ist das DOM Das Document Object Model (DOM) ist eine Programmierschnittstelle, die eine strukturierte Darstellung des HTML zur Verfügung stellt. Es stellt eine Baumstruktur dar, in der jedes Element im HTML als Knoten (Node) repräsentiert wird.\nDurch die Verwendung des DOMs können Entwickler dynamische Webseiten erstellen, auf Benutzerinteraktionen reagieren, Inhalte ändern und vieles mehr. Es ermöglicht die Trennung von Inhalt (HTML), Präsentation (CSS) und Verhalten (JavaScript), was eine flexible und interaktive Webentwicklung ermöglicht.\nng-container \u0026 ng-template Durch die Verwendung von ng-container und ng-template kann der HTML-Code in Components besser strukturiert, lesbarer und wiederverwendbarer gemacht werden. Sie bieten eine flexible Möglichkeit, Inhalte bedingt anzuzeigen, dynamische Templates zu erstellen und den Code effizienter zu gestalten.\nng-container und ng-template erzeugen kein zusätzliches HTML-Element im DOM, was bedeutet, dass man nur den HTML-Code innerhalb der beiden im DOM sieht, insofern diese aktiv sind. Das eignet sich gut, wenn man andere Directives wie *ngIf, *ngFor oder *ngSwitch verwenden möchte.\nUm das else-Statement in Kombination mit ngIf zu verwenden, definiert man einen Template-Verweis (Referenz) mit einem #-Präfix und verwendet ihn in einem ng-template. Somit kann man aussagen, dass wenn die Condition nicht zutrifft, man ein anderes Template anzeigen möchte.\nWenn man ng-container und ng-template verwendet, ist vielfach auch ein *ngTemplateOutlet im Spiel. *ngTemplateOutlet ist ein Directive, welches verwendet wird, um ein Template an einer bestimmten Stelle in einem Template eines Components einzusetzen. Es wird verwendet, wenn man nicht mit *ngif arbeiten muss (oder will, weil die Bedingung immer true sein sollte). Es ist wie im else ein Template-Verweis.\n1 2 3 4 5 6 7 8 import { Component } from \"@angular/core\"; @Component({ // .. }) export class GreetingComponent { name: string = \"Dragon Warrior\"; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u003cdiv\u003e \u003ch1\u003eHello, {{ name }}!\u003c/h1\u003e \u003cng-container *ngIf=\"name === 'Dragon Warrior'; else otherName\"\u003e \u003cng-container *ngTemplateOutlet=\"dragonWarrior\"\u003e\u003c/ng-container\u003e \u003c/ng-container\u003e \u003cng-template #dragonWarrior\u003e \u003cp\u003eWelcome to the battle against the enemy Angular!\u003c/p\u003e \u003cp\u003eMay your path be filled with glory and triumph!\u003c/p\u003e \u003c/ng-template\u003e \u003cng-template #otherName\u003e \u003cp\u003e You are not the true Dragon Warrior. You are not worthy of this battle. \u003c/p\u003e \u003c/ng-template\u003e \u003cp\u003eAdditional content specific to all warriors...\u003c/p\u003e \u003cp\u003eFace your fears and embrace the challenges!\u003c/p\u003e \u003c/div\u003e Wenn der obenstehende Code gerendert wurde, sieht man das im DOM nun nur der div-tag, der h1-tag und die beiden p-tags zu sehen sind, das ng-container und ng-template nicht.\n","categories":"","description":"Modul #F6 - Angular - Templates\n","excerpt":"Modul #F6 - Angular - Templates\n","ref":"/docs/03_web/06_angular/02_5_templates/","tags":"","title":"Templates"},{"body":"Ziele Du weisst, was ein Template ist. Du weisst, für was ng-container und ng-template verwendet werden und kannst diese anwenden. Was ist ein Template? In Angular ist das Template der Teil eines Components, der die Benutzeroberfläche definiert. Es ist im Wesentlichen das HTML, das vom Component angezeigt wird und mit dem der Benutzer interagieren kann.\nDas Template kann jedoch mehr als nur HTML enthalten. Es kann auch angularspezifische Syntax wie Template Styling, Directives, Pipes, Interpolationen und Bindings enthalten, die die Funktionalität und das Verhalten des Components bestimmen.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u003cdiv\u003e \u003ch1\u003eHello, {{ name }}!\u003c/h1\u003e \u003cdiv *ngIf=\"name === 'Dragon Warrior'; else otherName\"\u003e \u003cp\u003eWelcome to the battle against the enemy Angular!\u003c/p\u003e \u003cp\u003eMay your path be filled with glory and triumph!\u003c/p\u003e \u003c/div\u003e \u003cng-template #otherName\u003e \u003cp\u003e You are not the true Dragon Warrior. You are not worthy of this battle. \u003c/p\u003e \u003c/ng-template\u003e \u003cp\u003eAdditional content specific to all warriors...\u003c/p\u003e \u003cp\u003eFace your fears and embrace the challenges!\u003c/p\u003e \u003c/div\u003e Was ist das DOM Das Document Object Model (DOM) ist eine Programmierschnittstelle, die eine strukturierte Darstellung des HTML zur Verfügung stellt. Es stellt eine Baumstruktur dar, in der jedes Element im HTML als Knoten (Node) repräsentiert wird.\nDurch die Verwendung des DOMs können Entwickler dynamische Webseiten erstellen, auf Benutzerinteraktionen reagieren, Inhalte ändern und vieles mehr. Es ermöglicht die Trennung von Inhalt (HTML), Präsentation (CSS) und Verhalten (JavaScript), was eine flexible und interaktive Webentwicklung ermöglicht.\nng-container \u0026 ng-template Durch die Verwendung von ng-container und ng-template kann der HTML-Code in Components besser strukturiert, lesbarer und wiederverwendbarer gemacht werden. Sie bieten eine flexible Möglichkeit, Inhalte bedingt anzuzeigen, dynamische Templates zu erstellen und den Code effizienter zu gestalten.\nng-container und ng-template erzeugen kein zusätzliches HTML-Element im DOM, was bedeutet, dass man nur den HTML-Code innerhalb der beiden im DOM sieht, insofern diese aktiv sind. Das eignet sich gut, wenn man andere Directives wie *ngIf, *ngFor oder *ngSwitch verwenden möchte.\nUm das else-Statement in Kombination mit ngIf zu verwenden, definiert man einen Template-Verweis (Referenz) mit einem #-Präfix und verwendet ihn in einem ng-template. Somit kann man aussagen, dass wenn die Condition nicht zutrifft, man ein anderes Template anzeigen möchte.\nWenn man ng-container und ng-template verwendet, ist vielfach auch ein *ngTemplateOutlet im Spiel. *ngTemplateOutlet ist ein Directive, welches verwendet wird, um ein Template an einer bestimmten Stelle in einem Template eines Components einzusetzen. Es wird verwendet, wenn man nicht mit *ngif arbeiten muss (oder will, weil die Bedingung immer true sein sollte). Es ist wie im else ein Template-Verweis.\n1 2 3 4 5 6 7 8 import { Component } from \"@angular/core\"; @Component({ // .. }) export class GreetingComponent { name: string = \"Dragon Warrior\"; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u003cdiv\u003e \u003ch1\u003eHello, {{ name }}!\u003c/h1\u003e \u003cng-container *ngIf=\"name === 'Dragon Warrior'; else otherName\"\u003e \u003cng-container *ngTemplateOutlet=\"dragonWarrior\"\u003e\u003c/ng-container\u003e \u003c/ng-container\u003e \u003cng-template #dragonWarrior\u003e \u003cp\u003eWelcome to the battle against the enemy Angular!\u003c/p\u003e \u003cp\u003eMay your path be filled with glory and triumph!\u003c/p\u003e \u003c/ng-template\u003e \u003cng-template #otherName\u003e \u003cp\u003e You are not the true Dragon Warrior. You are not worthy of this battle. \u003c/p\u003e \u003c/ng-template\u003e \u003cp\u003eAdditional content specific to all warriors...\u003c/p\u003e \u003cp\u003eFace your fears and embrace the challenges!\u003c/p\u003e \u003c/div\u003e Wenn der obenstehende Code gerendert wurde, sieht man das im DOM nun nur der div-tag, der h1-tag und die beiden p-tags zu sehen sind, das ng-container und ng-template nicht.\n","categories":"","description":"Modul #F6 - Angular - Templates\n","excerpt":"Modul #F6 - Angular - Templates\n","ref":"/de/docs/03_web/06_angular/02_5_templates/","tags":"","title":"Templates"},{"body":"Ziele Du kennst den Unterschied zwischen Vergleichs-Operatoren und logischen Operatoren. Du kennst spezielle Operatoren wie !!, ??, ??= und kannst diese anwenden. Vergleiches und logische Operatoren Vergleichsoperatoren (comparison operators) Vergleichsoperatoren werden verwendet, um den Wert zweier Variablen oder Ausdrücke miteinander zu vergleichen. Es existieren die folgenden Vergleichsoperatoren:\nGleichheit (==) Ungleichheit (!=) Strikte Gleichheit (===) Strikte Ungleichheit (!==) Grösser als (\u003e) Kleiner als (\u003c) Grösser-Gleich (\u003e=) Kleiner-Gleich (\u003c=) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 const a = 5; const b = 10; const c = \"5\"; const d = 10; // Gleichheit console.log(a == b); // false console.log(a == c); // true // Ungleichheit console.log(a != b); // true //Strikte Gleichheit console.log(a === b); // false console.log(a === c); // false // Strikte Ungleichheit console.log(a !== b); // true // Grösser als console.log(a \u003e b); // false // Kleiner als console.log(a \u003c b); // true // Grösser-Gleich console.log(a \u003e= b); // false console.log(b \u003e= d); // true // Kleiner-Gleich console.log(a \u003c= b); // true console.log(b \u003c= d); // true Unterschiede von Gleichheit und strikter Gleichheit Das doppelte Gleichheitszeichen == führt einen “schwachen” Vergleich durch. Das bedeutet konkret, dass JavaScript bei der Verwendung des doppelten Gleichheitszeichens versucht, den Wert beider Operanden zu vergleichen, indem es sie in einen gemeinsamen Typen konvertiert. Wenn die Operanden unterschiedliche Datentypen haben, führt JavaScript implizite Typumwandlungen durch, um sie zu vergleichen. Das dreifache Gleichheitszeichen === führt einen “starken” Vergleich durch. Das bedeutet konkret, dass JavaScript bei der Verwendung des dreifachen Gleichheitszeichens nicht nur den Wert der Operanden vergleicht, sondern auch ihren Datentyp im Vergleich berücksichtigt. Sollten die Operanden unterschiedliche Datentypen haben, wird als Ergebnis eines Vergleichs mit dem dreifachen Gleichheitszeichen immer false resultieren. Hier sind einige Beispiele, die den Unterschied zwischen == und === genauer veranschaulichen:\n1 2 3 4 5 6 7 8 console.log(5 == \"5\"); // true console.log(5 === \"5\"); // false console.log(true == 1); // true, weil Binär die 0 für `false` steht und alles über 0 als `true` validiert wird console.log(true === 1); // false console.log(null == undefined); // true console.log(null === undefined); // false Logische Operatoren (logical operators) Logische Operatoren werden verwendet, um mehrere Bedingungen miteinander zu kombinieren und Ausdrücke zu evaluieren. Hierbei gibt es folgende Operatoren:\nBitwise AND (\u0026) AND (\u0026\u0026) Bitwise OR (|) OR (||) NOT (!) Bitwise AND Der bitwise AND-Operator vergleicht jedes Bit in den beiden Operanden und gibt für jede Bitposition im Ergebnis eine 1 zurück, wenn sowohl der linke als auch der rechte Operand an dieser Bitposition eine 1 haben. Wenn der linke oder der rechte Operand eine 0 an dieser Bitposition hat, gibt der bitweise AND-Operator auch eine 0 zurück.\nBeispiel:\n1 2 3 4 5 const a = 5; // 00000000000000000000000000000101 const b = 3; // 00000000000000000000000000000011 console.log(a \u0026 b); // 00000000000000000000000000000001 // Expected output: 1 AND (logisches AND) Der AND-Operator wird verwendet, um zu überprüfen, ob alle Operanden, auf die er angewandt wird, true sind. Wenn ja, gibt er den Wert true zurück, andernfalls gibt er false zurück. Der Operator wird häufig in Bedingungen verwendet, um zu überprüfen, ob mehrere Bedingungen erfüllt sind, bevor eine Aktion ausgeführt wird.\nBeispiel:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 const a = 5; const b = 10; if (a \u003e 0 \u0026\u0026 b == 15) { // Wenn beide Bedingungen true sind, wird der folgende Codeblock ausgeführt console.log(\"1\"); } else if (a \u003e 0 \u0026\u0026 b == 10) { // Wenn beide Bedingungen true sind, wird der folgende Codeblock ausgeführt console.log(\"2\"); } else { // Wenn beide Bedingungen nicht true sind, wird der folgende Codeblock ausgeführt console.log(\"3\"); } // Expected output: '2' Bitwise OR Der bitweise OR-Operator vergleicht jedes Bit innerhalb der beiden Operanden und gibt für jede Bitposition im Ergebnis eine 1 zurück, wenn entweder der linke oder der rechte Operand oder beide Operanden an dieser Bitposition eine 1 haben. Wenn sowohl der linke als auch der rechte Operand an dieser Bitposition eine 0 haben, gibt der bitweise OR-Operator eine 0 zurück.\nBeispiel:\n1 2 3 4 5 const a = 5; // 00000000000000000000000000000101 const b = 3; // 00000000000000000000000000000011 console.log(a | b); // 00000000000000000000000000000111 // Expected output: 7 OR (logisches OR) Der OR-Operator wird verwendet, um zu überprüfen, ob mindestens einer der Operanden, auf die er angewendet wird, wahr ist. Wenn ja, gibt er den Wert true zurück, andernfalls gibt er false zurück. Der Operator wird häufig in Bedingungen verwendet, um alternative Bedingungen zu überprüfen und eine Aktion auszuführen, wenn mindestens eine der Bedingungen erfüllt ist.\nBeispiel:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 const a = 5; const b = 10; if (a \u003c 0 || b == 15) { // Wenn eine der Bedingungen true ist, wird der folgende Codeblock ausgeführt console.log(\"1\"); } else if (a \u003e 0 || b == 15) { // Wenn eine der Bedingungen true ist, wird der folgende Codeblock ausgeführt console.log(\"2\"); } else { // Wenn beide Bedingungen nicht true sind, wird der folgende Codeblock ausgeführt console.log(\"3\"); } // Expected output: '2' NOT (logisches NOT) Der NOT-Operator wird verwendet, um einen booleschen Wert umzukehren, was heisst, dass true zu false und false zu true wird. Wenn ein Operand true ist, gibt der Operator false zurück, und wenn der Operand false ist, gibt er true zurück. Der Operator wird häufig in Bedingungen verwendet, um die Aussage einer Bedingung umzukehren.\nBeispiel:\n1 2 3 4 5 6 7 8 9 10 11 const a = 5; const b = 10; if (!(a \u003e 0 \u0026\u0026 b == 10)) { console.log(\"1\"); } else if (!(a \u003e 0 \u0026\u0026 b == 15)) { console.log(\"2\"); } else { console.log(\"3\"); } // Expected output: '2' Special Operators doppeltes NOT (!!) Der doppelte NOT-Operator wird verwendet, um einen Wert in einen booleschen Wert umzuwandeln. Die erste Negation kehrt den Wert um und die zweite Negation kehrt ihn wieder zurück, sodass der resultierende Wert immer ein boolescher Ausdruck ist. War der ursprüngliche Wert truthy, so wird das Ergebnis true sein, andernfalls false. Der doppelte Negationsoperator wird häufig verwendet, um sicherzustellen, dass ein Wert wirklich einem booleschen Ausdruck entspricht.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 console.log(0); // 0 console.log(!!0); // false console.log(1); // 1 console.log(!!1); // true console.log(-1); // -1 console.log(!!-1); // true console.log(1 / 0); // Infinity console.log(!!(1 / 0)); // true console.log(parseInt(\"js\")); // NaN console.log(!!parseInt(\"js\")); // false console.log(\"\"); // '' console.log(!!\"\"); // false console.log(\"js\"); // 'js' console.log(!!\"js\"); // true console.log(\"false\"); // 'false' console.log(!!\"false\"); // true auch wenn es einen falsy value hat console.log(person.name); // undefined console.log(!!person.name); // false console.log(undefined); // undefined console.log(!!undefined); // false console.log(null); // null console.log(!!null); // false console.log({}); // {} console.log(!!{}); // true console.log([]); // [] console.log(!![]); // true Logischer OR Assignment Operator (||=) Der Operator ||= prüft, ob die linke Seite des Operators falsy ist. Wenn die linke Seite falsy ist, wird der rechte Operand ausgewertet und der Wert diesem zugewiesen. Wenn die linke Seite truthy ist, wird der linke Wert beibehalten und kein weiterer Ausdruck ausgewertet.\nBeispiel:\n1 2 3 4 5 6 7 8 let falsyVariable = \"\"; let truthyVariable = \"Welt!\"; falsyVariable ||= \"Hallo\"; truthyVariable ||= \"Mensch\"; console.log(falsyVariable); // 'Hallo' console.log(truthyVariable); // 'Welt!' Logischer AND Assignment Operator (\u0026\u0026=) Der Operator \u0026\u0026= prüft, ob die linke Seite des Operators truthy ist. Wenn die linke Seite truthy ist, wird der rechte Operand ausgewertet und der Wert diesem zugewiesen. Wenn die linke Seite falsy ist, wird der linke Wert beibehalten und kein weiterer Ausdruck ausgewertet.\nBeispiel:\n1 2 3 4 5 6 7 8 let falsyVariable = \"\"; let truthyVariable = \"Welt!\"; falsyVariable \u0026\u0026= \"Hallo\"; truthyVariable \u0026\u0026= \"Mensch\"; console.log(falsyVariable); // '' console.log(truthyVariable); // 'Mensch' nullish coalescing Assignment Operator (??=) Der Operator ??= prüft, ob die linke Seite des Operators null oder undefined ist. Wenn die linke Seite null oder undefined ist, wird der rechte Operand ausgewertet und der Wert diesem zugewiesen. Wenn die linke Seite einen anderen falsy Wert als null oder undefined hat, wird der linke Wert beibehalten und kein weiterer Ausdruck ausgewertet.\nBeispiel:\n1 2 3 4 5 6 7 8 let nullVariable = null; let falsyVariable = \"\"; nullVariable ??= \"hello\"; falsyVariable ??= \"world\"; console.log(nullVariable); // \"hello\" console.log(falsyVariable); // \"\" nullish coalescing Operator (??) Der Operator ?? gibt den linken Ausdruck zurück, wenn er null oder undefined ergibt, andernfalls gibt er den rechten Ausdruck zurück. Im Gegensatz zum logischen OR-Operator (||) behandelt der Nullish Coalescing-Operator nur null und undefined als falsy Werte, und alle anderen Werte werden als truthy behandelt.\nBeispiel:\n1 2 3 4 5 6 7 8 9 10 11 const nullCheck = null ?? \"left is null\"; console.log(nullCheck); // 'left is null' const zeroCheck = 0 ?? 42; console.log(zeroCheck); // 0 const undefinedCheck = undefined ?? \"left is undefined\"; console.log(undefinedCheck); // 'left is undefined' const emptyStringCheck = \"\" ?? \"empty string\"; console.log(emptyStringCheck); // '' weil ein leerer String zwar falsy aber nicht null oder undefined ist ternary Operator (?:) Der Ternary-Operator (?:) ermöglicht es, eine Zuweisung kombiniert mit einer Bedingung (if/else) auf eine einzige Anweisung zu reduzieren.\nSchauen wir uns hierfür folgendes Beispiel an, für das eine if/else-Struktur umgesetzt wird:\n1 2 3 4 5 6 7 8 9 10 const age = 18; let canVote; if (age \u003e= 18) { canVote = \"yes\"; } else { canVote = \"no\"; } console.log(canVote); // 'yes' Hier haben wir 6 Zeilen Code gebraucht, um bedingt eine Variable zu setzen. Mit dem ternary-Operator können wir das Ganze auf eine Zeile reduzieren (und wir können direkt das Ergebnis per const zuweisen):\n1 2 3 4 5 const age = 18; const canVote = age \u003e= 18 ? \"yes\" : \"no\"; console.log(canVote); // 'yes' Oft wird diese Syntax bei Zuweisungen verwendet, kann aber auch anderorts verwendet werden, beispielsweise für Parameter:\nBeispiel:\n1 2 const oddNumber = 5; console.log(oddNumber % 2 === 0 ? \"even\" : \"odd\"); // 'odd' Ganz allgemein lautet die Syntax:\n1 condition ? expression1 : expression2; Zuerst wird die Bedingung (condition) ausgewertet. Wenn diese true entspricht, wird expression1 ausgeführt und zurückgegeben, andernfalls expression2.\n","categories":"","description":"Modul #F4 - JavaScript - Operatoren.\n","excerpt":"Modul #F4 - JavaScript - Operatoren.\n","ref":"/docs/03_web/03_javascript/06_operators/","tags":"","title":"Operatoren"},{"body":"Ziele Du kennst den Unterschied zwischen Vergleichs-Operatoren und logischen Operatoren. Du kennst spezielle Operatoren wie !!, ??, ??= und kannst diese anwenden. Vergleiches und logische Operatoren Vergleichsoperatoren (comparison operators) Vergleichsoperatoren werden verwendet, um den Wert zweier Variablen oder Ausdrücke miteinander zu vergleichen. Es existieren die folgenden Vergleichsoperatoren:\nGleichheit (==) Ungleichheit (!=) Strikte Gleichheit (===) Strikte Ungleichheit (!==) Grösser als (\u003e) Kleiner als (\u003c) Grösser-Gleich (\u003e=) Kleiner-Gleich (\u003c=) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 const a = 5; const b = 10; const c = \"5\"; const d = 10; // Gleichheit console.log(a == b); // false console.log(a == c); // true // Ungleichheit console.log(a != b); // true //Strikte Gleichheit console.log(a === b); // false console.log(a === c); // false // Strikte Ungleichheit console.log(a !== b); // true // Grösser als console.log(a \u003e b); // false // Kleiner als console.log(a \u003c b); // true // Grösser-Gleich console.log(a \u003e= b); // false console.log(b \u003e= d); // true // Kleiner-Gleich console.log(a \u003c= b); // true console.log(b \u003c= d); // true Unterschiede von Gleichheit und strikter Gleichheit Das doppelte Gleichheitszeichen == führt einen “schwachen” Vergleich durch. Das bedeutet konkret, dass JavaScript bei der Verwendung des doppelten Gleichheitszeichens versucht, den Wert beider Operanden zu vergleichen, indem es sie in einen gemeinsamen Typen konvertiert. Wenn die Operanden unterschiedliche Datentypen haben, führt JavaScript implizite Typumwandlungen durch, um sie zu vergleichen. Das dreifache Gleichheitszeichen === führt einen “starken” Vergleich durch. Das bedeutet konkret, dass JavaScript bei der Verwendung des dreifachen Gleichheitszeichens nicht nur den Wert der Operanden vergleicht, sondern auch ihren Datentyp im Vergleich berücksichtigt. Sollten die Operanden unterschiedliche Datentypen haben, wird als Ergebnis eines Vergleichs mit dem dreifachen Gleichheitszeichen immer false resultieren. Hier sind einige Beispiele, die den Unterschied zwischen == und === genauer veranschaulichen:\n1 2 3 4 5 6 7 8 console.log(5 == \"5\"); // true console.log(5 === \"5\"); // false console.log(true == 1); // true, weil Binär die 0 für `false` steht und alles über 0 als `true` validiert wird console.log(true === 1); // false console.log(null == undefined); // true console.log(null === undefined); // false Logische Operatoren (logical operators) Logische Operatoren werden verwendet, um mehrere Bedingungen miteinander zu kombinieren und Ausdrücke zu evaluieren. Hierbei gibt es folgende Operatoren:\nBitwise AND (\u0026) AND (\u0026\u0026) Bitwise OR (|) OR (||) NOT (!) Bitwise AND Der bitwise AND-Operator vergleicht jedes Bit in den beiden Operanden und gibt für jede Bitposition im Ergebnis eine 1 zurück, wenn sowohl der linke als auch der rechte Operand an dieser Bitposition eine 1 haben. Wenn der linke oder der rechte Operand eine 0 an dieser Bitposition hat, gibt der bitweise AND-Operator auch eine 0 zurück.\nBeispiel:\n1 2 3 4 5 const a = 5; // 00000000000000000000000000000101 const b = 3; // 00000000000000000000000000000011 console.log(a \u0026 b); // 00000000000000000000000000000001 // Expected output: 1 AND (logisches AND) Der AND-Operator wird verwendet, um zu überprüfen, ob alle Operanden, auf die er angewandt wird, true sind. Wenn ja, gibt er den Wert true zurück, andernfalls gibt er false zurück. Der Operator wird häufig in Bedingungen verwendet, um zu überprüfen, ob mehrere Bedingungen erfüllt sind, bevor eine Aktion ausgeführt wird.\nBeispiel:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 const a = 5; const b = 10; if (a \u003e 0 \u0026\u0026 b == 15) { // Wenn beide Bedingungen true sind, wird der folgende Codeblock ausgeführt console.log(\"1\"); } else if (a \u003e 0 \u0026\u0026 b == 10) { // Wenn beide Bedingungen true sind, wird der folgende Codeblock ausgeführt console.log(\"2\"); } else { // Wenn beide Bedingungen nicht true sind, wird der folgende Codeblock ausgeführt console.log(\"3\"); } // Expected output: '2' Bitwise OR Der bitweise OR-Operator vergleicht jedes Bit innerhalb der beiden Operanden und gibt für jede Bitposition im Ergebnis eine 1 zurück, wenn entweder der linke oder der rechte Operand oder beide Operanden an dieser Bitposition eine 1 haben. Wenn sowohl der linke als auch der rechte Operand an dieser Bitposition eine 0 haben, gibt der bitweise OR-Operator eine 0 zurück.\nBeispiel:\n1 2 3 4 5 const a = 5; // 00000000000000000000000000000101 const b = 3; // 00000000000000000000000000000011 console.log(a | b); // 00000000000000000000000000000111 // Expected output: 7 OR (logisches OR) Der OR-Operator wird verwendet, um zu überprüfen, ob mindestens einer der Operanden, auf die er angewendet wird, wahr ist. Wenn ja, gibt er den Wert true zurück, andernfalls gibt er false zurück. Der Operator wird häufig in Bedingungen verwendet, um alternative Bedingungen zu überprüfen und eine Aktion auszuführen, wenn mindestens eine der Bedingungen erfüllt ist.\nBeispiel:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 const a = 5; const b = 10; if (a \u003c 0 || b == 15) { // Wenn eine der Bedingungen true ist, wird der folgende Codeblock ausgeführt console.log(\"1\"); } else if (a \u003e 0 || b == 15) { // Wenn eine der Bedingungen true ist, wird der folgende Codeblock ausgeführt console.log(\"2\"); } else { // Wenn beide Bedingungen nicht true sind, wird der folgende Codeblock ausgeführt console.log(\"3\"); } // Expected output: '2' NOT (logisches NOT) Der NOT-Operator wird verwendet, um einen booleschen Wert umzukehren, was heisst, dass true zu false und false zu true wird. Wenn ein Operand true ist, gibt der Operator false zurück, und wenn der Operand false ist, gibt er true zurück. Der Operator wird häufig in Bedingungen verwendet, um die Aussage einer Bedingung umzukehren.\nBeispiel:\n1 2 3 4 5 6 7 8 9 10 11 const a = 5; const b = 10; if (!(a \u003e 0 \u0026\u0026 b == 10)) { console.log(\"1\"); } else if (!(a \u003e 0 \u0026\u0026 b == 15)) { console.log(\"2\"); } else { console.log(\"3\"); } // Expected output: '2' Special Operators doppeltes NOT (!!) Der doppelte NOT-Operator wird verwendet, um einen Wert in einen booleschen Wert umzuwandeln. Die erste Negation kehrt den Wert um und die zweite Negation kehrt ihn wieder zurück, sodass der resultierende Wert immer ein boolescher Ausdruck ist. War der ursprüngliche Wert truthy, so wird das Ergebnis true sein, andernfalls false. Der doppelte Negationsoperator wird häufig verwendet, um sicherzustellen, dass ein Wert wirklich einem booleschen Ausdruck entspricht.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 console.log(0); // 0 console.log(!!0); // false console.log(1); // 1 console.log(!!1); // true console.log(-1); // -1 console.log(!!-1); // true console.log(1 / 0); // Infinity console.log(!!(1 / 0)); // true console.log(parseInt(\"js\")); // NaN console.log(!!parseInt(\"js\")); // false console.log(\"\"); // '' console.log(!!\"\"); // false console.log(\"js\"); // 'js' console.log(!!\"js\"); // true console.log(\"false\"); // 'false' console.log(!!\"false\"); // true auch wenn es einen falsy value hat console.log(person.name); // undefined console.log(!!person.name); // false console.log(undefined); // undefined console.log(!!undefined); // false console.log(null); // null console.log(!!null); // false console.log({}); // {} console.log(!!{}); // true console.log([]); // [] console.log(!![]); // true Logischer OR Assignment Operator (||=) Der Operator ||= prüft, ob die linke Seite des Operators falsy ist. Wenn die linke Seite falsy ist, wird der rechte Operand ausgewertet und der Wert diesem zugewiesen. Wenn die linke Seite truthy ist, wird der linke Wert beibehalten und kein weiterer Ausdruck ausgewertet.\nBeispiel:\n1 2 3 4 5 6 7 8 let falsyVariable = \"\"; let truthyVariable = \"Welt!\"; falsyVariable ||= \"Hallo\"; truthyVariable ||= \"Mensch\"; console.log(falsyVariable); // 'Hallo' console.log(truthyVariable); // 'Welt!' Logischer AND Assignment Operator (\u0026\u0026=) Der Operator \u0026\u0026= prüft, ob die linke Seite des Operators truthy ist. Wenn die linke Seite truthy ist, wird der rechte Operand ausgewertet und der Wert diesem zugewiesen. Wenn die linke Seite falsy ist, wird der linke Wert beibehalten und kein weiterer Ausdruck ausgewertet.\nBeispiel:\n1 2 3 4 5 6 7 8 let falsyVariable = \"\"; let truthyVariable = \"Welt!\"; falsyVariable \u0026\u0026= \"Hallo\"; truthyVariable \u0026\u0026= \"Mensch\"; console.log(falsyVariable); // '' console.log(truthyVariable); // 'Mensch' nullish coalescing Assignment Operator (??=) Der Operator ??= prüft, ob die linke Seite des Operators null oder undefined ist. Wenn die linke Seite null oder undefined ist, wird der rechte Operand ausgewertet und der Wert diesem zugewiesen. Wenn die linke Seite einen anderen falsy Wert als null oder undefined hat, wird der linke Wert beibehalten und kein weiterer Ausdruck ausgewertet.\nBeispiel:\n1 2 3 4 5 6 7 8 let nullVariable = null; let falsyVariable = \"\"; nullVariable ??= \"hello\"; falsyVariable ??= \"world\"; console.log(nullVariable); // \"hello\" console.log(falsyVariable); // \"\" nullish coalescing Operator (??) Der Operator ?? gibt den linken Ausdruck zurück, wenn er null oder undefined ergibt, andernfalls gibt er den rechten Ausdruck zurück. Im Gegensatz zum logischen OR-Operator (||) behandelt der Nullish Coalescing-Operator nur null und undefined als falsy Werte, und alle anderen Werte werden als truthy behandelt.\nBeispiel:\n1 2 3 4 5 6 7 8 9 10 11 const nullCheck = null ?? \"left is null\"; console.log(nullCheck); // 'left is null' const zeroCheck = 0 ?? 42; console.log(zeroCheck); // 0 const undefinedCheck = undefined ?? \"left is undefined\"; console.log(undefinedCheck); // 'left is undefined' const emptyStringCheck = \"\" ?? \"empty string\"; console.log(emptyStringCheck); // '' weil ein leerer String zwar falsy aber nicht null oder undefined ist ternary Operator (?:) Der Ternary-Operator (?:) ermöglicht es, eine Zuweisung kombiniert mit einer Bedingung (if/else) auf eine einzige Anweisung zu reduzieren.\nSchauen wir uns hierfür folgendes Beispiel an, für das eine if/else-Struktur umgesetzt wird:\n1 2 3 4 5 6 7 8 9 10 const age = 18; let canVote; if (age \u003e= 18) { canVote = \"yes\"; } else { canVote = \"no\"; } console.log(canVote); // 'yes' Hier haben wir 6 Zeilen Code gebraucht, um bedingt eine Variable zu setzen. Mit dem ternary-Operator können wir das Ganze auf eine Zeile reduzieren (und wir können direkt das Ergebnis per const zuweisen):\n1 2 3 4 5 const age = 18; const canVote = age \u003e= 18 ? \"yes\" : \"no\"; console.log(canVote); // 'yes' Oft wird diese Syntax bei Zuweisungen verwendet, kann aber auch anderorts verwendet werden, beispielsweise für Parameter:\nBeispiel:\n1 2 const oddNumber = 5; console.log(oddNumber % 2 === 0 ? \"even\" : \"odd\"); // 'odd' Ganz allgemein lautet die Syntax:\n1 condition ? expression1 : expression2; Zuerst wird die Bedingung (condition) ausgewertet. Wenn diese true entspricht, wird expression1 ausgeführt und zurückgegeben, andernfalls expression2.\n","categories":"","description":"Modul #F4 - JavaScript - Operatoren.\n","excerpt":"Modul #F4 - JavaScript - Operatoren.\n","ref":"/de/docs/03_web/03_javascript/06_operators/","tags":"","title":"Operatoren"},{"body":"","categories":"","description":"Exams zu TypeScript und Angular.\n","excerpt":"Exams zu TypeScript und Angular.\n","ref":"/exams/03_web/06_angular/","tags":"","title":"Angular Exams"},{"body":"","categories":"","description":"Exams zu TypeScript und Angular.\n","excerpt":"Exams zu TypeScript und Angular.\n","ref":"/de/exams/03_web/06_angular/","tags":"","title":"Angular Exams"},{"body":"","categories":"","description":"Angular lernen\n","excerpt":"Angular lernen\n","ref":"/docs/03_web/06_angular/","tags":"","title":"Angular"},{"body":"","categories":"","description":"Angular lernen\n","excerpt":"Angular lernen\n","ref":"/de/docs/03_web/06_angular/","tags":"","title":"Angular"},{"body":"Annotationen in Spring Annotationen in Spring sind spezielle Markierungen im Code, die verwendet werden, um Metadaten bereitzustellen und das Verhalten von Klassen, Methoden oder Feldern zu konfigurieren. Sie helfen dabei, den Code sauberer und lesbarer zu machen, indem sie die Konfiguration direkt in den Code integrieren, anstatt sie in separaten XML-Dateien zu verwalten.\nEinige häufig verwendete Annotationen in Spring sind:\n@Component @Autowired @Service und @Repository @Controller Durch die Verwendung von Annotationen können Entwickler die Konfiguration und das Verhalten ihrer Spring-Anwendungen direkt im Code definieren, was die Entwicklung und Wartung erleichtert.\nDie verschiedenen Arten von Annotationen Spring Annotationen @Configuration: In Spring wird diese Annotation verwendet, um eine Klasse als Konfigurationsklasse zu markieren. Das bedeutet, dass diese Klasse Methoden enthalten kann, die Beans definieren und konfigurieren. Wenn Spring eine solche Klasse sieht, wird sie verwendet, um die Beans zu erstellen und zu verwalten, die für die Anwendung benötigt werden.\n@Bean: Die Annotation @Bean in Spring wird verwendet, um eine Methode in einer @Configuration-Klasse zu kennzeichnen, die eine Bean definiert und zurückgibt. Wenn Spring diese Methode aufruft, erstellt es das zurückgegebene Objekt als Bean und verwaltet es im Spring IoC Container. Dadurch kannst du die Erstellung und Konfiguration von Beans zentral in deiner Konfigurationsklasse steuern.\n@Component: Diese Annotation wird in Spring verwendet, um eine Klasse als Bean zu markieren, die vom Spring IoC Container verwaltet werden soll. Wenn Spring eine Klasse mit dieser Annotation findet, wird sie automatisch instanziiert und als Bean registriert. Das bedeutet, dass du diese Klasse nicht manuell konfigurieren musst, sondern Spring kümmert sich um die Erstellung und Verwaltung. @Component ist eine generische Annotation, und es gibt spezialisierte Versionen wie @Service, @Repository und @Controller für spezifische Anwendungsfälle.\n@ComponentScan: Mit dieser Annotation in Spring kannst du festlegen, in welchen Paketen nach Komponenten wie @Component, @Service, @Repository und @Controller gesucht werden soll. Diese Annotation wird häufig in einer Konfigurationsklasse zusammen mit @Configuration verwendet. Beim Start der Anwendung scannt Spring die angegebenen Pakete und registriert automatisch alle gefundenen Komponenten als Beans im IoC Container. Dadurch wird die Verwaltung und Konfiguration der Anwendung vereinfacht, da du nicht jede Bean manuell definieren musst.\n@Autowired: Mit der Annotation @Autowired in Spring kannst du die automatische Injektion von Abhängigkeiten nutzen. Das bedeutet, dass Spring die benötigten Beans automatisch findet und sie in das markierte Feld, den Konstruktor oder die Methode einfügt. Dadurch entfällt die Notwendigkeit, Abhängigkeiten manuell zu instanziieren, was den Code sauberer und übersichtlicher macht. @Autowired erleichtert die Verwaltung von Abhängigkeiten und fördert die lose Kopplung in deiner Anwendung.\n@Service: Wird in Spring verwendet, um eine Klasse als Service-Komponente zu kennzeichnen. Services sind spezialisierte Komponenten, die Geschäftslogik enthalten und häufig als Vermittler zwischen dem Controller und dem Repository fungieren. Durch die Verwendung von @Service erkennt Spring die Klasse als Bean und verwaltet sie automatisch im IoC Container. Das ermöglicht eine saubere Trennung der Geschäftslogik von anderen Schichten der Anwendung und fördert die Wiederverwendbarkeit und Testbarkeit des Codes.\n@Repository: Diese Annotation wird verwendet, um eine Klasse in Spring als Datenzugriffsschicht zu markieren. Diese Annotation stellt sicher, dass die Klasse für Datenbankoperationen wie Speichern, Abrufen, Aktualisieren und Löschen verantwortlich ist. Wenn Spring eine Klasse mit @Repository entdeckt, wird sie als Bean registriert und es werden zusätzliche Funktionen wie die automatische Behandlung von Datenbankausnahmen aktiviert. Dies verbessert die Verwaltung von Datenbankzugriffen und gewährleistet eine klare Trennung zwischen der Datenzugriffsschicht und anderen Teilen der Anwendung.\nMVC Annotationen @Controller: Um eine Klasse in Spring als Web-Controller zu kennzeichnen, wird die Annotation @Controller verwendet. Diese Annotation zeigt an, dass die Klasse HTTP-Anfragen entgegennimmt und darauf reagiert. Ein Controller verarbeitet die eingehenden Anfragen, delegiert die Geschäftslogik an entsprechende Services und gibt die passenden Antworten zurück. Typischerweise werden in einem Controller Methoden mit weiteren Annotationen wie @GetMapping oder @PostMapping versehen, um spezifische Endpunkte und HTTP-Methoden zu definieren. Durch die Verwendung von @Controller wird die Klasse als Bean im Spring IoC Container registriert, was die Strukturierung und Verwaltung von Webanfragen innerhalb der Anwendung erleichtert.\n@RequestMapping: Es ermöglicht dir, in Spring HTTP-Anfragen bestimmten Methoden in deinem Controller zuzuordnen. Es gibt spezialisierte Versionen dieser Annotation für die verschiedenen HTTP-Methoden, die den Code lesbarer und spezifischer machen. Hier sind die 4 wichtigsten Varianten:\n@GetMapping: Verarbeitung von GET-Anfragen. Diese Anfragen werden typischerweise verwendet, um Daten abzurufen. @PostMapping: Verwendung für POST-Anfragen. Diese Anfragen werden oft verwendet, um neue Daten zu erstellen oder zu senden. @PutMapping: Wird verwendet, um PUT-Anfragen zu verarbeiten. Diese Anfragen dienen in der Regel dazu, vorhandene Daten zu aktualisieren. @DeleteMapping: Verarbeitung von DELETE-Anfragen. Diese Anfragen werden genutzt, um Daten zu löschen. Diese spezialisierten Annotationen machen deinen Code klarer und einfacher zu verstehen, indem sie explizit angeben, welche HTTP-Methode verwendet wird.\n@PathVariable: Mit @PathVariable kannst du in Spring Platzhalter in der URL eines HTTP-Requests direkt an Methodenparameter im Controller binden. Diese Annotation ermöglicht es dir, dynamische Teile der URL zu erfassen und in deiner Methode zu verwenden. Dies ist besonders nützlich, wenn du RESTful APIs entwickelst, bei denen Ressourcen über eindeutige Identifikatoren in der URL aufgerufen werden.\nZum Beispiel kannst du in einer URL wie /users/{id} den Wert des {id}-Platzhalters direkt in deine Methode einfügen, um den entsprechenden Benutzer zu verarbeiten. Indem du @PathVariable in deiner Methodensignatur verwendest, kannst du diesen Wert einfach abrufen und weiterverarbeiten.\n1 2 3 4 5 @GetMapping(\"/users/{id}\") public User getUserById(@PathVariable(\"id\") Long userId) { // Logik zur Verarbeitung des Benutzer-IDs return userService.findById(userId); } In diesem Beispiel wird der Wert des URL-Platzhalters {id} automatisch der Methode als Parameter userId übergeben, was die Handhabung von dynamischen URLs erleichtert und den Code klarer und lesbarer macht.\n@RequestParam: Wenn du HTTP-Request-Parameter an Methodenparameter im Controller binden möchtest, ist @RequestParam die richtige Wahl. Diese Annotation ermöglicht es dir, Werte aus der URL-Abfragezeichenfolge direkt in deine Methode zu integrieren und weiterzuverarbeiten. Das ist besonders hilfreich, wenn du Daten wie Filterkriterien, Suchbegriffe oder andere Parameter übergeben möchtest.\nZum Beispiel kannst du in einer URL wie /search?query=Spring den Wert des Query-Parameters query direkt in deiner Methode verwenden. Indem du @RequestParam in deiner Methodensignatur angibst, kannst du diesen Wert abrufen und damit arbeiten.\n1 2 3 4 5 @GetMapping(\"/search\") public String search(@RequestParam(\"query\") String searchQuery) { // Logik zur Verarbeitung des Suchbegriffs return \"Ergebnisse für: \" + searchQuery; } In diesem Beispiel wird der Wert des Query-Parameters query automatisch der Methode als Parameter searchQuery übergeben. Dies erleichtert die Handhabung von URL-Parametern und macht deinen Code klarer und besser strukturiert.\n@RequestBody: Um den Inhalt einer HTTP-Anfrage direkt an ein Methodenparameter zu binden, verwendest du @RequestBody in Spring. Diese Annotation ist besonders nützlich, wenn du JSON- oder XML-Daten von einem Client empfangen und in ein Java-Objekt umwandeln möchtest. @RequestBody sorgt dafür, dass der Inhalt des Anfragekörpers automatisch deserialisiert und dem entsprechenden Parameter zugewiesen wird.\nZum Beispiel, wenn du eine POST-Anfrage sendest, die JSON-Daten enthält, kannst du diese Daten direkt in deiner Methode verarbeiten:\n1 2 3 4 5 6 @PostMapping(\"/users\") public ResponseEntity\u003cUser\u003e createUser(@RequestBody User newUser) { // Logik zur Verarbeitung des neuen Benutzers userService.save(newUser); return ResponseEntity.ok(newUser); } In diesem Beispiel wird der JSON-Inhalt der POST-Anfrage in das User-Objekt newUser umgewandelt. Dies erleichtert die Arbeit mit komplexen Datenstrukturen und sorgt für einen klaren und übersichtlichen Code, indem die Umwandlung von JSON zu Java-Objekten automatisch von Spring übernommen wird.\n@RequestHeader: Mit @RequestHeader in Spring kannst du HTTP-Header-Werte direkt an Methodenparameter im Controller binden. Diese Annotation ermöglicht es dir, spezifische Header-Informationen aus einer Anfrage zu extrahieren und in deiner Methode zu verwenden. Das ist besonders nützlich, wenn du Metadaten wie Authentifizierungsinformationen, Content-Type oder andere benutzerdefinierte Header benötigst.\nZum Beispiel kannst du den Wert eines spezifischen HTTP-Headers wie User-Agent direkt in deiner Methode verarbeiten:\n1 2 3 4 5 @GetMapping(\"/user-agent\") public ResponseEntity\u003cString\u003e getUserAgent(@RequestHeader(\"User-Agent\") String userAgent) { // Logik zur Verarbeitung des User-Agent-Headers return ResponseEntity.ok(\"User-Agent: \" + userAgent); } In diesem Beispiel wird der Wert des User-Agent-Headers automatisch der Methode als Parameter userAgent übergeben. Dies erleichtert die Arbeit mit HTTP-Headern und macht deinen Code klarer und besser strukturiert.\nSpring Boot Annotationen @SpringBootApplication: Es ist eine zentrale Annotation in Spring Boot, die als Einstiegspunkt für die Anwendung dient. Diese Annotation fasst mehrere wichtige Konfigurationen zusammen und vereinfacht so den Start und die Konfiguration deiner Spring Boot Anwendung.\nHier sind die drei Hauptbestandteile, die @SpringBootApplication kombiniert:\n@Configuration: Markiert die Klasse als eine Quelle für Bean-Definitionen. @EnableAutoConfiguration: Aktiviert die automatische Konfiguration von Spring Boot, basierend auf den in der Abhängigkeiten angegebenen Bibliotheken. @ComponentScan: Ermöglicht das automatische Scannen und Registrieren von Beans in den angegebenen Paketen. Ein typisches Beispiel für den Einsatz von @SpringBootApplication sieht so aus:\n1 2 3 4 5 6 @SpringBootApplication public class MyApplication { public static void main(String args) { SpringApplication.run(MyApplication.class, args); } } In diesem Beispiel wird die MyApplication-Klasse als Ausgangspunkt für die Spring Boot Anwendung verwendet. Durch die Verwendung von @SpringBootApplication wird die Konfiguration vereinfacht und du kannst schnell eine lauffähige Spring-Anwendung erstellen, da die wichtigsten Einstellungen und Scans automatisch durchgeführt werden.\n@EnableAutoConfiguration: Um die automatische Konfiguration in einer Spring-Boot-Anwendung zu aktivieren, verwendest du @EnableAutoConfiguration. Diese Annotation sorgt dafür, dass Spring Boot die Konfigurationseinstellungen basierend auf den Abhängigkeiten, die sich im Klassenpfad befinden, automatisch übernimmt. Dies ermöglicht es dir, eine Spring-Anwendung schnell und einfach zu starten, ohne umfangreiche Konfigurationsdateien erstellen zu müssen.\nWenn du @EnableAutoConfiguration in deiner Hauptanwendungsklasse verwendest, durchsucht Spring Boot den Klassenpfad nach Bibliotheken und aktiviert automatisch die entsprechenden Konfigurationen. Zum Beispiel, wenn du eine Datenbankabhängigkeit hinzufügst, wird Spring Boot automatisch die Datenbankkonfiguration vornehmen.\n","categories":"","description":"Modul #J8 - Spring Framework - Was sind Annotationen und welche gibt es in Spring?\n","excerpt":"Modul #J8 - Spring Framework - Was sind Annotationen und welche gibt …","ref":"/docs/02_java/12_spring-framework/06_annotationen/","tags":"","title":"Annotationen"},{"body":"Annotationen in Spring Annotationen in Spring sind spezielle Markierungen im Code, die verwendet werden, um Metadaten bereitzustellen und das Verhalten von Klassen, Methoden oder Feldern zu konfigurieren. Sie helfen dabei, den Code sauberer und lesbarer zu machen, indem sie die Konfiguration direkt in den Code integrieren, anstatt sie in separaten XML-Dateien zu verwalten.\nEinige häufig verwendete Annotationen in Spring sind:\n@Component @Autowired @Service und @Repository @Controller Durch die Verwendung von Annotationen können Entwickler die Konfiguration und das Verhalten ihrer Spring-Anwendungen direkt im Code definieren, was die Entwicklung und Wartung erleichtert.\nDie verschiedenen Arten von Annotationen Spring Annotationen @Configuration: In Spring wird diese Annotation verwendet, um eine Klasse als Konfigurationsklasse zu markieren. Das bedeutet, dass diese Klasse Methoden enthalten kann, die Beans definieren und konfigurieren. Wenn Spring eine solche Klasse sieht, wird sie verwendet, um die Beans zu erstellen und zu verwalten, die für die Anwendung benötigt werden.\n@Bean: Die Annotation @Bean in Spring wird verwendet, um eine Methode in einer @Configuration-Klasse zu kennzeichnen, die eine Bean definiert und zurückgibt. Wenn Spring diese Methode aufruft, erstellt es das zurückgegebene Objekt als Bean und verwaltet es im Spring IoC Container. Dadurch kannst du die Erstellung und Konfiguration von Beans zentral in deiner Konfigurationsklasse steuern.\n@Component: Diese Annotation wird in Spring verwendet, um eine Klasse als Bean zu markieren, die vom Spring IoC Container verwaltet werden soll. Wenn Spring eine Klasse mit dieser Annotation findet, wird sie automatisch instanziiert und als Bean registriert. Das bedeutet, dass du diese Klasse nicht manuell konfigurieren musst, sondern Spring kümmert sich um die Erstellung und Verwaltung. @Component ist eine generische Annotation, und es gibt spezialisierte Versionen wie @Service, @Repository und @Controller für spezifische Anwendungsfälle.\n@ComponentScan: Mit dieser Annotation in Spring kannst du festlegen, in welchen Paketen nach Komponenten wie @Component, @Service, @Repository und @Controller gesucht werden soll. Diese Annotation wird häufig in einer Konfigurationsklasse zusammen mit @Configuration verwendet. Beim Start der Anwendung scannt Spring die angegebenen Pakete und registriert automatisch alle gefundenen Komponenten als Beans im IoC Container. Dadurch wird die Verwaltung und Konfiguration der Anwendung vereinfacht, da du nicht jede Bean manuell definieren musst.\n@Autowired: Mit der Annotation @Autowired in Spring kannst du die automatische Injektion von Abhängigkeiten nutzen. Das bedeutet, dass Spring die benötigten Beans automatisch findet und sie in das markierte Feld, den Konstruktor oder die Methode einfügt. Dadurch entfällt die Notwendigkeit, Abhängigkeiten manuell zu instanziieren, was den Code sauberer und übersichtlicher macht. @Autowired erleichtert die Verwaltung von Abhängigkeiten und fördert die lose Kopplung in deiner Anwendung.\n@Service: Wird in Spring verwendet, um eine Klasse als Service-Komponente zu kennzeichnen. Services sind spezialisierte Komponenten, die Geschäftslogik enthalten und häufig als Vermittler zwischen dem Controller und dem Repository fungieren. Durch die Verwendung von @Service erkennt Spring die Klasse als Bean und verwaltet sie automatisch im IoC Container. Das ermöglicht eine saubere Trennung der Geschäftslogik von anderen Schichten der Anwendung und fördert die Wiederverwendbarkeit und Testbarkeit des Codes.\n@Repository: Diese Annotation wird verwendet, um eine Klasse in Spring als Datenzugriffsschicht zu markieren. Diese Annotation stellt sicher, dass die Klasse für Datenbankoperationen wie Speichern, Abrufen, Aktualisieren und Löschen verantwortlich ist. Wenn Spring eine Klasse mit @Repository entdeckt, wird sie als Bean registriert und es werden zusätzliche Funktionen wie die automatische Behandlung von Datenbankausnahmen aktiviert. Dies verbessert die Verwaltung von Datenbankzugriffen und gewährleistet eine klare Trennung zwischen der Datenzugriffsschicht und anderen Teilen der Anwendung.\nMVC Annotationen @Controller: Um eine Klasse in Spring als Web-Controller zu kennzeichnen, wird die Annotation @Controller verwendet. Diese Annotation zeigt an, dass die Klasse HTTP-Anfragen entgegennimmt und darauf reagiert. Ein Controller verarbeitet die eingehenden Anfragen, delegiert die Geschäftslogik an entsprechende Services und gibt die passenden Antworten zurück. Typischerweise werden in einem Controller Methoden mit weiteren Annotationen wie @GetMapping oder @PostMapping versehen, um spezifische Endpunkte und HTTP-Methoden zu definieren. Durch die Verwendung von @Controller wird die Klasse als Bean im Spring IoC Container registriert, was die Strukturierung und Verwaltung von Webanfragen innerhalb der Anwendung erleichtert.\n@RequestMapping: Es ermöglicht dir, in Spring HTTP-Anfragen bestimmten Methoden in deinem Controller zuzuordnen. Es gibt spezialisierte Versionen dieser Annotation für die verschiedenen HTTP-Methoden, die den Code lesbarer und spezifischer machen. Hier sind die 4 wichtigsten Varianten:\n@GetMapping: Verarbeitung von GET-Anfragen. Diese Anfragen werden typischerweise verwendet, um Daten abzurufen. @PostMapping: Verwendung für POST-Anfragen. Diese Anfragen werden oft verwendet, um neue Daten zu erstellen oder zu senden. @PutMapping: Wird verwendet, um PUT-Anfragen zu verarbeiten. Diese Anfragen dienen in der Regel dazu, vorhandene Daten zu aktualisieren. @DeleteMapping: Verarbeitung von DELETE-Anfragen. Diese Anfragen werden genutzt, um Daten zu löschen. Diese spezialisierten Annotationen machen deinen Code klarer und einfacher zu verstehen, indem sie explizit angeben, welche HTTP-Methode verwendet wird.\n@PathVariable: Mit @PathVariable kannst du in Spring Platzhalter in der URL eines HTTP-Requests direkt an Methodenparameter im Controller binden. Diese Annotation ermöglicht es dir, dynamische Teile der URL zu erfassen und in deiner Methode zu verwenden. Dies ist besonders nützlich, wenn du RESTful APIs entwickelst, bei denen Ressourcen über eindeutige Identifikatoren in der URL aufgerufen werden.\nZum Beispiel kannst du in einer URL wie /users/{id} den Wert des {id}-Platzhalters direkt in deine Methode einfügen, um den entsprechenden Benutzer zu verarbeiten. Indem du @PathVariable in deiner Methodensignatur verwendest, kannst du diesen Wert einfach abrufen und weiterverarbeiten.\n1 2 3 4 5 @GetMapping(\"/users/{id}\") public User getUserById(@PathVariable(\"id\") Long userId) { // Logik zur Verarbeitung des Benutzer-IDs return userService.findById(userId); } In diesem Beispiel wird der Wert des URL-Platzhalters {id} automatisch der Methode als Parameter userId übergeben, was die Handhabung von dynamischen URLs erleichtert und den Code klarer und lesbarer macht.\n@RequestParam: Wenn du HTTP-Request-Parameter an Methodenparameter im Controller binden möchtest, ist @RequestParam die richtige Wahl. Diese Annotation ermöglicht es dir, Werte aus der URL-Abfragezeichenfolge direkt in deine Methode zu integrieren und weiterzuverarbeiten. Das ist besonders hilfreich, wenn du Daten wie Filterkriterien, Suchbegriffe oder andere Parameter übergeben möchtest.\nZum Beispiel kannst du in einer URL wie /search?query=Spring den Wert des Query-Parameters query direkt in deiner Methode verwenden. Indem du @RequestParam in deiner Methodensignatur angibst, kannst du diesen Wert abrufen und damit arbeiten.\n1 2 3 4 5 @GetMapping(\"/search\") public String search(@RequestParam(\"query\") String searchQuery) { // Logik zur Verarbeitung des Suchbegriffs return \"Ergebnisse für: \" + searchQuery; } In diesem Beispiel wird der Wert des Query-Parameters query automatisch der Methode als Parameter searchQuery übergeben. Dies erleichtert die Handhabung von URL-Parametern und macht deinen Code klarer und besser strukturiert.\n@RequestBody: Um den Inhalt einer HTTP-Anfrage direkt an ein Methodenparameter zu binden, verwendest du @RequestBody in Spring. Diese Annotation ist besonders nützlich, wenn du JSON- oder XML-Daten von einem Client empfangen und in ein Java-Objekt umwandeln möchtest. @RequestBody sorgt dafür, dass der Inhalt des Anfragekörpers automatisch deserialisiert und dem entsprechenden Parameter zugewiesen wird.\nZum Beispiel, wenn du eine POST-Anfrage sendest, die JSON-Daten enthält, kannst du diese Daten direkt in deiner Methode verarbeiten:\n1 2 3 4 5 6 @PostMapping(\"/users\") public ResponseEntity\u003cUser\u003e createUser(@RequestBody User newUser) { // Logik zur Verarbeitung des neuen Benutzers userService.save(newUser); return ResponseEntity.ok(newUser); } In diesem Beispiel wird der JSON-Inhalt der POST-Anfrage in das User-Objekt newUser umgewandelt. Dies erleichtert die Arbeit mit komplexen Datenstrukturen und sorgt für einen klaren und übersichtlichen Code, indem die Umwandlung von JSON zu Java-Objekten automatisch von Spring übernommen wird.\n@RequestHeader: Mit @RequestHeader in Spring kannst du HTTP-Header-Werte direkt an Methodenparameter im Controller binden. Diese Annotation ermöglicht es dir, spezifische Header-Informationen aus einer Anfrage zu extrahieren und in deiner Methode zu verwenden. Das ist besonders nützlich, wenn du Metadaten wie Authentifizierungsinformationen, Content-Type oder andere benutzerdefinierte Header benötigst.\nZum Beispiel kannst du den Wert eines spezifischen HTTP-Headers wie User-Agent direkt in deiner Methode verarbeiten:\n1 2 3 4 5 @GetMapping(\"/user-agent\") public ResponseEntity\u003cString\u003e getUserAgent(@RequestHeader(\"User-Agent\") String userAgent) { // Logik zur Verarbeitung des User-Agent-Headers return ResponseEntity.ok(\"User-Agent: \" + userAgent); } In diesem Beispiel wird der Wert des User-Agent-Headers automatisch der Methode als Parameter userAgent übergeben. Dies erleichtert die Arbeit mit HTTP-Headern und macht deinen Code klarer und besser strukturiert.\nSpring Boot Annotationen @SpringBootApplication: Es ist eine zentrale Annotation in Spring Boot, die als Einstiegspunkt für die Anwendung dient. Diese Annotation fasst mehrere wichtige Konfigurationen zusammen und vereinfacht so den Start und die Konfiguration deiner Spring Boot Anwendung.\nHier sind die drei Hauptbestandteile, die @SpringBootApplication kombiniert:\n@Configuration: Markiert die Klasse als eine Quelle für Bean-Definitionen. @EnableAutoConfiguration: Aktiviert die automatische Konfiguration von Spring Boot, basierend auf den in der Abhängigkeiten angegebenen Bibliotheken. @ComponentScan: Ermöglicht das automatische Scannen und Registrieren von Beans in den angegebenen Paketen. Ein typisches Beispiel für den Einsatz von @SpringBootApplication sieht so aus:\n1 2 3 4 5 6 @SpringBootApplication public class MyApplication { public static void main(String args) { SpringApplication.run(MyApplication.class, args); } } In diesem Beispiel wird die MyApplication-Klasse als Ausgangspunkt für die Spring Boot Anwendung verwendet. Durch die Verwendung von @SpringBootApplication wird die Konfiguration vereinfacht und du kannst schnell eine lauffähige Spring-Anwendung erstellen, da die wichtigsten Einstellungen und Scans automatisch durchgeführt werden.\n@EnableAutoConfiguration: Um die automatische Konfiguration in einer Spring-Boot-Anwendung zu aktivieren, verwendest du @EnableAutoConfiguration. Diese Annotation sorgt dafür, dass Spring Boot die Konfigurationseinstellungen basierend auf den Abhängigkeiten, die sich im Klassenpfad befinden, automatisch übernimmt. Dies ermöglicht es dir, eine Spring-Anwendung schnell und einfach zu starten, ohne umfangreiche Konfigurationsdateien erstellen zu müssen.\nWenn du @EnableAutoConfiguration in deiner Hauptanwendungsklasse verwendest, durchsucht Spring Boot den Klassenpfad nach Bibliotheken und aktiviert automatisch die entsprechenden Konfigurationen. Zum Beispiel, wenn du eine Datenbankabhängigkeit hinzufügst, wird Spring Boot automatisch die Datenbankkonfiguration vornehmen.\n","categories":"","description":"Modul #J8 - Spring Framework - Was sind Annotationen und welche gibt es in Spring?\n","excerpt":"Modul #J8 - Spring Framework - Was sind Annotationen und welche gibt …","ref":"/de/docs/02_java/12_spring-framework/06_annotationen/","tags":"","title":"Annotationen"},{"body":"In diesem Lab soll die Arbeit mit mehreren Git Repositories kennengelernt werden. Dazu wird in einer ersten Aufgabe zwischen zwei Repositories gewechselt und jeweils kleinere Änderungen vorgenommen.\nDiese Aufgabe ist eine Einzelaufgabe, die von jedem IT-Ninja eigenständig bearbeitet werden muss.\nSchritt 1: Feature-Branch auf dem 2. Repository erstellen Starte deinen Browser. Rufe die Bitbucketseite mit dem zweiten Repository auf. Klicke auf Branch erstellen. Wähle den Branch-Typ “Feature” aus. Wähle unter Branch von “develop” aus. Trage als Branch-Name “Modul-S3-‹dein Vorname›-projekte” ein (ohne Anführungszeichen). Klicke auf Branch erstellen. Schritt 2: Neu erstellten Branch auschecken Starte IntelliJ. Wechsle zum zweiten Projekt (Menu › File › Recent Projects). Klicke bei der entsprechenden Nachfrage “This Window” an. Aktualisiere den lokalen Stand von Git (Menu › Git › Fetch). Checke den oben erstellten Branch aus (Menu › Git › Branches…). Schritt 3: Codeänderung Suche dir eine beliebige Datei des Projekts und ändere einige Codezeilen. Speichere die Änderungen, aber führe kein commit aus.\nSchritt 4: Zu Projekt 1 wechseln Wechsle nun zu deinem Feature-Branch von Projekt 1. Klicke bei der entsprechenden Nachfrage “This Window” an. (Der Arbeitsbereich der IDE wird wieder auf das 1. Projekt gesetzt.) Überprüfe, dass wirklich das erste Projekt geladen ist. Du solltest das am Projektnamen erkennen und daran, dass keine uncommitteten Änderungen vorhanden sind. Schritt 5: Zu Projekt 2 wechseln Wechsle zurück auf das Projekt zwei und kontrolliere den aktuellen Stand. Deine Änderungen sollten vorhanden und in der Commit Vorschau auswählbar sein.\nDu kannst nun den lokalen Arbeitsbereich zwischen verschiedenen Projekten wechseln. Da bei unterschiedlichen Repositories (Projekten) der Zeiger auf das Wurzelverzeichnis des Projekts in der IDE geändert wird, werden hierbei keine lokalen Daten überschrieben.\nSchritt 6: Projekt in 2. IDE-Fenster öffnen Wähle über Menu › File › Recent Projects das erste Projekt aus. Klicke bei der entsprechenden Nachfrage “New Window” an. Es wird eine neue Instanz der IDE mit eigenem Arbeitsbereich geöffnet. Jetzt kannst du durch Switchen der geöffneten IDE-Instanz an beiden Projekten arbeiten. Mit dieser 2. Variante hast du die Möglichkeit mehrere Repositories direkt in einem lokalen Arbeitsbereich zu öffnen und ohne Wartezeit zwischen ihnen zu wechseln.\n","categories":"","description":"Aufgabe Arbeiten an mehreren Projekten [Git Vertiefung](../../../../docs/04_git/02_vertiefung/03_mehrere-repositories)\n","excerpt":"Aufgabe Arbeiten an mehreren Projekten [Git …","ref":"/labs/04_git/02_vertiefung/05_project-switch/","tags":"","title":"Aufgabe: Arbeiten mit mehreren Projekten"},{"body":"In diesem Lab soll die Arbeit mit mehreren Git Repositories kennengelernt werden. Dazu wird in einer ersten Aufgabe zwischen zwei Repositories gewechselt und jeweils kleinere Änderungen vorgenommen.\nDiese Aufgabe ist eine Einzelaufgabe, die von jedem IT-Ninja eigenständig bearbeitet werden muss.\nSchritt 1: Feature-Branch auf dem 2. Repository erstellen Starte deinen Browser. Rufe die Bitbucketseite mit dem zweiten Repository auf. Klicke auf Branch erstellen. Wähle den Branch-Typ “Feature” aus. Wähle unter Branch von “develop” aus. Trage als Branch-Name “Modul-S3-‹dein Vorname›-projekte” ein (ohne Anführungszeichen). Klicke auf Branch erstellen. Schritt 2: Neu erstellten Branch auschecken Starte IntelliJ. Wechsle zum zweiten Projekt (Menu › File › Recent Projects). Klicke bei der entsprechenden Nachfrage “This Window” an. Aktualisiere den lokalen Stand von Git (Menu › Git › Fetch). Checke den oben erstellten Branch aus (Menu › Git › Branches…). Schritt 3: Codeänderung Suche dir eine beliebige Datei des Projekts und ändere einige Codezeilen. Speichere die Änderungen, aber führe kein commit aus.\nSchritt 4: Zu Projekt 1 wechseln Wechsle nun zu deinem Feature-Branch von Projekt 1. Klicke bei der entsprechenden Nachfrage “This Window” an. (Der Arbeitsbereich der IDE wird wieder auf das 1. Projekt gesetzt.) Überprüfe, dass wirklich das erste Projekt geladen ist. Du solltest das am Projektnamen erkennen und daran, dass keine uncommitteten Änderungen vorhanden sind. Schritt 5: Zu Projekt 2 wechseln Wechsle zurück auf das Projekt zwei und kontrolliere den aktuellen Stand. Deine Änderungen sollten vorhanden und in der Commit Vorschau auswählbar sein.\nDu kannst nun den lokalen Arbeitsbereich zwischen verschiedenen Projekten wechseln. Da bei unterschiedlichen Repositories (Projekten) der Zeiger auf das Wurzelverzeichnis des Projekts in der IDE geändert wird, werden hierbei keine lokalen Daten überschrieben.\nSchritt 6: Projekt in 2. IDE-Fenster öffnen Wähle über Menu › File › Recent Projects das erste Projekt aus. Klicke bei der entsprechenden Nachfrage “New Window” an. Es wird eine neue Instanz der IDE mit eigenem Arbeitsbereich geöffnet. Jetzt kannst du durch Switchen der geöffneten IDE-Instanz an beiden Projekten arbeiten. Mit dieser 2. Variante hast du die Möglichkeit mehrere Repositories direkt in einem lokalen Arbeitsbereich zu öffnen und ohne Wartezeit zwischen ihnen zu wechseln.\n","categories":"","description":"Aufgabe Arbeiten an mehreren Projekten [Git Vertiefung](../../../../docs/04_git/02_vertiefung/03_mehrere-repositories)\n","excerpt":"Aufgabe Arbeiten an mehreren Projekten [Git …","ref":"/de/labs/04_git/02_vertiefung/05_project-switch/","tags":"","title":"Aufgabe: Arbeiten mit mehreren Projekten"},{"body":" Voraussetzung Du verstehst und kennst die verschiedenen Conditional Statements. Du weisst, wann und wie welches Conditional Statement eingesetzt werden sollte. Wir stellen dir bei den Übungen jeweils komplette Projekte zur Verfügung. Du musst grundsätzlich nur dort was anpassen, wo die folgende Kommentarzeile steht:\nKopieren // IT-Ninja: Füge hier Deinen Code ein: 1 // IT-Ninja: Füge hier Deinen Code ein: Alles andere kannst du für den Moment ignorieren. Wir erklären dir die einzelnen Zeilen Schritt für Schritt in den Modulen.\nVorbereitungsarbeiten Drücke auf den Pfeil links um eine detaillierte Anleitung zu erhalten, wie Du den Quellcode auf deinem Rechner ablegen sollst.\nDiese Schritte musst du bei jeder Übung erneut machen. Jede Übung hat ein eigenes ZIP-File, welches du bei dir an die richtige Stelle kopieren musst. Die Anleitung zeigt dir ziemlich gut, wie das geht… Liess vor allem am Anfang die detaillierte Anleitung gut durch und befolge die Schritte exakt. Sie helfen dir, deinen Quellcode gut organisiert, strukturiert und sicher zu verwalten. Falls du die Anleitung schon auswendig kennst, findest du den Quellcode zur Übung direkt hier: Download | Online anschauen\nNeu bei it-ninja?\nDie Anleitung enthält einige Befehle und Fachbegriffe, die dir möglicherweise noch nichts sagen. Mach dir deswegen keine Sorgen – in den kommenden Modulen erklären wir dir alles Schritt für Schritt. Schon bald wirst auch du ein it-ninja sein. Um die folgenden Aufgaben erfolgreich umzusetzen, führe diese Schritte aus:\nBeim ersten Mal:\nIntelliJ IDEA installieren → !*IntelliJ IDEA einrichten Git-Repository einrichten → !*Persönliches Git-Repository Öffne eine !*CMD-Shell und wechsle ins Verzeichnis deines Git-Repositories:\nKopieren cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git status 1 2 cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git status Kopieren cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git status 1 2 cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git status Stelle sicher, dass alle Dateien im Git-Repository committed sind. Mit git status erhältst du eine Übersicht: Kopieren git status 1 git status Falls du bei diesem Befehl einen roten Text siehst, musst du zuerst die aktuellen Dateien sichern:\nKopieren git add . git commit -m \"[gescheiter Kommentar]\" 1 2 git add . git commit -m \"[gescheiter Kommentar]\" Erstelle oder wechsle in den Template Branch:\nBeim ersten Mal musst du einen Template Branch erstellen:\nKopieren git checkout -b \"templates\" 1 git checkout -b \"templates\" Falls er bereits existiert, kannst du einfach switchen:\nKopieren git switch \"templates\" 1 git switch \"templates\" Lade den Source-Code zu den Übungen herunter und entpacke ihn im Root-Verzeichnis deines lokalen Repositories:\n[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\nDen Source-Code findest du hier: Download | Online anschauen\nCommitte den originalen Source-Code, damit er sicher im Repository gespeichert ist:\nKopieren git add . git commit -m \"Add it-ninja_02_java_03_java-grundlagen_06_control-structures-if\" git push 1 2 3 git add . git commit -m \"Add it-ninja_02_java_03_java-grundlagen_06_control-structures-if\" git push Erstelle einen neuen Branch, um deine Lösung zu implementieren: Kopieren git checkout -b \"labs/it-ninja_02_java_03_java-grundlagen_06_control-structures-if\" 1 git checkout -b \"labs/it-ninja_02_java_03_java-grundlagen_06_control-structures-if\" Hier kannst du auch einen kürzeren Namen wählen. Verwende labs am Anfang des Branch-Namens für Branches, die deinen eigenen Code enthalten.\nStelle dir einen Branch vorerst als Ordner vor. Jeder Ordner enthält eine Version oder einen Stand von deinem Quellcode. Du kannst dann mit git zwischen diesen Ordern hin und her wechseln, sie vergleichen aber später auch zusammenführen.\nPro-Tipp:\nDu kannst jederzeit einen weiteren Branch erstellen – z. B. wenn du etwas ausprobieren möchtest. Alternativ kannst du auch in der Git-History einen alten Stand wiederherstellen, was aber weniger flexibel ist. Starte IntelliJ und öffne mit File → Open das Verzeichnis mit dem Source-Code. Du musst mit IntelliJ den Ordner suchen, welches einen Ordner src oder die Datei pom.xml enthält. Ansonsten wird IntelliJ Mühe haben, dir das Programm zu kompilieren. Wenn du alles korrekt gemacht hast, findest du das Projekt hier:\nKopieren `[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\\02_java\\03_java-grundlagen\\06_control-structures-if` 1 `[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\\02_java\\03_java-grundlagen\\06_control-structures-if` Kopieren `[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\\02_java/03_java-grundlagen/06_control-structures-if` 1 `[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\\02_java/03_java-grundlagen/06_control-structures-if` Falls du zum ersten Mal mit IntelliJ arbeitest, findest du !*hier eine Anleitung, wie man ein Programm startet. Um das Programm zu starten musst du jeweils die Datei Main.java öffenen. Dann sollte in IntelliJ oben rechts ein grünes Dreieck vorhanden sein, welches das Programm startet. Nun bist du bereit, die untenstehenden Aufgaben zu lösen.\nWenn du alle Änderungen gemacht hast und mit der Übung fertig bist, oder einen ‘Zwischenstand’ festhalten willst, führe die folgenden Befehle aus um das Repository auf dem Server zu speichern (von wo du es geklont hast):\nKopieren cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git add --all git commit -m \"Kurzer Kommentar\" 1 2 3 cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git add --all git commit -m \"Kurzer Kommentar\" Kopieren cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git add . git commit -m \"Kurzer Kommentar\" 1 2 3 cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git add . git commit -m \"Kurzer Kommentar\" Wenn du deine Änderungen auf dem Git-Server sichern willst, musst du das mit einem push machen.\nBeim ersten mal musst du git noch mitteilen, wie der Branch auf dem Git-Server heissen soll:\nKopieren git push --set-upstream origin labs/it-ninja_02_java_03_java-grundlagen_06_control-structures-if 1 git push --set-upstream origin labs/it-ninja_02_java_03_java-grundlagen_06_control-structures-if Bei weiteren pushes wird es dann einfacher:\nKopieren git push 1 git push Die meisten Übungen sind professionell strukturiert – so wie in echten Softwareprojekten. Zu gutem Code gehören auch Tests, die sicherstellen, dass dein Code wie erwartet funktioniert. Sofern nicht anders erwähnt, kannst du mit folgendem Befehl im Root-Verzeichnis des Projekts (dort, wo sich auch die pom.xml befindet) überprüfen, ob du die Aufgabe korrekt gelöst hast:\n1 mvn test Viel Erfolg!\nAufgabe 1 - Zahlenvergleich Passe die folgende Methode an. Vergleiche die beiden Zahlen ‘zahl1’ und ‘zahl2’ und gib das Resultat des Vergleichs auf auf der Konsole aus:\nZahl1(value1) ist kleiner als Zahl2(value2) Zahl1(value1) ist grösser als Zahl2(value2) Zahl1(value1) ist gleich gross wie Zahl2(value2) Wobei in der Ausgabe value1 und value2 durch die tatsächlichen Werte ersetzt werden sollen.\nIm zur Übung gehörendem Source kannst Du die Änderung an folgender Stelle machen:\nsrc\\main\\java\\ch\\itninja\\labs\\basicexercises\\CompareNumbers.java:\n1 2 3 4 5 public static void compareNumbers(int number1, int number2) { // IT-Ninja: Füge hier Deinen Code ein: } Beispiel 1:\nEingabe:\n1 CompareNumbers.compareNumbers(-1, 5); Ausgabe:\n1 Zahl1(-1) ist kleiner als Zahl2(5) Beispiel 2:\nEingabe:\n1 CompareNumbers.compareNumbers(23, 7); Ausgabe:\n1 Zahl1(23) ist grösser als Zahl2(7) Beispiel 3:\nEingabe:\n1 CompareNumbers.compareNumbers(47, 47); Ausgabe:\n1 Zahl1(47) ist gleich gross wie Zahl2(47) Beispiel 4:\nEingabe:\n1 CompareNumbers.compareNumbers(0, 0); Ausgabe:\n1 Zahl1(0) ist gleich gross wie Zahl2(0) Aufgabe 2 - Schaltjahr Passe die folgende Methode an. Stell fest, ob das übergebene Jahr ein Schaltjahr ist (gemäss gregorianischer Kalender). Gib auf der Konsole das Resultat aus:\nDas Jahr year ist ein Schaltjahr gemäss gregorianischem Kalender Das Jahr year ist kein Schaltjahr gemäss gregorianischem Kalender Wobei in der Ausgabe year durch das tatsächliche Jahr ersetzt werden soll. Falls das Jahr ein Schaltjahr gemäss gregorianischem Kalender ist, soll die Methode true zurückgeben, andernfalls false.\nVerwende keine logischen Ausdrücke zur Berechnung des Schaltjahres. Nutze stattdessen if-else- und else-if Anweisungen.\nIm zur Übung gehörendem Source kannst Du die Änderung an folgender Stelle machen:\nsrc\\main\\java\\ch\\itninja\\labs\\basicexercises\\LeapYear.java:\n1 2 3 4 5 public static boolean isLeapYear(int year) { // IT-Ninja: Füge hier Deinen Code ein: } Beispiel 1:\nEingabe:\n1 boolean result = LeapYear.isLeapYear(1200); Ausgabe:\n1 Das Jahr 1200 ist kein Schaltjahr gemäss gregorianischem Kalender Beispiel 2:\nEingabe:\n1 boolean result = LeapYear.isLeapYear(1996); Ausgabe:\n1 Das Jahr 1996 ist ein Schaltjahr gemäss gregorianischem Kalender Beispiel 3:\nEingabe:\n1 boolean result = LeapYear.isLeapYear(1900); Ausgabe:\n1 Das Jahr 1900 ist kein Schaltjahr gemäss gregorianischem Kalender Beispiel 4:\nEingabe:\n1 boolean result = LeapYear.isLeapYear(2000); Ausgabe:\n1 Das Jahr 2000 ist ein Schaltjahr gemäss gregorianischem Kalender Beispiel 5:\nEingabe:\n1 boolean result = LeapYear.isLeapYear(2021); Ausgabe:\n1 Das Jahr 2021 ist kein Schaltjahr gemäss gregorianischem Kalender Beispiel 6:\nEingabe:\n1 boolean result = LeapYear.isLeapYear(2024); Ausgabe:\n1 Das Jahr 2024 ist ein Schaltjahr gemäss gregorianischem Kalender Beispiel 7:\nEingabe:\n1 boolean result = LeapYear.isLeapYear(2100); Ausgabe:\n1 Das Jahr 2100 ist kein Schaltjahr gemäss gregorianischem Kalender Beispiel 8:\nEingabe:\n1 boolean result = LeapYear.isLeapYear(2400); Ausgabe:\n1 Das Jahr 2400 ist ein Schaltjahr gemäss gregorianischem Kalender Beispiel 9:\nEingabe:\n1 boolean result = LeapYear.isLeapYear(2023); Ausgabe:\n1 Das Jahr 2023 ist kein Schaltjahr gemäss gregorianischem Kalender ","categories":"","description":"Mit diesen Übungen kannst du dein Wissen über bedingte Ausführung vertiefen.\n","excerpt":"Mit diesen Übungen kannst du dein Wissen über bedingte Ausführung …","ref":"/labs/02_java/03_java-grundlagen/06_control-structures-if/","tags":"","title":"Java Exercises - Variablen und bedingte Anweisungen"},{"body":"Inhalt Diese Seite soll als Landing Page dienen und den Absprung zu den verschiedenen Debugging-Seiten erleichtern.\nDebugging von Java Code in IntelliJ Frontend-Debugging ","categories":"","description":"Landing Page fürs Debugging\n","excerpt":"Landing Page fürs Debugging\n","ref":"/docs/06_debugging/","tags":"","title":"Debugging"},{"body":"Inhalt Diese Seite soll als Landing Page dienen und den Absprung zu den verschiedenen Debugging-Seiten erleichtern.\nDebugging von Java Code in IntelliJ Frontend-Debugging ","categories":"","description":"Landing Page fürs Debugging\n","excerpt":"Landing Page fürs Debugging\n","ref":"/de/docs/06_debugging/","tags":"","title":"Debugging"},{"body":"(Dieses Modul ist optional)\nGitHub ist ein Webservice für das Verwalten von Software Code via Git. Darüber hinaus bietet GitHub viele weitere Funktionen, von Projektmanagement mit Taskverwaltung, über Wikis bis zum Buildserver. GitHub ist die Plattform für Opensource Projekte.\nWeitere Infos:\nWikipedia GitHub Doku GitHub Alternativen Natürlich ist GitHub nicht die einzige Plattform, welche diesen Service anbietet. Alle Alternativen haben ihre eigenen Features und Limitierungen, im Kern verwenden aber alle Git.\nAlternativen:\nGitea: https://gitea.io Gitolite: https://gitolite.com Gitosis: https://github.com/tv42/gitosis GitLab: https://gitlab.com/ Bitbucket: https://bitbucket.org GitHub Account Falls du noch keinen GitHub-Account hast, wäre jetzt der Moment einen zu erstellen. https://github.com/signup\nGit Protokolle Um auf ein entferntes Git Repository zuzugreifen, gibt es in der Regel zwei Varianten:\nHTTPS SSH Beide Protokolle bieten standardmässig Verschlüsselung, Authentifizierung und Komprimierung.\nGit über HTTPS Kurze Wiederholung: Um ein Repository über HTTPS zu klonen verwendet man den Befehl:\n1 $ git clone https://github.com/kelseyhightower/nocode.git Dies ist die einfachste Variante, um Code schnell herunterzuladen und lokal im eigenen Editor zu betrachten.\nVorteile:\nAnonymer Zugriff möglich Zugriff für Systeme, auf denen SSH weniger verbreitet ist HTTPS ist auf vielen Corporate Firewalls standardmässig offen Nachteile:\nZwischenspeicherung der Anmeldedaten mit HTTPS weniger benutzerfreundlich als mit SSH Keys Konfiguration des Webservers etwas komplizierter als die von SSH Git über SSH Um ein Repository mit SSH zu klonen, kommt folgender Befehl zum Einsatz:\n1 $ git clone git@github.com:cajotafer/10xengineers.git Für die meisten Anwendungsfälle ist dies der bevorzugte Weg, um entfernte Git Repositories zu verwenden.\nVorteile:\nSSH ist auf jedem Linux System bereits vorinstalliert (server- wie clientseitig) SSH Server sind sehr einfach zu konfigurieren Der Zugriff via SSH ist sehr sicher Nachteile:\nBietet keinen anonymen Zugriff GitHub Features Feature Funktion Issues Ermöglichen es, Tasks in einem Repo zu erstellen und zu tracken. Pull Requests Ein Pull Request ermöglicht es, Changes zu reviewen und zu besprechen, bevor sie in einen Branch gemerged werden. Forks Eine Fork ist eine Kopie von einem Git-Repo. Die Fork kann dann bearbeitet und angepasst werden, ohne dass das originale Repo davon betroffen ist. GitHub Pages Basic Webseiten welche auf GitHub gehostet werden GitHub Actions CI/CD Integration von GitHub Hands On Für dieses Hands-On werden wir alles via Webinterface von GitHub machen. Ein Grossteil der Tasks können jedoch auch Lokal mit Git im Terminal gemacht werden.\nBranches und Pull Requests https://guides.github.com/activities/hello-world/ Forks, Pull Requests, Reviews Fork erstellen vom Repo. Weitere User auf Fork hinzufügen Branch auf Fork erstellen\nhello-world.sh auf dem Master Branch anpassen und committen.\n1 2 3 #!/bin/bash echo 'Hello World Master' hello-world.sh auf dem neuen Branch anpassen und committen.\n1 2 3 #!/bin/bash echo 'Hello World Feature' Pull Request erstellen\nDa auf beiden Branches die gleiche Zeile bearbeitet wurde, kann GitHub die Branches nicht automatisch Mergen. Aus diesem Grund müssen zuerst die Konflikte gelöst werden Teamkollege als Reviewer zuweisen.\nReview Changes umsetzen.\nPull Request mergen.\nMerge Request auf Original Repo erstellen\nEnde\n","categories":"","description":"","excerpt":"(Dieses Modul ist optional)\nGitHub ist ein Webservice für das …","ref":"/docs/04_git/01_grundwissen/06_github/","tags":"","title":"GitHub"},{"body":"(Dieses Modul ist optional)\nGitHub ist ein Webservice für das Verwalten von Software Code via Git. Darüber hinaus bietet GitHub viele weitere Funktionen, von Projektmanagement mit Taskverwaltung, über Wikis bis zum Buildserver. GitHub ist die Plattform für Opensource Projekte.\nWeitere Infos:\nWikipedia GitHub Doku GitHub Alternativen Natürlich ist GitHub nicht die einzige Plattform, welche diesen Service anbietet. Alle Alternativen haben ihre eigenen Features und Limitierungen, im Kern verwenden aber alle Git.\nAlternativen:\nGitea: https://gitea.io Gitolite: https://gitolite.com Gitosis: https://github.com/tv42/gitosis GitLab: https://gitlab.com/ Bitbucket: https://bitbucket.org GitHub Account Falls du noch keinen GitHub-Account hast, wäre jetzt der Moment einen zu erstellen. https://github.com/signup\nGit Protokolle Um auf ein entferntes Git Repository zuzugreifen, gibt es in der Regel zwei Varianten:\nHTTPS SSH Beide Protokolle bieten standardmässig Verschlüsselung, Authentifizierung und Komprimierung.\nGit über HTTPS Kurze Wiederholung: Um ein Repository über HTTPS zu klonen verwendet man den Befehl:\n1 $ git clone https://github.com/kelseyhightower/nocode.git Dies ist die einfachste Variante, um Code schnell herunterzuladen und lokal im eigenen Editor zu betrachten.\nVorteile:\nAnonymer Zugriff möglich Zugriff für Systeme, auf denen SSH weniger verbreitet ist HTTPS ist auf vielen Corporate Firewalls standardmässig offen Nachteile:\nZwischenspeicherung der Anmeldedaten mit HTTPS weniger benutzerfreundlich als mit SSH Keys Konfiguration des Webservers etwas komplizierter als die von SSH Git über SSH Um ein Repository mit SSH zu klonen, kommt folgender Befehl zum Einsatz:\n1 $ git clone git@github.com:cajotafer/10xengineers.git Für die meisten Anwendungsfälle ist dies der bevorzugte Weg, um entfernte Git Repositories zu verwenden.\nVorteile:\nSSH ist auf jedem Linux System bereits vorinstalliert (server- wie clientseitig) SSH Server sind sehr einfach zu konfigurieren Der Zugriff via SSH ist sehr sicher Nachteile:\nBietet keinen anonymen Zugriff GitHub Features Feature Funktion Issues Ermöglichen es, Tasks in einem Repo zu erstellen und zu tracken. Pull Requests Ein Pull Request ermöglicht es, Changes zu reviewen und zu besprechen, bevor sie in einen Branch gemerged werden. Forks Eine Fork ist eine Kopie von einem Git-Repo. Die Fork kann dann bearbeitet und angepasst werden, ohne dass das originale Repo davon betroffen ist. GitHub Pages Basic Webseiten welche auf GitHub gehostet werden GitHub Actions CI/CD Integration von GitHub Hands On Für dieses Hands-On werden wir alles via Webinterface von GitHub machen. Ein Grossteil der Tasks können jedoch auch Lokal mit Git im Terminal gemacht werden.\nBranches und Pull Requests https://guides.github.com/activities/hello-world/ Forks, Pull Requests, Reviews Fork erstellen vom Repo. Weitere User auf Fork hinzufügen Branch auf Fork erstellen\nhello-world.sh auf dem Master Branch anpassen und committen.\n1 2 3 #!/bin/bash echo 'Hello World Master' hello-world.sh auf dem neuen Branch anpassen und committen.\n1 2 3 #!/bin/bash echo 'Hello World Feature' Pull Request erstellen\nDa auf beiden Branches die gleiche Zeile bearbeitet wurde, kann GitHub die Branches nicht automatisch Mergen. Aus diesem Grund müssen zuerst die Konflikte gelöst werden Teamkollege als Reviewer zuweisen.\nReview Changes umsetzen.\nPull Request mergen.\nMerge Request auf Original Repo erstellen\nEnde\n","categories":"","description":"","excerpt":"(Dieses Modul ist optional)\nGitHub ist ein Webservice für das …","ref":"/de/docs/04_git/01_grundwissen/06_github/","tags":"","title":"GitHub"},{"body":"Ziele Ich weiss, wie ich eine HTML-Seite strukturiere. Ich weiss, was das DOM ist. Ich weiss, wie ich das DOM einer Webseite inspizieren kann. Ich weiss, was Meta-Tags sind und wozu sie verwendet werden. Ich weiss, wie ich meine Seite auf Syntax-Fehler überprüfen kann. Struktur einer HTML-Seite Bisher haben wir ohne erkennbare Struktur HTML-Elemente hinzugefügt.\nNormalerweise folgt eine HTML-Datei der folgenden Struktur (ohne die h1- und p-Elemente):\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u003c!doctype html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003c!-- Place for external resources and meta tags. --\u003e \u003ctitle\u003eMy Website\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- Place for your website's content. --\u003e \u003ch1\u003eHello\u003c/h1\u003e \u003cp\u003eThis is my amazing website!\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e Auf der ersten Zeile definieren wir, dass es sich um ein HTML-Dokument handelt. Diese Zeile ist erforderlich und seit HTML5 praktisch immer gleich.\nAlle weiteren Elemente befinden sich dann im (einzigen) \u003chtml\u003e-Element. Im \u003chtml\u003e-Tag kann noch die Sprache der Seite mit dem lang-Attribut angegeben werden. Auf der nächsten Stufe sind nur \u003chead\u003e und \u003cbody\u003e erlaubt. Im \u003chead\u003e befinden sich Meta-Informationen über die Website wie z.B. der Tab-Titel der Website. Der eigentliche Seiteninhalt befindet sich vollständig im \u003cbody\u003e.\nDOM (Document Object Model) In der Webentwicklung wird sehr oft vom “DOM” gesprochen. Visualisiert sähe das DOM für das obige Beispiel ungefähr so aus:\nWas ist nun aber dieses “Document Object Model”? Simpel ausgedrückt beschreibt das DOM die Struktur der Website zur Laufzeit (also im Browser). Das DOM enthält also die Information, wie die Seite inklusive ihrer Elemente aufgebaut und verschachtelt ist. Im Gegensatz zum HTML-Dokument kann sich das DOM während des Besuches der Seite verändern (z.B. durch JavaScript). Das DOM enthält also die Information, was aktuell auf der Seite ist.\nZusätzliche Informationen findest du hier:\nhttps://www.w3schools.com/js/js_htmldom.asp https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction Wie das DOM auf einer beliebigen Webseite aussieht, kannst du ganz einfach herausfinden:\nÖffne die Entwickler-Tools von deinem Browser (normalerweise mit der [F12]-taste) Wechsle zum Reiter “Elemente” Nun siehst du das aktuelle DOM: Mache dich mit diesen Entwickler-Tools (auch mit dem Inspection-Button ganz oben links im Bild) unbedingt vertraut!\nDiese Tools sind sehr praktische Hilfsmittel bei der Entwicklung von HTML-Seiten, da du damit den aktuellen Zustand deiner Seite inspizieren kannst. Wenn du eine Webseite entwickelst, wirst du nicht daran vorbeikommen, diese Tools zu verwenden.\nDer Head Wichtig für dich zum Wissen ist auch, dass deine HTML-Seite bestimmte Meta-Tags haben sollte, damit sie als “valid” gilt. Nachfolgend ein paar wichtigere \u003cmeta\u003e-Tags:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u003chead\u003e \u003c!-- Place for external resources and meta tags. --\u003e \u003ctitle\u003eMy Website\u003c/title\u003e \u003cmeta charset=\"UTF-8\" /\u003e \u003cmeta name=\"description\" content=\"A simple useless website\" /\u003e \u003cmeta name=\"keywords\" content=\"HTML, Meta tags\" /\u003e \u003cmeta name=\"author\" content=\"Karl Klammer\" /\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /\u003e \u003c/head\u003e Der title ist der Text, der im Tab angezeigt wird. Das charset beschreibt, welcher Zeichensatz im Dokument verwendet wird, also wie die einzelnen Zeichen interpretiert werden. Damit du alle gängigen Zeichen brauchen kannst, wird “UTF-8” empfohlen. Das Fehlen dieser Zeile führt oft dazu, dass bestimmte Zeichen falsch dargestellt werden (Beispielsweise “ä”, “ö”, “ü” etc.). Die description wird zum Beispiel von Suchmaschinen verwendet. Wie z.B. Google solche Tags auswertet, erfährst du hier: https://developers.google.com/search/docs/advanced/crawling/special-tags?hl=de. keywords geht in eine ähnliche Richtung. Die Zeile für den viewport kann praktisch immer eins zu eins übernommen werden. Dieser Wert führt dazu, dass die Seite auf mobilen Endgeräten nicht wie eine Desktop-Seite aussieht. Mit diesem Element wird der Text auf Smartphones meistens grösser. Dieses Meta-Tag wird empfohlen, wenn die Seite auf Smartphones gut aussehen soll. Ist meine Seite valid? Um die Seite auf Syntax-Fehler und andere gängige Fehler zu überprüfen, kann es Sinn machen, die Seite von einem Validator überprüfen zu lassen. Dazu geeignet ist zum Beispiel der folgende: https://validator.w3.org/#validate_by_input\nHier kannst du deinen HTML-Code reinkopieren, worauf der Validator dir dann die Fehler anzeigt, die er in deinem Code entdeckt hat.\nJetzt bist du dran. Löse die Aufgabe 2 in den Labs.\n","categories":"","description":"Modul #F3 - HTML und CSS - HTML-Seite strukturieren\n","excerpt":"Modul #F3 - HTML und CSS - HTML-Seite strukturieren\n","ref":"/docs/03_web/02_html_css/06_html-structure/","tags":"","title":"HTML-Struktur"},{"body":"Ziele Ich weiss, wie ich eine HTML-Seite strukturiere. Ich weiss, was das DOM ist. Ich weiss, wie ich das DOM einer Webseite inspizieren kann. Ich weiss, was Meta-Tags sind und wozu sie verwendet werden. Ich weiss, wie ich meine Seite auf Syntax-Fehler überprüfen kann. Struktur einer HTML-Seite Bisher haben wir ohne erkennbare Struktur HTML-Elemente hinzugefügt.\nNormalerweise folgt eine HTML-Datei der folgenden Struktur (ohne die h1- und p-Elemente):\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u003c!doctype html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003c!-- Place for external resources and meta tags. --\u003e \u003ctitle\u003eMy Website\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- Place for your website's content. --\u003e \u003ch1\u003eHello\u003c/h1\u003e \u003cp\u003eThis is my amazing website!\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e Auf der ersten Zeile definieren wir, dass es sich um ein HTML-Dokument handelt. Diese Zeile ist erforderlich und seit HTML5 praktisch immer gleich.\nAlle weiteren Elemente befinden sich dann im (einzigen) \u003chtml\u003e-Element. Im \u003chtml\u003e-Tag kann noch die Sprache der Seite mit dem lang-Attribut angegeben werden. Auf der nächsten Stufe sind nur \u003chead\u003e und \u003cbody\u003e erlaubt. Im \u003chead\u003e befinden sich Meta-Informationen über die Website wie z.B. der Tab-Titel der Website. Der eigentliche Seiteninhalt befindet sich vollständig im \u003cbody\u003e.\nDOM (Document Object Model) In der Webentwicklung wird sehr oft vom “DOM” gesprochen. Visualisiert sähe das DOM für das obige Beispiel ungefähr so aus:\nWas ist nun aber dieses “Document Object Model”? Simpel ausgedrückt beschreibt das DOM die Struktur der Website zur Laufzeit (also im Browser). Das DOM enthält also die Information, wie die Seite inklusive ihrer Elemente aufgebaut und verschachtelt ist. Im Gegensatz zum HTML-Dokument kann sich das DOM während des Besuches der Seite verändern (z.B. durch JavaScript). Das DOM enthält also die Information, was aktuell auf der Seite ist.\nZusätzliche Informationen findest du hier:\nhttps://www.w3schools.com/js/js_htmldom.asp https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction Wie das DOM auf einer beliebigen Webseite aussieht, kannst du ganz einfach herausfinden:\nÖffne die Entwickler-Tools von deinem Browser (normalerweise mit der [F12]-taste) Wechsle zum Reiter “Elemente” Nun siehst du das aktuelle DOM: Mache dich mit diesen Entwickler-Tools (auch mit dem Inspection-Button ganz oben links im Bild) unbedingt vertraut!\nDiese Tools sind sehr praktische Hilfsmittel bei der Entwicklung von HTML-Seiten, da du damit den aktuellen Zustand deiner Seite inspizieren kannst. Wenn du eine Webseite entwickelst, wirst du nicht daran vorbeikommen, diese Tools zu verwenden.\nDer Head Wichtig für dich zum Wissen ist auch, dass deine HTML-Seite bestimmte Meta-Tags haben sollte, damit sie als “valid” gilt. Nachfolgend ein paar wichtigere \u003cmeta\u003e-Tags:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u003chead\u003e \u003c!-- Place for external resources and meta tags. --\u003e \u003ctitle\u003eMy Website\u003c/title\u003e \u003cmeta charset=\"UTF-8\" /\u003e \u003cmeta name=\"description\" content=\"A simple useless website\" /\u003e \u003cmeta name=\"keywords\" content=\"HTML, Meta tags\" /\u003e \u003cmeta name=\"author\" content=\"Karl Klammer\" /\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /\u003e \u003c/head\u003e Der title ist der Text, der im Tab angezeigt wird. Das charset beschreibt, welcher Zeichensatz im Dokument verwendet wird, also wie die einzelnen Zeichen interpretiert werden. Damit du alle gängigen Zeichen brauchen kannst, wird “UTF-8” empfohlen. Das Fehlen dieser Zeile führt oft dazu, dass bestimmte Zeichen falsch dargestellt werden (Beispielsweise “ä”, “ö”, “ü” etc.). Die description wird zum Beispiel von Suchmaschinen verwendet. Wie z.B. Google solche Tags auswertet, erfährst du hier: https://developers.google.com/search/docs/advanced/crawling/special-tags?hl=de. keywords geht in eine ähnliche Richtung. Die Zeile für den viewport kann praktisch immer eins zu eins übernommen werden. Dieser Wert führt dazu, dass die Seite auf mobilen Endgeräten nicht wie eine Desktop-Seite aussieht. Mit diesem Element wird der Text auf Smartphones meistens grösser. Dieses Meta-Tag wird empfohlen, wenn die Seite auf Smartphones gut aussehen soll. Ist meine Seite valid? Um die Seite auf Syntax-Fehler und andere gängige Fehler zu überprüfen, kann es Sinn machen, die Seite von einem Validator überprüfen zu lassen. Dazu geeignet ist zum Beispiel der folgende: https://validator.w3.org/#validate_by_input\nHier kannst du deinen HTML-Code reinkopieren, worauf der Validator dir dann die Fehler anzeigt, die er in deinem Code entdeckt hat.\nJetzt bist du dran. Löse die Aufgabe 2 in den Labs.\n","categories":"","description":"Modul #F3 - HTML und CSS - HTML-Seite strukturieren\n","excerpt":"Modul #F3 - HTML und CSS - HTML-Seite strukturieren\n","ref":"/de/docs/03_web/02_html_css/06_html-structure/","tags":"","title":"HTML-Struktur"},{"body":"Ziele Ich kann die zwei Hauptunterschiede von einem Konstruktor und einer gewöhnlichen Methode nennen. Ich kann in eigenen Worten erklären, was ein Konstruktor ist und wozu er verwendet wird. Ich kann in eigenen Worten erklären, was ein Default-Konstruktor ist, wann er erzeugt wird und wann er entfällt. Ich demonstriere die Anwendung von Konstruktoren anhand eines Beispiels ohne Hilfsmittel. Konstruktoren Konstruktoren sind spezielle Methoden, die benutzt werden, sobald ein neues Objekt einer Klasse erstellt wird. Ein Konstruktor einer Klasse wird aufgerufen, wenn eine neue Instanz mit dem Schlüsselwort new erstellt wird. Ein Konstruktor unterscheidet sich von anderen Methoden darin, dass:\ner den gleichen Namen haben muss wie die Klasse, die ihn enthält er keinen Rückgabetyp (nicht einmal void) hat Konstruktoren initialisieren Instanzen (Objekte) der Klasse. Sie können beliebige Parameter enthalten, um beispielsweise Instanzvariablen zu initialisieren.\nKonstruktoren verwenden Im folgenden Beispiel benutzen wir eine Klasse mit dem Namen Patient. Ein Objekt der Klasse hat einen Namen, ein Alter und eine Grösse. Die Klasse verfügt über einen Konstruktor mit drei Parametern, um ein neues Objekt mit bestimmten Werten zu initialisieren.\n1 2 3 4 5 6 7 8 9 10 11 public class Patient { private String name; private int age; private float height; public Patient(String name, int age, float height) { this.name = name; this.age = age; this.height = height; } } Der Konstruktor akzeptiert drei Parameter. Zum Initialisieren der Felder wird das Schlüsselwort this verwendet. Es ist ein Verweis auf die aktuelle Instanz der Klasse. Dieses Schlüsselwort ist nur erforderlich, wenn die Parameter des Konstruktors denselben Namen wie die Felder der Klasse haben (um sie voneinander unterscheiden zu können). Es ist aber allgemein Best Practices das Schlüsselwort this zu verwenden.\nNun erstellen wir einige Objekte der Klasse Patient:\n1 2 Patient heinrich = new Patient(\"Heinrich\", 40, 182.0f); Patient mary = new Patient(\"Mary\", 33, 171.5f); Jetzt haben wir zwei Objekte der Klasse Patient. Die beiden Referenzen heinrich und mary besitzen im Objekt die gleichen Felder, aber die Werte dieser Felder sind pro Objekt unterschiedlich.\nEine Klasse kann mehrere Konstruktoren enthalten, solange sich die Deklarationen der Konstruktoren unterscheiden. Zum Beispiel unterschiedliche Anzahl an Argumenten oder unterschiedliche Datentypen der Argumente.\nDefault Konstruktor Der Compiler stellt automatisch einen Standardkonstruktor ohne Argumente für jede Klasse ohne Konstruktor bereit (das heisst, wir können auch Objekte einer Klasse erstellen, deren Klassenkörper leer ist).\n1 2 3 4 5 public class Patient { private String name; private int age; private float height; } Wir können eine Instanz der Klasse Patient mit dem Standardkonstruktor ohne Argumente erstellen:\n1 Patient patient = new Patient(); In diesem Fall werden alle Felder mit den Standardwerten ihrer Typen befüllt (z.B: für ein int wird 0 als Standardwert definiert). Wenn wir einen bestimmten Konstruktor definieren, wird der Standardkonstruktor nicht mehr automatisch erstellt. Wir können einen Konstruktor auch ohne Argumente definieren, und damit eigene Standardwerte für Felder einer Klasse festlegen (der Standartwert für String ist null). Zum Beispiel können wir das Feld name mit \"Unknown\" initialisieren. Durch eine solche Definition wird der Default-Konstruktor ersetzt.\n1 2 3 4 5 6 7 8 9 10 public class Patient { private String name; private int age; private float height; public Patient() { // Hier wird nur einen Wert für `name` gesetzt, die andere Felder erhalten den Standardwert für ihre respektiven Datentypen. this.name = \"Unknown\"; } } Überladen von Konstruktor Das Überladen von Konstruktoren bedeutet, dass eine Java-Klasse mehrere Konstruktoren hat, welche sich in der Anzahl der Parameter unterscheiden. Das folgende Beispiel veranschaulicht wie das aussehen könnte:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Person { private String name; private int age; // Konstruktor ohne Parameter public Person() { this(\"Unknown\", 0); // Ruft den 2-Parameter-Konstruktor mit Standardwerten auf } // Konstruktor mit 2 Parametern public Person(String name, int age) { this.name = name; this.age = age; } // Konstruktor mit nur einem Parameter (name) public Person(String name) { this(name, 0); // Ruft den 2-Parameter-Konstruktor auf, setzt age auf 0 } // Konstruktor mit nur einem Parameter (age) public Person(int age) { this(\"Unknown\", age); // Ruft den 2-Parameter-Konstruktor auf, setzt name auf \"Unknown\" } } Im Beispiel fällt auf, dass die Konstruktoren jeweils this() aufrufen. Mit this() kann man in Java aus einem Konstuktor einen Aufruf auf einen anderern Konstruktor innerhalb derselben Klasse machen. Im Beispiel wird dies verwendet, um die Logik nur in einem Konstruktor definieren zu müssen.\nZusammenfassung Jede Java-Klasse verfügt über mindestens einen Konstruktor zum Initialisieren von Objekten. Ein Konstruktor hat denselben Namen wie die Klasse, die ihn enthält. Ein Konstruktor hat keinen Rückgabewert. Wenn eine Klasse keine expliziten Konstruktoren hat, stellt der Java-Compiler automatisch einen Standardkonstruktor ohne Argumente bereit. Wird ein eigener Konstruktor definiert, so entfällt der Standardkonstruktor. ","categories":"","description":"Modul #J2\n","excerpt":"Modul #J2\n","ref":"/docs/02_java/04_java-oop/06_constructors/","tags":"","title":"Konstruktoren"},{"body":"Ziele Ich kann die zwei Hauptunterschiede von einem Konstruktor und einer gewöhnlichen Methode nennen. Ich kann in eigenen Worten erklären, was ein Konstruktor ist und wozu er verwendet wird. Ich kann in eigenen Worten erklären, was ein Default-Konstruktor ist, wann er erzeugt wird und wann er entfällt. Ich demonstriere die Anwendung von Konstruktoren anhand eines Beispiels ohne Hilfsmittel. Konstruktoren Konstruktoren sind spezielle Methoden, die benutzt werden, sobald ein neues Objekt einer Klasse erstellt wird. Ein Konstruktor einer Klasse wird aufgerufen, wenn eine neue Instanz mit dem Schlüsselwort new erstellt wird. Ein Konstruktor unterscheidet sich von anderen Methoden darin, dass:\ner den gleichen Namen haben muss wie die Klasse, die ihn enthält er keinen Rückgabetyp (nicht einmal void) hat Konstruktoren initialisieren Instanzen (Objekte) der Klasse. Sie können beliebige Parameter enthalten, um beispielsweise Instanzvariablen zu initialisieren.\nKonstruktoren verwenden Im folgenden Beispiel benutzen wir eine Klasse mit dem Namen Patient. Ein Objekt der Klasse hat einen Namen, ein Alter und eine Grösse. Die Klasse verfügt über einen Konstruktor mit drei Parametern, um ein neues Objekt mit bestimmten Werten zu initialisieren.\n1 2 3 4 5 6 7 8 9 10 11 public class Patient { private String name; private int age; private float height; public Patient(String name, int age, float height) { this.name = name; this.age = age; this.height = height; } } Der Konstruktor akzeptiert drei Parameter. Zum Initialisieren der Felder wird das Schlüsselwort this verwendet. Es ist ein Verweis auf die aktuelle Instanz der Klasse. Dieses Schlüsselwort ist nur erforderlich, wenn die Parameter des Konstruktors denselben Namen wie die Felder der Klasse haben (um sie voneinander unterscheiden zu können). Es ist aber allgemein Best Practices das Schlüsselwort this zu verwenden.\nNun erstellen wir einige Objekte der Klasse Patient:\n1 2 Patient heinrich = new Patient(\"Heinrich\", 40, 182.0f); Patient mary = new Patient(\"Mary\", 33, 171.5f); Jetzt haben wir zwei Objekte der Klasse Patient. Die beiden Referenzen heinrich und mary besitzen im Objekt die gleichen Felder, aber die Werte dieser Felder sind pro Objekt unterschiedlich.\nEine Klasse kann mehrere Konstruktoren enthalten, solange sich die Deklarationen der Konstruktoren unterscheiden. Zum Beispiel unterschiedliche Anzahl an Argumenten oder unterschiedliche Datentypen der Argumente.\nDefault Konstruktor Der Compiler stellt automatisch einen Standardkonstruktor ohne Argumente für jede Klasse ohne Konstruktor bereit (das heisst, wir können auch Objekte einer Klasse erstellen, deren Klassenkörper leer ist).\n1 2 3 4 5 public class Patient { private String name; private int age; private float height; } Wir können eine Instanz der Klasse Patient mit dem Standardkonstruktor ohne Argumente erstellen:\n1 Patient patient = new Patient(); In diesem Fall werden alle Felder mit den Standardwerten ihrer Typen befüllt (z.B: für ein int wird 0 als Standardwert definiert). Wenn wir einen bestimmten Konstruktor definieren, wird der Standardkonstruktor nicht mehr automatisch erstellt. Wir können einen Konstruktor auch ohne Argumente definieren, und damit eigene Standardwerte für Felder einer Klasse festlegen (der Standartwert für String ist null). Zum Beispiel können wir das Feld name mit \"Unknown\" initialisieren. Durch eine solche Definition wird der Default-Konstruktor ersetzt.\n1 2 3 4 5 6 7 8 9 10 public class Patient { private String name; private int age; private float height; public Patient() { // Hier wird nur einen Wert für `name` gesetzt, die andere Felder erhalten den Standardwert für ihre respektiven Datentypen. this.name = \"Unknown\"; } } Überladen von Konstruktor Das Überladen von Konstruktoren bedeutet, dass eine Java-Klasse mehrere Konstruktoren hat, welche sich in der Anzahl der Parameter unterscheiden. Das folgende Beispiel veranschaulicht wie das aussehen könnte:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Person { private String name; private int age; // Konstruktor ohne Parameter public Person() { this(\"Unknown\", 0); // Ruft den 2-Parameter-Konstruktor mit Standardwerten auf } // Konstruktor mit 2 Parametern public Person(String name, int age) { this.name = name; this.age = age; } // Konstruktor mit nur einem Parameter (name) public Person(String name) { this(name, 0); // Ruft den 2-Parameter-Konstruktor auf, setzt age auf 0 } // Konstruktor mit nur einem Parameter (age) public Person(int age) { this(\"Unknown\", age); // Ruft den 2-Parameter-Konstruktor auf, setzt name auf \"Unknown\" } } Im Beispiel fällt auf, dass die Konstruktoren jeweils this() aufrufen. Mit this() kann man in Java aus einem Konstuktor einen Aufruf auf einen anderern Konstruktor innerhalb derselben Klasse machen. Im Beispiel wird dies verwendet, um die Logik nur in einem Konstruktor definieren zu müssen.\nZusammenfassung Jede Java-Klasse verfügt über mindestens einen Konstruktor zum Initialisieren von Objekten. Ein Konstruktor hat denselben Namen wie die Klasse, die ihn enthält. Ein Konstruktor hat keinen Rückgabewert. Wenn eine Klasse keine expliziten Konstruktoren hat, stellt der Java-Compiler automatisch einen Standardkonstruktor ohne Argumente bereit. Wird ein eigener Konstruktor definiert, so entfällt der Standardkonstruktor. ","categories":"","description":"Modul #J2\n","excerpt":"Modul #J2\n","ref":"/de/docs/02_java/04_java-oop/06_constructors/","tags":"","title":"Konstruktoren"},{"body":" Dieses Kapitel gehört zum Modul #J1 des Ausbildungsplans Ziele Ich weiss, was eine bedingte Anweisung ist und kann sie korrekt anwenden. Ich kann eine Schleife programmieren: for, foreach, while und do-while. Ich kenne die switch-Anweisung. Ich kenne den ternären (ternary) Operator ⏱️ Geschätzte Lesezeit: 15 Minuten Einführung Kontrollstrukturen steuern den Ablauf eines Programms. Sie ermöglichen es, bestimmte Codeabschnitte nur unter bestimmten Bedingungen auszuführen (→ bedingte Anweisungen) oder mehrfach zu wiederholen (→ Schleifen).\nBedingte Anweisungen Eine bedingte Anweisung ist eine Konstruktion, mit der ein Programm – abhängig vom Wahrheitswert eines booleschen Ausdrucks – unterschiedliche Wege gehen kann.\nEine Anweisung ist z. B. System.out.println(...). Ein Anweisungsblock ist ein Codeblock mit { ... }, der mehrere Anweisungen enthalten kann. If-Statement 1 2 3 if (expression) { // do something } Ist der Ausdruck expression in der Klammer true, wird der Codeblock ausgeführt. Andernfalls wird er übersprungen.\nIf-Else-Statement Der obige if-Fall kann mit dem Schlüsselwort else erweitert werden, um alternative Aktionen auszuführen, wenn der Ausdruck false ist:\n1 2 3 4 5 if (expression) { // do something } else { // do something else } Im folgenden Beispiel gibt das Programm je nach Wert von num (gerade oder ungerade) unterschiedlichen Text aus. Da eine Zahl nur gerade oder ungerade sein kann, wird nur eine der beiden Ausgaben gemacht.\nBeispiel:\n1 2 3 4 5 6 int num = ...; // the num is initialized by some value if (num % 2 == 0) { System.out.println(\"It's an even number\"); } else { System.out.println(\"It's an odd number\"); } Else-If-Kette Ein Else-Statement kann durch ein If-Statement erweitert werden.\n1 2 3 4 5 6 7 8 9 if (expression0) { // do something } else if (expression1) { // do something else } else if (expressionN) { // do something else } else { // in all other cases: do this } Beispiel:\n1 2 3 4 5 6 7 8 9 10 long dollars = ...; if (dollars \u003c 1000) { System.out.println(\"Buy a laptop\"); } else if (dollars \u003c 2000) { System.out.println(\"Buy a personal computer\"); } else if (dollars \u003c 100_000) { System.out.println(\"Buy a server\"); } else { System.out.println(\"Buy a data center or a quantum computer\"); } Beachte, dass bei einem if oder else-if alle nachfolgenden else oder else-if ignoriert werden, wenn die expression wahr ist.\nWürde das else if (dollars \u003c 100_000) vor dem else if (dollars \u003c 2000) kommen, würde es nie eine Ausgabe Buy a personal computer geben, da eine Zahl kleiner 2000 immer auch kleiner als 100'000 ist.\nJetzt bist du dran. Löse bitte die folgenden !*Aufgaben in den Labs. Lernvideo Wenn du dir die Erklärung noch mit einem Video anschauen möchtest, empfehlen wir dir dieses Video. Switch-Anweisung Die switch-Anweisung prüft den Wert einer Variablen auf mehrere mögliche Fälle.\n1 2 3 4 5 6 7 8 9 10 switch (variable) { case value1: // ... break; case value2: // ... break; default: // ... } Ohne break wird in den nächsten Fall „hineingefallen“ (fall-through). Der default-Fall wird ausgeführt, wenn kein anderer Fall zutrifft.\nSeit Java 12 sind auch die folgenden Schreibweisen möglich:\n1 2 3 4 5 switch (value) { case \"happy\" -\u003e System.out.println(\"Keep smiling.\"); case \"sad\" -\u003e System.out.println(\"Don't be sad!\"); default -\u003e System.out.println(\"Unknown mood\"); } Switch mit Rückgabe:\n1 2 3 4 5 6 7 8 9 10 int place = 1; String suffix = switch (place) { case 1 -\u003e \"st\"; case 2 -\u003e \"nd\"; case 3 -\u003e \"rd\"; default -\u003e \"th\"; }; System.out.println(\"You're on the \" + place + suffix + \" place.\"); Ternärer (Ternary) Operator Ternär bedeutet „drei-teilig“. Ein ternärer Operator hat:\neine Bedingung, einen Wert, wenn sie true ist, einen Wert, wenn sie false ist. Mit dem ternären Operator kannst du kurz und elegant eine Bedingung mit Rückgabe formulieren:\nbedingung ? wertWennTrue : wertWennFalse\nBeispiel:\n1 2 3 4 5 6 7 8 9 10 String tooYoung = \"You are too young\"; String oldEnough = \"You are old enough :)\"; int age = 17; System.out.println(age \u003e= 18 ? oldEnough : tooYoung); // Output: You are too young age = 26; System.out.println(age \u003e= 18 ? oldEnough : tooYoung); // Output: You are old enough :) Verschachtelter Ternary Operator: 1 2 3 4 5 6 7 8 int years = 12; String rank = years \u003e= 20 ? \"Kage\" : years \u003e= 10 ? \"Chunin\" : years \u003e= 5 ? \"Academy Student\" : \"Candidate\"; System.out.println(\"Your current rank is \" + rank); // Output: Your current rank is Chunin Verschachtelte ternäre Operatoren sind schwer lesbar. Wenn du merkst, dass du beim Lesen Mühe hast, verwende lieber eine if-else-Struktur. Jetzt bist du dran. Löse bitte die folgenden !*Aufgaben in den Labs. Schleifen (Loops) Mit Schleifen können Anweisungen wiederholt ausgeführt werden.\nWhile-Schleife Bei der while-Schleife wird die nachfolgende Anweisung oder der nachfolgende Anweisungs-Block solange ausgeführt, bis die Bedingung nicht mehr erfüllt ist. Falls die Bedingung bereits vor der ersten Prüfung nicht erfüllt ist, wird die nachfolgende Anweisung oder der nachfolgende Anweisungs-Block nie ausgeführt.\n1 2 3 while (condition) { // do something } Beispiel:\n1 2 3 4 5 6 int i = 0; while (i \u003c 5) { System.out.print(i + \" \"); i++; } // Output: 0 1 2 3 4 Do-While-Schleife Die do-while-Schleife funktionert gleich wie die while-Schleife mit dem Unterschied, das die Anweisung oder der Anweisungs-Block mindestens einmal ausgeführt wird, bevor die Bedingung überprüft wird.\n1 2 3 do { // do something } while (condition); Diese Schleife wird mindestens einmal ausgeführt.\nFor-Schleife Bei der for-Schleife wird ein Wert initialisert, die Bedingung überprüft und wenn die Bedingung erfüllt ist, wird die nachfolgende Anweisung oder der nachfolgende Anweisungs-Block ausgeführt und der Wert kann über Anweisungen modifiziert werden.\n1 2 3 for (initialization; condition; modification) { // do something } Beispiel:\n1 2 3 4 5 int n = 9; for (int i = 0; i \u003c= n; i++) { System.out.print(i + \" \"); } // Output: 0 1 2 3 4 5 6 7 8 9 Bei diesem Beispiel wird System.out.print(i + \" \"); für alle Zahlen i von 0 bis 9 ausgeführt.\nLernvideo Wenn du dir die Erklärung noch mit einem Video anschauen möchtest, empfehlen wir dir dieses Video (YouTube). Jetzt bist du dran. Löse bitte die folgenden !*Aufgaben in den Labs. ","categories":"","description":"In diesem Modul lernst du, wie du mit Kontrollstrukturen wie Bedingungen und Schleifen den Ablauf eines Programms gezielt steuerst.\n","excerpt":"In diesem Modul lernst du, wie du mit Kontrollstrukturen wie …","ref":"/docs/02_java/03_java-grundlagen/06_control_structures/","tags":"","title":"Kontrollstrukturen"},{"body":"Lombok ist ein Java-Library, welche die Entwicklung von Java-Anwendungen erleichtert, indem sie die Erstellung von Standardcode reduziert, insbesondere für Getter, Setter, Konstruktoren und andere repetitive Teile des Codes. Es automatisiert die Erstellung dieser Boilerplate-Code-Teile (*) und verbessert somit die Lesbarkeit und Wartbarkeit des Codes.\n(*) Info: Boilerplate-Code ist wiederkehrender Code, der in verschiedenen Teilen einer Softwareanwendung benötigt wird, aber wenig zur eigentlichen Funktionalität beiträgt.\nWofür wird Lombok verwendet? Reduzierung des Boilerplate-Codes: Lombok eliminiert die Notwendigkeit, viele standardmässige Java-Boilerplate-Codezeilen wie Getter, Setter, Konstruktoren und toString-Methoden manuell zu schreiben.\nVerbesserte Lesbarkeit: Durch die Reduzierung von Boilerplate-Code wird der Quellcode klarer und lesbarer, da unnötige Details ausgeblendet werden.\nKompakte Klassen: Lombok ermöglicht es, Klassen mit weniger Code zu erstellen, was die Wartung und das Verständnis des Codes erleichtert.\nEinige häufig verwendete Annotationen sind @Getter, @Setter, @NoArgsConstructor, @AllArgsConstructor, usw.\nIn folgendem Beispiel werden Getter und Setter automatisch von Lombok generiert, sobald die Annotationen @Getter und @Setter über den Klassenattributen firstname und lastname verwendet werden. Jedoch für age werden sie nicht generiert.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import lombok.Getter; import lombok.Setter; public class Person { @Getter @Setter private String firstname; @Getter @Setter private String lastname; private int age; } Wenn es jedoch alle Klassenattribute betrifft, muss man nicht über jedem Klassenattribut die Annotationen hinzufügen, sondern man kann es auch folgendermassen schreiben.\n1 2 3 4 5 6 7 8 9 10 11 12 13 import lombok.Getter; import lombok.Setter; @Getter @Setter public class Person { private String firstname; private String lastname; private int age; } @NoArgsConstructor: Diese Annotation wird verwendet, um einen parameterlosen Konstruktor automatisch zu generieren. Sie ist besonders nützlich, wenn Klassen benötigt werden, welche von Frameworks instanziiert werden müssen.\n1 2 3 4 5 6 7 import lombok.NoArgsConstructor; @NoArgsConstructor public class Person { private String name; private int age; } @AllArgsConstructor: Diese Annotation wird verwendet, um einen Konstruktor automatisch zu generieren, der alle Felder der Klasse als Parameter akzeptiert. Dieser Konstruktor ist besonders nützlich, wenn eine Klasse erstellt werden soll, bei welcher man den gesamten Zustand über den Konstruktor initialisieren möchte.\n1 2 3 4 5 6 7 import lombok.AllArgsConstructor; @AllArgsConstructor public class Person { private String name; private int age; } Maven Dependency Im POM.xml muss folgende Dependency hinzugefügt werden.\n1 2 3 4 5 \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003cversion\u003e1.18.34\u003c/version\u003e \u003c/dependency\u003e Vorteile von Lombok Kompaktheit: Lombok reduziert die Menge an Code, welcher geschrieben werden muss, um Getter und Setter etc. zu implementieren. Dadurch wird der Quellcode kompakter und einfacher zu lesen.\nZeitersparnis: Lombok automatisiert die Generierung von Boilerplate-Code, was Entwicklern Zeit spart, die sie sonst mit dem manuellen Schreiben dieser Methoden verbringen würden.\nWartbarkeit: Durch die Reduzierung von Boilerplate-Code minimiert Lombok die Möglichkeit von Fehlern und erleichtert die Wartung des Codes.\nNachteile von Lombok Transparenz: Für Entwickler, die nicht mit Lombok vertraut sind, kann der automatisch generierte Code möglicherweise undurchsichtig sein, da er nicht explizit im Quellcode angezeigt wird.\nAbhängigkeit: Die Verwendung von Lombok bedeutet, dass ein Projekt von der Lombok-Library abhängig ist. Wenn man Library-Dependencies minimieren möchten, kann dies als Nachteil angesehen werden.\nWeniger Kontrolle: Bei der Verwendung von Lombok hat man möglicherweise weniger Kontrolle über den generierten Code im Vergleich zur manuellen Implementierung.\nLombok mit IntelliJ Falls du in IntelliJ Probleme mit Lombok hast, kann es sein, dass das Annotation-Processing abgestellt ist. Helfen kann der der folgende Artikel: Baeldung: Setting up Lombok with Eclipse and Intellij.\nOptional: Finde mehr Informationen zu Lombok und was es kann unter: Lombok Features\nGit ready?! Falls du dich noch nicht intensiver mit Git auseinandergesetzt hast, ist jetzt die Zeit dafür: Erarbeite Git!\nBitte kehre nach Abschluss des Git-Moduls hierhin zurück und fahre mit der nächsten Seite fort.\n","categories":"","description":"Module #J3 - Vor- und Nachteile von Lombok\n","excerpt":"Module #J3 - Vor- und Nachteile von Lombok\n","ref":"/docs/02_java/06_lombok/","tags":"","title":"Lombok"},{"body":"Lombok ist ein Java-Library, welche die Entwicklung von Java-Anwendungen erleichtert, indem sie die Erstellung von Standardcode reduziert, insbesondere für Getter, Setter, Konstruktoren und andere repetitive Teile des Codes. Es automatisiert die Erstellung dieser Boilerplate-Code-Teile (*) und verbessert somit die Lesbarkeit und Wartbarkeit des Codes.\n(*) Info: Boilerplate-Code ist wiederkehrender Code, der in verschiedenen Teilen einer Softwareanwendung benötigt wird, aber wenig zur eigentlichen Funktionalität beiträgt.\nWofür wird Lombok verwendet? Reduzierung des Boilerplate-Codes: Lombok eliminiert die Notwendigkeit, viele standardmässige Java-Boilerplate-Codezeilen wie Getter, Setter, Konstruktoren und toString-Methoden manuell zu schreiben.\nVerbesserte Lesbarkeit: Durch die Reduzierung von Boilerplate-Code wird der Quellcode klarer und lesbarer, da unnötige Details ausgeblendet werden.\nKompakte Klassen: Lombok ermöglicht es, Klassen mit weniger Code zu erstellen, was die Wartung und das Verständnis des Codes erleichtert.\nEinige häufig verwendete Annotationen sind @Getter, @Setter, @NoArgsConstructor, @AllArgsConstructor, usw.\nIn folgendem Beispiel werden Getter und Setter automatisch von Lombok generiert, sobald die Annotationen @Getter und @Setter über den Klassenattributen firstname und lastname verwendet werden. Jedoch für age werden sie nicht generiert.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import lombok.Getter; import lombok.Setter; public class Person { @Getter @Setter private String firstname; @Getter @Setter private String lastname; private int age; } Wenn es jedoch alle Klassenattribute betrifft, muss man nicht über jedem Klassenattribut die Annotationen hinzufügen, sondern man kann es auch folgendermassen schreiben.\n1 2 3 4 5 6 7 8 9 10 11 12 13 import lombok.Getter; import lombok.Setter; @Getter @Setter public class Person { private String firstname; private String lastname; private int age; } @NoArgsConstructor: Diese Annotation wird verwendet, um einen parameterlosen Konstruktor automatisch zu generieren. Sie ist besonders nützlich, wenn Klassen benötigt werden, welche von Frameworks instanziiert werden müssen.\n1 2 3 4 5 6 7 import lombok.NoArgsConstructor; @NoArgsConstructor public class Person { private String name; private int age; } @AllArgsConstructor: Diese Annotation wird verwendet, um einen Konstruktor automatisch zu generieren, der alle Felder der Klasse als Parameter akzeptiert. Dieser Konstruktor ist besonders nützlich, wenn eine Klasse erstellt werden soll, bei welcher man den gesamten Zustand über den Konstruktor initialisieren möchte.\n1 2 3 4 5 6 7 import lombok.AllArgsConstructor; @AllArgsConstructor public class Person { private String name; private int age; } Maven Dependency Im POM.xml muss folgende Dependency hinzugefügt werden.\n1 2 3 4 5 \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003cversion\u003e1.18.34\u003c/version\u003e \u003c/dependency\u003e Vorteile von Lombok Kompaktheit: Lombok reduziert die Menge an Code, welcher geschrieben werden muss, um Getter und Setter etc. zu implementieren. Dadurch wird der Quellcode kompakter und einfacher zu lesen.\nZeitersparnis: Lombok automatisiert die Generierung von Boilerplate-Code, was Entwicklern Zeit spart, die sie sonst mit dem manuellen Schreiben dieser Methoden verbringen würden.\nWartbarkeit: Durch die Reduzierung von Boilerplate-Code minimiert Lombok die Möglichkeit von Fehlern und erleichtert die Wartung des Codes.\nNachteile von Lombok Transparenz: Für Entwickler, die nicht mit Lombok vertraut sind, kann der automatisch generierte Code möglicherweise undurchsichtig sein, da er nicht explizit im Quellcode angezeigt wird.\nAbhängigkeit: Die Verwendung von Lombok bedeutet, dass ein Projekt von der Lombok-Library abhängig ist. Wenn man Library-Dependencies minimieren möchten, kann dies als Nachteil angesehen werden.\nWeniger Kontrolle: Bei der Verwendung von Lombok hat man möglicherweise weniger Kontrolle über den generierten Code im Vergleich zur manuellen Implementierung.\nLombok mit IntelliJ Falls du in IntelliJ Probleme mit Lombok hast, kann es sein, dass das Annotation-Processing abgestellt ist. Helfen kann der der folgende Artikel: Baeldung: Setting up Lombok with Eclipse and Intellij.\nOptional: Finde mehr Informationen zu Lombok und was es kann unter: Lombok Features\nGit ready?! Falls du dich noch nicht intensiver mit Git auseinandergesetzt hast, ist jetzt die Zeit dafür: Erarbeite Git!\nBitte kehre nach Abschluss des Git-Moduls hierhin zurück und fahre mit der nächsten Seite fort.\n","categories":"","description":"Module #J3 - Vor- und Nachteile von Lombok\n","excerpt":"Module #J3 - Vor- und Nachteile von Lombok\n","ref":"/de/docs/02_java/06_lombok/","tags":"","title":"Lombok"},{"body":" Voraussetzung Du kennst die Befehle for, while und do. Wir stellen dir bei den Übungen jeweils komplette Projekte zur Verfügung. Du musst grundsätzlich nur dort was anpassen, wo die folgende Kommentarzeile steht:\nKopieren // IT-Ninja: Füge hier Deinen Code ein: 1 // IT-Ninja: Füge hier Deinen Code ein: Alles andere kannst du für den Moment ignorieren. Wir erklären dir die einzelnen Zeilen Schritt für Schritt in den Modulen.\nVorbereitungsarbeiten Drücke auf den Pfeil links um eine detaillierte Anleitung zu erhalten, wie Du den Quellcode auf deinem Rechner ablegen sollst.\nDiese Schritte musst du bei jeder Übung erneut machen. Jede Übung hat ein eigenes ZIP-File, welches du bei dir an die richtige Stelle kopieren musst. Die Anleitung zeigt dir ziemlich gut, wie das geht… Liess vor allem am Anfang die detaillierte Anleitung gut durch und befolge die Schritte exakt. Sie helfen dir, deinen Quellcode gut organisiert, strukturiert und sicher zu verwalten. Falls du die Anleitung schon auswendig kennst, findest du den Quellcode zur Übung direkt hier: Download | Online anschauen\nNeu bei it-ninja?\nDie Anleitung enthält einige Befehle und Fachbegriffe, die dir möglicherweise noch nichts sagen. Mach dir deswegen keine Sorgen – in den kommenden Modulen erklären wir dir alles Schritt für Schritt. Schon bald wirst auch du ein it-ninja sein. Um die folgenden Aufgaben erfolgreich umzusetzen, führe diese Schritte aus:\nBeim ersten Mal:\nIntelliJ IDEA installieren → !*IntelliJ IDEA einrichten Git-Repository einrichten → !*Persönliches Git-Repository Öffne eine !*CMD-Shell und wechsle ins Verzeichnis deines Git-Repositories:\nKopieren cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git status 1 2 cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git status Kopieren cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git status 1 2 cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git status Stelle sicher, dass alle Dateien im Git-Repository committed sind. Mit git status erhältst du eine Übersicht: Kopieren git status 1 git status Falls du bei diesem Befehl einen roten Text siehst, musst du zuerst die aktuellen Dateien sichern:\nKopieren git add . git commit -m \"[gescheiter Kommentar]\" 1 2 git add . git commit -m \"[gescheiter Kommentar]\" Erstelle oder wechsle in den Template Branch:\nBeim ersten Mal musst du einen Template Branch erstellen:\nKopieren git checkout -b \"templates\" 1 git checkout -b \"templates\" Falls er bereits existiert, kannst du einfach switchen:\nKopieren git switch \"templates\" 1 git switch \"templates\" Lade den Source-Code zu den Übungen herunter und entpacke ihn im Root-Verzeichnis deines lokalen Repositories:\n[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\nDen Source-Code findest du hier: Download | Online anschauen\nCommitte den originalen Source-Code, damit er sicher im Repository gespeichert ist:\nKopieren git add . git commit -m \"Add it-ninja_02_java_03_java-grundlagen_06_control-structures-loops\" git push 1 2 3 git add . git commit -m \"Add it-ninja_02_java_03_java-grundlagen_06_control-structures-loops\" git push Erstelle einen neuen Branch, um deine Lösung zu implementieren: Kopieren git checkout -b \"labs/it-ninja_02_java_03_java-grundlagen_06_control-structures-loops\" 1 git checkout -b \"labs/it-ninja_02_java_03_java-grundlagen_06_control-structures-loops\" Hier kannst du auch einen kürzeren Namen wählen. Verwende labs am Anfang des Branch-Namens für Branches, die deinen eigenen Code enthalten.\nStelle dir einen Branch vorerst als Ordner vor. Jeder Ordner enthält eine Version oder einen Stand von deinem Quellcode. Du kannst dann mit git zwischen diesen Ordern hin und her wechseln, sie vergleichen aber später auch zusammenführen.\nPro-Tipp:\nDu kannst jederzeit einen weiteren Branch erstellen – z. B. wenn du etwas ausprobieren möchtest. Alternativ kannst du auch in der Git-History einen alten Stand wiederherstellen, was aber weniger flexibel ist. Starte IntelliJ und öffne mit File → Open das Verzeichnis mit dem Source-Code. Du musst mit IntelliJ den Ordner suchen, welches einen Ordner src oder die Datei pom.xml enthält. Ansonsten wird IntelliJ Mühe haben, dir das Programm zu kompilieren. Wenn du alles korrekt gemacht hast, findest du das Projekt hier:\nKopieren `[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\\02_java\\03_java-grundlagen\\06_control-structures-loops` 1 `[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\\02_java\\03_java-grundlagen\\06_control-structures-loops` Kopieren `[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\\02_java/03_java-grundlagen/06_control-structures-loops` 1 `[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\\02_java/03_java-grundlagen/06_control-structures-loops` Falls du zum ersten Mal mit IntelliJ arbeitest, findest du !*hier eine Anleitung, wie man ein Programm startet. Um das Programm zu starten musst du jeweils die Datei Main.java öffenen. Dann sollte in IntelliJ oben rechts ein grünes Dreieck vorhanden sein, welches das Programm startet. Nun bist du bereit, die untenstehenden Aufgaben zu lösen.\nWenn du alle Änderungen gemacht hast und mit der Übung fertig bist, oder einen ‘Zwischenstand’ festhalten willst, führe die folgenden Befehle aus um das Repository auf dem Server zu speichern (von wo du es geklont hast):\nKopieren cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git add --all git commit -m \"Kurzer Kommentar\" 1 2 3 cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git add --all git commit -m \"Kurzer Kommentar\" Kopieren cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git add . git commit -m \"Kurzer Kommentar\" 1 2 3 cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git add . git commit -m \"Kurzer Kommentar\" Wenn du deine Änderungen auf dem Git-Server sichern willst, musst du das mit einem push machen.\nBeim ersten mal musst du git noch mitteilen, wie der Branch auf dem Git-Server heissen soll:\nKopieren git push --set-upstream origin labs/it-ninja_02_java_03_java-grundlagen_06_control-structures-loops 1 git push --set-upstream origin labs/it-ninja_02_java_03_java-grundlagen_06_control-structures-loops Bei weiteren pushes wird es dann einfacher:\nKopieren git push 1 git push Die meisten Übungen sind professionell strukturiert – so wie in echten Softwareprojekten. Zu gutem Code gehören auch Tests, die sicherstellen, dass dein Code wie erwartet funktioniert. Sofern nicht anders erwähnt, kannst du mit folgendem Befehl im Root-Verzeichnis des Projekts (dort, wo sich auch die pom.xml befindet) überprüfen, ob du die Aufgabe korrekt gelöst hast:\n1 mvn test Viel Erfolg!\nAufgabe 1 - Summe aller durch 8 teilbaren Zahlen von 1 bis 100 Passe die folgende Methode an. Zähle alle Zahlen von 1 bis 100 zusammen, welche durch 8 teilbar sind und gib das Resultat auf der Konsole aus:\nDie Summe aller durch 8 teilbaren Zahlen von 1 bis 100 beträgt 624. Im zur Übung gehörendem Source kannst Du die Änderung an folgender Stelle machen:\nsrc\\main\\java\\ch\\itninja\\labs\\basicexercises\\NumberHelper.java:\n1 2 3 4 public static void sumDivisibleByEightFixedRange() { // IT-Ninja: Füge hier Deinen Code ein: } Beispiel:\nEingabe:\n1 NumberHelper.sumDivisibleByEightFixedRange() Ausgabe:\n1 Die Summe aller durch 8 teilbaren Zahlen von 1 bis 100 beträgt 624. Aufgabe 2 - Summe aller durch X teilbaren Zahlen Passe die folgende Methode an. Zähle alle Zahlen von min bis max zusammen, welche durch divisor teilbar sind und gib das Resultat auf der Konsole aus:\nDie Summe aller durch [divisor] teilbaren Zahlen von [min] bis [max] beträgt [result]. Abgrenzung: Wenn max kleiner als min ist oder wenn divisor kleiner gleich 0 ist, soll folgender Text auf der Konsole ausgegeben werden: Berechnung mit diesen Werten nicht möglich\nIm zur Übung gehörendem Source kannst Du die Änderung an folgender Stelle machen:\nsrc\\main\\java\\ch\\itninja\\labs\\basicexercises\\NumberHelper.java:\n1 2 3 4 public static void sumDivisibleBy(int min, int max, int divisor) { // IT-Ninja: Füge hier Deinen Code ein: } Beispiel 1:\nEingabe:\n1 NumberHelper.sumDivisibleBy(10, 30, 7); Ausgabe:\n1 Die Summe aller durch 7 teilbaren Zahlen von 10 bis 30 beträgt 63. Beispiel 2:\nEingabe:\n1 NumberHelper.sumDivisibleBy(30, 10, 7); Ausgabe:\n1 Berechnung mit diesen Werten nicht möglich. Aufgabe 3 - Summe gemeinsames Vielfaches zweier Zahlen Passe die folgende Methode an. Zähle alle Zahlen von min bis max zusammen, welche ein gemeinsames Vielfaches von den beiden Zahlen number1 und number2sind und gib das Resultat auf der Konsole aus:\nSumme der Zahlen von [min] bis [max], die ein gemeinsames Vielfache von [number1] und [number2] sind: [result]. Abgrenzung: Wenn max kleiner als min ist oder wenn eine der Zahlen number1 oder ’number2’ kleiner gleich 0 ist, soll folgender Text auf der Konsole ausgegeben werden: Berechnung mit diesen Werten nicht möglich\nIm zur Übung gehörendem Source kannst Du die Änderung an folgender Stelle machen:\nsrc\\main\\java\\ch\\itninja\\labs\\basicexercises\\NumberHelper.java:\n1 2 3 4 public static void sumCommonMultiples(int min, int max, int number1, int number2) { // IT-Ninja: Füge hier Deinen Code ein: } Beispiel 1:\nEingabe:\n1 NumberHelper.sumCommonMultiples(1, 50, 3, 5); Ausgabe:\n1 Summe der Zahlen von 1 bis 50, die ein gemeinsames Vielfache von 3 und 5 sind: 90. Beispiel 2:\nEingabe:\n1 NumberHelper.sumCommonMultiples(1, 100, 4, 6); Ausgabe:\n1 Summe der Zahlen von 1 bis 100, die ein gemeinsames Vielfache von 4 und 6 sind: 432. Beispiel 3:\nEingabe:\n1 NumberHelper.sumCommonMultiples(1, 10, 4, 6); Ausgabe:\n1 Summe der Zahlen von 1 bis 10, die ein gemeinsames Vielfache von 4 und 6 sind: 0. Beispiel 4:\nEingabe:\n1 NumberHelper.sumCommonMultiples(50, 1, 3, 5); Ausgabe:\n1 Berechnung mit diesen Werten nicht möglich. Beispiel 5:\nEingabe:\n1 NumberHelper.sumCommonMultiples(15, 15, 3, 5); Ausgabe:\n1 Summe der Zahlen von 15 bis 15, die ein gemeinsames Vielfache von 3 und 5 sind: 15. Beispiel 6:\nEingabe:\n1 NumberHelper.sumCommonMultiples(60, 60, 4, 6); Ausgabe:\n1 Summe der Zahlen von 60 bis 60, die ein gemeinsames Vielfache von 4 und 6 sind: 60. Beispiel 7:\nEingabe:\n1 NumberHelper.sumCommonMultiples(-30, 30, 6, 10); Ausgabe:\n1 Summe der Zahlen von -30 bis 30, die ein gemeinsames Vielfache von 6 und 10 sind: 0. Beispiel 8:\nEingabe:\n1 NumberHelper.sumCommonMultiples(1, 1000, 8, 12); Ausgabe:\n1 Summe der Zahlen von 1 bis 1000, die ein gemeinsames Vielfache von 8 und 12 sind: 20664. ","categories":"","description":"Mit diesen Übungen kannst du dein Wissen über die Befehle `for`, `while` und `do` vertiefen.\n","excerpt":"Mit diesen Übungen kannst du dein Wissen über die Befehle `for`, …","ref":"/labs/02_java/03_java-grundlagen/06_control-structures-loops/","tags":"","title":"Java Exercises - Loops"},{"body":"Ziele Ich kann arithmetische Ausdrücke schreiben: Addition, Subtraktion, Multiplikation, Division, Modulo (Rest einer Division). Ich kenne die relationalen Operatoren: ==, \u003e=, \u003c=, \u003e, \u003c, !=. Ich kenne die booleschen Operatoren: \u0026\u0026 (AND), || (OR), ! (NOT), ^(XOR). Mathematik \u0026 Logik Mathe in Java ist sehr einfach. Beachte, dass mathematische Java-Operationen einer bestimmten Reihenfolge folgen (Punkt-Operationen vor Strich-Operationen)\nArithmetische Operatoren Symbol Arithmetische Operation Beispiel + Addition int sum = 2 + 3; - Subtraktion int difference = 5 – 2; / Division int quotient = 15 / 5; * Multiplikation int product = 3 * 4; % Division mit Rest int remainder = 7 % 3; ++ Post und Prä-Inkrement (1 addieren) count++; // (count = count + 1) - - Post und Prä-Dekrement (1 subtrahieren) count--; // (count = count – 1) Post- und Prä-Inkrement Das Inkrementieren und Dekrementieren von Variablen ist eine sehr häufige Operation. Von diesem Operator gibt es zwei Varianten:\nEr kann vor der Variable stehen, wie in ++i (Präfix-Schreibweise) oder dahinter, wie bei i++ (Postfix-Schreibweise) Der Präfix-Operator verändert die Variable vor der Auswertung der Programmzeile, und der Postfix-Operator ändert sie nach der Auswertung der Programmzeile. Mit anderen Worten: Nutzen wir einen Präfix-Operator, so wird die Variable erst herauf- bzw. heruntergesetzt und dann der Wert geliefert. Und beim Post-Operator ist es genau umgekehrt.\nPostinkrement 1 2 3 int i = 5; int c = i++; // c = 5 // ab hier ist i = 6 Präinkrement 1 2 int i = 5; int d = ++i; // d = 6 Postdekrement 1 2 3 int i = 5; int e = i--; // e = 5 // ab hier ist i = 4 Prädekrement 1 2 int i = 5; int f = --i; // f = 4 Vegleichsoperatoren Die Ergebnisse dieser Operationen sind stets Boolean-Werte.\nSymbol Vergleich Beispiel \u003e grösser als 5 \u003e 4 \u003c kleiner als 4 \u003c 5 \u003e= grösser gleich 3 \u003e= 3 \u003c= kleiner gleich 3 \u003c= 3 == gleich 2 == 2 != ungleich 2 != 4 Boolsche Operatoren Diese Operatoren basieren auf der boolschen Algebra. Daher arbeiten boolsche Operatoren direkt mit boolschen Werten. Es gibt vier Arten von boolschen Operatoren. Schauen wir uns zunächst ihre Symbole und deren Inhalt in der folgenden Tabelle an, bevor wir erläutern, welche Funktionen sie ausführen.\nSymbol Boolsche Operation Erklärung \u0026\u0026 Logisches UND (AND) AND gibt nur dann true zurück, wenn die Ausdrücke auf beiden Seiten des Operators true sind (Hinweis: Dieser Ausdruck wird lazy evaluiert. Dies bedeuetet, wenn der erste Ausdruck false ist, wird der zweite Ausdruck nicht mehr ausgewertet || Logisches ODER (OR) OR gibt true zurück, wenn der Ausdruck auf einer oder beiden Seiten des Operators true ist (Hinweis: Dieser Ausdruck wird lazy evaluiert. Dies bedeuetet, wenn der erste Ausdruck true ist, wird der zweite Ausdruck nicht mehr ausgewertet ! Logisches NICHT (NOT) NOT kehrt den Wert des darauffolgenden booleschen Ausdrucks um. Aus true wird also false und umgekehrt ^ Logisches ENTWEDER-ODER (XOR) XOR gibt true zurück, wenn die beiden Ausdrücke unterschiedlich sind \u0026 Logisches UND (AND) Im Unterschied zum obigen AND wertet dieses immer beide Ausdrücke aus | Logisches ODER (OR) Im Unterschied zum obigen OR wertet dieses immer beide Ausdrücke aus. Ternary Operator Mit dem Ternary Operator kann eine bedingte Zuweisung eines Werts durchgeführt werden. Dies kann nützlich sein, wenn es im Code zwei mögliche Werte gibt. Der Ternary Operator wird mit einem ? dargestellt. Der Aufbau ist folgendermassen: bedingung ? wert wenn Bedingung wahr : wert wenn Bedingung falsch\nSchauen wir uns noch ein Beispiel in Java an:\n1 2 3 4 5 6 7 8 9 int alter = 17; String zuJung = \"Du bist zu jung\"; String genugAlt = \"Du bist alt genug :)\"; System.out.println(alter \u003e= 18 ? genugAlt : zuJung); // Ausgabe: \"Du bist zu jung\", da das Alter kleiner als 18 ist. alter = 26; System.out.println(alter \u003e= 18 ? genugAlt : zuJung); // Ausgabe: \"Du bist alt genug :)\", da das Alter grösser als 18 ist. Ausserdem können mehrere Ternary hintereinander platziert werden:\n1 2 3 4 5 6 7 int ausbildungsjahre = 5; System.out.println(\"Dein aktueller Rang ist \" + ausbildungsjahre \u003e= 20 ? \"Kage\" : ausbildungsjahre \u003e= 10 ? \"Chunin\" : ausbildungsjahre \u003e= 5 ? \"Akademieschüler\" : \"Anwärter\"); // Ausgabe: \"Dein aktueller Rang ist Akademieschüler\", da Ausbildungs Jahre \u003e= 5 Jetzt bist du dran. Löse bitte die Aufgabe 4 in den Labs.\n","categories":"","description":"Modul #J1\n","excerpt":"Modul #J1\n","ref":"/de/docs/02_java/03_java-grundlagen/06_logic/","tags":"","title":"Mathematik \u0026 Logik"},{"body":"java.util.Queue Eine Queue ist ähnlich einem Stack ein Behälter, in den Elemente eingefügt und nur in einer bestimmten Reihenfolge wieder entnommen werden können. Bei den Queues gilt das First In First Out (=FIFO) Prinzip: Das Einfügen eines Elements erfolgt an einem Ende und heisst EnQueue. Die Entfernung eines Elements erfolgt dann am anderen Ende und heisst DeQueue. Das heisst also, das erste Elemente, das einer Queue eingefügt wird, ist das Element das zuerst der Queue entnommen werden kann. Queues können in ihrer Grösse beschränkt oder unbeschränkt sein.\nAuf Deutsch könnte man Queues als “Warteschlangen” bezeichnen. Wir kennen Warteschlangen von unserem Alltag: Beispielsweise vom Einkaufen, wo es eine Schlange von Kunden gibt, die an der Kasse auf einen Kassierer warten. Ein Kunde stellt sich zu hinterst an und rückt “in der Warteschlange” vor, wenn vorherigen Kunden bedient wurden.\nAlle Methoden vom Interface java.util.Queue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 /* * Fügt das angegebene Element in diese Queue ein, * wenn dies möglich ist, ohne Kapazitätsbeschränkungen zu verletzen. * Bei Erfolg wird true zurückgegeben. Eine IllegalStateException wird ausgelöst, wenn derzeit * kein Platz verfügbar ist. */ boolean add(E e); /* * Fügt das angegebene Element in diese Queue ein, * wenn dies möglich ist, ohne Kapazitätsbeschränkungen zu verletzen. * Bei Erfolg wird true zurückgegeben und sonst wird false zurückgegeben. * * Bei der Verwendung einer Queue mit Kapazitätsbeschränkungen ist diese Methode in der Regel add(E e) vorzuziehen, * da bei Verletzung der Kapazitätsbeschränkungen keine Exception geworfen wird, sondern false zurückgegeben wird. * */ boolean offer(E e); /* * Gibt das Element am Anfang des Queues zurück und entfernt es in der Queue. * Falls die Queue leer ist, dann wird null zurückgegeben. */ E poll(); /* * Gibt das Element am Anfang des Queues zurück und entfernt es in der Queue. * Diese Methode unterscheidet sich von poll() nur darin, dass sie eine Exception auslöst, wenn die Queue leer ist. */ E remove(); /* * Gibt das Element am Anfang des Queues zurück, entfernt es aber nicht. * Gibt null zurück, wenn die Queue leer ist. */ E peek(); /* * Gibt das Element am Anfang des Queues zurück, entfernt es aber nicht. * Diese Methode unterscheidet sich von peek() nur darin, dass sie eine Exception auslöst, wenn die Queue leer ist. */ E element(); java.util.Deque Die Deque ist eine Queue mit zwei Enden, und Datenelemente können an beiden Enden hinzugefügt oder entfernt werden. Die Deque in Java wird über die das Interface java.util.Deque implementiert, die ein Subtyp des Interface java.util.Queue ist.\nAlle Methoden vom Interface java.util.Deque 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 /* * Fügt das angegebene Element an den Anfang dieser Deque ein, * wenn dies möglich ist, ohne Kapazitätsbeschränkungen zu verletzen * und löst eine IllegalStateException aus, wenn derzeit kein Platz verfügbar ist. */ void addFirst(E e); /* * Fügt das angegebene Element an das Ende dieser Deque ein, * wenn dies möglich ist, ohne Kapazitätsbeschränkungen zu verletzen * und löst eine IllegalStateException aus, wenn derzeit kein Platz verfügbar ist. */ void addLast(E e); /* * Fügt das angegebene Element an den Anfang dieser Deque ein, * wenn dies möglich ist, ohne Kapazitätsbeschränkungen zu verletzen. * Bei Erfolg wird true zurückgegeben und sonst wird false zurückgegeben. * * Bei der Verwendung einer Deque mit Kapazitätsbeschränkungen ist diese Methode in der Regel addFirst(E e) vorzuziehen, * da bei Verletzung der Kapazitätsbeschränkungen keine Exception geworfen wird, sondern false zurückgegeben wird. * */ boolean offerFirst(E e); /* * Fügt das angegebene Element an das Ende dieser Deque ein, * wenn dies möglich ist, ohne Kapazitätsbeschränkungen zu verletzen. * Bei Erfolg wird true zurückgegeben und sonst wird false zurückgegeben. * * Bei der Verwendung einer Deque mit Kapazitätsbeschränkungen ist diese Methode in der Regel addLast(E e) vorzuziehen, * da bei Verletzung der Kapazitätsbeschränkungen keine Exception geworfen wird, sondern false zurückgegeben wird. * */ boolean offerLast(E e); /* * Gibt das Element am Anfang des Deques zurück und entfernt es in der Deque. * Falls die Deque leer ist, dann wird null zurückgegeben. */ E pollFirst(); /* * Gibt das Element am Ende des Deques zurück und entfernt es in der Deque. * Falls die Deque leer ist, dann wird null zurückgegeben. */ E pollLast(); /* * Gibt das Element am Anfang des Deques zurück und entfernt es in der Deque. * Diese Methode unterscheidet sich von pollFirst() nur darin, dass sie eine Exception auslöst, wenn die Deque leer ist. */ E removeFirst(); /* * Gibt das Element am Ende des Deques zurück und entfernt es in der Deque. * Diese Methode unterscheidet sich von pollLast() nur darin, dass sie eine Exception auslöst, wenn die Deque leer ist. */ E removeLast(); /* * Gibt das Element am Anfang des Deques zurück, entfernt es aber nicht. * Gibt null zurück, wenn die Deque leer ist. */ E peekFirst(); /* * Gibt das Element am Ende des Deques zurück, entfernt es aber nicht. * Gibt null zurück, wenn die Deque leer ist. */ E peekLast(); /* * Gibt das Element am Anfang des Deques zurück, entfernt es aber nicht. * Diese Methode unterscheidet sich von peekFirst() nur darin, dass sie eine Exception auslöst, wenn die Deque leer ist. */ E getFirst(); /* * Gibt das Element am Ende des Deques zurück, entfernt es aber nicht. * Diese Methode unterscheidet sich von peekLast() nur darin, dass sie eine Exception auslöst, wenn die Deque leer ist. */ E getLast(); /* * Entfernt das erste Vorkommen des angegebenen Elements aus dieser Deque, * sofern es vorhanden ist. Wenn diese Deque das Element nicht enthält, * bleibt sie unverändert. */ boolean removeFirstOccurrence(Object o); /* * Entfernt das letzte Vorkommen des angegebenen Elements aus dieser Deque, * sofern es vorhanden ist. Wenn diese Deque das Element nicht enthält, * bleibt sie unverändert. */ boolean removeLastOccurrence(Object o); // *** Queue methods *** ... // *** Stack methods *** ... Im Interface java.util.Deque sind Queue und Stack Methoden ebenfalls deklariert. Deques, bei denen Elemente nur an einem Ende eingefügt und am nur anderen Ende entnommen werden, stellen wiederum Queues dar. Deques, bei denen Elemente an einem Ende eingefügt und am gleichen Ende entnommen werden, stellen Stacks dar.\nAufgaben Aufgaben Aufgaben zu Modul #J6 - Java Collections - Queue + Deque\n","categories":"","description":"Die Datenstruktur für eine Warteschlange: die Queue.\n","excerpt":"Die Datenstruktur für eine Warteschlange: die Queue.\n","ref":"/docs/02_java/10_java-collections/06_queue/","tags":"","title":"Queue + Deque"},{"body":"java.util.Queue Eine Queue ist ähnlich einem Stack ein Behälter, in den Elemente eingefügt und nur in einer bestimmten Reihenfolge wieder entnommen werden können. Bei den Queues gilt das First In First Out (=FIFO) Prinzip: Das Einfügen eines Elements erfolgt an einem Ende und heisst EnQueue. Die Entfernung eines Elements erfolgt dann am anderen Ende und heisst DeQueue. Das heisst also, das erste Elemente, das einer Queue eingefügt wird, ist das Element das zuerst der Queue entnommen werden kann. Queues können in ihrer Grösse beschränkt oder unbeschränkt sein.\nAuf Deutsch könnte man Queues als “Warteschlangen” bezeichnen. Wir kennen Warteschlangen von unserem Alltag: Beispielsweise vom Einkaufen, wo es eine Schlange von Kunden gibt, die an der Kasse auf einen Kassierer warten. Ein Kunde stellt sich zu hinterst an und rückt “in der Warteschlange” vor, wenn vorherigen Kunden bedient wurden.\nAlle Methoden vom Interface java.util.Queue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 /* * Fügt das angegebene Element in diese Queue ein, * wenn dies möglich ist, ohne Kapazitätsbeschränkungen zu verletzen. * Bei Erfolg wird true zurückgegeben. Eine IllegalStateException wird ausgelöst, wenn derzeit * kein Platz verfügbar ist. */ boolean add(E e); /* * Fügt das angegebene Element in diese Queue ein, * wenn dies möglich ist, ohne Kapazitätsbeschränkungen zu verletzen. * Bei Erfolg wird true zurückgegeben und sonst wird false zurückgegeben. * * Bei der Verwendung einer Queue mit Kapazitätsbeschränkungen ist diese Methode in der Regel add(E e) vorzuziehen, * da bei Verletzung der Kapazitätsbeschränkungen keine Exception geworfen wird, sondern false zurückgegeben wird. * */ boolean offer(E e); /* * Gibt das Element am Anfang des Queues zurück und entfernt es in der Queue. * Falls die Queue leer ist, dann wird null zurückgegeben. */ E poll(); /* * Gibt das Element am Anfang des Queues zurück und entfernt es in der Queue. * Diese Methode unterscheidet sich von poll() nur darin, dass sie eine Exception auslöst, wenn die Queue leer ist. */ E remove(); /* * Gibt das Element am Anfang des Queues zurück, entfernt es aber nicht. * Gibt null zurück, wenn die Queue leer ist. */ E peek(); /* * Gibt das Element am Anfang des Queues zurück, entfernt es aber nicht. * Diese Methode unterscheidet sich von peek() nur darin, dass sie eine Exception auslöst, wenn die Queue leer ist. */ E element(); java.util.Deque Die Deque ist eine Queue mit zwei Enden, und Datenelemente können an beiden Enden hinzugefügt oder entfernt werden. Die Deque in Java wird über die das Interface java.util.Deque implementiert, die ein Subtyp des Interface java.util.Queue ist.\nAlle Methoden vom Interface java.util.Deque 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 /* * Fügt das angegebene Element an den Anfang dieser Deque ein, * wenn dies möglich ist, ohne Kapazitätsbeschränkungen zu verletzen * und löst eine IllegalStateException aus, wenn derzeit kein Platz verfügbar ist. */ void addFirst(E e); /* * Fügt das angegebene Element an das Ende dieser Deque ein, * wenn dies möglich ist, ohne Kapazitätsbeschränkungen zu verletzen * und löst eine IllegalStateException aus, wenn derzeit kein Platz verfügbar ist. */ void addLast(E e); /* * Fügt das angegebene Element an den Anfang dieser Deque ein, * wenn dies möglich ist, ohne Kapazitätsbeschränkungen zu verletzen. * Bei Erfolg wird true zurückgegeben und sonst wird false zurückgegeben. * * Bei der Verwendung einer Deque mit Kapazitätsbeschränkungen ist diese Methode in der Regel addFirst(E e) vorzuziehen, * da bei Verletzung der Kapazitätsbeschränkungen keine Exception geworfen wird, sondern false zurückgegeben wird. * */ boolean offerFirst(E e); /* * Fügt das angegebene Element an das Ende dieser Deque ein, * wenn dies möglich ist, ohne Kapazitätsbeschränkungen zu verletzen. * Bei Erfolg wird true zurückgegeben und sonst wird false zurückgegeben. * * Bei der Verwendung einer Deque mit Kapazitätsbeschränkungen ist diese Methode in der Regel addLast(E e) vorzuziehen, * da bei Verletzung der Kapazitätsbeschränkungen keine Exception geworfen wird, sondern false zurückgegeben wird. * */ boolean offerLast(E e); /* * Gibt das Element am Anfang des Deques zurück und entfernt es in der Deque. * Falls die Deque leer ist, dann wird null zurückgegeben. */ E pollFirst(); /* * Gibt das Element am Ende des Deques zurück und entfernt es in der Deque. * Falls die Deque leer ist, dann wird null zurückgegeben. */ E pollLast(); /* * Gibt das Element am Anfang des Deques zurück und entfernt es in der Deque. * Diese Methode unterscheidet sich von pollFirst() nur darin, dass sie eine Exception auslöst, wenn die Deque leer ist. */ E removeFirst(); /* * Gibt das Element am Ende des Deques zurück und entfernt es in der Deque. * Diese Methode unterscheidet sich von pollLast() nur darin, dass sie eine Exception auslöst, wenn die Deque leer ist. */ E removeLast(); /* * Gibt das Element am Anfang des Deques zurück, entfernt es aber nicht. * Gibt null zurück, wenn die Deque leer ist. */ E peekFirst(); /* * Gibt das Element am Ende des Deques zurück, entfernt es aber nicht. * Gibt null zurück, wenn die Deque leer ist. */ E peekLast(); /* * Gibt das Element am Anfang des Deques zurück, entfernt es aber nicht. * Diese Methode unterscheidet sich von peekFirst() nur darin, dass sie eine Exception auslöst, wenn die Deque leer ist. */ E getFirst(); /* * Gibt das Element am Ende des Deques zurück, entfernt es aber nicht. * Diese Methode unterscheidet sich von peekLast() nur darin, dass sie eine Exception auslöst, wenn die Deque leer ist. */ E getLast(); /* * Entfernt das erste Vorkommen des angegebenen Elements aus dieser Deque, * sofern es vorhanden ist. Wenn diese Deque das Element nicht enthält, * bleibt sie unverändert. */ boolean removeFirstOccurrence(Object o); /* * Entfernt das letzte Vorkommen des angegebenen Elements aus dieser Deque, * sofern es vorhanden ist. Wenn diese Deque das Element nicht enthält, * bleibt sie unverändert. */ boolean removeLastOccurrence(Object o); // *** Queue methods *** ... // *** Stack methods *** ... Im Interface java.util.Deque sind Queue und Stack Methoden ebenfalls deklariert. Deques, bei denen Elemente nur an einem Ende eingefügt und am nur anderen Ende entnommen werden, stellen wiederum Queues dar. Deques, bei denen Elemente an einem Ende eingefügt und am gleichen Ende entnommen werden, stellen Stacks dar.\nAufgaben Aufgaben Aufgaben zu Modul #J6 - Java Collections - Queue + Deque\n","categories":"","description":"Die Datenstruktur für eine Warteschlange: die Queue.\n","excerpt":"Die Datenstruktur für eine Warteschlange: die Queue.\n","ref":"/de/docs/02_java/10_java-collections/06_queue/","tags":"","title":"Queue + Deque"},{"body":"Aufgabe 1 - User-Eingabe in Liste umwandeln Schreibe folgendes Programm:\nLies eine Reihe von Zahlen aus der Kommandozeile in einer beliebigen Reihenfolge ein. Gib die unsortierte wie auch die sortierte Liste in der Konsole aus. Verwende hierfür Streams.\nZudem wird erwartet, dass ein eigenes Testing (wie in J4 Testing gelernt) zu der Umsetzung gehört.\nAufgabe 2 - Einfache mathematische Operation Schreibe folgendes Programm:\nLies eine Reihe von Zahlen aus der Kommandozeile in einer beliebigen Reihenfolge ein. Jede Zahl in der Liste wird mit sich selber multipliziert und schlussendlich werden die ursprüngliche wie auch die neue Liste (mit den Berechnungen) in der Konsole ausgegeben - einmal unsortiert und einmal sortiert. Verwende hierfür Streams.\nZudem wird erwartet, dass ein eigenes Testing (wie in J4 Testing gelernt) zu der Umsetzung gehört.\nAufgabe 3 - Kalorien berechnen Mache dir Gedanken über das, was du gestern gegessen hast. Schreibe die einzelnen Gerichte/Snacks auf.\nVersuche für jede Mahlzeit die Anzahl Kalorien zu ermitteln. Speichere die Gerichte mit den Kalorien-Werten als String in einem Array oder einer Liste - z.B. {\"Grilled Chicken Breast (230 calories)\", \"Mixed Greens Salad (50 calories)\", \"Balsamic Vinaigrette Dressing (60 calories)\", \"500 ml Cola (200 calories)\"}.\nSchreibe ein Programm, das mit Hilfe von Streams die Kalorien-Anzahl aus den Strings zusammenzählt.\nZudem wird erwartet, dass ein eigenes Testing (wie in J4 Testing gelernt) zu der Umsetzung gehört.\nAufgabe 4 - Notenschnitt berechnen Schreibe ein Programm, dass den Notenschnitt über Fächer berechnet.\nErstelle hierfür eine Klasse, die eine Note und ein Fach speichert. Erstelle einen Stream, der Objekte dieser Klasse beinhaltet.\nZudem wird erwartet, dass ein eigenes Testing (wie in J4 Testing gelernt) zu der Umsetzung gehört.\n","categories":"","description":"Aufgaben zu Modul #J6 - Collections\n","excerpt":"Aufgaben zu Modul #J6 - Collections\n","ref":"/labs/02_java/10_java-collections/06_streams/","tags":"","title":"Streams Basics - Aufgaben"},{"body":"Aufgabe 1 - User-Eingabe in Liste umwandeln Schreibe folgendes Programm:\nLies eine Reihe von Zahlen aus der Kommandozeile in einer beliebigen Reihenfolge ein. Gib die unsortierte wie auch die sortierte Liste in der Konsole aus. Verwende hierfür Streams.\nZudem wird erwartet, dass ein eigenes Testing (wie in J4 Testing gelernt) zu der Umsetzung gehört.\nAufgabe 2 - Einfache mathematische Operation Schreibe folgendes Programm:\nLies eine Reihe von Zahlen aus der Kommandozeile in einer beliebigen Reihenfolge ein. Jede Zahl in der Liste wird mit sich selber multipliziert und schlussendlich werden die ursprüngliche wie auch die neue Liste (mit den Berechnungen) in der Konsole ausgegeben - einmal unsortiert und einmal sortiert. Verwende hierfür Streams.\nZudem wird erwartet, dass ein eigenes Testing (wie in J4 Testing gelernt) zu der Umsetzung gehört.\nAufgabe 3 - Kalorien berechnen Mache dir Gedanken über das, was du gestern gegessen hast. Schreibe die einzelnen Gerichte/Snacks auf.\nVersuche für jede Mahlzeit die Anzahl Kalorien zu ermitteln. Speichere die Gerichte mit den Kalorien-Werten als String in einem Array oder einer Liste - z.B. {\"Grilled Chicken Breast (230 calories)\", \"Mixed Greens Salad (50 calories)\", \"Balsamic Vinaigrette Dressing (60 calories)\", \"500 ml Cola (200 calories)\"}.\nSchreibe ein Programm, das mit Hilfe von Streams die Kalorien-Anzahl aus den Strings zusammenzählt.\nZudem wird erwartet, dass ein eigenes Testing (wie in J4 Testing gelernt) zu der Umsetzung gehört.\nAufgabe 4 - Notenschnitt berechnen Schreibe ein Programm, dass den Notenschnitt über Fächer berechnet.\nErstelle hierfür eine Klasse, die eine Note und ein Fach speichert. Erstelle einen Stream, der Objekte dieser Klasse beinhaltet.\nZudem wird erwartet, dass ein eigenes Testing (wie in J4 Testing gelernt) zu der Umsetzung gehört.\n","categories":"","description":"Aufgaben zu Modul #J6 - Collections\n","excerpt":"Aufgaben zu Modul #J6 - Collections\n","ref":"/de/labs/02_java/10_java-collections/06_streams/","tags":"","title":"Streams Basics - Aufgaben"},{"body":" Voraussetzung Du kennst den switch Befehl. Wir stellen dir bei den Übungen jeweils komplette Projekte zur Verfügung. Du musst grundsätzlich nur dort was anpassen, wo die folgende Kommentarzeile steht:\nKopieren // IT-Ninja: Füge hier Deinen Code ein: 1 // IT-Ninja: Füge hier Deinen Code ein: Alles andere kannst du für den Moment ignorieren. Wir erklären dir die einzelnen Zeilen Schritt für Schritt in den Modulen.\nVorbereitungsarbeiten Drücke auf den Pfeil links um eine detaillierte Anleitung zu erhalten, wie Du den Quellcode auf deinem Rechner ablegen sollst.\nDiese Schritte musst du bei jeder Übung erneut machen. Jede Übung hat ein eigenes ZIP-File, welches du bei dir an die richtige Stelle kopieren musst. Die Anleitung zeigt dir ziemlich gut, wie das geht… Liess vor allem am Anfang die detaillierte Anleitung gut durch und befolge die Schritte exakt. Sie helfen dir, deinen Quellcode gut organisiert, strukturiert und sicher zu verwalten. Falls du die Anleitung schon auswendig kennst, findest du den Quellcode zur Übung direkt hier: Download | Online anschauen\nNeu bei it-ninja?\nDie Anleitung enthält einige Befehle und Fachbegriffe, die dir möglicherweise noch nichts sagen. Mach dir deswegen keine Sorgen – in den kommenden Modulen erklären wir dir alles Schritt für Schritt. Schon bald wirst auch du ein it-ninja sein. Um die folgenden Aufgaben erfolgreich umzusetzen, führe diese Schritte aus:\nBeim ersten Mal:\nIntelliJ IDEA installieren → !*IntelliJ IDEA einrichten Git-Repository einrichten → !*Persönliches Git-Repository Öffne eine !*CMD-Shell und wechsle ins Verzeichnis deines Git-Repositories:\nKopieren cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git status 1 2 cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git status Kopieren cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git status 1 2 cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git status Stelle sicher, dass alle Dateien im Git-Repository committed sind. Mit git status erhältst du eine Übersicht: Kopieren git status 1 git status Falls du bei diesem Befehl einen roten Text siehst, musst du zuerst die aktuellen Dateien sichern:\nKopieren git add . git commit -m \"[gescheiter Kommentar]\" 1 2 git add . git commit -m \"[gescheiter Kommentar]\" Erstelle oder wechsle in den Template Branch:\nBeim ersten Mal musst du einen Template Branch erstellen:\nKopieren git checkout -b \"templates\" 1 git checkout -b \"templates\" Falls er bereits existiert, kannst du einfach switchen:\nKopieren git switch \"templates\" 1 git switch \"templates\" Lade den Source-Code zu den Übungen herunter und entpacke ihn im Root-Verzeichnis deines lokalen Repositories:\n[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\nDen Source-Code findest du hier: Download | Online anschauen\nCommitte den originalen Source-Code, damit er sicher im Repository gespeichert ist:\nKopieren git add . git commit -m \"Add it-ninja_02_java_03_java-grundlagen_06_control-structures-switch\" git push 1 2 3 git add . git commit -m \"Add it-ninja_02_java_03_java-grundlagen_06_control-structures-switch\" git push Erstelle einen neuen Branch, um deine Lösung zu implementieren: Kopieren git checkout -b \"labs/it-ninja_02_java_03_java-grundlagen_06_control-structures-switch\" 1 git checkout -b \"labs/it-ninja_02_java_03_java-grundlagen_06_control-structures-switch\" Hier kannst du auch einen kürzeren Namen wählen. Verwende labs am Anfang des Branch-Namens für Branches, die deinen eigenen Code enthalten.\nStelle dir einen Branch vorerst als Ordner vor. Jeder Ordner enthält eine Version oder einen Stand von deinem Quellcode. Du kannst dann mit git zwischen diesen Ordern hin und her wechseln, sie vergleichen aber später auch zusammenführen.\nPro-Tipp:\nDu kannst jederzeit einen weiteren Branch erstellen – z. B. wenn du etwas ausprobieren möchtest. Alternativ kannst du auch in der Git-History einen alten Stand wiederherstellen, was aber weniger flexibel ist. Starte IntelliJ und öffne mit File → Open das Verzeichnis mit dem Source-Code. Du musst mit IntelliJ den Ordner suchen, welches einen Ordner src oder die Datei pom.xml enthält. Ansonsten wird IntelliJ Mühe haben, dir das Programm zu kompilieren. Wenn du alles korrekt gemacht hast, findest du das Projekt hier:\nKopieren `[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\\02_java\\03_java-grundlagen\\06_control-structures-switch` 1 `[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\\02_java\\03_java-grundlagen\\06_control-structures-switch` Kopieren `[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\\02_java/03_java-grundlagen/06_control-structures-switch` 1 `[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\\02_java/03_java-grundlagen/06_control-structures-switch` Falls du zum ersten Mal mit IntelliJ arbeitest, findest du !*hier eine Anleitung, wie man ein Programm startet. Um das Programm zu starten musst du jeweils die Datei Main.java öffenen. Dann sollte in IntelliJ oben rechts ein grünes Dreieck vorhanden sein, welches das Programm startet. Nun bist du bereit, die untenstehenden Aufgaben zu lösen.\nWenn du alle Änderungen gemacht hast und mit der Übung fertig bist, oder einen ‘Zwischenstand’ festhalten willst, führe die folgenden Befehle aus um das Repository auf dem Server zu speichern (von wo du es geklont hast):\nKopieren cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git add --all git commit -m \"Kurzer Kommentar\" 1 2 3 cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git add --all git commit -m \"Kurzer Kommentar\" Kopieren cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git add . git commit -m \"Kurzer Kommentar\" 1 2 3 cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git add . git commit -m \"Kurzer Kommentar\" Wenn du deine Änderungen auf dem Git-Server sichern willst, musst du das mit einem push machen.\nBeim ersten mal musst du git noch mitteilen, wie der Branch auf dem Git-Server heissen soll:\nKopieren git push --set-upstream origin labs/it-ninja_02_java_03_java-grundlagen_06_control-structures-switch 1 git push --set-upstream origin labs/it-ninja_02_java_03_java-grundlagen_06_control-structures-switch Bei weiteren pushes wird es dann einfacher:\nKopieren git push 1 git push Die meisten Übungen sind professionell strukturiert – so wie in echten Softwareprojekten. Zu gutem Code gehören auch Tests, die sicherstellen, dass dein Code wie erwartet funktioniert. Sofern nicht anders erwähnt, kannst du mit folgendem Befehl im Root-Verzeichnis des Projekts (dort, wo sich auch die pom.xml befindet) überprüfen, ob du die Aufgabe korrekt gelöst hast:\n1 mvn test Viel Erfolg!\nAufgabe 1 - Monat ausgeben Passe die folgende Methode an. Gib abhängig von der Variable month den passenden Monat auf der Konsole aus. Der Wert 1 soll dabei dem Monat Januar entsprechen, 2 dem Monat Februar, usw. Für Zahlen welche keinem Monat entsprechen soll ungültiger Monat auf der Konsole ausgegeben werden.\nIm zur Übung gehörendem Source kannst Du die Änderung an folgender Stelle machen:\nsrc\\main\\java\\ch\\itninja\\labs\\basicexercises\\MonthHelper.java:\n1 2 3 4 5 public static void printMonthByNumber(int month) { // IT-Ninja: Füge hier Deinen Code ein: } Beispiel 1:\nEingabe:\n1 MonthHelper.printMonthByNumber(1); Ausgabe:\n1 Januar Beispiel 2:\nEingabe:\n1 MonthHelper.printMonthByNumber(5); Ausgabe:\n1 Mai Beispiel 3:\nEingabe:\n1 MonthHelper.printMonthByNumber(9); Ausgabe:\n1 September Beispiel 4:\nEingabe:\n1 MonthHelper.printMonthByNumber(12); Ausgabe:\n1 Dezember Beispiel 5:\nEingabe:\n1 MonthHelper.printMonthByNumber(22); Ausgabe:\n1 ungültiger Monat Beispiel 6:\nEingabe:\n1 MonthHelper.printMonthByNumber(-3); Ausgabe:\n1 ungültiger Monat Aufgabe 2 - Wochentag Passe die folgende Methode an. Gib abhängig von der Variable weekdayName auf der Konsole aus, um welchen Wochentag es sich handelt:\nDer [weekdayName] ist der [weekday]. Tag in der Woche. [weekdayName] entspricht keinem bekannten Wochentag. Wobei in der Ausgabe [weekdayName] durch den Namen des Wochentags ersetzt werden soll und [weekday] durch den Tag der Woche, welche dem Wochentag entspricht. Der Montag soll dabei der erste Tag in der Woche sein.\nIm zur Übung gehörendem Source kannst Du die Änderung an folgender Stelle machen:\nsrc\\main\\java\\ch\\itninja\\labs\\basicexercises\\WeekHelper.java:\n1 2 3 4 5 public static void printWeekdayNumber(String weekdayName) { // IT-Ninja: Füge hier Deinen Code ein: } Beispiel 1:\nEingabe:\n1 WeekHelper.printWeekdayNumber(\"Freitag\"); Ausgabe:\n1 Der Freitag ist der 5. Tag in der Woche. Beispiel 2:\nEingabe:\n1 WeekHelper.printWeekdayNumber(\"Donnerstag\"); Ausgabe:\n1 Der Donnerstag ist der 4. Tag in der Woche. Beispiel 3:\nEingabe:\n1 WeekHelper.printWeekdayNumber(\"Weihnachten\"); Ausgabe:\n1 Weihnachten entspricht keinem bekannten Wochentag. Beispiel 4:\nEingabe:\n1 WeekHelper.printWeekdayNumber(\"Samstag\"); Ausgabe:\n1 Der Samstag ist der 6. Tag in der Woche. ","categories":"","description":"Mit diesen Übungen kannst du dein Wissen über den Befehl `switch` vertiefen.\n","excerpt":"Mit diesen Übungen kannst du dein Wissen über den Befehl `switch` …","ref":"/labs/02_java/03_java-grundlagen/06_control-structures-switch/","tags":"","title":"Java Exercises - Das Switch Statement"},{"body":"Schreibe eine Anwendung, welche entscheidet ob ein Damm geöffnet sein muss oder nicht. Die Entscheidung wird anhand der Wassermenge, welche in einen See hineinfliesst, verglichen mit der Wassermenge, welche aus diesem See wieder herausfliesst, gefällt.\nEine Wassermenge\nhat eine Menge hat eine Einheit wie Liter, Hektoliter oder m³ Die Anwendung soll Auskunft geben, ob die hineinfliessende Wassermenge gleich ist wie die herausfliessende Wassermenge Den Damm nur dann öffnen, wenn die hineinfliessende Wassermenge grösser ist als die herausfliessende Wassermenge. Es sollen keine Setter-Methoden für das Einfügen der Werte verwendet werden!\nAufgabe 1 Schreibe ein Programm, dass die Anforderungen auf eine objekt-orientierte Art und Weise umsetzt - d.h., dass die Methoden immer noch funktionieren würden, auch wenn es mehrere Dämme geben würde.\nSimuliere einen Damm zu drei verschiedenen Zeitpunkten mit unterschiedlichen hinein- und hinausfliessenden Wassermengen.\nEine Methode status() soll einen Wert zurückgeben, der aussagt, ob der Damm zum gegebenen Zeitpunkt offen oder geschlossen ist.\nAufgabe 2 - Zustände speichern (Erst nach dem Kapitel “Veränderbarkeit” lösen.)\nErweitere die status()-Methode so, dass bei jeder Status-Abfrage (also beim Aufruf der Methode) die Mengen in einer Liste gespeichert werden - und zwar als Objekte eurer Klasse für die Wassermenge.\nAm Ende des Programms sollen alle Mengen inkl. Einheiten dann in der Konsole ausgegeben werden.\nHier kannst du zurück zur Theorie.\n","categories":"","description":"Aufgabe zu Modul #J2 - OOP - Wassermenge\n","excerpt":"Aufgabe zu Modul #J2 - OOP - Wassermenge\n","ref":"/labs/02_java/04_java-oop/06_wassermenge/","tags":"","title":"Wassermenge"},{"body":"Schreibe eine Anwendung, welche entscheidet ob ein Damm geöffnet sein muss oder nicht. Die Entscheidung wird anhand der Wassermenge, welche in einen See hineinfliesst, verglichen mit der Wassermenge, welche aus diesem See wieder herausfliesst, gefällt.\nEine Wassermenge\nhat eine Menge hat eine Einheit wie Liter, Hektoliter oder m³ Die Anwendung soll Auskunft geben, ob die hineinfliessende Wassermenge gleich ist wie die herausfliessende Wassermenge Den Damm nur dann öffnen, wenn die hineinfliessende Wassermenge grösser ist als die herausfliessende Wassermenge. Es sollen keine Setter-Methoden für das Einfügen der Werte verwendet werden!\nAufgabe 1 Schreibe ein Programm, dass die Anforderungen auf eine objekt-orientierte Art und Weise umsetzt - d.h., dass die Methoden immer noch funktionieren würden, auch wenn es mehrere Dämme geben würde.\nSimuliere einen Damm zu drei verschiedenen Zeitpunkten mit unterschiedlichen hinein- und hinausfliessenden Wassermengen.\nEine Methode status() soll einen Wert zurückgeben, der aussagt, ob der Damm zum gegebenen Zeitpunkt offen oder geschlossen ist.\nAufgabe 2 - Zustände speichern (Erst nach dem Kapitel “Veränderbarkeit” lösen.)\nErweitere die status()-Methode so, dass bei jeder Status-Abfrage (also beim Aufruf der Methode) die Mengen in einer Liste gespeichert werden - und zwar als Objekte eurer Klasse für die Wassermenge.\nAm Ende des Programms sollen alle Mengen inkl. Einheiten dann in der Konsole ausgegeben werden.\nHier kannst du zurück zur Theorie.\n","categories":"","description":"Aufgabe zu Modul #J2 - OOP - Wassermenge\n","excerpt":"Aufgabe zu Modul #J2 - OOP - Wassermenge\n","ref":"/de/labs/02_java/04_java-oop/06_wassermenge/","tags":"","title":"Wassermenge"},{"body":"","categories":"","description":"Exams zu NgRx\n","excerpt":"Exams zu NgRx\n","ref":"/exams/03_web/07_angular-ngrx/","tags":"","title":"Angular NgRx Exams"},{"body":"","categories":"","description":"Exams zu NgRx\n","excerpt":"Exams zu NgRx\n","ref":"/de/exams/03_web/07_angular-ngrx/","tags":"","title":"Angular NgRx Exams"},{"body":"","categories":"","description":"Angular NgRx lernen\n","excerpt":"Angular NgRx lernen\n","ref":"/docs/03_web/07_angular-ngrx/","tags":"","title":"Angular NgRx (optional)"},{"body":"","categories":"","description":"Angular NgRx lernen\n","excerpt":"Angular NgRx lernen\n","ref":"/de/docs/03_web/07_angular-ngrx/","tags":"","title":"Angular NgRx (optional)"},{"body":"Ziele Du weisst, was SCSS ist und kennst die Vorteile gegenüber CSS. Du kannst ein Template anhand von Bedingungen stylen. Stylesheet Zu jedem Angular Component gehört ein Stylesheet, welches jeweils nur für die entsprechende Komponente verantwortlich ist, sprich für das HTML-File dieses Components. Erstellt man einen neuen Component über die CLI, so wird das Stylesheet automatisch erzeugt. Somit wird schon vorgegeben, dass die Styles ausgelagert werden sollten und nicht inline erfolgen. Man kann jedoch auch ein oder mehrere globale Stylesheets erstellen, diese gelten dann, wie der Name schon vermuten lässt, für das gesamte Projekt.\nDas Prinzip ist das gleiche wie bei normalem HTML und CSS, es werden KLassen und IDs vergeben, um diese dann stylen zu können.\nBeim Erstellen eines Angular Projekts kann man angeben, ob CSS, SCSS, SASS oder LESS verwendet werden soll. SCSS schauen wir nun etwas genauer an:\nSCSS SCSS (Sassy CSS) ist eine Erweiterung der CSS-Sprache, die zusätzliche Funktionen und Möglichkeiten bietet, um die Entwicklung von Stylesheets zu vereinfachen und effizienter zu gestalten. Die Files erhalten dann nicht mehr den Suffix .css sondern .scss.\nDie wichtigsten Hauptfunktionen von SCSS sind:\nVariablen Mit SCSS kann man Variablen definieren und verwenden, um Werte wie Farben, Schriftarten oder Ähnliches zu speichern und später im Stylesheet wiederverwenden zu können.\n1 2 3 4 5 6 7 $black: #000000; h1 { color: $black; font-size: 24px; font-weight: bold; } Verschachtelte Regeln Mit SCSS kann man verschachtelte Regeln schreiben, um die Lesbarkeit und Struktur des Stylesheets zu verbessern. Statt jedes Element separat zu selektieren, kann die Struktur des HTML-Codes innerhalb des SCSS-Files reflektiert werden.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 $black: #000000; .container { width: 100%; h1 { color: $black; font-size: 24px; font-weight: bold; } p { color: $black; font-size: 16px; } } Mixins Mixins ermöglichen es, Gruppen von SCSS-Deklarationen zu definieren und sie an verschiedenen Stellen im Stylesheet wiederzuverwenden.\n1 2 3 4 5 6 7 8 9 @mixin border-radius($radius) { -webkit-border-radius: $radius; -moz-border-radius: $radius; border-radius: $radius; } .button { @include border-radius(4px); } Vererbung SCSS ermöglicht es, Styles von einer Klasse zu einer anderen zu vererben, ähnlich wie bei der Vererbung in der objektorientierten Programmierung. Das kann dazu beitragen, die Menge des Stylesheet-Codes zu reduzieren und die Wartbarkeit zu verbessern.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 $black: #000000; .container { width: 100%; .text { color: $black; font-family: Helvetica, sans-serif; } h1 { @extend .text; font-size: 24px; font-weight: bold; } p { @extend .text; font-size: 16px; } } Partials \u0026 Importieren von Dateien Mit Partials kann man Stylesheet-Dateien in kleinere Teile aufteilen und sie bei Bedarf in andere Stylesheets importieren. Partials werden in der Regel mit einem führenden Unterstrich _ in ihrem Dateinamen gekennzeichnet, z.B. _variables.scss, _mixins.scss etc. Das hilft, den Code besser zu organisieren, da man ihn somit in logische Module aufteilt. Dadurch wird der Code wiederverwendbar.\n1 2 3 4 5 6 7 // _variables.scss $black: #000000; $white: #ffffff; $gray: #808080; $blue: #0000ff; $red: #ff0000; $yellow: #ffff00; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @import \"_variables\"; .container { width: 100%; .text { color: $black; font-family: Helvetica, sans-serif; } h1 { @extend .text; font-size: 24px; font-weight: bold; } p { @extend .text; font-size: 16px; } } Template Styling Es gibt zum einen das ngClass Directive, welches verwendet werden kann, um CSS/(SCSS)-Klassen dynamisch ins Template einzubinden. Alternativ dazu gibt es noch die [class.] Syntax. Man kann diese Syntax verwenden, um eine einzelne CSS/(SCSS)-Klasse basierend auf einer Bedingung hinzuzufügen oder zu entfernen. Ob eine Klasse hinzugefügt oder entfernt werden soll, wird meistens anhand eines Boolean-Werts aus dem Typescript geprüft. Ist das Boolean true, so wird die Klasse hinzugefügt, ansonsten wird sie ignoriert.\n1 2 3 4 5 6 7 8 import { Component } from \"@angular/core\"; @Component({ // .. }) export class GreetingComponent { isText: boolean = true; } 1 \u003cdiv [class.text]=\"isText\"\u003eText\u003c/div\u003e 1 2 3 4 5 6 @import \"_variables\"; .text { color: $black; font-family: Helvetica, sans-serif; } Alternativ zur Prüfung auf ein Boolean kann auch mit einer Bedingung gearbeitet werden, wie im folgenden Beispiel:\n1 2 3 4 5 6 7 8 9 import { Component } from \"@angular/core\"; @Component({ // .. }) export class GreetingComponent { type: string = \"text\"; textLength: number = 10; } 1 2 3 \u003cp [class.text]=\"type === 'text' \u0026\u0026 textLength === 10\"\u003e Face your fears and embrace the challenges! \u003c/p\u003e 1 2 3 4 5 6 @import \"_variables\"; .text { color: $black; font-family: Helvetica, sans-serif; } Globales Stylesheet Das globale Stylesheet wird automatisch generiert, wenn ein neues Angular-Projekt mit der Angular CLI erstellt wird. Diese Datei heisst dann im Fall von SCSS styles.scss. Im globalen Stylesheet werden Styles definiert, welche über das ganze Projekt immer gleich sein sollen. Zum Beispiel, dass alle p-tags überall eine bestimmte Schriftgrösse, Schriftart, Schriftfarbe oder ähnliches haben.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /* Globaler Stil für den Body */ @import \"_variables\"; body { font-family: Arial, sans-serif; margin: 0; padding: 0; } .text { color: $black; font-family: Helvetica, sans-serif; } h1 { @extend .text; font-size: 24px; font-weight: bold; } p { @extend .text; font-size: 16px; } /* Weitere globale Stilregeln */ ng-deep In SCSS gibt es den sogenannten ::ng-deep-Selektor, der verwendet wird, um SCSS-Regeln auf Elemente innerhalb von Components anzuwenden, die von der View-Encapsulation betroffen sind. Die View-Encapsulation ist eine Funktion von Angular, die den CSS-Code eines Components isoliert, um Kollisionen mit dem globalen Stylesheet zu vermeiden.\nWenn SCSS-Regeln in einem Component auf Elemente innerhalb eines anderen Components, bspw. ng-container und ng-template angwendet werden sollen, kann dies manchmal zu Problemen führen, da die View-Encapsulation diese Regeln standardmässig nicht zulässt. Hier kommt ::ng-deep ins Spiel.\nIndem ::ng-deep vor SCSS-Regeln innerhalb des Components hinzugefügt wird, können diese Regeln auf die Elemente innerhalb von ng-container und ng-template angewendet werden, unabhängig von der View-Encapsulation.\nBeachte jedoch, dass ::ng-deep als “deprecated” markiert ist, was bedeutet, dass es in Zukunft möglicherweise entfernt oder nicht mehr supported wird. Angular empfiehlt stattdessen, eine bessere Strukturierung der Components und die Verwendung von spezifischen Selektoren zu priorisieren, um spezifische Styles auf Elemente anzuwenden.\n1 2 3 4 ::ng-deep p { /* Stilregel für alle p-Elemente innerhalb des Components, einschliesslich innerhalb von ng-container und ng-template */ } ","categories":"","description":"Modul #F6 - Angular - Stylesheet\n","excerpt":"Modul #F6 - Angular - Stylesheet\n","ref":"/docs/03_web/06_angular/02_6_stylesheet/","tags":"","title":"Stylesheet"},{"body":"Ziele Du weisst, was SCSS ist und kennst die Vorteile gegenüber CSS. Du kannst ein Template anhand von Bedingungen stylen. Stylesheet Zu jedem Angular Component gehört ein Stylesheet, welches jeweils nur für die entsprechende Komponente verantwortlich ist, sprich für das HTML-File dieses Components. Erstellt man einen neuen Component über die CLI, so wird das Stylesheet automatisch erzeugt. Somit wird schon vorgegeben, dass die Styles ausgelagert werden sollten und nicht inline erfolgen. Man kann jedoch auch ein oder mehrere globale Stylesheets erstellen, diese gelten dann, wie der Name schon vermuten lässt, für das gesamte Projekt.\nDas Prinzip ist das gleiche wie bei normalem HTML und CSS, es werden KLassen und IDs vergeben, um diese dann stylen zu können.\nBeim Erstellen eines Angular Projekts kann man angeben, ob CSS, SCSS, SASS oder LESS verwendet werden soll. SCSS schauen wir nun etwas genauer an:\nSCSS SCSS (Sassy CSS) ist eine Erweiterung der CSS-Sprache, die zusätzliche Funktionen und Möglichkeiten bietet, um die Entwicklung von Stylesheets zu vereinfachen und effizienter zu gestalten. Die Files erhalten dann nicht mehr den Suffix .css sondern .scss.\nDie wichtigsten Hauptfunktionen von SCSS sind:\nVariablen Mit SCSS kann man Variablen definieren und verwenden, um Werte wie Farben, Schriftarten oder Ähnliches zu speichern und später im Stylesheet wiederverwenden zu können.\n1 2 3 4 5 6 7 $black: #000000; h1 { color: $black; font-size: 24px; font-weight: bold; } Verschachtelte Regeln Mit SCSS kann man verschachtelte Regeln schreiben, um die Lesbarkeit und Struktur des Stylesheets zu verbessern. Statt jedes Element separat zu selektieren, kann die Struktur des HTML-Codes innerhalb des SCSS-Files reflektiert werden.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 $black: #000000; .container { width: 100%; h1 { color: $black; font-size: 24px; font-weight: bold; } p { color: $black; font-size: 16px; } } Mixins Mixins ermöglichen es, Gruppen von SCSS-Deklarationen zu definieren und sie an verschiedenen Stellen im Stylesheet wiederzuverwenden.\n1 2 3 4 5 6 7 8 9 @mixin border-radius($radius) { -webkit-border-radius: $radius; -moz-border-radius: $radius; border-radius: $radius; } .button { @include border-radius(4px); } Vererbung SCSS ermöglicht es, Styles von einer Klasse zu einer anderen zu vererben, ähnlich wie bei der Vererbung in der objektorientierten Programmierung. Das kann dazu beitragen, die Menge des Stylesheet-Codes zu reduzieren und die Wartbarkeit zu verbessern.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 $black: #000000; .container { width: 100%; .text { color: $black; font-family: Helvetica, sans-serif; } h1 { @extend .text; font-size: 24px; font-weight: bold; } p { @extend .text; font-size: 16px; } } Partials \u0026 Importieren von Dateien Mit Partials kann man Stylesheet-Dateien in kleinere Teile aufteilen und sie bei Bedarf in andere Stylesheets importieren. Partials werden in der Regel mit einem führenden Unterstrich _ in ihrem Dateinamen gekennzeichnet, z.B. _variables.scss, _mixins.scss etc. Das hilft, den Code besser zu organisieren, da man ihn somit in logische Module aufteilt. Dadurch wird der Code wiederverwendbar.\n1 2 3 4 5 6 7 // _variables.scss $black: #000000; $white: #ffffff; $gray: #808080; $blue: #0000ff; $red: #ff0000; $yellow: #ffff00; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @import \"_variables\"; .container { width: 100%; .text { color: $black; font-family: Helvetica, sans-serif; } h1 { @extend .text; font-size: 24px; font-weight: bold; } p { @extend .text; font-size: 16px; } } Template Styling Es gibt zum einen das ngClass Directive, welches verwendet werden kann, um CSS/(SCSS)-Klassen dynamisch ins Template einzubinden. Alternativ dazu gibt es noch die [class.] Syntax. Man kann diese Syntax verwenden, um eine einzelne CSS/(SCSS)-Klasse basierend auf einer Bedingung hinzuzufügen oder zu entfernen. Ob eine Klasse hinzugefügt oder entfernt werden soll, wird meistens anhand eines Boolean-Werts aus dem Typescript geprüft. Ist das Boolean true, so wird die Klasse hinzugefügt, ansonsten wird sie ignoriert.\n1 2 3 4 5 6 7 8 import { Component } from \"@angular/core\"; @Component({ // .. }) export class GreetingComponent { isText: boolean = true; } 1 \u003cdiv [class.text]=\"isText\"\u003eText\u003c/div\u003e 1 2 3 4 5 6 @import \"_variables\"; .text { color: $black; font-family: Helvetica, sans-serif; } Alternativ zur Prüfung auf ein Boolean kann auch mit einer Bedingung gearbeitet werden, wie im folgenden Beispiel:\n1 2 3 4 5 6 7 8 9 import { Component } from \"@angular/core\"; @Component({ // .. }) export class GreetingComponent { type: string = \"text\"; textLength: number = 10; } 1 2 3 \u003cp [class.text]=\"type === 'text' \u0026\u0026 textLength === 10\"\u003e Face your fears and embrace the challenges! \u003c/p\u003e 1 2 3 4 5 6 @import \"_variables\"; .text { color: $black; font-family: Helvetica, sans-serif; } Globales Stylesheet Das globale Stylesheet wird automatisch generiert, wenn ein neues Angular-Projekt mit der Angular CLI erstellt wird. Diese Datei heisst dann im Fall von SCSS styles.scss. Im globalen Stylesheet werden Styles definiert, welche über das ganze Projekt immer gleich sein sollen. Zum Beispiel, dass alle p-tags überall eine bestimmte Schriftgrösse, Schriftart, Schriftfarbe oder ähnliches haben.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /* Globaler Stil für den Body */ @import \"_variables\"; body { font-family: Arial, sans-serif; margin: 0; padding: 0; } .text { color: $black; font-family: Helvetica, sans-serif; } h1 { @extend .text; font-size: 24px; font-weight: bold; } p { @extend .text; font-size: 16px; } /* Weitere globale Stilregeln */ ng-deep In SCSS gibt es den sogenannten ::ng-deep-Selektor, der verwendet wird, um SCSS-Regeln auf Elemente innerhalb von Components anzuwenden, die von der View-Encapsulation betroffen sind. Die View-Encapsulation ist eine Funktion von Angular, die den CSS-Code eines Components isoliert, um Kollisionen mit dem globalen Stylesheet zu vermeiden.\nWenn SCSS-Regeln in einem Component auf Elemente innerhalb eines anderen Components, bspw. ng-container und ng-template angwendet werden sollen, kann dies manchmal zu Problemen führen, da die View-Encapsulation diese Regeln standardmässig nicht zulässt. Hier kommt ::ng-deep ins Spiel.\nIndem ::ng-deep vor SCSS-Regeln innerhalb des Components hinzugefügt wird, können diese Regeln auf die Elemente innerhalb von ng-container und ng-template angewendet werden, unabhängig von der View-Encapsulation.\nBeachte jedoch, dass ::ng-deep als “deprecated” markiert ist, was bedeutet, dass es in Zukunft möglicherweise entfernt oder nicht mehr supported wird. Angular empfiehlt stattdessen, eine bessere Strukturierung der Components und die Verwendung von spezifischen Selektoren zu priorisieren, um spezifische Styles auf Elemente anzuwenden.\n1 2 3 4 ::ng-deep p { /* Stilregel für alle p-Elemente innerhalb des Components, einschliesslich innerhalb von ng-container und ng-template */ } ","categories":"","description":"Modul #F6 - Angular - Stylesheet\n","excerpt":"Modul #F6 - Angular - Stylesheet\n","ref":"/de/docs/03_web/06_angular/02_6_stylesheet/","tags":"","title":"Stylesheet"},{"body":"Ziele Du weisst, wie eine Funktionsdefinition aussieht und weisst, wie du eine solche Funktion aufrufen kannst. Du weisst, was Default-Parameter sind und wie man sie verwendet. Du weisst, was Arrow-Functions sind und wie mit dieser Schreibweise Funktionen definiert werden. Du kennst den Unterschied von Funktionen und Function-Expressions. Du weisst, was global Scope und block Scope bedeutet. Funktionsdefinition und Aufruf Eine Funktionsdefinition in JavaScript ist eine Möglichkeit, einen benannten Code-Block zu erstellen, der eine bestimmte Aufgabe ausführt.\n1 2 3 function sum(number1, number2) { return number1 + number2; } Um die Funktion aufzurufen, können wir den Funktionsnamen gefolgt von Runden klammern verwenden und die Argumente innerhalb dieser übergeben:\n1 2 let total = sum(3, 5); console.log(total); // 8 Man kann auch Funktionen ohne Argumente aufrufen, indem man einfach die Klammern leer lässt (das setzt aber voraus, dass die Funktion keinen Parameter erwartet):\n1 2 3 4 5 function sayHello() { console.log(\"Hello!\"); } sayHello(); // 'Hello!' Arrow Functions Arrow Functions sind eine kompakte und pragmatische Möglichkeit, Funktionen in JavaScript in einer Kurzform zu definieren. Im Gegensatz zu herkömmlichen Funktionsdefinitionen haben Arrow-Funktionen einen kürzeren und einfacheren Syntax. Dies ist besonders nützlich, um den Code zu vereinfachen und die Lesbarkeit zu erhöhen. Arrow-Funktionen haben auch eine andere this-Binding-Regel im Vergleich zu herkömmlichen Funktionen. In Arrow-Funktionen wird this an das this-Objekt des äusseren Kontexts gebunden, während bei herkömmlichen Funktionen this an das Objekt des Aufrufers gebunden wird.\nIm Gegensatz zu herkömmlichen Funktionsdefinition wird der Funktionsname weggelassen und durch einen Pfeil (=\u003e) ersetzt.\n1 2 3 4 5 6 const sum = (number1, number2) =\u003e { return number1 + number2; }; let total = sum(3, 5); console.log(total); // 8 Wenn die Funktion nur einen Ausdruck hat, kann sie noch kürzer geschrieben werden, indem die geschweiften Klammern und das return-Schlüsselwort weggelassen werden. Diese Syntax nennt man auch “implizite Rückgabe”.\n1 const sum = (number1, number2) =\u003e number1 + number2; Function Expressions Eine Funktionsexpression ist ein weiterer Ansatz, um eine Funktion in JavaScript zu definieren. Im Gegensatz zur Funktionsdeklaration wird bei der Funktionsexpression eine Funktion in einer Variablen gespeichert:\n1 2 3 4 5 6 7 8 9 10 // Function-Expression: const sum = function (number1, number2) { return number1 + number2; }; // Das Gleiche mit der Arrow-Function-Schreibweise: const sum2 = (a, b) =\u003e a + b; console.log(sum(3, 5)); // 8 console.log(sum2(3, 5)); // 8 Der Hauptunterschied zwischen einer Funktionsdeklaration und einer Funktionsexpression besteht darin, dass Funktionsexpressionen nur im Scope der Variabel aufgerufen werden können, sprich erst nach der Zuweisung der Variable.\nDieser Unterschied wird durch den Hoisting-Prozess verursacht: Der Hoisting-Prozess ist ein Konzept, bei dem Variablen- und Funktionsdeklarationen an den Anfang ihres Gültigkeitsbereichs verschoben werden. Mit anderen Worten werden, bevor der Code ausgeführt wird, Variablen und Funktionen in den Speicher geladen und sind somit bereits verfügbar, bevor sie im Code definiert wurden. Im Falle von Funktionsdeklarationen bedeutet das, dass die gesamte Funktionsdefinition im Speicher geladen wird, einschliesslich der Funktionsparameter und des Funktionskörpers. Dadurch kann eine Funktion in einem Programm an jeder beliebigen Stelle aufgerufen werden, auch wenn sie erst später im Code definiert wird. Es ist jedoch wichtig zu beachten, dass das Hoisting für Funktionsdeklarationen gilt, nicht aber für Funktionsexpressionen. Wenn man eine Funktion als Funktionsexpression definiert, wird sie nicht gehoisted. Das bedeutet, dass man sie erst nach der Definition aufrufen kann.\nBeispiel mit Hoisting-Prozess:\n1 2 3 4 5 6 7 8 9 10 console.log(multiply(2, 3)); // 6 console.log(sum(1, 2)); // Cannot access 'sum' before initialization function multiply(number1, number2) { return number1 * number2; } const sum = function (number1, number2) { return number1 + number2; }; ","categories":"","description":"Modul #F4 - JavaScript - Verschiedene Arten von Funktionen.\n","excerpt":"Modul #F4 - JavaScript - Verschiedene Arten von Funktionen.\n","ref":"/docs/03_web/03_javascript/07_functions/","tags":"","title":"Functions"},{"body":"Ziele Du weisst, wie eine Funktionsdefinition aussieht und weisst, wie du eine solche Funktion aufrufen kannst. Du weisst, was Default-Parameter sind und wie man sie verwendet. Du weisst, was Arrow-Functions sind und wie mit dieser Schreibweise Funktionen definiert werden. Du kennst den Unterschied von Funktionen und Function-Expressions. Du weisst, was global Scope und block Scope bedeutet. Funktionsdefinition und Aufruf Eine Funktionsdefinition in JavaScript ist eine Möglichkeit, einen benannten Code-Block zu erstellen, der eine bestimmte Aufgabe ausführt.\n1 2 3 function sum(number1, number2) { return number1 + number2; } Um die Funktion aufzurufen, können wir den Funktionsnamen gefolgt von Runden klammern verwenden und die Argumente innerhalb dieser übergeben:\n1 2 let total = sum(3, 5); console.log(total); // 8 Man kann auch Funktionen ohne Argumente aufrufen, indem man einfach die Klammern leer lässt (das setzt aber voraus, dass die Funktion keinen Parameter erwartet):\n1 2 3 4 5 function sayHello() { console.log(\"Hello!\"); } sayHello(); // 'Hello!' Arrow Functions Arrow Functions sind eine kompakte und pragmatische Möglichkeit, Funktionen in JavaScript in einer Kurzform zu definieren. Im Gegensatz zu herkömmlichen Funktionsdefinitionen haben Arrow-Funktionen einen kürzeren und einfacheren Syntax. Dies ist besonders nützlich, um den Code zu vereinfachen und die Lesbarkeit zu erhöhen. Arrow-Funktionen haben auch eine andere this-Binding-Regel im Vergleich zu herkömmlichen Funktionen. In Arrow-Funktionen wird this an das this-Objekt des äusseren Kontexts gebunden, während bei herkömmlichen Funktionen this an das Objekt des Aufrufers gebunden wird.\nIm Gegensatz zu herkömmlichen Funktionsdefinition wird der Funktionsname weggelassen und durch einen Pfeil (=\u003e) ersetzt.\n1 2 3 4 5 6 const sum = (number1, number2) =\u003e { return number1 + number2; }; let total = sum(3, 5); console.log(total); // 8 Wenn die Funktion nur einen Ausdruck hat, kann sie noch kürzer geschrieben werden, indem die geschweiften Klammern und das return-Schlüsselwort weggelassen werden. Diese Syntax nennt man auch “implizite Rückgabe”.\n1 const sum = (number1, number2) =\u003e number1 + number2; Function Expressions Eine Funktionsexpression ist ein weiterer Ansatz, um eine Funktion in JavaScript zu definieren. Im Gegensatz zur Funktionsdeklaration wird bei der Funktionsexpression eine Funktion in einer Variablen gespeichert:\n1 2 3 4 5 6 7 8 9 10 // Function-Expression: const sum = function (number1, number2) { return number1 + number2; }; // Das Gleiche mit der Arrow-Function-Schreibweise: const sum2 = (a, b) =\u003e a + b; console.log(sum(3, 5)); // 8 console.log(sum2(3, 5)); // 8 Der Hauptunterschied zwischen einer Funktionsdeklaration und einer Funktionsexpression besteht darin, dass Funktionsexpressionen nur im Scope der Variabel aufgerufen werden können, sprich erst nach der Zuweisung der Variable.\nDieser Unterschied wird durch den Hoisting-Prozess verursacht: Der Hoisting-Prozess ist ein Konzept, bei dem Variablen- und Funktionsdeklarationen an den Anfang ihres Gültigkeitsbereichs verschoben werden. Mit anderen Worten werden, bevor der Code ausgeführt wird, Variablen und Funktionen in den Speicher geladen und sind somit bereits verfügbar, bevor sie im Code definiert wurden. Im Falle von Funktionsdeklarationen bedeutet das, dass die gesamte Funktionsdefinition im Speicher geladen wird, einschliesslich der Funktionsparameter und des Funktionskörpers. Dadurch kann eine Funktion in einem Programm an jeder beliebigen Stelle aufgerufen werden, auch wenn sie erst später im Code definiert wird. Es ist jedoch wichtig zu beachten, dass das Hoisting für Funktionsdeklarationen gilt, nicht aber für Funktionsexpressionen. Wenn man eine Funktion als Funktionsexpression definiert, wird sie nicht gehoisted. Das bedeutet, dass man sie erst nach der Definition aufrufen kann.\nBeispiel mit Hoisting-Prozess:\n1 2 3 4 5 6 7 8 9 10 console.log(multiply(2, 3)); // 6 console.log(sum(1, 2)); // Cannot access 'sum' before initialization function multiply(number1, number2) { return number1 * number2; } const sum = function (number1, number2) { return number1 + number2; }; ","categories":"","description":"Modul #F4 - JavaScript - Verschiedene Arten von Funktionen.\n","excerpt":"Modul #F4 - JavaScript - Verschiedene Arten von Funktionen.\n","ref":"/de/docs/03_web/03_javascript/07_functions/","tags":"","title":"Functions"},{"body":"In der SBB wird primär das intern gehostete Bitbucket verwendet. Dieses Modul widmet sich dem Bitbucket der SBB.\nZiele Ich kenne das von der SBB gehostete Bitbucket. Ich kann im Bitbucket einen Pull Request erstellen und mir dessen Diff anzeigen. Pull Request (PR) erstellen und mergen Um einen Pull Request in BitBucket zu erstellen, muss im Web in der linken Navigationsleiste unter ACTIONS die Option Create pull request ausgewählt werden.\nHier hat man nun die Möglichkeit einen Branch auszuwählen, welcher Änderungen hat (Source Branch), und den Ziel Branch (Destination Branch) festzulegen, dort wo die Änderungen hinzugefügt werden sollen. Auf der folgenden Seite kann ein Titel und eine Beschreibung für den Pull Request gesetzt werden. Ebenfalls können hier Reviewers hinzugefügt werden.\nDa nun alle Einstellungen vorgenommen wurden, kann der Pull Request erstellt werden.\nDiff Wenn nun eine andere Person diesen PR öffnet und verstehen möchte was geändert wurde, öffnet sie diesen und geht in der oberen Navigation auf die Option Diff.\nDer hier angezeigte Vergleich wird Diff (kommt von Difference) genannt. Er zeigt dir zwei Versionen von Dateien eines Git-Repository an. Dabei werden links die modifizierten(Blauer Stift), neuen (grünes Plus-Zeichen), gelöschten (rotes Minus-Zeichen) und verschobenen (oranger Pfeil) Dateien angezeigt. Bei einer modifizierten Datei werden die geänderte Zeilen wie folgt hervorgehoben:\nGrün markiert neue Zeilen, die hinzugefügt wurden. Rot zeigt gelöschte Zeilen. Pull Request mergen Wenn man einen Pull Request schliessen möchte, kann man das über den oben rechts angezeigten Knopf Merge. Es öffnet sich ein Dialog-Fenster, in welchem man den Titel und die Beschreibung des Commits definieren kann.\nMan kann noch weitere Einstellungen vornehmen. Beispielsweise kann man festlegen, dass der Branch anschliessend gelöscht wird.\nEmpfohlen ist die Option Squash zu nutzen, welche links neben dem blauen Knopf per Dropdown ausgewählt werden. Diese kombiniert alle Commits des Branches zu einem einzelnen Commit, welcher anschliessend in den Target-Branch gemerged wird.\nCommit History Wenn man links in der Navigationsleiste auf Commits klickt, kann man sich die History des Projektes anhand der vergangenen Commits anzeigen lassen. Hier sind alle merged Pull Requests aber auch Commits welche direkt auf Master gemacht wurden ersichtlich.\nVon jeder Änderung ist der Autor, der Commit Hash, die Commit Message und das Datum ersichtlich. Die History ermöglicht es den Nutzern, den Verlauf von Änderungen nachzuverfolgen und auf frühere Versionen des Repositorys zurückzugreifen.\nForking Ein Fork ist eine Kopie eines bestehenden Git-Repositories. Wenn du ein Repository forkst, erstellst du eine eigene Version davon, die unabhängig vom Original ist. Diese Kopie befindet sich in deinem eigenen Account und ermöglicht es dir Änderungen vorzunehmen, ohne das ursprüngliche Projekt zu beeinflussen.\nIn Bitbucket findest du die Möglichkeit zum Forken in der linken Navigationsleiste, wenn du dich in einem Repository befindest.\n","categories":"","description":"","excerpt":"In der SBB wird primär das intern gehostete Bitbucket verwendet. …","ref":"/docs/04_git/01_grundwissen/07_bitbucket/","tags":"","title":"Bitbucket"},{"body":"In der SBB wird primär das intern gehostete Bitbucket verwendet. Dieses Modul widmet sich dem Bitbucket der SBB.\nZiele Ich kenne das von der SBB gehostete Bitbucket. Ich kann im Bitbucket einen Pull Request erstellen und mir dessen Diff anzeigen. Pull Request (PR) erstellen und mergen Um einen Pull Request in BitBucket zu erstellen, muss im Web in der linken Navigationsleiste unter ACTIONS die Option Create pull request ausgewählt werden.\nHier hat man nun die Möglichkeit einen Branch auszuwählen, welcher Änderungen hat (Source Branch), und den Ziel Branch (Destination Branch) festzulegen, dort wo die Änderungen hinzugefügt werden sollen. Auf der folgenden Seite kann ein Titel und eine Beschreibung für den Pull Request gesetzt werden. Ebenfalls können hier Reviewers hinzugefügt werden.\nDa nun alle Einstellungen vorgenommen wurden, kann der Pull Request erstellt werden.\nDiff Wenn nun eine andere Person diesen PR öffnet und verstehen möchte was geändert wurde, öffnet sie diesen und geht in der oberen Navigation auf die Option Diff.\nDer hier angezeigte Vergleich wird Diff (kommt von Difference) genannt. Er zeigt dir zwei Versionen von Dateien eines Git-Repository an. Dabei werden links die modifizierten(Blauer Stift), neuen (grünes Plus-Zeichen), gelöschten (rotes Minus-Zeichen) und verschobenen (oranger Pfeil) Dateien angezeigt. Bei einer modifizierten Datei werden die geänderte Zeilen wie folgt hervorgehoben:\nGrün markiert neue Zeilen, die hinzugefügt wurden. Rot zeigt gelöschte Zeilen. Pull Request mergen Wenn man einen Pull Request schliessen möchte, kann man das über den oben rechts angezeigten Knopf Merge. Es öffnet sich ein Dialog-Fenster, in welchem man den Titel und die Beschreibung des Commits definieren kann.\nMan kann noch weitere Einstellungen vornehmen. Beispielsweise kann man festlegen, dass der Branch anschliessend gelöscht wird.\nEmpfohlen ist die Option Squash zu nutzen, welche links neben dem blauen Knopf per Dropdown ausgewählt werden. Diese kombiniert alle Commits des Branches zu einem einzelnen Commit, welcher anschliessend in den Target-Branch gemerged wird.\nCommit History Wenn man links in der Navigationsleiste auf Commits klickt, kann man sich die History des Projektes anhand der vergangenen Commits anzeigen lassen. Hier sind alle merged Pull Requests aber auch Commits welche direkt auf Master gemacht wurden ersichtlich.\nVon jeder Änderung ist der Autor, der Commit Hash, die Commit Message und das Datum ersichtlich. Die History ermöglicht es den Nutzern, den Verlauf von Änderungen nachzuverfolgen und auf frühere Versionen des Repositorys zurückzugreifen.\nForking Ein Fork ist eine Kopie eines bestehenden Git-Repositories. Wenn du ein Repository forkst, erstellst du eine eigene Version davon, die unabhängig vom Original ist. Diese Kopie befindet sich in deinem eigenen Account und ermöglicht es dir Änderungen vorzunehmen, ohne das ursprüngliche Projekt zu beeinflussen.\nIn Bitbucket findest du die Möglichkeit zum Forken in der linken Navigationsleiste, wenn du dich in einem Repository befindest.\n","categories":"","description":"","excerpt":"In der SBB wird primär das intern gehostete Bitbucket verwendet. …","ref":"/de/docs/04_git/01_grundwissen/07_bitbucket/","tags":"","title":"Bitbucket"},{"body":"Ziele Ich weiss, was die CMD Shell ist. Ich kann sie unter Windows starten. Ich verstehe den grundlegenden Einsatzzweck. ⏱️ Geschätzte Lesezeit: 5 Minuten Was ist die CMD Shell? Die CMD Shell (oder Eingabeaufforderung) ist eine textbasierte Oberfläche, um Befehle direkt an das Windows-Betriebssystem zu senden.\nSie ist seit den frühen Windows-Versionen verfügbar und wird oft für Systemadministration, Skripte und Fehlerdiagnosen verwendet.\nTypische Einsatzbereiche:\nDateien und Ordner verwalten (dir, copy, del, …) Netzwerkbefehle ausführen (ping, ipconfig, …) Programme und Skripte starten Systemdiagnosen durchführen CMD starten Es gibt mehrere Wege, die CMD Shell zu öffnen:\nÜber das Startmenü\nKlicke auf die Windows-Taste oder das Startmenü. Tippe cmd ein. Drücke Enter oder klicke auf Eingabeaufforderung. Mit Administratorrechten\nFühre die Schritte oben aus. Klicke mit der rechten Maustaste auf Eingabeaufforderung. Wähle Als Administrator ausführen. Erste Befehle Probiere in der CMD Shell zum Einstieg:\n1 ver Zeigt die aktuelle Windows-Version an.\n1 help Listet alle verfügbaren Befehle mit kurzer Beschreibung.\nViele CMD-Befehle funktionieren auch in PowerShell, die moderner ist, aber ähnliche Grundlagen hat. ","categories":"","description":"Alt, aber immer noch nützlich – die Windows-Eingabeaufforderung (CMD).\n","excerpt":"Alt, aber immer noch nützlich – die Windows-Eingabeaufforderung (CMD). …","ref":"/docs/99_tools/shell/cmd/","tags":"","title":"Cmd Shell"},{"body":"Ziele Ich weiss, was nicht-semantische Tags sind und wofür sie verwendet werden. Ich weiss, was semantische Tags sind und wofür sie verwendet werden. Ich kann in HTML-5 semantische Elemente anwenden. Einführung Semantik, auch Bedeutungslehre genannt, ist die wissenschaftliche Beschäftigung mit Bedeutung und mit den verschiedenen Beziehungen zwischen einem Zeichen und dem Bezeichneten.\nIn HTML – insbesondere seit HTML 5 – gibt es semantische Tags, bei denen die Elemente eine ganz bestimmte Bedeutung haben (z.B. \u003ch1\u003e oder \u003clabel\u003e) und nicht-semantische Tags (z.B. \u003cspan\u003e oder \u003cdiv\u003e).\nNicht-semantische Tags Oft kommst du in die Situation, in der du mehrere Elemente in einem anderen Element gruppieren möchtest. In den meisten Fällen verwendet man dafür das div-Element.\n\u003cdiv\u003e-Tags werden oft als Container (Behälter) für HTML-Elemente verwendet. Dieser Container kann dann als Ganzes mit CSS gestylt oder mit JavaScript manipuliert werden. Probiere das nächste Beispiel einmal aus, ohne das Styling zu beachten (ignoriere also das, was im \u003cstyle\u003e-Element steht):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Just a Text \u003cdiv class=\"content\"\u003e \u003ch1\u003eHello\u003c/h1\u003e \u003cp\u003eThis is my amazing website!\u003c/p\u003e \u003c/div\u003e Other Text \u003cstyle\u003e .content { width: 20em; padding: 1em; border-radius: 1em; background-color: orange; } \u003c/style\u003e Das ist ein typisches Beispiel für die Verwendung von \u003cdiv\u003e Elementen.\nMöchtest du hingegen ein paar Wörter (aber nicht einen ganzen Block/Paragrafen) speziell stylen, kannst du ein \u003cspan\u003e-Element verwendet. Möchtest du beispielsweise das Datum in einem Text hervorheben, dann könnte das z.B. so aussehen:\n1 2 3 4 5 6 7 8 Das nächste Event findet am \u003cspan class=\"date\"\u003e20. Mai\u003c/span\u003e statt. \u003cstyle\u003e .date { font-size: 1.25em; font-weight: bold; color: blue; } \u003c/style\u003e In den beiden obenstehenden Beispielen wurde bei den Tags eine Klasse angegeben. Durch das Ansprechen der Klasse in CSS lässt sich das Element als Ganzes manipulieren.\nSemantische Tags Mit HTML5 wurden viele neue semantische Tags eingeführt, die in einigen Fällen \u003cdiv\u003e-Elemente und \u003cspan\u003e-Elemente ersetzen.\nDas “Zeit”-\u003cspan\u003e-Beispiel könnte folgendermassen vereinfacht werden:\n1 2 3 4 5 6 7 8 Das nächste Event findet am \u003ctime\u003e20. Mai\u003c/time\u003e statt. \u003cstyle\u003e time { font-size: 1.25em; font-weight: bold; color: blue; } \u003c/style\u003e In HTML5 wurden ebenfalls viele neue Tags eingeführt, die die Struktur von HTML-Dateien genauer beschreiben. Oft hat eine Website eine Struktur, die der folgenden ähnelt:\nDer \u003cheader\u003e ist das Element, welches auf einer Website zuoberst angezeigt wird. Dieser enthält oft den Titel der Applikation, das Logo der Firma und jenachdem auch eine \u003cnav\u003eigation (also Links wie für ‘Home’, ‘About’, ‘Kontakt’ etc.).\nDas Gegenteil des \u003cheader\u003e-Elements ist der \u003cfooter\u003e. Der Footer befindet sich am Ende der Website (also ganz unten) und enthält oft den Verweis auf das Copyright sowie weiterführende Links, beispielsweise zu den Datenschutzbestimmungen.\nNicht auf diesem Bild vorhanden, aber trotzdem relevant: Oft befindet sich der Hauptteil einer Website (dazu gehören nicht der \u003cheader\u003e und der \u003cfooter\u003e ) in einem \u003cmain\u003e-Element. Wenn die Website einen Leseartikel beschreibt, dann wäre der Text inkl. Überschriften dort drin.\nEinzelne Abschnitte (beispielsweise Unterkapitel inklusive Überschriften) werden oft in \u003csection\u003e-Elemente gebündelt und sind im nachfolgenden Beispiel-Code eine gute Alternative zu \u003cdiv\u003e-Elementen.\nWas genau ein \u003carticle\u003e ist, würde den Rahmen hier definitiv sprengen, grundsätzlich beschreibt ein article aber ein von der aktuellen Website unabhängiges und in sich geschlossenes Element. Ein article-Element könnte man also einfach von der aktuellen Seite ausschneiden und in eine andere kopieren.\nSchaue dir diese Dokumentation zu HTML Semantic Tags an. Dort ist unter anderem auch das \u003carticle\u003e-Element genauer beschrieben: https://www.w3schools.com/html/html5_semantic_elements.asp\nMit semantischen Tags könnte man zum Beispiel den folgenden Code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 \u003c!doctype html\u003e \u003chtml\u003e \u003chead\u003e\u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"header\"\u003e \u003ch1\u003eThe Header\u003c/h1\u003e \u003cdiv class=\"nav-links\"\u003e \u003cp\u003eNav:\u003c/p\u003e \u003cp\u003eHome\u003c/p\u003e \u003cp\u003eNews\u003c/p\u003e \u003cp\u003eAbout\u003c/p\u003e \u003c/div\u003e \u003c/div\u003e \u003cdiv id=\"content\"\u003e \u003ch1\u003eThe Article - BANANA TREE\u003c/h1\u003e \u003cdiv class=\"chapter\"\u003e \u003ch2\u003eSection 1\u003c/h2\u003e \u003cp\u003e A banana tree is a must if you wish to bring a sizeable touch of the tropics into your home. \u003c/p\u003e \u003c/div\u003e \u003cdiv class=\"chapter\"\u003e \u003ch2\u003eSection 2\u003c/h2\u003e \u003cp\u003eThere are some 400 species worldwide.\u003c/p\u003e \u003cdiv class=\"move-to-the-right\"\u003e \u003ch2\u003eA Aside - Why are bananas bent?\u003c/h2\u003e Gravity causes the fruit to hang down. \u003c/div\u003e \u003c/div\u003e \u003cp\u003e The text is from: \u003ca href=\"https://www.thejoyofplants.co.uk/banana-tree\" \u003eThe Joy of Plants.co.uk\u003c/a \u003e \u003c/p\u003e \u003c/div\u003e \u003cdiv id=\"end-of-the-page\"\u003e \u003ch2\u003eThe Footer\u003c/h2\u003e \u003cdiv\u003e \u003cp\u003eContact\u003c/p\u003e \u003cp\u003eImpressum\u003c/p\u003e \u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e in diese Form vereinfachen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 \u003c!doctype html\u003e \u003chtml\u003e \u003chead\u003e\u003c/head\u003e \u003cbody\u003e \u003cheader\u003e \u003ch1\u003eThe Header\u003c/h1\u003e \u003cnav\u003e \u003cp\u003eNav:\u003c/p\u003e \u003cp\u003eHome\u003c/p\u003e \u003cp\u003eNews\u003c/p\u003e \u003cp\u003eAbout\u003c/p\u003e \u003c/nav\u003e \u003c/header\u003e \u003cmain\u003e \u003carticle\u003e \u003ch1\u003eThe Article - BANANA TREE\u003c/h1\u003e \u003csection\u003e \u003ch2\u003eSection 1\u003c/h2\u003e \u003cp\u003e A banana tree is a must if you wish to bring a sizeable touch of the tropics into your home. \u003c/p\u003e \u003c/section\u003e \u003csection\u003e \u003ch2\u003eSection 2\u003c/h2\u003e \u003cp\u003eThere are some 400 species worldwide.\u003c/p\u003e \u003caside\u003e \u003ch2\u003eA Aside - Why are bananas bent?\u003c/h2\u003e Gravity causes the fruit to hang down. \u003c/aside\u003e \u003c/section\u003e \u003cp\u003e The text is from: \u003ca href=\"https://www.thejoyofplants.co.uk/banana-tree\" \u003eThe Joy of Plants.co.uk\u003c/a \u003e \u003c/p\u003e \u003c/article\u003e \u003c/main\u003e \u003cfooter\u003e \u003ch2\u003eThe Footer\u003c/h2\u003e \u003cdiv\u003e \u003cp\u003eContact\u003c/p\u003e \u003cp\u003eImpressum\u003c/p\u003e \u003c/div\u003e \u003c/footer\u003e \u003c/body\u003e \u003c/html\u003e Jetzt bist du dran. Löse die Aufgabe 3 in den Labs.\n","categories":"","description":"Modul #F3 - HTML- und CSS-Tags, welche ihre Bedeutung dem Browser und dem Entwickler beschreiben.\n","excerpt":"Modul #F3 - HTML- und CSS-Tags, welche ihre Bedeutung dem Browser und …","ref":"/docs/03_web/02_html_css/07_html-5-semantic-tags/","tags":"","title":"HTML5 Semantic Tags"},{"body":"Ziele Ich weiss, was nicht-semantische Tags sind und wofür sie verwendet werden. Ich weiss, was semantische Tags sind und wofür sie verwendet werden. Ich kann in HTML-5 semantische Elemente anwenden. Einführung Semantik, auch Bedeutungslehre genannt, ist die wissenschaftliche Beschäftigung mit Bedeutung und mit den verschiedenen Beziehungen zwischen einem Zeichen und dem Bezeichneten.\nIn HTML – insbesondere seit HTML 5 – gibt es semantische Tags, bei denen die Elemente eine ganz bestimmte Bedeutung haben (z.B. \u003ch1\u003e oder \u003clabel\u003e) und nicht-semantische Tags (z.B. \u003cspan\u003e oder \u003cdiv\u003e).\nNicht-semantische Tags Oft kommst du in die Situation, in der du mehrere Elemente in einem anderen Element gruppieren möchtest. In den meisten Fällen verwendet man dafür das div-Element.\n\u003cdiv\u003e-Tags werden oft als Container (Behälter) für HTML-Elemente verwendet. Dieser Container kann dann als Ganzes mit CSS gestylt oder mit JavaScript manipuliert werden. Probiere das nächste Beispiel einmal aus, ohne das Styling zu beachten (ignoriere also das, was im \u003cstyle\u003e-Element steht):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Just a Text \u003cdiv class=\"content\"\u003e \u003ch1\u003eHello\u003c/h1\u003e \u003cp\u003eThis is my amazing website!\u003c/p\u003e \u003c/div\u003e Other Text \u003cstyle\u003e .content { width: 20em; padding: 1em; border-radius: 1em; background-color: orange; } \u003c/style\u003e Das ist ein typisches Beispiel für die Verwendung von \u003cdiv\u003e Elementen.\nMöchtest du hingegen ein paar Wörter (aber nicht einen ganzen Block/Paragrafen) speziell stylen, kannst du ein \u003cspan\u003e-Element verwendet. Möchtest du beispielsweise das Datum in einem Text hervorheben, dann könnte das z.B. so aussehen:\n1 2 3 4 5 6 7 8 Das nächste Event findet am \u003cspan class=\"date\"\u003e20. Mai\u003c/span\u003e statt. \u003cstyle\u003e .date { font-size: 1.25em; font-weight: bold; color: blue; } \u003c/style\u003e In den beiden obenstehenden Beispielen wurde bei den Tags eine Klasse angegeben. Durch das Ansprechen der Klasse in CSS lässt sich das Element als Ganzes manipulieren.\nSemantische Tags Mit HTML5 wurden viele neue semantische Tags eingeführt, die in einigen Fällen \u003cdiv\u003e-Elemente und \u003cspan\u003e-Elemente ersetzen.\nDas “Zeit”-\u003cspan\u003e-Beispiel könnte folgendermassen vereinfacht werden:\n1 2 3 4 5 6 7 8 Das nächste Event findet am \u003ctime\u003e20. Mai\u003c/time\u003e statt. \u003cstyle\u003e time { font-size: 1.25em; font-weight: bold; color: blue; } \u003c/style\u003e In HTML5 wurden ebenfalls viele neue Tags eingeführt, die die Struktur von HTML-Dateien genauer beschreiben. Oft hat eine Website eine Struktur, die der folgenden ähnelt:\nDer \u003cheader\u003e ist das Element, welches auf einer Website zuoberst angezeigt wird. Dieser enthält oft den Titel der Applikation, das Logo der Firma und jenachdem auch eine \u003cnav\u003eigation (also Links wie für ‘Home’, ‘About’, ‘Kontakt’ etc.).\nDas Gegenteil des \u003cheader\u003e-Elements ist der \u003cfooter\u003e. Der Footer befindet sich am Ende der Website (also ganz unten) und enthält oft den Verweis auf das Copyright sowie weiterführende Links, beispielsweise zu den Datenschutzbestimmungen.\nNicht auf diesem Bild vorhanden, aber trotzdem relevant: Oft befindet sich der Hauptteil einer Website (dazu gehören nicht der \u003cheader\u003e und der \u003cfooter\u003e ) in einem \u003cmain\u003e-Element. Wenn die Website einen Leseartikel beschreibt, dann wäre der Text inkl. Überschriften dort drin.\nEinzelne Abschnitte (beispielsweise Unterkapitel inklusive Überschriften) werden oft in \u003csection\u003e-Elemente gebündelt und sind im nachfolgenden Beispiel-Code eine gute Alternative zu \u003cdiv\u003e-Elementen.\nWas genau ein \u003carticle\u003e ist, würde den Rahmen hier definitiv sprengen, grundsätzlich beschreibt ein article aber ein von der aktuellen Website unabhängiges und in sich geschlossenes Element. Ein article-Element könnte man also einfach von der aktuellen Seite ausschneiden und in eine andere kopieren.\nSchaue dir diese Dokumentation zu HTML Semantic Tags an. Dort ist unter anderem auch das \u003carticle\u003e-Element genauer beschrieben: https://www.w3schools.com/html/html5_semantic_elements.asp\nMit semantischen Tags könnte man zum Beispiel den folgenden Code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 \u003c!doctype html\u003e \u003chtml\u003e \u003chead\u003e\u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"header\"\u003e \u003ch1\u003eThe Header\u003c/h1\u003e \u003cdiv class=\"nav-links\"\u003e \u003cp\u003eNav:\u003c/p\u003e \u003cp\u003eHome\u003c/p\u003e \u003cp\u003eNews\u003c/p\u003e \u003cp\u003eAbout\u003c/p\u003e \u003c/div\u003e \u003c/div\u003e \u003cdiv id=\"content\"\u003e \u003ch1\u003eThe Article - BANANA TREE\u003c/h1\u003e \u003cdiv class=\"chapter\"\u003e \u003ch2\u003eSection 1\u003c/h2\u003e \u003cp\u003e A banana tree is a must if you wish to bring a sizeable touch of the tropics into your home. \u003c/p\u003e \u003c/div\u003e \u003cdiv class=\"chapter\"\u003e \u003ch2\u003eSection 2\u003c/h2\u003e \u003cp\u003eThere are some 400 species worldwide.\u003c/p\u003e \u003cdiv class=\"move-to-the-right\"\u003e \u003ch2\u003eA Aside - Why are bananas bent?\u003c/h2\u003e Gravity causes the fruit to hang down. \u003c/div\u003e \u003c/div\u003e \u003cp\u003e The text is from: \u003ca href=\"https://www.thejoyofplants.co.uk/banana-tree\" \u003eThe Joy of Plants.co.uk\u003c/a \u003e \u003c/p\u003e \u003c/div\u003e \u003cdiv id=\"end-of-the-page\"\u003e \u003ch2\u003eThe Footer\u003c/h2\u003e \u003cdiv\u003e \u003cp\u003eContact\u003c/p\u003e \u003cp\u003eImpressum\u003c/p\u003e \u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e in diese Form vereinfachen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 \u003c!doctype html\u003e \u003chtml\u003e \u003chead\u003e\u003c/head\u003e \u003cbody\u003e \u003cheader\u003e \u003ch1\u003eThe Header\u003c/h1\u003e \u003cnav\u003e \u003cp\u003eNav:\u003c/p\u003e \u003cp\u003eHome\u003c/p\u003e \u003cp\u003eNews\u003c/p\u003e \u003cp\u003eAbout\u003c/p\u003e \u003c/nav\u003e \u003c/header\u003e \u003cmain\u003e \u003carticle\u003e \u003ch1\u003eThe Article - BANANA TREE\u003c/h1\u003e \u003csection\u003e \u003ch2\u003eSection 1\u003c/h2\u003e \u003cp\u003e A banana tree is a must if you wish to bring a sizeable touch of the tropics into your home. \u003c/p\u003e \u003c/section\u003e \u003csection\u003e \u003ch2\u003eSection 2\u003c/h2\u003e \u003cp\u003eThere are some 400 species worldwide.\u003c/p\u003e \u003caside\u003e \u003ch2\u003eA Aside - Why are bananas bent?\u003c/h2\u003e Gravity causes the fruit to hang down. \u003c/aside\u003e \u003c/section\u003e \u003cp\u003e The text is from: \u003ca href=\"https://www.thejoyofplants.co.uk/banana-tree\" \u003eThe Joy of Plants.co.uk\u003c/a \u003e \u003c/p\u003e \u003c/article\u003e \u003c/main\u003e \u003cfooter\u003e \u003ch2\u003eThe Footer\u003c/h2\u003e \u003cdiv\u003e \u003cp\u003eContact\u003c/p\u003e \u003cp\u003eImpressum\u003c/p\u003e \u003c/div\u003e \u003c/footer\u003e \u003c/body\u003e \u003c/html\u003e Jetzt bist du dran. Löse die Aufgabe 3 in den Labs.\n","categories":"","description":"Modul #F3 - HTML- und CSS-Tags, welche ihre Bedeutung dem Browser und dem Entwickler beschreiben.\n","excerpt":"Modul #F3 - HTML- und CSS-Tags, welche ihre Bedeutung dem Browser und …","ref":"/de/docs/03_web/02_html_css/07_html-5-semantic-tags/","tags":"","title":"HTML5 Semantic Tags"},{"body":"Ziele Ich kann in eigenen Worten den Unterschied zwischen statische- und nicht-statische Initialisierungsblöcke erklären. Ich kann den Zweck erörtern, welcher Initialisierungsblöcke erfüllen. Initialisierungsblöcke Neben Konstruktoren gibt es noch zwei weitere Konstrukte, die der Initialisierung dienen. Statische und nicht-statische Initialisierungsblöcke. Diese sehen wie folgt aus:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Car { static { // Statischer Initialisierungsblock } { // Instanzblock } public Car { // Konstruktor } } Innerhalb dieser Initialisierungblöcke können ähnlich wie bei den Konstruktoren bestimmte Initialisierungen durchgeführt werden. Initialisierungsblöcke sind dann nützlich, wenn z.B. bei der Erstellung eines Objekts gewisser Code noch vor der Ausführung des Konstruktors als Vorbereitung ausgeführt werden muss.\nGrundsätzlich können die beiden Blöcke beliebigen Programmcode enthalten. Die Reihenfolge bei der Erstellung eines neuen Objekts ist wie folgt:\nStatische Variablen Statische Initialisierungblöcke Instanzvariablen Instanzblöcke Konstruktoren Eine Java-Klasse kann beliebig viele statische und nicht-statische Initialisierungsblöcke aufweisen. Die Reihenfolge des Aufrufs bei mehreren Blöcken richtet sich nach der Reihenfolge der Implementation (sprich, die oberen Blöcke werden zuerst ausgeführt).\nBeispiel Folgendes Beispiel braucht einen statischen Initialisierungsblock, um eine Default-Waffe auszuwählen, die als Default für alle Ninjas gilt. In einem Instanzblock wird die Instanzvariable weapon gleich diesem Default-Wert gesetzt, damit das nicht in jedem Konstruktor (stelle dir vor, es gäbe viele davon) gemacht werden muss, wo die weapon nicht gesetzt wird.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 import java.util.Random; public class Ninja { private String name; private String weapon; private static String defaultWeapon; private static final String[] availableWeapons = {\"Shuriken\", \"Ninjatō\", \"Kunai\"}; static { Random random = new Random(System.currentTimeMillis()); int randomIndex = random.nextInt(availableWeapons.length); defaultWeapon = availableWeapons[randomIndex]; } // Instanzblock { // Default-Wert, damit der Wert nicht in jedem Konstruktor gesetzt werden muss: this.weapon = defaultWeapon; } public Ninja(String name) { this.name = name; } public Ninja(String name, String weapon) { this(name); this.weapon = weapon; } @Override public String toString() { return \"[name: \" + name + \", weapon: \" + weapon + \"]\"; } public static void main(String[] args) { Ninja ninja1 = new Ninja(\"Kaito\"); Ninja ninja2 = new Ninja(\"Kota\", \"Kusarigama\"); System.out.println(ninja1); System.out.println(ninja2); } } ","categories":"","description":"Modul #J2\n","excerpt":"Modul #J2\n","ref":"/docs/02_java/04_java-oop/07_initialization-blocks/","tags":"","title":"Initialisierungsblöcke"},{"body":"Ziele Ich kann in eigenen Worten den Unterschied zwischen statische- und nicht-statische Initialisierungsblöcke erklären. Ich kann den Zweck erörtern, welcher Initialisierungsblöcke erfüllen. Initialisierungsblöcke Neben Konstruktoren gibt es noch zwei weitere Konstrukte, die der Initialisierung dienen. Statische und nicht-statische Initialisierungsblöcke. Diese sehen wie folgt aus:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Car { static { // Statischer Initialisierungsblock } { // Instanzblock } public Car { // Konstruktor } } Innerhalb dieser Initialisierungblöcke können ähnlich wie bei den Konstruktoren bestimmte Initialisierungen durchgeführt werden. Initialisierungsblöcke sind dann nützlich, wenn z.B. bei der Erstellung eines Objekts gewisser Code noch vor der Ausführung des Konstruktors als Vorbereitung ausgeführt werden muss.\nGrundsätzlich können die beiden Blöcke beliebigen Programmcode enthalten. Die Reihenfolge bei der Erstellung eines neuen Objekts ist wie folgt:\nStatische Variablen Statische Initialisierungblöcke Instanzvariablen Instanzblöcke Konstruktoren Eine Java-Klasse kann beliebig viele statische und nicht-statische Initialisierungsblöcke aufweisen. Die Reihenfolge des Aufrufs bei mehreren Blöcken richtet sich nach der Reihenfolge der Implementation (sprich, die oberen Blöcke werden zuerst ausgeführt).\nBeispiel Folgendes Beispiel braucht einen statischen Initialisierungsblock, um eine Default-Waffe auszuwählen, die als Default für alle Ninjas gilt. In einem Instanzblock wird die Instanzvariable weapon gleich diesem Default-Wert gesetzt, damit das nicht in jedem Konstruktor (stelle dir vor, es gäbe viele davon) gemacht werden muss, wo die weapon nicht gesetzt wird.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 import java.util.Random; public class Ninja { private String name; private String weapon; private static String defaultWeapon; private static final String[] availableWeapons = {\"Shuriken\", \"Ninjatō\", \"Kunai\"}; static { Random random = new Random(System.currentTimeMillis()); int randomIndex = random.nextInt(availableWeapons.length); defaultWeapon = availableWeapons[randomIndex]; } // Instanzblock { // Default-Wert, damit der Wert nicht in jedem Konstruktor gesetzt werden muss: this.weapon = defaultWeapon; } public Ninja(String name) { this.name = name; } public Ninja(String name, String weapon) { this(name); this.weapon = weapon; } @Override public String toString() { return \"[name: \" + name + \", weapon: \" + weapon + \"]\"; } public static void main(String[] args) { Ninja ninja1 = new Ninja(\"Kaito\"); Ninja ninja2 = new Ninja(\"Kota\", \"Kusarigama\"); System.out.println(ninja1); System.out.println(ninja2); } } ","categories":"","description":"Modul #J2\n","excerpt":"Modul #J2\n","ref":"/de/docs/02_java/04_java-oop/07_initialization-blocks/","tags":"","title":"Initialisierungsblöcke"},{"body":"","categories":"","description":"Exercises zu Modul #J3 - [OOD](../../../../docs/02_java/07_java-ood)\n","excerpt":"Exercises zu Modul #J3 - [OOD](../../../../docs/02_java/07_java-ood)\n","ref":"/labs/02_java/07_java-ood/","tags":"","title":"Java Exercises - OOD"},{"body":"","categories":"","description":"Exercises zu Modul #J3 - [OOD](../../../../docs/02_java/07_java-ood)\n","excerpt":"Exercises zu Modul #J3 - [OOD](../../../../docs/02_java/07_java-ood)\n","ref":"/de/labs/02_java/07_java-ood/","tags":"","title":"Java Exercises - OOD"},{"body":"","categories":"","description":"Exams zu Modul #J3\n","excerpt":"Exams zu Modul #J3\n","ref":"/exams/02_java/07_java-ood/","tags":"","title":"Java OOD Exams"},{"body":"","categories":"","description":"Exams zu Modul #J3\n","excerpt":"Exams zu Modul #J3\n","ref":"/de/exams/02_java/07_java-ood/","tags":"","title":"Java OOD Exams"},{"body":"java.util.LinkedList LinkedLists sind verkettete Listen. D.h. die Elemente der Listen sind zueinander verkettet und nicht wie bei einer ArrayList an bestimmten Positionen platziert.\njava.util.LinkedList implementiert zwei Collection-Interfaces: java.util.List und java.util.Deque. Das bedeutet grundsätzlich, dass sie sowohl die Methoden des List-Interfaces implementiert, als auch die des Deque-Interfaces.\nGrundsätzlich gibt es zwei Arten von verketteten Listen: Einfach verkettete Listen und doppelt verkettete Liste. Wir werden beide anschauen, wie sie im Allgemeinen aussehen. Die java.util.LinkedList ist die Implementierung einer doppelt verketteten Liste.\nEinfach verkettete Listen Verkettete Listen bestehen aus Knoten (Nodes). Jeder Knoten enthält ein Element und eine Referenz auf einen weiteren Knoten, falls dieser vorhanden ist. Die Knoten sind somit über eine Referenz auf jeweils den nächsten Knoten miteinander verkettet. Die verkettete Liste enthält schlussendlich eine Referenz auf den ersten Knoten in der Liste. Der letzte Knoten enthält eine Referenz auf null.\nElement zu einer einfach verketten Liste hinzufügen Wird ein Knoten zu einer einfach verketteten Liste hinzugefügt, dann muss die Referenz des Knotens davor auf dieses Element zeigen und die Referenz des Elements, das hinzugefügt wird, muss auf den nächsten Knoten zeigen. So wird ein neuer Knoten zwischen zwei Knoten eingeschoben.\nElement aus einer einfach verketten Liste löschen Wird ein Knoten aus einer einfach verketteten Liste gelöscht, dann muss die Referenz des Knotens davor auf das zu löschende Element gelöscht werden und ersetzt werden mit der Referenz auf das nächste Element. Die Referenz des Elements, das gelöscht wird, auf das nächste Element muss auch gelöscht werden. So wird ein bestehender Knoten zwischen zwei Knoten entfernt.\nDoppelt verkettete Listen In einer doppelt verketteten Liste haben die Knoten nicht nur eine Referenz auf den nächsten Knoten, sondern auch eine Referenz auf den vorherigen Knoten. Eine mögliche Implementierung einder doppelt verketteten Liste könnte sein, dass der letzte Knoten, wie auch schon bei einer einfach verketteten Liste eine Referenz auf null hat als nächsten Knoten und der erste Knoten in einer doppelt verketteten Liste eine Referenz auf null hat als vorherigen Knoten. Zusätzlich hat man eine Referenz auf den Kopf der Liste, d.h. auf den ersten Knoten und eine Referenze auf den letzten Knoten der Liste.\nDas Einfügen und Entfernen funktioniert analog zu einer einfach verketteten Liste.\nEin Element aus einer (einfach oder doppelt) verketteten Liste auslesen Wenn man ein Element in einer einfach verketteten Liste auslesen möchte, dann muss man vom ersten Knoten anfangen und ein Knoten nach dem anderen die Liste durchlaufen bis zu diesem Element. Im “schlimmsten” Fall muss über alle Knoten iteriert werden, wenn das Element, das man sucht, im letzten Knoten ist.\nArrayList vs. LinkedList Der Vorteil von LinkedLists besteht darin, dass Elemente schneller hinzugefügt und schneller aus der Liste gelöscht werden können im Vergleich zu ArrayLists. Bei einer LinkedList müssen nur die Referenzen zum “Vorgänger” und “Nachfolgen” angepasst werden, wenn man ein Element einfügen oder löschen möchte. Der Nachteil jedoch besteht darin, dass der Zugriff auf Elementen der Liste an einer bestimmten Position im Vergleich zu ArrayLists langsamer ist, da in diesem Fall die Liste bis zu dem entsprechenden Element durchlaufen werden muss. Die Entscheidung für einen bestimmten Listen-Typ ist also abhängig von der Art und Anzahl der Zugriffe.\nLinkedList-Klasse im Java Die LinkedList-Klasse im Java (java.util.LinkedList) implementiert eine doppelt verkettete Liste. Sie ist so implementiert, dass sie zwei Referenzen enthält, zum einen die Referenz zum ersten Knoten und zum anderen die Referenz zum zweiten Knoten:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class LinkedList\u003cE\u003e extends AbstractSequentialList\u003cE\u003e implements List\u003cE\u003e, Deque\u003cE\u003e, Cloneable, java.io.Serializable { transient int size = 0; /** * Pointer to first node. */ transient Node\u003cE\u003e first; /** * Pointer to last node. */ transient Node\u003cE\u003e last; ... } Das Java-Schlüsselwort transient wird verwendet, um ein Feld in einer Klasse von der Serialisierung auszuschließen. Serialisierung ist der Prozess, ein Objekt in einen Byte-Stream umzuwandeln, um es zu speichern oder über ein Netzwerk zu übertragen. Transiente Felder werden dabei nicht gespeichert und erhalten nach der Deserialisierung ihre Standardwerte (z. B. null für Objekte, 0 für Zahlen).\nEin Knoten, also das Objekt des Typs Node, enthält\ndas Element, welches einen generischen Typ hat (deshalb Node\u003cE\u003e), die Referenz auf den vorherigen Knoten, also auf ein Node-Objekt und eine Referenz auf den nächsten Knoten. Die statische Klasse Node\u003cE\u003e ist innerhalb der Klasse java.util.LinkedList definiert:\n1 2 3 4 5 6 7 8 9 10 11 private static class Node\u003cE\u003e { E item; Node\u003cE\u003e next; Node\u003cE\u003e prev; Node(Node\u003cE\u003e prev, E element, Node\u003cE\u003e next) { this.item = element; this.next = next; this.prev = prev; } } Einige Methoden der Klasse java.util.LinkedList 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 /* * Konstruktor: Erstellt eine initial leere Liste */ public LinkedList() /* * Gibt das erste Element der Liste zurück. */ public E getFirst() /* * Gibt das letzte Element der Liste zurück. */ public E getLast() /* * Entfernt das erste Element der Liste und gibt es zurück. */ public E removeFirst() /* * Entfernt das letzte Element der Liste und gibt es zurück. */ public E removeLast() /* * Fügt das angegeben Element an den Anfang der Liste ein. */ public void addFirst(E e) /* * Fügt das angegebene Element an das Ende der Liste an. */ public void addLast(E e) ... // *** Queue and Deque methods *** ... // *** Stack methods *** ... // *** List methods *** ... Beispiel Hier ein kurzes Beispiel wie LinkedList verwendet werden könnte:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import java.util.LinkedList; public class Main { public static void main(String[] args) { LinkedList\u003cString\u003e fruits = new LinkedList\u003c\u003e(); // LinkedList erstellen // Elemente hinzufügen fruits.add(\"Apfel\"); fruits.add(\"Banane\"); fruits.addFirst(\"Erdbeere\"); // Element am Anfang hinzufügen // Elemente anzeigen System.out.println(\"Früchte: \" + fruits); // [Erdbeere, Apfel, Banane] // Elemente entfernen fruits.remove(\"Apfel\"); // Spezifisches Element entfernen System.out.println(\"Nach Entfernen: \" + fruits); // [Erdbeere, Banane] // Auf ein Element zugreifen System.out.println(\"Erstes Element: \" + fruits.get(0)); // Erdbeere } } Aufgaben Löse nun die Aufgaben zur LinkedList.\n","categories":"","description":"Eine verkettete Liste, die LinkedList.\n","excerpt":"Eine verkettete Liste, die LinkedList.\n","ref":"/docs/02_java/10_java-collections/07_linked-list/","tags":"","title":"LinkedList"},{"body":"java.util.LinkedList LinkedLists sind verkettete Listen. D.h. die Elemente der Listen sind zueinander verkettet und nicht wie bei einer ArrayList an bestimmten Positionen platziert.\njava.util.LinkedList implementiert zwei Collection-Interfaces: java.util.List und java.util.Deque. Das bedeutet grundsätzlich, dass sie sowohl die Methoden des List-Interfaces implementiert, als auch die des Deque-Interfaces.\nGrundsätzlich gibt es zwei Arten von verketteten Listen: Einfach verkettete Listen und doppelt verkettete Liste. Wir werden beide anschauen, wie sie im Allgemeinen aussehen. Die java.util.LinkedList ist die Implementierung einer doppelt verketteten Liste.\nEinfach verkettete Listen Verkettete Listen bestehen aus Knoten (Nodes). Jeder Knoten enthält ein Element und eine Referenz auf einen weiteren Knoten, falls dieser vorhanden ist. Die Knoten sind somit über eine Referenz auf jeweils den nächsten Knoten miteinander verkettet. Die verkettete Liste enthält schlussendlich eine Referenz auf den ersten Knoten in der Liste. Der letzte Knoten enthält eine Referenz auf null.\nElement zu einer einfach verketten Liste hinzufügen Wird ein Knoten zu einer einfach verketteten Liste hinzugefügt, dann muss die Referenz des Knotens davor auf dieses Element zeigen und die Referenz des Elements, das hinzugefügt wird, muss auf den nächsten Knoten zeigen. So wird ein neuer Knoten zwischen zwei Knoten eingeschoben.\nElement aus einer einfach verketten Liste löschen Wird ein Knoten aus einer einfach verketteten Liste gelöscht, dann muss die Referenz des Knotens davor auf das zu löschende Element gelöscht werden und ersetzt werden mit der Referenz auf das nächste Element. Die Referenz des Elements, das gelöscht wird, auf das nächste Element muss auch gelöscht werden. So wird ein bestehender Knoten zwischen zwei Knoten entfernt.\nDoppelt verkettete Listen In einer doppelt verketteten Liste haben die Knoten nicht nur eine Referenz auf den nächsten Knoten, sondern auch eine Referenz auf den vorherigen Knoten. Eine mögliche Implementierung einder doppelt verketteten Liste könnte sein, dass der letzte Knoten, wie auch schon bei einer einfach verketteten Liste eine Referenz auf null hat als nächsten Knoten und der erste Knoten in einer doppelt verketteten Liste eine Referenz auf null hat als vorherigen Knoten. Zusätzlich hat man eine Referenz auf den Kopf der Liste, d.h. auf den ersten Knoten und eine Referenze auf den letzten Knoten der Liste.\nDas Einfügen und Entfernen funktioniert analog zu einer einfach verketteten Liste.\nEin Element aus einer (einfach oder doppelt) verketteten Liste auslesen Wenn man ein Element in einer einfach verketteten Liste auslesen möchte, dann muss man vom ersten Knoten anfangen und ein Knoten nach dem anderen die Liste durchlaufen bis zu diesem Element. Im “schlimmsten” Fall muss über alle Knoten iteriert werden, wenn das Element, das man sucht, im letzten Knoten ist.\nArrayList vs. LinkedList Der Vorteil von LinkedLists besteht darin, dass Elemente schneller hinzugefügt und schneller aus der Liste gelöscht werden können im Vergleich zu ArrayLists. Bei einer LinkedList müssen nur die Referenzen zum “Vorgänger” und “Nachfolgen” angepasst werden, wenn man ein Element einfügen oder löschen möchte. Der Nachteil jedoch besteht darin, dass der Zugriff auf Elementen der Liste an einer bestimmten Position im Vergleich zu ArrayLists langsamer ist, da in diesem Fall die Liste bis zu dem entsprechenden Element durchlaufen werden muss. Die Entscheidung für einen bestimmten Listen-Typ ist also abhängig von der Art und Anzahl der Zugriffe.\nLinkedList-Klasse im Java Die LinkedList-Klasse im Java (java.util.LinkedList) implementiert eine doppelt verkettete Liste. Sie ist so implementiert, dass sie zwei Referenzen enthält, zum einen die Referenz zum ersten Knoten und zum anderen die Referenz zum zweiten Knoten:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class LinkedList\u003cE\u003e extends AbstractSequentialList\u003cE\u003e implements List\u003cE\u003e, Deque\u003cE\u003e, Cloneable, java.io.Serializable { transient int size = 0; /** * Pointer to first node. */ transient Node\u003cE\u003e first; /** * Pointer to last node. */ transient Node\u003cE\u003e last; ... } Das Java-Schlüsselwort transient wird verwendet, um ein Feld in einer Klasse von der Serialisierung auszuschließen. Serialisierung ist der Prozess, ein Objekt in einen Byte-Stream umzuwandeln, um es zu speichern oder über ein Netzwerk zu übertragen. Transiente Felder werden dabei nicht gespeichert und erhalten nach der Deserialisierung ihre Standardwerte (z. B. null für Objekte, 0 für Zahlen).\nEin Knoten, also das Objekt des Typs Node, enthält\ndas Element, welches einen generischen Typ hat (deshalb Node\u003cE\u003e), die Referenz auf den vorherigen Knoten, also auf ein Node-Objekt und eine Referenz auf den nächsten Knoten. Die statische Klasse Node\u003cE\u003e ist innerhalb der Klasse java.util.LinkedList definiert:\n1 2 3 4 5 6 7 8 9 10 11 private static class Node\u003cE\u003e { E item; Node\u003cE\u003e next; Node\u003cE\u003e prev; Node(Node\u003cE\u003e prev, E element, Node\u003cE\u003e next) { this.item = element; this.next = next; this.prev = prev; } } Einige Methoden der Klasse java.util.LinkedList 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 /* * Konstruktor: Erstellt eine initial leere Liste */ public LinkedList() /* * Gibt das erste Element der Liste zurück. */ public E getFirst() /* * Gibt das letzte Element der Liste zurück. */ public E getLast() /* * Entfernt das erste Element der Liste und gibt es zurück. */ public E removeFirst() /* * Entfernt das letzte Element der Liste und gibt es zurück. */ public E removeLast() /* * Fügt das angegeben Element an den Anfang der Liste ein. */ public void addFirst(E e) /* * Fügt das angegebene Element an das Ende der Liste an. */ public void addLast(E e) ... // *** Queue and Deque methods *** ... // *** Stack methods *** ... // *** List methods *** ... Beispiel Hier ein kurzes Beispiel wie LinkedList verwendet werden könnte:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import java.util.LinkedList; public class Main { public static void main(String[] args) { LinkedList\u003cString\u003e fruits = new LinkedList\u003c\u003e(); // LinkedList erstellen // Elemente hinzufügen fruits.add(\"Apfel\"); fruits.add(\"Banane\"); fruits.addFirst(\"Erdbeere\"); // Element am Anfang hinzufügen // Elemente anzeigen System.out.println(\"Früchte: \" + fruits); // [Erdbeere, Apfel, Banane] // Elemente entfernen fruits.remove(\"Apfel\"); // Spezifisches Element entfernen System.out.println(\"Nach Entfernen: \" + fruits); // [Erdbeere, Banane] // Auf ein Element zugreifen System.out.println(\"Erstes Element: \" + fruits.get(0)); // Erdbeere } } Aufgaben Löse nun die Aufgaben zur LinkedList.\n","categories":"","description":"Eine verkettete Liste, die LinkedList.\n","excerpt":"Eine verkettete Liste, die LinkedList.\n","ref":"/de/docs/02_java/10_java-collections/07_linked-list/","tags":"","title":"LinkedList"},{"body":"Aufgabe 1 Du hast eine Playlist mit 5 Liedern, die in einer LinkedList gespeichert ist und wie folgt vordefiniert ist:\n1 2 3 4 5 6 7 LinkedList\u003cString\u003e songList = new LinkedList\u003c\u003e(Arrays.asList( \"Bohemian Rhapsody\", \"Stairway to Heaven\", \"Hotel California\", \"Imagine\", \"Hey Jude\" )); Nun sollen verschiedene Aktionen mit der Playlist vorgenommen werden.\nEntferne den ersten Song in der Playlist. Füge den Song “Blinding Lights” in der Mitte der Playlist ein. Ersetze den letzten Song mit “Smells Like Teen Spirit”. Schreibe anschliessend die Playlist in die Konsole. Vom Format her sollte die Ausgabe so aussehen:\n1 [Stairway to Heaven, Hotel California, Blinding Lights, Imagine, Smells Like Teen Spirit] Um dieses Format zu erhalten, kannst du die Methode toString() auf deiner LinkedList aufrufen.\nAusgabe überprüfen Verwende wieder die kleine Hilfsklasse OutputValidation zum Verifizieren des Konsolen-Outputs. Der Konsole-Output Hash für diese Aufgabe ist: -642408310\n","categories":"","description":"Aufgaben zu [Java Collections - LinkedList](../../../docs/02_java/10_java-collections/07_linked-list)\n","excerpt":"Aufgaben zu [Java Collections - …","ref":"/labs/02_java/10_java-collections/07_linkedlist/","tags":"","title":"LinkedList - Aufgaben"},{"body":"Aufgabe 1 Du hast eine Playlist mit 5 Liedern, die in einer LinkedList gespeichert ist und wie folgt vordefiniert ist:\n1 2 3 4 5 6 7 LinkedList\u003cString\u003e songList = new LinkedList\u003c\u003e(Arrays.asList( \"Bohemian Rhapsody\", \"Stairway to Heaven\", \"Hotel California\", \"Imagine\", \"Hey Jude\" )); Nun sollen verschiedene Aktionen mit der Playlist vorgenommen werden.\nEntferne den ersten Song in der Playlist. Füge den Song “Blinding Lights” in der Mitte der Playlist ein. Ersetze den letzten Song mit “Smells Like Teen Spirit”. Schreibe anschliessend die Playlist in die Konsole. Vom Format her sollte die Ausgabe so aussehen:\n1 [Stairway to Heaven, Hotel California, Blinding Lights, Imagine, Smells Like Teen Spirit] Um dieses Format zu erhalten, kannst du die Methode toString() auf deiner LinkedList aufrufen.\nAusgabe überprüfen Verwende wieder die kleine Hilfsklasse OutputValidation zum Verifizieren des Konsolen-Outputs. Der Konsole-Output Hash für diese Aufgabe ist: -642408310\n","categories":"","description":"Aufgaben zu [Java Collections - LinkedList](../../../docs/02_java/10_java-collections/07_linked-list)\n","excerpt":"Aufgaben zu [Java Collections - …","ref":"/de/labs/02_java/10_java-collections/07_linkedlist/","tags":"","title":"LinkedList - Aufgaben"},{"body":"Aufgabe 1 NinjaCups ist ein aufstrebendes Kaffeeunternehmen mit verschiedenen Standorten. Jeder Standort verkauft eine Vielzahl von Kaffees. Deine Aufgabe ist es, eine Java-Klasse zu schreiben, die den Gesamtverkauf von Kaffee über alle Standorte von NinjaCups verfolgt. Eine Instanz dieser Klasse soll somit ein Standort des Unternehmens darstellen. Über die Klasse soll schlussendlich ersichtlich sein, wie viele Kaffees über das gesamte Unternehmen verkauft wurden.\nHier kannst du zurück zur Theorie.\n","categories":"","description":"Aufgabe zu Modul #J2 - OOP - NinjaCups (static)\n","excerpt":"Aufgabe zu Modul #J2 - OOP - NinjaCups (static)\n","ref":"/labs/02_java/04_java-oop/07_ninjacups/","tags":"","title":"NinjaCups"},{"body":"Aufgabe 1 NinjaCups ist ein aufstrebendes Kaffeeunternehmen mit verschiedenen Standorten. Jeder Standort verkauft eine Vielzahl von Kaffees. Deine Aufgabe ist es, eine Java-Klasse zu schreiben, die den Gesamtverkauf von Kaffee über alle Standorte von NinjaCups verfolgt. Eine Instanz dieser Klasse soll somit ein Standort des Unternehmens darstellen. Über die Klasse soll schlussendlich ersichtlich sein, wie viele Kaffees über das gesamte Unternehmen verkauft wurden.\nHier kannst du zurück zur Theorie.\n","categories":"","description":"Aufgabe zu Modul #J2 - OOP - NinjaCups (static)\n","excerpt":"Aufgabe zu Modul #J2 - OOP - NinjaCups (static)\n","ref":"/de/labs/02_java/04_java-oop/07_ninjacups/","tags":"","title":"NinjaCups"},{"body":"Ziele Ich kann die Konzepte der Generalisierung und Spezialisierung im Kontext der Vererbung erklären und anwenden. Ich weiss, wie ich Unterklassen von einer Oberklasse ableiten kann (extends). Ich kann vererbte Methoden und Attribute einer Klasse von lokalen Methoden und Attributen unterscheiden. Ich kann in UML (Unified Modeling Language) die Vererbungsbeziehung zweier Klassen erkennen. Ich weiss, wie ich das Schlüsselwort super nutze, um den Konstruktor der Oberklasse zu verwenden. Ich weiss, wie ich das Schlüsselwort super nutze, um eine Methode aus der Oberklasse aufzurufen. Ich kann das Konzept des “Überschreibens” (Overriding) von Methoden und Attributen erklären, erkennen und nutzen. Ich weiss, was Interfaces sind und wann es angebracht ist, ein Interface zu verwenden. Ich weiss, welche Methoden und Felder in einem Interface vorhanden sind und wie sie geschrieben werden bzw. über welche Eigenschaften sie verfügen. Ich kann eine Klasse schreiben, die ein Interface implementiert. Einführung Beim objektorientierten Design (OOD) handelt es sich um die Modellierung der realen Welt in Klassen und Objekten. In dieser Phase der Softwareentwicklung werden Objekte und Klassen definiert sowie ihre Eigenschaften, Funktionen und die Beziehungen untereinander festgelegt.\nDie wichtigsten Konzepte/Prinzipien des objektorientierten Designs sind:\nVererbung ermöglicht es in Java, eine hierarchische Ordnung für Klassen festzulegen. Dadurch wird die Menge an redundantem Code reduziert. Polymorphismus beschreibt eine Sprachstruktur, bei der Methoden mit derselben Signatur unterschiedlich implementiert werden können und dadurch verschiedene Ergebnisse liefern. Abstraktion ist ein Prinzip, bei dem durch das Weglassen von Details nur die wesentlichen Eigenschaften eines Objekts hervorgehoben werden. Kapselung ermöglicht es, den Zugriff auf die Methoden und Attribute einer Klasse zu kontrollieren und zu schützen. Das Befolgen dieser Konzepte/Prinzipien führt zu einem guten objektorientierten Design und trägt wesentlich zur Qualität der Software bei.\nVererbung Vererbung ist ein Mechanismus zum Ableiten einer neuen Klasse von einer anderen Klasse. Die neue Klasse erbt alle nicht-privaten Felder und Methoden der Basisklasse. Die Vererbung ist eines der Hauptkonzepte der objektorientierten Programmierung.\nAls Beispiel dient uns die Klasse Auto, welche von der Klasse Fahrzeug abgeleitet ist. Die Beziehung zwischen den Klassen wird als IS-A Beziehung bezeichnet. Wir würden also logischerweise sagen, dass ein Auto ein Fahrzeug ist. Die Klasse Auto wird auch als Spezialisierung der Klasse Fahrzeug bezeichnet. Umgekehrt bezeichnen wir die Klasse Fahrzeug als Generalisierung der Klasse Auto.\nSynonyme für die abgeleitete Klasse sind:\nUnterklasse (Subclass), abgeleitete Klasse (Derived Class), erweiterte Klasse (Extended Class), Kind-Klasse (Child Class). Synonyme für die Klasse, von der abgeleitet wird:\nOberklasse (Superclass), Basisklasse (Base Class), Eltern-Klasse (Parent Class). Der Anwendungsfall der Vererbung kommt also dort zum Tragen, wo es eine IS-A Beziehung zwischen zwei Objekten gibt. Dazu ein paar Beispiele:\nEin Quadrat ist eine geometrische Form. Java ist eine Programmiersprache. Ein Schwert ist eine Klingenwaffe. Eine Klingenwaffe ist eine Waffe. Superklasse Subklasse Geometrische Form Quadrat Programmiersprache Java Klingenwaffe Schwert Waffe Klingenwaffe Es gibt einige wichtige Punkte zur Vererbung in Java:\nIn Java gibt es keine Mehrfachvererbung. Eine Klasse kann immer nur von maximal einer anderen Klasse erben Eine Klassenhierarchie kann beliebig viele Ebenen haben Die Klasse Schwert erbt von der Klasse Klingenwaffe und die Klasse Klingenwaffe erbt von der Klasse Waffe Eine Superklasse kann beliebig viele Subklassen haben Im UML-Diagramm sind die Basisklassen oberhalb der abgeleiteten Klassen abgebildet. Die Klassen werden mit Pfeilen verbunden, wobei die Pfeilrichtung von der abgeleiteten Klasse in Richtung der Basisklasse verläuft. Der Vererbungspfeil hat eine durchgezogene Linie und ein geschlossenes Dreieck als Pfeilspitze.\nEine Subklasse kann beliebig viele neue Felder und Methoden enthalten. Geerbte und neu hinzugefügte Felder und Methoden werden wie bisher gelernt verwendet.\nDas Schlüsselwort extends In Java wird eine Vererbungsbeziehung implementiert, indem wir das Schlüsselwort extends verwenden.\n1 2 3 public class Fahrzeug { } 1 2 3 public class Auto extends Fahrzeug { } Bei der Deklaration eines Autos ist es nun aufgrund der Vererbungsbeziehung möglich, dass wir statt eines Autos ein Fahrzeug verwenden. Dies funktioniert, weil ein Auto ja ein Fahrzeug ist (IS-A).\n1 2 3 4 5 6 public class Main { public static void main(String[] args) { Fahrzeug fahrzeug = new Auto(); } } Das Schlüsselwort final Wenn eine Klasse mit dem Schlüsselwort final versehen wird, dann kann sie keine Subklassen haben. Wir können die Vererbung also verbieten.\n1 2 3 public final class NonDerivableClass { } Viele der Standardklassen von Java sind final. Dazu gehören alle Wrapper-Klassen von primitiven Datentypen wie Integer, Long oder Float und die Klasse String.\nDas Schlüsselwort super Das Schlüsselwort super ähnelt dem Schlüsselwort this. Es erlaubt den direkten Zugriff auf Felder, Konstruktoren und Methoden der Superklasse. Bei gleicher Namensgebung von Feldern oder beim Überschreiben von Methoden ist es teilweise sogar zwingend notwendig.\nUmgang mit Konstruktoren Konstruktoren werden nicht an die Subklasse vererbt. Wenn aber ein neues Objekt einer Subklasse erzeugt werden soll, so kann der Konstruktor der Superklasse nicht einfach ignoriert werden. Beim Erzeugen von Objekten einer Subklasse unterscheiden wir zwischen den folgenden Fällen:\nDie Superklasse hat keinen Konstruktor (das heisst, sie besitzt einen Default-Konstruktor). Die Superklasse hat einen anderen Konstruktor als den Default-Konstruktor. Die Superklasse hat einen anderen Konstruktor und zusätzlich einen Default-Konstruktor. Beispiel 1 - Die Superklasse hat keinen Konstruktor\n1 2 3 public class Fahrzeug { } 1 2 3 public class Auto extends Fahrzeug { } 1 2 3 4 5 6 public class Main { public static void main(String[] args) { Fahrzeug auto = new Auto(); } } Beispiel 2 - Die Superklasse hat einen anderen Konstruktor als den Default-Konstruktor\n1 2 3 4 5 6 7 8 public class Fahrzeug { private String marke; public Fahrzeug(String marke) { this.marke = marke; } } 1 2 3 4 5 6 7 8 9 10 11 12 public class Auto extends Fahrzeug { // Möglichkeit 1 - Konstruktor-Weiterleitung public Auto(String marke) { super(marke); } // Möglichkeit 2 - Fixer Wert public Auto() { super(\"Unbekannt\"); } } 1 2 3 4 5 6 7 8 9 public class Main { public static void main(String[] args) { // Möglichkeit 1 Fahrzeug ferrari = new Auto(\"Ferrari\"); // Möglichkeit 2 Fahrzeug any = new Auto(); } } Für die Erzegung eines Fahrzeugs ist nun eine Marke notwendig. Dies bedeutet automatisch, dass die Erzeugung eines Autos auch einen Wert für diese Marke besitzen muss. Der Wert kann entweder über einen weiteren Konstruktor in der Klasse Auto in das Fahrzeug gelangen oder man wählt - wie im Beispiel gezeigt - einen fixen Wert. Die Erzeugung eines neuen Autos ohne einen Wert für die Marke ist aber nicht möglich, da die Superklasse einen Wert verlangt.\nBeispiel 3 - Die Superklasse hat einen anderen Konstruktor und zusätzlich einen Default-Konstruktor\n1 2 3 4 5 6 7 8 9 10 11 12 public class Fahrzeug { private String marke; public Fahrzeug() { this.marke = \"Unbekannt\"; } public Fahrzeug(String marke) { this.marke = marke; } } 1 2 3 4 5 6 7 8 9 10 public class Auto extends Fahrzeug { public Auto() { super(); } public Auto(String marke) { super(marke); } } 1 2 3 4 5 6 7 public class Main { public static void main(String[] args) { Fahrzeug ferrari = new Auto(\"Ferrari\"); Fahrzeug any = new Auto(); } } Hier gelten die gleichen Regeln wie beim Beispiel 2. Der einzige Unterschied besteht nun darin, dass die Klasse Auto ebenfalls beide Konstruktoren besitzen muss.\nDer geübte Entwickler behält also stets die Konstruktoren der Superklasse im Auge. Sie werden immer vor den Konstruktoren der Subklasse aufgerufen. Dies ist auch der Grund, weshalb der Aufruf des Super-Konstruktors immer als erstes Statement in einem Subklassen-Konstruktor aufgeführt werden muss.\nBeziehungen In Java gibt es vier Grundtypen von Beziehungen, welche Objekte miteinander bilden können. Diese sind:\nGeneralisierung und Spezialisierung (IS-A Beziehung) Aggregation und Komposition (HAS-A Beziehung) Assoziationen (KNOWS-A Beziehung) Abhängigkeit (USES Beziehung) Generalisierung und Spezialisierung (IS-A Beziehung) Die IS-A Beziehung beschreibt, wovon sich ein Objekt ableitet. Dies gilt für Basisklassen, abstrakte Klassen und Interfaces. Je genereller eine Funktion oder Beschreibung ist, desto höher ist sie stets in der Klassenhierarchie. Weiter unten in der Hierarchie sind also die spezialisierten Dinge anzutreffen.\nDarstellung der Generalisierung mit UML:\n1 2 3 4 5 6 7 public class Fahrzeug { //... } public class Auto extends Fahrzeug { //... } Bei der Implementation eines Interfaces mit UML wird die folgende Darstellung verwendet (Interfaces werden weiter unten erklärt):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // Interface Flyable interface Flyable { void fly(); // Methode zum Fliegen, die implementiert werden muss } // Oberklasse Bird class Bird { // Leere Klasse Bird, kann später Attribute und Methoden haben } // Unterklasse Crow, die von Bird erbt und das Flyable-Interface implementiert class Crow extends Bird implements Flyable { // Implementierung der Methode aus dem Flyable-Interface @Override public void fly() { System.out.println(\"Die Krähe fliegt!\"); } } Aggregation und Komposition (HAS-A Beziehung) Die HAS-A Beziehung beschreibt, woraus sich ein Objekt zusammensetzt. Ein Objekt kann selbstverständlich beliebig viele andere Objekte aufnehmen. Die aufgenommenen Objekte sind dabei Bestandteile des Hauptobjekts.\nEin einfaches Beispiel wäre, dass ein Auto (normalerweise) einen Motor hat.\n1 2 3 public class Motor { } 1 2 3 4 public class Auto { private Motor motor; } Die Umsetzung beider Beziehungen wird durch Instanzvariablen abgebildet, welche die entsprechenden Objekte aufnehmen. Ist bei einer Aggregation das verbundene Objekt nicht vorhanden, so wird der Instanzvariable der Wert null zugewiesen. Wenn die Beziehung zwischen den Objekten mehrfach (1 zu n) vorhanden ist, so kann dafür ein Array oder auch eine Liste verwendet werden.\nBei dieser Beziehung wird zwischen Aggregation und Komposition unterschieden.\nAggregation Die Aggregation ist\nstärker als eine Assoziation (siehe weiter unten), aber schwächer als eine Komposition. eine Beziehung der Art “besitzt ein/e”. in ihrer Lebensdauer nicht an die Lebensdauer des Ganzen gebunden. Beispiel 1: “Eine Taskforce hat Experten und -innen”. Das bedeutet, dass es die Experten und -innen immer noch gibt, wenn die Taskforce aufgelöst wird. Beispiel 2: “Ein Auto hat einen Fahrer oder eine Fahrerin”. Die Existenz des Fahrers / der Fahrerin ist nicht an die Existenz des Autos gebunden.\nDarstellung der Aggregation mit UML:\nIn der Aggregation kann das zugeordnete Objekt unabhängig existieren. Es wird also nicht vollständig vom “Besitzer” (Container-Objekt) kontrolliert.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // Aggregation: Ein Auto hat einen Fahrer, aber der Fahrer kann auch ohne Auto existieren class Fahrer { String name; public Fahrer(String name) { this.name = name; } } class Auto { private Fahrer fahrer; // Aggregation: Auto hat einen Fahrer public Auto(Fahrer fahrer) { this.fahrer = fahrer; } } Hier kann der Fahrer unabhängig vom Auto existieren, was die lose Beziehung der Aggregation verdeutlicht.\nKomposition Die Komposition ist\neine sehr starke Beziehung. eine Beziehung der Art “ist ein Teil von” / “besteht aus”. in ihrer Lebensdauer an die Lebensdauer des Ganzen gebunden. Beispiel 1: “Ein Labyrinth hat Wände.” Eine Wand kann nur als Teil eines Labyrinths existieren. Beispiel 2: “Ein Mensch hat ein Herz.” Ein Mensch kann ohne Herz nicht existieren.\nDarstellung der Komposition in UML:\nIn der Komposition existiert das “Teil”-Objekt nur im Kontext des “Ganzen”. Es kann nicht unabhängig existieren.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // Komposition: Ein Haus besteht aus Räumen, die nur im Haus existieren class Raum { private String name; public Raum(String name) { this.name = name; } } class Haus { private Raum raum; // Komposition: Haus besitzt Raum, und dieser existiert nur innerhalb des Hauses public Haus() { this.raum = new Raum(\"Wohnzimmer\"); } } Hier ist Raum vollständig in Haus eingebettet, und ohne das Haus gäbe es den Raum nicht, was die Komposition darstellt. Die Instanz von Raum wird direkt im Haus erstellt und existiert ausserhalb nicht.\nAssoziation (KNOWS-A Beziehung) Wir haben bereits zwei Formen von Assoziationen kennengelernt: Aggregation \u0026 Komposition. Wenn von einer Assoziation die Rede ist, so sind damit Objekte gemeint, welche miteinander auf irgendeine Weise in Beziehung stehen. Die Komposition ist die stärkste Form der Assoziation, die Aggregation ist etwas abgeschwächt und die Assoziation selbst ist die schwächste Beziehung. Der Begriff Assoziation ist hier etwas verwirrend, weil er gleichzeitig als Oberbegriff und als Verbindung benutzt wird.\nEine Assoziation ist\neine Beziehung der Art “benutzt ein/e”, “ist zugeordnet zu”, “hat eine Beziehung zu”. auch unter der Bezeichnung KNOWS-A bekannt. Beispiel: “Eine Musikerin spielt ein Instrument.” Sie “kennt” das Instrument, das sie spielt.\nDarstellung der Assoziation in UML:\nDie Assoziation beschreibt eine lose Beziehung zwischen Objekten, die miteinander “wissen” oder \" kennen\".\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // Assoziation: Ein Musiker kennt das Instrument, das er spielt class Instrument { private String name; public Instrument(String name) { this.name = name; } public String getName() { return name; } } class Musiker { private Instrument instrument; // Assoziation: Musiker kennt ein Instrument public Musiker(Instrument instrument) { this.instrument = instrument; } public void spielen() { System.out.println(\"Der Musiker spielt \" + instrument.getName()); } } Der Musiker kennt das Instrument, das er spielt, was die lose Assoziation verdeutlicht.\nGerichtete Assoziation Eine gerichtete Assoziation ist eine Verbindung zwischen zwei Klassen, bei der die Beziehung eine klare Richtung hat.\nBeispiel: Du hast zwei Klassen: Kunde und Bestellung. Es besteht eine gerichtete Assoziation von Kunde zu Bestellung. Das bedeutet, dass der Kunde eine oder mehrere Bestellungen kennt, Bestellung weiss aber nichts über den Kunden.\nEine gerichtete Assoziation zeigt eine Richtung in der Beziehung zwischen zwei Objekten.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // Gerichtete Assoziation: Kunde kennt Bestellungen, aber Bestellungen kennen den Kunden nicht class Bestellung { private String beschreibung; public Bestellung(String beschreibung) { this.beschreibung = beschreibung; } public String getBeschreibung() { return beschreibung; } } class Kunde { private Bestellung bestellung; // Kunde kennt eine Bestellung public Kunde(Bestellung bestellung) { this.bestellung = bestellung; } public void anzeigen() { System.out.println(\"Kunde hat Bestellung: \" + bestellung.getBeschreibung()); } } Hier “kennt” der Kunde die Bestellung, aber die Bestellung weiss nichts vom Kunden.\nAbhängigkeit (USES Beziehung) Eine Abhängigkeit ist\neine gerichtete Beziehung zwischen einem abhängigen (Client) und einem unabhängigen Element ( Supplier). eine Beziehung, wo die eine Klasse die andere zum Funktionieren braucht. schwächer als eine Assoziation. möglich, ohne ein Objekt der Abhängigkeit dauerhaft zu speichern. Die abhängige Klasse hat keine Instanzvariable vom Typ der unabhängigen Klasse. Es werden nur Parameter vom Typ der unabhängigen Klasse verwendet. Es ist auch möglich, eine Abhängigkeit ohne Objekte zu erstellen, zum Beispiel mit statischen Methoden.\nDarstellung der Abhängigkeit in UML:\nEine Abhängigkeit zeigt, dass eine Klasse eine andere zum Funktionieren benötigt, aber nicht dauerhaft hält.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Abhängigkeit: Eine Klasse benutzt eine andere Klasse temporär, z.B. in einer Methode class Drucker { public void drucken(String dokument) { System.out.println(\"Druckt Dokument: \" + dokument); } } class Benutzer { public void benutzeDrucker(Drucker drucker) { drucker.drucken(\"Mein Bericht\"); } } In diesem Beispiel benötigt der Benutzer einen Drucker, um ein Dokument zu drucken, aber es gibt keine dauerhafte Beziehung, nur eine temporäre Verwendung. Es gibt also keine Instanzvariable des Typs Drucker in Benutzer, sondern nur eine Methode mit einem Parameter drucker, welcher nur temporär existiert.\nPolymorphismus Polymorphie bedeutet “Vielgestaltigkeit”. Die Polymorphie beschreibt ein Konzept der objektorientierten Programmierung, wobei der Aufruf einer Methode mit identischer Signatur unterschiedliche Ergebnisse liefern kann. Dieses Verhalten ist vorallem bei der Vererbung anzutreffen. In Java sind alle Objekte polymorph, da jedes Objekt eine IS-A Beziehung für seinen eigenen Typ und für die Klasse Object besitzt (alle Klassen erben von Object, Everything is an Object).\nEine Referenzvariable kann auf jedes Objekt ihres deklarierten Typs oder auf jeden Subtyp ihres deklarierten Typs verweisen.\nBeispiel:\n1 2 3 4 5 6 class Animal { public void move() { System.out.println(\"Animals can move\"); } } 1 2 3 4 5 6 class Dog extends Animal { public void move() { System.out.println(\"Dogs can walk and run\"); } } 1 2 3 4 5 6 7 8 9 10 public class Main { public static void main(String args[]) { Animal animal = new Animal(); Animal dog = new Dog(); animal.move(); dog.move(); } } Die Ausgabe ist wie folgt:\nAnimals can move Dogs can walk and run In diesem Beispiel ist erkennbar, dass die Referenz dog (obwohl es sich um ein Animal handelt), die Methode move() der Klasse Dog ausführt. Der Grund dafür ist, dass während der Kompilierung der Referenztyp überprüft wird. Zur Laufzeit ermittelt die JVM jedoch das Objekt und führt die Methode aus, die zu der Klasse dieses Objekts gehört.\nOverriding Beim Überschreiben von Methoden wird eine Methode der Superklasse in einer Subklasse neu definiert. Eine Subklasse kann dadurch das Verhalten einer Methode der Superklasse anders spezifizieren. Das Überschreiben hat den Vorteil, dass ein Verhalten definiert werden kann, das für den Typ der Subklasse spezifisch ist. Die überschreibende Methode muss dieselbe Signatur (Methodenname; Anzahl, Typ und Reihenfolge der Parameter) aufweisen. Die zu überschreibende Methode darf nicht final sein.\nBeispiel:\n1 2 3 4 5 6 public class Shape { public double getArea() { return 0; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Rectangle extends Shape { private double width; private double height; public Rectangle(double width, double height) { this.width = width; this.height = height; } @Override public double getArea() { return width * height; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 public class Circle extends Shape { private double radius; public Circle(double radius) { this.radius = radius; } @Override public double getArea() { return Math.pow(this.radius, 2.0) * Math.PI; } } 1 2 3 4 5 6 7 8 9 10 public class Main { public static void main(String[] args) { Shape rectangle = new Rectangle(10.0, 5.0); Shape circle = new Circle(4.0); System.out.println(\"Area of the rectangle: \" + rectangle.getArea()); System.out.println(\"Area of the circle \" + circle.getArea()); } } Die Ausgaben sind nicht verwunderlich. Da es sich um Objekte des Typs Rectangle und Circle handelt, werden jeweils die überschriebenen Methoden aufgerufen. Wenn eine Subklasse ein bestimmte Methode nicht überschreibt, so wird die Methode der nächsthöheren Klasse (in diesem Falle der Klasse Shape) verwendet.\n@Override Die Annotation @Override weist den Compiler an, die Signatur der überschreibenden Methode zu überprüfen. Die Annotation ist optional, hilft aber in einfacher Weise Fehler beim Überschreiben zu verhindern. Wenn eine mit @Override gekennzeichnete Methode die Methode der Superklasse nicht korrekt überschreibt, generiert der Compiler einen Fehler.\nAbstraktion In der objektorientierten Programmierung bezieht sich Abstraktion darauf, dem Benutzer Funktionalität bereitzustellen, ohne die Details der Implementierung preiszugeben. Es ist also bekannt, was ein Objekt tun kann, aber nicht wie die Funktionalität genau umgesetzt ist. In Java wird Abstraktion mit Hilfe von abstrakten Klassen und Interfaces erreicht.\nAbstrakte Klassen Eine Klasse, die das Schlüsselwort abstract in ihrer Deklaration enthält, wird als abstrakte Klasse bezeichnet.\nAbstrakte Klassen können beliebig viele abstrakte Methoden enthalten. Eine abstrakte Methode besitzt keinen Block, sie muss in jedem Fall durch eine nicht-abstrakte Methode einer Klasse in der darunterliegenden Hierarchie überschrieben werden. Eine abstrakte Klasse kann nicht instanziert werden, es ist also nicht möglich von einer solchen Klasse ein Objekt zu erstellen. Abstrakte Klassen eignen sich, um gemeinsame Funktionalitäten von Subklassen aufzunehmen. Beispiel:\nEine abstrakte Klasse Animal Eine abstrakte Subklasse Carnivore (Fleischfresser) Eine abstrakte Subklasse Herbivore (Pflanzenfresser) Eine Subklasse Dog Eine Subklasse Cat Eine Subklasse Sheep Eine Subklasse Cow Alle diese Tiere sollen sich bewegen und unterschiedliche Geräusche machen können. Die Methoden move() und sound() bewerkstelligen dies.\n1 2 3 4 5 6 7 8 public abstract class Animal { public void move() { System.out.println(\"Animal is moving\"); } public abstract void sound(); //Die abstrakte Methode sound() hat keinen Body } 1 2 3 public abstract class Carnivore extends Animal { // some carnivore specific stuff } 1 2 3 public abstract class Herbivore extends Animal { // some herbivore specific stuff } 1 2 3 4 5 6 7 public class Dog extends Carnivore { @Override public void sound() { System.out.println(\"Woff Woff...\"); } } 1 2 3 4 5 6 7 public class Cat extends Carnivore { @Override public void sound() { System.out.println(\"Meow Meow...\"); } } 1 2 3 4 5 6 7 public class Sheep extends Herbivore { @Override public void sound() { System.out.println(\"Baa Baa...\"); } } 1 2 3 4 5 6 7 public class Cow extends Herbivore { @Override public void sound() { System.out.println(\"Moo Moo...\"); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Main { public static void main(String args[]) { Animal dog = new Dog(); Animal cat = new Cat(); Animal sheep = new Sheep(); Animal cow = new Cow(); dog.sound(); dog.move(); cat.sound(); cat.move(); sheep.sound(); sheep.move(); cow.sound(); cow.move(); } } Zusammenfassung:\nAlle Tiere können sich bewegen. Als ein gemeinsames Merkmal ist dies in der Klasse Animal implementiert. Fleischfresser und Pflanzenfresser könnten in den jeweiligen Klassen spezifische Implementationen bereitstellen. Alle Tiere machen unterschiedliche Geräusche und aus diesem Grund wird die Methode sound() in der Klasse Animal als abstract deklariert, so dass alle untergeordneten Klassen diese Methode auf ihre eigene Weise implementieren müssen. Eine weitere wichtige Lektion ist die Polymorphie in der Klassenhierarchie. Eine Katze ist gemäss Definition ein Fleischfresser. Das folgende Beispiel soll die mögliche Typenumwandlung erklären.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Main { public static void main(String args[]) { Cat cat = new Cat(); Carnivore carnivoreCat = cat; // Möglich, da eine Katze ein Fleischfresser ist Animal animalCat1 = cat; // Möglich, da eine Katze ein Tier ist Animal animalCat2 = carnivoreCat; // Möglich, da ein Fleischfresser ein Tier ist Animal animalDog = new Dog(); Carnivore carnivoreDog1 = animalDog; // Nicht möglich, da ein Tier kein Fleischfresser ist Carnivore carnivoreDog2 = (Carnivore) animalDog; // Mit Cast-Operator möglich Dog dog1 = animalDog; // Nicht möglich, da ein Tier kein Hund ist Dog dog2 = (Dog) animalDog; // Mit Cast-Operator möglich Dog dog3 = carnivoreDog2; // Nicht möglich, da ein Fleischfresser kein Hund ist Dog dog4 = (Dog) carnivoreDog2; // Mit Cast-Operator möglich } } Wie wir sehen ist die Umwandlung in einen Typ, welche höher in der Klassenhierarchie liegt, stets ohne Cast-Operator möglich. Bei der Umwandlung in einen unterliegenden Typ (Downcasting) muss der Cast-Operator zwingend implementiert werden. Zur Laufzeit kann es beim Downcasting jedoch zu einer ClassCastException kommen, wenn die Referenz kein Objekt des gecasteten Typs ist.\ninstanceof Operator Durch den Einsatz des Operators instanceof kann zur Laufzeit die Referenz eines Objektes auf einen bestimmten Typ überprüft werden.\nBeispiel:\n1 2 3 4 5 6 7 8 9 public class Main { public static void main(String args[]) { Animal dog = new Dog(); if (dog instanceof Dog) { // ... } } } Der Operator überprüft also den Typ einer Instanz und berücksichtigt dabei Subklassen und Interfaces.\nInterfaces Ein Interface dient dem Angebot von Methoden, die durch Klassen zu implementieren sind, welche das Interface “implementieren”. Damit definiert ein Interface einen Satz von bestimmten Funktionen, die allen implementierenden Klassen des Interfaces gleich sind. Ein Interface muss dabei nicht zwingend eine Methode enthalten. Dies ist z.B. der Fall beim Interface Serializable. Dieses sagt lediglich semantisch aus, dass eine Klasse resp. das Objekt davon serialisiert werden kann.\nEine Schnittstelle hat im Unterschied zu einer Klasse weder ein Verhalten noch einen Status – wir können ein Interface als einen Vertrag betrachtet, den eine Klasse erfüllen muss. Ein Interface besitzt anstelle der Klassendefinition das Schlüsselwort interface.\nEin Interface kann die folgenden Dinge enthalten:\nKonstanten, also public static final Variablen, wobei die Schlüsselwörter nicht erforderlich sind. public abstract Methoden, wobei die Schlüsselwörte nicht erforderlich sind. Normale Methoden mit Implementierung (das Schlüsselwort default ist erforderlich) seit Java 8. Statische Methoden mit Implementierung (das Schlüsselwort static ist erforderlich) seit Java 8. Ein Interface darf die folgenden Dinge nicht enthalten:\nInstanzvariablen Konstruktoren Nicht-öffentliche abstrakte Methoden 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public interface Vehicle { double MILES_PER_KM = 1.60934; String getBrand(); String speedUp(); String slowDown(); static double parseToKmh(double mph) { return mph * MILES_PER_KM; } static double parseToMph(double kmh) { return kmh / MILES_PER_KM; } default String turnAlarmOn() { return \"Turning the vehicle alarm on.\"; } default String turnAlarmOff() { return \"Turning the vehicle alarm off.\"; } } Eine Klasse verwendet in ihrer Deklaration das Schlüsselwort implements, um eine Schnittstelle zu implementieren. Ein Interface verwendet jedoch das Schlüsselwort extends, um eine andere Schnittstelle zu erweitern.\nBeispiel:\nEine Basisklasse mit dem Namen Bird Eine Subklasse mit dem Namen Parrot Eine Subklasse mit dem Namen Penguin Ein Interface mit dem Namen Flyable 1 2 3 4 5 6 public class Bird { public void eat() { System.out.println(getClass().getSimpleName() + \" is eating!\"); } } 1 2 3 4 public interface Flyable { void fly(); } 1 2 3 4 5 6 7 public class Parrot extends Bird implements Flyable { @Override public void fly() { System.out.println(\"Parrot is Flying!\"); } } 1 2 3 public class Penguin extends Bird { } Wie wir sehen ist die Klasse Parrot gezwungen den Vertrag mit dem Interface Flyable zu erfüllen. Der Vorteil dieser Implementation wird erst ersichtlich, wenn das Interface beispielsweise als Parameter verwendet wird. Nur Instanzen von Klassen, welche das Interface implementieren, können als Parameter verwendet werden.\n1 2 3 4 5 6 public class Birdhouse { public void arrive(Flyable flyable) { flyable.fly(); } } 1 2 3 4 5 6 7 8 public class Main { public static void main(String[] args) { Flyable parrot = new Parrot(); Birdhouse birdhouse = new Birdhouse(); birdhouse.arrive(parrot); } } Im Beispiel sehen wir, dass durch die Verwendung eines Interfaces die Abhängigkeiten zwischen den Klassen Birdhouse und Parrot vollständig aufgehoben wird. Beide Klassen kennen einander nicht, dies wird Entkopplung genannt. Dem Vogelhaus ist es also egal, welcher Vogel ankommt. Er muss aber fliegen können.\nKomposition vor Vererbung “Komposition vor Vererbung” ist ein Prinzip in der objektorientierten Programmierung (OOP), das empfiehlt, Komposition gegenüber Vererbung zu bevorzugen, um Systeme zu entwerfen. Dieses Prinzip zielt darauf ab, die Einschränkungen der Vererbung zu überwinden und flexibleren sowie wartbareren Code zu ermöglichen.\nLass uns die beiden Konzepte näher betrachten:\nVererbung\nVererbung ist ein Mechanismus, bei dem eine Klasse (die Unterklasse oder abgeleitete Klasse) Attribute und Methoden von einer anderen Klasse (der Oberklasse oder Basisklasse) erbt. Vererbung ermöglicht die Wiederverwendung von Code und stellt Beziehungen wie “ist-ein” (z. B. ein Hund ist ein Säugetier) her.\nDie Vererbung kann jedoch einige Probleme verursachen:\nEnge Kopplung: Unterklassen sind eng mit ihren Oberklassen verbunden, was bedeutet, dass Änderungen in der Oberklasse alle abgeleiteten Klassen beeinflussen können. Starre Hierarchie: Vererbung schafft eine strenge Hierarchie, die oft unflexibel ist. Es wird schwieriger, neue Funktionalitäten hinzuzufügen, ohne bestehende Strukturen zu ändern. Dies kann gegen das Open-Closed-Prinzip (OCP) des SOLID-Designs verstossen. Übernutzung führt zu Zerbrechlichkeit: Zu viel Vererbung kann zu fragilen und schwer wartbaren Codebasen führen. Änderungen in einer Oberklasse können unvorhergesehene Konsequenzen für alle abgeleiteten Klassen haben. Komposition\nKomposition hingegen bezieht sich auf die Praxis, eine Klasse durch den Einsatz anderer Klassen zu \" komponieren\", anstatt Vererbung zu verwenden. Das bedeutet, dass eine Klasse Objekte von anderen Klassen als Instanzvariablen enthält, um Funktionalität wiederzuverwenden. Dies folgt dem “hat-ein” -Prinzip (z. B. ein Auto hat einen Motor).\nVorteile der Komposition:\nFlexibilität: Komposition ermöglicht es, Objekte dynamisch zu kombinieren oder zu ändern, was mehr Flexibilität bei der Strukturierung eines Programms bietet. Geringere Kopplung: Da Klassen nicht voneinander erben, sind sie weniger eng miteinander verbunden. Änderungen in einer Klasse wirken sich nicht auf die andere aus. Erleichtert das Testen: Da Klassen unabhängiger sind, wird das Testen vereinfacht, insbesondere bei der Verwendung von Mock-Objekten oder Stubs. Beispiel\nAnstatt eine Klasse Vogel von einer Klasse Tier zu erben, könnte man eine Klasse Fliegen als Komponente verwenden:\nVererbung:\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Vogel extends Tier { void fliegen() { // Fluglogik } } class Kiwi extends Vogel { @Override void fliegen() { // Der Kiwi kann nicht fliegen, dies muss hier behandelt werden. } } Das Problem hier ist, wenn es ein Vogel gibt, welcher nicht fliegen kann, wie zum Beispiel ein Kiwi. Der Kiwi ist ein Vogel, erbt also von Vogel, kann aber nicht fliegen. Die Methode fliegen() wird aber trotzdem vererbt, was nicht korrekt ist.\nKomposition:\n1 2 3 4 5 6 7 8 9 10 11 12 class Kiwi { private Fliegen flugVerhalten; public Kiwi(Fliegen flugVerhalten) { this.flugVerhalten = flugVerhalten; } void fliegen() { flugVerhalten.fliegen(); } } oder mit Interface\n1 2 3 4 5 6 7 8 9 interface Flyable { void fliegen(); } class Kiwi implements Flyable { void fliegen() { //Implementation } } Mit Komposition könnte man nun verschiedene Flugverhalten einfach austauschen, ohne die Vogelklasse zu ändern, was sie flexibler und wartbarer macht.\nZusammengefasst fördert das Prinzip “Komposition vor Vererbung” eine flexiblere und modularere Softwarearchitektur und hilft dabei, die Nachteile von starrer Vererbung zu vermeiden.\nKapselung Kapselung ist eines der bedeutendsten Konzepte der objektorientierten Programmierung, welches Sicherheit bietet, indem es die sensiblen Daten/Implementierungsdetails einer Klasse vor den Benutzern verbirgt.\nIn Java kann die Kapselung erreicht werden, indem die Klassenattribute/-variablen als privat deklariert werden. Die Klasse stellt dann öffentliche Methoden zur Verfügung, welche von “aussen” ( durch andere Klassen) verwendet werden können, um bestimmte Information zu erhalten oder um bestimmten Operationen, welche auf den Attributen der Klasse basiert sind, ausführen zu können.\nBeispiel\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Student { private final String name; private final String lastName; private final int age; private int index = 0; private final String[] courses = {}; public Student(String name, String lastName, int age) { this.name = name; this.lastName = lastName; this.age = age; } public void enroleCourse(String course) { courses[index++] = course; } @Override public void toString() { System.out.printf(\"Name: %s\\nLastname: %s\\nAge: %d\\n\", name, lastName, age); System.out.println(\"Courses:\"); Arrays.stream(courses).forEach(System.out::println); } } Die Student Klasse beinhaltet vier private Attribute, worauf der Benutzer dieser Klasse keinen Zugriff hat. Die Klasse stellt neben dem Konstruktor lediglich zwei öffentliche Methoden zur Verfügung. Die interne Struktur der Student Klasse bleibt vom Benutzer verborgen. So weiss der Benutzer z.B. nicht, dass die Liste der Courses mit einem Array umgesetzt worden ist. Dies erlaubt eine Strukturänderung innerhalb der Student Klasse, ohne dass der Benutzer etwas davon merkt oder seinen Code ändern muss (die öffentlichen Methoden ändern sich nicht):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class Student { private final String name; private final String lastName; private final int age; private final List\u003cString\u003e courses; // use List instead of Array public Student(String name, String lastName, int age) { this.name = name; this.lastName = lastName; this.age = age; } public void enroleCourse(String course) { courses.add(course); } @Override public void toString() { System.out.printf(\"Name: %s\\nLastname: %s\\nAge: %d\\n\", name, lastName, age); System.out.println(\"Courses:\"); courses.forEach(System.out::println); } } Die Student Klasse erlaubt zusätzlich keinen direkten Zugriff auf ihre Attribute (es gibt keine Getter-Methoden). Die Überlegung hier ist, dass die einzelnen Attribute niemanden ausserhalb der Student Klasse interessieren. Von aussen will man lediglich dem Student einen Kurs zuweisen können und alle Informationen zum Studenten ausgeben.\nDas Befolgen des Kapselung-Prinzips führt zu einem Design, welches folgende Vorteile mit sich bringt:\nDie Attribute und damit der Zustand einer Klasse bzw. eines Objektes sind vor “fremdem” Zugriff geschützt (Data-Hiding). Die Klasse hat eine öffentliche API, welche von Benutzern der Klasse verwendet werden kann. Somit ist auch klar definiert, was die Aufgabe dieser Klasse ist. Die öffentliche API einer Klasse ermöglicht das Verbergen von Umsetzungsdetails. Somit haben interne Strukturänderungen dieser Klasse keinen Einfluss auf den Code des Benutzers. Jetzt bist du dran. Löse bitte die Aufgaben in den Labs.\n","categories":"","description":"Modul #J3\n","excerpt":"Modul #J3\n","ref":"/docs/02_java/07_java-ood/","tags":"","title":"Objektorientiertes Design"},{"body":"Ziele Ich kann die Konzepte der Generalisierung und Spezialisierung im Kontext der Vererbung erklären und anwenden. Ich weiss, wie ich Unterklassen von einer Oberklasse ableiten kann (extends). Ich kann vererbte Methoden und Attribute einer Klasse von lokalen Methoden und Attributen unterscheiden. Ich kann in UML (Unified Modeling Language) die Vererbungsbeziehung zweier Klassen erkennen. Ich weiss, wie ich das Schlüsselwort super nutze, um den Konstruktor der Oberklasse zu verwenden. Ich weiss, wie ich das Schlüsselwort super nutze, um eine Methode aus der Oberklasse aufzurufen. Ich kann das Konzept des “Überschreibens” (Overriding) von Methoden und Attributen erklären, erkennen und nutzen. Ich weiss, was Interfaces sind und wann es angebracht ist, ein Interface zu verwenden. Ich weiss, welche Methoden und Felder in einem Interface vorhanden sind und wie sie geschrieben werden bzw. über welche Eigenschaften sie verfügen. Ich kann eine Klasse schreiben, die ein Interface implementiert. Einführung Beim objektorientierten Design (OOD) handelt es sich um die Modellierung der realen Welt in Klassen und Objekten. In dieser Phase der Softwareentwicklung werden Objekte und Klassen definiert sowie ihre Eigenschaften, Funktionen und die Beziehungen untereinander festgelegt.\nDie wichtigsten Konzepte/Prinzipien des objektorientierten Designs sind:\nVererbung ermöglicht es in Java, eine hierarchische Ordnung für Klassen festzulegen. Dadurch wird die Menge an redundantem Code reduziert. Polymorphismus beschreibt eine Sprachstruktur, bei der Methoden mit derselben Signatur unterschiedlich implementiert werden können und dadurch verschiedene Ergebnisse liefern. Abstraktion ist ein Prinzip, bei dem durch das Weglassen von Details nur die wesentlichen Eigenschaften eines Objekts hervorgehoben werden. Kapselung ermöglicht es, den Zugriff auf die Methoden und Attribute einer Klasse zu kontrollieren und zu schützen. Das Befolgen dieser Konzepte/Prinzipien führt zu einem guten objektorientierten Design und trägt wesentlich zur Qualität der Software bei.\nVererbung Vererbung ist ein Mechanismus zum Ableiten einer neuen Klasse von einer anderen Klasse. Die neue Klasse erbt alle nicht-privaten Felder und Methoden der Basisklasse. Die Vererbung ist eines der Hauptkonzepte der objektorientierten Programmierung.\nAls Beispiel dient uns die Klasse Auto, welche von der Klasse Fahrzeug abgeleitet ist. Die Beziehung zwischen den Klassen wird als IS-A Beziehung bezeichnet. Wir würden also logischerweise sagen, dass ein Auto ein Fahrzeug ist. Die Klasse Auto wird auch als Spezialisierung der Klasse Fahrzeug bezeichnet. Umgekehrt bezeichnen wir die Klasse Fahrzeug als Generalisierung der Klasse Auto.\nSynonyme für die abgeleitete Klasse sind:\nUnterklasse (Subclass), abgeleitete Klasse (Derived Class), erweiterte Klasse (Extended Class), Kind-Klasse (Child Class). Synonyme für die Klasse, von der abgeleitet wird:\nOberklasse (Superclass), Basisklasse (Base Class), Eltern-Klasse (Parent Class). Der Anwendungsfall der Vererbung kommt also dort zum Tragen, wo es eine IS-A Beziehung zwischen zwei Objekten gibt. Dazu ein paar Beispiele:\nEin Quadrat ist eine geometrische Form. Java ist eine Programmiersprache. Ein Schwert ist eine Klingenwaffe. Eine Klingenwaffe ist eine Waffe. Superklasse Subklasse Geometrische Form Quadrat Programmiersprache Java Klingenwaffe Schwert Waffe Klingenwaffe Es gibt einige wichtige Punkte zur Vererbung in Java:\nIn Java gibt es keine Mehrfachvererbung. Eine Klasse kann immer nur von maximal einer anderen Klasse erben Eine Klassenhierarchie kann beliebig viele Ebenen haben Die Klasse Schwert erbt von der Klasse Klingenwaffe und die Klasse Klingenwaffe erbt von der Klasse Waffe Eine Superklasse kann beliebig viele Subklassen haben Im UML-Diagramm sind die Basisklassen oberhalb der abgeleiteten Klassen abgebildet. Die Klassen werden mit Pfeilen verbunden, wobei die Pfeilrichtung von der abgeleiteten Klasse in Richtung der Basisklasse verläuft. Der Vererbungspfeil hat eine durchgezogene Linie und ein geschlossenes Dreieck als Pfeilspitze.\nEine Subklasse kann beliebig viele neue Felder und Methoden enthalten. Geerbte und neu hinzugefügte Felder und Methoden werden wie bisher gelernt verwendet.\nDas Schlüsselwort extends In Java wird eine Vererbungsbeziehung implementiert, indem wir das Schlüsselwort extends verwenden.\n1 2 3 public class Fahrzeug { } 1 2 3 public class Auto extends Fahrzeug { } Bei der Deklaration eines Autos ist es nun aufgrund der Vererbungsbeziehung möglich, dass wir statt eines Autos ein Fahrzeug verwenden. Dies funktioniert, weil ein Auto ja ein Fahrzeug ist (IS-A).\n1 2 3 4 5 6 public class Main { public static void main(String[] args) { Fahrzeug fahrzeug = new Auto(); } } Das Schlüsselwort final Wenn eine Klasse mit dem Schlüsselwort final versehen wird, dann kann sie keine Subklassen haben. Wir können die Vererbung also verbieten.\n1 2 3 public final class NonDerivableClass { } Viele der Standardklassen von Java sind final. Dazu gehören alle Wrapper-Klassen von primitiven Datentypen wie Integer, Long oder Float und die Klasse String.\nDas Schlüsselwort super Das Schlüsselwort super ähnelt dem Schlüsselwort this. Es erlaubt den direkten Zugriff auf Felder, Konstruktoren und Methoden der Superklasse. Bei gleicher Namensgebung von Feldern oder beim Überschreiben von Methoden ist es teilweise sogar zwingend notwendig.\nUmgang mit Konstruktoren Konstruktoren werden nicht an die Subklasse vererbt. Wenn aber ein neues Objekt einer Subklasse erzeugt werden soll, so kann der Konstruktor der Superklasse nicht einfach ignoriert werden. Beim Erzeugen von Objekten einer Subklasse unterscheiden wir zwischen den folgenden Fällen:\nDie Superklasse hat keinen Konstruktor (das heisst, sie besitzt einen Default-Konstruktor). Die Superklasse hat einen anderen Konstruktor als den Default-Konstruktor. Die Superklasse hat einen anderen Konstruktor und zusätzlich einen Default-Konstruktor. Beispiel 1 - Die Superklasse hat keinen Konstruktor\n1 2 3 public class Fahrzeug { } 1 2 3 public class Auto extends Fahrzeug { } 1 2 3 4 5 6 public class Main { public static void main(String[] args) { Fahrzeug auto = new Auto(); } } Beispiel 2 - Die Superklasse hat einen anderen Konstruktor als den Default-Konstruktor\n1 2 3 4 5 6 7 8 public class Fahrzeug { private String marke; public Fahrzeug(String marke) { this.marke = marke; } } 1 2 3 4 5 6 7 8 9 10 11 12 public class Auto extends Fahrzeug { // Möglichkeit 1 - Konstruktor-Weiterleitung public Auto(String marke) { super(marke); } // Möglichkeit 2 - Fixer Wert public Auto() { super(\"Unbekannt\"); } } 1 2 3 4 5 6 7 8 9 public class Main { public static void main(String[] args) { // Möglichkeit 1 Fahrzeug ferrari = new Auto(\"Ferrari\"); // Möglichkeit 2 Fahrzeug any = new Auto(); } } Für die Erzegung eines Fahrzeugs ist nun eine Marke notwendig. Dies bedeutet automatisch, dass die Erzeugung eines Autos auch einen Wert für diese Marke besitzen muss. Der Wert kann entweder über einen weiteren Konstruktor in der Klasse Auto in das Fahrzeug gelangen oder man wählt - wie im Beispiel gezeigt - einen fixen Wert. Die Erzeugung eines neuen Autos ohne einen Wert für die Marke ist aber nicht möglich, da die Superklasse einen Wert verlangt.\nBeispiel 3 - Die Superklasse hat einen anderen Konstruktor und zusätzlich einen Default-Konstruktor\n1 2 3 4 5 6 7 8 9 10 11 12 public class Fahrzeug { private String marke; public Fahrzeug() { this.marke = \"Unbekannt\"; } public Fahrzeug(String marke) { this.marke = marke; } } 1 2 3 4 5 6 7 8 9 10 public class Auto extends Fahrzeug { public Auto() { super(); } public Auto(String marke) { super(marke); } } 1 2 3 4 5 6 7 public class Main { public static void main(String[] args) { Fahrzeug ferrari = new Auto(\"Ferrari\"); Fahrzeug any = new Auto(); } } Hier gelten die gleichen Regeln wie beim Beispiel 2. Der einzige Unterschied besteht nun darin, dass die Klasse Auto ebenfalls beide Konstruktoren besitzen muss.\nDer geübte Entwickler behält also stets die Konstruktoren der Superklasse im Auge. Sie werden immer vor den Konstruktoren der Subklasse aufgerufen. Dies ist auch der Grund, weshalb der Aufruf des Super-Konstruktors immer als erstes Statement in einem Subklassen-Konstruktor aufgeführt werden muss.\nBeziehungen In Java gibt es vier Grundtypen von Beziehungen, welche Objekte miteinander bilden können. Diese sind:\nGeneralisierung und Spezialisierung (IS-A Beziehung) Aggregation und Komposition (HAS-A Beziehung) Assoziationen (KNOWS-A Beziehung) Abhängigkeit (USES Beziehung) Generalisierung und Spezialisierung (IS-A Beziehung) Die IS-A Beziehung beschreibt, wovon sich ein Objekt ableitet. Dies gilt für Basisklassen, abstrakte Klassen und Interfaces. Je genereller eine Funktion oder Beschreibung ist, desto höher ist sie stets in der Klassenhierarchie. Weiter unten in der Hierarchie sind also die spezialisierten Dinge anzutreffen.\nDarstellung der Generalisierung mit UML:\n1 2 3 4 5 6 7 public class Fahrzeug { //... } public class Auto extends Fahrzeug { //... } Bei der Implementation eines Interfaces mit UML wird die folgende Darstellung verwendet (Interfaces werden weiter unten erklärt):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // Interface Flyable interface Flyable { void fly(); // Methode zum Fliegen, die implementiert werden muss } // Oberklasse Bird class Bird { // Leere Klasse Bird, kann später Attribute und Methoden haben } // Unterklasse Crow, die von Bird erbt und das Flyable-Interface implementiert class Crow extends Bird implements Flyable { // Implementierung der Methode aus dem Flyable-Interface @Override public void fly() { System.out.println(\"Die Krähe fliegt!\"); } } Aggregation und Komposition (HAS-A Beziehung) Die HAS-A Beziehung beschreibt, woraus sich ein Objekt zusammensetzt. Ein Objekt kann selbstverständlich beliebig viele andere Objekte aufnehmen. Die aufgenommenen Objekte sind dabei Bestandteile des Hauptobjekts.\nEin einfaches Beispiel wäre, dass ein Auto (normalerweise) einen Motor hat.\n1 2 3 public class Motor { } 1 2 3 4 public class Auto { private Motor motor; } Die Umsetzung beider Beziehungen wird durch Instanzvariablen abgebildet, welche die entsprechenden Objekte aufnehmen. Ist bei einer Aggregation das verbundene Objekt nicht vorhanden, so wird der Instanzvariable der Wert null zugewiesen. Wenn die Beziehung zwischen den Objekten mehrfach (1 zu n) vorhanden ist, so kann dafür ein Array oder auch eine Liste verwendet werden.\nBei dieser Beziehung wird zwischen Aggregation und Komposition unterschieden.\nAggregation Die Aggregation ist\nstärker als eine Assoziation (siehe weiter unten), aber schwächer als eine Komposition. eine Beziehung der Art “besitzt ein/e”. in ihrer Lebensdauer nicht an die Lebensdauer des Ganzen gebunden. Beispiel 1: “Eine Taskforce hat Experten und -innen”. Das bedeutet, dass es die Experten und -innen immer noch gibt, wenn die Taskforce aufgelöst wird. Beispiel 2: “Ein Auto hat einen Fahrer oder eine Fahrerin”. Die Existenz des Fahrers / der Fahrerin ist nicht an die Existenz des Autos gebunden.\nDarstellung der Aggregation mit UML:\nIn der Aggregation kann das zugeordnete Objekt unabhängig existieren. Es wird also nicht vollständig vom “Besitzer” (Container-Objekt) kontrolliert.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // Aggregation: Ein Auto hat einen Fahrer, aber der Fahrer kann auch ohne Auto existieren class Fahrer { String name; public Fahrer(String name) { this.name = name; } } class Auto { private Fahrer fahrer; // Aggregation: Auto hat einen Fahrer public Auto(Fahrer fahrer) { this.fahrer = fahrer; } } Hier kann der Fahrer unabhängig vom Auto existieren, was die lose Beziehung der Aggregation verdeutlicht.\nKomposition Die Komposition ist\neine sehr starke Beziehung. eine Beziehung der Art “ist ein Teil von” / “besteht aus”. in ihrer Lebensdauer an die Lebensdauer des Ganzen gebunden. Beispiel 1: “Ein Labyrinth hat Wände.” Eine Wand kann nur als Teil eines Labyrinths existieren. Beispiel 2: “Ein Mensch hat ein Herz.” Ein Mensch kann ohne Herz nicht existieren.\nDarstellung der Komposition in UML:\nIn der Komposition existiert das “Teil”-Objekt nur im Kontext des “Ganzen”. Es kann nicht unabhängig existieren.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // Komposition: Ein Haus besteht aus Räumen, die nur im Haus existieren class Raum { private String name; public Raum(String name) { this.name = name; } } class Haus { private Raum raum; // Komposition: Haus besitzt Raum, und dieser existiert nur innerhalb des Hauses public Haus() { this.raum = new Raum(\"Wohnzimmer\"); } } Hier ist Raum vollständig in Haus eingebettet, und ohne das Haus gäbe es den Raum nicht, was die Komposition darstellt. Die Instanz von Raum wird direkt im Haus erstellt und existiert ausserhalb nicht.\nAssoziation (KNOWS-A Beziehung) Wir haben bereits zwei Formen von Assoziationen kennengelernt: Aggregation \u0026 Komposition. Wenn von einer Assoziation die Rede ist, so sind damit Objekte gemeint, welche miteinander auf irgendeine Weise in Beziehung stehen. Die Komposition ist die stärkste Form der Assoziation, die Aggregation ist etwas abgeschwächt und die Assoziation selbst ist die schwächste Beziehung. Der Begriff Assoziation ist hier etwas verwirrend, weil er gleichzeitig als Oberbegriff und als Verbindung benutzt wird.\nEine Assoziation ist\neine Beziehung der Art “benutzt ein/e”, “ist zugeordnet zu”, “hat eine Beziehung zu”. auch unter der Bezeichnung KNOWS-A bekannt. Beispiel: “Eine Musikerin spielt ein Instrument.” Sie “kennt” das Instrument, das sie spielt.\nDarstellung der Assoziation in UML:\nDie Assoziation beschreibt eine lose Beziehung zwischen Objekten, die miteinander “wissen” oder \" kennen\".\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // Assoziation: Ein Musiker kennt das Instrument, das er spielt class Instrument { private String name; public Instrument(String name) { this.name = name; } public String getName() { return name; } } class Musiker { private Instrument instrument; // Assoziation: Musiker kennt ein Instrument public Musiker(Instrument instrument) { this.instrument = instrument; } public void spielen() { System.out.println(\"Der Musiker spielt \" + instrument.getName()); } } Der Musiker kennt das Instrument, das er spielt, was die lose Assoziation verdeutlicht.\nGerichtete Assoziation Eine gerichtete Assoziation ist eine Verbindung zwischen zwei Klassen, bei der die Beziehung eine klare Richtung hat.\nBeispiel: Du hast zwei Klassen: Kunde und Bestellung. Es besteht eine gerichtete Assoziation von Kunde zu Bestellung. Das bedeutet, dass der Kunde eine oder mehrere Bestellungen kennt, Bestellung weiss aber nichts über den Kunden.\nEine gerichtete Assoziation zeigt eine Richtung in der Beziehung zwischen zwei Objekten.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // Gerichtete Assoziation: Kunde kennt Bestellungen, aber Bestellungen kennen den Kunden nicht class Bestellung { private String beschreibung; public Bestellung(String beschreibung) { this.beschreibung = beschreibung; } public String getBeschreibung() { return beschreibung; } } class Kunde { private Bestellung bestellung; // Kunde kennt eine Bestellung public Kunde(Bestellung bestellung) { this.bestellung = bestellung; } public void anzeigen() { System.out.println(\"Kunde hat Bestellung: \" + bestellung.getBeschreibung()); } } Hier “kennt” der Kunde die Bestellung, aber die Bestellung weiss nichts vom Kunden.\nAbhängigkeit (USES Beziehung) Eine Abhängigkeit ist\neine gerichtete Beziehung zwischen einem abhängigen (Client) und einem unabhängigen Element ( Supplier). eine Beziehung, wo die eine Klasse die andere zum Funktionieren braucht. schwächer als eine Assoziation. möglich, ohne ein Objekt der Abhängigkeit dauerhaft zu speichern. Die abhängige Klasse hat keine Instanzvariable vom Typ der unabhängigen Klasse. Es werden nur Parameter vom Typ der unabhängigen Klasse verwendet. Es ist auch möglich, eine Abhängigkeit ohne Objekte zu erstellen, zum Beispiel mit statischen Methoden.\nDarstellung der Abhängigkeit in UML:\nEine Abhängigkeit zeigt, dass eine Klasse eine andere zum Funktionieren benötigt, aber nicht dauerhaft hält.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Abhängigkeit: Eine Klasse benutzt eine andere Klasse temporär, z.B. in einer Methode class Drucker { public void drucken(String dokument) { System.out.println(\"Druckt Dokument: \" + dokument); } } class Benutzer { public void benutzeDrucker(Drucker drucker) { drucker.drucken(\"Mein Bericht\"); } } In diesem Beispiel benötigt der Benutzer einen Drucker, um ein Dokument zu drucken, aber es gibt keine dauerhafte Beziehung, nur eine temporäre Verwendung. Es gibt also keine Instanzvariable des Typs Drucker in Benutzer, sondern nur eine Methode mit einem Parameter drucker, welcher nur temporär existiert.\nPolymorphismus Polymorphie bedeutet “Vielgestaltigkeit”. Die Polymorphie beschreibt ein Konzept der objektorientierten Programmierung, wobei der Aufruf einer Methode mit identischer Signatur unterschiedliche Ergebnisse liefern kann. Dieses Verhalten ist vorallem bei der Vererbung anzutreffen. In Java sind alle Objekte polymorph, da jedes Objekt eine IS-A Beziehung für seinen eigenen Typ und für die Klasse Object besitzt (alle Klassen erben von Object, Everything is an Object).\nEine Referenzvariable kann auf jedes Objekt ihres deklarierten Typs oder auf jeden Subtyp ihres deklarierten Typs verweisen.\nBeispiel:\n1 2 3 4 5 6 class Animal { public void move() { System.out.println(\"Animals can move\"); } } 1 2 3 4 5 6 class Dog extends Animal { public void move() { System.out.println(\"Dogs can walk and run\"); } } 1 2 3 4 5 6 7 8 9 10 public class Main { public static void main(String args[]) { Animal animal = new Animal(); Animal dog = new Dog(); animal.move(); dog.move(); } } Die Ausgabe ist wie folgt:\nAnimals can move Dogs can walk and run In diesem Beispiel ist erkennbar, dass die Referenz dog (obwohl es sich um ein Animal handelt), die Methode move() der Klasse Dog ausführt. Der Grund dafür ist, dass während der Kompilierung der Referenztyp überprüft wird. Zur Laufzeit ermittelt die JVM jedoch das Objekt und führt die Methode aus, die zu der Klasse dieses Objekts gehört.\nOverriding Beim Überschreiben von Methoden wird eine Methode der Superklasse in einer Subklasse neu definiert. Eine Subklasse kann dadurch das Verhalten einer Methode der Superklasse anders spezifizieren. Das Überschreiben hat den Vorteil, dass ein Verhalten definiert werden kann, das für den Typ der Subklasse spezifisch ist. Die überschreibende Methode muss dieselbe Signatur (Methodenname; Anzahl, Typ und Reihenfolge der Parameter) aufweisen. Die zu überschreibende Methode darf nicht final sein.\nBeispiel:\n1 2 3 4 5 6 public class Shape { public double getArea() { return 0; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Rectangle extends Shape { private double width; private double height; public Rectangle(double width, double height) { this.width = width; this.height = height; } @Override public double getArea() { return width * height; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 public class Circle extends Shape { private double radius; public Circle(double radius) { this.radius = radius; } @Override public double getArea() { return Math.pow(this.radius, 2.0) * Math.PI; } } 1 2 3 4 5 6 7 8 9 10 public class Main { public static void main(String[] args) { Shape rectangle = new Rectangle(10.0, 5.0); Shape circle = new Circle(4.0); System.out.println(\"Area of the rectangle: \" + rectangle.getArea()); System.out.println(\"Area of the circle \" + circle.getArea()); } } Die Ausgaben sind nicht verwunderlich. Da es sich um Objekte des Typs Rectangle und Circle handelt, werden jeweils die überschriebenen Methoden aufgerufen. Wenn eine Subklasse ein bestimmte Methode nicht überschreibt, so wird die Methode der nächsthöheren Klasse (in diesem Falle der Klasse Shape) verwendet.\n@Override Die Annotation @Override weist den Compiler an, die Signatur der überschreibenden Methode zu überprüfen. Die Annotation ist optional, hilft aber in einfacher Weise Fehler beim Überschreiben zu verhindern. Wenn eine mit @Override gekennzeichnete Methode die Methode der Superklasse nicht korrekt überschreibt, generiert der Compiler einen Fehler.\nAbstraktion In der objektorientierten Programmierung bezieht sich Abstraktion darauf, dem Benutzer Funktionalität bereitzustellen, ohne die Details der Implementierung preiszugeben. Es ist also bekannt, was ein Objekt tun kann, aber nicht wie die Funktionalität genau umgesetzt ist. In Java wird Abstraktion mit Hilfe von abstrakten Klassen und Interfaces erreicht.\nAbstrakte Klassen Eine Klasse, die das Schlüsselwort abstract in ihrer Deklaration enthält, wird als abstrakte Klasse bezeichnet.\nAbstrakte Klassen können beliebig viele abstrakte Methoden enthalten. Eine abstrakte Methode besitzt keinen Block, sie muss in jedem Fall durch eine nicht-abstrakte Methode einer Klasse in der darunterliegenden Hierarchie überschrieben werden. Eine abstrakte Klasse kann nicht instanziert werden, es ist also nicht möglich von einer solchen Klasse ein Objekt zu erstellen. Abstrakte Klassen eignen sich, um gemeinsame Funktionalitäten von Subklassen aufzunehmen. Beispiel:\nEine abstrakte Klasse Animal Eine abstrakte Subklasse Carnivore (Fleischfresser) Eine abstrakte Subklasse Herbivore (Pflanzenfresser) Eine Subklasse Dog Eine Subklasse Cat Eine Subklasse Sheep Eine Subklasse Cow Alle diese Tiere sollen sich bewegen und unterschiedliche Geräusche machen können. Die Methoden move() und sound() bewerkstelligen dies.\n1 2 3 4 5 6 7 8 public abstract class Animal { public void move() { System.out.println(\"Animal is moving\"); } public abstract void sound(); //Die abstrakte Methode sound() hat keinen Body } 1 2 3 public abstract class Carnivore extends Animal { // some carnivore specific stuff } 1 2 3 public abstract class Herbivore extends Animal { // some herbivore specific stuff } 1 2 3 4 5 6 7 public class Dog extends Carnivore { @Override public void sound() { System.out.println(\"Woff Woff...\"); } } 1 2 3 4 5 6 7 public class Cat extends Carnivore { @Override public void sound() { System.out.println(\"Meow Meow...\"); } } 1 2 3 4 5 6 7 public class Sheep extends Herbivore { @Override public void sound() { System.out.println(\"Baa Baa...\"); } } 1 2 3 4 5 6 7 public class Cow extends Herbivore { @Override public void sound() { System.out.println(\"Moo Moo...\"); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Main { public static void main(String args[]) { Animal dog = new Dog(); Animal cat = new Cat(); Animal sheep = new Sheep(); Animal cow = new Cow(); dog.sound(); dog.move(); cat.sound(); cat.move(); sheep.sound(); sheep.move(); cow.sound(); cow.move(); } } Zusammenfassung:\nAlle Tiere können sich bewegen. Als ein gemeinsames Merkmal ist dies in der Klasse Animal implementiert. Fleischfresser und Pflanzenfresser könnten in den jeweiligen Klassen spezifische Implementationen bereitstellen. Alle Tiere machen unterschiedliche Geräusche und aus diesem Grund wird die Methode sound() in der Klasse Animal als abstract deklariert, so dass alle untergeordneten Klassen diese Methode auf ihre eigene Weise implementieren müssen. Eine weitere wichtige Lektion ist die Polymorphie in der Klassenhierarchie. Eine Katze ist gemäss Definition ein Fleischfresser. Das folgende Beispiel soll die mögliche Typenumwandlung erklären.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Main { public static void main(String args[]) { Cat cat = new Cat(); Carnivore carnivoreCat = cat; // Möglich, da eine Katze ein Fleischfresser ist Animal animalCat1 = cat; // Möglich, da eine Katze ein Tier ist Animal animalCat2 = carnivoreCat; // Möglich, da ein Fleischfresser ein Tier ist Animal animalDog = new Dog(); Carnivore carnivoreDog1 = animalDog; // Nicht möglich, da ein Tier kein Fleischfresser ist Carnivore carnivoreDog2 = (Carnivore) animalDog; // Mit Cast-Operator möglich Dog dog1 = animalDog; // Nicht möglich, da ein Tier kein Hund ist Dog dog2 = (Dog) animalDog; // Mit Cast-Operator möglich Dog dog3 = carnivoreDog2; // Nicht möglich, da ein Fleischfresser kein Hund ist Dog dog4 = (Dog) carnivoreDog2; // Mit Cast-Operator möglich } } Wie wir sehen ist die Umwandlung in einen Typ, welche höher in der Klassenhierarchie liegt, stets ohne Cast-Operator möglich. Bei der Umwandlung in einen unterliegenden Typ (Downcasting) muss der Cast-Operator zwingend implementiert werden. Zur Laufzeit kann es beim Downcasting jedoch zu einer ClassCastException kommen, wenn die Referenz kein Objekt des gecasteten Typs ist.\ninstanceof Operator Durch den Einsatz des Operators instanceof kann zur Laufzeit die Referenz eines Objektes auf einen bestimmten Typ überprüft werden.\nBeispiel:\n1 2 3 4 5 6 7 8 9 public class Main { public static void main(String args[]) { Animal dog = new Dog(); if (dog instanceof Dog) { // ... } } } Der Operator überprüft also den Typ einer Instanz und berücksichtigt dabei Subklassen und Interfaces.\nInterfaces Ein Interface dient dem Angebot von Methoden, die durch Klassen zu implementieren sind, welche das Interface “implementieren”. Damit definiert ein Interface einen Satz von bestimmten Funktionen, die allen implementierenden Klassen des Interfaces gleich sind. Ein Interface muss dabei nicht zwingend eine Methode enthalten. Dies ist z.B. der Fall beim Interface Serializable. Dieses sagt lediglich semantisch aus, dass eine Klasse resp. das Objekt davon serialisiert werden kann.\nEine Schnittstelle hat im Unterschied zu einer Klasse weder ein Verhalten noch einen Status – wir können ein Interface als einen Vertrag betrachtet, den eine Klasse erfüllen muss. Ein Interface besitzt anstelle der Klassendefinition das Schlüsselwort interface.\nEin Interface kann die folgenden Dinge enthalten:\nKonstanten, also public static final Variablen, wobei die Schlüsselwörter nicht erforderlich sind. public abstract Methoden, wobei die Schlüsselwörte nicht erforderlich sind. Normale Methoden mit Implementierung (das Schlüsselwort default ist erforderlich) seit Java 8. Statische Methoden mit Implementierung (das Schlüsselwort static ist erforderlich) seit Java 8. Ein Interface darf die folgenden Dinge nicht enthalten:\nInstanzvariablen Konstruktoren Nicht-öffentliche abstrakte Methoden 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public interface Vehicle { double MILES_PER_KM = 1.60934; String getBrand(); String speedUp(); String slowDown(); static double parseToKmh(double mph) { return mph * MILES_PER_KM; } static double parseToMph(double kmh) { return kmh / MILES_PER_KM; } default String turnAlarmOn() { return \"Turning the vehicle alarm on.\"; } default String turnAlarmOff() { return \"Turning the vehicle alarm off.\"; } } Eine Klasse verwendet in ihrer Deklaration das Schlüsselwort implements, um eine Schnittstelle zu implementieren. Ein Interface verwendet jedoch das Schlüsselwort extends, um eine andere Schnittstelle zu erweitern.\nBeispiel:\nEine Basisklasse mit dem Namen Bird Eine Subklasse mit dem Namen Parrot Eine Subklasse mit dem Namen Penguin Ein Interface mit dem Namen Flyable 1 2 3 4 5 6 public class Bird { public void eat() { System.out.println(getClass().getSimpleName() + \" is eating!\"); } } 1 2 3 4 public interface Flyable { void fly(); } 1 2 3 4 5 6 7 public class Parrot extends Bird implements Flyable { @Override public void fly() { System.out.println(\"Parrot is Flying!\"); } } 1 2 3 public class Penguin extends Bird { } Wie wir sehen ist die Klasse Parrot gezwungen den Vertrag mit dem Interface Flyable zu erfüllen. Der Vorteil dieser Implementation wird erst ersichtlich, wenn das Interface beispielsweise als Parameter verwendet wird. Nur Instanzen von Klassen, welche das Interface implementieren, können als Parameter verwendet werden.\n1 2 3 4 5 6 public class Birdhouse { public void arrive(Flyable flyable) { flyable.fly(); } } 1 2 3 4 5 6 7 8 public class Main { public static void main(String[] args) { Flyable parrot = new Parrot(); Birdhouse birdhouse = new Birdhouse(); birdhouse.arrive(parrot); } } Im Beispiel sehen wir, dass durch die Verwendung eines Interfaces die Abhängigkeiten zwischen den Klassen Birdhouse und Parrot vollständig aufgehoben wird. Beide Klassen kennen einander nicht, dies wird Entkopplung genannt. Dem Vogelhaus ist es also egal, welcher Vogel ankommt. Er muss aber fliegen können.\nKomposition vor Vererbung “Komposition vor Vererbung” ist ein Prinzip in der objektorientierten Programmierung (OOP), das empfiehlt, Komposition gegenüber Vererbung zu bevorzugen, um Systeme zu entwerfen. Dieses Prinzip zielt darauf ab, die Einschränkungen der Vererbung zu überwinden und flexibleren sowie wartbareren Code zu ermöglichen.\nLass uns die beiden Konzepte näher betrachten:\nVererbung\nVererbung ist ein Mechanismus, bei dem eine Klasse (die Unterklasse oder abgeleitete Klasse) Attribute und Methoden von einer anderen Klasse (der Oberklasse oder Basisklasse) erbt. Vererbung ermöglicht die Wiederverwendung von Code und stellt Beziehungen wie “ist-ein” (z. B. ein Hund ist ein Säugetier) her.\nDie Vererbung kann jedoch einige Probleme verursachen:\nEnge Kopplung: Unterklassen sind eng mit ihren Oberklassen verbunden, was bedeutet, dass Änderungen in der Oberklasse alle abgeleiteten Klassen beeinflussen können. Starre Hierarchie: Vererbung schafft eine strenge Hierarchie, die oft unflexibel ist. Es wird schwieriger, neue Funktionalitäten hinzuzufügen, ohne bestehende Strukturen zu ändern. Dies kann gegen das Open-Closed-Prinzip (OCP) des SOLID-Designs verstossen. Übernutzung führt zu Zerbrechlichkeit: Zu viel Vererbung kann zu fragilen und schwer wartbaren Codebasen führen. Änderungen in einer Oberklasse können unvorhergesehene Konsequenzen für alle abgeleiteten Klassen haben. Komposition\nKomposition hingegen bezieht sich auf die Praxis, eine Klasse durch den Einsatz anderer Klassen zu \" komponieren\", anstatt Vererbung zu verwenden. Das bedeutet, dass eine Klasse Objekte von anderen Klassen als Instanzvariablen enthält, um Funktionalität wiederzuverwenden. Dies folgt dem “hat-ein” -Prinzip (z. B. ein Auto hat einen Motor).\nVorteile der Komposition:\nFlexibilität: Komposition ermöglicht es, Objekte dynamisch zu kombinieren oder zu ändern, was mehr Flexibilität bei der Strukturierung eines Programms bietet. Geringere Kopplung: Da Klassen nicht voneinander erben, sind sie weniger eng miteinander verbunden. Änderungen in einer Klasse wirken sich nicht auf die andere aus. Erleichtert das Testen: Da Klassen unabhängiger sind, wird das Testen vereinfacht, insbesondere bei der Verwendung von Mock-Objekten oder Stubs. Beispiel\nAnstatt eine Klasse Vogel von einer Klasse Tier zu erben, könnte man eine Klasse Fliegen als Komponente verwenden:\nVererbung:\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Vogel extends Tier { void fliegen() { // Fluglogik } } class Kiwi extends Vogel { @Override void fliegen() { // Der Kiwi kann nicht fliegen, dies muss hier behandelt werden. } } Das Problem hier ist, wenn es ein Vogel gibt, welcher nicht fliegen kann, wie zum Beispiel ein Kiwi. Der Kiwi ist ein Vogel, erbt also von Vogel, kann aber nicht fliegen. Die Methode fliegen() wird aber trotzdem vererbt, was nicht korrekt ist.\nKomposition:\n1 2 3 4 5 6 7 8 9 10 11 12 class Kiwi { private Fliegen flugVerhalten; public Kiwi(Fliegen flugVerhalten) { this.flugVerhalten = flugVerhalten; } void fliegen() { flugVerhalten.fliegen(); } } oder mit Interface\n1 2 3 4 5 6 7 8 9 interface Flyable { void fliegen(); } class Kiwi implements Flyable { void fliegen() { //Implementation } } Mit Komposition könnte man nun verschiedene Flugverhalten einfach austauschen, ohne die Vogelklasse zu ändern, was sie flexibler und wartbarer macht.\nZusammengefasst fördert das Prinzip “Komposition vor Vererbung” eine flexiblere und modularere Softwarearchitektur und hilft dabei, die Nachteile von starrer Vererbung zu vermeiden.\nKapselung Kapselung ist eines der bedeutendsten Konzepte der objektorientierten Programmierung, welches Sicherheit bietet, indem es die sensiblen Daten/Implementierungsdetails einer Klasse vor den Benutzern verbirgt.\nIn Java kann die Kapselung erreicht werden, indem die Klassenattribute/-variablen als privat deklariert werden. Die Klasse stellt dann öffentliche Methoden zur Verfügung, welche von “aussen” ( durch andere Klassen) verwendet werden können, um bestimmte Information zu erhalten oder um bestimmten Operationen, welche auf den Attributen der Klasse basiert sind, ausführen zu können.\nBeispiel\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Student { private final String name; private final String lastName; private final int age; private int index = 0; private final String[] courses = {}; public Student(String name, String lastName, int age) { this.name = name; this.lastName = lastName; this.age = age; } public void enroleCourse(String course) { courses[index++] = course; } @Override public void toString() { System.out.printf(\"Name: %s\\nLastname: %s\\nAge: %d\\n\", name, lastName, age); System.out.println(\"Courses:\"); Arrays.stream(courses).forEach(System.out::println); } } Die Student Klasse beinhaltet vier private Attribute, worauf der Benutzer dieser Klasse keinen Zugriff hat. Die Klasse stellt neben dem Konstruktor lediglich zwei öffentliche Methoden zur Verfügung. Die interne Struktur der Student Klasse bleibt vom Benutzer verborgen. So weiss der Benutzer z.B. nicht, dass die Liste der Courses mit einem Array umgesetzt worden ist. Dies erlaubt eine Strukturänderung innerhalb der Student Klasse, ohne dass der Benutzer etwas davon merkt oder seinen Code ändern muss (die öffentlichen Methoden ändern sich nicht):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class Student { private final String name; private final String lastName; private final int age; private final List\u003cString\u003e courses; // use List instead of Array public Student(String name, String lastName, int age) { this.name = name; this.lastName = lastName; this.age = age; } public void enroleCourse(String course) { courses.add(course); } @Override public void toString() { System.out.printf(\"Name: %s\\nLastname: %s\\nAge: %d\\n\", name, lastName, age); System.out.println(\"Courses:\"); courses.forEach(System.out::println); } } Die Student Klasse erlaubt zusätzlich keinen direkten Zugriff auf ihre Attribute (es gibt keine Getter-Methoden). Die Überlegung hier ist, dass die einzelnen Attribute niemanden ausserhalb der Student Klasse interessieren. Von aussen will man lediglich dem Student einen Kurs zuweisen können und alle Informationen zum Studenten ausgeben.\nDas Befolgen des Kapselung-Prinzips führt zu einem Design, welches folgende Vorteile mit sich bringt:\nDie Attribute und damit der Zustand einer Klasse bzw. eines Objektes sind vor “fremdem” Zugriff geschützt (Data-Hiding). Die Klasse hat eine öffentliche API, welche von Benutzern der Klasse verwendet werden kann. Somit ist auch klar definiert, was die Aufgabe dieser Klasse ist. Die öffentliche API einer Klasse ermöglicht das Verbergen von Umsetzungsdetails. Somit haben interne Strukturänderungen dieser Klasse keinen Einfluss auf den Code des Benutzers. Jetzt bist du dran. Löse bitte die Aufgaben in den Labs.\n","categories":"","description":"Modul #J3\n","excerpt":"Modul #J3\n","ref":"/de/docs/02_java/07_java-ood/","tags":"","title":"Objektorientiertes Design"},{"body":" Dieses Kapitel gehört zum Modul #J1 des Ausbildungsplans Ziele Ich weiss, wie man in IntelliJ eine .jar-Datei aus einem Java-Projekt erzeugt. Ich kann eine .jar-Datei lokal speichern und weitergeben. Ich kann ein lokal gespeichertes Package in einem anderen Projekt einbinden und verwenden. ⏱️ Geschätzte Lesezeit: 10 Minuten Warum das wichtig ist Wenn du eigene Hilfsklassen oder Utility-Packages erstellt hast, möchtest du sie vielleicht in mehreren Projekten verwenden – ohne sie jedes Mal neu zu schreiben. Dafür eignet sich das Java-Archivformat (.jar).\nDieses Modul zeigt dir, wie du in IntelliJ IDEA ohne Maven:\nein .jar-Archiv erzeugst es in einem anderen Projekt wieder einbindest Falls du mehr über Java Packages erfahren willst: Java Grundlagen - Java Packages\nSchritt 1: Projekt vorbereiten Stelle sicher, dass dein Projekt eine sinnvolle Package-Struktur hat und die Klassen public sind:\n1 2 3 4 5 6 7 package ch.itninja.util; public class MathUtils { public static int add(int a, int b) { return a + b; } } Schritt 2: .jar-Datei erzeugen Öffne dein Projekt in IntelliJ Gehe auf File → Project Structure (Ctrl+Alt+Shift+S) Unter Artifacts: Klicke auf das + → JAR → From modules with dependencies Wähle dein Hauptmodul und die Hauptklasse (oder „extract to the classes directory“) Setze das Häkchen bei Include in project build Klicke auf Apply und OK Nun kannst du das .jar-File erstellen:\nMenü Build → Build Artifacts… → Build Die Datei findest du im Ordner out/artifacts/... Schritt 3: .jar in neues Projekt einbinden Erstelle ein neues Java-Projekt in IntelliJ Öffne wieder die Project Structure (Ctrl+Alt+Shift+S) Unter Libraries: Klicke auf das + → Java Wähle dein .jar-File aus IntelliJ fügt es dem Projekt hinzu Nun kannst du in deinem Code importieren:\n1 import ch.itninja.util.MathUtils; Und verwenden:\n1 int result = MathUtils.add(3, 5); Weitergabe an andere Du kannst die .jar-Datei einfach:\nper E-Mail, USB-Stick oder Cloudspeicher weitergeben in ein gemeinsames Netzlaufwerk legen Wenn du das .jar regelmässig aktualisierst, empfiehlt sich später ein zentraler Server oder ein Maven-Repository.\nDie .jar-Datei enthält nur die kompilierten .class-Dateien. JavaDoc-Kommentare oder Quellcode sind darin nicht enthalten.\nWenn du willst, kannst du im Artifact auch den Sourcecode oder die JavaDoc einbinden.\n","categories":"","description":"In diesem Modul lernst du, wie du ein eigenes Java-Package in IntelliJ als .jar-Datei exportierst und in einem anderen Projekt ohne Maven verwenden kannst.\n","excerpt":"In diesem Modul lernst du, wie du ein eigenes Java-Package in IntelliJ …","ref":"/docs/99_tools/ide/intellij/07_packages/","tags":"","title":"Packages lokal verwenden"},{"body":"Referenztypen Nebst primitiven Datentypen gibt es Referenzdatentypen. Eine Variable von diesem Typ enthält nicht die Werte selbst (wie eine Variable primitiven Typs), sondern nur einen Verweis (Referenz) auf den Speicherort der Daten. Der Standardwert von Referenzvariablen ist null, welcher besagt, dass die Variable auf kein Objekt verweist.\nEs gibt zwei Unterarten von Referenztypen:\nObjektdatentyp, repräsentiert ein beliebiges Objekt einer Klasse wie z.B. String (wird im nächsten Kapitel präsentiert) Array: Eine Datenstruktur fester Grösse, die dazu dient, mehrere Elemente des gleichen Typs zu speichern (wird später im Kapitel Arrays behandelt) ","categories":"","description":"Modul #J1\n","excerpt":"Modul #J1\n","ref":"/de/docs/02_java/03_java-grundlagen/07_reference_types/","tags":"","title":"Referenztypen"},{"body":"Ziele Du lernst, wie man .env-Dateien mit dotenv in Node.js verwendet. Du schützt deine Zugangsdaten vor versehentlicher Veröffentlichung. Du testest den Zugriff auf Variablen im TypeScript-Code. ⏱️ Geschätzte Lesezeit: 10 Minuten Geheimnisse in einem Typescript-Projekt schützen Die nachfolgende Anleitung soll dir helfen, Geheimnisse zu schützen, welche dein Projekt benötigt (z.B. Passwort für Datenbank-Zugriff).\nSchritt 1: .env-Datei erstellen 1 GOOGLE_API_KEY=dein_api_key In .gitignore eintragen:\n1 .env Schritt 2: dotenv installieren 1 npm install dotenv Schritt 3: Zugriff im Code 1 2 3 4 5 6 7 8 9 import * as dotenv from \"dotenv\"; dotenv.config(); const apiKey = process.env.GOOGLE_API_KEY; if (!apiKey) { throw new Error( \"API key not set. Please check your .env file or environment variables.\", ); } Schritt 4: .env.template bereitstellen 1 2 3 4 # This file contains the required environment variables! To use it, rename it to '.env'. # Never commit your real .env file with secrets! GOOGLE_API_KEY=PLACEHOLDER Hinweise zu CI/CD In GitHub Actions kannst du die Werte in den Secrets speichern:\n1 2 env: GOOGLE_API_KEY: ${{ secrets.GOOGLE_API_KEY }} In GitLab CI via Settings → CI/CD → Variables eintragen.\nEmpfehlung Verwende dotenv in Kombination mit einem .env.template, um deinen Code sicher und teamfähig zu gestalten.\n","categories":"","description":"Zugriff auf API-Schlüssel in einem TypeScript-Projekt mit dotenv\n","excerpt":"Zugriff auf API-Schlüssel in einem TypeScript-Projekt mit dotenv\n","ref":"/docs/99_tools/ide/intellij/05_secrets/02_secrets-in-typescript/","tags":"","title":"Secrets im Node.js Projekt"},{"body":"Ziele Ich weiss was Spring Boot ist und wofür es verwendet wird. Ich kenne die Unterschiede zwischen dem Spring-Framework und Spring Boot. Ich kann eine einfache Spring Boot Applikation erzeugen (Bootstrap). Ich kenne die am häufigsten verwendeten Spring Boot Annotationen (z.B. @SpringBootApplication, @EnableAutoConfiguration) und deren Bedeutung. Ich weiss was ein Spring Boot Starter ist und kenne die am häufigsten verwendeten Spring Boot Starter (z.B. Web-Starter, Test-Starter usw.) und deren Zweck. Ich kann eine Rest-Schnittstelle mit Spring Boot erstellen und diese mit Insomnia (o.ä) ausführen und testen Spring Boot Spring Boot ist ein Projekt von Spring, welches dazu gemacht ist, einfacher Spring benutzen zu können. Es gibt viele Voreinstellungen, die auch nachträglich noch geändert werden können. Es gibt auch den Spring Initializr, der ein Spring Boot Projekt erstellt. Dort kann man dann auch weitere Abhängigkeiten und Funktionalitäten hinzufügen.\nSpring Boot nimmt uns eigentlich sehr viel Arbeit ab, wenn man damit umzugehen weiss. Z.B. beherrscht Spring Boot die Autokonfiguration, kann zusätzlich eigenständige Anwendungen erstellen und vieles mehr. Wir gehen hier aber nur auf die wichtigsten Aspekte ein.\nAutokonfiguration: Autokonfiguration bedeutet, dass deine Anwendungen bereits mit voreingestellten Abhängigkeiten initialisiert werden. Dies dient hauptsächlich dazu, Zeit zu sparen und blöde Fehler bei der Konfiguration zu vermeiden. Durch die Autokonfiguration erhältst du ein sofort ausführbares Programm. Meinungsansatz: Spring Boot wählt nach eigenem Ermessen Pakete aus und welche Standardwerte verwendet werden sollen, damit wir das nicht selbst machen müssen. Standard Spring Boot umfasst über 50 solcher Spring Starter, jedoch gibt es noch viele weitere, die von Drittanbietern zur Verfügung gestellt werden. Eigenständige Anwendungen: Spring Boot kann selbst Anwendungen erstellen, die eigenständig ausgeführt werden, ohne sich auf einen externen Webserver zu verlassen. Infolgedessen kannst du deine Anwendung auf jeder Plattform starten, indem du einfach auf ausführen drückst. Falls man eine Anwendung ohne eingebetteten Webserver erstellen will, kann man diese Funktion einfach deaktivieren. Nun ist aber die Frage, was ist überhaupt der Unterschied zwischen dem Spring Framework und Spring Boot? Und was davon ist besser?\nDa Spring Boot auf dem Spring Framework aufbaut, gibt es in der Grundstruktur keine grossen Unterschiede. Einer der grössten Unterschiede ist jedoch, dass Spring Boot sehr viel auf Komfortfunktionen setzt wie z.B. einen schnellen Projektstart, Starter Pakete und so weiter. Zudem besitzt Spring Boot noch Funktionen wie z.B. eingebettete Server, um Komplexität zu vermeiden aber auch automatische Konfigurationen für die Spring Funktionalität.\nIn der Praxis lohnt sich die Verwendung von Spring Boot, ausser du benötigst eine sehr einzigartige Konfiguration. Da man mit Boot auch auf das Annotationssystem des Spring Frameworks zugreifen kann und der Anwendung immer problemlos zusätzliche Abhängigkeiten hinzufügen kann, wird Boot in den meisten Fällen empfohlen.\nSpring Boot spezifische Annotationen Für Spring Boot gibt es spezifische Annotationen. Die @SpringBootApplication konfiguriert eine Klasse. Die @SpringBootApplication Annotation ist equivalent zu @Configuration, @EnableAutoConfiguration und @ComponentScan. Die @EnableAutoConfiguration Annotation schaltet die automatische Konfiguration ein, was einer der Hauptbestandteile von Spring Boot ist.\nMehr dazu findest du hier.\nSpring Boot Starter Wichtig zu erwähnen ist, dass die hier aufgeführten Starter nur ein Bruchteil von allen verfügbaren sind. Es sind jedoch die wichtigsten und am häufigsten verwendeten Starter.\nTest Starter: Für Testing brauchen wir normalerweise ein Paar der folgenden Erweiterungen: JUnit, Hamcrest, Mockito oder Spring Test. Diese könnten wir manuell einbinden oder verwenden den Test Starter der das für uns erledigt. Data JPA Starter: Der Data JPA Starter hilft dir, dich effizient mit relationalen Datenbanken zu verbinden. Intern verwendet der Data JPA Starter die Spring-boot-Jpa-Abhängigkeit. Jedoch schreiben wir die SQL-Abfragen nicht mehr wie z.b. bei JDBC, denn in der JPA speichern wir die Daten von Objekten in Tabellen und umgekehrt. Mail Starter: Vielleicht wirst du diesen Starter nicht allzu oft verwenden, jedoch ist es wichtig ihn zu erwähnen, damit du ihn kennst. Der Mail Starter kann hilfreich sein in der Unternehmensentwicklung, da dort das Senden von E-Mails und der direkte Umgang mit Java Mail API normalerweise schwierig sein kann. Mail Starter verbirgt diese Komplexitäten. Web Starter: Der Spring Boot Web Starter konfiguriert dir automatisch folgende Dinge: Dispatcher, Servlet, Fehlerseite, Web-JAR’s und eingebettete Servlet-Behälter. Dies sind alles wichtige Konfigurationen, wenn du ein Spring Boot Backend für Web aufbauen willst. Nun schauen wir uns kurz an, wie man diese Starter in das Projekt einbringen würde:\nTest Starter:\n1 2 3 4 5 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e Data JPA Starter\n1 2 3 4 5 6 7 8 9 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-data-jpa\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.h2database\u003c/groupId\u003e \u003cartifactId\u003eh2\u003c/artifactId\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003c/dependency\u003e Mail Starter\n1 2 3 4 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-mail\u003c/artifactId\u003e \u003c/dependency\u003e Web Starter\n1 2 3 4 5 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003cversion\u003e2.2.2.RELEASE\u003c/version\u003e \u003c/dependency\u003e Debuggen von Spring Boot Spring Boot Code ist in Java geschrieben, dementsprechend bleibt das Debuggen grundsätzlich gleich. Jedoch musst du die Interaktionen zwischen Repositorys, Services und Controllern gut verstehen und wissen, wo du die Breakpoints zu setzen hast. Im Zweifelsfall kann dir die Funktion Step Into behilflich sein.\nJetzt bist du dran. Löse bitte die Aufgaben in den Labs.\n","categories":"","description":"Modul #J8 - Spring Framework - Spring Boot\n","excerpt":"Modul #J8 - Spring Framework - Spring Boot\n","ref":"/docs/02_java/12_spring-framework/07_spring-boot/","tags":"","title":"Spring Boot"},{"body":"Ziele Ich weiss was Spring Boot ist und wofür es verwendet wird. Ich kenne die Unterschiede zwischen dem Spring-Framework und Spring Boot. Ich kann eine einfache Spring Boot Applikation erzeugen (Bootstrap). Ich kenne die am häufigsten verwendeten Spring Boot Annotationen (z.B. @SpringBootApplication, @EnableAutoConfiguration) und deren Bedeutung. Ich weiss was ein Spring Boot Starter ist und kenne die am häufigsten verwendeten Spring Boot Starter (z.B. Web-Starter, Test-Starter usw.) und deren Zweck. Ich kann eine Rest-Schnittstelle mit Spring Boot erstellen und diese mit Insomnia (o.ä) ausführen und testen Spring Boot Spring Boot ist ein Projekt von Spring, welches dazu gemacht ist, einfacher Spring benutzen zu können. Es gibt viele Voreinstellungen, die auch nachträglich noch geändert werden können. Es gibt auch den Spring Initializr, der ein Spring Boot Projekt erstellt. Dort kann man dann auch weitere Abhängigkeiten und Funktionalitäten hinzufügen.\nSpring Boot nimmt uns eigentlich sehr viel Arbeit ab, wenn man damit umzugehen weiss. Z.B. beherrscht Spring Boot die Autokonfiguration, kann zusätzlich eigenständige Anwendungen erstellen und vieles mehr. Wir gehen hier aber nur auf die wichtigsten Aspekte ein.\nAutokonfiguration: Autokonfiguration bedeutet, dass deine Anwendungen bereits mit voreingestellten Abhängigkeiten initialisiert werden. Dies dient hauptsächlich dazu, Zeit zu sparen und blöde Fehler bei der Konfiguration zu vermeiden. Durch die Autokonfiguration erhältst du ein sofort ausführbares Programm. Meinungsansatz: Spring Boot wählt nach eigenem Ermessen Pakete aus und welche Standardwerte verwendet werden sollen, damit wir das nicht selbst machen müssen. Standard Spring Boot umfasst über 50 solcher Spring Starter, jedoch gibt es noch viele weitere, die von Drittanbietern zur Verfügung gestellt werden. Eigenständige Anwendungen: Spring Boot kann selbst Anwendungen erstellen, die eigenständig ausgeführt werden, ohne sich auf einen externen Webserver zu verlassen. Infolgedessen kannst du deine Anwendung auf jeder Plattform starten, indem du einfach auf ausführen drückst. Falls man eine Anwendung ohne eingebetteten Webserver erstellen will, kann man diese Funktion einfach deaktivieren. Nun ist aber die Frage, was ist überhaupt der Unterschied zwischen dem Spring Framework und Spring Boot? Und was davon ist besser?\nDa Spring Boot auf dem Spring Framework aufbaut, gibt es in der Grundstruktur keine grossen Unterschiede. Einer der grössten Unterschiede ist jedoch, dass Spring Boot sehr viel auf Komfortfunktionen setzt wie z.B. einen schnellen Projektstart, Starter Pakete und so weiter. Zudem besitzt Spring Boot noch Funktionen wie z.B. eingebettete Server, um Komplexität zu vermeiden aber auch automatische Konfigurationen für die Spring Funktionalität.\nIn der Praxis lohnt sich die Verwendung von Spring Boot, ausser du benötigst eine sehr einzigartige Konfiguration. Da man mit Boot auch auf das Annotationssystem des Spring Frameworks zugreifen kann und der Anwendung immer problemlos zusätzliche Abhängigkeiten hinzufügen kann, wird Boot in den meisten Fällen empfohlen.\nSpring Boot spezifische Annotationen Für Spring Boot gibt es spezifische Annotationen. Die @SpringBootApplication konfiguriert eine Klasse. Die @SpringBootApplication Annotation ist equivalent zu @Configuration, @EnableAutoConfiguration und @ComponentScan. Die @EnableAutoConfiguration Annotation schaltet die automatische Konfiguration ein, was einer der Hauptbestandteile von Spring Boot ist.\nMehr dazu findest du hier.\nSpring Boot Starter Wichtig zu erwähnen ist, dass die hier aufgeführten Starter nur ein Bruchteil von allen verfügbaren sind. Es sind jedoch die wichtigsten und am häufigsten verwendeten Starter.\nTest Starter: Für Testing brauchen wir normalerweise ein Paar der folgenden Erweiterungen: JUnit, Hamcrest, Mockito oder Spring Test. Diese könnten wir manuell einbinden oder verwenden den Test Starter der das für uns erledigt. Data JPA Starter: Der Data JPA Starter hilft dir, dich effizient mit relationalen Datenbanken zu verbinden. Intern verwendet der Data JPA Starter die Spring-boot-Jpa-Abhängigkeit. Jedoch schreiben wir die SQL-Abfragen nicht mehr wie z.b. bei JDBC, denn in der JPA speichern wir die Daten von Objekten in Tabellen und umgekehrt. Mail Starter: Vielleicht wirst du diesen Starter nicht allzu oft verwenden, jedoch ist es wichtig ihn zu erwähnen, damit du ihn kennst. Der Mail Starter kann hilfreich sein in der Unternehmensentwicklung, da dort das Senden von E-Mails und der direkte Umgang mit Java Mail API normalerweise schwierig sein kann. Mail Starter verbirgt diese Komplexitäten. Web Starter: Der Spring Boot Web Starter konfiguriert dir automatisch folgende Dinge: Dispatcher, Servlet, Fehlerseite, Web-JAR’s und eingebettete Servlet-Behälter. Dies sind alles wichtige Konfigurationen, wenn du ein Spring Boot Backend für Web aufbauen willst. Nun schauen wir uns kurz an, wie man diese Starter in das Projekt einbringen würde:\nTest Starter:\n1 2 3 4 5 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e Data JPA Starter\n1 2 3 4 5 6 7 8 9 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-data-jpa\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.h2database\u003c/groupId\u003e \u003cartifactId\u003eh2\u003c/artifactId\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003c/dependency\u003e Mail Starter\n1 2 3 4 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-mail\u003c/artifactId\u003e \u003c/dependency\u003e Web Starter\n1 2 3 4 5 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003cversion\u003e2.2.2.RELEASE\u003c/version\u003e \u003c/dependency\u003e Debuggen von Spring Boot Spring Boot Code ist in Java geschrieben, dementsprechend bleibt das Debuggen grundsätzlich gleich. Jedoch musst du die Interaktionen zwischen Repositorys, Services und Controllern gut verstehen und wissen, wo du die Breakpoints zu setzen hast. Im Zweifelsfall kann dir die Funktion Step Into behilflich sein.\nJetzt bist du dran. Löse bitte die Aufgaben in den Labs.\n","categories":"","description":"Modul #J8 - Spring Framework - Spring Boot\n","excerpt":"Modul #J8 - Spring Framework - Spring Boot\n","ref":"/de/docs/02_java/12_spring-framework/07_spring-boot/","tags":"","title":"Spring Boot"},{"body":"Inhalt Diese Seite soll als Landing Page dienen und den Absprung zu den verschiedenen Testing-Seiten erleichtern.\nTesting Konzepte / JUnit / Mockito Spring Boot Testing Rest-Schnittstellen testen Angular Testfiles ","categories":"","description":"Landing Page fürs Testing\n","excerpt":"Landing Page fürs Testing\n","ref":"/docs/07_testing/","tags":"","title":"Testing"},{"body":"Inhalt Diese Seite soll als Landing Page dienen und den Absprung zu den verschiedenen Testing-Seiten erleichtern.\nTesting Konzepte / JUnit / Mockito Spring Boot Testing Rest-Schnittstellen testen Angular Testfiles ","categories":"","description":"Landing Page fürs Testing\n","excerpt":"Landing Page fürs Testing\n","ref":"/de/docs/07_testing/","tags":"","title":"Testing"},{"body":" Dieses Kapitel gehört zum Modul #J1 des Ausbildungsplans Ziele Ich verstehe den Unterschied zwischen impliziter und expliziter Typumwandlung (Casting). Ich kann einfache Casts selbst schreiben und weiss, worauf ich achten muss. Ich kenne mögliche Probleme beim Casten (z. B. Datenverlust oder Rundungsfehler). ⏱️ Geschätzte Lesezeit: 10 Minuten Einführung Beim Programmieren musst du oft mit verschiedenen Datentypen arbeiten – z. B. int und double. Damit Rechnungen korrekt funktionieren oder Werte gespeichert werden können, musst du manchmal eine Typumwandlung durchführen.\nDiese Umwandlung nennt man Casting.\nImplizite Typumwandlung Wenn Java sicher ist, dass kein Informationsverlust auftritt, wird automatisch eine Umwandlung gemacht – z. B. von int zu double.\n1 2 3 4 int a = 10; double b = a; // int → double ist erlaubt (automatisch) System.out.println(b); // Ausgabe: 10.0 Hier wird a automatisch in einen double umgewandelt, da double alle int-Werte darstellen kann.\nExplizite Typumwandlung (Casting) Wenn ein möglicher Informationsverlust besteht, musst du die Umwandlung explizit angeben:\n1 2 3 4 double x = 3.7; int y = (int) x; // explizites Casting System.out.println(y); // Ausgabe: 3 Beim Casten von double zu int wird nicht gerundet, sondern abgeschnitten (der Nachkommateil wird ignoriert). Weitere Beispiele 1 2 3 byte b = 42; int i = b; // implizit: byte → int short s = (short)i; // explizit: int → short Casting bei Operationen 1 2 3 4 5 int a = 5; int b = 2; System.out.println(a / b); // Ausgabe: 2 (Ganzzahldivision) System.out.println((double) a / b); // Ausgabe: 2.5 (wegen Casting) Wenn du eine der Zahlen in double umwandelst, wird die ganze Rechnung als Gleitkommazahl berechnet. Typumwandlung bei Zuweisungen 1 2 3 4 long big = 9999999999L; int small = (int) big; System.out.println(small); // Ausgabe: ein unerwarteter Wert! Wenn der Zieltyp zu klein ist (z. B. int statt long), kommt es zu Überlauf. Java schneidet einfach ab – das führt zu falschen Werten. Zusammenfassung Von Typ → Nach Typ Erlaubt? Art int → double ✅ automatisch implizit double → int ❌ nur mit Cast explizit int → byte ❌ nur mit Cast explizit char → int ✅ automatisch implizit ","categories":"","description":"In diesem Modul lernst du, wie du Werte von einem Datentyp in einen anderen umwandeln kannst – z. B. von `double` nach `int`.\n","excerpt":"In diesem Modul lernst du, wie du Werte von einem Datentyp in einen …","ref":"/docs/02_java/03_java-grundlagen/07_typecasting/","tags":"","title":"Typumwandlung (Casting)"},{"body":"Das Lab ist eine praktische Übung zum Wechseln zwischen verschiedenen Branches oder Commits eines Repositories. Dabei sollen die erlernten Kenntnisse zu checkout, stash, commit, pull und push vertieft werden. Für die Aufgabe wird nur das zweite Projekt benötigt.\nDiese Aufgabe ist eine Einzelaufgabe, die von jedem IT-Ninja eigenständig bearbeitet werden muss.\nSchritt 1: Feature-Branch auf dem 2. Repository erstellen Erstelle einen neuen Feature-Branch von developauf dem 2. Repository. Nutze dazu die dir bekannten Tools und Befehle.\nSchritt 2: Neuen Branch ausschecken Hole den neuen Branch als Arbeitskopie auf deinen Rechner. Gehe dazu vor, wie in den anderen Aufgaben gelernt.\nSchritt 3: Code ändern Ändere eine beliebige Methode oder erstelle eine neue Methode in einer beliebigen Klasse. Speichere deine Änderungen im lokalen Arbeitsbereich und führe commit \u0026 push aus.\nSchritt 4: “Hotfix” erstellen Erstelle einen weiteren Branch von develop auf diesem Repository und checke diesen aus. Mache einen Hotfix, indem du die Zeile System.out.println(“This is a hotfix”); in einer beliebigen Methode einfügst. Committe deine Änderungen (ohne push!).\nSchritt 5: Zum ersten Branch wechseln Checke wieder den ersten Branch aus und füge hier den folgenden Code in der main-Methode ein:\n1 2 3 if (args.length \u003e 0) { System.out.println(\"Es wurden \" + args.length + \" Argumente übergeben\"); } Speichere deine Änderungen.\nSchritt 6: Zuruck zum Hotfix-Branch Gehe auf Git › Branches…, wähle den Hotfix-Branch aus und gehe auf Checkout. Du solltest nun einen Hinweis sehen, der dich vor dem Überschreiben von nicht committeten Änderungen warnt. Klicke auf Don't checkout.\nSchritt 7: Stash Stashe deine lokalen Änderungen mit dem Git Befehl oder über das Kontextmenü in der IDE (muss auf der geänderten Klasse aufgerufen werden).\nSchritt 8: Checkout Führe den Checkout auf dem Hotfix-Branch erneut aus. Überprüfe die main-Methode. Die Änderungen aus Schritt 5 sollten nun nicht mehr vorhanden sein.\nSchritt 9: Unstash Kehre nun zum Feature-Branch zurück und überprüfe die Main-Methode. Auch hier sind die Änderungen aus Schritt 5 nicht vorhanden. Überlege, warum das so ist.\nFühre nun git pop oder git apply auf dieser Klasse aus. Begründe deine Entscheidung!\n","categories":"","description":"Aufgabe Arbeiten mit unterschiedlichen Branches [Git Vertiefung](../../../../docs/04_git/02_vertiefung/03_mehrere-repositories)\n","excerpt":"Aufgabe Arbeiten mit unterschiedlichen Branches [Git …","ref":"/labs/04_git/02_vertiefung/06_branch-switch/","tags":"","title":"Aufgabe: Arbeiten mit unterschiedlichen Branches"},{"body":"Das Lab ist eine praktische Übung zum Wechseln zwischen verschiedenen Branches oder Commits eines Repositories. Dabei sollen die erlernten Kenntnisse zu checkout, stash, commit, pull und push vertieft werden. Für die Aufgabe wird nur das zweite Projekt benötigt.\nDiese Aufgabe ist eine Einzelaufgabe, die von jedem IT-Ninja eigenständig bearbeitet werden muss.\nSchritt 1: Feature-Branch auf dem 2. Repository erstellen Erstelle einen neuen Feature-Branch von developauf dem 2. Repository. Nutze dazu die dir bekannten Tools und Befehle.\nSchritt 2: Neuen Branch ausschecken Hole den neuen Branch als Arbeitskopie auf deinen Rechner. Gehe dazu vor, wie in den anderen Aufgaben gelernt.\nSchritt 3: Code ändern Ändere eine beliebige Methode oder erstelle eine neue Methode in einer beliebigen Klasse. Speichere deine Änderungen im lokalen Arbeitsbereich und führe commit \u0026 push aus.\nSchritt 4: “Hotfix” erstellen Erstelle einen weiteren Branch von develop auf diesem Repository und checke diesen aus. Mache einen Hotfix, indem du die Zeile System.out.println(“This is a hotfix”); in einer beliebigen Methode einfügst. Committe deine Änderungen (ohne push!).\nSchritt 5: Zum ersten Branch wechseln Checke wieder den ersten Branch aus und füge hier den folgenden Code in der main-Methode ein:\n1 2 3 if (args.length \u003e 0) { System.out.println(\"Es wurden \" + args.length + \" Argumente übergeben\"); } Speichere deine Änderungen.\nSchritt 6: Zuruck zum Hotfix-Branch Gehe auf Git › Branches…, wähle den Hotfix-Branch aus und gehe auf Checkout. Du solltest nun einen Hinweis sehen, der dich vor dem Überschreiben von nicht committeten Änderungen warnt. Klicke auf Don't checkout.\nSchritt 7: Stash Stashe deine lokalen Änderungen mit dem Git Befehl oder über das Kontextmenü in der IDE (muss auf der geänderten Klasse aufgerufen werden).\nSchritt 8: Checkout Führe den Checkout auf dem Hotfix-Branch erneut aus. Überprüfe die main-Methode. Die Änderungen aus Schritt 5 sollten nun nicht mehr vorhanden sein.\nSchritt 9: Unstash Kehre nun zum Feature-Branch zurück und überprüfe die Main-Methode. Auch hier sind die Änderungen aus Schritt 5 nicht vorhanden. Überlege, warum das so ist.\nFühre nun git pop oder git apply auf dieser Klasse aus. Begründe deine Entscheidung!\n","categories":"","description":"Aufgabe Arbeiten mit unterschiedlichen Branches [Git Vertiefung](../../../../docs/04_git/02_vertiefung/03_mehrere-repositories)\n","excerpt":"Aufgabe Arbeiten mit unterschiedlichen Branches [Git …","ref":"/de/labs/04_git/02_vertiefung/06_branch-switch/","tags":"","title":"Aufgabe: Arbeiten mit unterschiedlichen Branches"},{"body":"Ziele Du weisst, was Unit-Tests in Angular sind. Du kannst beschreiben, welche Blöcke es in einem Unit-Test gibt. Unit Testing Testdateien (.spec.ts-Files) sind Teil des Test-Frameworks, das in Angular integriert ist. Sie dienen dazu, verschiedene Components, Services, Directives, Pipes etc. in einer Angular-Anwendung zu testen. Das Testen ist ein wichtiger Bestandteil der Entwicklung, da es hilft, die Funktionalität einer Anwendung zu überprüfen, Fehler zu identifizieren und sicherzustellen, dass gemachte Änderungen keine unerwünschten Nebenwirkungen haben.\nAls Beispiel folgt ein minimaler Test, welcher für den AppComponent erstellt wurde:\n1 2 3 4 5 6 7 8 9 10 11 // app.component.ts import { Component } from \"@angular/core\"; @Component({ selector: \"app-root\", templateUrl: \"./app.component.html\", styleUrls: [\"./app.component.scss\"], }) export class AppComponent { title = \"docs-project\"; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // app.component.spec.ts import { TestBed } from \"@angular/core/testing\"; import { RouterTestingModule } from \"@angular/router/testing\"; import { AppComponent } from \"./app.component\"; describe(\"AppComponent\", () =\u003e { beforeEach(() =\u003e TestBed.configureTestingModule({ imports: [RouterTestingModule], declarations: [AppComponent], }), ); it(\"should create the app\", () =\u003e { const fixture = TestBed.createComponent(AppComponent); const app = fixture.componentInstance; expect(app).toBeTruthy(); }); it(`should have as title 'docs-project'`, () =\u003e { const fixture = TestBed.createComponent(AppComponent); const app = fixture.componentInstance; expect(app.title).toEqual(\"docs-project\"); }); it(\"should render title\", () =\u003e { const fixture = TestBed.createComponent(AppComponent); fixture.detectChanges(); const compiled = fixture.nativeElement as HTMLElement; expect(compiled.querySelector(\".content span\")?.textContent).toContain( \"docs-project app is running!\", ); }); }); Wozu die einzelnen Blöcke und Methoden im Testfile sind wird nachfolgend erläutert.\nTest-Suites (describe-Blöcke): Eine Testdatei enthält normalerweise eine oder mehrere Test-Suiten. Eine Test-Suite fasst eine Gruppe von verwandten Tests zusammen. Zum Beispiel kann man eine Test-Suite für einen bestimmten Component oder einen bestimmten Service erstellen. Test-Cases (it-Blöcke): Innerhalb einer Test-Suite werden einzelne Test-Cases definiert. Ein Test-Case überprüft eine bestimmte Funktionalität oder ein bestimmtes Verhalten der Anwendung. Man kann mehrere Test-Cases innerhalb einer Test-Suite haben. Test-Setup (beforeEach-Block): Vor jedem Testfall kann man den beforeEach-Block verwenden, um die für den Test notwendigen Vorbereitungsschritte auszuführen. Zum Beispiel kann man einen Component initialisieren, Abhängigkeiten injizieren oder den Zustand der Anwendung festlegen. Dies stellt sicher, dass jeder Test-Case in einem konsistenten Zustand beginnt. Assertions: In den Test-Cases verwendet man Assertions, um zu überprüfen, ob das erwartete Verhalten erfüllt ist. Man kann verschiedene Assertions verwenden, um Eigenschaften, Zustände, Ausgaben oder Verhalten des Components zu überprüfen. Beispiele für Assertions sind expect(), toBe(), toEqual(), toContain(), toBeTruthy() etc. ","categories":"","description":"Modul #F6 - Angular - Testing\n","excerpt":"Modul #F6 - Angular - Testing\n","ref":"/docs/03_web/06_angular/02_7_unit-test/","tags":"","title":"Testfiles"},{"body":"Ziele Du weisst, was Unit-Tests in Angular sind. Du kannst beschreiben, welche Blöcke es in einem Unit-Test gibt. Unit Testing Testdateien (.spec.ts-Files) sind Teil des Test-Frameworks, das in Angular integriert ist. Sie dienen dazu, verschiedene Components, Services, Directives, Pipes etc. in einer Angular-Anwendung zu testen. Das Testen ist ein wichtiger Bestandteil der Entwicklung, da es hilft, die Funktionalität einer Anwendung zu überprüfen, Fehler zu identifizieren und sicherzustellen, dass gemachte Änderungen keine unerwünschten Nebenwirkungen haben.\nAls Beispiel folgt ein minimaler Test, welcher für den AppComponent erstellt wurde:\n1 2 3 4 5 6 7 8 9 10 11 // app.component.ts import { Component } from \"@angular/core\"; @Component({ selector: \"app-root\", templateUrl: \"./app.component.html\", styleUrls: [\"./app.component.scss\"], }) export class AppComponent { title = \"docs-project\"; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // app.component.spec.ts import { TestBed } from \"@angular/core/testing\"; import { RouterTestingModule } from \"@angular/router/testing\"; import { AppComponent } from \"./app.component\"; describe(\"AppComponent\", () =\u003e { beforeEach(() =\u003e TestBed.configureTestingModule({ imports: [RouterTestingModule], declarations: [AppComponent], }), ); it(\"should create the app\", () =\u003e { const fixture = TestBed.createComponent(AppComponent); const app = fixture.componentInstance; expect(app).toBeTruthy(); }); it(`should have as title 'docs-project'`, () =\u003e { const fixture = TestBed.createComponent(AppComponent); const app = fixture.componentInstance; expect(app.title).toEqual(\"docs-project\"); }); it(\"should render title\", () =\u003e { const fixture = TestBed.createComponent(AppComponent); fixture.detectChanges(); const compiled = fixture.nativeElement as HTMLElement; expect(compiled.querySelector(\".content span\")?.textContent).toContain( \"docs-project app is running!\", ); }); }); Wozu die einzelnen Blöcke und Methoden im Testfile sind wird nachfolgend erläutert.\nTest-Suites (describe-Blöcke): Eine Testdatei enthält normalerweise eine oder mehrere Test-Suiten. Eine Test-Suite fasst eine Gruppe von verwandten Tests zusammen. Zum Beispiel kann man eine Test-Suite für einen bestimmten Component oder einen bestimmten Service erstellen. Test-Cases (it-Blöcke): Innerhalb einer Test-Suite werden einzelne Test-Cases definiert. Ein Test-Case überprüft eine bestimmte Funktionalität oder ein bestimmtes Verhalten der Anwendung. Man kann mehrere Test-Cases innerhalb einer Test-Suite haben. Test-Setup (beforeEach-Block): Vor jedem Testfall kann man den beforeEach-Block verwenden, um die für den Test notwendigen Vorbereitungsschritte auszuführen. Zum Beispiel kann man einen Component initialisieren, Abhängigkeiten injizieren oder den Zustand der Anwendung festlegen. Dies stellt sicher, dass jeder Test-Case in einem konsistenten Zustand beginnt. Assertions: In den Test-Cases verwendet man Assertions, um zu überprüfen, ob das erwartete Verhalten erfüllt ist. Man kann verschiedene Assertions verwenden, um Eigenschaften, Zustände, Ausgaben oder Verhalten des Components zu überprüfen. Beispiele für Assertions sind expect(), toBe(), toEqual(), toContain(), toBeTruthy() etc. ","categories":"","description":"Modul #F6 - Angular - Testing\n","excerpt":"Modul #F6 - Angular - Testing\n","ref":"/de/docs/03_web/06_angular/02_7_unit-test/","tags":"","title":"Testfiles"},{"body":"Ziele Du weisst, wie man Arrays und Listen erstellt und updated. Du weisst, wie man durch Arrays iteriert und welcher Ansatz jeweils welche Vor- oder Nachteile besitzt. Arrays Basics Ein Array ist eine Datenstruktur in JavaScript, die eine geordnete Sammlung von Elementen speichert. Ein Array kann verschiedene Datentypen speichern, beispielsweise Zahlen, Zeichenketten und Objekte. Arrays werden in JavaScript durch eckige Klammern [] definiert und die Elemente innerhalb des Arrays werden durch Kommas getrennt.\n1 2 3 const array = [1, 2, 3, \"vier\", \"fünf\", { name: \"Max\" }]; console.log(array); // [1, 2, 3, 'vier', 'fünf', {name: 'Max'}] Jedes Element im Array hat eine Indexposition, die bei 0 beginnt. Auf die Elemente eines Arrays kann zugegriffen werden, indem der Index des Elements in eckigen Klammern angegeben wird:\n1 2 3 4 const array = [1, 2, 3, \"vier\", \"fünf\", { name: \"Max\" }]; console.log(array[0]); // 1 console.log(array[3]); // 'vier' Erstellen Um ein Array in JavaScript zu erstellen, kann man die eckige Klammern-Notation verwenden und die Elemente durch Kommas trennen.\n1 2 3 const array = [1, 2, 3, \"vier\", \"fünf\", { name: \"Max\" }]; console.log(array); // [1, 2, 3, 'vier', 'fünf', {name: 'Max'}] Es kann auch ein leeres Array erstellt werden:\n1 2 3 const array = []; console.log(array); // [] Elemente verändern Um ein Element an einer bestimmten Position in einem Array anzupassen, wird der entsprechende Index des Elements in eckigen Klammern angeben. Anschliessen kann dieser Wert zugewiesen werden:\n1 2 3 4 let array = [1, 2, 3, 4, 5]; array[1] = 10; console.log(array); // [1, 10, 3, 4, 5] Länge bestimmen Man kann die Länge (Anzahl der Elemente) eines JavaScript-Arrays mit der Eigenschaft length bestimmen.\n1 2 3 const array = [1, 2, 3, 4, 5]; console.log(array.length); // 5 Iterieren Um durch ein Array zu iterieren, gibt es mehrere Möglichkeiten. Die gängigsten davon sind for, forEach und for of\nFor-Loop Der for-Loop ist ein Loop, mit dem sich eine bestimmte Anzahl von Wiederholungen einer Kontrollstruktur durchlaufen lässt. Er wird häufig genutzt, um durch Arrays zu iterieren oder eine Aktion mehrmals auszuführen.\n1 2 3 4 5 const array = [1, 2, 3, 4, 5]; for (let i = 0; i \u003c array.length; i++) { console.log(array[i]); } break Das break-Statement wird verwendet, um einen Loop vorzeitig zu beenden.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 const numbers = [1, 2, 3, 4, 5, 6]; for (let i = 0; i \u003c numbers.length; i++) { if (numbers[i] === 4) { break; } console.log(numbers[i]); } console.log(\"Loop beendet!\"); // 1 // 2 // 3 // Loop beendet! continue Das continue-Statement wird verwendet, um den aktuellen Durchlauf des Loops zu überspringen und mit dem nächsten Durchlauf fortzufahren.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 const numbers = [1, 2, 3, 4, 5, 6]; for (let i = 0; i \u003c numbers.length; i++) { if (numbers[i] % 2 === 0) { continue; } console.log(numbers[i]); } console.log(\"Loop beendet!\"); // 1 // 3 // 5 // Loop beendet! forEach-Loop forEach ist eine Methode auf Arrays, um Stück für Stück durch jedes Element des Arrays zu iterieren. Der forEach-Loop ist eine kürzere Schreibweise, um durch ein Array zu iterieren.\nMan kann das in JavaScript mit der function() lösen:\n1 2 3 4 5 6 7 8 9 10 const array = [1, 2, 3, 4, 5]; array.forEach(function (element) { console.log(element); }); // 1 // 2 // 3 // 4 // 5 Wie in Kapitel Functions beschrieben, kann auch eine Arrow-Function verwendet werden. Grundsätzlich ist die Arrow-Function der Verwendung von function() vorzuziehen, da diese Schreibweise einfacher zu verstehen ist:\n1 2 3 4 5 6 7 8 const array = [1, 2, 3, 4, 5]; array.forEach((element) =\u003e console.log(element)); // 1 // 2 // 3 // 4 // 5 Im Gegensatz zum for Loop bietet der forEach-Loop jedoch weniger Kontrolle über den Loop. Zum Beispiel kann man den Loop nicht mit break oder continue unterbrechen oder überspringen. Ausserdem gibt es so keine Möglichkeit, auf den Index jedes Elements im Array zuzugreifen. Wenn man den Index benötigen, müsste man einen Zähler verwenden.\nfor…of-Loop Der for (... of ...)-Loop ist darauf ausgelegt, Arrays oder andere iterierbare Objekte wie Maps, Sets, Strings etc. zu durchlaufen. Dieser Loop ist in der Regel einfacher zu lesen und zu schreiben als ein traditioneller for-Loop.\n1 2 3 4 5 6 7 8 9 10 const array = [1, 2, 3, 4, 5]; for (const element of array) { console.log(element); } // 1 // 2 // 3 // 4 // 5 Funktionen Hinzufügen Mit der push()Methode kann man ein Element am Ende des Arrays hinzufügen.\n1 2 3 4 5 6 7 8 9 let array = [1, 2, 3]; array.push(4); // einzelnes Element hinzufügen array.push(5, 6); // zwei Elemente aufs Mal hinzufügen const x = 7; array.push(x); // Variablen funktionieren natürlich auch: console.log(array); // [1, 2, 3, 4, 5, 6, 7] Letztes Element entfernen Mit der Methode pop() kann man das letzte Element aus dem Array entfernen und zurückgeben.\n1 2 3 4 5 let array = [1, 2, 3, 4, 5]; const removedElement = array.pop(); console.log(array); // 1, 2, 3, 4] console.log(removedElement); // 5 Erstes Element entfernen Im Gegensatz zu pop() verwendet man shift() um das erste Element aus dem Array entfernen und zurückgeben zu können.\n1 2 3 4 5 let array = [1, 2, 3, 4, 5]; const removedElement = array.shift(); console.log(array); // [2, 3, 4, 5] console.log(removedElement); // 1 Elemente am Anfang hinzufügen Die Methode unshift()ist das Gegenstück zu der Methode shift(), mit der ein oder mehrere Elemente am Anfang des Arrays hinzugefügt werden können.\nunshift() gibt die neue Länge des Arrays zurückgibt.\n1 2 3 4 5 let array = [1, 2, 3]; const newLength = array.unshift(4, 5); console.log(array); // [4, 5, 1, 2, 3] console.log(newLength); // 5 Elemente an bestimmter Position hinzufügen oder entfernen Die splice()-Methode wird verwendet, um Elemente im Array hinzuzufügen oder zu entfernen.\nsplice() ändert das ursprüngliche Array und gibt das gelöschte Element oder die gelöschten Elemente zurück.\nBeispiel für Elemente löschen:\n1 2 3 4 5 let array = [1, 2, 3, 4, 5]; const removedElements = array.splice(2, 2); console.log(array); // [1, 2, 5] console.log(removedElements); // [3, 4] Beispiel für Elemente hinzufügen:\n1 2 3 4 5 6 7 let array = [1, 2, 3, 4, 5]; // An der 3. Stelle (Index 2), 0 Elemente entfernen. // Füge dort die Elemente 6 und 7 hinzu: array.splice(2, 0, 6, 7); console.log(array); // [1, 2, 6, 7, 3, 4, 5] Arrays kombinieren Die concat() Methode gibt ein neues Array zurück, das aus der Verkettung (Zusammenführung) von zwei oder mehr Arrays besteht. Man kann somit mehrere Arrays zusammenführen.\n1 2 3 4 5 const array1 = [1, 2, 3]; const array2 = [4, 5, 6]; const newArray = array1.concat(array2); console.log(newArray); // [1, 2, 3, 4, 5, 6] Mehrere Arrays werden wie folgt miteinander verkettet:\n1 2 3 4 5 const array1 = [1, 2, 3]; const array2 = [4, 5, 6]; const array3 = [7, 8, 9]; let newArray = array1.concat(array2, array3); console.log(newArray); // [1, 2, 3, 4, 5, 6, 7, 8, 9] Index eines Elements herausfinden Um den Index eines bestimmten Elements in einem Array zu finden, wird die Methode indexOf()verwendet.\nWenn das Element im Array nicht gefunden wird, gibt die Methode den Wert -1 zurück.\nBeispiel:\n1 2 3 4 const fruits = [\"apple\", \"banana\", \"orange\", \"pear\"]; const index = fruits.indexOf(\"banana\"); console.log(index); // 1 Beispiel, wenn Element nicht gefunden wird:\n1 2 3 4 const fruits = [\"apple\", \"banana\", \"orange\", \"pear\"]; const index = fruits.indexOf(\"grape\"); console.log(index); // -1 Man kann der Methode auch einen optionalen Parameter hinzufügen, der angibt, ab welchem Index die Suche beginnen soll. Wenn dieser Parameter nicht angegeben wird, wird die Suche ab Index 0 gestartet.\n1 2 3 4 const fruits = [\"pear\", \"banana\", \"orange\", \"pear\"]; const index = fruits.indexOf(\"pear\", 1); console.log(index); // 3 ","categories":"","description":"Modul #F4 - JavaScript - Arrays/Listen und ihre Methoden.\n","excerpt":"Modul #F4 - JavaScript - Arrays/Listen und ihre Methoden.\n","ref":"/docs/03_web/03_javascript/08_arrays/","tags":"","title":"Arrays"},{"body":"Ziele Du weisst, wie man Arrays und Listen erstellt und updated. Du weisst, wie man durch Arrays iteriert und welcher Ansatz jeweils welche Vor- oder Nachteile besitzt. Arrays Basics Ein Array ist eine Datenstruktur in JavaScript, die eine geordnete Sammlung von Elementen speichert. Ein Array kann verschiedene Datentypen speichern, beispielsweise Zahlen, Zeichenketten und Objekte. Arrays werden in JavaScript durch eckige Klammern [] definiert und die Elemente innerhalb des Arrays werden durch Kommas getrennt.\n1 2 3 const array = [1, 2, 3, \"vier\", \"fünf\", { name: \"Max\" }]; console.log(array); // [1, 2, 3, 'vier', 'fünf', {name: 'Max'}] Jedes Element im Array hat eine Indexposition, die bei 0 beginnt. Auf die Elemente eines Arrays kann zugegriffen werden, indem der Index des Elements in eckigen Klammern angegeben wird:\n1 2 3 4 const array = [1, 2, 3, \"vier\", \"fünf\", { name: \"Max\" }]; console.log(array[0]); // 1 console.log(array[3]); // 'vier' Erstellen Um ein Array in JavaScript zu erstellen, kann man die eckige Klammern-Notation verwenden und die Elemente durch Kommas trennen.\n1 2 3 const array = [1, 2, 3, \"vier\", \"fünf\", { name: \"Max\" }]; console.log(array); // [1, 2, 3, 'vier', 'fünf', {name: 'Max'}] Es kann auch ein leeres Array erstellt werden:\n1 2 3 const array = []; console.log(array); // [] Elemente verändern Um ein Element an einer bestimmten Position in einem Array anzupassen, wird der entsprechende Index des Elements in eckigen Klammern angeben. Anschliessen kann dieser Wert zugewiesen werden:\n1 2 3 4 let array = [1, 2, 3, 4, 5]; array[1] = 10; console.log(array); // [1, 10, 3, 4, 5] Länge bestimmen Man kann die Länge (Anzahl der Elemente) eines JavaScript-Arrays mit der Eigenschaft length bestimmen.\n1 2 3 const array = [1, 2, 3, 4, 5]; console.log(array.length); // 5 Iterieren Um durch ein Array zu iterieren, gibt es mehrere Möglichkeiten. Die gängigsten davon sind for, forEach und for of\nFor-Loop Der for-Loop ist ein Loop, mit dem sich eine bestimmte Anzahl von Wiederholungen einer Kontrollstruktur durchlaufen lässt. Er wird häufig genutzt, um durch Arrays zu iterieren oder eine Aktion mehrmals auszuführen.\n1 2 3 4 5 const array = [1, 2, 3, 4, 5]; for (let i = 0; i \u003c array.length; i++) { console.log(array[i]); } break Das break-Statement wird verwendet, um einen Loop vorzeitig zu beenden.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 const numbers = [1, 2, 3, 4, 5, 6]; for (let i = 0; i \u003c numbers.length; i++) { if (numbers[i] === 4) { break; } console.log(numbers[i]); } console.log(\"Loop beendet!\"); // 1 // 2 // 3 // Loop beendet! continue Das continue-Statement wird verwendet, um den aktuellen Durchlauf des Loops zu überspringen und mit dem nächsten Durchlauf fortzufahren.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 const numbers = [1, 2, 3, 4, 5, 6]; for (let i = 0; i \u003c numbers.length; i++) { if (numbers[i] % 2 === 0) { continue; } console.log(numbers[i]); } console.log(\"Loop beendet!\"); // 1 // 3 // 5 // Loop beendet! forEach-Loop forEach ist eine Methode auf Arrays, um Stück für Stück durch jedes Element des Arrays zu iterieren. Der forEach-Loop ist eine kürzere Schreibweise, um durch ein Array zu iterieren.\nMan kann das in JavaScript mit der function() lösen:\n1 2 3 4 5 6 7 8 9 10 const array = [1, 2, 3, 4, 5]; array.forEach(function (element) { console.log(element); }); // 1 // 2 // 3 // 4 // 5 Wie in Kapitel Functions beschrieben, kann auch eine Arrow-Function verwendet werden. Grundsätzlich ist die Arrow-Function der Verwendung von function() vorzuziehen, da diese Schreibweise einfacher zu verstehen ist:\n1 2 3 4 5 6 7 8 const array = [1, 2, 3, 4, 5]; array.forEach((element) =\u003e console.log(element)); // 1 // 2 // 3 // 4 // 5 Im Gegensatz zum for Loop bietet der forEach-Loop jedoch weniger Kontrolle über den Loop. Zum Beispiel kann man den Loop nicht mit break oder continue unterbrechen oder überspringen. Ausserdem gibt es so keine Möglichkeit, auf den Index jedes Elements im Array zuzugreifen. Wenn man den Index benötigen, müsste man einen Zähler verwenden.\nfor…of-Loop Der for (... of ...)-Loop ist darauf ausgelegt, Arrays oder andere iterierbare Objekte wie Maps, Sets, Strings etc. zu durchlaufen. Dieser Loop ist in der Regel einfacher zu lesen und zu schreiben als ein traditioneller for-Loop.\n1 2 3 4 5 6 7 8 9 10 const array = [1, 2, 3, 4, 5]; for (const element of array) { console.log(element); } // 1 // 2 // 3 // 4 // 5 Funktionen Hinzufügen Mit der push()Methode kann man ein Element am Ende des Arrays hinzufügen.\n1 2 3 4 5 6 7 8 9 let array = [1, 2, 3]; array.push(4); // einzelnes Element hinzufügen array.push(5, 6); // zwei Elemente aufs Mal hinzufügen const x = 7; array.push(x); // Variablen funktionieren natürlich auch: console.log(array); // [1, 2, 3, 4, 5, 6, 7] Letztes Element entfernen Mit der Methode pop() kann man das letzte Element aus dem Array entfernen und zurückgeben.\n1 2 3 4 5 let array = [1, 2, 3, 4, 5]; const removedElement = array.pop(); console.log(array); // 1, 2, 3, 4] console.log(removedElement); // 5 Erstes Element entfernen Im Gegensatz zu pop() verwendet man shift() um das erste Element aus dem Array entfernen und zurückgeben zu können.\n1 2 3 4 5 let array = [1, 2, 3, 4, 5]; const removedElement = array.shift(); console.log(array); // [2, 3, 4, 5] console.log(removedElement); // 1 Elemente am Anfang hinzufügen Die Methode unshift()ist das Gegenstück zu der Methode shift(), mit der ein oder mehrere Elemente am Anfang des Arrays hinzugefügt werden können.\nunshift() gibt die neue Länge des Arrays zurückgibt.\n1 2 3 4 5 let array = [1, 2, 3]; const newLength = array.unshift(4, 5); console.log(array); // [4, 5, 1, 2, 3] console.log(newLength); // 5 Elemente an bestimmter Position hinzufügen oder entfernen Die splice()-Methode wird verwendet, um Elemente im Array hinzuzufügen oder zu entfernen.\nsplice() ändert das ursprüngliche Array und gibt das gelöschte Element oder die gelöschten Elemente zurück.\nBeispiel für Elemente löschen:\n1 2 3 4 5 let array = [1, 2, 3, 4, 5]; const removedElements = array.splice(2, 2); console.log(array); // [1, 2, 5] console.log(removedElements); // [3, 4] Beispiel für Elemente hinzufügen:\n1 2 3 4 5 6 7 let array = [1, 2, 3, 4, 5]; // An der 3. Stelle (Index 2), 0 Elemente entfernen. // Füge dort die Elemente 6 und 7 hinzu: array.splice(2, 0, 6, 7); console.log(array); // [1, 2, 6, 7, 3, 4, 5] Arrays kombinieren Die concat() Methode gibt ein neues Array zurück, das aus der Verkettung (Zusammenführung) von zwei oder mehr Arrays besteht. Man kann somit mehrere Arrays zusammenführen.\n1 2 3 4 5 const array1 = [1, 2, 3]; const array2 = [4, 5, 6]; const newArray = array1.concat(array2); console.log(newArray); // [1, 2, 3, 4, 5, 6] Mehrere Arrays werden wie folgt miteinander verkettet:\n1 2 3 4 5 const array1 = [1, 2, 3]; const array2 = [4, 5, 6]; const array3 = [7, 8, 9]; let newArray = array1.concat(array2, array3); console.log(newArray); // [1, 2, 3, 4, 5, 6, 7, 8, 9] Index eines Elements herausfinden Um den Index eines bestimmten Elements in einem Array zu finden, wird die Methode indexOf()verwendet.\nWenn das Element im Array nicht gefunden wird, gibt die Methode den Wert -1 zurück.\nBeispiel:\n1 2 3 4 const fruits = [\"apple\", \"banana\", \"orange\", \"pear\"]; const index = fruits.indexOf(\"banana\"); console.log(index); // 1 Beispiel, wenn Element nicht gefunden wird:\n1 2 3 4 const fruits = [\"apple\", \"banana\", \"orange\", \"pear\"]; const index = fruits.indexOf(\"grape\"); console.log(index); // -1 Man kann der Methode auch einen optionalen Parameter hinzufügen, der angibt, ab welchem Index die Suche beginnen soll. Wenn dieser Parameter nicht angegeben wird, wird die Suche ab Index 0 gestartet.\n1 2 3 4 const fruits = [\"pear\", \"banana\", \"orange\", \"pear\"]; const index = fruits.indexOf(\"pear\", 1); console.log(index); // 3 ","categories":"","description":"Modul #F4 - JavaScript - Arrays/Listen und ihre Methoden.\n","excerpt":"Modul #F4 - JavaScript - Arrays/Listen und ihre Methoden.\n","ref":"/de/docs/03_web/03_javascript/08_arrays/","tags":"","title":"Arrays"},{"body":"Inhalt In diesem optionalen Kapitel lernst du, was CI/CD bedeutet, wie man eine CI-Pipeline baut und was für Vorteile das bietet.\n","categories":"","description":"Grundlagen für das Bauen und Warten von CI/CD-Infrastruktur\n","excerpt":"Grundlagen für das Bauen und Warten von CI/CD-Infrastruktur\n","ref":"/docs/08_cicd/","tags":"","title":"CI/CD"},{"body":"Inhalt In diesem optionalen Kapitel lernst du, was CI/CD bedeutet, wie man eine CI-Pipeline baut und was für Vorteile das bietet.\n","categories":"","description":"Grundlagen für das Bauen und Warten von CI/CD-Infrastruktur\n","excerpt":"Grundlagen für das Bauen und Warten von CI/CD-Infrastruktur\n","ref":"/de/docs/08_cicd/","tags":"","title":"CI/CD"},{"body":"Aufgabe 1 - generische Methode um alle Elemente in einem Array auszugeben Schreibe eine generische Methode, welche ein Array als Parameter erhält und alle Elemente im Array ausgibt. Verwende diese Methode jeweils mit Arrays, welche folgende Typen beinhalten: Integer, String, Double.\nAufgabe 2 - generische Klasse Schreibe eine generische Klasse “NumberList”, welche eine Liste von Zahlen erhält und folgende Operationen auf diesen Zahlen ausführen kann:\nDie grösste Zahl in der Liste finden Die kleinste Zahl in der Liste finden Die Typen der Input-Zahlen können unterschiedlich sein (Ganzzahlen, Kommazahlen…)\nHier kannst du zurück zur Theorie.\n","categories":"","description":"Aufgabe zu Modul #J2 - OOP - Generics I\n","excerpt":"Aufgabe zu Modul #J2 - OOP - Generics I\n","ref":"/labs/02_java/04_java-oop/08_generics/","tags":"","title":"Generics"},{"body":"Aufgabe 1 - generische Methode um alle Elemente in einem Array auszugeben Schreibe eine generische Methode, welche ein Array als Parameter erhält und alle Elemente im Array ausgibt. Verwende diese Methode jeweils mit Arrays, welche folgende Typen beinhalten: Integer, String, Double.\nAufgabe 2 - generische Klasse Schreibe eine generische Klasse “NumberList”, welche eine Liste von Zahlen erhält und folgende Operationen auf diesen Zahlen ausführen kann:\nDie grösste Zahl in der Liste finden Die kleinste Zahl in der Liste finden Die Typen der Input-Zahlen können unterschiedlich sein (Ganzzahlen, Kommazahlen…)\nHier kannst du zurück zur Theorie.\n","categories":"","description":"Aufgabe zu Modul #J2 - OOP - Generics I\n","excerpt":"Aufgabe zu Modul #J2 - OOP - Generics I\n","ref":"/de/labs/02_java/04_java-oop/08_generics/","tags":"","title":"Generics"},{"body":"Du hast inzwischen viel über HTML gelernt. Jetzt kannst du die Aufgabe 4 in den Labs lösen.\nBeherrschst du HTML? Wenn dem so ist, dann gib deinem HTML ein Glow up - mit CSS! Fahre hier fort.\nHast du nicht alles verstanden oder du fühlst dich noch nicht so sattelfest? Dann kannst du HTML gerne noch ein bisschen üben. Wir empfehlen dazu den HTML-Teil aus dem folgenden Kurs:\nIntro to HTML and CSS - Udacity ","categories":"","description":"Modul #F3 - HTML und CSS - Wie weiter?\n","excerpt":"Modul #F3 - HTML und CSS - Wie weiter?\n","ref":"/docs/03_web/02_html_css/08_html-finish/","tags":"","title":"HTML Rekapitulieren"},{"body":"Du hast inzwischen viel über HTML gelernt. Jetzt kannst du die Aufgabe 4 in den Labs lösen.\nBeherrschst du HTML? Wenn dem so ist, dann gib deinem HTML ein Glow up - mit CSS! Fahre hier fort.\nHast du nicht alles verstanden oder du fühlst dich noch nicht so sattelfest? Dann kannst du HTML gerne noch ein bisschen üben. Wir empfehlen dazu den HTML-Teil aus dem folgenden Kurs:\nIntro to HTML and CSS - Udacity ","categories":"","description":"Modul #F3 - HTML und CSS - Wie weiter?\n","excerpt":"Modul #F3 - HTML und CSS - Wie weiter?\n","ref":"/de/docs/03_web/02_html_css/08_html-finish/","tags":"","title":"HTML Rekapitulieren"},{"body":"Ziele Ich kann alle Komponenten auswendig aufzählen, die zu einer Methodendeklaration gehören. Ich kann auswendig die Regeln aufzählen, die ein Methodenname einhalten sollte (Konventionen). Ich schreibe Getter- und Setter-Methoden gemäss Namenskonventionen. Ich kann in eigenen Worten erklären, warum der Zugriffsmodifikator einer Methode so restriktiv wie möglich gewählt werden sollte. Ich kann die Voraussetzungen, um Methoden überladen zu können, vollständig aufzählen. Ich kann in eigenen Worten die Umstände erläutern, wann die equals- und die hashCode-Methode überschrieben werden sollten. Ich kann in eigenen Worten die Bedingungen beschreiben, welche bei der Überschreibung der Methode equals erfüllt werden müssen. Ich kann in eigenen Worten die Bedingungen beschreiben, welche bei der Überschreibung der Methode hashCode erfüllt werden müssen. Instanzmethoden Methoden sind dafür da, bestimmte Aufgaben auszuführen. Sie können den Zustand eines Objekts ändern oder Berechnungen durchführen. Kurz gesagt, hier passiert die “Magie” in einer Anwendung. Zum Beispiel kann eine Methode den Wert eines Datenfeldes ändern (wie die Geschwindigkeit eines Autos) oder eine Berechnung durchführen (wie das Berechnen der benötigten Zeit, um eine bestimmte Strecke zurückzulegen).\nEine Methodendeklaration besteht aus bis zu sieben Komponenten\nZugriffsmodifikator: public, protected, private oder package-private. Er bestimmt, wer auf die Methode zugreifen kann. Wichtig: Wähle immer den Modifikator, der den Zugriff so eingeschränkt wie möglich hält. Andere Modifikatoren: Beispielsweise static oder synchronized. static: Wenn eine Methode als static deklariert wird, gehört sie zur Klasse und nicht zu einer Instanz der Klasse. Das bedeutet, dass du die Methode aufrufen kannst, ohne ein Objekt der Klasse zu erstellen. Zum Beispiel: Math.abs(). Das wird später in der objektorientierten Programmierung wichtig, musst du jetzt aber noch nicht verstehen. synchronized: Dieser Modifikator sorgt dafür, dass die Methode nur von einem Thread gleichzeitig ausgeführt werden kann. Das ist wichtig, wenn mehrere Threads gleichzeitig auf dieselben Daten zugreifen und diese ändern, um Fehler zu vermeiden. Rückgabewert: Das ist der Datentyp, den die Methode zurückgibt. Wenn nichts zurückgegeben wird, verwendet man void. Methodenname: Der Name der Methode, zum Beispiel calculateTimeToDistance. Parameterliste: Die Werte, die die Methode als Eingabe bekommt. Das ist eine Liste in Klammern, wie zum Beispiel (int distance), wobei auch mehrere Parameter erlaubt sind. Wenn keine Parameter gebraucht werden, lässt man die Klammern leer. Ausnahmen (Exceptions): Hier wird festgelegt, welche Fehler die Methode auslösen kann. Mehr dazu gibt es später im Modul “Exception Handling”. Methodenkörper: Der Code in geschweiften Klammern {}, der die Methode ausführt. Beispiel: Methode für ein Auto Schauen wir uns eine Methode (calculateTimeToDistance) für ein Auto an:\n1 2 3 4 5 6 7 8 9 public class Auto{ // Ein Datenfeld für die Geschwindigkeit des Autos (in km/h) private int speedInKmh; // Eine Methode, um die Zeit zu berechnen, die benötigt wird, um eine bestimmte Distanz (distance) zu überwinden public double calculateTimeToDistance(int distanceInKm) throws ArithmeticException { return (double) distance / this.speed; } } Erklärung der Methode:\nZugriffsmodifikator: public - Die Methode kann von aussen aufgerufen werden. Andere Modifikatoren: Keine. Rückgabewert: double - Die Methode gibt die benötigte Zeit in Stunden zurück, daher der Datentyp double. Methodenname: calculateTimeToDistance - Der Name sagt klar aus, was die Methode macht. Parameterliste: int distanceInKm - Die Methode braucht die Distanz als Eingabewert. Ausnahmen (Exceptions): throws ArithmeticException - Falls die Geschwindigkeit 0 ist, könnte es zu einer Exception kommen, weil eine Division durch 0 nicht möglich ist. Dies wird in einem späteren Kapitel genauer erklärt. Methodenkörper: Die Berechnung wird durchgeführt, indem die Distanz durch die Geschwindigkeit geteilt wird. Namenskonventionen für Methoden Methodennamen sollen - per Konvention - folgende Regeln einhalten:\nDer erste Buchstabe ist immer klein. Verwende CamelCase: Das bedeutet, dass alle Buchstaben des ersten Worts klein geschrieben werden. Ab dann wird jeweils der erste Buchstaben von jedem Wort gross geschrieben. Beispiele: equals, printThisToConsole. Der Methodenname soll ein Verb enthalten, welches die Funktionalität der Methode beschreibt. Wenn es dem Verständnis der Funktionalität dient, wird dieses Verb zusammen mit einem Nomen zusammengesetzt. Der Name sollte möglichst klar und verständlich sein, damit man sofort weiss, was die Methode macht. Vermeide Abkürzungen, schreibe die Wörter lieber aus (ausser es sind sehr bekannte Abkürzungen). Getter und Setter Eine get-Methode (auch Getter genannt) holt den Wert eines bestimmten Datenfelds und gibt ihn zurück. Eine set-Methode (auch Setter genannt) ändert den Wert dieses Datenfelds. Das Ganze gehört zum Prinzip der Kapselung, was bedeutet, dass Daten sicher verwaltet werden.\nDu fragst dich vielleicht: Warum nicht einfach alle meine Variablen als public deklarieren? Das klingt doch einfacher, oder? Aber das Problem ist, dass jeder Teil deines Programms dann direkt auf die Daten zugreifen und sie ändern könnte – auch unbeabsichtigt. Mit get- und set-Methoden kannst du kontrollieren, wer auf die Daten zugreifen oder sie verändern darf. Zum Beispiel auch, wenn andere Entwickler auf deinem Code arbeiten. Zum Beispiel: Wenn du nur eine get-Methode ohne set-Methode erstellst, machst du das Datenfeld von ausserhalb nur lesbar – man kann es also nicht ändern.\nNamenskonventionen Für Getter- und Setter-Methoden werden immer die gleichen Methodennamen verwendet. Als Präfix benutzen wir get und set gefolgt vom Namen des Datenfelds worauf sich die Methode bezieht.\n1 2 3 4 5 6 7 8 9 10 11 public class Car { private int speed; public int getSpeed() { return speed; } public void setSpeed(int speed) { this.speed = speed; } } 1 2 3 4 5 6 7 class Demo { public static void main(String[] args) { Car car = new Car(); car.setSpeed(100); System.out.println(car.getSpeed()); } } Methoden überladen In Java können wir Methoden überladen. Das heisst, wir können mehrere Methoden mit demselben Namen definieren, solange die Anzahl an Parametern oder die Datentypen der Parameter variieren. Beim Aufruf der Methode wird vom Compiler die entsprechende Definition ausgewählt.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Calculator { public double product(double x, double y) { return x * y; } // Overloading the function to handle three arguments public double product(double x, double y, double z) { return x * y * z; } // Overloading the function to handle int public int product(int x, int y) { return x * y; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 class Demo { public static void main(String[] args) { Calculator cal = new Calculator(); double x = 10; double y = 20; double z = 5; int a = 12; int b = 4; System.out.println(cal.product(x, y)); System.out.println(cal.product(x, y, z)); System.out.println(cal.product(a, b)); } } Methoden, deren Parameter gleich sind (gleiche Anzahl, gleiche Datentypen) und sich lediglich in ihren Rückgabetypen unterscheiden, können nicht überladen werden, da der Compiler nicht in der Lage ist, zwischen ihren Aufrufen zu unterscheiden.\nDie Methoden equals() und hashCode() Die Methoden equals() und hashCode() sind wichtige Bestandteile der Java-APIs. Sie sind automatisch in jeder Klasse vorhanden, weil sie von der Object-Klasse geerbt werden. Das bedeutet, dass jede Klasse in Java diese beiden Methoden hat, auch wenn du sie nicht selbst hinzufügst. Mehr darüber erfährst du im Modul “Objektorientiertes Design (OOD)”.\nequals() Du hast bereits im Thema String gesehen, dass man mit equals() überprüft, ob zwei Objekte denselben Wert haben. Der Unterschied zu == ist, dass == nur prüft, ob beide Objekte exakt dasselbe sind, also die gleiche Speicheradresse haben. Mit equals() hingegen vergleichst du den Inhalt der Objekte.\nStandardmässig definiert die equals()-Methode in der Object-Klasse, dass zwei Objekte nur dann gleich sind, wenn sie exakt die gleiche Identität haben. Das bedeutet, dass zwei unterschiedliche Objekte derselben Klasse als nicht gleich angesehen werden, selbst wenn alle ihre Felder die gleichen Werte enthalten. Es wird also die Speicheradresse mit == verlgichen:\n1 2 3 4 // Der Code aus der Klasse Object in Java public boolean equals(Object obj) { return (this == obj); } Das passt aber nicht immer, besonders wenn du den Inhalt der Objekte vergleichen möchtest oder du nur spezifische Eigenschaften, wie zum Beispiel eine ID vergleichen möchtest. In diesem Fall musst du die equals()-Methode überschreiben, um die Gleichheit richtig zu definieren.\nBei der Umsetzung müssen folgende Bedingungen für die Definition der Gleichheit bei nicht-null Objekten gemäss API-Definition für equals() erfüllt werden:\nReflexivität: Das Objekt liefert beim Vergleich mit sich selbst true. Symmetrie: Wenn Objekt x gleich Objekt y ist, dann muss y auch gleich x sein. Transivität: Wenn x gleich y ist und y gleich z, dann muss auch x gleich z sein. Konsistenz: Egal wie häufig der Vergleich durchgeführt wird, es kommt immer dasselbe heraus, sofern sich der Inhalt der Objekte nicht verändert. Behandlung von null: Der Vergleich mit null liefert immer false. Eine mögliche Implementierung von equals() für die Klasse Car könnte wie folgt aussehen:\n1 2 3 4 5 6 7 @Override public boolean equals(Object other) { if (this == other) return true; if (other == null || getClass() != other.getClass()) return false; Car car = (Car) other; return speed == car.speed; } (Die Angabe (“Annotation”) von @Override ist freiwillig. Sie wird angegeben, wenn eine bestehende Methode (z.B. von der Klasse Object) überschrieben wird. Diese Angabe bewirkt, dass es ein Kompilierfehler gibt, falls keine bestehende Methode überschrieben wird.)\nDie equals()-Methode kannst du wie eine ganz normale Methode aufrufen, wird aber meistens in einer if-Anweisung verwendet:\n1 2 3 4 5 6 7 8 9 10 11 Car carA = new Car(); carA.setSpeed(3); Car carB = new Car(); carA.setSpeed(4); if (carA.equals(carB)){ System.out.println(\"Both cars are equal.\"); } else { System.out.println(\"The cars are different.\"); } // Output: The cars are different. hashCode() Die Methode hashCode() erstellt für jedes Objekt einen Hashwert – das ist wie ein Fingerabdruck, der das Objekt möglichst eindeutig beschreibt. Dieser Hashwert wird aus den Feldern des Objekts berechnet. Der Hashwert ist eine Zahl, der Rückgabetyp von hashCode ist also ein int.\nFalls du genauer erfahren möchtest, wie Hashing funktioniert, kannst du diesen Beitrag lesen.\nDer Hashwert ermöglicht es Java, Objekte effizient zu vergleichen und zu verwalten. Wichtig ist, dass der Hashwert immer dieselbe Zahl liefert, solange sich das Objekt nicht ändert.\nAuch für diese Methode definiert die API-Definition für hashCode() Bedingungen, welche erfüllt werden müssen, damit die Methode zweckmässig verwendet werden kann:\nKonsistenz: Jedes Mal, wenn hashCode() aufgerufen wird, muss derselbe Wert zurückgegeben werden, solange das Objekt unverändert bleibt. Zusammenhang mit equals(): Zwei Objekte, die gemäss equals() gleich sind, müssen den gleichen Hashwert liefern. Zusammenhang bei ungleichen Objekten: Zwei Objekte die gemäss equals() verschieden sind, müssen nicht zwingend unterschiedliche Hashwerte liefern. Grundsätzlich wäre es aber besser für die Performanz, wenn verschiedene Objekte auch verschiedene Hashwerte liefern würden. Wenn du die Methode equals() überschreibst, solltest du auch hashCode() überschreiben, damit beide zusammen korrekt funktionieren.\nHier ein Beispiel für die Klasse Car, wie eine mögliche hashCode()-Methode aussehen könnte. Hier haben wir 2 weitere Felder aus Demonstrationsgründen hinzugefügt:\n1 2 3 4 5 6 7 8 9 10 public class Car { private int speed; private String brand; private float remainingAmountOfFuel; @Override public int hashCode() { return Objects.hash(speed, brand, remainingAmountOfFuel); } } Oft sieht man statt Objects.hash(...) auch eine eigene Implementation wie die folgende:\n1 2 3 4 5 6 7 @Override public int hashCode() { int result = speed; result = 31 * result + (brand != null ? brand.hashCode() : 0); result = 31 * result + (remainingAmountOfFuel != +0.0f ? Float.floatToIntBits(remainingAmountOfFuel) : 0); return result; } ","categories":"","description":"Modul #J2\n","excerpt":"Modul #J2\n","ref":"/docs/02_java/04_java-oop/08_methods/","tags":"","title":"Instanzmethoden"},{"body":"Ziele Ich kann alle Komponenten auswendig aufzählen, die zu einer Methodendeklaration gehören. Ich kann auswendig die Regeln aufzählen, die ein Methodenname einhalten sollte (Konventionen). Ich schreibe Getter- und Setter-Methoden gemäss Namenskonventionen. Ich kann in eigenen Worten erklären, warum der Zugriffsmodifikator einer Methode so restriktiv wie möglich gewählt werden sollte. Ich kann die Voraussetzungen, um Methoden überladen zu können, vollständig aufzählen. Ich kann in eigenen Worten die Umstände erläutern, wann die equals- und die hashCode-Methode überschrieben werden sollten. Ich kann in eigenen Worten die Bedingungen beschreiben, welche bei der Überschreibung der Methode equals erfüllt werden müssen. Ich kann in eigenen Worten die Bedingungen beschreiben, welche bei der Überschreibung der Methode hashCode erfüllt werden müssen. Instanzmethoden Methoden sind dafür da, bestimmte Aufgaben auszuführen. Sie können den Zustand eines Objekts ändern oder Berechnungen durchführen. Kurz gesagt, hier passiert die “Magie” in einer Anwendung. Zum Beispiel kann eine Methode den Wert eines Datenfeldes ändern (wie die Geschwindigkeit eines Autos) oder eine Berechnung durchführen (wie das Berechnen der benötigten Zeit, um eine bestimmte Strecke zurückzulegen).\nEine Methodendeklaration besteht aus bis zu sieben Komponenten\nZugriffsmodifikator: public, protected, private oder package-private. Er bestimmt, wer auf die Methode zugreifen kann. Wichtig: Wähle immer den Modifikator, der den Zugriff so eingeschränkt wie möglich hält. Andere Modifikatoren: Beispielsweise static oder synchronized. static: Wenn eine Methode als static deklariert wird, gehört sie zur Klasse und nicht zu einer Instanz der Klasse. Das bedeutet, dass du die Methode aufrufen kannst, ohne ein Objekt der Klasse zu erstellen. Zum Beispiel: Math.abs(). Das wird später in der objektorientierten Programmierung wichtig, musst du jetzt aber noch nicht verstehen. synchronized: Dieser Modifikator sorgt dafür, dass die Methode nur von einem Thread gleichzeitig ausgeführt werden kann. Das ist wichtig, wenn mehrere Threads gleichzeitig auf dieselben Daten zugreifen und diese ändern, um Fehler zu vermeiden. Rückgabewert: Das ist der Datentyp, den die Methode zurückgibt. Wenn nichts zurückgegeben wird, verwendet man void. Methodenname: Der Name der Methode, zum Beispiel calculateTimeToDistance. Parameterliste: Die Werte, die die Methode als Eingabe bekommt. Das ist eine Liste in Klammern, wie zum Beispiel (int distance), wobei auch mehrere Parameter erlaubt sind. Wenn keine Parameter gebraucht werden, lässt man die Klammern leer. Ausnahmen (Exceptions): Hier wird festgelegt, welche Fehler die Methode auslösen kann. Mehr dazu gibt es später im Modul “Exception Handling”. Methodenkörper: Der Code in geschweiften Klammern {}, der die Methode ausführt. Beispiel: Methode für ein Auto Schauen wir uns eine Methode (calculateTimeToDistance) für ein Auto an:\n1 2 3 4 5 6 7 8 9 public class Auto{ // Ein Datenfeld für die Geschwindigkeit des Autos (in km/h) private int speedInKmh; // Eine Methode, um die Zeit zu berechnen, die benötigt wird, um eine bestimmte Distanz (distance) zu überwinden public double calculateTimeToDistance(int distanceInKm) throws ArithmeticException { return (double) distance / this.speed; } } Erklärung der Methode:\nZugriffsmodifikator: public - Die Methode kann von aussen aufgerufen werden. Andere Modifikatoren: Keine. Rückgabewert: double - Die Methode gibt die benötigte Zeit in Stunden zurück, daher der Datentyp double. Methodenname: calculateTimeToDistance - Der Name sagt klar aus, was die Methode macht. Parameterliste: int distanceInKm - Die Methode braucht die Distanz als Eingabewert. Ausnahmen (Exceptions): throws ArithmeticException - Falls die Geschwindigkeit 0 ist, könnte es zu einer Exception kommen, weil eine Division durch 0 nicht möglich ist. Dies wird in einem späteren Kapitel genauer erklärt. Methodenkörper: Die Berechnung wird durchgeführt, indem die Distanz durch die Geschwindigkeit geteilt wird. Namenskonventionen für Methoden Methodennamen sollen - per Konvention - folgende Regeln einhalten:\nDer erste Buchstabe ist immer klein. Verwende CamelCase: Das bedeutet, dass alle Buchstaben des ersten Worts klein geschrieben werden. Ab dann wird jeweils der erste Buchstaben von jedem Wort gross geschrieben. Beispiele: equals, printThisToConsole. Der Methodenname soll ein Verb enthalten, welches die Funktionalität der Methode beschreibt. Wenn es dem Verständnis der Funktionalität dient, wird dieses Verb zusammen mit einem Nomen zusammengesetzt. Der Name sollte möglichst klar und verständlich sein, damit man sofort weiss, was die Methode macht. Vermeide Abkürzungen, schreibe die Wörter lieber aus (ausser es sind sehr bekannte Abkürzungen). Getter und Setter Eine get-Methode (auch Getter genannt) holt den Wert eines bestimmten Datenfelds und gibt ihn zurück. Eine set-Methode (auch Setter genannt) ändert den Wert dieses Datenfelds. Das Ganze gehört zum Prinzip der Kapselung, was bedeutet, dass Daten sicher verwaltet werden.\nDu fragst dich vielleicht: Warum nicht einfach alle meine Variablen als public deklarieren? Das klingt doch einfacher, oder? Aber das Problem ist, dass jeder Teil deines Programms dann direkt auf die Daten zugreifen und sie ändern könnte – auch unbeabsichtigt. Mit get- und set-Methoden kannst du kontrollieren, wer auf die Daten zugreifen oder sie verändern darf. Zum Beispiel auch, wenn andere Entwickler auf deinem Code arbeiten. Zum Beispiel: Wenn du nur eine get-Methode ohne set-Methode erstellst, machst du das Datenfeld von ausserhalb nur lesbar – man kann es also nicht ändern.\nNamenskonventionen Für Getter- und Setter-Methoden werden immer die gleichen Methodennamen verwendet. Als Präfix benutzen wir get und set gefolgt vom Namen des Datenfelds worauf sich die Methode bezieht.\n1 2 3 4 5 6 7 8 9 10 11 public class Car { private int speed; public int getSpeed() { return speed; } public void setSpeed(int speed) { this.speed = speed; } } 1 2 3 4 5 6 7 class Demo { public static void main(String[] args) { Car car = new Car(); car.setSpeed(100); System.out.println(car.getSpeed()); } } Methoden überladen In Java können wir Methoden überladen. Das heisst, wir können mehrere Methoden mit demselben Namen definieren, solange die Anzahl an Parametern oder die Datentypen der Parameter variieren. Beim Aufruf der Methode wird vom Compiler die entsprechende Definition ausgewählt.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Calculator { public double product(double x, double y) { return x * y; } // Overloading the function to handle three arguments public double product(double x, double y, double z) { return x * y * z; } // Overloading the function to handle int public int product(int x, int y) { return x * y; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 class Demo { public static void main(String[] args) { Calculator cal = new Calculator(); double x = 10; double y = 20; double z = 5; int a = 12; int b = 4; System.out.println(cal.product(x, y)); System.out.println(cal.product(x, y, z)); System.out.println(cal.product(a, b)); } } Methoden, deren Parameter gleich sind (gleiche Anzahl, gleiche Datentypen) und sich lediglich in ihren Rückgabetypen unterscheiden, können nicht überladen werden, da der Compiler nicht in der Lage ist, zwischen ihren Aufrufen zu unterscheiden.\nDie Methoden equals() und hashCode() Die Methoden equals() und hashCode() sind wichtige Bestandteile der Java-APIs. Sie sind automatisch in jeder Klasse vorhanden, weil sie von der Object-Klasse geerbt werden. Das bedeutet, dass jede Klasse in Java diese beiden Methoden hat, auch wenn du sie nicht selbst hinzufügst. Mehr darüber erfährst du im Modul “Objektorientiertes Design (OOD)”.\nequals() Du hast bereits im Thema String gesehen, dass man mit equals() überprüft, ob zwei Objekte denselben Wert haben. Der Unterschied zu == ist, dass == nur prüft, ob beide Objekte exakt dasselbe sind, also die gleiche Speicheradresse haben. Mit equals() hingegen vergleichst du den Inhalt der Objekte.\nStandardmässig definiert die equals()-Methode in der Object-Klasse, dass zwei Objekte nur dann gleich sind, wenn sie exakt die gleiche Identität haben. Das bedeutet, dass zwei unterschiedliche Objekte derselben Klasse als nicht gleich angesehen werden, selbst wenn alle ihre Felder die gleichen Werte enthalten. Es wird also die Speicheradresse mit == verlgichen:\n1 2 3 4 // Der Code aus der Klasse Object in Java public boolean equals(Object obj) { return (this == obj); } Das passt aber nicht immer, besonders wenn du den Inhalt der Objekte vergleichen möchtest oder du nur spezifische Eigenschaften, wie zum Beispiel eine ID vergleichen möchtest. In diesem Fall musst du die equals()-Methode überschreiben, um die Gleichheit richtig zu definieren.\nBei der Umsetzung müssen folgende Bedingungen für die Definition der Gleichheit bei nicht-null Objekten gemäss API-Definition für equals() erfüllt werden:\nReflexivität: Das Objekt liefert beim Vergleich mit sich selbst true. Symmetrie: Wenn Objekt x gleich Objekt y ist, dann muss y auch gleich x sein. Transivität: Wenn x gleich y ist und y gleich z, dann muss auch x gleich z sein. Konsistenz: Egal wie häufig der Vergleich durchgeführt wird, es kommt immer dasselbe heraus, sofern sich der Inhalt der Objekte nicht verändert. Behandlung von null: Der Vergleich mit null liefert immer false. Eine mögliche Implementierung von equals() für die Klasse Car könnte wie folgt aussehen:\n1 2 3 4 5 6 7 @Override public boolean equals(Object other) { if (this == other) return true; if (other == null || getClass() != other.getClass()) return false; Car car = (Car) other; return speed == car.speed; } (Die Angabe (“Annotation”) von @Override ist freiwillig. Sie wird angegeben, wenn eine bestehende Methode (z.B. von der Klasse Object) überschrieben wird. Diese Angabe bewirkt, dass es ein Kompilierfehler gibt, falls keine bestehende Methode überschrieben wird.)\nDie equals()-Methode kannst du wie eine ganz normale Methode aufrufen, wird aber meistens in einer if-Anweisung verwendet:\n1 2 3 4 5 6 7 8 9 10 11 Car carA = new Car(); carA.setSpeed(3); Car carB = new Car(); carA.setSpeed(4); if (carA.equals(carB)){ System.out.println(\"Both cars are equal.\"); } else { System.out.println(\"The cars are different.\"); } // Output: The cars are different. hashCode() Die Methode hashCode() erstellt für jedes Objekt einen Hashwert – das ist wie ein Fingerabdruck, der das Objekt möglichst eindeutig beschreibt. Dieser Hashwert wird aus den Feldern des Objekts berechnet. Der Hashwert ist eine Zahl, der Rückgabetyp von hashCode ist also ein int.\nFalls du genauer erfahren möchtest, wie Hashing funktioniert, kannst du diesen Beitrag lesen.\nDer Hashwert ermöglicht es Java, Objekte effizient zu vergleichen und zu verwalten. Wichtig ist, dass der Hashwert immer dieselbe Zahl liefert, solange sich das Objekt nicht ändert.\nAuch für diese Methode definiert die API-Definition für hashCode() Bedingungen, welche erfüllt werden müssen, damit die Methode zweckmässig verwendet werden kann:\nKonsistenz: Jedes Mal, wenn hashCode() aufgerufen wird, muss derselbe Wert zurückgegeben werden, solange das Objekt unverändert bleibt. Zusammenhang mit equals(): Zwei Objekte, die gemäss equals() gleich sind, müssen den gleichen Hashwert liefern. Zusammenhang bei ungleichen Objekten: Zwei Objekte die gemäss equals() verschieden sind, müssen nicht zwingend unterschiedliche Hashwerte liefern. Grundsätzlich wäre es aber besser für die Performanz, wenn verschiedene Objekte auch verschiedene Hashwerte liefern würden. Wenn du die Methode equals() überschreibst, solltest du auch hashCode() überschreiben, damit beide zusammen korrekt funktionieren.\nHier ein Beispiel für die Klasse Car, wie eine mögliche hashCode()-Methode aussehen könnte. Hier haben wir 2 weitere Felder aus Demonstrationsgründen hinzugefügt:\n1 2 3 4 5 6 7 8 9 10 public class Car { private int speed; private String brand; private float remainingAmountOfFuel; @Override public int hashCode() { return Objects.hash(speed, brand, remainingAmountOfFuel); } } Oft sieht man statt Objects.hash(...) auch eine eigene Implementation wie die folgende:\n1 2 3 4 5 6 7 @Override public int hashCode() { int result = speed; result = 31 * result + (brand != null ? brand.hashCode() : 0); result = 31 * result + (remainingAmountOfFuel != +0.0f ? Float.floatToIntBits(remainingAmountOfFuel) : 0); return result; } ","categories":"","description":"Modul #J2\n","excerpt":"Modul #J2\n","ref":"/de/docs/02_java/04_java-oop/08_methods/","tags":"","title":"Instanzmethoden"},{"body":"","categories":"","description":"Exercises zu Modul #J4 - Testing\n","excerpt":"Exercises zu Modul #J4 - Testing\n","ref":"/labs/02_java/08_java-testing/","tags":"","title":"Java Exercises - Testing"},{"body":"","categories":"","description":"Exercises zu Modul #J4 - Testing\n","excerpt":"Exercises zu Modul #J4 - Testing\n","ref":"/de/labs/02_java/08_java-testing/","tags":"","title":"Java Exercises - Testing"},{"body":" Dieses Kapitel gehört zum Modul #J1 des Ausbildungsplans Ziele Ich weiss, wofür Methoden da sind. Ich kenne den Aufbau einer Methode. Ich weiss, wie Parameter an eine Methode übergeben werden. Ich weiss, wie eine Methode einen Wert zurückgibt. Ich kann Methoden gezielt in meinem Programm einsetzen. ⏱️ Geschätzte Lesezeit: 15 Minuten Was sind Methoden? In Java sind Methoden benannte Codeblöcke, die eine bestimmte Aufgabe ausführen. Sie helfen, Programme besser zu strukturieren und wiederverwendbaren Code zu schreiben.\nWenn du die bisherigen Aufgaben anschaust, welche du gelöst hast, wirst du feststellen, dass dort deine Anpassungen immer in einem benannten CodeBlock war. Du hast also schon die ganze Zeit Methoden angepasst und benutzt. Methoden ermöglichen:\ndas Bündeln von Anweisungen zu einer klaren Funktionalität das Ausführen dieser Funktionalität durch einen einfachen Aufruf eine saubere Trennung einzelner Aufgaben im Programm Aufbau einer Methode Eine Methode besteht aus einem Methodenkopf und einem Rumpf:\n1 2 3 public static Rückgabetyp methodName(Parameterliste) { // Anweisungen } public static: Gibt an, dass die Methode überall und immer genutzt werden darf (darauf gehen wir später genauer ein) Rückgabetyp: Gibt an, welcher Datentyp zurückgegeben wird (int, String, …). Wird nichts zurückgegeben, nutzt man void. methodName: Der Name der Methode – über diesen wird sie aufgerufen. Parameterliste: Liste von Eingabewerten, die die Methode beim Aufruf erwartet. Anweisungen: Der Code, der ausgeführt wird, wenn die Methode aufgerufen wird. Methoden mit Parametern Methoden können Parameter (Eingabewerte) erwarten:\n1 2 3 public static void greetUser(String name) { System.out.println(\"Hallo, \" + name + \"!\"); } Diese Methode erhält einen String-Parameter name und gibt eine Begrüssung aus.\nLernvideo Wenn du dir die Erklärung noch mit einem Video anschauen möchtest, empfehlen wir dir dieses Video (YouTube, Methoden einfach erklärt). Methoden ohne Parametern Methoden können auch ohne Parameter definiert werden:\n1 2 3 public static void sayGoodBye() { System.out.println(\"Good Bye!\"); } Diese Methode hat keinen Parameter und gibt einfach einen Text aus.\nMethoden mit Rückgabewert Methoden können auch Werte zurückgeben:\n1 2 3 public static int add(int a, int b) { return a + b; } Diese Methode addiert zwei Zahlen und gibt die Summe zurück.\nDu kannst diese Methode so aufrufen:\n1 int result = add(17, 10); // Variable result will be 27 afterwards Lernvideo Wenn du dir die Erklärung noch mit einem Video anschauen möchtest, empfehlen wir dir dieses Video (YouTube, Methoden mit Rückgabewert). Methoden ohne Rückgabewert (void) Wenn eine Methode keinen Wert zurückgeben soll, verwendest du den Rückgabetyp void.\nSolche Methoden führen Anweisungen aus, ohne ein Ergebnis an den Aufrufer zurückzugeben – z. B. eine Ausgabe oder das Setzen eines Wertes.\n1 2 3 public static void greet() { System.out.println(\"Hallo!\"); } Du kannst diese Methode so aufrufen:\n1 greet(); Wozu brauche ich Methoden? Methoden bringen viele Vorteile:\nWiederverwendbarkeit: Einmal schreiben, beliebig oft nutzen. Reduktion von Code-Duplikaten: Weniger Fehler, einfachere Wartung. Lesbarkeit: Durch sprechende Namen versteht man den Code schneller. Strukturierung: Jede Methode übernimmt eine klar abgegrenzte Aufgabe. Beispiel: Division ohne Methoden Ohne Methoden wiederholen sich Prüfungen und Ausgaben:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public static void main(String[] args) { Random random = new Random(); int a = random.nextInt(11); int b = random.nextInt(11); int c = random.nextInt(11); if (b != 0) { int result1 = a / b; if (c != 0) { int result2 = result1 / c; System.out.println(\"Ergebnis: \" + result2); } else { System.out.println(\"Division durch 0 nicht erlaubt.\"); } } else { System.out.println(\"Division durch 0 nicht erlaubt.\"); } } ⚠️ Gleicher Code mehrfach und verschachtelte Blöcke → schlecht wartbar.\nBeispiel: Division mit Methoden Eleganter und übersichtlicher mit einer Methode:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public static void main(String[] args) { Random random = new Random(); int a = random.nextInt(11); int b = random.nextInt(11); int c = random.nextInt(11); int result1 = divide(a, b); int result2 = divide(result1, c); System.out.println(\"Ergebnis: \" + result2); } public static int divide(int numerator, int denominator) { if (denominator == 0) { System.out.println(\"Division durch 0 nicht erlaubt.\"); return 0; } return numerator / denominator; } ✅ Nur eine zentrale Prüfung\n✅ Verständlicher Code\n✅ Wiederverwendbare Methode\nNamenskonventionen für Methoden und Parameter Methoden Beim Benennen von Methoden beachtest du folgende Regeln:\nDer Name beginnt mit einem Kleinbuchstaben. Er besteht aus mehreren sinnvollen Wörtern im camelCase (z. B. calculateTotal). Der Name beschreibt eine Aktion oder Aufgabe (z. B. printText, getUserName). Vermeide Abkürzungen, ausser sie sind allgemein verständlich (z. B. id, url). Parameter sind benannte Eingabewerte von Methoden. Für sie gelten die gleichen Regeln wie bei Variablen Beispiele:\n1 2 3 public static void calculateTaxes(double income) { ... } public static String formatDate(LocalDate date) { ... } public static void printReport(String title, int pageCount) { ... } Die Regeln zur Benennung von Methoden und Parametern sind Teil unserer Coding Guidelines. Du findest die vollständige Richtlinie für Java hier. Rekursive Methoden Eine Methode kann sich selbst aufrufen – das nennt man Rekursion.\nDas ist besonders hilfreich, wenn sich ein Problem in gleichartige Teilprobleme zerlegen lässt.\nBeispiel: Fakultät berechnen (n! = n * (n-1) * (n-2) * ... * 1)\n1 2 3 4 public static int factorial(int n) { if (n \u003c= 1) return 1; return n * factorial(n - 1); } Ablauf bei factorial(3):\n1 2 3 4 → factorial(3) → 3 * factorial(2) → 3 * 2 * factorial(1) → 3 * 2 * 1 → ergibt 6 Jede Rekursion braucht eine Abbruchbedingung, sonst ruft sich die Methode endlos selbst auf – und das führt zu einem Fehler (“Stack Overflow”).\nVielleicht erinnerst du dich noch an die Erklärung von Stack und Heap. Der Stack wird benutzt, um Parameter an eine Methode zu übergeben. Sie bleiben dort, bis die Methode zurückkehrt. Bei Rekursion kommen immer wieder neue Parameter auf den Stack, ohne dass sie wieder freigegeben werden. Das führt dann innert kurzer Zeit dazu, dass es keinen Platz mehr auf dem Stack hat und es zum sogenannten “Stack Overflow” kommt. Es können dann keine Methoden mehr aufgerufen werden und das Programm wird beendet.\nAufruf fremder Methoden Methoden werden immer einer “Klasse” zugeordnet:\n1 2 3 4 5 6 public class EineKlasse { public static void eineMethode() { System.out.println(\"Ich mach mal was...\"); } } In anderen Methoden in derselben “Klasse” können sie direkt aufgerufen werden:\n1 2 3 4 5 6 7 8 9 10 11 public class EineKlasse { public static void eineMethode() { System.out.println(\"Ich mach mal was...\"); } public static void eineAndereMethode() { eineMethode(); System.out.println(\"... und mach noch was anderes.\"); } } Der Name einer Methode muss innerhalb der gleichen Klasse eindeutig sein:\n1 2 3 4 5 6 7 8 9 10 11 public class EineKlasse { public static void eineMethode() { System.out.println(\"Ich mach mal was...\"); } public static void eineMethode() { // \u003c- Compiler-Error... 2 Methoden mit gleichem Namen eineMethode(); System.out.println(\"... und mach noch was anderes.\"); } } Ist die Methode in einer anderen “Klasse”, muss man den Namen der Klasse angegen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class EineKlasse { public static void eineAndereMethode() { EineAndereKlasse.eineMethode(); System.out.println(\"... und mache noch was anderes.\"); } } public class EineAndereKlasse { public static void eineMethode() { System.out.println(\"Ich mache AUCH was...\"); } public static void eineAndereMethode() { eineMethode(); System.out.println(\"... und mache noch was anderes.\"); } } Ist die Methode in einer anderen “Klasse”, darf der Name gleich sein. Durch den Namen der “Klasse” ist immer klar, welche Methode aufgerufen werden soll. Ist keine “Klasse” angegeben, wird immer die Methode aus derselben “Klasse” genommen. Lokale und statische Variablen Bis jetzt hast du Variablen immer innerhalb einer Methode genutzt. Die bezeichnet man genau genommen als lokale Variablen.\nLokale Variablen werden innerhalb einer Methode deklariert und existieren nur während der Ausführung dieser Methode. Statische Variablen gehören zur Klasse und behalten ihren Wert zwischen mehreren Methodenaufrufen. Beispiel:\n1 2 3 4 5 6 7 8 9 public class Demo { private static int calls = 0; // statische Variable public static void sayHello() { calls = calls + 1; // Zugriff auf die statische Variable String message = \"Hallo\"; // lokale Variable System.out.println(message + \" #\" + calls); } } In diesem Beispiel:\nmessage ist eine lokale Variable: Sie existiert nur innerhalb von sayHello() und wird bei jedem Aufruf neu erstellt.\ncalls ist eine statische Variable: Sie merkt sich, wie oft die Methode aufgerufen wurde – auch über mehrere Aufrufe hinweg.\nJetzt bist du dran. Löse bitte die folgenden !*Aufgaben in den Labs. ","categories":"","description":"In diesem Modul lernst du, wie du Methoden in Java definierst, Parameter übergibst und Rückgabewerte nutzt.\n","excerpt":"In diesem Modul lernst du, wie du Methoden in Java definierst, …","ref":"/docs/02_java/03_java-grundlagen/08_methods/","tags":"","title":"Methoden"},{"body":" Voraussetzung Wir stellen dir bei den Übungen jeweils komplette Projekte zur Verfügung. Du musst grundsätzlich nur dort was anpassen, wo die folgende Kommentarzeile steht:\nKopieren // IT-Ninja: Füge hier Deinen Code ein: 1 // IT-Ninja: Füge hier Deinen Code ein: Alles andere kannst du für den Moment ignorieren. Wir erklären dir die einzelnen Zeilen Schritt für Schritt in den Modulen.\nVorbereitungsarbeiten Drücke auf den Pfeil links um eine detaillierte Anleitung zu erhalten, wie Du den Quellcode auf deinem Rechner ablegen sollst.\nDiese Schritte musst du bei jeder Übung erneut machen. Jede Übung hat ein eigenes ZIP-File, welches du bei dir an die richtige Stelle kopieren musst. Die Anleitung zeigt dir ziemlich gut, wie das geht… Liess vor allem am Anfang die detaillierte Anleitung gut durch und befolge die Schritte exakt. Sie helfen dir, deinen Quellcode gut organisiert, strukturiert und sicher zu verwalten. Falls du die Anleitung schon auswendig kennst, findest du den Quellcode zur Übung direkt hier: Download | Online anschauen\nNeu bei it-ninja?\nDie Anleitung enthält einige Befehle und Fachbegriffe, die dir möglicherweise noch nichts sagen. Mach dir deswegen keine Sorgen – in den kommenden Modulen erklären wir dir alles Schritt für Schritt. Schon bald wirst auch du ein it-ninja sein. Um die folgenden Aufgaben erfolgreich umzusetzen, führe diese Schritte aus:\nBeim ersten Mal:\nIntelliJ IDEA installieren → !*IntelliJ IDEA einrichten Git-Repository einrichten → !*Persönliches Git-Repository Öffne eine !*CMD-Shell und wechsle ins Verzeichnis deines Git-Repositories:\nKopieren cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git status 1 2 cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git status Kopieren cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git status 1 2 cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git status Stelle sicher, dass alle Dateien im Git-Repository committed sind. Mit git status erhältst du eine Übersicht: Kopieren git status 1 git status Falls du bei diesem Befehl einen roten Text siehst, musst du zuerst die aktuellen Dateien sichern:\nKopieren git add . git commit -m \"[gescheiter Kommentar]\" 1 2 git add . git commit -m \"[gescheiter Kommentar]\" Erstelle oder wechsle in den Template Branch:\nBeim ersten Mal musst du einen Template Branch erstellen:\nKopieren git checkout -b \"templates\" 1 git checkout -b \"templates\" Falls er bereits existiert, kannst du einfach switchen:\nKopieren git switch \"templates\" 1 git switch \"templates\" Lade den Source-Code zu den Übungen herunter und entpacke ihn im Root-Verzeichnis deines lokalen Repositories:\n[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\nDen Source-Code findest du hier: Download | Online anschauen\nCommitte den originalen Source-Code, damit er sicher im Repository gespeichert ist:\nKopieren git add . git commit -m \"Add it-ninja_02_java_03_java-grundlagen_08_methods\" git push 1 2 3 git add . git commit -m \"Add it-ninja_02_java_03_java-grundlagen_08_methods\" git push Erstelle einen neuen Branch, um deine Lösung zu implementieren: Kopieren git checkout -b \"labs/it-ninja_02_java_03_java-grundlagen_08_methods\" 1 git checkout -b \"labs/it-ninja_02_java_03_java-grundlagen_08_methods\" Hier kannst du auch einen kürzeren Namen wählen. Verwende labs am Anfang des Branch-Namens für Branches, die deinen eigenen Code enthalten.\nStelle dir einen Branch vorerst als Ordner vor. Jeder Ordner enthält eine Version oder einen Stand von deinem Quellcode. Du kannst dann mit git zwischen diesen Ordern hin und her wechseln, sie vergleichen aber später auch zusammenführen.\nPro-Tipp:\nDu kannst jederzeit einen weiteren Branch erstellen – z. B. wenn du etwas ausprobieren möchtest. Alternativ kannst du auch in der Git-History einen alten Stand wiederherstellen, was aber weniger flexibel ist. Starte IntelliJ und öffne mit File → Open das Verzeichnis mit dem Source-Code. Du musst mit IntelliJ den Ordner suchen, welches einen Ordner src oder die Datei pom.xml enthält. Ansonsten wird IntelliJ Mühe haben, dir das Programm zu kompilieren. Wenn du alles korrekt gemacht hast, findest du das Projekt hier:\nKopieren `[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\\02_java\\03_java-grundlagen\\08_methods` 1 `[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\\02_java\\03_java-grundlagen\\08_methods` Kopieren `[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\\02_java/03_java-grundlagen/08_methods` 1 `[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\\02_java/03_java-grundlagen/08_methods` Falls du zum ersten Mal mit IntelliJ arbeitest, findest du !*hier eine Anleitung, wie man ein Programm startet. Um das Programm zu starten musst du jeweils die Datei Main.java öffenen. Dann sollte in IntelliJ oben rechts ein grünes Dreieck vorhanden sein, welches das Programm startet. Nun bist du bereit, die untenstehenden Aufgaben zu lösen.\nWenn du alle Änderungen gemacht hast und mit der Übung fertig bist, oder einen ‘Zwischenstand’ festhalten willst, führe die folgenden Befehle aus um das Repository auf dem Server zu speichern (von wo du es geklont hast):\nKopieren cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git add --all git commit -m \"Kurzer Kommentar\" 1 2 3 cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git add --all git commit -m \"Kurzer Kommentar\" Kopieren cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git add . git commit -m \"Kurzer Kommentar\" 1 2 3 cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git add . git commit -m \"Kurzer Kommentar\" Wenn du deine Änderungen auf dem Git-Server sichern willst, musst du das mit einem push machen.\nBeim ersten mal musst du git noch mitteilen, wie der Branch auf dem Git-Server heissen soll:\nKopieren git push --set-upstream origin labs/it-ninja_02_java_03_java-grundlagen_08_methods 1 git push --set-upstream origin labs/it-ninja_02_java_03_java-grundlagen_08_methods Bei weiteren pushes wird es dann einfacher:\nKopieren git push 1 git push Die meisten Übungen sind professionell strukturiert – so wie in echten Softwareprojekten. Zu gutem Code gehören auch Tests, die sicherstellen, dass dein Code wie erwartet funktioniert. Sofern nicht anders erwähnt, kannst du mit folgendem Befehl im Root-Verzeichnis des Projekts (dort, wo sich auch die pom.xml befindet) überprüfen, ob du die Aufgabe korrekt gelöst hast:\n1 mvn test Viel Erfolg!\nAufgabe 1: Nachricht drucken Passe untenstehenden Quellcode an und füge folgende Methode hinzu:\nName der Methode: Bestimme selber einen passenden Namen für die Methode\nFunktion: Gibt eine Nachricht auf der Konsole aus, Format: Nachricht an [Name des Empfängers]: [Nachricht]\nParameter1: Name des Empfängers [String]\nParameter2: Nachricht [String]\nRückgabewert: Keiner\nHalte die Coding Guidelines ein!\nIm zur Übung gehörendem Source kannst Du die Änderung an folgender Stelle machen:\nsrc\\main\\java\\ch\\itninja\\labs\\basicexercises\\MessageHelper.java:\n1 2 3 4 public class MessageHelper { // IT-Ninja: Füge hier Deinen Code ein: } Wenn du die Methode implementiert hast, kannst du sie aus main aufrufen.\nIm zur Übung gehörendem Source kannst Du die Änderung an folgender Stelle machen:\nsrc\\main\\java\\ch\\itninja\\labs\\Main.java:\n1 2 3 4 5 6 7 8 9 10 11 public static void main(String[] args) { // Sample call for \"Nachricht drucken\" // IT-Ninja: Füge hier Deinen Code ein: // Sample call for \"Minimum von drei Zahlen\" // IT-Ninja: Füge hier Deinen Code ein: // Sample call for \"Fibonacci\" // IT-Ninja: Füge hier Deinen Code ein: } Falls du sie testen willst, kannst du sie aus dem vorbereiteten Test aufrufen.\nIm zur Übung gehörendem Source kannst Du die Änderung an folgender Stelle machen:\nsrc\\test\\java\\ch\\itninja\\labs\\basicexercises\\MessageHelperTest.java:\n1 2 3 4 5 6 7 try { // WHEN // Aufruf der Methode, welche wir testen wollen (etwas wie: methode(name, message);): // IT-Ninja: Füge hier Deinen Code ein: } finally { System.setOut(originalOut); } Beispiel 1:\nEingabe:\n1 yourImplementation(\"Peter\", \"Das Meeting beginnt um 9 Uhr.\"); Ausgabe:\n1 Nachricht an Peter: Das Meeting beginnt um 9 Uhr. Beispiel 2:\nEingabe:\n1 yourImplementation(\"Linda\", \"Bitte rufe Hans Mustermann zurück.\"); Ausgabe:\n1 Nachricht an Linda: Bitte rufe Hans Mustermann zurück. Aufgabe 2: Minimum von drei Zahlen Passe untenstehenden Quellcode an und füge folgende Methode hinzu:\n**Name der Methode: Bestimme selber einen passenden Namen für die Methode\nFunktion: Gibt die kleinste von 3 Zahlen zurück\nParameter1: Erste Zahl [int]\nParameter2: Zweite Zahl [int]\nParameter3: Dritte Zahl [int]\n**Rückgabewert:** Kleinste der 3 Zahlen [int]\nHalte die Coding Guidelines ein!\nIm zur Übung gehörendem Source kannst Du die Änderung an folgender Stelle machen:\nsrc\\main\\java\\ch\\itninja\\labs\\basicexercises\\NumberHelper.java:\n1 2 3 4 public class NumberHelper { // IT-Ninja: Füge hier Deinen Code ein: } Wenn du die Methode implementiert hast, kannst du sie aus main aufrufen.\nIm zur Übung gehörendem Source kannst Du die Änderung an folgender Stelle machen:\nsrc\\main\\java\\ch\\itninja\\labs\\Main.java:\n1 2 3 4 5 6 7 8 9 10 11 public static void main(String[] args) { // Sample call for \"Nachricht drucken\" // IT-Ninja: Füge hier Deinen Code ein: // Sample call for \"Minimum von drei Zahlen\" // IT-Ninja: Füge hier Deinen Code ein: // Sample call for \"Fibonacci\" // IT-Ninja: Füge hier Deinen Code ein: } Falls du sie testen willst, kannst du sie aus dem vorbereiteten Test aufrufen.\nIm zur Übung gehörendem Source kannst Du die Änderung an folgender Stelle machen:\nsrc\\test\\java\\ch\\itninja\\labs\\basicexercises\\NumberHelperTest.java:\n1 2 3 4 5 6 try { // WHEN // Aufruf der Methode, welche wir testen wollen (etwas wie: min = methode(a, b, c);): // IT-Ninja: Füge hier Deinen Code ein: } finally { } Beispiel 1:\nEingabe:\n1 min = yourImplementation(63, 22, 98); Ausgabe:\n1 Example Output: The minimum from 63, 22 and 98 is 22. Beispiel 2:\nEingabe:\n1 min = yourImplementation(17, 67, 32); Ausgabe:\n1 Example Output: The minimum from 17, 67 and 32 is 17. Beispiel 3:\nEingabe:\n1 min = yourImplementation(4, 56, 3); Ausgabe:\n1 Example Output: The minimum from 4, 56 and 3 is 3. Aufgabe 3: Fibonacci Passe untenstehenden Quellcode an und füge folgende Methode hinzu:\nName der Methode: Bestimme selber einen passenden Namen für die Methode\nFunktion: Berechnet die n-te Zahl der Fibonacci-Folge.\nParameter1: n [int]\nRückgabewert: n-te Zahl der Fibonacci-Folge [int]\nAbgrenzung: Gibt -1 zurück, wenn Fibonacci-Folge ausserhalb des Wertebreichs von int ist.\nInformationen zur Fibonacci-Folge findest du hier.\nHalte die Coding Guidelines ein!\nIm zur Übung gehörendem Source kannst Du die Änderung an folgender Stelle machen:\nsrc\\main\\java\\ch\\itninja\\labs\\basicexercises\\FibonacciHelper.java:\n1 2 3 4 public class FibonacciHelper { // IT-Ninja: Füge hier Deinen Code ein: } Wenn du die Methode implementiert hast, kannst du sie aus main aufrufen.\nIm zur Übung gehörendem Source kannst Du die Änderung an folgender Stelle machen:\nsrc\\main\\java\\ch\\itninja\\labs\\Main.java:\n1 2 3 4 5 6 7 8 9 10 11 public static void main(String[] args) { // Sample call for \"Nachricht drucken\" // IT-Ninja: Füge hier Deinen Code ein: // Sample call for \"Minimum von drei Zahlen\" // IT-Ninja: Füge hier Deinen Code ein: // Sample call for \"Fibonacci\" // IT-Ninja: Füge hier Deinen Code ein: } Falls du sie testen willst, kannst du sie aus dem vorbereiteten Test aufrufen.\nIm zur Übung gehörendem Source kannst Du die Änderung an folgender Stelle machen:\nsrc\\test\\java\\ch\\itninja\\labs\\basicexercises\\FibonacciHelperTest.java:\n1 2 3 4 5 6 try { // WHEN // Aufruf der Methode, welche wir testen wollen (etwas wie: fibonacci = methode(n);): // IT-Ninja: Füge hier Deinen Code ein: } finally { } Beispiel 1:\nEingabe:\n1 fibonacci = yourImplementation(0); Ausgabe:\n1 Example Output: The 0. element of the Fibonacci sequence is 0. Beispiel 2:\nEingabe:\n1 fibonacci = yourImplementation(1); Ausgabe:\n1 Example Output: The 1. element of the Fibonacci sequence is 1. Beispiel 3:\nEingabe:\n1 fibonacci = yourImplementation(2); Ausgabe:\n1 Example Output: The 2. element of the Fibonacci sequence is 1. Beispiel 4:\nEingabe:\n1 fibonacci = yourImplementation(7); Ausgabe:\n1 Example Output: The 7. element of the Fibonacci sequence is 13. Beispiel 5:\nEingabe:\n1 fibonacci = yourImplementation(-5); Ausgabe:\n1 Example Output: The -5. element of the Fibonacci sequence is 0. Beispiel 6:\nEingabe:\n1 fibonacci = yourImplementation(100); Ausgabe:\n1 Example Output: The 100. element of the Fibonacci sequence is -1. ","categories":"","description":"Mit diesen Übungen kannst du dein Wissen über Methoden vertiefen.\n","excerpt":"Mit diesen Übungen kannst du dein Wissen über Methoden vertiefen.\n","ref":"/labs/02_java/03_java-grundlagen/08_methods/","tags":"","title":"Java Exercises - Methoden"},{"body":"Schritt 1: Maven-Projekt erstellen / pom.xml In diesem ersten Schritt wirst du eine Spring Boot Anwendung erstellen und ausführen. Hier stehen dir zwei Möglichkeiten für die Umsetzung zur Verfügung:\nDie Projektstruktur manuell anzulegen (#Hard-Core-Variante) Die Projektstruktur mit Spring-Initializr anlegen (#Easy-Going-Variante) Beide Möglichkeiten werden in dieser Aufgabe aufgeführt.\nVoraussetzungen (was du brauchst) Java 20 oder neuer ist installiert. Maven 3.5 oder neuer ist installiert. IntelliJ ist installiert und konfiguriert. Ein Bitbucket Repository steht bereit, um den Code des Projektes zu verwalten und ist auf der lokalen Maschine geklont worden. Variante I: Projekt manuell anlegen Erstelle ein Maven-Projekt in IntelliJ Öffne IntelliJ und erstelle ein neues Maven-Projekt (File → New → Project): Ersetze GroupId, ArtifactId, Name und Location durch passende Werte.\nPasse dein pom.xml File an Füge den “Parent” und folgende Dependencies und Maven-Plugins in deine pom.xml Datei hinzu:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \u003c!-- Parent kommt normalerweise nach der modelVersion --\u003e \u003cparent\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-parent\u003c/artifactId\u003e \u003cversion\u003e3.1.5\u003c/version\u003e \u003crelativePath/\u003e \u003c!-- lookup parent from repository --\u003e \u003c/parent\u003e \u003c!-- Dependencies kommen normalerweise nach den Properties --\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c!-- Build kommen normalerweise nach den Dependencies --\u003e \u003cbuild\u003e \u003cplugins\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-maven-plugin\u003c/artifactId\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c/build\u003e Lade alle Dependencies erneut (Maven-View -\u003e Reload all maven projects).\nErsetze die Main Klasse mit einer Spring Boot Applikation Klasse Wenn du beim Erstellen des Projektes “add sample code” angekreuzt hast, beinhaltet dein Projekt nun eine Main-Klasse in deinem Source-Folder (im richtigen Package selbstverständlich). Diese Main Klasse werden wir nun in einer SpringBootApplication-Klasse umwandeln:\nBenenne die Main Klasse um, so dass sie \u003cname-deines-artefaktes\u003eApplication heisst (z.B. wenn dein Artefakt “demo” heisst, wird die Klasse nun “DemoApplication” heissen). Füge die Annotation @SpringBootApplication auf der Klassenebene hinzu Passe deine main Methode an, so dass sie wie folgt aussieht (Ersetzte DemoApplication mit deinem Application-Klassennamen): 1 2 3 public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } Zuletzt solltest du noch deine Projektstruktur überprüfen. Diese sollte wie folgt aussehen: Gratuliere! Du hast nun dein Projekt angelegt, und zwar Hard-Core. Bravo! Fahre nun mit dem Schritt “Führe deine Anwendung aus” fort.\nVariante II: Projekt mit Spring-Initializr anlegen Öffne die Seite: https://start.spring.io/ und ersetzte die Angaben zu Group, Artifact (der Name wird sich automatisch ändern) und Description durch passende Werte. Achte das bei Project “Maven” ausgewählt ist und nicht Gradle. Füge die Abhängigkeit für “Spring Web” hinzu und drücke den “GENERATE” Knopf. Entpacke das heruntergeladene Zip-File in deinem Repository-Verzeichnis und öffne die Anwendung als Maven-Projekt in IntelliJ: File → New → Project from existing sources → Zum Root-Folder des Projektes navigieren und pom.xml auswählen.\nFühre deine Anwendung aus Öffne deine Application-Klasse (normalerweise heist sie Application). Wenn du Spring-Initializr benutzt hast, wurde diese Klasse für dich automatisch erstellt. Starte deine Anwendung mit der Default-Run-Konfiguration. Zu diesem Zweck kannst du die Application-Klasse öffnen und die Main-Methode ausführen.\nNach dem Start sollte die Run-Konsole wie folgt aussehen: Schritt 2: Rest Schnittstellen definieren und umsetzen In diesem Schritt geht es darum die Schnittstellen (die API) zur Anwendung zu definieren. Über diese Schnittstellen können die Benutzer:innen die gewünschten Aktionen ausführen\nSystem-Design erstellen und Code Struktur anlegen Damit du den Code gemäss den nicht-funktionalen Anforderungen (NFA) aufbauen kannst, überlege dir zuerst, wie du deine Anwendung zerlegen möchtest.\nDazu kannst du die Schritte der Methodik “functional decomposition” anwenden (mehr Information zur Methode findest du in diesem Artikel).\nBei der Zerlegung des Systems beachte auch Prinzipien wie Kohäsion (starke Kohäsion ist gewünscht) und Kopplung (lose Kopplung sollte das Ziel sein).\nAufgabe\nSobald du die Zerlegung deiner Anwendung gemacht hast, kannst du die passende Java-Packages erstellen, welche diese Zerlegung dann abbildet. Dein Code fügst du später an den richtigen Stellen hinzu.\nREST-Schnittstelle definieren Die Struktur für deine Anwendung steht. Nun definierst du die Schnittstellen, womit die Benutzer:innen mit der Anwendung interagieren werden. Die nötige Funktionalität entnimmst du aus den funktionalen Anforderungen.\nBeispiel: Anforderung - ein neues Schulfach hinzufügen\nDie entsprechende Schnittstelle könnte entsprechend so aussehen:\nBeschreibung Http-Methode URL Request-Body Beispiel Path-Variable Response-Body Beispiel Neues Schulfach hinzufügen POST /admin/schulfaecher {“name”: “Physik”} keine {“id”: 3, “name”: “Physik”} Dort, wo ein Request-Body und/oder ein Response-Body benötigt wird, wird mit JSON-Objekten gearbeitet. Diese JSON-Objekte werden wir im nächsten Abschnitt verwenden, um die Resource-Representation Klassen zu erzeugen.\nAufgabe\nErweitere die oben stehende Tabelle mit den restlichen Funktionen gemäss den funktionalen Anforderungen. Buche sobald du fertig bist ein Review mit einem Praxisbildner, damit spätere Fehler vermieden werden.\nWichtig Endpunkt für Profil: Vergiss nicht, dass du noch einen Endpunkt erstellen musst, um herauszufinden, mit welchem Profil die Anwendung gestartet wurde.\nResource-Representation Klassen erstellen Unsere Schnittstellendefinition verwendet JSON-Objekte bei bestimmten Requests und Responses. Diese JSON-Objekte stellen sog. “Resource” dar. Im Beispiel “Neues Schulfach hinzufügen” stellt das JSON-Objekt ein Schulfach dar.\nIn diesem Abschnitt wirst du für alle JSON-Objekte entsprechende Java-Klassen erstellen. Das sind sogenannte Resource-Representation Klassen, auch Modelle genannt.\nIn unserer Anwendung werden wir die Resource-Representation Klassen als sog. DTOs (Data Transfer Objects) umsetzen. Diese Klassen wirst du später in deinen Controllern verwenden.\nBeispiel: Schulfach Resource-Representation\nDas folgende JSON-Objekt stellt ein Schulfach dar:\n1 2 3 4 { \"id\": 1, \"name\": \"Deutsch\" } Daraus können wir unsere DTO-Klasse erstellen (vorerst nur mit Feldern und noch keine weitere Funktionalität):\n1 2 3 4 public class SchulfachDto { private final Long id; private final String name; } Aufgabe\nErstelle für jedes JSON-Objekt aus dem vorherigen Abschnitt eine DTO-Klasse. Denke daran die Klassen in die richtigen Packages zu setzen.\nController erstellen In Spring werden HTTP Requests an REST-Services von Controllern behandelt. Das ist eine Java-Klasse, welche mit @RestController annotiert wird. Controller sind also die Umsetzung unserer Schnittstellendefinition. Da wir noch keine persistierten Daten haben, wirst du vorerst Mockdaten aus den Schnittstellenmethoden liefern müssen.\nBeispiel: Controller für die Schulfachverwaltung\n1 2 3 4 5 6 7 8 9 10 11 12 @RestController @RequestMapping(\"/api/admin\") public class SchulfachAdminController { @PostMapping(\"/schulfaecher\") public SchulfachDto createNewSchulfach(@RequestBody SchulfachDto newSchulfach) { // TODO: Das sind Mockdaten und sollten zu einem späteren Zeitpunkt mit \"echtem\" Code ersetzt werden return new SchulfachDto(3, \"Physik\"); } // hier können weitere Methoden der Schnittstelle umgesetzt werden } Aufgabe\nErstelle Controller und Methoden (mit Mockdaten), um die Umsetzung deiner Schnittstellen abzuschliessen.\nSchritt 3: Services anlegen Service-Klassen erstellen In diesem Schritt wird ein komplett neuer Layer angelegt, welcher die Business-Logik der Applikation enthalten wird. Er ist zuständig für Aufgaben wie Exception-Handling und Validierung. Dieser Layer wird Service-Layer genannt. Service-Klassen werden grundsätzlich mit der Annotation @Service annotiert. Diese Annotation ist eine der möglichen Spezialisierungen eines Spring Components.\nDie möglichen Annotationen für einen Spring Component sind die folgenden:\n@Component @Controller @Service @Repository Mehr Informationen zu diesen Annotationen findest auf dieser Seite.\nIm folgenden Beispiel wird nun eine Service-Klasse angelegt, welche den vom Controller empfangenen Request-Body als Parameter entgegennimmt und diesen dann später weiter verarbeiten wird. Im Moment begnügen wir uns damit die Mock-Daten aus dem Controller hierher zu verschieben.\nBeispiel: Service für die Schulfachverwaltung\n1 2 3 4 5 6 7 8 9 10 @Service public class SchulfachAdminService { public SchulfachDto createNewSchulfach(SchulfachDto newSchulfach) { // TODO: Dies sind die Mock-Daten aus dem Controller, sie werden später durch richtige Daten ersetzt return new SchulfachDto(3, \"Physik\"); } // hier können weitere Methoden des Services umgesetzt werden } Aufgabe\nErstelle die nötigen Service-Klassen mit entsprechenden Methoden und verschiebe die Mock-Daten aus den Controllern in die Service-Methoden. Versuche die Methoden, welche das gleiche fachliche Thema behandeln im gleichen Service unterzubringen. Denke daran, die Service-Klassen in das richtige Package zu setzen.\nService-Klassen und Controller verbinden Nun ist es an der Zeit, die erstellten Controller- und Service-Klassen miteinander zu verbinden. Dazu nutzen wir die Dependency Injection. Controller- und Service-Klassen werden durch ihre Annotationen als Spring-Components erkannt und durch den Spring Container instanziiert. Die Injection eines Service in einen Controller kann beispielsweise durch eine Constructor-Injection erfolgen. Durch diese Art von Implementation holt sich der Controller den Service aus dem Container selbst. Die Methoden von dem Controller leiten nun ihre Anfragen an die entsprechenden Service-Klassen weiter.\nBeispiel: Constructor-Injection\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @RestController @RequestMapping(\"/api/admin\") public class SchulfachAdminController { private final SchulfachAdminService schulfachAdminService; public SchulfachAdminController(SchulfachAdminService schulfachAdminService) { this.schulfachAdminService = schulfachAdminService; } @PostMapping(\"/schulfaecher\") public SchulfachDto createNewSchulfach(@RequestBody SchulfachDto newSchulfach) { return this.schulfachAdminService.createNewSchulfach(newSchulfach); } // ... } Aufgabe\nVerbinde die erstellten Controller-Klassen mit den entsprechenden Services. Leite sämtliche Anfragen aus den Controllern an die Service-Methoden weiter. Die ursprünglich erstellten Tests sollten immer noch erfolgreich ausführbar sein.\nSchritt 4: Datenbank-Verbindung herstellen Repository-Klassen erstellen In diesem Schritt wird erneut ein komplett neuer Layer angelegt, welcher die Verbindung der Applikation zu einer Datenbank aufbauen wird. Dieser Layer wird Persistenz-Layer genannt. Repository-Klassen werden grundsätzlich mit der Annotation @Repository annotiert.\nDie Verbindung zu einer Datenbank kann auf verschiedene Arten realisiert werden. In diesem Kapitel werden wir auf JPA oder JDBCTemplate eingehen.\nMöglichkeit 1: JPA-Repository mit Spring Data Möglichkeit 1: JPA-Repository mit Spring Data Bei dieser Variante wird die Jakarta Persistence API (JPA) mit Spring Data verwendet. Sie ermöglicht die automatische Generierung von Queries durch die Deklaration eines entsprechenden Methodennamens. Dies bedeutet, dass der Methodenname zugleich ein Datenbank-Query darstellt.\nDamit diese Möglichkeit der Implementation überhaupt besteht, müssen zuerst sogenannte Entitäten angelegt werden. Eine Entität ist in Java das Abbild einer Datenbank-Tabelle. Jede Zeile in einer Datenbank-Tabelle führt zu einem neuen Objekt der Entität. Entitäten können untereinander, genauso wie Datenbank-Tabellen, Beziehungen eingehen.\nBeispiel: Entität für ein Schulfach\n1 2 3 4 5 6 7 8 9 10 11 12 @Entity @Table(name = \"SCHOOL_SUBJECT\") public class Schulfach { @Id @Column(name = \"Id\") private Long id; @Column(name = \"description\") private String bezeichnung; } Die gezeigte Entität wird mit @Entity annotiert, damit sie generell als solche erkannt wird. Die Annotation @Table verbindet die Entität mit der entsprechenden Tabelle. Für jede Kolonne in der Datenbank wird eine Instanzvariable angelegt, welche diese mit @Column und der Angabe des Spaltennamens mit der entsprechenden Spalten aus der Datenbank verbindet. Die Annotation @Id dient der Markierung des Primärschlüssels.\nAufgabe\nErstelle die Entitäten für die anderen beiden Tabellen GRADE und SCHOOL_SUBJECT_GRADE. Wähle für alle Attribute die richtigen Datentypen und gib die richtigen Spaltennamen an.\nNun sollen die drei Entitäten miteinander verbunden werden. Die Beziehung zwischen den Tabellen ist wie folgt geregelt:\nEin Eintrag in SCHOOL_SUBJECT_GRADE besitzt immer ein SCHOOL_SUBJECT und eine GRADE Eine GRADE kann in mehreren SCHOOL_SUBJECT_GRADE eingesetzt werden Ein SCHOOL_SUBJECT kann in mehreren SCHOOL_SUBJECT_GRADE eingesetzt werden Damit sind die Beziehungen zwischen den Tabellen jeweils 1:m, dies wird auch One-To-Many genannt. Aus Sicht eines SCHOOL_SUBJECT_GRADE ist die Beziehung umgekehrt m:1, dies wird auch Many-To-One genannt. Mit diesen Kenntnissen können nun die entsprechenden Annotationen aus JPA verwendet werden, um die Entitäten zu verbinden.\nBeispiel: Beziehung zwischen Schulfach und Mapping-Tabelle\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Entity @Table(name = \"SCHOOL_SUBJECT\") public class Schulfach { @OneToMany(mappedBy = \"schulfach\") private Set\u003cSchulfachNote\u003e noten; } @Entity @Table(name = \"SCHOOL_SUBJECT_GRADE\") public class SchulfachNote { @ManyToOne @JoinColumn(name = \"FK_SCHOOL_SUBJECT_ID\", nullable = false) private Schulfach schulfach; } Bei der Klasse Schulfach sehen wir die Verbindung zu allen Schulfach-Noten über ein Set und die Annotation @OneToMany unter Angabe des Namens der Instanzvariabel aus der Klasse SchulfachNote. Bei der Klasse SchulfachNote sehen wir die Verbindung zu einem Schulfach über die Annotation @ManyToOne und der Angabe der Kolonne, welche den Fremdschlüssel enthält. Die Angabe von nullable = false dient der Angabe, dass die Kolonne des Fremdschlüssels keine null-Werte zulässt.\nAufgabe\nVerbinde die anderen beiden Entitäten GRADE und SCHOOL_SUBJECT_GRADE mit den richtigen Beziehungen.\nIm nächsten Schritt werden nun die Repository-Interfaces angelegt.\nBeispiel: JPA-Repository für die Schulfachverwaltung\n1 2 3 4 @Repository public interface SchulfachAdminRepository extends JpaRepository\u003cSchulfach, String\u003e { } Bei diesem Repository sehen wir die Definition eines Interfaces, welches ein JpaRepository erweitert. Die generischen Angaben stehen für die Klasse der Entität und dessen Primärschlüssel-Typ. Durch dieses Repository stehen bereits die wichtigsten CRUD-Operationen zur Verfügung.\nAufgabe\nErstelle die Repository-Klassen für die beiden anderen Entitäten.\nDie folgende Aufzählung der Operationen ist nicht vollständig, zeigt aber welchen Funktionsumfang ein solches Repository nun bereits besitzt:\nList\u003cT\u003e findAll() liefert alle Einträge der Entität zurück T getReferenceById(ID id) liefert den Eintrag mit der entsprechenden ID zurück Optional\u003cT\u003e findById(ID id) liefert den Eintrag mit der entsprechenden ID als Optional zurück long count() zählt alle Einträge void delete(T entity) löscht die angegebene Entität \u003cS extends T\u003e S save(S entity) speichert die angegebene Entität und liefert sie zur weiteren Bearbeitung zurück Für die Realisierung von Methoden zur Abdeckung der funktionalen Anforderungen dient die folgende Tabelle:\nFunktionale Anforderung Abdeckung durch JpaRepository Alle Fächer und all deren Noten auflisten (ein Fach kann mehreren Noten beinhalten) Nein Alle Fächer und deren Durchschnittsnote auflisten Nein Für ein bestimmtes Fach: Alle Noten und die Durchschnittsnote des Fachs auflisten Nein Für ein bestimmtes Fach: Eine neue Note hinzufügen Methode save Für ein bestimmtes Fach: Eine bestehende Note ändern Methode save Für ein bestimmtes Fach: Eine bestehende Note löschen Methode delete Alle Fächer auflisten Methode findAll Neue Fächer hinzufügen Methode save Bestehende Fächer bearbeiten Methode save Bestehende Fächer löschen Methode delete Damit müssen nur die Methoden für die ein wenig komplizierteren Datenbank-Abfragen definiert werden. Der einfachste Weg zu schnellen Resultaten führt über die Entitäten und deren Verbindungen untereinander.\nEine Note (GRADE) und ein Schulfach (SCHOOL_SUBJECT) sind jeweils über die letzte Tabelle (SCHOOL_SUBJECT_GRADE) miteinander verbunden. Diese Verbindung kann ebenfalls über JPA in den Entitäten abgebildet werden.\nBeispiel: Many-To-Many Verbindung zwischen Noten und Schulfächern\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 @Entity @Table(name = \"SCHOOL_SUBJECT\") public class Schulfach { @ManyToMany @JoinTable( name = \"SCHOOL_SUBJECT_GRADE\", joinColumns = @JoinColumn(name = \"FK_SCHOOL_SUBJECT_ID\"), inverseJoinColumns = @JoinColumn(name = \"FK_GRADE_ID\") ) private List\u003cNote\u003e noten; } @Entity @Table(name = \"GRADE\") public class Note { @ManyToMany @JoinTable( name = \"SCHOOL_SUBJECT_GRADE\", joinColumns = @JoinColumn(name = \"FK_GRADE_ID\"), inverseJoinColumns = @JoinColumn(name = \"FK_SCHOOL_SUBJECT_ID\") ) private List\u003cSchoolSubject\u003e subjects; } Es reicht also die “Mapping”-Tabelle und die gerichteten Verbindungen in Form der Kolonnen-Namen anzugeben.\nDamit für ein bestimmtes Fach nun alle Noten abgeholt werden können, ist die folgende Implementation notwendig: Beispiel: Laden aller Noten für ein bestimmtes Fach\n1 2 3 4 5 6 @Repository public interface GradeRepository extends JpaRepository\u003cGrade, Integer\u003e { List\u003cGrade\u003e findGradesBySubjectsSubject(String subject); } Möglichkeit 2: JDBC-Template Möglichkeit 2: JDBC-Template Wer nicht mehr genau weiss was JDBC ist kann es hier nachlesen.\nDependency Damit JDBC verwendet werden kann, muss zuerst eine neue Dependency in das pom.xml hinzufügen werden.\n1 2 3 4 5 6 7 8 9 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-data-jdbc\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mariadb.jdbc\u003c/groupId\u003e \u003cartifactId\u003emariadb-java-client\u003c/artifactId\u003e \u003cversion\u003e3.1.0\u003c/version\u003e \u003c/dependency\u003e Entity-Klasse Eine Entity-Klasse ist eine normale Java-Klasse, die als Modell für eine Tabelle in der Datenbank dient. Jedes Objekt dieser Klasse entspricht einer Zeile in der Tabelle.\n1 2 3 4 5 6 @Getter @Setter public class Grade { private Long gradeId; private Double gradeValue; } Die Annotationen @Getter und @Setter sind zwei der am häufigsten verwendeten Annotationen in Lombok. Sie generieren automatisch Getter- und Setter-Methoden für die Felder einer Klasse. Lombok ist eine Java-Bibliothek, die es Entwicklern ermöglicht, boilerplate Code in ihren Java-Klassen zu reduzieren.\nDamit man Lombok jedoch verwenden kann, muss man die folgende Dependency im pom.xml hinzufügen:\n1 2 3 4 5 6 \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003cversion\u003e1.18.30\u003c/version\u003e \u003cscope\u003eprovided\u003c/scope\u003e \u003c/dependency\u003e Repository Ein Repository ein Designmuster oder eine Klasse, die den Datenbankzugriff für eine bestimmte Entität oder ein bestimmtes Objektmodell verwaltet. Es hilft, den Code zu organisieren und zentrale Methoden für den Zugriff auf die Datenbank bereitzustellen.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Repository public class StudentRepository { private final JdbcTemplate jdbcTemplate; public StudentRepositoryImpl(JdbcTemplate jdbcTemplate) { this.jdbcTemplate = jdbcTemplate; } public List\u003cSchoolSubject\u003e getAllSubjectsAndGrades() { return null; } // ... } Repository-Klassen und Service-Klassen verbinden Die Verbindung zwischen Repository- und Service-Klassen in einer Softwareanwendung ist entscheidend für eine saubere Struktur und effiziente Datenverwaltung. Repository-Klassen handhaben den Datenzugriff, während Service-Klassen die Geschäftslogik umsetzen. Service-Klassen nutzen die Methoden der Repository-Klassen, um auf Daten zuzugreifen oder diese zu manipulieren. Diese Trennung ermöglicht eine klare Aufgabenverteilung, verbessert die Wartbarkeit und erleichtert die Integration von Datenzugriff und Geschäftslogik.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Service public class StudentService { private final StudentRepository studentRepository; public StudentService(StudentRepository studentRepository) { this.studentRepository = studentRepository; } public List\u003cSchoolSubjectGradeDto\u003e getAllSubjectsAndGrades() { return studentRepository.getAllSubjectsAndGrades(); } // ... } Aufgabe Füge die benötigte Dependency in dein Projekt ein und erstelle die nötigen Entity-Klassen. Zudem erstelle die benötigten Services und Repositories in der korrekten packages Struktur.\nSchritt 5: Konfiguration anlegen In der Konfigurationsdatei können Einstellungen für die Datenbankverbindung, Log-Ebene, Profile, Spring-Profile, Webserver-Port, Sicherheitskonfigurationen und viele andere Aspekte der Anwendung angegeben werden.\nDie zwei häufigsten Arten eine Konfigurationsdatei anzulegen sind in application.yml oder die application.properties. Der Unterschied der beiden besteht darin das die application.yml-Datei, in YAML-Syntax geschrieben ist, und die application.properties-Datei eine einfache Key-Value-Paar-Syntax verwendet.\napplication.properties:\n1 2 3 4 spring.datasource.url=jdbc:mariadb://localhost:3306/[your_database] spring.datasource.username=[your_username] spring.datasource.password=[your_password] spring.datasource.driver-class-name=org.mariadb.jdbc.Driver application.yml:\n1 2 3 4 5 6 spring: datasource: url: jdbc:mariadb://localhost:3306/[your_database] username: [your_username] password: [your_password] driver-class-name: org.mariadb.jdbc.Driver Aufgabe\nErstelle deine Konfigurationsdatei entsprechend deiner Datenbank.\nSchritt 6: Profile anlegen In diesem Schritt erstellst du die gewünschten Spring Boot Profile: “student” und “admin”. Diese Profile werden benutzt, um die verfügbare Funktionalität einzuschränken bzw. zu erweitern. Welche Funktionalität mit welchem Profil zur Verfügung stehen darf, entnimmst du aus den funktionalen Anforderungen.\nMit der @Profile Annotation, kannst du bestimmte Beans für das gegebene Profil aktivieren bzw. deaktivieren.\nAufgabe\nAktiviere bzw. deaktiviere die Schnittstellen-Funktionalität entsprechend dem aktiven Profil\nSchritt 7 Business-Logik- und Persistenz-Layer anpassen Repository- und Service-Implementierungen In Spring Boot ist die Verwendung von Repository- und Service-Implementierungen eine bewährte Methode, um eine saubere Trennung von Geschäftslogik, Datenzugriff und Präsentation sicherzustellen. Diese Trennung hilft, den Code übersichtlich, wartbar und testbar zu machen.\nRepository-Interface: Definiert die Methoden für den Datenzugriff.\nRepository-Implementierung (RepositoryImpl): Implementiert die Methoden des Repository-Interfaces und führt die tatsächlichen Datenbankoperationen aus.\nService-Interface: Definiert die Methoden für die Geschäftslogik.\nService-Implementierung (ServiceImpl): Implementiert die Methoden des Service-Interfaces und ruft bei Bedarf das Repository auf, um auf Daten zuzugreifen.\n1 2 3 4 5 public interface StudentRepository { List\u003cSchoolSubject\u003e getAllSubjectsAndGrades(); // ... } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Repository public class StudentRepositoryImpl implements StudentRepository { private final JdbcTemplate jdbcTemplate; public StudentRepositoryImpl(JdbcTemplate jdbcTemplate) { this.jdbcTemplate = jdbcTemplate; } @Override public List\u003cSchoolSubject\u003e getAllSubjectsAndGrades() { return null; } // ... } Aufgabe\nPasse deine Services und Repositories entsprechend der Implementierungs-Methode an.\nSchritt 8 Persistenz-Layer fertigstellen (Nur für JDBC) Schritt 8 Persistenz-Layer fertigstellen (Nur für JDBC) Queries Typischerweise implementieren JDBC-Repositories benutzerdefinierte Methoden für spezielle Datenbankabfragen. Diese Methoden nutzen das JdbcTemplate (Teil des Spring-Frameworks), um SQL-Queries auszuführen. Dabei können Platzhalter oder Named Parameters verwendet werden, um dynamische Werte in die Abfragen einzufügen.\nPreparedStatementSetter ist ein funktionales Interface in Spring JDBC. Es wird verwendet, um Parameter für parametrisierte Abfragen auf einem PreparedStatement festzulegen. Die Verwendung von PreparedStatementSetter hilft, die Logik zum Setzen von Parametern zu kapseln, was den Code modularer und leichter wartbar macht.\n1 INSERT INTO SCHOOL_SUBJECT (subject_name) VALUES (?) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @Repository public class StudentRepositoryImpl implements StudentRepository { private final JdbcTemplate jdbcTemplate; public StudentRepositoryImpl(JdbcTemplate jdbcTemplate) { this.jdbcTemplate = jdbcTemplate; } // ... @Override public void addSubject(SchoolSubjectDto schoolSubjectDto) { String sql = \"INSERT INTO SCHOOL_SUBJECT (subject_name) VALUES (?)\"; PreparedStatementSetter preparedStatementSetter = preparedStatement -\u003e { preparedStatement.setString(1, schoolSubjectDto.getSubjectName()); }; jdbcTemplate.update(sql, preparedStatementSetter); } // ... } Mapping In der Softwareentwicklung stellt sich oft die Frage, wie man das Mapping zwischen verschiedenen Ebenen der Anwendung am besten handhabt. Insbesondere geht es darum, wie man Daten zwischen der Datenbank, der Geschäftslogik (Services) und der Benutzerschnittstelle (DTOs - Data Transfer Objects) hin- und herbewegt.\nEine Möglichkeit ist, das Mapping nicht im Service durchzuführen. Dies wird zwar nicht zwingend empfohlen, aber es ähnelt dem Ansatz von JPA (Java Persistence API) und kann daher vorteilhaft sein. Hierbei wird das Mapping eher in den Repositories durchgeführt. Dies verringert die Belastung des Service mit zusätzlichem Mapping und spezifischen Abfragen (Queries). Allerdings kann dies zu einer unübersichtlichen Repository-Schicht führen, da sie dann sowohl für das Mapping als auch für die Abfragen verantwortlich ist.\nWenn das Mapping im Service durchgeführt wird, bedeutet dies ein zusätzliches Mapping von der Abfrage (Query) zu den Entity-Objekten und dann zu den DTOs. Dies kann ineffizient erscheinen, da man ein Objekt erstellt, das später vom Garbage Collector aufgeräumt werden muss.\nDer JPA-Ansatz könnte mehr Daten zurückholen, als tatsächlich benötigt werden, da alle Eigenschaften in das Entity-Objekt geladen werden, selbst wenn sie im DTO nicht benötigt werden. Dies könnte ineffizient sein, insbesondere wenn nur ein Teil der Daten benötigt wird.\nIm Kontext von JDBC (Java Database Connectivity) gibt es viele verschiedene Ansätze und keinen “einen” richtigen Weg. Es ist möglich, JPA und JDBC zu mischen, um das Beste aus beiden Welten zu nutzen.\nInsgesamt ist die Wahl des richtigen Ansatzes abhängig von den Anforderungen des Projekts, der Skalierbarkeit, der Performance und den individuellen Vorlieben des Entwicklungsteams. Es ist wichtig, die Vor- und Nachteile der verschiedenen Ansätze abzuwägen und den am besten geeigneten Ansatz für das spezifische Projekt zu wählen.\nDTO zu Entity Durch das Mappen der Entity-Objekte auf DTOs können wir die Datenstruktur an die spezifischen Anforderungen anpassen. DTOs enthalten nur die relevanten Daten, die zwischen verschiedenen Teilen der Anwendung oder sogar zu externen Systemen übertragen werden müssen. Dies ermöglicht eine effizientere Datenübertragung und verhindert die Offenlegung von sensiblen oder unnötigen Informationen.\nDes Weiteren schafft die Verwendung von DTO’s eine klare Trennung der Verantwortlichkeiten. Die Entity-Objekte kümmern sich um die Interaktion mit der Datenbank, während die DTO’s die übertragenen Daten in geeigneter Form halten. Somit wird eine saubere Architektur gefördert, die gut skalierbar und wartbar ist.\n1 2 3 4 5 6 7 8 9 10 public static SchoolSubject mapDtoToEntity(SchoolSubjectDto dto) { if (dto == null) { return null; } SchoolSubject entity = new SchoolSubject(); entity.setSubjectId(dto.getSubjectId()); entity.setSubjectName(dto.getSubjectName()); return entity; } 1 2 3 4 5 6 7 8 9 10 11 12 13 @Service public class AdminService { private final AdminRepository adminRepository; public AdminService(AdminRepository adminRepository) { this.adminRepository = adminRepository; } public void addSubject(SchoolSubjectDto schoolSubjectDto) { adminRepository.addSubject(mapDtoToEntity(schoolSubjectDto)); } } RowMapper In JDBC, ist der RowMapper ein Interface, das verwendet wird, um das Mapping von Zeilen aus dem ResultSet auf Objekte zu ermöglichen. Es wird verwendet, um das Ergebnis jedes Datensatzes aus der Abfrage in ein Objekt umzuwandeln.\nErstelle eine Klasse, die das RowMapper-Interface implementiert und die mapRow-Methode überschreibt. In dieser Methode wird definiert, wie eine Zeile aus dem ResultSet in ein Objekt gemappt wird.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import org.springframework.jdbc.core.RowMapper; import java.sql.ResultSet; import java.sql.SQLException; public class SchoolSubjectDtoRowMapper implements RowMapper\u003cSchoolSubjectDto\u003e { @Override public SchoolSubjectDto mapRow(ResultSet resultSet, int rowNum) throws SQLException { Long subjectId = resultSet.getLong(\"subject_id\"); String subjectName = resultSet.getString(\"subject_name\"); return new SchoolSubjectDto(subjectId, subjectName); } } Im RepositoryImpl kann man nun die erstellte Mapper-Methode verwenden, um das Ergebnis der JDBC-Operation zu mappen.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @Repository public class StudentRepositoryImpl implements StudentRepository { private final NamedParameterJdbcTemplate namedParameterJdbcTemplate; private final CommonDeclarableProperties declarableProperties; public StudentRepositoryImpl(NamedParameterJdbcTemplate namedParameterJdbcTemplate, CommonDeclarableProperties declarableProperties) { this.namedParameterJdbcTemplate = namedParameterJdbcTemplate; this.declarableProperties = declarableProperties; } // ... @Override public List\u003cSchoolSubjectDto\u003e getAllSubjects() { String sql = \"SELECT * FROM SCHOOL_SUBJECT\"; return namedParameterJdbcTemplate.query(sql, new SchoolSubjectDtoRowMapper()); } // ... } ResultSetExtractor Auch der ResultSetExtractor ist ein funktionales Interface, das verwendet wird, um das Mapping von ResultSet auf ein Objekt oder eine Liste von Objekten zu ermöglichen. Es ermöglicht eine benutzerdefinierte Verarbeitung der ResultSet-Daten.\nErstelle eine Klasse und verwende das ResultSetExtractor-Interface, um zu definieren, wie das ResultSet in ein Objekt oder eine Liste von Objekten umgewandelt werden soll.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class SchoolSubjectDtoResultSetExtractor implements ResultSetExtractor\u003cList\u003cSchoolSubjectDto\u003e\u003e { @Override public List\u003cSchoolSubjectDto\u003e extractData(ResultSet resultSet) throws SQLException { List\u003cSchoolSubjectDto\u003e schoolSubjectDtos = new ArrayList\u003c\u003e(); while (resultSet.next()) { Long gradeId = resultSet.getLong(\"subject_id\"); String subjectName = resultSet.getString(\"subject_name\"); SchoolSubjectDto schoolSubjectDto = new SchoolSubjectDto(gradeId, subjectName); schoolSubjectDtos.add(schoolSubjectDto); } return schoolSubjectDtos; } } Im RepositoryImpl kann man nun die erstellte Extractor-Methode verwenden um das Ergebnis der JDBC Operation zu mappen.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @Repository public class AdminRepositoryImpl implements AdminRepository { private final NamedParameterJdbcTemplate namedParameterJdbcTemplate; private final JdbcTemplate jdbcTemplate; public AdminRepositoryImpl(NamedParameterJdbcTemplate namedParameterJdbcTemplate, JdbcTemplate jdbcTemplate) { this.namedParameterJdbcTemplate = namedParameterJdbcTemplate; this.jdbcTemplate = jdbcTemplate; } // ... @Override public List\u003cSchoolSubjectDto\u003e getAllSubjects() { String sql = \"SELECT * FROM SCHOOL_SUBJECT\"; return namedParameterJdbcTemplate.query(sql, new SchoolSubjectDtoResultSetExtractor()); } // ... } Aufgabe Ergänze deine Repositories mit den nötigen SQL-Queries (wähle selbst, ob du es auslagern möchtest oder nicht). Implementiere die benötigten Mapper und setze sie an den benötigten Orten ein (wähle selbst, ob du es mit einem Mapper oder Extractor machen willst).\nSchritt 9: API testen Sobald deine Schnittstelle umgesetzt wird bzw. bereits ab dem zweiten Schritt in diesem Auftrag, kann die Schnittstelle von HTTP-Clients angesprochen und getestet werden. In diesem Schritt wirst du deine Schnittstelle mit dem IntelliJ HTTP-Client testen.\nEine Alternative zum IntelliJ HTTP-Client bietet Swagger an. Swagger ist ein Open-Source-Framework, das in erster Linie dazu dient, APIs zu entwerfen, zu dokumentieren und zu testen. Es ermöglicht eine einfache und strukturierte Beschreibung von Webdiensten, um deren Funktionalitäten, Parameter und Endpunkte zu verstehen.\nMit Spring Boot 3 kann man neu nur noch eine Dependency hinzufügen damit der Swagger läuft. Diese sieht folgendermassen aus:\n1 2 3 4 5 \u003cdependency\u003e \u003cgroupId\u003eorg.springdoc\u003c/groupId\u003e \u003cartifactId\u003espringdoc-openapi-starter-webmvc-ui\u003c/artifactId\u003e \u003cversion\u003e2.2.0\u003c/version\u003e \u003c/dependency\u003e Für unsere Test-Zwecke reicht der IntelliJ HTTP-Client völlig aus.\nTesten mit IntelliJ HTTP Client Wenn du eine RestController-Klasse in IntelliJ offen hast, wird an einigen Stellen ein Symbol dargestellt, wie hier mit Rot unterstrichen: Wenn man den Pfeil neben dem Symbol drückt, kann man die Option “Generate Request in HTTP Client” auswählen: Somit wird der HTTP-Client Editor geöffnet, mit dem entsprechenden HTTP-Method und Pfad: Mit einem Klick auf dem grünen Pfeil, wird die HTTP Request ausgeführt. Wenn du ein Beispiel brauchst, um zu wissen, wie du Requests erstellst (z.B. solche mit einem Request-Body) kannst du auf dem Examples Pfeil (oben rechts) klicken und die entsprechende Beispiel-Datei öffnen.\nWeitere Dokumentation zum IntelliJ HTTP-Client findest du auf dieser IntelliJ IDEA Seite\nAufgabe\nErstelle eine HTTP-Request Datei, welche alle Methoden in deiner Schnittstelle ausführt.\nIntegrationstests mit H2 umsetzen Integrationstests mit H2 in einem Spring-Boot-Projekt umzusetzen, ist eine bewährte Methode, um die Interaktion zwischen verschiedenen Komponenten einer Anwendung zu testen, ohne auf eine reale Datenbank angewiesen zu sein. In diesem Kontext dient H2, eine In-Memory-Datenbank, als Ersatz für die eigentliche Datenbank und erlaubt es, Tests zu schreiben, welche die Anwendungslogik unter simulierten Bedingungen überprüft.\nStruktur Es wird folgende Ordnerstruktur empfohlen, damit das gesamte Testing wie gewollt funktioniert:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 src/ |-- main/ | |-- java/ | | |-- com/ | | |-- example/ | | |-- myapp/ | | |-- YourProductionCode.java |-- test/ | |-- java/ | | |-- com/ | | |-- example/ | | |-- myapp/ | | |-- integration/ | | |-- YourIntegrationTests.java | |-- resources/ | |-- application-test.properties | |-- schema.sql | |-- data.sql Dependencies Damit man H2 verwenden kann, muss man auch hier noch einen Dependency im pom.xml hinzufügen. Diese ist folgende:\n1 2 3 4 5 \u003cdependency\u003e \u003cgroupId\u003ecom.h2database\u003c/groupId\u003e \u003cartifactId\u003eh2\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e Konfiguration anlegen In der Testkonfiguration (z. B. application-test.properties), konfiguriert man H2 als Datenbank für die Integrationstests. Es wird die Verbindungs-URL, der Treiber und die Anmeldeinformationen für H2 festgelegt. Diese Datenbank wird in den Tests automatisch erstellt und verwaltet.\napplication-test.properties:\n1 2 3 4 5 6 spring.datasource.url=jdbc:h2:mem:testdb spring.datasource.driverClassName=org.h2.Driver spring.datasource.username=sa spring.datasource.password=password spring.datasource.platform=h2 spring.jpa.hibernate.ddl-auto=update application-test.yml:\n1 2 3 4 5 6 7 8 9 10 spring: datasource: url: jdbc:h2:mem:testdb username: sa password: password platform: h2 driver-class-name: org.h2.Driver jpa: hibernate: ddl-auto: update SQL Files Nun werden SQL-Skripte benötigt, die das Datenbankschema und Testdaten definieren. Diese Skripte werden während der Testausführung automatisch geladen.\nSchema File 1 2 3 4 CREATE TABLE SCHOOL_SUBJECT ( subject_id INT AUTO_INCREMENT PRIMARY KEY, subject_name VARCHAR(255) NOT NULL ); Data File 1 2 3 4 INSERT INTO SCHOOL_SUBJECT (subject_name) VALUES ('Mathematics'); INSERT INTO SCHOOL_SUBJECT (subject_name) VALUES ('History'); INSERT INTO SCHOOL_SUBJECT (subject_name) VALUES ('Science'); INSERT INTO SCHOOL_SUBJECT (subject_name) VALUES ('English'); Integration Test Integrationstests sind wichtig, um sicherzustellen, dass verschiedene Komponenten einer Anwendung (z. B. Klassen, Module, Services, REST-Endpunkte) ordnungsgemäss miteinander interagieren und Daten korrekt austauschen. Sie helfen dabei, potenzielle Fehler und Inkompatibilitäten zwischen den Komponenten frühzeitig zu erkennen und zu beheben.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @SpringBootTest @AutoConfigureMockMvc @ActiveProfiles(\"admin\") @ExtendWith(SpringExtension.class) public class AdminControllerIntegrationTest { @Autowired private MockMvc mockMvc; @MockBean private AdminService adminService; @Test public void testGetAllSubjects() throws Exception { List\u003cSchoolSubjectDto\u003e subjects = new ArrayList\u003c\u003e(); subjects.add(new SchoolSubjectDto(1, \"Mathematics\")); subjects.add(new SchoolSubjectDto(2, \"History\")); when(adminService.getAllSubjects()).thenReturn(subjects); mockMvc.perform(get(\"/api/admin/subjects\") .contentType(MediaType.APPLICATION_JSON)) .andExpect(status().isOk()) .andExpect(content().contentType(MediaType.APPLICATION_JSON)) .andExpect(jsonPath(\"$[0].subjectId\").value(1)) .andExpect(jsonPath(\"$[0].subjectName\").value(\"Mathematics\")) .andExpect(jsonPath(\"$[1].subjectId\").value(2)) .andExpect(jsonPath(\"$[1].subjectName\").value(\"History\")); } // ... } Jetzt bist du dran. Löse bitte die Aufgaben zu Spring in den Labs.\n","categories":"","description":"Modul #J8 - Spring Framework - Wie erstelle ich ein Projekt mit Spring\n","excerpt":"Modul #J8 - Spring Framework - Wie erstelle ich ein Projekt mit Spring …","ref":"/docs/02_java/12_spring-framework/08_projekt-erstellen/","tags":"","title":"Projekt Erstellen"},{"body":"Schritt 1: Maven-Projekt erstellen / pom.xml In diesem ersten Schritt wirst du eine Spring Boot Anwendung erstellen und ausführen. Hier stehen dir zwei Möglichkeiten für die Umsetzung zur Verfügung:\nDie Projektstruktur manuell anzulegen (#Hard-Core-Variante) Die Projektstruktur mit Spring-Initializr anlegen (#Easy-Going-Variante) Beide Möglichkeiten werden in dieser Aufgabe aufgeführt.\nVoraussetzungen (was du brauchst) Java 20 oder neuer ist installiert. Maven 3.5 oder neuer ist installiert. IntelliJ ist installiert und konfiguriert. Ein Bitbucket Repository steht bereit, um den Code des Projektes zu verwalten und ist auf der lokalen Maschine geklont worden. Variante I: Projekt manuell anlegen Erstelle ein Maven-Projekt in IntelliJ Öffne IntelliJ und erstelle ein neues Maven-Projekt (File → New → Project): Ersetze GroupId, ArtifactId, Name und Location durch passende Werte.\nPasse dein pom.xml File an Füge den “Parent” und folgende Dependencies und Maven-Plugins in deine pom.xml Datei hinzu:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \u003c!-- Parent kommt normalerweise nach der modelVersion --\u003e \u003cparent\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-parent\u003c/artifactId\u003e \u003cversion\u003e3.1.5\u003c/version\u003e \u003crelativePath/\u003e \u003c!-- lookup parent from repository --\u003e \u003c/parent\u003e \u003c!-- Dependencies kommen normalerweise nach den Properties --\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c!-- Build kommen normalerweise nach den Dependencies --\u003e \u003cbuild\u003e \u003cplugins\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-maven-plugin\u003c/artifactId\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c/build\u003e Lade alle Dependencies erneut (Maven-View -\u003e Reload all maven projects).\nErsetze die Main Klasse mit einer Spring Boot Applikation Klasse Wenn du beim Erstellen des Projektes “add sample code” angekreuzt hast, beinhaltet dein Projekt nun eine Main-Klasse in deinem Source-Folder (im richtigen Package selbstverständlich). Diese Main Klasse werden wir nun in einer SpringBootApplication-Klasse umwandeln:\nBenenne die Main Klasse um, so dass sie \u003cname-deines-artefaktes\u003eApplication heisst (z.B. wenn dein Artefakt “demo” heisst, wird die Klasse nun “DemoApplication” heissen). Füge die Annotation @SpringBootApplication auf der Klassenebene hinzu Passe deine main Methode an, so dass sie wie folgt aussieht (Ersetzte DemoApplication mit deinem Application-Klassennamen): 1 2 3 public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } Zuletzt solltest du noch deine Projektstruktur überprüfen. Diese sollte wie folgt aussehen: Gratuliere! Du hast nun dein Projekt angelegt, und zwar Hard-Core. Bravo! Fahre nun mit dem Schritt “Führe deine Anwendung aus” fort.\nVariante II: Projekt mit Spring-Initializr anlegen Öffne die Seite: https://start.spring.io/ und ersetzte die Angaben zu Group, Artifact (der Name wird sich automatisch ändern) und Description durch passende Werte. Achte das bei Project “Maven” ausgewählt ist und nicht Gradle. Füge die Abhängigkeit für “Spring Web” hinzu und drücke den “GENERATE” Knopf. Entpacke das heruntergeladene Zip-File in deinem Repository-Verzeichnis und öffne die Anwendung als Maven-Projekt in IntelliJ: File → New → Project from existing sources → Zum Root-Folder des Projektes navigieren und pom.xml auswählen.\nFühre deine Anwendung aus Öffne deine Application-Klasse (normalerweise heist sie Application). Wenn du Spring-Initializr benutzt hast, wurde diese Klasse für dich automatisch erstellt. Starte deine Anwendung mit der Default-Run-Konfiguration. Zu diesem Zweck kannst du die Application-Klasse öffnen und die Main-Methode ausführen.\nNach dem Start sollte die Run-Konsole wie folgt aussehen: Schritt 2: Rest Schnittstellen definieren und umsetzen In diesem Schritt geht es darum die Schnittstellen (die API) zur Anwendung zu definieren. Über diese Schnittstellen können die Benutzer:innen die gewünschten Aktionen ausführen\nSystem-Design erstellen und Code Struktur anlegen Damit du den Code gemäss den nicht-funktionalen Anforderungen (NFA) aufbauen kannst, überlege dir zuerst, wie du deine Anwendung zerlegen möchtest.\nDazu kannst du die Schritte der Methodik “functional decomposition” anwenden (mehr Information zur Methode findest du in diesem Artikel).\nBei der Zerlegung des Systems beachte auch Prinzipien wie Kohäsion (starke Kohäsion ist gewünscht) und Kopplung (lose Kopplung sollte das Ziel sein).\nAufgabe\nSobald du die Zerlegung deiner Anwendung gemacht hast, kannst du die passende Java-Packages erstellen, welche diese Zerlegung dann abbildet. Dein Code fügst du später an den richtigen Stellen hinzu.\nREST-Schnittstelle definieren Die Struktur für deine Anwendung steht. Nun definierst du die Schnittstellen, womit die Benutzer:innen mit der Anwendung interagieren werden. Die nötige Funktionalität entnimmst du aus den funktionalen Anforderungen.\nBeispiel: Anforderung - ein neues Schulfach hinzufügen\nDie entsprechende Schnittstelle könnte entsprechend so aussehen:\nBeschreibung Http-Methode URL Request-Body Beispiel Path-Variable Response-Body Beispiel Neues Schulfach hinzufügen POST /admin/schulfaecher {“name”: “Physik”} keine {“id”: 3, “name”: “Physik”} Dort, wo ein Request-Body und/oder ein Response-Body benötigt wird, wird mit JSON-Objekten gearbeitet. Diese JSON-Objekte werden wir im nächsten Abschnitt verwenden, um die Resource-Representation Klassen zu erzeugen.\nAufgabe\nErweitere die oben stehende Tabelle mit den restlichen Funktionen gemäss den funktionalen Anforderungen. Buche sobald du fertig bist ein Review mit einem Praxisbildner, damit spätere Fehler vermieden werden.\nWichtig Endpunkt für Profil: Vergiss nicht, dass du noch einen Endpunkt erstellen musst, um herauszufinden, mit welchem Profil die Anwendung gestartet wurde.\nResource-Representation Klassen erstellen Unsere Schnittstellendefinition verwendet JSON-Objekte bei bestimmten Requests und Responses. Diese JSON-Objekte stellen sog. “Resource” dar. Im Beispiel “Neues Schulfach hinzufügen” stellt das JSON-Objekt ein Schulfach dar.\nIn diesem Abschnitt wirst du für alle JSON-Objekte entsprechende Java-Klassen erstellen. Das sind sogenannte Resource-Representation Klassen, auch Modelle genannt.\nIn unserer Anwendung werden wir die Resource-Representation Klassen als sog. DTOs (Data Transfer Objects) umsetzen. Diese Klassen wirst du später in deinen Controllern verwenden.\nBeispiel: Schulfach Resource-Representation\nDas folgende JSON-Objekt stellt ein Schulfach dar:\n1 2 3 4 { \"id\": 1, \"name\": \"Deutsch\" } Daraus können wir unsere DTO-Klasse erstellen (vorerst nur mit Feldern und noch keine weitere Funktionalität):\n1 2 3 4 public class SchulfachDto { private final Long id; private final String name; } Aufgabe\nErstelle für jedes JSON-Objekt aus dem vorherigen Abschnitt eine DTO-Klasse. Denke daran die Klassen in die richtigen Packages zu setzen.\nController erstellen In Spring werden HTTP Requests an REST-Services von Controllern behandelt. Das ist eine Java-Klasse, welche mit @RestController annotiert wird. Controller sind also die Umsetzung unserer Schnittstellendefinition. Da wir noch keine persistierten Daten haben, wirst du vorerst Mockdaten aus den Schnittstellenmethoden liefern müssen.\nBeispiel: Controller für die Schulfachverwaltung\n1 2 3 4 5 6 7 8 9 10 11 12 @RestController @RequestMapping(\"/api/admin\") public class SchulfachAdminController { @PostMapping(\"/schulfaecher\") public SchulfachDto createNewSchulfach(@RequestBody SchulfachDto newSchulfach) { // TODO: Das sind Mockdaten und sollten zu einem späteren Zeitpunkt mit \"echtem\" Code ersetzt werden return new SchulfachDto(3, \"Physik\"); } // hier können weitere Methoden der Schnittstelle umgesetzt werden } Aufgabe\nErstelle Controller und Methoden (mit Mockdaten), um die Umsetzung deiner Schnittstellen abzuschliessen.\nSchritt 3: Services anlegen Service-Klassen erstellen In diesem Schritt wird ein komplett neuer Layer angelegt, welcher die Business-Logik der Applikation enthalten wird. Er ist zuständig für Aufgaben wie Exception-Handling und Validierung. Dieser Layer wird Service-Layer genannt. Service-Klassen werden grundsätzlich mit der Annotation @Service annotiert. Diese Annotation ist eine der möglichen Spezialisierungen eines Spring Components.\nDie möglichen Annotationen für einen Spring Component sind die folgenden:\n@Component @Controller @Service @Repository Mehr Informationen zu diesen Annotationen findest auf dieser Seite.\nIm folgenden Beispiel wird nun eine Service-Klasse angelegt, welche den vom Controller empfangenen Request-Body als Parameter entgegennimmt und diesen dann später weiter verarbeiten wird. Im Moment begnügen wir uns damit die Mock-Daten aus dem Controller hierher zu verschieben.\nBeispiel: Service für die Schulfachverwaltung\n1 2 3 4 5 6 7 8 9 10 @Service public class SchulfachAdminService { public SchulfachDto createNewSchulfach(SchulfachDto newSchulfach) { // TODO: Dies sind die Mock-Daten aus dem Controller, sie werden später durch richtige Daten ersetzt return new SchulfachDto(3, \"Physik\"); } // hier können weitere Methoden des Services umgesetzt werden } Aufgabe\nErstelle die nötigen Service-Klassen mit entsprechenden Methoden und verschiebe die Mock-Daten aus den Controllern in die Service-Methoden. Versuche die Methoden, welche das gleiche fachliche Thema behandeln im gleichen Service unterzubringen. Denke daran, die Service-Klassen in das richtige Package zu setzen.\nService-Klassen und Controller verbinden Nun ist es an der Zeit, die erstellten Controller- und Service-Klassen miteinander zu verbinden. Dazu nutzen wir die Dependency Injection. Controller- und Service-Klassen werden durch ihre Annotationen als Spring-Components erkannt und durch den Spring Container instanziiert. Die Injection eines Service in einen Controller kann beispielsweise durch eine Constructor-Injection erfolgen. Durch diese Art von Implementation holt sich der Controller den Service aus dem Container selbst. Die Methoden von dem Controller leiten nun ihre Anfragen an die entsprechenden Service-Klassen weiter.\nBeispiel: Constructor-Injection\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @RestController @RequestMapping(\"/api/admin\") public class SchulfachAdminController { private final SchulfachAdminService schulfachAdminService; public SchulfachAdminController(SchulfachAdminService schulfachAdminService) { this.schulfachAdminService = schulfachAdminService; } @PostMapping(\"/schulfaecher\") public SchulfachDto createNewSchulfach(@RequestBody SchulfachDto newSchulfach) { return this.schulfachAdminService.createNewSchulfach(newSchulfach); } // ... } Aufgabe\nVerbinde die erstellten Controller-Klassen mit den entsprechenden Services. Leite sämtliche Anfragen aus den Controllern an die Service-Methoden weiter. Die ursprünglich erstellten Tests sollten immer noch erfolgreich ausführbar sein.\nSchritt 4: Datenbank-Verbindung herstellen Repository-Klassen erstellen In diesem Schritt wird erneut ein komplett neuer Layer angelegt, welcher die Verbindung der Applikation zu einer Datenbank aufbauen wird. Dieser Layer wird Persistenz-Layer genannt. Repository-Klassen werden grundsätzlich mit der Annotation @Repository annotiert.\nDie Verbindung zu einer Datenbank kann auf verschiedene Arten realisiert werden. In diesem Kapitel werden wir auf JPA oder JDBCTemplate eingehen.\nMöglichkeit 1: JPA-Repository mit Spring Data Möglichkeit 1: JPA-Repository mit Spring Data Bei dieser Variante wird die Jakarta Persistence API (JPA) mit Spring Data verwendet. Sie ermöglicht die automatische Generierung von Queries durch die Deklaration eines entsprechenden Methodennamens. Dies bedeutet, dass der Methodenname zugleich ein Datenbank-Query darstellt.\nDamit diese Möglichkeit der Implementation überhaupt besteht, müssen zuerst sogenannte Entitäten angelegt werden. Eine Entität ist in Java das Abbild einer Datenbank-Tabelle. Jede Zeile in einer Datenbank-Tabelle führt zu einem neuen Objekt der Entität. Entitäten können untereinander, genauso wie Datenbank-Tabellen, Beziehungen eingehen.\nBeispiel: Entität für ein Schulfach\n1 2 3 4 5 6 7 8 9 10 11 12 @Entity @Table(name = \"SCHOOL_SUBJECT\") public class Schulfach { @Id @Column(name = \"Id\") private Long id; @Column(name = \"description\") private String bezeichnung; } Die gezeigte Entität wird mit @Entity annotiert, damit sie generell als solche erkannt wird. Die Annotation @Table verbindet die Entität mit der entsprechenden Tabelle. Für jede Kolonne in der Datenbank wird eine Instanzvariable angelegt, welche diese mit @Column und der Angabe des Spaltennamens mit der entsprechenden Spalten aus der Datenbank verbindet. Die Annotation @Id dient der Markierung des Primärschlüssels.\nAufgabe\nErstelle die Entitäten für die anderen beiden Tabellen GRADE und SCHOOL_SUBJECT_GRADE. Wähle für alle Attribute die richtigen Datentypen und gib die richtigen Spaltennamen an.\nNun sollen die drei Entitäten miteinander verbunden werden. Die Beziehung zwischen den Tabellen ist wie folgt geregelt:\nEin Eintrag in SCHOOL_SUBJECT_GRADE besitzt immer ein SCHOOL_SUBJECT und eine GRADE Eine GRADE kann in mehreren SCHOOL_SUBJECT_GRADE eingesetzt werden Ein SCHOOL_SUBJECT kann in mehreren SCHOOL_SUBJECT_GRADE eingesetzt werden Damit sind die Beziehungen zwischen den Tabellen jeweils 1:m, dies wird auch One-To-Many genannt. Aus Sicht eines SCHOOL_SUBJECT_GRADE ist die Beziehung umgekehrt m:1, dies wird auch Many-To-One genannt. Mit diesen Kenntnissen können nun die entsprechenden Annotationen aus JPA verwendet werden, um die Entitäten zu verbinden.\nBeispiel: Beziehung zwischen Schulfach und Mapping-Tabelle\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Entity @Table(name = \"SCHOOL_SUBJECT\") public class Schulfach { @OneToMany(mappedBy = \"schulfach\") private Set\u003cSchulfachNote\u003e noten; } @Entity @Table(name = \"SCHOOL_SUBJECT_GRADE\") public class SchulfachNote { @ManyToOne @JoinColumn(name = \"FK_SCHOOL_SUBJECT_ID\", nullable = false) private Schulfach schulfach; } Bei der Klasse Schulfach sehen wir die Verbindung zu allen Schulfach-Noten über ein Set und die Annotation @OneToMany unter Angabe des Namens der Instanzvariabel aus der Klasse SchulfachNote. Bei der Klasse SchulfachNote sehen wir die Verbindung zu einem Schulfach über die Annotation @ManyToOne und der Angabe der Kolonne, welche den Fremdschlüssel enthält. Die Angabe von nullable = false dient der Angabe, dass die Kolonne des Fremdschlüssels keine null-Werte zulässt.\nAufgabe\nVerbinde die anderen beiden Entitäten GRADE und SCHOOL_SUBJECT_GRADE mit den richtigen Beziehungen.\nIm nächsten Schritt werden nun die Repository-Interfaces angelegt.\nBeispiel: JPA-Repository für die Schulfachverwaltung\n1 2 3 4 @Repository public interface SchulfachAdminRepository extends JpaRepository\u003cSchulfach, String\u003e { } Bei diesem Repository sehen wir die Definition eines Interfaces, welches ein JpaRepository erweitert. Die generischen Angaben stehen für die Klasse der Entität und dessen Primärschlüssel-Typ. Durch dieses Repository stehen bereits die wichtigsten CRUD-Operationen zur Verfügung.\nAufgabe\nErstelle die Repository-Klassen für die beiden anderen Entitäten.\nDie folgende Aufzählung der Operationen ist nicht vollständig, zeigt aber welchen Funktionsumfang ein solches Repository nun bereits besitzt:\nList\u003cT\u003e findAll() liefert alle Einträge der Entität zurück T getReferenceById(ID id) liefert den Eintrag mit der entsprechenden ID zurück Optional\u003cT\u003e findById(ID id) liefert den Eintrag mit der entsprechenden ID als Optional zurück long count() zählt alle Einträge void delete(T entity) löscht die angegebene Entität \u003cS extends T\u003e S save(S entity) speichert die angegebene Entität und liefert sie zur weiteren Bearbeitung zurück Für die Realisierung von Methoden zur Abdeckung der funktionalen Anforderungen dient die folgende Tabelle:\nFunktionale Anforderung Abdeckung durch JpaRepository Alle Fächer und all deren Noten auflisten (ein Fach kann mehreren Noten beinhalten) Nein Alle Fächer und deren Durchschnittsnote auflisten Nein Für ein bestimmtes Fach: Alle Noten und die Durchschnittsnote des Fachs auflisten Nein Für ein bestimmtes Fach: Eine neue Note hinzufügen Methode save Für ein bestimmtes Fach: Eine bestehende Note ändern Methode save Für ein bestimmtes Fach: Eine bestehende Note löschen Methode delete Alle Fächer auflisten Methode findAll Neue Fächer hinzufügen Methode save Bestehende Fächer bearbeiten Methode save Bestehende Fächer löschen Methode delete Damit müssen nur die Methoden für die ein wenig komplizierteren Datenbank-Abfragen definiert werden. Der einfachste Weg zu schnellen Resultaten führt über die Entitäten und deren Verbindungen untereinander.\nEine Note (GRADE) und ein Schulfach (SCHOOL_SUBJECT) sind jeweils über die letzte Tabelle (SCHOOL_SUBJECT_GRADE) miteinander verbunden. Diese Verbindung kann ebenfalls über JPA in den Entitäten abgebildet werden.\nBeispiel: Many-To-Many Verbindung zwischen Noten und Schulfächern\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 @Entity @Table(name = \"SCHOOL_SUBJECT\") public class Schulfach { @ManyToMany @JoinTable( name = \"SCHOOL_SUBJECT_GRADE\", joinColumns = @JoinColumn(name = \"FK_SCHOOL_SUBJECT_ID\"), inverseJoinColumns = @JoinColumn(name = \"FK_GRADE_ID\") ) private List\u003cNote\u003e noten; } @Entity @Table(name = \"GRADE\") public class Note { @ManyToMany @JoinTable( name = \"SCHOOL_SUBJECT_GRADE\", joinColumns = @JoinColumn(name = \"FK_GRADE_ID\"), inverseJoinColumns = @JoinColumn(name = \"FK_SCHOOL_SUBJECT_ID\") ) private List\u003cSchoolSubject\u003e subjects; } Es reicht also die “Mapping”-Tabelle und die gerichteten Verbindungen in Form der Kolonnen-Namen anzugeben.\nDamit für ein bestimmtes Fach nun alle Noten abgeholt werden können, ist die folgende Implementation notwendig: Beispiel: Laden aller Noten für ein bestimmtes Fach\n1 2 3 4 5 6 @Repository public interface GradeRepository extends JpaRepository\u003cGrade, Integer\u003e { List\u003cGrade\u003e findGradesBySubjectsSubject(String subject); } Möglichkeit 2: JDBC-Template Möglichkeit 2: JDBC-Template Wer nicht mehr genau weiss was JDBC ist kann es hier nachlesen.\nDependency Damit JDBC verwendet werden kann, muss zuerst eine neue Dependency in das pom.xml hinzufügen werden.\n1 2 3 4 5 6 7 8 9 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-data-jdbc\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mariadb.jdbc\u003c/groupId\u003e \u003cartifactId\u003emariadb-java-client\u003c/artifactId\u003e \u003cversion\u003e3.1.0\u003c/version\u003e \u003c/dependency\u003e Entity-Klasse Eine Entity-Klasse ist eine normale Java-Klasse, die als Modell für eine Tabelle in der Datenbank dient. Jedes Objekt dieser Klasse entspricht einer Zeile in der Tabelle.\n1 2 3 4 5 6 @Getter @Setter public class Grade { private Long gradeId; private Double gradeValue; } Die Annotationen @Getter und @Setter sind zwei der am häufigsten verwendeten Annotationen in Lombok. Sie generieren automatisch Getter- und Setter-Methoden für die Felder einer Klasse. Lombok ist eine Java-Bibliothek, die es Entwicklern ermöglicht, boilerplate Code in ihren Java-Klassen zu reduzieren.\nDamit man Lombok jedoch verwenden kann, muss man die folgende Dependency im pom.xml hinzufügen:\n1 2 3 4 5 6 \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003cversion\u003e1.18.30\u003c/version\u003e \u003cscope\u003eprovided\u003c/scope\u003e \u003c/dependency\u003e Repository Ein Repository ein Designmuster oder eine Klasse, die den Datenbankzugriff für eine bestimmte Entität oder ein bestimmtes Objektmodell verwaltet. Es hilft, den Code zu organisieren und zentrale Methoden für den Zugriff auf die Datenbank bereitzustellen.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Repository public class StudentRepository { private final JdbcTemplate jdbcTemplate; public StudentRepositoryImpl(JdbcTemplate jdbcTemplate) { this.jdbcTemplate = jdbcTemplate; } public List\u003cSchoolSubject\u003e getAllSubjectsAndGrades() { return null; } // ... } Repository-Klassen und Service-Klassen verbinden Die Verbindung zwischen Repository- und Service-Klassen in einer Softwareanwendung ist entscheidend für eine saubere Struktur und effiziente Datenverwaltung. Repository-Klassen handhaben den Datenzugriff, während Service-Klassen die Geschäftslogik umsetzen. Service-Klassen nutzen die Methoden der Repository-Klassen, um auf Daten zuzugreifen oder diese zu manipulieren. Diese Trennung ermöglicht eine klare Aufgabenverteilung, verbessert die Wartbarkeit und erleichtert die Integration von Datenzugriff und Geschäftslogik.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Service public class StudentService { private final StudentRepository studentRepository; public StudentService(StudentRepository studentRepository) { this.studentRepository = studentRepository; } public List\u003cSchoolSubjectGradeDto\u003e getAllSubjectsAndGrades() { return studentRepository.getAllSubjectsAndGrades(); } // ... } Aufgabe Füge die benötigte Dependency in dein Projekt ein und erstelle die nötigen Entity-Klassen. Zudem erstelle die benötigten Services und Repositories in der korrekten packages Struktur.\nSchritt 5: Konfiguration anlegen In der Konfigurationsdatei können Einstellungen für die Datenbankverbindung, Log-Ebene, Profile, Spring-Profile, Webserver-Port, Sicherheitskonfigurationen und viele andere Aspekte der Anwendung angegeben werden.\nDie zwei häufigsten Arten eine Konfigurationsdatei anzulegen sind in application.yml oder die application.properties. Der Unterschied der beiden besteht darin das die application.yml-Datei, in YAML-Syntax geschrieben ist, und die application.properties-Datei eine einfache Key-Value-Paar-Syntax verwendet.\napplication.properties:\n1 2 3 4 spring.datasource.url=jdbc:mariadb://localhost:3306/[your_database] spring.datasource.username=[your_username] spring.datasource.password=[your_password] spring.datasource.driver-class-name=org.mariadb.jdbc.Driver application.yml:\n1 2 3 4 5 6 spring: datasource: url: jdbc:mariadb://localhost:3306/[your_database] username: [your_username] password: [your_password] driver-class-name: org.mariadb.jdbc.Driver Aufgabe\nErstelle deine Konfigurationsdatei entsprechend deiner Datenbank.\nSchritt 6: Profile anlegen In diesem Schritt erstellst du die gewünschten Spring Boot Profile: “student” und “admin”. Diese Profile werden benutzt, um die verfügbare Funktionalität einzuschränken bzw. zu erweitern. Welche Funktionalität mit welchem Profil zur Verfügung stehen darf, entnimmst du aus den funktionalen Anforderungen.\nMit der @Profile Annotation, kannst du bestimmte Beans für das gegebene Profil aktivieren bzw. deaktivieren.\nAufgabe\nAktiviere bzw. deaktiviere die Schnittstellen-Funktionalität entsprechend dem aktiven Profil\nSchritt 7 Business-Logik- und Persistenz-Layer anpassen Repository- und Service-Implementierungen In Spring Boot ist die Verwendung von Repository- und Service-Implementierungen eine bewährte Methode, um eine saubere Trennung von Geschäftslogik, Datenzugriff und Präsentation sicherzustellen. Diese Trennung hilft, den Code übersichtlich, wartbar und testbar zu machen.\nRepository-Interface: Definiert die Methoden für den Datenzugriff.\nRepository-Implementierung (RepositoryImpl): Implementiert die Methoden des Repository-Interfaces und führt die tatsächlichen Datenbankoperationen aus.\nService-Interface: Definiert die Methoden für die Geschäftslogik.\nService-Implementierung (ServiceImpl): Implementiert die Methoden des Service-Interfaces und ruft bei Bedarf das Repository auf, um auf Daten zuzugreifen.\n1 2 3 4 5 public interface StudentRepository { List\u003cSchoolSubject\u003e getAllSubjectsAndGrades(); // ... } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Repository public class StudentRepositoryImpl implements StudentRepository { private final JdbcTemplate jdbcTemplate; public StudentRepositoryImpl(JdbcTemplate jdbcTemplate) { this.jdbcTemplate = jdbcTemplate; } @Override public List\u003cSchoolSubject\u003e getAllSubjectsAndGrades() { return null; } // ... } Aufgabe\nPasse deine Services und Repositories entsprechend der Implementierungs-Methode an.\nSchritt 8 Persistenz-Layer fertigstellen (Nur für JDBC) Schritt 8 Persistenz-Layer fertigstellen (Nur für JDBC) Queries Typischerweise implementieren JDBC-Repositories benutzerdefinierte Methoden für spezielle Datenbankabfragen. Diese Methoden nutzen das JdbcTemplate (Teil des Spring-Frameworks), um SQL-Queries auszuführen. Dabei können Platzhalter oder Named Parameters verwendet werden, um dynamische Werte in die Abfragen einzufügen.\nPreparedStatementSetter ist ein funktionales Interface in Spring JDBC. Es wird verwendet, um Parameter für parametrisierte Abfragen auf einem PreparedStatement festzulegen. Die Verwendung von PreparedStatementSetter hilft, die Logik zum Setzen von Parametern zu kapseln, was den Code modularer und leichter wartbar macht.\n1 INSERT INTO SCHOOL_SUBJECT (subject_name) VALUES (?) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @Repository public class StudentRepositoryImpl implements StudentRepository { private final JdbcTemplate jdbcTemplate; public StudentRepositoryImpl(JdbcTemplate jdbcTemplate) { this.jdbcTemplate = jdbcTemplate; } // ... @Override public void addSubject(SchoolSubjectDto schoolSubjectDto) { String sql = \"INSERT INTO SCHOOL_SUBJECT (subject_name) VALUES (?)\"; PreparedStatementSetter preparedStatementSetter = preparedStatement -\u003e { preparedStatement.setString(1, schoolSubjectDto.getSubjectName()); }; jdbcTemplate.update(sql, preparedStatementSetter); } // ... } Mapping In der Softwareentwicklung stellt sich oft die Frage, wie man das Mapping zwischen verschiedenen Ebenen der Anwendung am besten handhabt. Insbesondere geht es darum, wie man Daten zwischen der Datenbank, der Geschäftslogik (Services) und der Benutzerschnittstelle (DTOs - Data Transfer Objects) hin- und herbewegt.\nEine Möglichkeit ist, das Mapping nicht im Service durchzuführen. Dies wird zwar nicht zwingend empfohlen, aber es ähnelt dem Ansatz von JPA (Java Persistence API) und kann daher vorteilhaft sein. Hierbei wird das Mapping eher in den Repositories durchgeführt. Dies verringert die Belastung des Service mit zusätzlichem Mapping und spezifischen Abfragen (Queries). Allerdings kann dies zu einer unübersichtlichen Repository-Schicht führen, da sie dann sowohl für das Mapping als auch für die Abfragen verantwortlich ist.\nWenn das Mapping im Service durchgeführt wird, bedeutet dies ein zusätzliches Mapping von der Abfrage (Query) zu den Entity-Objekten und dann zu den DTOs. Dies kann ineffizient erscheinen, da man ein Objekt erstellt, das später vom Garbage Collector aufgeräumt werden muss.\nDer JPA-Ansatz könnte mehr Daten zurückholen, als tatsächlich benötigt werden, da alle Eigenschaften in das Entity-Objekt geladen werden, selbst wenn sie im DTO nicht benötigt werden. Dies könnte ineffizient sein, insbesondere wenn nur ein Teil der Daten benötigt wird.\nIm Kontext von JDBC (Java Database Connectivity) gibt es viele verschiedene Ansätze und keinen “einen” richtigen Weg. Es ist möglich, JPA und JDBC zu mischen, um das Beste aus beiden Welten zu nutzen.\nInsgesamt ist die Wahl des richtigen Ansatzes abhängig von den Anforderungen des Projekts, der Skalierbarkeit, der Performance und den individuellen Vorlieben des Entwicklungsteams. Es ist wichtig, die Vor- und Nachteile der verschiedenen Ansätze abzuwägen und den am besten geeigneten Ansatz für das spezifische Projekt zu wählen.\nDTO zu Entity Durch das Mappen der Entity-Objekte auf DTOs können wir die Datenstruktur an die spezifischen Anforderungen anpassen. DTOs enthalten nur die relevanten Daten, die zwischen verschiedenen Teilen der Anwendung oder sogar zu externen Systemen übertragen werden müssen. Dies ermöglicht eine effizientere Datenübertragung und verhindert die Offenlegung von sensiblen oder unnötigen Informationen.\nDes Weiteren schafft die Verwendung von DTO’s eine klare Trennung der Verantwortlichkeiten. Die Entity-Objekte kümmern sich um die Interaktion mit der Datenbank, während die DTO’s die übertragenen Daten in geeigneter Form halten. Somit wird eine saubere Architektur gefördert, die gut skalierbar und wartbar ist.\n1 2 3 4 5 6 7 8 9 10 public static SchoolSubject mapDtoToEntity(SchoolSubjectDto dto) { if (dto == null) { return null; } SchoolSubject entity = new SchoolSubject(); entity.setSubjectId(dto.getSubjectId()); entity.setSubjectName(dto.getSubjectName()); return entity; } 1 2 3 4 5 6 7 8 9 10 11 12 13 @Service public class AdminService { private final AdminRepository adminRepository; public AdminService(AdminRepository adminRepository) { this.adminRepository = adminRepository; } public void addSubject(SchoolSubjectDto schoolSubjectDto) { adminRepository.addSubject(mapDtoToEntity(schoolSubjectDto)); } } RowMapper In JDBC, ist der RowMapper ein Interface, das verwendet wird, um das Mapping von Zeilen aus dem ResultSet auf Objekte zu ermöglichen. Es wird verwendet, um das Ergebnis jedes Datensatzes aus der Abfrage in ein Objekt umzuwandeln.\nErstelle eine Klasse, die das RowMapper-Interface implementiert und die mapRow-Methode überschreibt. In dieser Methode wird definiert, wie eine Zeile aus dem ResultSet in ein Objekt gemappt wird.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import org.springframework.jdbc.core.RowMapper; import java.sql.ResultSet; import java.sql.SQLException; public class SchoolSubjectDtoRowMapper implements RowMapper\u003cSchoolSubjectDto\u003e { @Override public SchoolSubjectDto mapRow(ResultSet resultSet, int rowNum) throws SQLException { Long subjectId = resultSet.getLong(\"subject_id\"); String subjectName = resultSet.getString(\"subject_name\"); return new SchoolSubjectDto(subjectId, subjectName); } } Im RepositoryImpl kann man nun die erstellte Mapper-Methode verwenden, um das Ergebnis der JDBC-Operation zu mappen.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @Repository public class StudentRepositoryImpl implements StudentRepository { private final NamedParameterJdbcTemplate namedParameterJdbcTemplate; private final CommonDeclarableProperties declarableProperties; public StudentRepositoryImpl(NamedParameterJdbcTemplate namedParameterJdbcTemplate, CommonDeclarableProperties declarableProperties) { this.namedParameterJdbcTemplate = namedParameterJdbcTemplate; this.declarableProperties = declarableProperties; } // ... @Override public List\u003cSchoolSubjectDto\u003e getAllSubjects() { String sql = \"SELECT * FROM SCHOOL_SUBJECT\"; return namedParameterJdbcTemplate.query(sql, new SchoolSubjectDtoRowMapper()); } // ... } ResultSetExtractor Auch der ResultSetExtractor ist ein funktionales Interface, das verwendet wird, um das Mapping von ResultSet auf ein Objekt oder eine Liste von Objekten zu ermöglichen. Es ermöglicht eine benutzerdefinierte Verarbeitung der ResultSet-Daten.\nErstelle eine Klasse und verwende das ResultSetExtractor-Interface, um zu definieren, wie das ResultSet in ein Objekt oder eine Liste von Objekten umgewandelt werden soll.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class SchoolSubjectDtoResultSetExtractor implements ResultSetExtractor\u003cList\u003cSchoolSubjectDto\u003e\u003e { @Override public List\u003cSchoolSubjectDto\u003e extractData(ResultSet resultSet) throws SQLException { List\u003cSchoolSubjectDto\u003e schoolSubjectDtos = new ArrayList\u003c\u003e(); while (resultSet.next()) { Long gradeId = resultSet.getLong(\"subject_id\"); String subjectName = resultSet.getString(\"subject_name\"); SchoolSubjectDto schoolSubjectDto = new SchoolSubjectDto(gradeId, subjectName); schoolSubjectDtos.add(schoolSubjectDto); } return schoolSubjectDtos; } } Im RepositoryImpl kann man nun die erstellte Extractor-Methode verwenden um das Ergebnis der JDBC Operation zu mappen.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @Repository public class AdminRepositoryImpl implements AdminRepository { private final NamedParameterJdbcTemplate namedParameterJdbcTemplate; private final JdbcTemplate jdbcTemplate; public AdminRepositoryImpl(NamedParameterJdbcTemplate namedParameterJdbcTemplate, JdbcTemplate jdbcTemplate) { this.namedParameterJdbcTemplate = namedParameterJdbcTemplate; this.jdbcTemplate = jdbcTemplate; } // ... @Override public List\u003cSchoolSubjectDto\u003e getAllSubjects() { String sql = \"SELECT * FROM SCHOOL_SUBJECT\"; return namedParameterJdbcTemplate.query(sql, new SchoolSubjectDtoResultSetExtractor()); } // ... } Aufgabe Ergänze deine Repositories mit den nötigen SQL-Queries (wähle selbst, ob du es auslagern möchtest oder nicht). Implementiere die benötigten Mapper und setze sie an den benötigten Orten ein (wähle selbst, ob du es mit einem Mapper oder Extractor machen willst).\nSchritt 9: API testen Sobald deine Schnittstelle umgesetzt wird bzw. bereits ab dem zweiten Schritt in diesem Auftrag, kann die Schnittstelle von HTTP-Clients angesprochen und getestet werden. In diesem Schritt wirst du deine Schnittstelle mit dem IntelliJ HTTP-Client testen.\nEine Alternative zum IntelliJ HTTP-Client bietet Swagger an. Swagger ist ein Open-Source-Framework, das in erster Linie dazu dient, APIs zu entwerfen, zu dokumentieren und zu testen. Es ermöglicht eine einfache und strukturierte Beschreibung von Webdiensten, um deren Funktionalitäten, Parameter und Endpunkte zu verstehen.\nMit Spring Boot 3 kann man neu nur noch eine Dependency hinzufügen damit der Swagger läuft. Diese sieht folgendermassen aus:\n1 2 3 4 5 \u003cdependency\u003e \u003cgroupId\u003eorg.springdoc\u003c/groupId\u003e \u003cartifactId\u003espringdoc-openapi-starter-webmvc-ui\u003c/artifactId\u003e \u003cversion\u003e2.2.0\u003c/version\u003e \u003c/dependency\u003e Für unsere Test-Zwecke reicht der IntelliJ HTTP-Client völlig aus.\nTesten mit IntelliJ HTTP Client Wenn du eine RestController-Klasse in IntelliJ offen hast, wird an einigen Stellen ein Symbol dargestellt, wie hier mit Rot unterstrichen: Wenn man den Pfeil neben dem Symbol drückt, kann man die Option “Generate Request in HTTP Client” auswählen: Somit wird der HTTP-Client Editor geöffnet, mit dem entsprechenden HTTP-Method und Pfad: Mit einem Klick auf dem grünen Pfeil, wird die HTTP Request ausgeführt. Wenn du ein Beispiel brauchst, um zu wissen, wie du Requests erstellst (z.B. solche mit einem Request-Body) kannst du auf dem Examples Pfeil (oben rechts) klicken und die entsprechende Beispiel-Datei öffnen.\nWeitere Dokumentation zum IntelliJ HTTP-Client findest du auf dieser IntelliJ IDEA Seite\nAufgabe\nErstelle eine HTTP-Request Datei, welche alle Methoden in deiner Schnittstelle ausführt.\nIntegrationstests mit H2 umsetzen Integrationstests mit H2 in einem Spring-Boot-Projekt umzusetzen, ist eine bewährte Methode, um die Interaktion zwischen verschiedenen Komponenten einer Anwendung zu testen, ohne auf eine reale Datenbank angewiesen zu sein. In diesem Kontext dient H2, eine In-Memory-Datenbank, als Ersatz für die eigentliche Datenbank und erlaubt es, Tests zu schreiben, welche die Anwendungslogik unter simulierten Bedingungen überprüft.\nStruktur Es wird folgende Ordnerstruktur empfohlen, damit das gesamte Testing wie gewollt funktioniert:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 src/ |-- main/ | |-- java/ | | |-- com/ | | |-- example/ | | |-- myapp/ | | |-- YourProductionCode.java |-- test/ | |-- java/ | | |-- com/ | | |-- example/ | | |-- myapp/ | | |-- integration/ | | |-- YourIntegrationTests.java | |-- resources/ | |-- application-test.properties | |-- schema.sql | |-- data.sql Dependencies Damit man H2 verwenden kann, muss man auch hier noch einen Dependency im pom.xml hinzufügen. Diese ist folgende:\n1 2 3 4 5 \u003cdependency\u003e \u003cgroupId\u003ecom.h2database\u003c/groupId\u003e \u003cartifactId\u003eh2\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e Konfiguration anlegen In der Testkonfiguration (z. B. application-test.properties), konfiguriert man H2 als Datenbank für die Integrationstests. Es wird die Verbindungs-URL, der Treiber und die Anmeldeinformationen für H2 festgelegt. Diese Datenbank wird in den Tests automatisch erstellt und verwaltet.\napplication-test.properties:\n1 2 3 4 5 6 spring.datasource.url=jdbc:h2:mem:testdb spring.datasource.driverClassName=org.h2.Driver spring.datasource.username=sa spring.datasource.password=password spring.datasource.platform=h2 spring.jpa.hibernate.ddl-auto=update application-test.yml:\n1 2 3 4 5 6 7 8 9 10 spring: datasource: url: jdbc:h2:mem:testdb username: sa password: password platform: h2 driver-class-name: org.h2.Driver jpa: hibernate: ddl-auto: update SQL Files Nun werden SQL-Skripte benötigt, die das Datenbankschema und Testdaten definieren. Diese Skripte werden während der Testausführung automatisch geladen.\nSchema File 1 2 3 4 CREATE TABLE SCHOOL_SUBJECT ( subject_id INT AUTO_INCREMENT PRIMARY KEY, subject_name VARCHAR(255) NOT NULL ); Data File 1 2 3 4 INSERT INTO SCHOOL_SUBJECT (subject_name) VALUES ('Mathematics'); INSERT INTO SCHOOL_SUBJECT (subject_name) VALUES ('History'); INSERT INTO SCHOOL_SUBJECT (subject_name) VALUES ('Science'); INSERT INTO SCHOOL_SUBJECT (subject_name) VALUES ('English'); Integration Test Integrationstests sind wichtig, um sicherzustellen, dass verschiedene Komponenten einer Anwendung (z. B. Klassen, Module, Services, REST-Endpunkte) ordnungsgemäss miteinander interagieren und Daten korrekt austauschen. Sie helfen dabei, potenzielle Fehler und Inkompatibilitäten zwischen den Komponenten frühzeitig zu erkennen und zu beheben.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @SpringBootTest @AutoConfigureMockMvc @ActiveProfiles(\"admin\") @ExtendWith(SpringExtension.class) public class AdminControllerIntegrationTest { @Autowired private MockMvc mockMvc; @MockBean private AdminService adminService; @Test public void testGetAllSubjects() throws Exception { List\u003cSchoolSubjectDto\u003e subjects = new ArrayList\u003c\u003e(); subjects.add(new SchoolSubjectDto(1, \"Mathematics\")); subjects.add(new SchoolSubjectDto(2, \"History\")); when(adminService.getAllSubjects()).thenReturn(subjects); mockMvc.perform(get(\"/api/admin/subjects\") .contentType(MediaType.APPLICATION_JSON)) .andExpect(status().isOk()) .andExpect(content().contentType(MediaType.APPLICATION_JSON)) .andExpect(jsonPath(\"$[0].subjectId\").value(1)) .andExpect(jsonPath(\"$[0].subjectName\").value(\"Mathematics\")) .andExpect(jsonPath(\"$[1].subjectId\").value(2)) .andExpect(jsonPath(\"$[1].subjectName\").value(\"History\")); } // ... } Jetzt bist du dran. Löse bitte die Aufgaben zu Spring in den Labs.\n","categories":"","description":"Modul #J8 - Spring Framework - Wie erstelle ich ein Projekt mit Spring\n","excerpt":"Modul #J8 - Spring Framework - Wie erstelle ich ein Projekt mit Spring …","ref":"/de/docs/02_java/12_spring-framework/08_projekt-erstellen/","tags":"","title":"Projekt Erstellen"},{"body":"Du findest die Anleitung zur Einrichtung eines SSH-Keys hier.\nEntschuldige, da fehlt noch was...\n--\u003e Lab konvertieren:\nGit Hands On Aufgabe ../../../../labs/04_git/01_grundlagen\n","categories":"","description":"","excerpt":"Du findest die Anleitung zur Einrichtung eines SSH-Keys hier. …","ref":"/docs/04_git/01_grundwissen/08_git-ssh/","tags":"","title":"SSH-Key in Git"},{"body":"Du findest die Anleitung zur Einrichtung eines SSH-Keys hier.\nJetzt bist du dran. Löse bitte die Git Hands On Aufgabe in den Labs.\n","categories":"","description":"","excerpt":"Du findest die Anleitung zur Einrichtung eines SSH-Keys hier.\nJetzt …","ref":"/de/docs/04_git/01_grundwissen/08_git-ssh/","tags":"","title":"SSH-Key in Git"},{"body":"Ziele Ich kann in eigenen Worten und mit Hilfe von Skizzen erklären, was Streams sind und wofür sie verwendet werden. Ich kann Streams für die Iteration über Listen anwenden. Ich kann mindestens eine intermediäre und eine terminale Stream-Operation aus dem Kopf nennen und beschreiben. Streams Mit Java 8 ist das Stream-API zum java.util-Package des JDKs hinzugekommen. Das API ist eine Erweiterung des Java-Collection-Frameworks mit einer Schnittstelle im Stil der funktionalen Programmierung. Mit dem Stream-API wurden mächtige Möglichkeiten zur Durchführung von Operationen auf Arrays und Listen eingeführt.\nIn diesem Teil wird erklärt, was Streams sind und wie sie für Operationen auf Arrays und Listen eingesetzt werden können.\nWas ist ein Stream? Streams stellen Ströme von Referenzen dar, die es erlauben, verkettete Operationen auf diesen Referenzen nacheinander oder parallel auszuführen.\nEin Stream erhält seinen Input aus Datenstrukturen wie Arrays oder Listen und führt die gewünschte Operationen auf diesem Input aus, ohne die ursprüngliche Datenstruktur zu verändern.\nNachfolgend ist ein Code aufgelistet, der aus einem Array mit den verschiedenen Punktzahlen von verschiedenen Studierenden aus einer Prüfung\nalle Punktzahlen aussortiert, die 0 oder kleiner sind (Intermediäre Operation filter(...)), dann die Punktzahlen in Noten umrechnet (Intermediäre Operation mapToDouble(...)), und dann den Durchschnitt über alle Studierenden berechnet (Terminale Operation average(), zu Deutsch “Durchschnitt”). 1 2 3 4 5 6 7 8 9 10 11 12 import java.util.Arrays; int[] scores = new int[] { 4, 19, 22, 23, 0, 12 }; int maxScores = 24; var averageGrade = Arrays.stream(scores) .filter(score -\u003e score \u003e 0) .mapToDouble(score -\u003e score * 5f / maxScores + 1f) .average(); System.out.println(\"Average: \" + averageGrade.getAsDouble()); Die einzelnen Bestandteile werden in den weiteren Unterkapitel genauer beleuchtet und die sogenannten Lambda-Ausdrücke score -\u003e score \u003e 0 und score -\u003e score * 5f / maxScores + 1f werden später erläutert.\nErzeugung von Streams Damit überhaupt mit Streams gearbeitet werden kann, muss zuerst ein Stream existieren bzw. erzeugt werden. Streams können aus Arrays, Listen und anderen Collections erzeugt werden.\nErzeugung aus Elementes eines Arrays Aus den Elementen eines Arrays kann ein Stream mithilfe der Klasse Arrays aus dem java.util-Package wie folgt erzeugt werden:\n1 2 3 4 5 int[] numbers = {1, 2, 3, 4}; IntStream numbersStream = Arrays.stream(numbers); // IntStream ist eine Spezialisierung von Stream, welche die Verabeitung von primitive int-Werte ermöglicht. String[] greeting = {\"Hello\", \"Streams\"}; Stream\u003cString\u003e greetingStream = Arrays.stream(greeting); // Anhand der spitzigen Klammern wird ersichtlich, welche Objekttypen durch den Stream verarbeitet werden. Erzeugung aus Elementen einer Liste Wenn eine Liste bereits vorhanden ist, kann die Methode stream() aufgerufen werden, um einen Stream aus den Elementen der Liste zu erzeugen:\n1 2 3 4 5 6 List\u003cString\u003e stringList = new ArrayList\u003c\u003e(); stringList.add(\"Hello\"); stringList.add(\"List\"); stringList.add(\"Stream\"); Stream\u003cString\u003e stream2 = stringList.stream(); Unterschied zwischen generischen Streams und IntStreams Wenn du beim Aufruf von Arrays.stream(...) ein Array vom Typ int[] oder double[] übergibst, erhältst du keinen gewöhnlichen Stream vom Typ Stream sondern einen optimierten Stream-Typ für den entsprechenden Datentyp:\nein int-Array resultiert in einem IntStream, ein double-Array in einem DoubleStream, usw. An dieser Stelle könnte man sich fragen wieso. Aber die Antwort ist ziemlich klar:\nEin IntStream besitzt mehr Methoden als ein Stream\u003cInteger\u003e. So kannst du auf dem Stream z.B. direkt eine Summe (.sum()) oder Durchschnitt (.average()) berechnen, statt selbst diese Funktionen zu implementieren.\nHast du z.B. ein Stream\u003cInteger\u003e und möchtest aber eine Summe berechnen, dann kannst du z.B. den Stream\u003cInteger\u003e mit der Methode mapToInt(...) in einen IntStream umwandeln:\n1 2 3 4 5 6 Stream\u003cInteger\u003e integerStream = Stream.of(1, 2, 3, 4, 5); IntStream intStream = integerStream.mapToInt(Integer::intValue); int summe = intStream.sum(); System.out.println(\"Summe der Zahlen 1 bis 5: \" + summe); Lasse dich von der “Methodenreferenz” Integer::intValue nicht verwirren - wird in einem der nächsten Unterkapitel erklärt. Diese wird hier angegeben, damit beim Stream klar ist, wie jeder einzelne Integer in einen int umgewandelt wird. In diesem Fall wird ein Integer integer wie folgt umgewandelt: int neuerWert = integer.intValue().\nLambda Expressions Streams arbeiten mit sog. Lambda-Expressions oder Methodenreferenzen. Lambda Expressions (Lambda-Ausdrücke) wurden in Java 8 eingeführt, damit Funktionen als Argumente bei Methoden übergeben werden können.\nDa Lambda-Expressions oft in Streams verwendet werden, wird hier aufgezeigt, wie Lambdas aussehen und wie sie verwendet werden können.\nLambda-Ausdrücke in Java sind quasi Methoden ohne Namen. Sie bestehen aus folgenden Elementen:\neiner Liste von Parametern. Mehrere Parameter werden durch ein Komma separiert und mit Klammern umrundet. (keine Parameter werden mit leeren Klammern () dargestellt, einen Parameter muss nicht zwingend mit Klammern umrundet werden) einem Pfeil-Token -\u003e und einem Funktionsrumpf. Wenn der Funktionsrumpf mehrere Anweisungen lang ist, wird er mit geschweiften Klammern { ... } umrundet. Wenn keine geschweiften Klammern verwendet werden, dann ist der Ausdruck nach dem Pfeil-Token automatisch der Rückgabewert der Funktion (das return entfällt). Im Gegensatz zu Methoden werden der Rückgabetyp und Exceptions nicht spezifiziert, sondern vom Compiler “erraten”.\nIm Beispiel mit den Prüfungsnoten haben wir mit .mapToDouble(score -\u003e score * 5.0 / maxScores + 1.0) die einzelnen Punktzahlen in Noten umgerechnet (map()-Methoden werden später erklärt). Hierbei wurde der Lambda-Ausdruck score -\u003e score * 5.0 / maxScores + 1.0 verwendet. Dieser Lambda-Ausdruck ist eine Funktion (Methode), die beschreibt, wie jede Punktzahl in eine Note umgerechnet werden soll. Würden wir diesen Lambda-Ausdruck in eine Methode umschreiben, dann könnte diese so aussehen:\n1 2 3 private static double punkteZuNote(int score) { return score * 5.0 / maxScores + 1.0; } Der Lambda-Ausdruck score -\u003e score \u003e 0 hingegen könnte als Methode so geschrieben werden:\n1 2 3 private static boolean isScoreGreaterThan0(int score) { return score \u003e 0; } Beispiele\nHier noch ein paar Beispiele, wie Lambda-Ausdrücke geschrieben werden können:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // keine Parameter () -\u003e System.out.println(\"Ich habe kein Parameter\") () -\u003e return 1 // ein Parameter word -\u003e System.out.printf(\"Ich habe einen Parameter erhalten, nämlich: %s\", word) // zwei oder mehr Parameter (name, age) -\u003e System.out.println(\"My name is \" + name + \" and I am \" + age + \"years old\") // Funktionsrumpf mehrzeilig (name, age) -\u003e { System.out.println(\"My name is \" + name); System.out.println(\"I am \" + age + \"years old\"); } Method Reference Eine Methoden-Referenz ist die verkürzte Schreibweise einer Lambda-Expression, welche nur einen einzigen Methodenaufruf beinhaltet. Die generische Syntax für Methodenreferenz sieht wie folgt aus: Klasse::methode. Bei Methoden-Referenzen werden die Argumente für die Methode nicht notiert.\n1 2 3 4 5 6 // Lambda-Expression mit einem Methodenaufruf (word) -\u003e System.out.println(word) // Method-Reference Syntax der obigen Lambda-Expression. Funktioniert sowohl für statische als auch instance Methoden // Das Argument (word) muss nicht mitgegeben werden System.out::println Der wesentliche Vorteil von dieser Schreibweise ist, dass er kürzer ist. Lambda-Ausdrücke sind aber oft einfacher zu verstehen.\nParallele Streams Anders als beim sequentiellen Stream werden beim ParallelStream mehrere Elemente gleichzeitig verarbeitet, um die Geschwindigkeit zu erhöhen.\nAls Beispiel haben wir eine Liste von Zahlen wollen diese summieren. Mit einem normalen Stream würdest du nun jede Zahl nacheinander verarbeiten. Mit einem ParallelStream hingegen werden die Zahlen auf mehrere Threads verteilt und gleichzeitig verarbeitet.\n1 2 3 4 5 6 7 List\u003cInteger\u003e numbers = Arrays.asList(1, 2, 3, 4, 5); // normaler Stream int sum = numbers.stream().reduce(0, Integer::sum); //paralleler Stream int sum = numbers.parallelStream().reduce(0, Integer::sum); ParallelStream kann bei großen Datenmengen schneller sein, muss aber nicht immer der Fall sein.\nMethodenausführung auf Streams Im Beispiel mit den Prüfungsnoten haben wir verschiedene Operationen auf dem Stream durchgeführt, die die einzelnen Werte entweder umrechnen oder am Schluss in einem einzigen Wert zusammenfasst (z.B. average()). Folglich stellen Streams Operationen zur Verfügung, welche in zwei Kategorien unterteilt werden können:\nIntermediäre Operationen, welche am Ende der Verarbeitung in einem Stream resultieren (und somit eine weitere, verkettete Verarbeitung ermöglichen) wie z.B. filter(...) oder map(...). Terminale Operationen, welche am Ende der Verarbeitung einen Wert zurückliefern (und somit den Stream beenden) wie sum() oder average(). Folgendes Bild illustriert die Arbeitsweise von Streams Nun werden einige Operationen auf Streams vorgestellt:\nIntermediäre Operationen: filter(...) sortiert alle Elemente aus, die NICHT die übergebenen Bedingung erfüllen. map(...), mapToInt(...) und mapToDouble(...) wandeln die einzelnen Stream-Elemente in andere Werte um (bilden diese ab auf andere). sorted() sortiert die einzelnen Werte. Terminale Operationen: Mit forEach(...) kann für jedes Element etwas gemacht werden (z.B. jedes Element ausgeben). collect(...) und toArray(...) füllen die einzelnen Elemente in Listen oder Arrays ab. Intermediäre Operationen Die filter(...)-Methode Die filter(...)-Methode ist eine intermediäre Operation, die Elemente in einem Stream auf diejenigen beschränkt, die einer bestimmten Bedingung entsprechen. Diese Bedingung wird als Lambda-Ausdruck angegeben, der true zurückgibt, wenn das Element im Stream bleiben soll. Gibt er false zurück, wird das Element aussortiert.\nIm folgenden Beispiel werden alle ungeraden Zahlen aus einem Stream entfernt und dann alle verbleibenden Elemente ausgegeben:\n1 2 3 IntStream.of(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 15) .filter(x -\u003e x % 2 == 0) .forEach(System.out::println); Die map(...)- und mapToInt(...)-Methode Die map(...)- und mapToInt(...)-Methode gehört zu den intermediären Operationen eines Streams.\nDie Methode liefert einen Stream zurück, worin jedes einzelne Element durch den Rückgabewert der übergebenen Funktion ersetzt wurde.\nDie map(...)-Methode wird oft verwendet, um Daten umzuwandeln oder den Stream auf ein Feld/Methode eines Objekts zu fokussieren.\nHier ein Beispiel, in welchem Zahlen durch ihr Quadrat ersetzt werden:\n1 Stream.of(1,2,3,4).map(x -\u003e x * x).forEach(System.out::println); Und hier ein Beispiel, wo uns nur die Länge der Strings interessiert:\n1 2 3 Stream.of(\"Ein\", \"Ninja\", \"bewegt\", \"sich\", \"lautlos\", \"wie\", \"der\", \"Wind\", \"und\", \"unsichtbar\", \"wie\", \"der\", \"Schatten\") .map(word -\u003e word.length()) .forEach(System.out::println); Im zweiten Beispiel könnte unser Ziel sein, die durchschnittliche Länge der Wörter zu berechnen. Wenn man mathematische Operationen mit Streams durchführen möchte, dann ist es oft einfacher, den Stream in einen für den mathematischen Typ spezifischen Stream wie IntStream zu “verwandeln”, damit Funktionen wie sum() und average() (Durchschnitt) nicht manuell implementiert werden müssen. Hierfür kannst du statt der map(...)- die mapToInt(...)-Methode (oder mapToDouble) verwenden:\n1 2 3 4 5 6 7 8 System.out.println( \"Durchschnittliche Länge eines Wortes: \" + Stream.of(\"Ein\", \"Ninja\", \"bewegt\", \"sich\", \"lautlos\", \"wie\", \"der\", \"Wind\", \"und\", \"unsichtbar\", \"wie\", \"der\", \"Schatten\") .mapToInt(word -\u003e word.length()) .average() ); Die sorted() Methode Die sorted()-Methode gehört zu den intermediären Operationen eines Streams.\nDie Methode liefert ein Stream zurück, worin die Elemente im Stream nach ihrer natürlichen Reihenfolge (natural order) sortiert sind.\nDie Syntax der Methode ist wie folgt: Stream\u003cT\u003e sorted() wobei T der Typ der Elemente innerhalb des Streams ist\nBeispiel mit einem Array\n1 2 3 4 5 6 7 8 // Erstelle ein Array mit Strings String[] greeting = {\"C\", \"A\", \"B\"}; // Sortiere die Strings nach ihrer natürlichen Reihenfolge (alphabetisch) und // gib die sortierten Elementen in der Console wieder aus Arrays.stream(greeting) .sorted() .forEach(System.out::println); Beispiel mit einer Liste\n1 2 3 4 5 6 7 8 // Erstelle eine Liste mit Zahlen List\u003cInteger\u003e list = Arrays.asList(-9, -18, 0, 25, 4); // Sortiere die Zahlen nach ihrer natürlichen Reihenfolge (numerisch sortiert) und // gib die sortierten Elementen in der Console wieder aus list.stream() .sorted() .forEach(System.out::println); Terminale Operationen Die forEach() Methode Die forEach(Consumer action) Methode gehört zu den terminalen Operationen eines Streams.\nDer Parameter action ist vom Typ Consumer (ist ein FunctionalInterface). Dieser Typ repräsentiert eine Operation (eine Funktion), welche nur ein einziges Input-Argument akzeptiert und keine Ergebnisse (also void) zurückliefert. Ein Beispiel für so einen Consumer ist die Methode System.out.println(...), welche maximal ein einziges Objekt als Parameter akzeptiert, dieses Objekt in den Standard-Output ausgibt und void (also kein Ergebnis) zurückliefert. Die Methode System.out.println erfüllt also die Bedingungen eines Consumers und kann als Parameter für die forEach() Methode verwendet werden\nDie forEach()-Methode kann als Ersatz für einen for-Loop verwendet werden.\nBeispiel mit einem Array\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 String[] greeting = {\"Hello\", \"Streams\"}; // Hier wid jedes Element des Arrays ausgegeben for (String word : greeting) { System.out.println(word); } // Hier wird mithilfe von Streams dasselbe erreicht wie beim for-loop Arrays.stream(greeting) .forEach(word -\u003e System.out.println(word)); // Und nun noch kürzer mit der Method-Reference Syntax der obigen Lambda-Expression Arrays.stream(greeting) .forEach(System.out::println); Beispiel mit einer Liste\n1 2 3 4 5 6 7 8 9 10 11 12 13 List\u003cString\u003e greetingList = new ArrayList\u003c\u003e(); greetingList.add(\"Hello\"); greetingList.add(\"Stream\"); greetingList.add(\"List\"); // Einmal mit der vollen Syntax der Lambda-Expression greetingList.stream().forEach(word -\u003e System.out.println(word)); // Und einmal mit der verkürzte Variante mittels Method-Reference greetingList.stream().forEach(System.out::println); // Collection, darunter auch Listen, haben selbst eine forEach Methode, // welche die gleichen Ergebnisse liefert, wie diejenige vom Stream-Interface greetingList.forEach(System.out::println); Die collect()-Methode Die collect(Collector collector)-Methode ist auch eine terminale Operation auf einem Stream. Sie ermöglicht es, die Ergebnisse der Bearbeitung des Streams in einer neuen Collection (List, Map usw.) zu speichern. Dies ist nötig, da bei der Bearbeitung des Streams die ursprüngliche Elemente nicht geändert werden können.\nDer Parameter collector ist vom Typ Collector. Die Aufgabe eines Collectors besteht darin, mehrere Input-Elemente in einem Result-Container zusammenzufassen. Zum Beispiel können die Elemente eines Streams in einer Liste “gespeichert” und zurückgeliefert werden.\nUm ein Collector zu erzeugen, wird oft die Klasse Collectors aus dem java.util.stream-Package verwendet. Diese beinhaltet mehrere öffentliche, statische Methode um Collectors unterschiedlicher Typen (List, Map usw.) erzeugen zu können.\nBeispiel\n1 2 3 4 5 6 7 8 9 10 11 12 13 // Erstelle eine Liste von unsortieren Zahlen List\u003cInteger\u003e unsortedList = Arrays.asList(-9, -18, 0, 25, 4); // Aus der unstortierte Liste, erstelle eine NEUE, sortierte Liste List\u003cInteger\u003e sortedList = unsortedList.stream() .sorted() .collect(Collectors.toList()); // hier wird aus dem sortierten Stream eine neue Liste erstellt // gib die unsortierte Liste in der Konsole aus (die Original-Liste wurde nicht verändert!) unsortedList.forEach(System.out::println); // gib die sortierte Liste in der Konsole aus sortedList.forEach(System.out::println); Die toArray(...)-Methode Mit der collect(...)-Methode kannst du den Stream in eine Liste umwandeln. Wenn du den Stream aber in ein Array umwandeln möchtest, dann hilft dir die toArray(...)-Methode:\n1 2 3 4 5 6 7 8 9 String[] strings = Stream.of(\"A\", \"B\", \"C\") // String[]::new muss noch angegeben werden, damit ein String-Array (und nicht ein Object[]) zurückgegeben wird: .toArray(String[]::new); int[] array = Stream.of(1,2,3,4) // Zu einem IntStream umwandeln, weil sonst ein Integer[] statt int[] resultieren müsste: .mapToInt(Integer::intValue) .toArray(); Die toArray(...)-Methode ist eine terminale Operation auf einem Stream.\nDie reduce(...)-Methode Die reduce()-Methode in Java Streams wird verwendet, um mehrere Werte in einen einzelnen Wert zu kombinieren. Man gibt eine Funktion an, die zwei Werte zusammenfügt, und kann einen Startwert angeben, um auch bei einem leeren Stream ein Ergebnis zu erhalten.\n1 2 3 4 5 6 7 List\u003cInteger\u003e numbers = Arrays.asList(1, 2, 3, 4, 5); // Summe berechnen int sum = numbers.stream() .reduce(0, (a, b) -\u003e a + b); System.out.println(\"Summe: \" + sum); // Ausgabe: Summe: 15 Jetzt bist du dran. Löse bitte die Aufgabe 1 - 3 in den Stream-Labs.\n","categories":"","description":"Modul #J6\n","excerpt":"Modul #J6\n","ref":"/docs/02_java/10_java-collections/08_streams/","tags":"","title":"Streams Basics"},{"body":"Ziele Ich kann in eigenen Worten und mit Hilfe von Skizzen erklären, was Streams sind und wofür sie verwendet werden. Ich kann Streams für die Iteration über Listen anwenden. Ich kann mindestens eine intermediäre und eine terminale Stream-Operation aus dem Kopf nennen und beschreiben. Streams Mit Java 8 ist das Stream-API zum java.util-Package des JDKs hinzugekommen. Das API ist eine Erweiterung des Java-Collection-Frameworks mit einer Schnittstelle im Stil der funktionalen Programmierung. Mit dem Stream-API wurden mächtige Möglichkeiten zur Durchführung von Operationen auf Arrays und Listen eingeführt.\nIn diesem Teil wird erklärt, was Streams sind und wie sie für Operationen auf Arrays und Listen eingesetzt werden können.\nWas ist ein Stream? Streams stellen Ströme von Referenzen dar, die es erlauben, verkettete Operationen auf diesen Referenzen nacheinander oder parallel auszuführen.\nEin Stream erhält seinen Input aus Datenstrukturen wie Arrays oder Listen und führt die gewünschte Operationen auf diesem Input aus, ohne die ursprüngliche Datenstruktur zu verändern.\nNachfolgend ist ein Code aufgelistet, der aus einem Array mit den verschiedenen Punktzahlen von verschiedenen Studierenden aus einer Prüfung\nalle Punktzahlen aussortiert, die 0 oder kleiner sind (Intermediäre Operation filter(...)), dann die Punktzahlen in Noten umrechnet (Intermediäre Operation mapToDouble(...)), und dann den Durchschnitt über alle Studierenden berechnet (Terminale Operation average(), zu Deutsch “Durchschnitt”). 1 2 3 4 5 6 7 8 9 10 11 12 import java.util.Arrays; int[] scores = new int[] { 4, 19, 22, 23, 0, 12 }; int maxScores = 24; var averageGrade = Arrays.stream(scores) .filter(score -\u003e score \u003e 0) .mapToDouble(score -\u003e score * 5f / maxScores + 1f) .average(); System.out.println(\"Average: \" + averageGrade.getAsDouble()); Die einzelnen Bestandteile werden in den weiteren Unterkapitel genauer beleuchtet und die sogenannten Lambda-Ausdrücke score -\u003e score \u003e 0 und score -\u003e score * 5f / maxScores + 1f werden später erläutert.\nErzeugung von Streams Damit überhaupt mit Streams gearbeitet werden kann, muss zuerst ein Stream existieren bzw. erzeugt werden. Streams können aus Arrays, Listen und anderen Collections erzeugt werden.\nErzeugung aus Elementes eines Arrays Aus den Elementen eines Arrays kann ein Stream mithilfe der Klasse Arrays aus dem java.util-Package wie folgt erzeugt werden:\n1 2 3 4 5 int[] numbers = {1, 2, 3, 4}; IntStream numbersStream = Arrays.stream(numbers); // IntStream ist eine Spezialisierung von Stream, welche die Verabeitung von primitive int-Werte ermöglicht. String[] greeting = {\"Hello\", \"Streams\"}; Stream\u003cString\u003e greetingStream = Arrays.stream(greeting); // Anhand der spitzigen Klammern wird ersichtlich, welche Objekttypen durch den Stream verarbeitet werden. Erzeugung aus Elementen einer Liste Wenn eine Liste bereits vorhanden ist, kann die Methode stream() aufgerufen werden, um einen Stream aus den Elementen der Liste zu erzeugen:\n1 2 3 4 5 6 List\u003cString\u003e stringList = new ArrayList\u003c\u003e(); stringList.add(\"Hello\"); stringList.add(\"List\"); stringList.add(\"Stream\"); Stream\u003cString\u003e stream2 = stringList.stream(); Unterschied zwischen generischen Streams und IntStreams Wenn du beim Aufruf von Arrays.stream(...) ein Array vom Typ int[] oder double[] übergibst, erhältst du keinen gewöhnlichen Stream vom Typ Stream sondern einen optimierten Stream-Typ für den entsprechenden Datentyp:\nein int-Array resultiert in einem IntStream, ein double-Array in einem DoubleStream, usw. An dieser Stelle könnte man sich fragen wieso. Aber die Antwort ist ziemlich klar:\nEin IntStream besitzt mehr Methoden als ein Stream\u003cInteger\u003e. So kannst du auf dem Stream z.B. direkt eine Summe (.sum()) oder Durchschnitt (.average()) berechnen, statt selbst diese Funktionen zu implementieren.\nHast du z.B. ein Stream\u003cInteger\u003e und möchtest aber eine Summe berechnen, dann kannst du z.B. den Stream\u003cInteger\u003e mit der Methode mapToInt(...) in einen IntStream umwandeln:\n1 2 3 4 5 6 Stream\u003cInteger\u003e integerStream = Stream.of(1, 2, 3, 4, 5); IntStream intStream = integerStream.mapToInt(Integer::intValue); int summe = intStream.sum(); System.out.println(\"Summe der Zahlen 1 bis 5: \" + summe); Lasse dich von der “Methodenreferenz” Integer::intValue nicht verwirren - wird in einem der nächsten Unterkapitel erklärt. Diese wird hier angegeben, damit beim Stream klar ist, wie jeder einzelne Integer in einen int umgewandelt wird. In diesem Fall wird ein Integer integer wie folgt umgewandelt: int neuerWert = integer.intValue().\nLambda Expressions Streams arbeiten mit sog. Lambda-Expressions oder Methodenreferenzen. Lambda Expressions (Lambda-Ausdrücke) wurden in Java 8 eingeführt, damit Funktionen als Argumente bei Methoden übergeben werden können.\nDa Lambda-Expressions oft in Streams verwendet werden, wird hier aufgezeigt, wie Lambdas aussehen und wie sie verwendet werden können.\nLambda-Ausdrücke in Java sind quasi Methoden ohne Namen. Sie bestehen aus folgenden Elementen:\neiner Liste von Parametern. Mehrere Parameter werden durch ein Komma separiert und mit Klammern umrundet. (keine Parameter werden mit leeren Klammern () dargestellt, einen Parameter muss nicht zwingend mit Klammern umrundet werden) einem Pfeil-Token -\u003e und einem Funktionsrumpf. Wenn der Funktionsrumpf mehrere Anweisungen lang ist, wird er mit geschweiften Klammern { ... } umrundet. Wenn keine geschweiften Klammern verwendet werden, dann ist der Ausdruck nach dem Pfeil-Token automatisch der Rückgabewert der Funktion (das return entfällt). Im Gegensatz zu Methoden werden der Rückgabetyp und Exceptions nicht spezifiziert, sondern vom Compiler “erraten”.\nIm Beispiel mit den Prüfungsnoten haben wir mit .mapToDouble(score -\u003e score * 5.0 / maxScores + 1.0) die einzelnen Punktzahlen in Noten umgerechnet (map()-Methoden werden später erklärt). Hierbei wurde der Lambda-Ausdruck score -\u003e score * 5.0 / maxScores + 1.0 verwendet. Dieser Lambda-Ausdruck ist eine Funktion (Methode), die beschreibt, wie jede Punktzahl in eine Note umgerechnet werden soll. Würden wir diesen Lambda-Ausdruck in eine Methode umschreiben, dann könnte diese so aussehen:\n1 2 3 private static double punkteZuNote(int score) { return score * 5.0 / maxScores + 1.0; } Der Lambda-Ausdruck score -\u003e score \u003e 0 hingegen könnte als Methode so geschrieben werden:\n1 2 3 private static boolean isScoreGreaterThan0(int score) { return score \u003e 0; } Beispiele\nHier noch ein paar Beispiele, wie Lambda-Ausdrücke geschrieben werden können:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // keine Parameter () -\u003e System.out.println(\"Ich habe kein Parameter\") () -\u003e return 1 // ein Parameter word -\u003e System.out.printf(\"Ich habe einen Parameter erhalten, nämlich: %s\", word) // zwei oder mehr Parameter (name, age) -\u003e System.out.println(\"My name is \" + name + \" and I am \" + age + \"years old\") // Funktionsrumpf mehrzeilig (name, age) -\u003e { System.out.println(\"My name is \" + name); System.out.println(\"I am \" + age + \"years old\"); } Method Reference Eine Methoden-Referenz ist die verkürzte Schreibweise einer Lambda-Expression, welche nur einen einzigen Methodenaufruf beinhaltet. Die generische Syntax für Methodenreferenz sieht wie folgt aus: Klasse::methode. Bei Methoden-Referenzen werden die Argumente für die Methode nicht notiert.\n1 2 3 4 5 6 // Lambda-Expression mit einem Methodenaufruf (word) -\u003e System.out.println(word) // Method-Reference Syntax der obigen Lambda-Expression. Funktioniert sowohl für statische als auch instance Methoden // Das Argument (word) muss nicht mitgegeben werden System.out::println Der wesentliche Vorteil von dieser Schreibweise ist, dass er kürzer ist. Lambda-Ausdrücke sind aber oft einfacher zu verstehen.\nParallele Streams Anders als beim sequentiellen Stream werden beim ParallelStream mehrere Elemente gleichzeitig verarbeitet, um die Geschwindigkeit zu erhöhen.\nAls Beispiel haben wir eine Liste von Zahlen wollen diese summieren. Mit einem normalen Stream würdest du nun jede Zahl nacheinander verarbeiten. Mit einem ParallelStream hingegen werden die Zahlen auf mehrere Threads verteilt und gleichzeitig verarbeitet.\n1 2 3 4 5 6 7 List\u003cInteger\u003e numbers = Arrays.asList(1, 2, 3, 4, 5); // normaler Stream int sum = numbers.stream().reduce(0, Integer::sum); //paralleler Stream int sum = numbers.parallelStream().reduce(0, Integer::sum); ParallelStream kann bei großen Datenmengen schneller sein, muss aber nicht immer der Fall sein.\nMethodenausführung auf Streams Im Beispiel mit den Prüfungsnoten haben wir verschiedene Operationen auf dem Stream durchgeführt, die die einzelnen Werte entweder umrechnen oder am Schluss in einem einzigen Wert zusammenfasst (z.B. average()). Folglich stellen Streams Operationen zur Verfügung, welche in zwei Kategorien unterteilt werden können:\nIntermediäre Operationen, welche am Ende der Verarbeitung in einem Stream resultieren (und somit eine weitere, verkettete Verarbeitung ermöglichen) wie z.B. filter(...) oder map(...). Terminale Operationen, welche am Ende der Verarbeitung einen Wert zurückliefern (und somit den Stream beenden) wie sum() oder average(). Folgendes Bild illustriert die Arbeitsweise von Streams Nun werden einige Operationen auf Streams vorgestellt:\nIntermediäre Operationen: filter(...) sortiert alle Elemente aus, die NICHT die übergebenen Bedingung erfüllen. map(...), mapToInt(...) und mapToDouble(...) wandeln die einzelnen Stream-Elemente in andere Werte um (bilden diese ab auf andere). sorted() sortiert die einzelnen Werte. Terminale Operationen: Mit forEach(...) kann für jedes Element etwas gemacht werden (z.B. jedes Element ausgeben). collect(...) und toArray(...) füllen die einzelnen Elemente in Listen oder Arrays ab. Intermediäre Operationen Die filter(...)-Methode Die filter(...)-Methode ist eine intermediäre Operation, die Elemente in einem Stream auf diejenigen beschränkt, die einer bestimmten Bedingung entsprechen. Diese Bedingung wird als Lambda-Ausdruck angegeben, der true zurückgibt, wenn das Element im Stream bleiben soll. Gibt er false zurück, wird das Element aussortiert.\nIm folgenden Beispiel werden alle ungeraden Zahlen aus einem Stream entfernt und dann alle verbleibenden Elemente ausgegeben:\n1 2 3 IntStream.of(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 15) .filter(x -\u003e x % 2 == 0) .forEach(System.out::println); Die map(...)- und mapToInt(...)-Methode Die map(...)- und mapToInt(...)-Methode gehört zu den intermediären Operationen eines Streams.\nDie Methode liefert einen Stream zurück, worin jedes einzelne Element durch den Rückgabewert der übergebenen Funktion ersetzt wurde.\nDie map(...)-Methode wird oft verwendet, um Daten umzuwandeln oder den Stream auf ein Feld/Methode eines Objekts zu fokussieren.\nHier ein Beispiel, in welchem Zahlen durch ihr Quadrat ersetzt werden:\n1 Stream.of(1,2,3,4).map(x -\u003e x * x).forEach(System.out::println); Und hier ein Beispiel, wo uns nur die Länge der Strings interessiert:\n1 2 3 Stream.of(\"Ein\", \"Ninja\", \"bewegt\", \"sich\", \"lautlos\", \"wie\", \"der\", \"Wind\", \"und\", \"unsichtbar\", \"wie\", \"der\", \"Schatten\") .map(word -\u003e word.length()) .forEach(System.out::println); Im zweiten Beispiel könnte unser Ziel sein, die durchschnittliche Länge der Wörter zu berechnen. Wenn man mathematische Operationen mit Streams durchführen möchte, dann ist es oft einfacher, den Stream in einen für den mathematischen Typ spezifischen Stream wie IntStream zu “verwandeln”, damit Funktionen wie sum() und average() (Durchschnitt) nicht manuell implementiert werden müssen. Hierfür kannst du statt der map(...)- die mapToInt(...)-Methode (oder mapToDouble) verwenden:\n1 2 3 4 5 6 7 8 System.out.println( \"Durchschnittliche Länge eines Wortes: \" + Stream.of(\"Ein\", \"Ninja\", \"bewegt\", \"sich\", \"lautlos\", \"wie\", \"der\", \"Wind\", \"und\", \"unsichtbar\", \"wie\", \"der\", \"Schatten\") .mapToInt(word -\u003e word.length()) .average() ); Die sorted() Methode Die sorted()-Methode gehört zu den intermediären Operationen eines Streams.\nDie Methode liefert ein Stream zurück, worin die Elemente im Stream nach ihrer natürlichen Reihenfolge (natural order) sortiert sind.\nDie Syntax der Methode ist wie folgt: Stream\u003cT\u003e sorted() wobei T der Typ der Elemente innerhalb des Streams ist\nBeispiel mit einem Array\n1 2 3 4 5 6 7 8 // Erstelle ein Array mit Strings String[] greeting = {\"C\", \"A\", \"B\"}; // Sortiere die Strings nach ihrer natürlichen Reihenfolge (alphabetisch) und // gib die sortierten Elementen in der Console wieder aus Arrays.stream(greeting) .sorted() .forEach(System.out::println); Beispiel mit einer Liste\n1 2 3 4 5 6 7 8 // Erstelle eine Liste mit Zahlen List\u003cInteger\u003e list = Arrays.asList(-9, -18, 0, 25, 4); // Sortiere die Zahlen nach ihrer natürlichen Reihenfolge (numerisch sortiert) und // gib die sortierten Elementen in der Console wieder aus list.stream() .sorted() .forEach(System.out::println); Terminale Operationen Die forEach() Methode Die forEach(Consumer action) Methode gehört zu den terminalen Operationen eines Streams.\nDer Parameter action ist vom Typ Consumer (ist ein FunctionalInterface). Dieser Typ repräsentiert eine Operation (eine Funktion), welche nur ein einziges Input-Argument akzeptiert und keine Ergebnisse (also void) zurückliefert. Ein Beispiel für so einen Consumer ist die Methode System.out.println(...), welche maximal ein einziges Objekt als Parameter akzeptiert, dieses Objekt in den Standard-Output ausgibt und void (also kein Ergebnis) zurückliefert. Die Methode System.out.println erfüllt also die Bedingungen eines Consumers und kann als Parameter für die forEach() Methode verwendet werden\nDie forEach()-Methode kann als Ersatz für einen for-Loop verwendet werden.\nBeispiel mit einem Array\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 String[] greeting = {\"Hello\", \"Streams\"}; // Hier wid jedes Element des Arrays ausgegeben for (String word : greeting) { System.out.println(word); } // Hier wird mithilfe von Streams dasselbe erreicht wie beim for-loop Arrays.stream(greeting) .forEach(word -\u003e System.out.println(word)); // Und nun noch kürzer mit der Method-Reference Syntax der obigen Lambda-Expression Arrays.stream(greeting) .forEach(System.out::println); Beispiel mit einer Liste\n1 2 3 4 5 6 7 8 9 10 11 12 13 List\u003cString\u003e greetingList = new ArrayList\u003c\u003e(); greetingList.add(\"Hello\"); greetingList.add(\"Stream\"); greetingList.add(\"List\"); // Einmal mit der vollen Syntax der Lambda-Expression greetingList.stream().forEach(word -\u003e System.out.println(word)); // Und einmal mit der verkürzte Variante mittels Method-Reference greetingList.stream().forEach(System.out::println); // Collection, darunter auch Listen, haben selbst eine forEach Methode, // welche die gleichen Ergebnisse liefert, wie diejenige vom Stream-Interface greetingList.forEach(System.out::println); Die collect()-Methode Die collect(Collector collector)-Methode ist auch eine terminale Operation auf einem Stream. Sie ermöglicht es, die Ergebnisse der Bearbeitung des Streams in einer neuen Collection (List, Map usw.) zu speichern. Dies ist nötig, da bei der Bearbeitung des Streams die ursprüngliche Elemente nicht geändert werden können.\nDer Parameter collector ist vom Typ Collector. Die Aufgabe eines Collectors besteht darin, mehrere Input-Elemente in einem Result-Container zusammenzufassen. Zum Beispiel können die Elemente eines Streams in einer Liste “gespeichert” und zurückgeliefert werden.\nUm ein Collector zu erzeugen, wird oft die Klasse Collectors aus dem java.util.stream-Package verwendet. Diese beinhaltet mehrere öffentliche, statische Methode um Collectors unterschiedlicher Typen (List, Map usw.) erzeugen zu können.\nBeispiel\n1 2 3 4 5 6 7 8 9 10 11 12 13 // Erstelle eine Liste von unsortieren Zahlen List\u003cInteger\u003e unsortedList = Arrays.asList(-9, -18, 0, 25, 4); // Aus der unstortierte Liste, erstelle eine NEUE, sortierte Liste List\u003cInteger\u003e sortedList = unsortedList.stream() .sorted() .collect(Collectors.toList()); // hier wird aus dem sortierten Stream eine neue Liste erstellt // gib die unsortierte Liste in der Konsole aus (die Original-Liste wurde nicht verändert!) unsortedList.forEach(System.out::println); // gib die sortierte Liste in der Konsole aus sortedList.forEach(System.out::println); Die toArray(...)-Methode Mit der collect(...)-Methode kannst du den Stream in eine Liste umwandeln. Wenn du den Stream aber in ein Array umwandeln möchtest, dann hilft dir die toArray(...)-Methode:\n1 2 3 4 5 6 7 8 9 String[] strings = Stream.of(\"A\", \"B\", \"C\") // String[]::new muss noch angegeben werden, damit ein String-Array (und nicht ein Object[]) zurückgegeben wird: .toArray(String[]::new); int[] array = Stream.of(1,2,3,4) // Zu einem IntStream umwandeln, weil sonst ein Integer[] statt int[] resultieren müsste: .mapToInt(Integer::intValue) .toArray(); Die toArray(...)-Methode ist eine terminale Operation auf einem Stream.\nDie reduce(...)-Methode Die reduce()-Methode in Java Streams wird verwendet, um mehrere Werte in einen einzelnen Wert zu kombinieren. Man gibt eine Funktion an, die zwei Werte zusammenfügt, und kann einen Startwert angeben, um auch bei einem leeren Stream ein Ergebnis zu erhalten.\n1 2 3 4 5 6 7 List\u003cInteger\u003e numbers = Arrays.asList(1, 2, 3, 4, 5); // Summe berechnen int sum = numbers.stream() .reduce(0, (a, b) -\u003e a + b); System.out.println(\"Summe: \" + sum); // Ausgabe: Summe: 15 Jetzt bist du dran. Löse bitte die Aufgabe 1 - 3 in den Stream-Labs.\n","categories":"","description":"Modul #J6\n","excerpt":"Modul #J6\n","ref":"/de/docs/02_java/10_java-collections/08_streams/","tags":"","title":"Streams Basics"},{"body":"Ziele Ich kann String-Variablen deklarieren und initialisieren. Ich kann mehrere Strings miteinander in eine String-Variable verknüpfen (String Concatenation). Ich weiss, wann man einen StringBuilder verwenden sollte. Ich weiss, wie ich herausfinde, wie viele Zeichen eine String-Variable enthält. Ich weiss, dass String-Variablen nicht mit == sondern equals verglichen werden sollten. Ich kann von der Klasse String folgende Methode anwenden: toUpperCase(), toLowerCase(), charAt(...), indexOf(...), contains(...), substring(...), replace(...), split(...). String Eine Variable, die eine Zeichenkette repräsentiert, hat den Typ String und kann wie folgt initialisiert werden:\n1 String hello = \"Hello, Java\"; Diese Zeichenkette besteht aus 11 Zeichen, einschliesslich eines Leerzeichens. Wie wir hier ebenfalls sehen, müssen String-Literale von doppelten Anführungszeichen umgeben sein.\nEin Objekt des Typs String ist unveränderlich, die Werte innerhalb eines Strings können also nach dessen Erstellung nicht mehr verändert werden - der Variable kann aber ein neuer String-Wert zugewiesen werden:\n1 2 String hello = \"Hello, Java\"; hello = \"Hello, how are you?\"; Ausserdem ist es möglich, Strings mit mehreren Zeilen zu definieren, indem du einen String mit 3 \" beginnst und beendest und den String auf einer neuen Zeile beginnst:\n1 2 3 4 5 String poem = \"\"\" Strings dürfen mehreren Zeilen enthalten. So kannst du auch einfach eine Auflistung notieren: 1. Element 2. Element.\"\"\"; Strings verknüpfen (String Concatenation) Oft generierst du aus verschiedenen Variablen EINEN neuen String. Angenommen du hast eine Variable für “name” und “age” (Alter), dann kannst du wie folgt den String “Hallo {name}, du bist {age} Jahre alt.” generieren:\n1 2 3 4 String name = \"Leonardo\"; int age = 68; String greeting = \"Hallo \" + name +\", du bist \" + age + \" Jahre alt.\"; Alternativ kannst du statt die vielen + auch von der String.format()-Methode Gebrauch machen:\n1 String greeting = String.format( \"Hallo %s, du bist %d Jahre alt.\", name, age); Bei der String.format()-Methode übergeben wir dann die einzelnen Werte als Argumente. Beachte hierbei, dass %s für String- und %d für Integer-Werte verwendet werden.\nWenn Performance (also wie schnell, dass ein Programm läuft) eine übergeordnete Rolle einnimmt, dann wird die Methode mit einem StringBuilder bevorzugt:\n1 2 3 4 5 6 7 8 StringBuilder sb = new StringBuilder(); sb.append(\"Hallo \") .append(name) .append(\", du bist \") .append(age) .append(\" Jahre alt.\"); String greeting = sb.toString(); Hierbei musst du aber zuerst ein neues StringBuilder-Objekt erstellen. (Im Modul #J1 musst du solche Objekte noch nicht verstehen.) Anschliessend fügst du alle einzelnen Strings via .append(...) hinzu. Den gewünschten String kannst du dann mit .toString() generieren lassen.\nNeue Zeilen oder Tabs Beim Verknüpfen von Strings ist es oft praktisch, wenn man Zeilenumbrüche hinzufügen kann. Dies kannst du mit dem Character '\\n' (new line) tun:\n1 String greeting = \" name: \" + name + \", \\n nage: \" + age; Das Gleiche ist auch mit Einrückungen (Tabulatoren) möglich mit dem Character '\\t' (tab):\n1 2 3 4 System.out.println(\"weapon name \\t ranges (m)\"); System.out.println(\"Shuriken \\t 5-10\"); System.out.println(\"Nunchaku \\t 1-1.5\"); System.out.println(\"Naginata \\t 3-4\"); Im Java fungiert das Zeichen \\ als “escape character”. Das bedeutet, dass spezielle Zeichen, die in einem String regulär nicht möglich wären, oft irgendwie mit einem \\ “escaped” werden. Neben der “New-Line” und dem “Tabulator” gibt es noch weitere, die oft verwendet werden:\n\\\\: Das \\-Zeichen (“Backslash) selber. \\\": Ein Anführungszeichen in einem String. Hier ein Beispiel, wie das Anführungszeichen und Backslash in einem String verwendet werden können:\n1 System.out.println(\"Die Datei \\\"Main.java\\\" befindet sich im Ordner C:\\\\Users\\\\Ninja\\\\Documents.\"); Methoden Nachfolgend sind einige der wichtigsten Methoden der Klasse String beschrieben. Alle Methoden sind detailliertet beschrieben unter java.lang.String zu finden.\nAnzahl Zeichen (String.length()) Bei Strings sind dessen Länge (also Anzahl Zeichen) oft von Interesse.\nIm folgenden Beispiel wird eine Nachricht ausgegeben, wenn eine Dummy-Usereingabe nicht mindestens 6 Zeichen enthält:\n1 2 3 4 String nickname = \"peter\"; if (nickname.length() \u003c 6) System.out.println(\"Der Nickname muss mindestens 6 Zeichen enthalten!\"); Strings miteinander vergleichen (String.equals(String)) Sehr oft wirst du überprüfen, ob ein String einem anderen entspricht. Dies kannst du mit der equals()-Methode tun:\n1 2 3 4 5 String a = \"hello\"; String b = \"hello\"; if (a.equals(b)) System.out.println(\"A ist gleich B.\"); Beachte hierbei, dass du zum Vergleichen von Strings in Java immer equals() nun nie == verwenden solltest, weil String kein primitiver Datentyp ist. == funktioniert in einfacheren Beispielen, führt aber in vielen Fällen trotzdem nicht zum gewünschten Resultat.\nIn Gross-/Kleinbuchstaben umwandeln In bestimmten Fällen soll die Gross- und Klein-Schreibung keine Rolle spielen. Nehmen wir hierfür noch einmal das Beispiel von der equals-Methode:\n1 2 3 4 String input = \"hello\"; if (input.toUpperCase().equals(\"HELLO\")) System.out.println(\"Der Input entspricht 'hello'.\"); Die relevanten String-Methoden bezüglich Gross- und Klein-Schreibung sind hierbei:\ntoUpperCase(): Gibt die Zeichenkette in Grossbuchstaben zurück. toLowerCase(): Gibt die Zeichenkette in Kleinbuchstaben zurück. Eine häufige Fehlerquelle ist es zu denken, dass eine dieser beiden Methoden den String verändert. Strings können sich aber nicht verändern. Deswegen geben diese beide Funktionen einen neuen String zurück, der Wert in der Variable bleibt also unverändert:\n1 2 3 4 5 6 7 8 String myString = \"Hello\"; myString.toUpperCase(); System.out.println(myString); // Ausgabe: // Hello Damit dieses Beispiel wie gewollt funktioniert, müsste es so geschrieben werden:\n1 2 3 4 5 6 7 8 String myString = \"Hello\"; myString = myString.toUpperCase(); System.out.println(myString); // Ausgabe: // HELLO Buchstaben an bestimmter Position ermitteln (String.charAt(int)) Wenn du z.B. alle Buchstaben in einem String durchgehen willst, dann musst du irgendwie den Buchstaben (char) an einer bestimmten Position des Strings ermitteln können. Dies kannst du mit charAt(int).\nDas folgende Beispiel liest den ersten Buchstaben aus einem String aus und gibt in aus:\n1 2 3 4 5 6 7 8 String word = \"Hello\"; char firstLetter = word.charAt(0); System.out.println(\"Erster Buchstabe: '\" + firstLetter + \"'\"); // Ausgabe: // Erster Buchstabe: 'H' Beachte, dass die Nummerierung in Java generell bei 0 beginnt. Für das erste Element übergibst du 0, für das zweite 1, für das vierte 3, für n das (n-1)-te, usw. Für charAt(...) bedeutet das, dass du wie folgt Buchstaben an bestimmten Positionen ermittelst:\n1 2 3 4 5 6 7 8 9 10 11 // erstes Zeichen: word.charAt(0); // zweites Zeichen: word.charAt(1); // viertes Zeichen: word.charAt(3); // letztes Zeichen: word.charAt(word.length() - 1); Nach Strings in Strings suchen (String.indexOf() und String.contains()) In seltenen Fällen möchtest du wissen, an welcher Position ein kleinerer String (oder char) in einem grösseren String vorkommt. Diese Information erhältst du mit indexOf(String/char).\nMöchtest du z.B. herausfinden, an welcher Stelle in einer Email-Adresse das “@” steht, dann könnte das wie folgt aussehen:\n1 2 3 4 5 String email = \"wallace@gmail.com\"; int indexOfAt = email.indexOf(\"@gmail\"); System.out.println(\"Der Teil vor dem @ ist \" + indexOfAt + \" Zeichen lang.\"); In diesem Fall gibt die Methode 7 zurück, weil sich das @ an der 8. Stelle befindet.\nAllgemein gibt indexOf(...) folgendes zurück:\nWenn der Suchbegriff vorkommt, dann die Position, wo der Suchbegriff zum ersten Mal beginnt. Wenn der Suchbegriff nie vorkommt: -1. Weil -1 zurückgeben wird, wenn der Suchbegriff nicht vorkommt, könnte diese Methode auch dafür verwendet werden, um herauszufinden, ob ein bestimmter Text in einem String vorkommt. Java bietet aber für diesen Fall bereits eine praktischere Methode:\n1 2 3 4 String email = \"wallace@gmail.com\"; if (email.contains(\"@gmail.\")) System.out.println(\"Diese Email-Adresse ist ein Gmail-Adresse.\"); Der Vorteil von der contains()-Methode ist, dass sie bereits einen boolean zurückgibt, was die if-Anweisung einfacher macht als das Überprüfen nach -1.\nText aus einem String ausschneiden Die substring()-Methode ist nützlich, wenn ein Text aus einem String ausgeschnitten werden soll.\nIn diesem Beispiel interessiert uns die Information nach dem “:”, welches sich immer an 6. Stelle befindet:\n1 2 3 4 5 6 7 8 String systemInfo = \"power: on\"; String status = systemInfo.substring(7); System.out.println(\"The system is \" + status + \".\"); // Ausgabe: // The system is on. In diesem Beispiel haben wir mit dem Schneiden an 7. Stelle begonnen. Wir können aber auch angeben, wie viele Zeichen, das ausgeschnitten werden sollen:\n1 2 3 4 5 6 7 8 String sentence = \"Today is Wed, 9th August 2023\"; String dayOfWeek = sentence.substring(9, 12); System.out.println(\"Day of Week: \" + dayOfWeek); // Ausgabe: // Day of Week: Wed In diesem Beispiel beginnt das Ausschneiden bei Index 9 und hört 1 Zeichen VOR Index 12 auf.\nIn all diesen Beispielen sind wir davon ausgegangen, dass wir wissen, ab welcher Stelle das Ausschneiden beginnt. Oft ist diese Stelle aber dynamisch. Hier kann daher eine Kombination mit indexOf() weiterhelfen:\n1 2 3 4 5 6 7 String dadJoke = \"Warum dürfen Geister keine Lügen erzählen? Weil man durch sie hindurchsieht!\"; String punchline = dadJoke.substring(dadJoke.indexOf(\"Weil \")); System.out.println(\"Pointe: \" + punchline); // Ausgabe: // Weil man durch sie hindurchsieht! Teile eines Strings ersetzen (String.replace()) Ein bestimmter Teil eines Strings kannst du mit replace ersetzen:\n1 2 3 4 5 String classicPhrase = \"To be or not to be, that's the question.\"; System.out.println(classicPhrase.replace(\"o be\", \"o beer\")); // Ausgabe: // To beer or not to beer, that's the question Beachte auch hier, dass replace den ursprünglichen String nicht verändert, sondern einen neuen zurückgibt.\nBausteine aus einem String herauslösen (String.split()) Mit der split(String)-Methode kannst du einen String anhand eines Suchbegriffes aufteilen und erhältst dann eine Auflistung von Strings, die sich zwischen dem Suchbegriff befinden:\n1 2 3 4 5 6 7 String ingredients = \"Käse, Brot, Speck, Eier, Surströmming\"; var items = ingredients.split(\", \"); System.out.println(\"This receipt has \" + items.length + \". Ingredients: \"); for (String item : items) System.out.println(item); Die for-Schlaufe gibt schlussendlich folgende Werte aus:\nKäse Brot Speck Eier Surströmming Auf diese Art und Weise können wir z.B. alle Wörter aus einem String ermitteln.\nAnzufügen ist noch, dass es sich beim Suchbegriff um eine sogenannten “Regulären Ausdruck” (RegEx) handelt. Eine RegEx ist eine Folge von Zeichen, die ein Suchmuster bilden. Eine Regex wird dafür verwendet, um einen Text anhand eines Musters (einer Regel) abzugleichen. RegEx ist im Moment kein Thema im Modul #J1. Wichtig ist für dich im Moment nur, dass du weisst, dass sich bei diesem Suchbegriff von split(...) nicht um einen gewöhnlichen String handelt, sondern um eine RegEx. Möglicherweise können dir RegEx’ viel Arbeit abnehmen.\nFalls du mehr über RegEx lernen möchtest empfehlen wir dieses Tutorial. Das Gelernte kannst du anschliessend gleich in dieser Sandbox challengen. Achte bei der Sandbox darauf, dass du das richtige Flavor (Java 8) auswählst.\nJetzt bist du dran. Löse bitte die Aufgaben 6 und 7 in den Labs.\n","categories":"","description":"Modul #J1\n","excerpt":"Modul #J1\n","ref":"/de/docs/02_java/03_java-grundlagen/08_strings/","tags":"","title":"String"},{"body":"Ziele Ich weiss, warum das Testen in der Softwareentwicklung eine zentrale Bedeutung hat. Ich kenne die relevantesten gängigen Testarten in der Software-Entwicklung und deren Zweck. Ich weiss, was Testmanagement ist und was es dabei zu beachten gilt. Ich kenne die wichtigsten Funktionen des Frameworks JUnit 5. Ich kann für einfache Anwendungen selber Unit-Tests implementieren. Ich kenne die wichtigsten Funktionen des Frameworks Mockito. Ich weiss, was Mocks und Spies sind und kenne den Unterschied dazwischen. Ich weiss, was Test-Driven-Development ist und wie ich diese Methodik anwenden kann. Einführung Tests in den unterschiedlichen Phasen der Softwareentwicklung dienen dazu festzustellen, ob die entwickelte Software die spezifizierten Anforderungen erfüllt oder nicht. Ausserdem können Tests Mängel in dem produzierten Code aufdecken noch bevor der Code produktiv geschaltet wird und stellen damit sicher, dass das Endprodukt fehlerfrei funktioniert.\nTests sind vor allem aus folgenden Gründen sehr wichtig und sollen entsprechend sehr früh (dazu später) in den Entwicklungsprozess integriert werden:\nTesting erhöht die Qualität des entwickelten Produkts, da damit Mängel frühzeitig entdeckt und beseitigt werden können. Testing gibt mehr Sicherheit bei Änderungen am Code, da damit sichergestellt werden kann, dass die Änderung nicht zu unerwünschten Nebenwirkungen geführt haben. Testing spart Geld da damit weniger Nachbearbeitungsaufwand in Form von Bug/Hot-Fixes betrieben werden muss. Testing führt zu höherer Kundenzufriedenheit da damit weniger Fehler den Kunden davor hindern, fehlerfrei mit dem Produkt zu arbeiten. Testarten Es gibt viele verschiedene Softwaretestverfahren und Methoden, mit denen sichergestellt werden kann, dass Änderungen am Code wie erwartet funktionieren.\nSoftwaretests können in zwei Bereiche unterteilt werden: manuelles Testen und automatisiertes Testen. Beim manuellen Testen werden Testfälle manuell durch einen Menschen und ohne Unterstützung durch Werkzeuge oder Skripte ausgeführt.\nBeim automatisierten Testen werden Testfälle jedoch mithilfe von Tools, Skripten und Software ausgeführt.\nHier werden wir uns auf das automatisierte Testen konzentrieren, da dieses im Softwareentwicklungsprozess essenziell ist.\nUnit-Tests Unit-Tests sind inhaltlich sehr simpel und erfolgen nah an der Quelle der Anwendung.\nSie dienen zum Testen einzelner Methoden und Funktionen der von der Software verwendeten Klassen, Komponenten oder Module.\nMit Unit-Tests stellen wir sicher, dass einzelne Funktionsblöcke einer Applikation genau das machen, was sie sollen. Vielen passiert es am Anfang, dass nur “Positiv-Fälle” getestet werden. Konkret heisst das, dass der getestete Teil nur im Rahmen des korrekten, erwarteten Verhaltens geprüft wird. Es ist aber genauso wichtig, Negativ-Tests und Rahmentests durchzuführen, wo der geprüfte Teil konkret auf das Verhalten in einem Grenz- oder Fehlerfall geprüft wird. So kann bereits vielen Fehlern in der Zukunft mit wenig Aufwand vorgebeugt werden.\nEin Unit-Test ist immer ein sog. “White-Box” Test, da der Entwickler bei der Implementation von Unit-Tests den Sourcecode kennt oder ihn einsehen kann.\nBei Unit-Tests in Java ist der Testumfang eines Unit-Tests normalerweise in der Grössenordnung einer Methode oder Funktionalität.\nIn der Regel lassen sich Unit-Tests automatisieren und können einzeln oder auch in Gruppen (in sog. Test-Suites) lokal (an der eigenen Maschine) oder von einem Continuous-Integration-Server (eine externe Maschine, die dafür sorgt, dass Programmteile sofort getestet und zusammengeführt werden können) sehr schnell durchgeführt werden.\nIntegration-Tests Mit Integration-Tests wird sichergestellt, dass verschiedene Programmteile der Anwendung problemlos ineinandergreifen und miteinander harmonieren. So kann beispielsweise die Interaktion mit einer Datenbank oder das Zusammenspiel von verschiedenen Mikroservices getestet werden. Im Gegensatz zu Unit-Tests beschränkt sich diese Test-Art also nicht auf einzelne Methoden oder Funktionen, sondern auf verschiedene Module oder Klassen und deren Zusammenspiel.\nTests dieser Art sind kostspieliger und können auch länger dauern als Unit-Tests, weil dafür mehrere Teile der Anwendung funktionsfähig sein müssen. Dafür können konkretere Aussagen über den generellen Zustand einzelner, ineinandergreifende Funktionalitäten aufgrund der Testergebnisse getätigt werden.\nSystem-Tests System-Tests gehen noch einmal eine Stufe höher als Integrations-Tests und prüfen eine gesamte Applikation auf spezifische Business-Anforderungen. Zumeist werden diese mithilfe von Tools automatisch ausgeführt und sind im Vergleich zu Integrations-Tests und vor allem Unit-Tests ziemlich aufwändig.\nSystem-Tests bieten, wenn sie richtig geschrieben und gepflegt werden, einen grossen Mehrwert für das Team. Da nicht nur einzelne Funktionen, sondern ganze Anwendungsfälle geprüft werden und die Tests automatisch ausführbar sind, bieten sie einen starken Rückhalt bei der Pflege der Applikation und der Kommunikation bei Erreichung einer Anforderung.\nAkzeptanz-Tests Bei Akzeptanz-Tests wird der Umgang des Benutzers (oder auch andere, externe Programme) mit der Software in einer vollständigen Anwendungsumgebung repliziert. Auf diese Weise wird das ordnungsgemässe Funktionieren von Benutzerabläufen überprüft. Die Szenarien können ganz einfach sein (z.B. Laden einer Website, Anmeldevorgang) oder auch sehr komplex (z.B. E-Mail-Benachrichtigungen, Onlinezahlungen).\nAkzeptanz-Tests sind sehr nützlich, aber auch aufwändiger zu erstellen und in automatisierter Form unter Umständen schwer zu verwalten. Daher empfiehlt es sich grundsätzlich, Akzeptanz-Tests manuell auf Basis der Use-Cases, die man für eine Applikation hat, zu testen. Viele Teams oder Organisations-Einheiten haben ein dediziertes Testing-Team, welches sich ausschliesslich um das Testen von Applikationen und den Umgang mit gefundenen Fehlern kümmert.\nWichtig anzumerken ist ebenfalls, dass Akzeptanz-Tests auch nicht-funktionale Anforderungen abdecken. Während Unit-Tests hauptsächlich funktionale Anforderungen wie beispielsweise eine Anmeldefunktion geprüft werden, werden mit Akzeptanz-Tests auch nicht-funktionale Anforderungen wie bspw. die Latenz von Anfragen geprüft.\nTestmanagement Unter Testmanagement versteht man die geplante und effiziente Koordination aller Testprozesse, die die Qualität von Software optimieren und langfristig gewährleisten. Grundsätzlich wird so die Identifizierung von und Reduzierung teilweise versteckter Qualitätsrisiken ermöglicht, womit potenzielle zukünftig auftretende finanzielle und aufwandstechnische Belastungen in der Zukunft minimiert werden können. Hauptsächlich verfolgt das Testmanagement also 2 Ziele:\nMöglichst früh Software-Fehler aufdecken. Die Unsicherheit bezüglich der Qualität der Software minimieren. Diese beiden Punkte sollen nachfolgend noch ein Stück ausformuliert werden.\nMöglichst früh Software-Fehler aufdecken Oft ist es so, dass in der Entwicklung, Anpassungen oder Installation von Software erst recht spät getestet wird, was dazu führt, dass eine entsprechende Reaktion auf einen Fehler meist erst verspätet ermöglicht wird. Grundsätzlich ist es so, dass die aus einem Fehler entstehenden Kosten exponentiell ansteigen, je später ein solcher gefunden und behandelt wird. Die untenstehende Grafik veranschaulicht das relativ gut. Während das Beheben eines gefundenen Fehlers beim Erstellen und Prüfen der Anforderungen (Reqs) kaum etwas kostet, sind die Kosten im Produktiven-Kontext (PROD) schon um einiges höher.\nDa die meisten Fehler schon sehr früh im Umsetzungs-Ablauf passieren, lohnt es sich enorm, in ein sinnvolles Test-Management zu investieren, da so enorm viele Ressourcen gespart werden können.\nDie Unsicherheit bezüglich der Qualität der Software minimieren Es ist oft schwierig, einen guten Ausgleich zwischen einer guten Testabdeckung und einer lohnenswerten Wirtschaftlichkeit für das Unternehmen zu finden, da beispielsweise eine Testabdeckung von 100% bei einer App schon sehr teuer werden kann. Daher ist es auch ein Fehlschluss, dass man mit genügend Tests sicherstellen könne, dass eine Software fehlerfrei ist. Testmanagement hat daher zum Ziel, die Unsicherheit, dass eine Software kritische Fehler enthält, soweit zu minimieren, dass eine Produktivsetzung der App ohne schlechtes Gewissen durchgeführt werden kann. Testmanagement hat daher nicht zum Ziel, dass eine Software absolut fehlerfrei ist.\nVorteile von Testmanagement Ein strukturiertes Testmanagement mit klar verteilten Rollen, Verantwortlichkeiten und Aufgaben resultiert zumeist in einigen Vorteilen, beispielsweise den folgenden:\nKostenreduktion: Da Fehler oft zu einem früheren Zeitpunkt gefunden werden, wenn ein sinnvolles Testmanagement umgesetzt wird, können viele sonst entstehende Mehrkosten vermieden werden. Zudem bestehen in diesem Fall auch geringe Wartungsaufwände durch wiederholbare Tests und Klarheit in Bezug auf die zu testenden Anforderungen. Auch so kann stellenweise viel Geld gespart werden. Bessere Planbarkeit der Testphasen durch bekannte Testumfänge. Personenunabhängige Tests durch ausreichende Testfalldefinitionen und -dokumentation, was je nachdem sogar ein Outsourcing des Testings erlaubt. Stetige Verbesserung der Softwarequalität durch das Leben und durchgehende Verbessern des Testmanagements. Potenzielle Ressourcen- und Zeiteinsparung durch automatisierte Tests. Der Testprozess nach ISTQB Ein offizieller Testprozess, nachdem man sich grundsätzlich ausrichten kann, ist der des International Software Testing Qualitications Board. (ISTQB) Das ISTQB hat gängige, bewährte Praktiken und Terminologien zu einem prinzipiell universell anwendbaren Standard gebündelt, auf den nachfolgend etwas genauer eingegangen werden soll.\nDer ISTQB-Prozess besteht grundsätzlich aus 4 Testphasen:\nIncident Management Problem Management Change Management Release Management Zu den jeweiligen Phasen gehören jeweils noch die entsprechenden Aktivitäten, namentlich die Planung, Spezifikation, Durchführung, Protokollierung und Auswertung der Tests. Diese Aktvitäten werden per ISTQB jeweils in die folgenden Gruppen eingerodnet:\nTestplanung und -steuerung Testanalyse und -design Testrealisierung und -durchführung Testauswertung und -bericht Abschluss Rollen im Testmanagement Es gibt innerhalb des Testmanagements viele verschiedene Rollen, die jeweils verschiedene Tätigkeiten verfolgen. Wie man diese unterscheidet, ist jeweils abhängig von der Tiefe der Betrachtung pro Fall, der Einfachheit nehmen wir hier aber die einfachste Unterscheidung mit 2 Rollen; einmal der des Testmanagers und einmal der des Testers.\nTestmanager Der Testmanager ist für den gesamten, übergreifenden Testprozess und die erfolgreiche Durchführung der Testaktivitäten zu verantworten. Da es sich hier um eine rein koordinative Arbeit handelt, kann diese Rolle von verschiedenen Personen übernommen werden. Wenn es der technische Prozess fordert, kann das ein professioneller Testmanager sein, in anderen Fällen kann es aber genau so gut ein Projektleiter ohne grossen technischen Hintergrund sein.\nTypische Aufgaben eines Testmanagers umfassen:\nDas Festlegen der Testrategie und -vorgaben für das Unternehmen Das Erstellen und Aktualisieren von Testplänen Das Koordinieren der Testpläne zwischen verschiedenen Stakeholdern Das Einplanen und Anstossen der verschiedenen Testaktivitäten wie der Testanalyse, dem Testdesign, der Testimplementierung und der Testdurchführung. Das Monitoring (Überwachen) der Testfortschritte und -ergebnisse Das Berichten über die Testfortschritte und -ergebnisse Diese Aufgaben sind nicht als fixe Beschreibung der Rolle eines Testmanagers zu verstehen, sondern mehr als Beispiele. Je nach Grösse des Unternehmens, Anforderungen an das Testmanagement und das Produkt selbst und gegebener Zeit können andere Aufgaben dazukommen oder genannte Aufgaben wegfallen. Eine Priorisierung dieser Aufgaben ist somit für jeden Fall unterschiedlich.\nTester Ein Tester übernimmt grundsätzlich alle operativen Aufgaben innerhalb des Testprozesses, wobei das Durchführen der Tests nur eine Aufgabe darstellt, die der Tester übernimmt. Je nachdem, welches Rollenmodell verfolgt wird, wird innerhalb der Rolle des Testers noch weiter zwischen einzelnen rollen unterschieden. Das können beispielsweise die folgenden sein:\nTestdesigner Testautomatisierer Testarchitekt etc. Im Rahmen dieser Dokumentation nehmen wir aber alle diese Teilrollen unter einen Hut als “Tester”. Typische Aufgaben in dieser Rolle können das Folgende umfassen:\nPrüfen der Anforderungen, Spezifikationen und Akzeptanzkriterien in Bezug auf die Testbarkeit Identifizieren und Dokumentieren der Testvoraussetzungen Erstellung und Implementation von Testfällen und Testprozeduren Erstellung des detaillierten Testausführungsplans Testautomatisierung (Bereitstellung der Testumgebung mit geeigneten Testdaten) JUnit Zur Implementation von Unit-Tests steht in Java das Framework JUnit zur Verfügung. Die aktuellste Version ist 5.9.0. Dies ändert aber stetig, da das Produkt laufend weiterentwickelt wird. Vielfach ist in Produkten und Projekten auch JUnit 4 im Einsatz. In diesem Modul wird jedoch nur die aktuellste Version von JUnit behandelt. Wir schreiben Unit-Tests also mit JUnit 5.\nWie ist JUnit 5 aufgebaut? Das Framework besteht aus folgenden Teilen:\nTeil Verwendung JUnit Plattform Grundlage zur Einführung von Testframeworks in die JVM. Definition der Test-Engine zur Entwicklung von Testframeworks auf der jeweiligen Plattform. Plattform-Konsole zum Starten der Plattform. Kurz gesagt: Plattform zur Ausführung von Unit-Tests JUnit Jupiter Programmiermodell zur Implementation von Unit-Tests JUnit Vintage Ermöglicht die Ausführung von Tests, die mit JUnit 3 oder JUnit 4 geschrieben wurden Wo kann ich das Framework herunterladen? Damit wir nun Unit-Tests implementieren können benötigen wir zuerst die Bibliotheken von JUnit 5, dies wird in den beiden folgenden Abschnitten beschrieben.\nAbhängigkeiten einbinden ohne Maven Dieser Abschnitt kann übersprungen werden, wenn mit einem Maven-Projekt gearbeitet wird. Alle Bibliotheken sind unter den beiden folgenden Links zu finden:\norg.junit.jupiter org.junit.platform Die folgenden JARs werden benötigt:\nAus dem ersten Link junit-jupiter-engine junit-jupiter-params junit-jupiter junit-jupiter-api Aus dem zweiten Link junit-platform-engine junit-platform-commons Die Einbindung in ein Projekt muss (ohne Maven) manuell gemacht werden. Die folgende Anleitung soll dabei helfen:\n# Beschreibung Screenshot 1 Ordner für Bibliotheken im Projekt anlegen. Im Projekt (Root) einfach einen neuen Ordner “lib” erzeugen. 2 Die oben genannten JAR-Bibliotheken in den neuen Ordner kopieren 3 Projekteinstellungen öffnen. Das Projekt mit einem Klick markieren und Taste F4 drücken. Die Projekteinstellungen werden geöffnet 4 Auf der linken Seite den Tab “Libraries” auswählen 5 Oben auf das Plus-Icon klicken und Java auswählen 6 Die vorhin kopierten Bibliotheken auswählen und alle Dialoge mit OK bestätigen 7 Die Bibliothek muss anschliessend dem Modul hinzugefügt werden. Der Scope sollte auf Test gestellt werden, da es sich um reine Test-Bibliotheken handelt. Abhängigkeiten einbinden mit Maven Dieser Abschnitt kann übersprungen werden, wenn es sich nicht um ein Maven Projekt handelt.\nDie entsprechenden Abhängigkeiten für das Project Object Model (pom.xml) sind:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 \u003cdependencies\u003e \u003c!-- Plattform --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter\u003c/artifactId\u003e \u003cversion\u003e5.9.0\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c!-- API, enthält unter anderem alle Annotationen --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter-api\u003c/artifactId\u003e \u003cversion\u003e5.9.0\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c!-- Test-Engine zur Ausführung von Unit-Tests, die mit JUnit 5 geschrieben wurden --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter-engine\u003c/artifactId\u003e \u003cversion\u003e5.9.0\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c!-- JUnit 5 Erweiterung für parametrisierte Tests (Optional) --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter-params\u003c/artifactId\u003e \u003cversion\u003e5.9.0\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c!-- Test-Enginge zur Ausführung von Unit-Tests, die mit JUnit 3 oder JUnit 4 geschrieben wurden (Optional) --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.vintage\u003c/groupId\u003e \u003cartifactId\u003ejunit-vintage-engine\u003c/artifactId\u003e \u003cversion\u003e5.9.0\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c!-- Bibliotheken für die Ausführung von Unit-Tests --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.platform\u003c/groupId\u003e \u003cartifactId\u003ejunit-platform-engine\u003c/artifactId\u003e \u003cversion\u003e1.9.0\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.platform\u003c/groupId\u003e \u003cartifactId\u003ejunit-platform-commons\u003c/artifactId\u003e \u003cversion\u003e1.9.0\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e Füge diese Abhängigkeiten (ohne die optionalen) in dein pom.xml ein. Danach besitzt du alle Bibliotheken, die zur Implementation von Unit-Tests notwendig sind.\nOrdnerstruktur anlegen Um Unit-Tests implementieren zu können benötigen wir grundsätzlich die folgende Ordnerstruktur im IntelliJ IDEA.\nFalls dein Projekt kein Maven-Projekt ist, kannst du die Verzeichnisse einfach manuell anlegen. Mit einem Rechtsklick auf die Verzeichnisse, kannst du sie mit dem Befehl “Mark Directory as” aus dem Kontext-Menü wie folgt markieren:\nVerzeichnis Markierung Zweck src/main/java Sources Root Source Code deiner Applikation src/main/resources Resources Root Ressourcen deiner Applikation, die nicht Programmcode sind src/test/java Test Sources Root Source Code deiner Unit-Tests src/test/resources Test Resources Root Ressourcen deiner Unit-Tests, die nicht Programmcode sind Diese Ordnerstruktur wurde ursprünglich vom Projektmanagement-Tool Gradle “erfunden” und dann von Maven übernommen. Stand heute ist dies die Standard-Ordnerstruktur innerhalb von Java-Projekten.\nImplementation von Unit-Tests an einem Beispiel Nach all den Vorbereitungen sind wir nun bereit Unit-Tests zu implementieren. Der folgende Abschnitt beschreibt die Grundlagen für das Schreiben von Unit-Tests.\nDas JUnit-Framework\nnutzt Assertions, um Resultate innerhalb eines Tests zu überprüfen nutzt Annotationen, um Testfälle zu finden und durchzuführen Erklärung Beispiel einer Unit-Test Implementation anhand eines einfachen Beispiels.\nHinweis im Beispielcode wird folgendes Namensschema für Tests verwendet:\n1 2 3 public void given_when_then() { ... } Wobei:\ngiven die Ausgangslage definiert (z.B. twoIntegers oder givenTwoIntegers) when ist der Name der Methode, welche getestet wird (z.B. whenAdd oder add) then ist das Ergebnis, welche erwartet wird (z.B. thenSumIsCorrect oder sumCorrect) Source-Code\n1 2 3 4 5 6 7 package ch.sbb.talentfactory.calculator; public class Calculator { public int add(int i1, int i2) { return i1 + i2; } } Test-Code\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package ch.sbb.talentfactory.calculator; import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; public class CalculatorTest { private Calculator uut = new Calculator(); @Test void givenTwoIntegers_whenAdd_thenSumIsCorrect() { // prepare test data int i1 = 5; int i2 = 9; // call method int result = this.uut.add(i1, i2); // verify assertEquals(14, result); } } Der Unit-Test befindet sich im gleichen Package wie die zu testende Klasse. Innerhalb der weiter oben genannten Ordnerstruktur ist die Test-Klasse aber nicht am gleichen Ort abgelegt! Innerhalb des Unit-Tests wird zuerst eine Instanz der zu testenden Klasse angelegt. Die Bezeichnung für diese Instanz lautet normalerweise UUT, dies steht für “Unit Under Test”. Für jeden Test einer der Methoden aus dem UUT wird anschliessend eine Test-Methode implementiert. Diese Methoden sind mit @Test zu annotieren, so werden sie anschliessend vom Test-Framework als eigenständiger Test erkannt und ausgeführt. Ein Unit-Test kann beliebig viele Testmethoden enthalten. Grundsätzlich reichen aber je nach Funktionalität ein paar wenige Tests aus, um die ganze Funktionalität einer Methode zu überprüfen. Innerhalb der Test-Methoden implementieren wir dann “normalen” Programmcode, welcher den Code aus dem UUT “überprüft”. In unserem Beispiel setzen wir zwei Variablen und rufen damit die zu testende Methode auf. Mit einer Assertion vergleichen wir dann einen erwarteten Wert mit dem von der Methode zurückgelieferten Resultat. Beachte, dass der erwartete Wert in der Assertion immer an erster Stelle stehen muss. Wenn die beiden Werte identisch sind, dann ist der Unit-Test erfolgreich.\nVorgehen beim Schreiben von Unit-Tests Grundsätzlich sollte die AAA-Methode angewendet werden, sie ist auch im Beispiel oben ersichtlich. AAA steht für “Arrange”, “Act” und “Assert”. “Arrange” steht dabei für die Vorbereitung des Tests, “Act” ist die eigentliche Durchführung und mit “Assert” werden die Resultate des Tests überprüft.\nGrenzwerte austesten Vielfach sind gewisse Funktionen in einer Applikation so implementiert, dass sie sich mit wenigen Unit-Tests komplett testen lassen. Dazu ein kleines Beispiel: gegeben ist ein Rechteck mit bestimmten Koordinaten (Ecke oben links) und einer bestimmten Grösse (Höhe und Breite).\nEine Methode innerhalb des Rechtecks dient dazu herauszufinden, ob eine bestimmte Koordinate inner- oder ausserhalb des Rechtecks liegt. Punkte, die auf dem Rand zu liegen kommen gelten in diesem Sinne nicht als innerhalb des Rechtecks.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package ch.sbb.talentfactory.rectangle; public class Rectangle { private int top; private int left; private int width; private int height; public Rectangle(int top, int left, int width, int height) { this.top = top; this.left = left; this.width = width; this.height= height; } public boolean isInside(int x, int y) { if (x \u003e left \u0026\u0026 x \u003c left + width) { if (y \u003e top \u0026\u0026 y \u003c top + height) { return true; } } return false; } } Damit keine Verwirrung entsteht, hier das verwendete Koordinatensystem. Wie wir in der Implementation sehen können, gibt es hier vier verschiedene Bedingungen. Das Ziel des Tests muss es also sein, dass wir alle diese Bedingungen überprüfen. Wenn immer möglich, sollten alle möglichen Kombinationen getestet werden. Nur so kann sichergestellt werden, dass die Methode wie gewünscht funktioniert. Aufgrund der AND-Verknüpfung werden die zweiten Bedingungen der jeweiligen Statements nicht mehr ausgewertet. Damit müssen die folgenden Kombinationen durch einen Unit-Test abgedeckt werden\nBedingung x \u003e left x \u003c left + width y \u003e top y \u003c top + height Resultat Variante 1 False False Variante 2 True False False Variante 3 True True False False Variante 4 True True True False False Variante 5 True True True True True Dies bedeutet wir implementieren fünf Unit-Tests, um die Methode vollständig abzudecken.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package ch.sbb.talentfactory.rectangle; import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; public class RectangleTest { // I know this is a square ;-) private Rectangle uut = new Rectangle(0, 0, 10, 10); @Test void givenPointLeftOfRectangle_whenIsInsideCheck_thenReturnsFalse() { assertFalse(this.uut.isInside(-1, 5)); } @Test void givenPointRightOfRectangle_whenIsInsideCheck_thenReturnsFalse() { assertFalse(this.uut.isInside(11, 5)); } @Test void givenPointAboveRectangle_whenIsInsideCheck_thenReturnsFalse() { assertFalse(this.uut.isInside(5, -1)); } @Test void givenPointBelowRectangle_whenIsInsideCheck_thenReturnsFalse() { assertFalse(this.uut.isInside(5, 11)); } @Test void givenPointInsideRectangle_whenIsInsideCheck_thenReturnsTrue() { assertTrue(this.uut.isInside(5, 5)); } } Im IntelliJ gibt es wie bei der Ausführung einer Applikation auch die Möglichkeit einen Unit-Test zu debuggen. Zusätzlich können wir die Testabdeckung anschauen, wenn wir den Unit-Test mit “Coverage” durchlaufen lassen. Wenn der Test erfolgreich durchgelaufen ist, dann kann die getestete Klasse geöffnet werden.\nDie grünen Balken auf der linken Seite zeigen die Testabdeckung an. In diesem Fall sind sämtliche Zeilen durch einen Test durchlaufen worden.\nDa der Unit-Test nun alle Möglichkeiten der Methode abdeckt, kann ein einfaches Refactoring durchgeführt werden. In unserem Fall kann die Methode wie folgt vereinfacht werden:\n1 2 3 public boolean isInside(int x, int y) { return x \u003e left \u0026\u0026 x \u0026lt; left + width \u0026\u0026 y \u0026gt; top \u0026\u0026 y \u003c top + height; } Der Test kann dann beliebig oft erneut durchgeführt werden, um das Refactoring zu überprüfen.\nAnnotationen von JUnit5 Die folgende Tabelle zeigt eine Übersicht über die wichtigsten Annotationen von JUnit 5. Mehr Informationen zu den jeweiligen Annotationen finden sich in den nächsten Kapiteln.\nAnnotation Beschreibung @Test Bezeichnet einen Test @ParameterizedTest Bezeichnet einen parametrisierten Test @RepeatedTest Bezeichnet einen sich wiederholenden Test @DisplayName Namensgebung für Testklassen und -methoden @Disabled Möglichkeit eine Testklasse oder -methode nicht ausführen zu lassen @TestMethodOrder\n@Order Ausführungsreihenfolge der Tests bestimmen. @BeforeAll\n@BeforeEach\n@AfterAll\n@AfterEach Initialiserungen und Aufräumarbeiten vor und nach Unit-Tests Parametrisierte Unit-Tests Der oben gezeigte Unit-Test ist ein typisches Beispiel für einen Test, der mit vielen unterschiedlichen Parametern durchlaufen werden sollte. Wenn wir den Test parametrisieren, können wir die Test-Methode wiederverwenden.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package ch.sbb.talentfactory.rectangle; import org.junit.jupiter.params.ParameterizedTest; import org.junit.jupiter.params.provider.CsvSource; import static org.junit.jupiter.api.Assertions.assertEquals; public class RectangleTest { private Rectangle uut = new Rectangle(0, 0, 10, 10); @ParameterizedTest @CsvSource({ \"-1, 5, false\", \"11, 5, false\", \"5, -1, false\", \"5, 11, false\", \"5, 5, true\" }) void givenPoint_whenIsInside_thenReturnsExpectedResult(int x, int y, boolean expectedResult) { assertEquals(expectedResult, this.uut.isInside(x, y)); } } Mit @CsvSource können mehrere Parameter mit Komma getrennt angegeben werden. Die Anzahl (im Beispiel 3) muss mit den Parameter der Testklasse übereinstimmen.\nEin simpleres Beispiel ist hier zu sehen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package ch.sbb.talentfactory.calculator; import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; public class CalculatorTest { private Calculator uut = new Calculator(); @ParameterizedTest @ValueSource(ints = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }) public void givenOperand_whenAddFive_thenSumIsCorrect(int operand1) { // call method int result = this.uut.add(operand1, 5); // verify assertEquals(operand1 + 5, result); } } Der gezeigte Test wird so insgesamt neun Mal durchlaufen, wobei der Parameter operand1 jeweils die Werte des angegebenen Arrays durchläuft.\nWiederholende Unit-Tests Unit-Tests können mehrmals hintereinander ausgeführt werden, dabei wird die annotierte Test-Methode einfach mehrfach aufgerufen. Die Anzahl Aufrufe wird durch den Parameter in der Annotation bestimmt.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package ch.sbb.talentfactory.calculator; import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; public class CalculatorTest { private Calculator uut = new Calculator(); @RepeatedTest(10) public void givenRandomIntegers_whenAdd_thenSumIsCorrect() { // prepare test data Random random = new Random(); int i1 = random.nextInt(100); int i2 = random.nextInt(100); // call method int result = this.uut.add(i1, i2); // verify assertEquals(i1 + i2, result); } } Repetierende Tests können wie oben gezeigt benutzt werden, um beispielsweise mit generierten Zufallszahlen bestimmte Funktionen zu überprüfen.\nDisplay Names Testklassen und -methoden können mit der Annotation @DisplayName beliebig umbenannt werden.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package ch.sbb.talentfactory.calculator; import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; @DisplayName(\"Special test for calculator\") public class CalculatorTest { private Calculator uut = new Calculator(); @Test @DisplayName(\"Ultimate addition test\") public void givenTwoIntegers_whenAdd_thenSumIsCorrect() { // prepare test data int i1 = 5; int i2 = 9; // call method int result = this.uut.add(i1, i2); // verify assertEquals(14, result); } } Der angegebene Name erscheint dann in der Testauswertung.\nTests ausschalten Testklassen und -methoden können mit der Annotation @Disabled aus den Testläufen ausgeschlossen werden.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package ch.sbb.talentfactory.calculator; import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; @Disabled(\"Test disabled until calculator is finished\") public class CalculatorTest { private Calculator uut = new Calculator(); @Test public void givenTwoIntegers_whenAdd_thenSumIsCorrect() { // prepare test data int i1 = 5; int i2 = 9; // call method int result = this.uut.add(i1, i2); // verify assertEquals(14, result); } } Reihenfolge der Ausführung Die Reihenfolge von Tests bei der Ausführung kann durch die Verwendung von @TestMethodOrder und @Order bestimmt werden.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 package ch.sbb.talentfactory.calculator; import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; @TestMethodOrder(OrderAnnotation.class) public class CalculatorTest { private Calculator uut = new Calculator(); @Test @Order(1) public void givenTwoIntegers_whenAdd_thenSumIsCorrect() { // prepare test data int i1 = 5; int i2 = 9; // call method int result = this.uut.add(i1, i2); // verify assertEquals(14, result); } @Test @Order(2) public void givenTwoIntegersWithNegative_whenAdd_thenSumIsCorrect() { // prepare test data int i1 = -1; int i2 = 3; // call method int result = this.uut.add(i1, i2); // verify assertEquals(2, result); } } Die Annotation @Order wird nur verwendet, wenn der Typ der Ausführung OrderAnnation.class ist. Weitere Angaben sind “Alphanumeric” (Sortierung nach Methodenname) und “Random” (Zufällige Ausführungsreihenfolge).\nDaten initialisieren / aufräumen Mit den Annotationen @BeforeEach, @AfterEach, @BeforeAll und @AfterAll können bestimmte Initialisierungen und Aufräumarbeiten vor und nach Unit-Tests ausgeführt werden.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 package ch.sbb.talentfactory.calculator; import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; public class CalculatorTest { private Calculator uut = new Calculator(); @BeforeAll public static void setUpAll() { // Diese Methode wird VOR allen Test-Methoden EINMALIG ausgeführt } @BeforeEach public void setUp() { // Diese Methode wird VOR jeder Test-Methode ERNEUT ausgeführt } @Test public void givenTwoIntegers_whenAdd_thenSumIsCorrect() { // prepare test data int i1 = 5; int i2 = 9; // call method int result = this.uut.add(i1, i2); // verify assertEquals(14, result); } @AfterEach public void tearDown() { // Diese Methode wird NACH jeder Test-Methode ERNEUT ausgeführt } @AfterAll public static void tearDownAll() { // Diese Methode wird NACH allen Test-Methoden einmalig ausgeführt } } Verwendung von Providern Bei der Verwendung von parametrisierten Tests ist es möglich, dem Unit-Test über einen Stream von Argumenten entsprechende Testdaten oder Instanzen von verschiedenen Objekten zukommen zu lassen. Das folgende Beispiel illustriert die Verwendung eines solchen Providers.\nVier Gewinnt Interface\n1 2 3 public interface ConnectFourCheck { String checkWin(String[][] board); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class VierGewinntTest { private String[][] testBoard = { {\" \", \" \", \" \", \" \", \"O\"}, {\" \", \" \", \" \", \"O\", \"X\"}, {\" \", \" \", \" \", \"O\", \"X\"}, {\" \", \" \", \"O\", \"X\", \"X\"}, {\" \", \" \", \" \", \" \", \"X\"} }; // Alle Klassen des Streams (VierGewinntSolution1 und VierGewinntSolution2) implementieren das oben gezeigte Interface private static Stream\u003cArguments\u003e instances() { return Stream.of( Arguments.of(new VierGewinntSolution1()), Arguments.of(new VierGewinntSolution2()) ); } @ParameterizedTest @MethodSource(\"instances\") public void givenBoardWithWinningX_whenCheckWin_thenReturnsX(ConnectFourCheck cfc) { try { String winner = cfc.checkWin(this.testBoard); assertEquals(\"X\", winner); } catch (Exception e) { fail(e); } } } Mit einem solchen Provider kann derselbe Unit-Test für verschiedene Implementation (zum Beispiel eines Interfaces) wiederverwendet werden.\nMockito Mockito ist ein Framework zum Erstellen und Benutzen von Mocks in Softwaretests. Es bietet die Möglichkeit, Verhalten von noch nicht implementierten Klassen und Methoden rudimentär zu simulieren, um so das zu testende System (trotz fehlender Teile) testen zu können. Mockito ermöglicht auch andere Systeme/Services zu simulieren, welche z.B. von einem anderen Team entwickelt werden wie auch solche, deren echtes Verhalten zum Testzweck nicht interessiert oder sogar nicht erwünscht ist (man will aber z.B. wissen, dass diese Systeme/Services vom getesteten Code angesprochen worden sind).\nMockito kann in Unit-Tests wie auch in Integrations-Tests verwendet werden.\nWo kann ich das Framework herunterladen? Wie bei JUnit, werden auch für die Arbeit mit Mockito die Bibliotheken davon benötigt.\nAbhängigkeiten einbinden ohne Maven Dieser Abschnitt kann übersprungen werden, wenn mit einem Maven-Projekt gearbeitet wird. Das letzte Release (aktuell 5.3.1) kann hier heruntergeladen werden: Mockito Core 5.3.1 Jar-Datei\nDie Heruntergeladene Jar-Datei kann nun genau wie die JUnit-Jar-Dateien eingebunden werden.\nAbhängigkeiten einbinden mit Maven Dieser Abschnitt kann übersprungen werden, wenn es sich nicht um ein Maven Projekt handelt.\nDie entsprechende Abhängigkeit für das Project Object Model (pom.xml) ist:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mockito\u003c/groupId\u003e \u003cartifactId\u003emockito-core\u003c/artifactId\u003e \u003cversion\u003e5.3.1\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mockito\u003c/groupId\u003e \u003cartifactId\u003emockito-junit-jupiter\u003c/artifactId\u003e \u003cversion\u003e5.3.1\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e Mockito Begriffe Mock Mocks sind ein vollständiger Ersatz für Objekte, Services usw., von denen der zu testende Code abhängt, um seine Kernlogik zu testen. Ein Mock kann so programmiert werden, dass es eine angegebene Ausgabe zurückgibt, wenn eine Methode des Mocks aufgerufen wird.\nMockito bietet eine Standardimplementierung für alle Methoden eines Mocks. Das bedeutet, dass beim Aufrufen einer Methode eines Mocks, nicht der “echte” Code der Methode aufgerufen wird, sondern es wird ein von Mockito vordefinierter Wert zurückgeliefert (abhängig vom Rückgabewert-Typ der Methode).\nEs gibt Situationen, in denen es nützlich sein kann, bestimmte Werte aus einer Methode zurückzuliefern statt die Mockito-Standardwerte. In diesen Situationen kann ein gewünschter Rückgabewert vorkonfiguriert werden, so dass beim Aufruf der Methode, dieser Wert zurückgeliefert wird.\nSpy Ein Spy (‘Spion’) ist im Wesentlichen ein Wrapper für eine “echte” Instanz eines gemockten Objekts. Dies bedeutet, dass eine neue Instanz des Objektes erforderlich ist und dann ein Spy darüber hinzugefügt wird.\nStandardmässig leiten Spies Methodenaufrufe an die “echten” Methoden des Objekts weiter. Das ist auch der Hauptunterschied zwischen Spies und Mocks. Letztere überschreiben den “echten” Methoden-Code.\nSpies bieten aber auch die Möglichkeit, bestimmte Methoden als Mock-Methoden vorzukonfigurieren. In solchen Fällen, wird der Methodenaufruf nicht auf den “echten” Code weitergeleitet, sondern es wird, wie beim Mock, der vorgegebene Rückgabewert zurückgeliefert.\nMockito Annotationen Damit die Mockito-Annotationen innerhalb eines JUnit-Tests verwendet werden könnten, müssen sie zuerst eingeschaltet werden. Eine Möglichkeit dies zu tun ist, die Unit-Test-Klasse mit @ExtendWith zu annotieren und als Parameter den Wert MockitoExtension.class anzugeben:\n1 2 3 4 @ExtendWith(MockitoExtension.class) public class MyUnitTest { //TODO write tests } Die folgende Tabelle zeigt eine Übersicht über die wichtigsten Annotationen von Mockito:\nAnnotation Beschreibung @Mock Mock-Objekte erzeugen lassen @InjectMock Markiert ein Feld, welches mit Mocks initiiert wird @Spy Spy-Objekte erzeugen lassen @Captor ArgumentCaptor Objekte erzeugen lassen Wie diese Annotationen verwendet werden, wird in den folgenden Kapiteln gezeigt.\n@Mock Annotation Diese Annotation wird dazu verwendet, um Mock-Objekte komplett von Mockito erzeugen zu lassen. Das heisst, die gesamte Mock-Funktionalität wird von Mockito zur Verfügung gestellt.\n1 2 3 4 5 6 7 8 9 10 11 12 13 @ExtendWith(MockitoExtension.class) public class MyUnitTest { @Mock private List\u003cString\u003e mockedList; // hier wird eine Liste von Strings gemockt. // Mockito stellt eine rudimentäre Umsetzung für JEDE Methode der Liste zur Verfügung @Test public void givenMockedList_whenAddElement_thenSizeRemainsZero() { mockedList.add(\"one\"); assertEquals(0, mockedList.size()); } } Was mit einem Mock gemacht werden kann und wie der Mock vorkonfiguriert werden kann, wird in einem späteren Kapitel erklärt.\n@InjectMocks Annotation Wenn eine Klasse ein Objekt-Feld beinhaltet, kann Mockito dieses Feld mit einem Mock initiieren. Damit es funktioniert, muss das Feld entweder via Konstruktor, via Setter oder via Property-Injection initialisiert werden.\nIm folgenden Beispiel, hat die Klasse MyService ein Feld vom Typ DataService, welches mittels Konstruktor initialisiert werden kann:\n1 2 3 4 5 6 7 8 9 10 11 12 13 import java.util.List; public class MyService { private final DataService dataService; public MyService(DataService dataService) { this.dataService = dataService; } public int processData(List\u003cInteger\u003e numbers) { return dataService.sum(numbers); } } 1 2 3 4 5 import java.util.List; public interface DataService { int sum(List\u003cInteger\u003e numbers); } Im Test, wird ein Mock für ein DataService erstellt und mit der Annotation @InjectMocks, via Konstruktor-Initialisierung in dem MyService-Objekt injektiert (der Konstruktor muss also nicht noch dazu aufgerufen werden):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import org.junit.jupiter.api.Test; import org.junit.jupiter.api.extension.ExtendWith; import org.mockito.InjectMocks; import org.mockito.Mock; import org.mockito.junit.jupiter.MockitoExtension; import java.util.Arrays; import java.util.List; import static org.junit.jupiter.api.Assertions.assertEquals; @ExtendWith(MockitoExtension.class) public class MyServiceTest { @Mock private DataService dataService; // hier wird ein DataService gemockt. @InjectMocks private MyService myService; // der Mock von DataService wird in die MyService-Instanz \"injiziiert\", das heisst // überall im DataService-Objekt, wo der DataService verwendet wird, wird der Mock zum Zug kommen! @Test public void givenListOfNumbers_whenProcessData_thenReturnsSum() { List\u003cInteger\u003e numbers = Arrays.asList(1, 2, 3, 4, 5); Mockito.when(dataService.sum(numbers)).thenReturn(15); int result = myService.processData(numbers); assertEquals(15, result); } } @Spy Annotation Ein Spy wird auf einem “echten” Objekt erzeugt. Dieser Spy leitet, sofern nichts anderes konfiguriert wurde, alle Methodenaufrufe an das echte Objekt weiter. Mit Hilfe der Mockito-Methoden, kann jedoch definiert werden, dass bestimmte Methoden “umgeleitet” werden und eine andere Umsetzung dafür angewendet wird.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import org.junit.jupiter.api.Test; import org.junit.jupiter.api.extension.ExtendWith; import org.mockito.*; import org.mockito.junit.jupiter.MockitoExtension; import java.util.List; import static org.junit.jupiter.api.Assertions.assertEquals; @ExtendWith(MockitoExtension.class) public class MyUnitTest { @Spy private List\u003cString\u003e spiedList; // Ein Spy über eine Liste. Wenn nichts anders konfiguriert wird // werden die \"echte\" Listen-Methoden aufgerufen, wenn der Spy verwendet wird. @Captor private ArgumentCaptor\u003cString\u003e stringCaptor; // stringCaptor wird ein Argument vom Typ String \"fangen\" @Test public void givenSpiedList_whenAddElement_thenCaptorCapturesValue() { spiedList.add(\"one\"); Mockito.verify(spiedList).add(stringCaptor.capture()); // während der Prüfung wird das Argument // für die Methode add() gefangen // und im stringCaptor aufbewahrt assertEquals(\"one\", stringCaptor.getValue()); // mit getValue() kann das gefangene Argument inspiziert werden } } ⚠️ ACHTUNG ⚠️\nFür Stubbing in @Spy muss immer die Notation Mockito.doReturn().when().size(); verwendet werden. Mit Mockito.when().thenReturn() wird es nicht funktionieren. Grund dafür ist, dass wenn Mockito.doReturn().when().size(); verwendet wird, in jedem Fall das gegebene Return durchgeführt wird. Wenn bei Mockito.when().thenReturn() zum Beispiel eine Exception auftritt, wird nicht das richtige Resultat zurück gegeben.\nWie ein Spy verwendet werden kann, um nur einige Methoden umzuleiten, wird in einem späteren Kapitel erklärt.\n@Captor Annotation Ein ArgumentCaptor kann Argumente einer Methode “fangen” damit diese danach inspiziert werden könnten.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import org.junit.jupiter.api.Test; import org.junit.jupiter.api.extension.ExtendWith; import org.mockito.ArgumentCaptor; import org.mockito.*; import org.mockito.junit.jupiter.MockitoExtension; import java.util.List; import static org.junit.jupiter.api.Assertions.assertEquals; @ExtendWith(MockitoExtension.class) public class MyUnitTest { @Mock private List\u003cString\u003e mockedList; @Captor private ArgumentCaptor\u003cString\u003e stringCaptor; // stringCaptor wird ein Argument vom Typ String \"fangen\" @Test public void givenMockedList_whenAddElement_thenCaptorCapturesValue() { mockedList.add(\"one\"); Mockito.verify(mockedList).add(stringCaptor.capture()); // während der Prüfung wird das Argument // für die Methode add() gefangen // und im stringCaptor aufbewahrt assertEquals(\"one\", stringCaptor.getValue()); // mit getValue() kann das gefangene Argument inspiziert werden } } Mockito statische Methoden Mockito stellt mehrere statische Methoden zur Verfügung, welche das Konfigurieren von Mocks und Spies wie auch deren Überwachung ermöglichen. In diesem Kapitel werden die wichtigsten Methoden anhand von Beispielen erklärt.\nMockito.when kombiniert mit Mockito.thenReturn Die Mockito.when Methode kombiniert mit der Methode Mockito.thenReturn ermöglicht es, die Standardimplementierung einer Methode für ein gegebenen Mock zu überschreiben. Dasselbe kann auch mit der Kombination Mockito.doReturn und danach when erreicht werden.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @ExtendWith(MockitoExtension.class) public class MyUnitTest { @Mock private List\u003cString\u003e mockedList; // eine Mock-Liste, mit Mockitos-Standardimplementierung für alle Methoden @Test public void givenMockedList_whenSizeIsOverridden_thenReturnsConfiguredValues() { assertEquals(0, mockedList.size()); // die Mockito-Standardimplementierung für \"size()\" // liefert immer 0 zurück Mockito.when(mockedList.size()).thenReturn(10); // hier wird die Standardimplementierung der Methode // size() auf dem Mock-Objekt überschrieben, // sodass immer der Wert 10 zurückgeliefert wird. assertEquals(10, mockedList.size()); Mockito.doReturn(20).when(mockedList).size(); // auch hier wird die Standardimplementierung der Methode // size() auf dem Mock-Objekt überschrieben, // diesmal mit dem Wert 20. assertEquals(20, mockedList.size()); } } Mockito.verify Die Mockito.verify Methode prüft, ob eine Interaktion mit dem Mock/Spy-Objekt stattgefunden hat. Geprüft werden kann unter anderem folgendes (weitere Prüfungen werden hier anhand von Beispielen erklärt):\nEs gab keine Interaktion mit dem Mock/Spy Es gab eine Interaktion mit dem Mock/Spy Es gab eine gewisse Anzahl an Interaktionen mit dem Mock/Spy Es gab mindestens eine gewisse Anzahl an Interaktionen mit dem Mock/Spy Es gab nicht mehr als eine gewisse Anzahl an Interaktionen mit dem Mock/Spy Interaktion in diesem Sinn kann entweder eine Interaktion mit dem Objekt oder mit einer seiner Methoden sein.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 import org.junit.jupiter.api.Test; import org.junit.jupiter.api.extension.ExtendWith; import org.mockito.*; import org.mockito.junit.jupiter.MockitoExtension; import java.util.List; import static org.mockito.Mockito.*; @ExtendWith(MockitoExtension.class) public class MyUnitTest { @Mock private List\u003cString\u003e mockedList; // eine Mock-Liste, mit Mockitos-Standardimplementierung für alle Methoden @Spy private List\u003cString\u003e spiedList; // ein Spy über eine Liste. @Test public void givenSpiedList_whenAddAndClear_thenVerifyInteractions() { spiedList.add(\"one\"); // hier wird die \"echte\" add Methode einer Liste aufgerufen! verify(spiedList).add(\"one\"); // prüfe, ob die \"add\" Methode mit dem Parameter \"one\" auf dem spyList aufgerufen wurde verify(spiedList, never()).size(); // prüfe, ob die size() Methode nie aufgerufen wurde spiedList.clear(); spiedList.clear(); verify(spiedList, times(2)).clear(); // prüfe, ob die clear() Methode genau 2 Mal aufgerufen wurde } @Test public void givenMockedList_whenSizeCalled_thenVerifyInteractionCount() { Mockito.verifyNoInteractions(mockedList); // bis hier gab es keine Interaktionen mit dem mockedList Objekt mockedList.size(); mockedList.size(); mockedList.size(); mockedList.size(); verify(mockedList, atLeast(1)).size(); // prüfe, ob die size() Methode mindestens einmal aufgerufen wurde verify(mockedList, atMost(5)).size(); // prüfe, ob die size() Methode nicht mehr als 5 Mal aufgerufen wurde } } Test Driven Development (TDD) Test Driven Development (TDD) (Testgetriebene Entwicklung) ist ein Softwareentwicklungsansatz, bei dem ein Test geschrieben wird, bevor der Code geschrieben wird. Sobald der neue Code den Test besteht, wird er auf einen akzeptablen Standard umgestellt.\nTDD stellt sicher, dass der Quellcode gründlich getestet wird und zu modularisiertem, flexiblem und erweiterbarem Code führt. Es konzentriert sich darauf, nur den Code zu schreiben, der notwendig ist, um Tests zu bestehen, wodurch das Design einfach und klar wird.\nMit TDD kann der Programmierer beim Schreiben von Software kleine Schritte unternehmen.\nDer Test wird vor dem Testen der Funktionalität geschrieben und stellt sicher, dass die Anwendung für die Testbarkeit geeignet ist, erst danach wird die Funktionalität implementiert. Dies wird als „Rot-Grün-Refaktor“ bezeichnet, wobei Rot bedeutet, fehlgeschlagen zu sein, und Grün zeigt einen erfolgreichen Durchlauf an. Diese Schritte werden dann wiederholt.\nSchritte eines test gesteuerten Entwicklungszyklus Der test-gesteuerte Entwicklungszyklus besteht aus folgenden, sich immer wiederholenden, Schritten:\nHinzufügen eines Tests, der fehlschlägt: Jedes neue Feature in TDD beginnt mit einem Test, der nach seiner Implementation fehlschlagen muss, bevor die Features implementiert werden. Code schreiben und damit den Test “begrünen”: Es wird nur soviel Code geschrieben, wie zum “Begrünen” des Tests nötig ist - nicht mehr! (alle bisherigen Tests müssen weiterhin erfolgreich durchlaufen!!) Code verbessern, ohne dabei die Funktionalität zu verändern (Refactor): Code bereinigen (z.B. das Entfernen von Duplikaten, kleinere Methoden usw.) und auf “Clean Code” Standard bringen TDD Walkthrough In diesem Walkthrough wird der TDD Entwicklungszyklus anhand eines Beispiels erläutert.\nIn diesem Beispiel geht es darum eine Klasse zu schreiben, welche ein Tier modelliert. Das Tier soll uns informieren, ob es Hunger hat oder nicht.\nSchritt 1: Grundgerüst erstellen Es wird nur die Klasse erstellt, welche dann getestet werden soll:\n1 2 public class Animal { } Schritt 2: Fehlschlagender Test schreiben 1 2 3 4 5 6 7 public class AnimalTest { @Test public void newAnimal_isHungry_returnTrue() { Animal myAnimal = new Animal(); assertTrue(myAnimal.isHungry()); } } Zu diesem Zeitpunkt existiert die Methode “isHungry” nicht (Kompilierfehler) und natürlich gibt sie kein “true” zurück. Im nächsten Schritt wird die Methode hinzugefügt und der Test “begrünt”.\nSchritt 3: Test “begrünen” 1 2 3 4 5 public class Animal { public boolean isHungry() { return true; } } Der Test, welcher vorher geschrieben wurde, kompiliert nun und kann erfolgreich durchlaufen werden. Somit ist dieser Zyklus beendet (es gibt noch nichts, was refactored werden soll)\nSchritt 4: Neuer, fehlschlagender Test schreiben 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class AnimalTest { @Test // Dieser Test ist nun grün... public void newAnimal_isHungry_returnTrue() { Animal myAnimal = new Animal(); assertTrue(myAnimal.isHungry()); } @Test public void animalAte_isHungry_returnFalse() { Animal myAnimal = new Animal(); animal.eat(); // Kompilierfehler, da es diese Methode noch nicht gibt assertFalse(myAnimal.isHungry()); } } Schritt 5: zweiter Test “begrünen”, ohne den ersten Test “kaputt” zu machen In diesem Schritt finden wir heraus, dass wir einen Hunger-Zustand für unser Tier haben müssen, welcher sich ändert, wenn das Tier gefressen hat:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Animal { private boolean isHungry = true; // müssen wir hier so setzen, damit der erste Test noch funktioniert! public boolean isHungry() { if (isHungry) { return true; } else { return false; } } public void eat() { isHungry = false; } } Nach diesem Schritt kompiliert der Test wieder erfolgreich und beide Tests werden erfolgreich durchlaufen.\nSchritt 6: Refactor Unser Code kann nun eleganter geschrieben werden, ohne dabei die Funktionalität zu ändern:\n1 2 3 4 5 6 7 8 9 10 11 public class Animal { private boolean isHungry = true; public boolean isHungry() { return isHungry; // if-else ersetzt, da nicht nötig } public void eat() { isHungry = false; } } Somit ist auch dieser Zyklus beendet.\nDer code wird so stetig weiterentwickelt und neue Funktionalitäten werden auf diese Weise Schritt für Schritt und getestet hinzugefügt. Dabei werden die bereits bestehenden Funktionalitäten durch die bisherigen Tests vor ungewollten Änderungen geschützt.\nJetzt bist du dran. Löse bitte die Aufgaben in den Labs.\n","categories":"","description":"Modul #J4\n","excerpt":"Modul #J4\n","ref":"/docs/02_java/08_java-testing/","tags":"","title":"Testing"},{"body":"Ziele Ich weiss, warum das Testen in der Softwareentwicklung eine zentrale Bedeutung hat. Ich kenne die relevantesten gängigen Testarten in der Software-Entwicklung und deren Zweck. Ich weiss, was Testmanagement ist und was es dabei zu beachten gilt. Ich kenne die wichtigsten Funktionen des Frameworks JUnit 5. Ich kann für einfache Anwendungen selber Unit-Tests implementieren. Ich kenne die wichtigsten Funktionen des Frameworks Mockito. Ich weiss, was Mocks und Spies sind und kenne den Unterschied dazwischen. Ich weiss, was Test-Driven-Development ist und wie ich diese Methodik anwenden kann. Einführung Tests in den unterschiedlichen Phasen der Softwareentwicklung dienen dazu festzustellen, ob die entwickelte Software die spezifizierten Anforderungen erfüllt oder nicht. Ausserdem können Tests Mängel in dem produzierten Code aufdecken noch bevor der Code produktiv geschaltet wird und stellen damit sicher, dass das Endprodukt fehlerfrei funktioniert.\nTests sind vor allem aus folgenden Gründen sehr wichtig und sollen entsprechend sehr früh (dazu später) in den Entwicklungsprozess integriert werden:\nTesting erhöht die Qualität des entwickelten Produkts, da damit Mängel frühzeitig entdeckt und beseitigt werden können. Testing gibt mehr Sicherheit bei Änderungen am Code, da damit sichergestellt werden kann, dass die Änderung nicht zu unerwünschten Nebenwirkungen geführt haben. Testing spart Geld da damit weniger Nachbearbeitungsaufwand in Form von Bug/Hot-Fixes betrieben werden muss. Testing führt zu höherer Kundenzufriedenheit da damit weniger Fehler den Kunden davor hindern, fehlerfrei mit dem Produkt zu arbeiten. Testarten Es gibt viele verschiedene Softwaretestverfahren und Methoden, mit denen sichergestellt werden kann, dass Änderungen am Code wie erwartet funktionieren.\nSoftwaretests können in zwei Bereiche unterteilt werden: manuelles Testen und automatisiertes Testen. Beim manuellen Testen werden Testfälle manuell durch einen Menschen und ohne Unterstützung durch Werkzeuge oder Skripte ausgeführt.\nBeim automatisierten Testen werden Testfälle jedoch mithilfe von Tools, Skripten und Software ausgeführt.\nHier werden wir uns auf das automatisierte Testen konzentrieren, da dieses im Softwareentwicklungsprozess essenziell ist.\nUnit-Tests Unit-Tests sind inhaltlich sehr simpel und erfolgen nah an der Quelle der Anwendung.\nSie dienen zum Testen einzelner Methoden und Funktionen der von der Software verwendeten Klassen, Komponenten oder Module.\nMit Unit-Tests stellen wir sicher, dass einzelne Funktionsblöcke einer Applikation genau das machen, was sie sollen. Vielen passiert es am Anfang, dass nur “Positiv-Fälle” getestet werden. Konkret heisst das, dass der getestete Teil nur im Rahmen des korrekten, erwarteten Verhaltens geprüft wird. Es ist aber genauso wichtig, Negativ-Tests und Rahmentests durchzuführen, wo der geprüfte Teil konkret auf das Verhalten in einem Grenz- oder Fehlerfall geprüft wird. So kann bereits vielen Fehlern in der Zukunft mit wenig Aufwand vorgebeugt werden.\nEin Unit-Test ist immer ein sog. “White-Box” Test, da der Entwickler bei der Implementation von Unit-Tests den Sourcecode kennt oder ihn einsehen kann.\nBei Unit-Tests in Java ist der Testumfang eines Unit-Tests normalerweise in der Grössenordnung einer Methode oder Funktionalität.\nIn der Regel lassen sich Unit-Tests automatisieren und können einzeln oder auch in Gruppen (in sog. Test-Suites) lokal (an der eigenen Maschine) oder von einem Continuous-Integration-Server (eine externe Maschine, die dafür sorgt, dass Programmteile sofort getestet und zusammengeführt werden können) sehr schnell durchgeführt werden.\nIntegration-Tests Mit Integration-Tests wird sichergestellt, dass verschiedene Programmteile der Anwendung problemlos ineinandergreifen und miteinander harmonieren. So kann beispielsweise die Interaktion mit einer Datenbank oder das Zusammenspiel von verschiedenen Mikroservices getestet werden. Im Gegensatz zu Unit-Tests beschränkt sich diese Test-Art also nicht auf einzelne Methoden oder Funktionen, sondern auf verschiedene Module oder Klassen und deren Zusammenspiel.\nTests dieser Art sind kostspieliger und können auch länger dauern als Unit-Tests, weil dafür mehrere Teile der Anwendung funktionsfähig sein müssen. Dafür können konkretere Aussagen über den generellen Zustand einzelner, ineinandergreifende Funktionalitäten aufgrund der Testergebnisse getätigt werden.\nSystem-Tests System-Tests gehen noch einmal eine Stufe höher als Integrations-Tests und prüfen eine gesamte Applikation auf spezifische Business-Anforderungen. Zumeist werden diese mithilfe von Tools automatisch ausgeführt und sind im Vergleich zu Integrations-Tests und vor allem Unit-Tests ziemlich aufwändig.\nSystem-Tests bieten, wenn sie richtig geschrieben und gepflegt werden, einen grossen Mehrwert für das Team. Da nicht nur einzelne Funktionen, sondern ganze Anwendungsfälle geprüft werden und die Tests automatisch ausführbar sind, bieten sie einen starken Rückhalt bei der Pflege der Applikation und der Kommunikation bei Erreichung einer Anforderung.\nAkzeptanz-Tests Bei Akzeptanz-Tests wird der Umgang des Benutzers (oder auch andere, externe Programme) mit der Software in einer vollständigen Anwendungsumgebung repliziert. Auf diese Weise wird das ordnungsgemässe Funktionieren von Benutzerabläufen überprüft. Die Szenarien können ganz einfach sein (z.B. Laden einer Website, Anmeldevorgang) oder auch sehr komplex (z.B. E-Mail-Benachrichtigungen, Onlinezahlungen).\nAkzeptanz-Tests sind sehr nützlich, aber auch aufwändiger zu erstellen und in automatisierter Form unter Umständen schwer zu verwalten. Daher empfiehlt es sich grundsätzlich, Akzeptanz-Tests manuell auf Basis der Use-Cases, die man für eine Applikation hat, zu testen. Viele Teams oder Organisations-Einheiten haben ein dediziertes Testing-Team, welches sich ausschliesslich um das Testen von Applikationen und den Umgang mit gefundenen Fehlern kümmert.\nWichtig anzumerken ist ebenfalls, dass Akzeptanz-Tests auch nicht-funktionale Anforderungen abdecken. Während Unit-Tests hauptsächlich funktionale Anforderungen wie beispielsweise eine Anmeldefunktion geprüft werden, werden mit Akzeptanz-Tests auch nicht-funktionale Anforderungen wie bspw. die Latenz von Anfragen geprüft.\nTestmanagement Unter Testmanagement versteht man die geplante und effiziente Koordination aller Testprozesse, die die Qualität von Software optimieren und langfristig gewährleisten. Grundsätzlich wird so die Identifizierung von und Reduzierung teilweise versteckter Qualitätsrisiken ermöglicht, womit potenzielle zukünftig auftretende finanzielle und aufwandstechnische Belastungen in der Zukunft minimiert werden können. Hauptsächlich verfolgt das Testmanagement also 2 Ziele:\nMöglichst früh Software-Fehler aufdecken. Die Unsicherheit bezüglich der Qualität der Software minimieren. Diese beiden Punkte sollen nachfolgend noch ein Stück ausformuliert werden.\nMöglichst früh Software-Fehler aufdecken Oft ist es so, dass in der Entwicklung, Anpassungen oder Installation von Software erst recht spät getestet wird, was dazu führt, dass eine entsprechende Reaktion auf einen Fehler meist erst verspätet ermöglicht wird. Grundsätzlich ist es so, dass die aus einem Fehler entstehenden Kosten exponentiell ansteigen, je später ein solcher gefunden und behandelt wird. Die untenstehende Grafik veranschaulicht das relativ gut. Während das Beheben eines gefundenen Fehlers beim Erstellen und Prüfen der Anforderungen (Reqs) kaum etwas kostet, sind die Kosten im Produktiven-Kontext (PROD) schon um einiges höher.\nDa die meisten Fehler schon sehr früh im Umsetzungs-Ablauf passieren, lohnt es sich enorm, in ein sinnvolles Test-Management zu investieren, da so enorm viele Ressourcen gespart werden können.\nDie Unsicherheit bezüglich der Qualität der Software minimieren Es ist oft schwierig, einen guten Ausgleich zwischen einer guten Testabdeckung und einer lohnenswerten Wirtschaftlichkeit für das Unternehmen zu finden, da beispielsweise eine Testabdeckung von 100% bei einer App schon sehr teuer werden kann. Daher ist es auch ein Fehlschluss, dass man mit genügend Tests sicherstellen könne, dass eine Software fehlerfrei ist. Testmanagement hat daher zum Ziel, die Unsicherheit, dass eine Software kritische Fehler enthält, soweit zu minimieren, dass eine Produktivsetzung der App ohne schlechtes Gewissen durchgeführt werden kann. Testmanagement hat daher nicht zum Ziel, dass eine Software absolut fehlerfrei ist.\nVorteile von Testmanagement Ein strukturiertes Testmanagement mit klar verteilten Rollen, Verantwortlichkeiten und Aufgaben resultiert zumeist in einigen Vorteilen, beispielsweise den folgenden:\nKostenreduktion: Da Fehler oft zu einem früheren Zeitpunkt gefunden werden, wenn ein sinnvolles Testmanagement umgesetzt wird, können viele sonst entstehende Mehrkosten vermieden werden. Zudem bestehen in diesem Fall auch geringe Wartungsaufwände durch wiederholbare Tests und Klarheit in Bezug auf die zu testenden Anforderungen. Auch so kann stellenweise viel Geld gespart werden. Bessere Planbarkeit der Testphasen durch bekannte Testumfänge. Personenunabhängige Tests durch ausreichende Testfalldefinitionen und -dokumentation, was je nachdem sogar ein Outsourcing des Testings erlaubt. Stetige Verbesserung der Softwarequalität durch das Leben und durchgehende Verbessern des Testmanagements. Potenzielle Ressourcen- und Zeiteinsparung durch automatisierte Tests. Der Testprozess nach ISTQB Ein offizieller Testprozess, nachdem man sich grundsätzlich ausrichten kann, ist der des International Software Testing Qualitications Board. (ISTQB) Das ISTQB hat gängige, bewährte Praktiken und Terminologien zu einem prinzipiell universell anwendbaren Standard gebündelt, auf den nachfolgend etwas genauer eingegangen werden soll.\nDer ISTQB-Prozess besteht grundsätzlich aus 4 Testphasen:\nIncident Management Problem Management Change Management Release Management Zu den jeweiligen Phasen gehören jeweils noch die entsprechenden Aktivitäten, namentlich die Planung, Spezifikation, Durchführung, Protokollierung und Auswertung der Tests. Diese Aktvitäten werden per ISTQB jeweils in die folgenden Gruppen eingerodnet:\nTestplanung und -steuerung Testanalyse und -design Testrealisierung und -durchführung Testauswertung und -bericht Abschluss Rollen im Testmanagement Es gibt innerhalb des Testmanagements viele verschiedene Rollen, die jeweils verschiedene Tätigkeiten verfolgen. Wie man diese unterscheidet, ist jeweils abhängig von der Tiefe der Betrachtung pro Fall, der Einfachheit nehmen wir hier aber die einfachste Unterscheidung mit 2 Rollen; einmal der des Testmanagers und einmal der des Testers.\nTestmanager Der Testmanager ist für den gesamten, übergreifenden Testprozess und die erfolgreiche Durchführung der Testaktivitäten zu verantworten. Da es sich hier um eine rein koordinative Arbeit handelt, kann diese Rolle von verschiedenen Personen übernommen werden. Wenn es der technische Prozess fordert, kann das ein professioneller Testmanager sein, in anderen Fällen kann es aber genau so gut ein Projektleiter ohne grossen technischen Hintergrund sein.\nTypische Aufgaben eines Testmanagers umfassen:\nDas Festlegen der Testrategie und -vorgaben für das Unternehmen Das Erstellen und Aktualisieren von Testplänen Das Koordinieren der Testpläne zwischen verschiedenen Stakeholdern Das Einplanen und Anstossen der verschiedenen Testaktivitäten wie der Testanalyse, dem Testdesign, der Testimplementierung und der Testdurchführung. Das Monitoring (Überwachen) der Testfortschritte und -ergebnisse Das Berichten über die Testfortschritte und -ergebnisse Diese Aufgaben sind nicht als fixe Beschreibung der Rolle eines Testmanagers zu verstehen, sondern mehr als Beispiele. Je nach Grösse des Unternehmens, Anforderungen an das Testmanagement und das Produkt selbst und gegebener Zeit können andere Aufgaben dazukommen oder genannte Aufgaben wegfallen. Eine Priorisierung dieser Aufgaben ist somit für jeden Fall unterschiedlich.\nTester Ein Tester übernimmt grundsätzlich alle operativen Aufgaben innerhalb des Testprozesses, wobei das Durchführen der Tests nur eine Aufgabe darstellt, die der Tester übernimmt. Je nachdem, welches Rollenmodell verfolgt wird, wird innerhalb der Rolle des Testers noch weiter zwischen einzelnen rollen unterschieden. Das können beispielsweise die folgenden sein:\nTestdesigner Testautomatisierer Testarchitekt etc. Im Rahmen dieser Dokumentation nehmen wir aber alle diese Teilrollen unter einen Hut als “Tester”. Typische Aufgaben in dieser Rolle können das Folgende umfassen:\nPrüfen der Anforderungen, Spezifikationen und Akzeptanzkriterien in Bezug auf die Testbarkeit Identifizieren und Dokumentieren der Testvoraussetzungen Erstellung und Implementation von Testfällen und Testprozeduren Erstellung des detaillierten Testausführungsplans Testautomatisierung (Bereitstellung der Testumgebung mit geeigneten Testdaten) JUnit Zur Implementation von Unit-Tests steht in Java das Framework JUnit zur Verfügung. Die aktuellste Version ist 5.9.0. Dies ändert aber stetig, da das Produkt laufend weiterentwickelt wird. Vielfach ist in Produkten und Projekten auch JUnit 4 im Einsatz. In diesem Modul wird jedoch nur die aktuellste Version von JUnit behandelt. Wir schreiben Unit-Tests also mit JUnit 5.\nWie ist JUnit 5 aufgebaut? Das Framework besteht aus folgenden Teilen:\nTeil Verwendung JUnit Plattform Grundlage zur Einführung von Testframeworks in die JVM. Definition der Test-Engine zur Entwicklung von Testframeworks auf der jeweiligen Plattform. Plattform-Konsole zum Starten der Plattform. Kurz gesagt: Plattform zur Ausführung von Unit-Tests JUnit Jupiter Programmiermodell zur Implementation von Unit-Tests JUnit Vintage Ermöglicht die Ausführung von Tests, die mit JUnit 3 oder JUnit 4 geschrieben wurden Wo kann ich das Framework herunterladen? Damit wir nun Unit-Tests implementieren können benötigen wir zuerst die Bibliotheken von JUnit 5, dies wird in den beiden folgenden Abschnitten beschrieben.\nAbhängigkeiten einbinden ohne Maven Dieser Abschnitt kann übersprungen werden, wenn mit einem Maven-Projekt gearbeitet wird. Alle Bibliotheken sind unter den beiden folgenden Links zu finden:\norg.junit.jupiter org.junit.platform Die folgenden JARs werden benötigt:\nAus dem ersten Link junit-jupiter-engine junit-jupiter-params junit-jupiter junit-jupiter-api Aus dem zweiten Link junit-platform-engine junit-platform-commons Die Einbindung in ein Projekt muss (ohne Maven) manuell gemacht werden. Die folgende Anleitung soll dabei helfen:\n# Beschreibung Screenshot 1 Ordner für Bibliotheken im Projekt anlegen. Im Projekt (Root) einfach einen neuen Ordner “lib” erzeugen. 2 Die oben genannten JAR-Bibliotheken in den neuen Ordner kopieren 3 Projekteinstellungen öffnen. Das Projekt mit einem Klick markieren und Taste F4 drücken. Die Projekteinstellungen werden geöffnet 4 Auf der linken Seite den Tab “Libraries” auswählen 5 Oben auf das Plus-Icon klicken und Java auswählen 6 Die vorhin kopierten Bibliotheken auswählen und alle Dialoge mit OK bestätigen 7 Die Bibliothek muss anschliessend dem Modul hinzugefügt werden. Der Scope sollte auf Test gestellt werden, da es sich um reine Test-Bibliotheken handelt. Abhängigkeiten einbinden mit Maven Dieser Abschnitt kann übersprungen werden, wenn es sich nicht um ein Maven Projekt handelt.\nDie entsprechenden Abhängigkeiten für das Project Object Model (pom.xml) sind:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 \u003cdependencies\u003e \u003c!-- Plattform --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter\u003c/artifactId\u003e \u003cversion\u003e5.9.0\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c!-- API, enthält unter anderem alle Annotationen --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter-api\u003c/artifactId\u003e \u003cversion\u003e5.9.0\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c!-- Test-Engine zur Ausführung von Unit-Tests, die mit JUnit 5 geschrieben wurden --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter-engine\u003c/artifactId\u003e \u003cversion\u003e5.9.0\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c!-- JUnit 5 Erweiterung für parametrisierte Tests (Optional) --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter-params\u003c/artifactId\u003e \u003cversion\u003e5.9.0\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c!-- Test-Enginge zur Ausführung von Unit-Tests, die mit JUnit 3 oder JUnit 4 geschrieben wurden (Optional) --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.vintage\u003c/groupId\u003e \u003cartifactId\u003ejunit-vintage-engine\u003c/artifactId\u003e \u003cversion\u003e5.9.0\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c!-- Bibliotheken für die Ausführung von Unit-Tests --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.platform\u003c/groupId\u003e \u003cartifactId\u003ejunit-platform-engine\u003c/artifactId\u003e \u003cversion\u003e1.9.0\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.platform\u003c/groupId\u003e \u003cartifactId\u003ejunit-platform-commons\u003c/artifactId\u003e \u003cversion\u003e1.9.0\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e Füge diese Abhängigkeiten (ohne die optionalen) in dein pom.xml ein. Danach besitzt du alle Bibliotheken, die zur Implementation von Unit-Tests notwendig sind.\nOrdnerstruktur anlegen Um Unit-Tests implementieren zu können benötigen wir grundsätzlich die folgende Ordnerstruktur im IntelliJ IDEA.\nFalls dein Projekt kein Maven-Projekt ist, kannst du die Verzeichnisse einfach manuell anlegen. Mit einem Rechtsklick auf die Verzeichnisse, kannst du sie mit dem Befehl “Mark Directory as” aus dem Kontext-Menü wie folgt markieren:\nVerzeichnis Markierung Zweck src/main/java Sources Root Source Code deiner Applikation src/main/resources Resources Root Ressourcen deiner Applikation, die nicht Programmcode sind src/test/java Test Sources Root Source Code deiner Unit-Tests src/test/resources Test Resources Root Ressourcen deiner Unit-Tests, die nicht Programmcode sind Diese Ordnerstruktur wurde ursprünglich vom Projektmanagement-Tool Gradle “erfunden” und dann von Maven übernommen. Stand heute ist dies die Standard-Ordnerstruktur innerhalb von Java-Projekten.\nImplementation von Unit-Tests an einem Beispiel Nach all den Vorbereitungen sind wir nun bereit Unit-Tests zu implementieren. Der folgende Abschnitt beschreibt die Grundlagen für das Schreiben von Unit-Tests.\nDas JUnit-Framework\nnutzt Assertions, um Resultate innerhalb eines Tests zu überprüfen nutzt Annotationen, um Testfälle zu finden und durchzuführen Erklärung Beispiel einer Unit-Test Implementation anhand eines einfachen Beispiels.\nHinweis im Beispielcode wird folgendes Namensschema für Tests verwendet:\n1 2 3 public void given_when_then() { ... } Wobei:\ngiven die Ausgangslage definiert (z.B. twoIntegers oder givenTwoIntegers) when ist der Name der Methode, welche getestet wird (z.B. whenAdd oder add) then ist das Ergebnis, welche erwartet wird (z.B. thenSumIsCorrect oder sumCorrect) Source-Code\n1 2 3 4 5 6 7 package ch.sbb.talentfactory.calculator; public class Calculator { public int add(int i1, int i2) { return i1 + i2; } } Test-Code\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package ch.sbb.talentfactory.calculator; import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; public class CalculatorTest { private Calculator uut = new Calculator(); @Test void givenTwoIntegers_whenAdd_thenSumIsCorrect() { // prepare test data int i1 = 5; int i2 = 9; // call method int result = this.uut.add(i1, i2); // verify assertEquals(14, result); } } Der Unit-Test befindet sich im gleichen Package wie die zu testende Klasse. Innerhalb der weiter oben genannten Ordnerstruktur ist die Test-Klasse aber nicht am gleichen Ort abgelegt! Innerhalb des Unit-Tests wird zuerst eine Instanz der zu testenden Klasse angelegt. Die Bezeichnung für diese Instanz lautet normalerweise UUT, dies steht für “Unit Under Test”. Für jeden Test einer der Methoden aus dem UUT wird anschliessend eine Test-Methode implementiert. Diese Methoden sind mit @Test zu annotieren, so werden sie anschliessend vom Test-Framework als eigenständiger Test erkannt und ausgeführt. Ein Unit-Test kann beliebig viele Testmethoden enthalten. Grundsätzlich reichen aber je nach Funktionalität ein paar wenige Tests aus, um die ganze Funktionalität einer Methode zu überprüfen. Innerhalb der Test-Methoden implementieren wir dann “normalen” Programmcode, welcher den Code aus dem UUT “überprüft”. In unserem Beispiel setzen wir zwei Variablen und rufen damit die zu testende Methode auf. Mit einer Assertion vergleichen wir dann einen erwarteten Wert mit dem von der Methode zurückgelieferten Resultat. Beachte, dass der erwartete Wert in der Assertion immer an erster Stelle stehen muss. Wenn die beiden Werte identisch sind, dann ist der Unit-Test erfolgreich.\nVorgehen beim Schreiben von Unit-Tests Grundsätzlich sollte die AAA-Methode angewendet werden, sie ist auch im Beispiel oben ersichtlich. AAA steht für “Arrange”, “Act” und “Assert”. “Arrange” steht dabei für die Vorbereitung des Tests, “Act” ist die eigentliche Durchführung und mit “Assert” werden die Resultate des Tests überprüft.\nGrenzwerte austesten Vielfach sind gewisse Funktionen in einer Applikation so implementiert, dass sie sich mit wenigen Unit-Tests komplett testen lassen. Dazu ein kleines Beispiel: gegeben ist ein Rechteck mit bestimmten Koordinaten (Ecke oben links) und einer bestimmten Grösse (Höhe und Breite).\nEine Methode innerhalb des Rechtecks dient dazu herauszufinden, ob eine bestimmte Koordinate inner- oder ausserhalb des Rechtecks liegt. Punkte, die auf dem Rand zu liegen kommen gelten in diesem Sinne nicht als innerhalb des Rechtecks.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package ch.sbb.talentfactory.rectangle; public class Rectangle { private int top; private int left; private int width; private int height; public Rectangle(int top, int left, int width, int height) { this.top = top; this.left = left; this.width = width; this.height= height; } public boolean isInside(int x, int y) { if (x \u003e left \u0026\u0026 x \u003c left + width) { if (y \u003e top \u0026\u0026 y \u003c top + height) { return true; } } return false; } } Damit keine Verwirrung entsteht, hier das verwendete Koordinatensystem. Wie wir in der Implementation sehen können, gibt es hier vier verschiedene Bedingungen. Das Ziel des Tests muss es also sein, dass wir alle diese Bedingungen überprüfen. Wenn immer möglich, sollten alle möglichen Kombinationen getestet werden. Nur so kann sichergestellt werden, dass die Methode wie gewünscht funktioniert. Aufgrund der AND-Verknüpfung werden die zweiten Bedingungen der jeweiligen Statements nicht mehr ausgewertet. Damit müssen die folgenden Kombinationen durch einen Unit-Test abgedeckt werden\nBedingung x \u003e left x \u003c left + width y \u003e top y \u003c top + height Resultat Variante 1 False False Variante 2 True False False Variante 3 True True False False Variante 4 True True True False False Variante 5 True True True True True Dies bedeutet wir implementieren fünf Unit-Tests, um die Methode vollständig abzudecken.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package ch.sbb.talentfactory.rectangle; import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; public class RectangleTest { // I know this is a square ;-) private Rectangle uut = new Rectangle(0, 0, 10, 10); @Test void givenPointLeftOfRectangle_whenIsInsideCheck_thenReturnsFalse() { assertFalse(this.uut.isInside(-1, 5)); } @Test void givenPointRightOfRectangle_whenIsInsideCheck_thenReturnsFalse() { assertFalse(this.uut.isInside(11, 5)); } @Test void givenPointAboveRectangle_whenIsInsideCheck_thenReturnsFalse() { assertFalse(this.uut.isInside(5, -1)); } @Test void givenPointBelowRectangle_whenIsInsideCheck_thenReturnsFalse() { assertFalse(this.uut.isInside(5, 11)); } @Test void givenPointInsideRectangle_whenIsInsideCheck_thenReturnsTrue() { assertTrue(this.uut.isInside(5, 5)); } } Im IntelliJ gibt es wie bei der Ausführung einer Applikation auch die Möglichkeit einen Unit-Test zu debuggen. Zusätzlich können wir die Testabdeckung anschauen, wenn wir den Unit-Test mit “Coverage” durchlaufen lassen. Wenn der Test erfolgreich durchgelaufen ist, dann kann die getestete Klasse geöffnet werden.\nDie grünen Balken auf der linken Seite zeigen die Testabdeckung an. In diesem Fall sind sämtliche Zeilen durch einen Test durchlaufen worden.\nDa der Unit-Test nun alle Möglichkeiten der Methode abdeckt, kann ein einfaches Refactoring durchgeführt werden. In unserem Fall kann die Methode wie folgt vereinfacht werden:\n1 2 3 public boolean isInside(int x, int y) { return x \u003e left \u0026\u0026 x \u0026lt; left + width \u0026\u0026 y \u0026gt; top \u0026\u0026 y \u003c top + height; } Der Test kann dann beliebig oft erneut durchgeführt werden, um das Refactoring zu überprüfen.\nAnnotationen von JUnit5 Die folgende Tabelle zeigt eine Übersicht über die wichtigsten Annotationen von JUnit 5. Mehr Informationen zu den jeweiligen Annotationen finden sich in den nächsten Kapiteln.\nAnnotation Beschreibung @Test Bezeichnet einen Test @ParameterizedTest Bezeichnet einen parametrisierten Test @RepeatedTest Bezeichnet einen sich wiederholenden Test @DisplayName Namensgebung für Testklassen und -methoden @Disabled Möglichkeit eine Testklasse oder -methode nicht ausführen zu lassen @TestMethodOrder\n@Order Ausführungsreihenfolge der Tests bestimmen. @BeforeAll\n@BeforeEach\n@AfterAll\n@AfterEach Initialiserungen und Aufräumarbeiten vor und nach Unit-Tests Parametrisierte Unit-Tests Der oben gezeigte Unit-Test ist ein typisches Beispiel für einen Test, der mit vielen unterschiedlichen Parametern durchlaufen werden sollte. Wenn wir den Test parametrisieren, können wir die Test-Methode wiederverwenden.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package ch.sbb.talentfactory.rectangle; import org.junit.jupiter.params.ParameterizedTest; import org.junit.jupiter.params.provider.CsvSource; import static org.junit.jupiter.api.Assertions.assertEquals; public class RectangleTest { private Rectangle uut = new Rectangle(0, 0, 10, 10); @ParameterizedTest @CsvSource({ \"-1, 5, false\", \"11, 5, false\", \"5, -1, false\", \"5, 11, false\", \"5, 5, true\" }) void givenPoint_whenIsInside_thenReturnsExpectedResult(int x, int y, boolean expectedResult) { assertEquals(expectedResult, this.uut.isInside(x, y)); } } Mit @CsvSource können mehrere Parameter mit Komma getrennt angegeben werden. Die Anzahl (im Beispiel 3) muss mit den Parameter der Testklasse übereinstimmen.\nEin simpleres Beispiel ist hier zu sehen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package ch.sbb.talentfactory.calculator; import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; public class CalculatorTest { private Calculator uut = new Calculator(); @ParameterizedTest @ValueSource(ints = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }) public void givenOperand_whenAddFive_thenSumIsCorrect(int operand1) { // call method int result = this.uut.add(operand1, 5); // verify assertEquals(operand1 + 5, result); } } Der gezeigte Test wird so insgesamt neun Mal durchlaufen, wobei der Parameter operand1 jeweils die Werte des angegebenen Arrays durchläuft.\nWiederholende Unit-Tests Unit-Tests können mehrmals hintereinander ausgeführt werden, dabei wird die annotierte Test-Methode einfach mehrfach aufgerufen. Die Anzahl Aufrufe wird durch den Parameter in der Annotation bestimmt.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package ch.sbb.talentfactory.calculator; import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; public class CalculatorTest { private Calculator uut = new Calculator(); @RepeatedTest(10) public void givenRandomIntegers_whenAdd_thenSumIsCorrect() { // prepare test data Random random = new Random(); int i1 = random.nextInt(100); int i2 = random.nextInt(100); // call method int result = this.uut.add(i1, i2); // verify assertEquals(i1 + i2, result); } } Repetierende Tests können wie oben gezeigt benutzt werden, um beispielsweise mit generierten Zufallszahlen bestimmte Funktionen zu überprüfen.\nDisplay Names Testklassen und -methoden können mit der Annotation @DisplayName beliebig umbenannt werden.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package ch.sbb.talentfactory.calculator; import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; @DisplayName(\"Special test for calculator\") public class CalculatorTest { private Calculator uut = new Calculator(); @Test @DisplayName(\"Ultimate addition test\") public void givenTwoIntegers_whenAdd_thenSumIsCorrect() { // prepare test data int i1 = 5; int i2 = 9; // call method int result = this.uut.add(i1, i2); // verify assertEquals(14, result); } } Der angegebene Name erscheint dann in der Testauswertung.\nTests ausschalten Testklassen und -methoden können mit der Annotation @Disabled aus den Testläufen ausgeschlossen werden.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package ch.sbb.talentfactory.calculator; import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; @Disabled(\"Test disabled until calculator is finished\") public class CalculatorTest { private Calculator uut = new Calculator(); @Test public void givenTwoIntegers_whenAdd_thenSumIsCorrect() { // prepare test data int i1 = 5; int i2 = 9; // call method int result = this.uut.add(i1, i2); // verify assertEquals(14, result); } } Reihenfolge der Ausführung Die Reihenfolge von Tests bei der Ausführung kann durch die Verwendung von @TestMethodOrder und @Order bestimmt werden.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 package ch.sbb.talentfactory.calculator; import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; @TestMethodOrder(OrderAnnotation.class) public class CalculatorTest { private Calculator uut = new Calculator(); @Test @Order(1) public void givenTwoIntegers_whenAdd_thenSumIsCorrect() { // prepare test data int i1 = 5; int i2 = 9; // call method int result = this.uut.add(i1, i2); // verify assertEquals(14, result); } @Test @Order(2) public void givenTwoIntegersWithNegative_whenAdd_thenSumIsCorrect() { // prepare test data int i1 = -1; int i2 = 3; // call method int result = this.uut.add(i1, i2); // verify assertEquals(2, result); } } Die Annotation @Order wird nur verwendet, wenn der Typ der Ausführung OrderAnnation.class ist. Weitere Angaben sind “Alphanumeric” (Sortierung nach Methodenname) und “Random” (Zufällige Ausführungsreihenfolge).\nDaten initialisieren / aufräumen Mit den Annotationen @BeforeEach, @AfterEach, @BeforeAll und @AfterAll können bestimmte Initialisierungen und Aufräumarbeiten vor und nach Unit-Tests ausgeführt werden.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 package ch.sbb.talentfactory.calculator; import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; public class CalculatorTest { private Calculator uut = new Calculator(); @BeforeAll public static void setUpAll() { // Diese Methode wird VOR allen Test-Methoden EINMALIG ausgeführt } @BeforeEach public void setUp() { // Diese Methode wird VOR jeder Test-Methode ERNEUT ausgeführt } @Test public void givenTwoIntegers_whenAdd_thenSumIsCorrect() { // prepare test data int i1 = 5; int i2 = 9; // call method int result = this.uut.add(i1, i2); // verify assertEquals(14, result); } @AfterEach public void tearDown() { // Diese Methode wird NACH jeder Test-Methode ERNEUT ausgeführt } @AfterAll public static void tearDownAll() { // Diese Methode wird NACH allen Test-Methoden einmalig ausgeführt } } Verwendung von Providern Bei der Verwendung von parametrisierten Tests ist es möglich, dem Unit-Test über einen Stream von Argumenten entsprechende Testdaten oder Instanzen von verschiedenen Objekten zukommen zu lassen. Das folgende Beispiel illustriert die Verwendung eines solchen Providers.\nVier Gewinnt Interface\n1 2 3 public interface ConnectFourCheck { String checkWin(String[][] board); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class VierGewinntTest { private String[][] testBoard = { {\" \", \" \", \" \", \" \", \"O\"}, {\" \", \" \", \" \", \"O\", \"X\"}, {\" \", \" \", \" \", \"O\", \"X\"}, {\" \", \" \", \"O\", \"X\", \"X\"}, {\" \", \" \", \" \", \" \", \"X\"} }; // Alle Klassen des Streams (VierGewinntSolution1 und VierGewinntSolution2) implementieren das oben gezeigte Interface private static Stream\u003cArguments\u003e instances() { return Stream.of( Arguments.of(new VierGewinntSolution1()), Arguments.of(new VierGewinntSolution2()) ); } @ParameterizedTest @MethodSource(\"instances\") public void givenBoardWithWinningX_whenCheckWin_thenReturnsX(ConnectFourCheck cfc) { try { String winner = cfc.checkWin(this.testBoard); assertEquals(\"X\", winner); } catch (Exception e) { fail(e); } } } Mit einem solchen Provider kann derselbe Unit-Test für verschiedene Implementation (zum Beispiel eines Interfaces) wiederverwendet werden.\nMockito Mockito ist ein Framework zum Erstellen und Benutzen von Mocks in Softwaretests. Es bietet die Möglichkeit, Verhalten von noch nicht implementierten Klassen und Methoden rudimentär zu simulieren, um so das zu testende System (trotz fehlender Teile) testen zu können. Mockito ermöglicht auch andere Systeme/Services zu simulieren, welche z.B. von einem anderen Team entwickelt werden wie auch solche, deren echtes Verhalten zum Testzweck nicht interessiert oder sogar nicht erwünscht ist (man will aber z.B. wissen, dass diese Systeme/Services vom getesteten Code angesprochen worden sind).\nMockito kann in Unit-Tests wie auch in Integrations-Tests verwendet werden.\nWo kann ich das Framework herunterladen? Wie bei JUnit, werden auch für die Arbeit mit Mockito die Bibliotheken davon benötigt.\nAbhängigkeiten einbinden ohne Maven Dieser Abschnitt kann übersprungen werden, wenn mit einem Maven-Projekt gearbeitet wird. Das letzte Release (aktuell 5.3.1) kann hier heruntergeladen werden: Mockito Core 5.3.1 Jar-Datei\nDie Heruntergeladene Jar-Datei kann nun genau wie die JUnit-Jar-Dateien eingebunden werden.\nAbhängigkeiten einbinden mit Maven Dieser Abschnitt kann übersprungen werden, wenn es sich nicht um ein Maven Projekt handelt.\nDie entsprechende Abhängigkeit für das Project Object Model (pom.xml) ist:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mockito\u003c/groupId\u003e \u003cartifactId\u003emockito-core\u003c/artifactId\u003e \u003cversion\u003e5.3.1\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mockito\u003c/groupId\u003e \u003cartifactId\u003emockito-junit-jupiter\u003c/artifactId\u003e \u003cversion\u003e5.3.1\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e Mockito Begriffe Mock Mocks sind ein vollständiger Ersatz für Objekte, Services usw., von denen der zu testende Code abhängt, um seine Kernlogik zu testen. Ein Mock kann so programmiert werden, dass es eine angegebene Ausgabe zurückgibt, wenn eine Methode des Mocks aufgerufen wird.\nMockito bietet eine Standardimplementierung für alle Methoden eines Mocks. Das bedeutet, dass beim Aufrufen einer Methode eines Mocks, nicht der “echte” Code der Methode aufgerufen wird, sondern es wird ein von Mockito vordefinierter Wert zurückgeliefert (abhängig vom Rückgabewert-Typ der Methode).\nEs gibt Situationen, in denen es nützlich sein kann, bestimmte Werte aus einer Methode zurückzuliefern statt die Mockito-Standardwerte. In diesen Situationen kann ein gewünschter Rückgabewert vorkonfiguriert werden, so dass beim Aufruf der Methode, dieser Wert zurückgeliefert wird.\nSpy Ein Spy (‘Spion’) ist im Wesentlichen ein Wrapper für eine “echte” Instanz eines gemockten Objekts. Dies bedeutet, dass eine neue Instanz des Objektes erforderlich ist und dann ein Spy darüber hinzugefügt wird.\nStandardmässig leiten Spies Methodenaufrufe an die “echten” Methoden des Objekts weiter. Das ist auch der Hauptunterschied zwischen Spies und Mocks. Letztere überschreiben den “echten” Methoden-Code.\nSpies bieten aber auch die Möglichkeit, bestimmte Methoden als Mock-Methoden vorzukonfigurieren. In solchen Fällen, wird der Methodenaufruf nicht auf den “echten” Code weitergeleitet, sondern es wird, wie beim Mock, der vorgegebene Rückgabewert zurückgeliefert.\nMockito Annotationen Damit die Mockito-Annotationen innerhalb eines JUnit-Tests verwendet werden könnten, müssen sie zuerst eingeschaltet werden. Eine Möglichkeit dies zu tun ist, die Unit-Test-Klasse mit @ExtendWith zu annotieren und als Parameter den Wert MockitoExtension.class anzugeben:\n1 2 3 4 @ExtendWith(MockitoExtension.class) public class MyUnitTest { //TODO write tests } Die folgende Tabelle zeigt eine Übersicht über die wichtigsten Annotationen von Mockito:\nAnnotation Beschreibung @Mock Mock-Objekte erzeugen lassen @InjectMock Markiert ein Feld, welches mit Mocks initiiert wird @Spy Spy-Objekte erzeugen lassen @Captor ArgumentCaptor Objekte erzeugen lassen Wie diese Annotationen verwendet werden, wird in den folgenden Kapiteln gezeigt.\n@Mock Annotation Diese Annotation wird dazu verwendet, um Mock-Objekte komplett von Mockito erzeugen zu lassen. Das heisst, die gesamte Mock-Funktionalität wird von Mockito zur Verfügung gestellt.\n1 2 3 4 5 6 7 8 9 10 11 12 13 @ExtendWith(MockitoExtension.class) public class MyUnitTest { @Mock private List\u003cString\u003e mockedList; // hier wird eine Liste von Strings gemockt. // Mockito stellt eine rudimentäre Umsetzung für JEDE Methode der Liste zur Verfügung @Test public void givenMockedList_whenAddElement_thenSizeRemainsZero() { mockedList.add(\"one\"); assertEquals(0, mockedList.size()); } } Was mit einem Mock gemacht werden kann und wie der Mock vorkonfiguriert werden kann, wird in einem späteren Kapitel erklärt.\n@InjectMocks Annotation Wenn eine Klasse ein Objekt-Feld beinhaltet, kann Mockito dieses Feld mit einem Mock initiieren. Damit es funktioniert, muss das Feld entweder via Konstruktor, via Setter oder via Property-Injection initialisiert werden.\nIm folgenden Beispiel, hat die Klasse MyService ein Feld vom Typ DataService, welches mittels Konstruktor initialisiert werden kann:\n1 2 3 4 5 6 7 8 9 10 11 12 13 import java.util.List; public class MyService { private final DataService dataService; public MyService(DataService dataService) { this.dataService = dataService; } public int processData(List\u003cInteger\u003e numbers) { return dataService.sum(numbers); } } 1 2 3 4 5 import java.util.List; public interface DataService { int sum(List\u003cInteger\u003e numbers); } Im Test, wird ein Mock für ein DataService erstellt und mit der Annotation @InjectMocks, via Konstruktor-Initialisierung in dem MyService-Objekt injektiert (der Konstruktor muss also nicht noch dazu aufgerufen werden):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import org.junit.jupiter.api.Test; import org.junit.jupiter.api.extension.ExtendWith; import org.mockito.InjectMocks; import org.mockito.Mock; import org.mockito.junit.jupiter.MockitoExtension; import java.util.Arrays; import java.util.List; import static org.junit.jupiter.api.Assertions.assertEquals; @ExtendWith(MockitoExtension.class) public class MyServiceTest { @Mock private DataService dataService; // hier wird ein DataService gemockt. @InjectMocks private MyService myService; // der Mock von DataService wird in die MyService-Instanz \"injiziiert\", das heisst // überall im DataService-Objekt, wo der DataService verwendet wird, wird der Mock zum Zug kommen! @Test public void givenListOfNumbers_whenProcessData_thenReturnsSum() { List\u003cInteger\u003e numbers = Arrays.asList(1, 2, 3, 4, 5); Mockito.when(dataService.sum(numbers)).thenReturn(15); int result = myService.processData(numbers); assertEquals(15, result); } } @Spy Annotation Ein Spy wird auf einem “echten” Objekt erzeugt. Dieser Spy leitet, sofern nichts anderes konfiguriert wurde, alle Methodenaufrufe an das echte Objekt weiter. Mit Hilfe der Mockito-Methoden, kann jedoch definiert werden, dass bestimmte Methoden “umgeleitet” werden und eine andere Umsetzung dafür angewendet wird.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import org.junit.jupiter.api.Test; import org.junit.jupiter.api.extension.ExtendWith; import org.mockito.*; import org.mockito.junit.jupiter.MockitoExtension; import java.util.List; import static org.junit.jupiter.api.Assertions.assertEquals; @ExtendWith(MockitoExtension.class) public class MyUnitTest { @Spy private List\u003cString\u003e spiedList; // Ein Spy über eine Liste. Wenn nichts anders konfiguriert wird // werden die \"echte\" Listen-Methoden aufgerufen, wenn der Spy verwendet wird. @Captor private ArgumentCaptor\u003cString\u003e stringCaptor; // stringCaptor wird ein Argument vom Typ String \"fangen\" @Test public void givenSpiedList_whenAddElement_thenCaptorCapturesValue() { spiedList.add(\"one\"); Mockito.verify(spiedList).add(stringCaptor.capture()); // während der Prüfung wird das Argument // für die Methode add() gefangen // und im stringCaptor aufbewahrt assertEquals(\"one\", stringCaptor.getValue()); // mit getValue() kann das gefangene Argument inspiziert werden } } ⚠️ ACHTUNG ⚠️\nFür Stubbing in @Spy muss immer die Notation Mockito.doReturn().when().size(); verwendet werden. Mit Mockito.when().thenReturn() wird es nicht funktionieren. Grund dafür ist, dass wenn Mockito.doReturn().when().size(); verwendet wird, in jedem Fall das gegebene Return durchgeführt wird. Wenn bei Mockito.when().thenReturn() zum Beispiel eine Exception auftritt, wird nicht das richtige Resultat zurück gegeben.\nWie ein Spy verwendet werden kann, um nur einige Methoden umzuleiten, wird in einem späteren Kapitel erklärt.\n@Captor Annotation Ein ArgumentCaptor kann Argumente einer Methode “fangen” damit diese danach inspiziert werden könnten.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import org.junit.jupiter.api.Test; import org.junit.jupiter.api.extension.ExtendWith; import org.mockito.ArgumentCaptor; import org.mockito.*; import org.mockito.junit.jupiter.MockitoExtension; import java.util.List; import static org.junit.jupiter.api.Assertions.assertEquals; @ExtendWith(MockitoExtension.class) public class MyUnitTest { @Mock private List\u003cString\u003e mockedList; @Captor private ArgumentCaptor\u003cString\u003e stringCaptor; // stringCaptor wird ein Argument vom Typ String \"fangen\" @Test public void givenMockedList_whenAddElement_thenCaptorCapturesValue() { mockedList.add(\"one\"); Mockito.verify(mockedList).add(stringCaptor.capture()); // während der Prüfung wird das Argument // für die Methode add() gefangen // und im stringCaptor aufbewahrt assertEquals(\"one\", stringCaptor.getValue()); // mit getValue() kann das gefangene Argument inspiziert werden } } Mockito statische Methoden Mockito stellt mehrere statische Methoden zur Verfügung, welche das Konfigurieren von Mocks und Spies wie auch deren Überwachung ermöglichen. In diesem Kapitel werden die wichtigsten Methoden anhand von Beispielen erklärt.\nMockito.when kombiniert mit Mockito.thenReturn Die Mockito.when Methode kombiniert mit der Methode Mockito.thenReturn ermöglicht es, die Standardimplementierung einer Methode für ein gegebenen Mock zu überschreiben. Dasselbe kann auch mit der Kombination Mockito.doReturn und danach when erreicht werden.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @ExtendWith(MockitoExtension.class) public class MyUnitTest { @Mock private List\u003cString\u003e mockedList; // eine Mock-Liste, mit Mockitos-Standardimplementierung für alle Methoden @Test public void givenMockedList_whenSizeIsOverridden_thenReturnsConfiguredValues() { assertEquals(0, mockedList.size()); // die Mockito-Standardimplementierung für \"size()\" // liefert immer 0 zurück Mockito.when(mockedList.size()).thenReturn(10); // hier wird die Standardimplementierung der Methode // size() auf dem Mock-Objekt überschrieben, // sodass immer der Wert 10 zurückgeliefert wird. assertEquals(10, mockedList.size()); Mockito.doReturn(20).when(mockedList).size(); // auch hier wird die Standardimplementierung der Methode // size() auf dem Mock-Objekt überschrieben, // diesmal mit dem Wert 20. assertEquals(20, mockedList.size()); } } Mockito.verify Die Mockito.verify Methode prüft, ob eine Interaktion mit dem Mock/Spy-Objekt stattgefunden hat. Geprüft werden kann unter anderem folgendes (weitere Prüfungen werden hier anhand von Beispielen erklärt):\nEs gab keine Interaktion mit dem Mock/Spy Es gab eine Interaktion mit dem Mock/Spy Es gab eine gewisse Anzahl an Interaktionen mit dem Mock/Spy Es gab mindestens eine gewisse Anzahl an Interaktionen mit dem Mock/Spy Es gab nicht mehr als eine gewisse Anzahl an Interaktionen mit dem Mock/Spy Interaktion in diesem Sinn kann entweder eine Interaktion mit dem Objekt oder mit einer seiner Methoden sein.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 import org.junit.jupiter.api.Test; import org.junit.jupiter.api.extension.ExtendWith; import org.mockito.*; import org.mockito.junit.jupiter.MockitoExtension; import java.util.List; import static org.mockito.Mockito.*; @ExtendWith(MockitoExtension.class) public class MyUnitTest { @Mock private List\u003cString\u003e mockedList; // eine Mock-Liste, mit Mockitos-Standardimplementierung für alle Methoden @Spy private List\u003cString\u003e spiedList; // ein Spy über eine Liste. @Test public void givenSpiedList_whenAddAndClear_thenVerifyInteractions() { spiedList.add(\"one\"); // hier wird die \"echte\" add Methode einer Liste aufgerufen! verify(spiedList).add(\"one\"); // prüfe, ob die \"add\" Methode mit dem Parameter \"one\" auf dem spyList aufgerufen wurde verify(spiedList, never()).size(); // prüfe, ob die size() Methode nie aufgerufen wurde spiedList.clear(); spiedList.clear(); verify(spiedList, times(2)).clear(); // prüfe, ob die clear() Methode genau 2 Mal aufgerufen wurde } @Test public void givenMockedList_whenSizeCalled_thenVerifyInteractionCount() { Mockito.verifyNoInteractions(mockedList); // bis hier gab es keine Interaktionen mit dem mockedList Objekt mockedList.size(); mockedList.size(); mockedList.size(); mockedList.size(); verify(mockedList, atLeast(1)).size(); // prüfe, ob die size() Methode mindestens einmal aufgerufen wurde verify(mockedList, atMost(5)).size(); // prüfe, ob die size() Methode nicht mehr als 5 Mal aufgerufen wurde } } Test Driven Development (TDD) Test Driven Development (TDD) (Testgetriebene Entwicklung) ist ein Softwareentwicklungsansatz, bei dem ein Test geschrieben wird, bevor der Code geschrieben wird. Sobald der neue Code den Test besteht, wird er auf einen akzeptablen Standard umgestellt.\nTDD stellt sicher, dass der Quellcode gründlich getestet wird und zu modularisiertem, flexiblem und erweiterbarem Code führt. Es konzentriert sich darauf, nur den Code zu schreiben, der notwendig ist, um Tests zu bestehen, wodurch das Design einfach und klar wird.\nMit TDD kann der Programmierer beim Schreiben von Software kleine Schritte unternehmen.\nDer Test wird vor dem Testen der Funktionalität geschrieben und stellt sicher, dass die Anwendung für die Testbarkeit geeignet ist, erst danach wird die Funktionalität implementiert. Dies wird als „Rot-Grün-Refaktor“ bezeichnet, wobei Rot bedeutet, fehlgeschlagen zu sein, und Grün zeigt einen erfolgreichen Durchlauf an. Diese Schritte werden dann wiederholt.\nSchritte eines test gesteuerten Entwicklungszyklus Der test-gesteuerte Entwicklungszyklus besteht aus folgenden, sich immer wiederholenden, Schritten:\nHinzufügen eines Tests, der fehlschlägt: Jedes neue Feature in TDD beginnt mit einem Test, der nach seiner Implementation fehlschlagen muss, bevor die Features implementiert werden. Code schreiben und damit den Test “begrünen”: Es wird nur soviel Code geschrieben, wie zum “Begrünen” des Tests nötig ist - nicht mehr! (alle bisherigen Tests müssen weiterhin erfolgreich durchlaufen!!) Code verbessern, ohne dabei die Funktionalität zu verändern (Refactor): Code bereinigen (z.B. das Entfernen von Duplikaten, kleinere Methoden usw.) und auf “Clean Code” Standard bringen TDD Walkthrough In diesem Walkthrough wird der TDD Entwicklungszyklus anhand eines Beispiels erläutert.\nIn diesem Beispiel geht es darum eine Klasse zu schreiben, welche ein Tier modelliert. Das Tier soll uns informieren, ob es Hunger hat oder nicht.\nSchritt 1: Grundgerüst erstellen Es wird nur die Klasse erstellt, welche dann getestet werden soll:\n1 2 public class Animal { } Schritt 2: Fehlschlagender Test schreiben 1 2 3 4 5 6 7 public class AnimalTest { @Test public void newAnimal_isHungry_returnTrue() { Animal myAnimal = new Animal(); assertTrue(myAnimal.isHungry()); } } Zu diesem Zeitpunkt existiert die Methode “isHungry” nicht (Kompilierfehler) und natürlich gibt sie kein “true” zurück. Im nächsten Schritt wird die Methode hinzugefügt und der Test “begrünt”.\nSchritt 3: Test “begrünen” 1 2 3 4 5 public class Animal { public boolean isHungry() { return true; } } Der Test, welcher vorher geschrieben wurde, kompiliert nun und kann erfolgreich durchlaufen werden. Somit ist dieser Zyklus beendet (es gibt noch nichts, was refactored werden soll)\nSchritt 4: Neuer, fehlschlagender Test schreiben 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class AnimalTest { @Test // Dieser Test ist nun grün... public void newAnimal_isHungry_returnTrue() { Animal myAnimal = new Animal(); assertTrue(myAnimal.isHungry()); } @Test public void animalAte_isHungry_returnFalse() { Animal myAnimal = new Animal(); animal.eat(); // Kompilierfehler, da es diese Methode noch nicht gibt assertFalse(myAnimal.isHungry()); } } Schritt 5: zweiter Test “begrünen”, ohne den ersten Test “kaputt” zu machen In diesem Schritt finden wir heraus, dass wir einen Hunger-Zustand für unser Tier haben müssen, welcher sich ändert, wenn das Tier gefressen hat:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Animal { private boolean isHungry = true; // müssen wir hier so setzen, damit der erste Test noch funktioniert! public boolean isHungry() { if (isHungry) { return true; } else { return false; } } public void eat() { isHungry = false; } } Nach diesem Schritt kompiliert der Test wieder erfolgreich und beide Tests werden erfolgreich durchlaufen.\nSchritt 6: Refactor Unser Code kann nun eleganter geschrieben werden, ohne dabei die Funktionalität zu ändern:\n1 2 3 4 5 6 7 8 9 10 11 public class Animal { private boolean isHungry = true; public boolean isHungry() { return isHungry; // if-else ersetzt, da nicht nötig } public void eat() { isHungry = false; } } Somit ist auch dieser Zyklus beendet.\nDer code wird so stetig weiterentwickelt und neue Funktionalitäten werden auf diese Weise Schritt für Schritt und getestet hinzugefügt. Dabei werden die bereits bestehenden Funktionalitäten durch die bisherigen Tests vor ungewollten Änderungen geschützt.\nJetzt bist du dran. Löse bitte die Aufgaben in den Labs.\n","categories":"","description":"Modul #J4\n","excerpt":"Modul #J4\n","ref":"/de/docs/02_java/08_java-testing/","tags":"","title":"Testing"},{"body":"Ziele Du weisst, was ein Directive ist und wozu diese verwendet wird. Du kennst die drei Arten von Directives und kannst diese beschrieben. Du kannst ngIf, ngFor, ngSwitch und ngClass anwenden und erklären. Directives Directives sind ein Mechanismus, um die Darstellung von HTML-Elementen und das Verhalten von Components zu manipulieren. Directives ermöglichen es, benutzerdefinierte HTML-Attribute oder -Elemente zu definieren, die spezielle Funktionalitäten bereitstellen, die standardmässig nicht in HTML verfügbar sind.\nEs gibt drei Arten von Directives in Angular:\nComponents-Directives Components-Directives sind die am häufigsten verwendeten Directives in Angular. Sie erweitern das HTML durch die Definition von benutzerdefinierten HTML-Elementen und enthalten zugehörige Templates und Logik. Components-Direktiven sind im Wesentlichen Angular-Components.\n1 2 \u003c!--app-greeting.html--\u003e \u003capp-triumphs [title]=\"'Triumphs'\"\u003e\u003c/app-triumphs\u003e 1 2 3 4 5 6 7 8 import { Component, Input } from \"@angular/core\"; @Component({ // .. }) export class TriumphsComponent { @Input() title: string = \"\"; } 1 2 \u003c!--app-triumphs.html--\u003e \u003ch1\u003e{{ title }}\u003c/h1\u003e Struktur-Directives Struktur-Directives sind Directives, die das DOM manipulieren und Elemente hinzufügen oder entfernen. Ein Beispiel für eine Struktur-Directive ist *ngIf, das ein Element ausblendet, wenn eine Bedingung nicht erfüllt ist.\n1 2 \u003c!--app-greeting.html--\u003e \u003capp-triumphs *ngif=\"hasTriumphs\" [title]=\"'Triumphs'\"\u003e\u003c/app-triumphs\u003e 1 2 3 4 5 6 7 8 9 10 import { Component } from \"@angular/core\"; @Component({ // .. }) export class GreetingComponent { // .. triumphs: string[] = [\"HTML\", \"CSS\", \"JavaScript\", \"TypeScript\"]; hasTriumphs: boolean = this.triumphs.length \u003e 0; } *ngIf Die *ngIf-Direktive wird verwendet, um im Template eines Components Bedingungen zu überprüfen und den darin enthaltenen HTML-Code nur dann anzuzeigen, wenn die Bedingung erfüllt ist. Wenn die Bedingung nicht erfüllt ist, wird der entsprechende HTML-Code aus der gerenderten View entfernt.\nDie Verwendung von *ngIf ermöglicht es, dynamisch Elemente in der View zu steuern.\n1 2 \u003c!--app-greeting.html--\u003e \u003capp-triumphs *ngif=\"hasTriumphs\" [title]=\"'Triumphs'\"\u003e\u003c/app-triumphs\u003e 1 2 3 4 5 6 7 8 9 10 import { Component } from \"@angular/core\"; @Component({ // .. }) export class GreetingComponent { // .. triumphs: string[] = [\"HTML\", \"CSS\", \"JavaScript\", \"TypeScript\"]; hasTriumphs: boolean = this.triumphs.length \u003e 0; } *ngFor Die *ngFor-Direktive wird verwendet, um eine Liste von Elementen im Template eines Components zu rendern. Mit *ngFor kann man über eine Datenquelle iterieren und für jedes Element den entsprechenden Code im Template generieren. Das ist besonders nützlich, wenn man Kacheln anzeigen möchte oder eine Liste mit User Objekten anzeigen möchte.\n1 2 3 4 5 6 \u003c!--app-greeting.html--\u003e \u003capp-triumphs *ngIf=\"hasTriumphs\" [title]=\"'Triumphs'\" [triumphs]=\"triumphs\" \u003e\u003c/app-triumphs\u003e 1 2 3 4 5 6 7 8 9 10 import { Component } from \"@angular/core\"; @Component({ // .. }) export class GreetingComponent { // .. triumphs: string[] = [\"HTML\", \"CSS\", \"JavaScript\", \"TypeScript\"]; hasTriumphs: boolean = this.triumphs.length \u003e 0; } 1 2 3 4 \u003c!--app-triumphs.html--\u003e \u003cdiv *ngFor=\"let triumph of triumphs\"\u003e \u003cp\u003e{{ triumph }}\u003c/p\u003e \u003c/div\u003e 1 2 3 4 5 6 7 8 9 import { Component, Input } from \"@angular/core\"; @Component({ // .. }) export class TriumphsComponent { @Input() title: string = \"\"; @Input() triumphs: string[] = []; } Wenn man den Index bei einem *ngFor benötigt, kann dieser sehr einfach angegeben werden. Dazu muss man nach dem *ngFor den Code ; let i = index hinzufügen. Nun kann man in den Elementen innerhalb des *ngFor auf den Index der Elemente zu greifen. Der Index ist insofern relevant, dass man einzelne Elemente anhand dessen identifizieren kann, zudem ist direkt ersichtlich, welchen Index das gerenderte Element innehat.\n1 2 3 \u003cdiv *ngFor=\"let triumph of triumphs; let i = index\"\u003e \u003cp\u003e{{ triumph }}, {{ i }}\u003c/p\u003e \u003c/div\u003e *ngSwitch Das ngSwitch-Directive ermöglicht das bedingte Rendern von Inhalten auf der Grundlage eines Ausdrucks mit mehreren möglichen Werten. Es funktioniert ähnlich wie ein switch-Statement in anderen Programmiersprachen.\n1 2 3 4 5 6 7 8 import { Component } from \"@angular/core\"; @Component({ // .. }) export class WeaponComponent { weapons: string[] = [\"Sword\"]; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u003cdiv [ngSwitch]=\"weapons\"\u003e \u003cdiv *ngSwitchCase=\"'Sword'\"\u003e \u003cp\u003eYou are wielding a mighty sword!\u003c/p\u003e \u003cp\u003eDefeat your enemies with precision and power.\u003c/p\u003e \u003c/div\u003e \u003cdiv *ngSwitchCase=\"'Bow'\"\u003e \u003cp\u003eYou have a deadly bow and arrows!\u003c/p\u003e \u003cp\u003eStrike your foes from a distance with accuracy.\u003c/p\u003e \u003c/div\u003e \u003cdiv *ngSwitchCase=\"'Staff'\"\u003e \u003cp\u003eYour staff is a conduit of mystical energy!\u003c/p\u003e \u003cp\u003eHarness the power of magic to overcome your adversaries.\u003c/p\u003e \u003c/div\u003e \u003cdiv *ngSwitchDefault\u003e \u003cp\u003eYou have not chosen a weapon yet.\u003c/p\u003e \u003cp\u003eFind your destined weapon and embark on your epic journey.\u003c/p\u003e \u003c/div\u003e \u003c/div\u003e Attribut-Directives Attribut-Directives sind Directives, die das Verhalten von HTML-Elementen ändern, ohne sie zu ersetzen. Ein Beispiel für eine Attribut-Direktive ist ngClass, welche es ermöglicht, CSS-Klassen basierend auf Bedingungen hinzuzufügen oder zu entfernen.\n1 \u003ch1 appTriumphs\u003e{{ title }}\u003c/h1\u003e 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import { Directive, ElementRef, Renderer2 } from \"@angular/core\"; @Directive({ selector: \"[appTriumphs]\", }) export class TriumphsDirective { constructor( private elementRef: ElementRef, private renderer: Renderer2, ) { this.renderer.setStyle(this.elementRef.nativeElement, \"padding\", \"10px\"); this.renderer.setStyle( this.elementRef.nativeElement, \"font-style\", \"italic\", ); this.renderer.setStyle( this.elementRef.nativeElement, \"text-decoration\", \"underline\", ); } } ngClass Die Direktive ngClass wird verwendet, um dynamisch CSS/(SCSS)-Klassen auf ein HTML-Element anzuwenden. Sie ermöglicht es, CSS/(SCSS)-Klassen basierend auf Bedingungen oder Ausdrücken hinzuzufügen oder zu entfernen.\nEs gibt zwei verschiedene Arten wie ngClass verwendet wird:\nVariante 1: Bei der ersten Variante gibt man zuerst die Klasse an und nach einem Doppelpunkt dann die Bedingung. Bei der Bedingung kann wieder mit Booleans oder Operatoren gearbeitet werden.\n1 2 3 4 5 6 7 8 import { Component } from \"@angular/core\"; @Component({ // .. }) export class GreetingComponent { type: string = \"text\"; } 1 \u003cdiv [ngClass]=\"{'text': type === 'text'}\"\u003eText\u003c/div\u003e 1 2 3 4 5 6 @import \"_variables\"; .text { color: $black; font-family: Helvetica, sans-serif; } Man kann jedoch diese Variante auch für mehrere Klassen machen, indem man diese aneinander reiht und mit einem Komma trennt.\n1 2 3 4 5 6 7 8 9 import { Component } from \"@angular/core\"; @Component({ // .. }) export class GreetingComponent { type: string = \"text\"; textLength: number = 10; } 1 2 3 \u003cdiv [ngClass]=\"{'text': type === 'text', 'title' : textLength === 10 }\"\u003e Text \u003c/div\u003e 1 2 3 4 5 6 7 8 9 10 11 12 13 @import \"_variables\"; .text { color: $black; font-family: Helvetica, sans-serif; } .title { color: $black; font-family: Arial, sans-serif; font-size: 24px; font-weight: bold; } Variante 2: Bei der zweiten Variante arbeitet man mit dem ternary Operator, um zu prüfen ob eine Bedingung true ist. Wenn das der Fall ist, wird die erste angegebene Klasse verwendet. Ist die Bedingung jedoch false, so wird die zweite Klasse verwendet.\n1 2 3 4 5 6 7 8 import { Component } from \"@angular/core\"; @Component({ // .. }) export class GreetingComponent { textLength: number = 10; } 1 \u003cdiv [ngClass]=\"textLength === 10 ? 'title' : 'text'\"\u003eText\u003c/div\u003e 1 2 3 4 5 6 7 8 9 10 11 12 13 @import \"_variables\"; .text { color: $black; font-family: Helvetica, sans-serif; } .title { color: $black; font-family: Arial, sans-serif; font-size: 24px; font-weight: bold; } ","categories":"","description":"Modul #F6 - Angular - Directives\n","excerpt":"Modul #F6 - Angular - Directives\n","ref":"/docs/03_web/06_angular/02_8_directives/","tags":"","title":"Directives"},{"body":"Ziele Du weisst, was ein Directive ist und wozu diese verwendet wird. Du kennst die drei Arten von Directives und kannst diese beschrieben. Du kannst ngIf, ngFor, ngSwitch und ngClass anwenden und erklären. Directives Directives sind ein Mechanismus, um die Darstellung von HTML-Elementen und das Verhalten von Components zu manipulieren. Directives ermöglichen es, benutzerdefinierte HTML-Attribute oder -Elemente zu definieren, die spezielle Funktionalitäten bereitstellen, die standardmässig nicht in HTML verfügbar sind.\nEs gibt drei Arten von Directives in Angular:\nComponents-Directives Components-Directives sind die am häufigsten verwendeten Directives in Angular. Sie erweitern das HTML durch die Definition von benutzerdefinierten HTML-Elementen und enthalten zugehörige Templates und Logik. Components-Direktiven sind im Wesentlichen Angular-Components.\n1 2 \u003c!--app-greeting.html--\u003e \u003capp-triumphs [title]=\"'Triumphs'\"\u003e\u003c/app-triumphs\u003e 1 2 3 4 5 6 7 8 import { Component, Input } from \"@angular/core\"; @Component({ // .. }) export class TriumphsComponent { @Input() title: string = \"\"; } 1 2 \u003c!--app-triumphs.html--\u003e \u003ch1\u003e{{ title }}\u003c/h1\u003e Struktur-Directives Struktur-Directives sind Directives, die das DOM manipulieren und Elemente hinzufügen oder entfernen. Ein Beispiel für eine Struktur-Directive ist *ngIf, das ein Element ausblendet, wenn eine Bedingung nicht erfüllt ist.\n1 2 \u003c!--app-greeting.html--\u003e \u003capp-triumphs *ngif=\"hasTriumphs\" [title]=\"'Triumphs'\"\u003e\u003c/app-triumphs\u003e 1 2 3 4 5 6 7 8 9 10 import { Component } from \"@angular/core\"; @Component({ // .. }) export class GreetingComponent { // .. triumphs: string[] = [\"HTML\", \"CSS\", \"JavaScript\", \"TypeScript\"]; hasTriumphs: boolean = this.triumphs.length \u003e 0; } *ngIf Die *ngIf-Direktive wird verwendet, um im Template eines Components Bedingungen zu überprüfen und den darin enthaltenen HTML-Code nur dann anzuzeigen, wenn die Bedingung erfüllt ist. Wenn die Bedingung nicht erfüllt ist, wird der entsprechende HTML-Code aus der gerenderten View entfernt.\nDie Verwendung von *ngIf ermöglicht es, dynamisch Elemente in der View zu steuern.\n1 2 \u003c!--app-greeting.html--\u003e \u003capp-triumphs *ngif=\"hasTriumphs\" [title]=\"'Triumphs'\"\u003e\u003c/app-triumphs\u003e 1 2 3 4 5 6 7 8 9 10 import { Component } from \"@angular/core\"; @Component({ // .. }) export class GreetingComponent { // .. triumphs: string[] = [\"HTML\", \"CSS\", \"JavaScript\", \"TypeScript\"]; hasTriumphs: boolean = this.triumphs.length \u003e 0; } *ngFor Die *ngFor-Direktive wird verwendet, um eine Liste von Elementen im Template eines Components zu rendern. Mit *ngFor kann man über eine Datenquelle iterieren und für jedes Element den entsprechenden Code im Template generieren. Das ist besonders nützlich, wenn man Kacheln anzeigen möchte oder eine Liste mit User Objekten anzeigen möchte.\n1 2 3 4 5 6 \u003c!--app-greeting.html--\u003e \u003capp-triumphs *ngIf=\"hasTriumphs\" [title]=\"'Triumphs'\" [triumphs]=\"triumphs\" \u003e\u003c/app-triumphs\u003e 1 2 3 4 5 6 7 8 9 10 import { Component } from \"@angular/core\"; @Component({ // .. }) export class GreetingComponent { // .. triumphs: string[] = [\"HTML\", \"CSS\", \"JavaScript\", \"TypeScript\"]; hasTriumphs: boolean = this.triumphs.length \u003e 0; } 1 2 3 4 \u003c!--app-triumphs.html--\u003e \u003cdiv *ngFor=\"let triumph of triumphs\"\u003e \u003cp\u003e{{ triumph }}\u003c/p\u003e \u003c/div\u003e 1 2 3 4 5 6 7 8 9 import { Component, Input } from \"@angular/core\"; @Component({ // .. }) export class TriumphsComponent { @Input() title: string = \"\"; @Input() triumphs: string[] = []; } Wenn man den Index bei einem *ngFor benötigt, kann dieser sehr einfach angegeben werden. Dazu muss man nach dem *ngFor den Code ; let i = index hinzufügen. Nun kann man in den Elementen innerhalb des *ngFor auf den Index der Elemente zu greifen. Der Index ist insofern relevant, dass man einzelne Elemente anhand dessen identifizieren kann, zudem ist direkt ersichtlich, welchen Index das gerenderte Element innehat.\n1 2 3 \u003cdiv *ngFor=\"let triumph of triumphs; let i = index\"\u003e \u003cp\u003e{{ triumph }}, {{ i }}\u003c/p\u003e \u003c/div\u003e *ngSwitch Das ngSwitch-Directive ermöglicht das bedingte Rendern von Inhalten auf der Grundlage eines Ausdrucks mit mehreren möglichen Werten. Es funktioniert ähnlich wie ein switch-Statement in anderen Programmiersprachen.\n1 2 3 4 5 6 7 8 import { Component } from \"@angular/core\"; @Component({ // .. }) export class WeaponComponent { weapons: string[] = [\"Sword\"]; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u003cdiv [ngSwitch]=\"weapons\"\u003e \u003cdiv *ngSwitchCase=\"'Sword'\"\u003e \u003cp\u003eYou are wielding a mighty sword!\u003c/p\u003e \u003cp\u003eDefeat your enemies with precision and power.\u003c/p\u003e \u003c/div\u003e \u003cdiv *ngSwitchCase=\"'Bow'\"\u003e \u003cp\u003eYou have a deadly bow and arrows!\u003c/p\u003e \u003cp\u003eStrike your foes from a distance with accuracy.\u003c/p\u003e \u003c/div\u003e \u003cdiv *ngSwitchCase=\"'Staff'\"\u003e \u003cp\u003eYour staff is a conduit of mystical energy!\u003c/p\u003e \u003cp\u003eHarness the power of magic to overcome your adversaries.\u003c/p\u003e \u003c/div\u003e \u003cdiv *ngSwitchDefault\u003e \u003cp\u003eYou have not chosen a weapon yet.\u003c/p\u003e \u003cp\u003eFind your destined weapon and embark on your epic journey.\u003c/p\u003e \u003c/div\u003e \u003c/div\u003e Attribut-Directives Attribut-Directives sind Directives, die das Verhalten von HTML-Elementen ändern, ohne sie zu ersetzen. Ein Beispiel für eine Attribut-Direktive ist ngClass, welche es ermöglicht, CSS-Klassen basierend auf Bedingungen hinzuzufügen oder zu entfernen.\n1 \u003ch1 appTriumphs\u003e{{ title }}\u003c/h1\u003e 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import { Directive, ElementRef, Renderer2 } from \"@angular/core\"; @Directive({ selector: \"[appTriumphs]\", }) export class TriumphsDirective { constructor( private elementRef: ElementRef, private renderer: Renderer2, ) { this.renderer.setStyle(this.elementRef.nativeElement, \"padding\", \"10px\"); this.renderer.setStyle( this.elementRef.nativeElement, \"font-style\", \"italic\", ); this.renderer.setStyle( this.elementRef.nativeElement, \"text-decoration\", \"underline\", ); } } ngClass Die Direktive ngClass wird verwendet, um dynamisch CSS/(SCSS)-Klassen auf ein HTML-Element anzuwenden. Sie ermöglicht es, CSS/(SCSS)-Klassen basierend auf Bedingungen oder Ausdrücken hinzuzufügen oder zu entfernen.\nEs gibt zwei verschiedene Arten wie ngClass verwendet wird:\nVariante 1: Bei der ersten Variante gibt man zuerst die Klasse an und nach einem Doppelpunkt dann die Bedingung. Bei der Bedingung kann wieder mit Booleans oder Operatoren gearbeitet werden.\n1 2 3 4 5 6 7 8 import { Component } from \"@angular/core\"; @Component({ // .. }) export class GreetingComponent { type: string = \"text\"; } 1 \u003cdiv [ngClass]=\"{'text': type === 'text'}\"\u003eText\u003c/div\u003e 1 2 3 4 5 6 @import \"_variables\"; .text { color: $black; font-family: Helvetica, sans-serif; } Man kann jedoch diese Variante auch für mehrere Klassen machen, indem man diese aneinander reiht und mit einem Komma trennt.\n1 2 3 4 5 6 7 8 9 import { Component } from \"@angular/core\"; @Component({ // .. }) export class GreetingComponent { type: string = \"text\"; textLength: number = 10; } 1 2 3 \u003cdiv [ngClass]=\"{'text': type === 'text', 'title' : textLength === 10 }\"\u003e Text \u003c/div\u003e 1 2 3 4 5 6 7 8 9 10 11 12 13 @import \"_variables\"; .text { color: $black; font-family: Helvetica, sans-serif; } .title { color: $black; font-family: Arial, sans-serif; font-size: 24px; font-weight: bold; } Variante 2: Bei der zweiten Variante arbeitet man mit dem ternary Operator, um zu prüfen ob eine Bedingung true ist. Wenn das der Fall ist, wird die erste angegebene Klasse verwendet. Ist die Bedingung jedoch false, so wird die zweite Klasse verwendet.\n1 2 3 4 5 6 7 8 import { Component } from \"@angular/core\"; @Component({ // .. }) export class GreetingComponent { textLength: number = 10; } 1 \u003cdiv [ngClass]=\"textLength === 10 ? 'title' : 'text'\"\u003eText\u003c/div\u003e 1 2 3 4 5 6 7 8 9 10 11 12 13 @import \"_variables\"; .text { color: $black; font-family: Helvetica, sans-serif; } .title { color: $black; font-family: Arial, sans-serif; font-size: 24px; font-weight: bold; } ","categories":"","description":"Modul #F6 - Angular - Directives\n","excerpt":"Modul #F6 - Angular - Directives\n","ref":"/de/docs/03_web/06_angular/02_8_directives/","tags":"","title":"Directives"},{"body":"Ziele Du kannst ein Array mithilfe von Higher Order Functions filtrieren, deren Elemente umwandeln (map) und sortieren. Higher Order Functions map() Die map() Methode wird verwendet, um eine neue Array-Instanz zu erstellen, indem jeder Wert des ursprünglichen Arrays durch eine bestimmte Funktion transformiert wird. Dabei wird eine neue Array-Instanz erstellt, die die transformierten Werte aufnimmt.\n1 2 3 4 5 6 const numbers = [1, 2, 3, 4, 5]; const squares = numbers.map(function (num) { return num * num; }); console.log(squares); // [1, 4, 9, 16, 25] filter() Die Methode filter() wird angewendet, um eine neue Array-Instanz zu erstellen, die nur die Elemente des ursprünglichen Arrays enthält, die bestimmte Kriterien erfüllen (Filtern).\n1 2 3 4 5 6 const numbers = [1, 2, 3, 4, 5]; const evenNumbers = numbers.filter(function (num) { return num % 2 === 0; }); console.log(evenNumbers); // [2, 4] sort() Die sort()-Methode sortiert die Elemente in einem Array.\nDie Standard-Sortierreihenfolge ist alphanumerisch. Das bedeutet, dass die Elemente nach ihrer Unicode-Platzierung sortiert werden.\n1 2 3 4 const fruits = [\"Banana\", \"Mango\", \"Apple\", \"Orange\"]; const sortedFruits = fruits.sort(); console.log(sortedFruits); // [\"Apple\", \"Banana\", \"Mango\", \"Orange\"] Die sort()-Funktion kann auch mit einer Vergleichsfunktion verwendet werden, um die Elemente auf andere Weise zu sortieren.\nDie Vergleichsfunktion sollte dabei:\nzwei Argumente haben und einen negativen Wert zurückgeben, wenn das erste Argument vor dem zweiten Argument in der Sortierreihenfolge stehen soll, einen positiven Wert, wenn das erste Argument nach dem zweiten Argument stehen soll, und 0, wenn sie beide gleich zu gewichten sind. 1 2 3 4 const numbers = [10, 5, 20, 3]; numbers.sort((a, b) =\u003e a - b); console.log(numbers); // [3, 5, 10, 20] includes() (contains) Die includes()-Funktion wird verwendet, um zu prüfen, ob ein bestimmtes Element in einem Array vorhanden ist oder nicht. Die Funktion gibt true zurück, wenn das Element gefunden wurde, sonst false.\n1 2 3 4 const fruits = [\"Banana\", \"Mango\", \"Apple\", \"Orange\"]; const isAppleInFruits = fruits.includes(\"Apple\"); console.log(isAppleInFruits); // true includes() kann auch mit einem optionalen zweiten Parameter verwendet werden. Das wäre der Index, der angibt, von welcher Position im Array aus die Suche beginnen soll. Wenn dieser Parameter nicht angegeben wird, beginnt die Suche am Anfang des Arrays.\n1 2 3 4 const fruits = [\"Banana\", \"Mango\", \"Apple\", \"Orange\"]; const isAppleInFruits = fruits.includes(\"Banana\", 2); console.log(isAppleInFruits); // false some() Die Methode some() prüft, ob zumindest ein Element in einem Array die angegebene Kondition erfüllt. Die Funktion gibt true zurück, wenn mindestens ein Element der Kondition entspricht, andernfalls gibt sie false zurück.\n1 2 3 4 const fruits = [\"Banana\", \"Mango\", \"Apple\", \"Orange\"]; const isAppleInFruits = fruits.some((fruit) =\u003e fruit === \"Apple\"); console.log(isAppleInFruits); // true find() Die find()-Methode wird verwendet, um das erste Element in einem Array zu finden, welches der angegebenen Kondition entspricht. Die Funktion gibt das gefundene Element zurück, falls eines gefunden wird, andernfalls gibt sie undefined zurück.\n1 2 3 4 const fruits = [\"Banana\", \"Mango\", \"Apple\", \"Orange\"]; const apple = fruits.find((fruit) =\u003e fruit === \"Apple\"); console.log(apple); // 'Apple' reduce() Die reduce()-Methode wird verwendet, um das Array auf einen einzigen Wert zu reduzieren. Dabei wird der erste Wert (auch als Accumulator bezeichnet) genommen und mit dem zweiten kombiniert. Das Ergebnis davon ist der neue Accumulator und mit dem nächsten Wert (Wert des dritten Elements) im Array kombiniert. Das geschieht so lange, bis man durch das gesamte Array durchiteriert hat.\nBeispiel mit nur Reduktionsfunktion:\n1 2 3 4 5 6 const numbers = [1, 2, 3, 4, 5]; const sum = numbers.reduce(function (accumulator, currentValue) { return accumulator + currentValue; }); console.log(sum); // 15 ","categories":"","description":"Modul #F4 - JavaScript - Higher Order Functions von Arrays.\n","excerpt":"Modul #F4 - JavaScript - Higher Order Functions von Arrays.\n","ref":"/docs/03_web/03_javascript/09_higher-order-functions-arrays/","tags":"","title":"Arrays - Higher Order Functions"},{"body":"Ziele Du kannst ein Array mithilfe von Higher Order Functions filtrieren, deren Elemente umwandeln (map) und sortieren. Higher Order Functions map() Die map() Methode wird verwendet, um eine neue Array-Instanz zu erstellen, indem jeder Wert des ursprünglichen Arrays durch eine bestimmte Funktion transformiert wird. Dabei wird eine neue Array-Instanz erstellt, die die transformierten Werte aufnimmt.\n1 2 3 4 5 6 const numbers = [1, 2, 3, 4, 5]; const squares = numbers.map(function (num) { return num * num; }); console.log(squares); // [1, 4, 9, 16, 25] filter() Die Methode filter() wird angewendet, um eine neue Array-Instanz zu erstellen, die nur die Elemente des ursprünglichen Arrays enthält, die bestimmte Kriterien erfüllen (Filtern).\n1 2 3 4 5 6 const numbers = [1, 2, 3, 4, 5]; const evenNumbers = numbers.filter(function (num) { return num % 2 === 0; }); console.log(evenNumbers); // [2, 4] sort() Die sort()-Methode sortiert die Elemente in einem Array.\nDie Standard-Sortierreihenfolge ist alphanumerisch. Das bedeutet, dass die Elemente nach ihrer Unicode-Platzierung sortiert werden.\n1 2 3 4 const fruits = [\"Banana\", \"Mango\", \"Apple\", \"Orange\"]; const sortedFruits = fruits.sort(); console.log(sortedFruits); // [\"Apple\", \"Banana\", \"Mango\", \"Orange\"] Die sort()-Funktion kann auch mit einer Vergleichsfunktion verwendet werden, um die Elemente auf andere Weise zu sortieren.\nDie Vergleichsfunktion sollte dabei:\nzwei Argumente haben und einen negativen Wert zurückgeben, wenn das erste Argument vor dem zweiten Argument in der Sortierreihenfolge stehen soll, einen positiven Wert, wenn das erste Argument nach dem zweiten Argument stehen soll, und 0, wenn sie beide gleich zu gewichten sind. 1 2 3 4 const numbers = [10, 5, 20, 3]; numbers.sort((a, b) =\u003e a - b); console.log(numbers); // [3, 5, 10, 20] includes() (contains) Die includes()-Funktion wird verwendet, um zu prüfen, ob ein bestimmtes Element in einem Array vorhanden ist oder nicht. Die Funktion gibt true zurück, wenn das Element gefunden wurde, sonst false.\n1 2 3 4 const fruits = [\"Banana\", \"Mango\", \"Apple\", \"Orange\"]; const isAppleInFruits = fruits.includes(\"Apple\"); console.log(isAppleInFruits); // true includes() kann auch mit einem optionalen zweiten Parameter verwendet werden. Das wäre der Index, der angibt, von welcher Position im Array aus die Suche beginnen soll. Wenn dieser Parameter nicht angegeben wird, beginnt die Suche am Anfang des Arrays.\n1 2 3 4 const fruits = [\"Banana\", \"Mango\", \"Apple\", \"Orange\"]; const isAppleInFruits = fruits.includes(\"Banana\", 2); console.log(isAppleInFruits); // false some() Die Methode some() prüft, ob zumindest ein Element in einem Array die angegebene Kondition erfüllt. Die Funktion gibt true zurück, wenn mindestens ein Element der Kondition entspricht, andernfalls gibt sie false zurück.\n1 2 3 4 const fruits = [\"Banana\", \"Mango\", \"Apple\", \"Orange\"]; const isAppleInFruits = fruits.some((fruit) =\u003e fruit === \"Apple\"); console.log(isAppleInFruits); // true find() Die find()-Methode wird verwendet, um das erste Element in einem Array zu finden, welches der angegebenen Kondition entspricht. Die Funktion gibt das gefundene Element zurück, falls eines gefunden wird, andernfalls gibt sie undefined zurück.\n1 2 3 4 const fruits = [\"Banana\", \"Mango\", \"Apple\", \"Orange\"]; const apple = fruits.find((fruit) =\u003e fruit === \"Apple\"); console.log(apple); // 'Apple' reduce() Die reduce()-Methode wird verwendet, um das Array auf einen einzigen Wert zu reduzieren. Dabei wird der erste Wert (auch als Accumulator bezeichnet) genommen und mit dem zweiten kombiniert. Das Ergebnis davon ist der neue Accumulator und mit dem nächsten Wert (Wert des dritten Elements) im Array kombiniert. Das geschieht so lange, bis man durch das gesamte Array durchiteriert hat.\nBeispiel mit nur Reduktionsfunktion:\n1 2 3 4 5 6 const numbers = [1, 2, 3, 4, 5]; const sum = numbers.reduce(function (accumulator, currentValue) { return accumulator + currentValue; }); console.log(sum); // 15 ","categories":"","description":"Modul #F4 - JavaScript - Higher Order Functions von Arrays.\n","excerpt":"Modul #F4 - JavaScript - Higher Order Functions von Arrays.\n","ref":"/de/docs/03_web/03_javascript/09_higher-order-functions-arrays/","tags":"","title":"Arrays - Higher Order Functions"},{"body":"Ziele Ich kann auswendig in eigenen Worten beschreiben, was Enums sind und wann sie benutzt werden. Ich setze Enums in einem konkreten Code-Beispiel selbständig und korrekt ein. Ich setze Methoden und Konstruktoren in Enums in einem konkreten Code-Beispiel selbständig und korrekt ein. Enums Enums (kurz für “enumeration”, zu Deutsch “Aufzählung”) bieten die Möglichkeit, vordefinierte Konstanten zusammen zu gruppieren. Enums werden dann verwendet, wenn alle mögliche Werte zur Kompilierzeit bekannt sind (z.B. alle Wochentage, alle Planeten im Sonnensystem usw.).\nIn Java sind Aufzählungstypen als Klassen realisiert und die definierten Werte sind als Objekte implementiert. Daraus ergeben sich folgenden nützlichen Eigenschaften:\nEnums können Konstruktoren, Instanzvariablen und Instanz-Methoden beinhalten Der Name der Enum-Werte kann mithilfe der toString()-Methode (oder mit dem Keywort this) im Klartext (String) ausgegeben werden. Mithilfe des ==-Operators kann auf Gleichheit geprüft werden. Enumerations können in switch-Anweisungen verwendet werden. Mithilfe der values-Methode wird ein Array zurückgegeben, das alle Elemente der Enumeration enthält. In Verbindung mit der erweiterten for-Schleife (for-each) können die Elemente sehr einfach durchlaufen werden. Obwohl Java Enums als Klassen realisiert werden, müssen sie nicht mit new instanziiert werden. Im Gegensatz zu Klassen können Java-Enums weder erweitert werden noch von anderen Klassen erben.\nEnums definieren Enums können innerhalb oder ausserhalb einer Klasse definiert werden (nicht aber innerhalb einer Methode!). Um ein Enum zu definieren, wird das Java-Schlüsselwort enum verwendet.\nDie erste Zeile(n) innerhalb der Enum-Definition soll eine kommagetrennte Liste von Konstanten beinhalten (in Java per Konvention mit Grossbuchstaben geschrieben). Danach werden allfällige Variablen, Methoden und Konstruktoren definiert.\nJede Enum-Konstante ist implizit public static final. Weil es static ist, kann über den Enum-Namen darauf zugegriffen werden. Weil es final ist, kann es nicht erweitert werden.\nBeispiel: Definition ausserhalb einer Klasse 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 enum Weekday { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY } public class DailyPlanner { private static void dailyMood(Weekday weekday) { switch (weekday) { case MONDAY: System.out.println(\"I don't like Mondays\"); break; case FRIDAY: System.out.println(\"Thank God it's Friday\"); break; case SATURDAY: case SUNDAY: System.out.println(\"There aren't enough days in the weekend\"); break; default: System.out.println(\"Some Midweek days feel like Mondays when I wish they were Fridays\"); break; } } public static void main(String[] args) { dailyMood(Weekday.MONDAY); } } Beispiel: Definition innerhalb einer Klasse 1 2 3 4 5 6 7 8 9 public class DailyPlanner { enum Weekday { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY } public static void main(String[] args) { System.out.println(\"I like \" + Weekday.SATURDAY + \" and \" + Weekday.SUNDAY + \" the best\"); } } Enum mit einem Konstruktor Ein Enum-Konstruktor wird für jede Enum-Konstante während dem Klassenladen des Enums ausgeführt. Es ist unmöglich, Enum-Objekte explizit zu erzeugen. Darum kann ein Enum-Konstruktor auch nicht direkt aufgerufen werden.\nBeispiel: Enum mit einem Konstruktor 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 enum Weekday { MONDAY(1), TUESDAY(2), WEDNESDAY(3), THURSDAY(4), FRIDAY(5), SATURDAY(6), SUNDAY(7); final int dayNumber; Weekday(int dayNumber) { this.dayNumber = dayNumber; System.out.println(\"Konstruktor für Tag \" + this.toString() + \" wird ausgeführt. Das ist der \" + this.dayNumber+ \". Tag in der Woche\"); } } public class TestDays { public static void main(String[] args) { Weekday monday = Weekday.MONDAY; // Output: // Konstruktor für Tag MONDAY wird ausgeführt. Das ist der 1. Tag in der Woche // Konstruktor für Tag TUESDAY wird ausgeführt. Das ist der 2. Tag in der Woche // Konstruktor für Tag WEDNESDAY wird ausgeführt. Das ist der 3. Tag in der Woche // Konstruktor für Tag THURSDAY wird ausgeführt. Das ist der 4. Tag in der Woche // Konstruktor für Tag FRIDAY wird ausgeführt. Das ist der 5. Tag in der Woche // Konstruktor für Tag SATURDAY wird ausgeführt. Das ist der 6. Tag in der Woche // Konstruktor für Tag SUNDAY wird ausgeführt. Das ist der 7. Tag in der Woche System.out.println(monday); // Output: MONDAY } } Enum mit Methoden Ein Enum kann konkrete wie auch abstrakte Methoden beinhalten. Wenn ein Enum eine abstrakte Methode beinhaltet, muss jede Instanz (also jede Konstante) dieses Enums diese Methode umsetzen (mehr Information über abstrakten Methoden findest du im Modul OOD).\nBeispiel: Enum mit konkreten und abstrakten Methoden 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 enum Color { RED { // Umsetzung der abstrakten Methode für die Farbe RED @Override public void colorPoem() { System.out.println(\"Roses are red\"); } }, VIOLET { // Umsetzung der abstrakten Methode für die Farbe VIOLET @Override public void colorPoem() { System.out.println(\"Violets are blue\"); } }; // Konkrete Methode, welche für alle Werte im Enum, dasselbe tut public void generalColorInfo(){ System.out.println(\"Everyday color is a great color!\"); } // Abstrakte Methode, welche von jedem Wert im Enum umgesetzt werden muss public abstract void colorPoem(); } public class Test { public static void main(String[] args) { Color violet = Color.VIOLET; violet.generalColorInfo(); // Output: Everyday color is a great color! violet.colorPoem(); // Output: Violets are blue Color red = Color.RED; red.generalColorInfo(); // Output: Everyday color is a great color! red.colorPoem(); // Output: Roses are red } } ","categories":"","description":"Modul #J2\n","excerpt":"Modul #J2\n","ref":"/docs/02_java/04_java-oop/09_enums/","tags":"","title":"Enums"},{"body":"Ziele Ich kann auswendig in eigenen Worten beschreiben, was Enums sind und wann sie benutzt werden. Ich setze Enums in einem konkreten Code-Beispiel selbständig und korrekt ein. Ich setze Methoden und Konstruktoren in Enums in einem konkreten Code-Beispiel selbständig und korrekt ein. Enums Enums (kurz für “enumeration”, zu Deutsch “Aufzählung”) bieten die Möglichkeit, vordefinierte Konstanten zusammen zu gruppieren. Enums werden dann verwendet, wenn alle mögliche Werte zur Kompilierzeit bekannt sind (z.B. alle Wochentage, alle Planeten im Sonnensystem usw.).\nIn Java sind Aufzählungstypen als Klassen realisiert und die definierten Werte sind als Objekte implementiert. Daraus ergeben sich folgenden nützlichen Eigenschaften:\nEnums können Konstruktoren, Instanzvariablen und Instanz-Methoden beinhalten Der Name der Enum-Werte kann mithilfe der toString()-Methode (oder mit dem Keywort this) im Klartext (String) ausgegeben werden. Mithilfe des ==-Operators kann auf Gleichheit geprüft werden. Enumerations können in switch-Anweisungen verwendet werden. Mithilfe der values-Methode wird ein Array zurückgegeben, das alle Elemente der Enumeration enthält. In Verbindung mit der erweiterten for-Schleife (for-each) können die Elemente sehr einfach durchlaufen werden. Obwohl Java Enums als Klassen realisiert werden, müssen sie nicht mit new instanziiert werden. Im Gegensatz zu Klassen können Java-Enums weder erweitert werden noch von anderen Klassen erben.\nEnums definieren Enums können innerhalb oder ausserhalb einer Klasse definiert werden (nicht aber innerhalb einer Methode!). Um ein Enum zu definieren, wird das Java-Schlüsselwort enum verwendet.\nDie erste Zeile(n) innerhalb der Enum-Definition soll eine kommagetrennte Liste von Konstanten beinhalten (in Java per Konvention mit Grossbuchstaben geschrieben). Danach werden allfällige Variablen, Methoden und Konstruktoren definiert.\nJede Enum-Konstante ist implizit public static final. Weil es static ist, kann über den Enum-Namen darauf zugegriffen werden. Weil es final ist, kann es nicht erweitert werden.\nBeispiel: Definition ausserhalb einer Klasse 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 enum Weekday { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY } public class DailyPlanner { private static void dailyMood(Weekday weekday) { switch (weekday) { case MONDAY: System.out.println(\"I don't like Mondays\"); break; case FRIDAY: System.out.println(\"Thank God it's Friday\"); break; case SATURDAY: case SUNDAY: System.out.println(\"There aren't enough days in the weekend\"); break; default: System.out.println(\"Some Midweek days feel like Mondays when I wish they were Fridays\"); break; } } public static void main(String[] args) { dailyMood(Weekday.MONDAY); } } Beispiel: Definition innerhalb einer Klasse 1 2 3 4 5 6 7 8 9 public class DailyPlanner { enum Weekday { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY } public static void main(String[] args) { System.out.println(\"I like \" + Weekday.SATURDAY + \" and \" + Weekday.SUNDAY + \" the best\"); } } Enum mit einem Konstruktor Ein Enum-Konstruktor wird für jede Enum-Konstante während dem Klassenladen des Enums ausgeführt. Es ist unmöglich, Enum-Objekte explizit zu erzeugen. Darum kann ein Enum-Konstruktor auch nicht direkt aufgerufen werden.\nBeispiel: Enum mit einem Konstruktor 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 enum Weekday { MONDAY(1), TUESDAY(2), WEDNESDAY(3), THURSDAY(4), FRIDAY(5), SATURDAY(6), SUNDAY(7); final int dayNumber; Weekday(int dayNumber) { this.dayNumber = dayNumber; System.out.println(\"Konstruktor für Tag \" + this.toString() + \" wird ausgeführt. Das ist der \" + this.dayNumber+ \". Tag in der Woche\"); } } public class TestDays { public static void main(String[] args) { Weekday monday = Weekday.MONDAY; // Output: // Konstruktor für Tag MONDAY wird ausgeführt. Das ist der 1. Tag in der Woche // Konstruktor für Tag TUESDAY wird ausgeführt. Das ist der 2. Tag in der Woche // Konstruktor für Tag WEDNESDAY wird ausgeführt. Das ist der 3. Tag in der Woche // Konstruktor für Tag THURSDAY wird ausgeführt. Das ist der 4. Tag in der Woche // Konstruktor für Tag FRIDAY wird ausgeführt. Das ist der 5. Tag in der Woche // Konstruktor für Tag SATURDAY wird ausgeführt. Das ist der 6. Tag in der Woche // Konstruktor für Tag SUNDAY wird ausgeführt. Das ist der 7. Tag in der Woche System.out.println(monday); // Output: MONDAY } } Enum mit Methoden Ein Enum kann konkrete wie auch abstrakte Methoden beinhalten. Wenn ein Enum eine abstrakte Methode beinhaltet, muss jede Instanz (also jede Konstante) dieses Enums diese Methode umsetzen (mehr Information über abstrakten Methoden findest du im Modul OOD).\nBeispiel: Enum mit konkreten und abstrakten Methoden 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 enum Color { RED { // Umsetzung der abstrakten Methode für die Farbe RED @Override public void colorPoem() { System.out.println(\"Roses are red\"); } }, VIOLET { // Umsetzung der abstrakten Methode für die Farbe VIOLET @Override public void colorPoem() { System.out.println(\"Violets are blue\"); } }; // Konkrete Methode, welche für alle Werte im Enum, dasselbe tut public void generalColorInfo(){ System.out.println(\"Everyday color is a great color!\"); } // Abstrakte Methode, welche von jedem Wert im Enum umgesetzt werden muss public abstract void colorPoem(); } public class Test { public static void main(String[] args) { Color violet = Color.VIOLET; violet.generalColorInfo(); // Output: Everyday color is a great color! violet.colorPoem(); // Output: Violets are blue Color red = Color.RED; red.generalColorInfo(); // Output: Everyday color is a great color! red.colorPoem(); // Output: Roses are red } } ","categories":"","description":"Modul #J2\n","excerpt":"Modul #J2\n","ref":"/de/docs/02_java/04_java-oop/09_enums/","tags":"","title":"Enums"},{"body":" Voraussetzungen Du kennst try, catch, throw, throws und finally. Wir stellen dir bei den Übungen jeweils komplette Projekte zur Verfügung. Du musst grundsätzlich nur dort was anpassen, wo die folgende Kommentarzeile steht:\nKopieren // IT-Ninja: Füge hier Deinen Code ein: 1 // IT-Ninja: Füge hier Deinen Code ein: Alles andere kannst du für den Moment ignorieren. Wir erklären dir die einzelnen Zeilen Schritt für Schritt in den Modulen.\nVorbereitungsarbeiten Drücke auf den Pfeil links um eine detaillierte Anleitung zu erhalten, wie Du den Quellcode auf deinem Rechner ablegen sollst.\nDiese Schritte musst du bei jeder Übung erneut machen. Jede Übung hat ein eigenes ZIP-File, welches du bei dir an die richtige Stelle kopieren musst. Die Anleitung zeigt dir ziemlich gut, wie das geht… Liess vor allem am Anfang die detaillierte Anleitung gut durch und befolge die Schritte exakt. Sie helfen dir, deinen Quellcode gut organisiert, strukturiert und sicher zu verwalten. Falls du die Anleitung schon auswendig kennst, findest du den Quellcode zur Übung direkt hier: Download | Online anschauen\nNeu bei it-ninja?\nDie Anleitung enthält einige Befehle und Fachbegriffe, die dir möglicherweise noch nichts sagen. Mach dir deswegen keine Sorgen – in den kommenden Modulen erklären wir dir alles Schritt für Schritt. Schon bald wirst auch du ein it-ninja sein. Um die folgenden Aufgaben erfolgreich umzusetzen, führe diese Schritte aus:\nBeim ersten Mal:\nIntelliJ IDEA installieren → !*IntelliJ IDEA einrichten Git-Repository einrichten → !*Persönliches Git-Repository Öffne eine !*CMD-Shell und wechsle ins Verzeichnis deines Git-Repositories:\nKopieren cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git status 1 2 cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git status Kopieren cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git status 1 2 cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git status Stelle sicher, dass alle Dateien im Git-Repository committed sind. Mit git status erhältst du eine Übersicht: Kopieren git status 1 git status Falls du bei diesem Befehl einen roten Text siehst, musst du zuerst die aktuellen Dateien sichern:\nKopieren git add . git commit -m \"[gescheiter Kommentar]\" 1 2 git add . git commit -m \"[gescheiter Kommentar]\" Erstelle oder wechsle in den Template Branch:\nBeim ersten Mal musst du einen Template Branch erstellen:\nKopieren git checkout -b \"templates\" 1 git checkout -b \"templates\" Falls er bereits existiert, kannst du einfach switchen:\nKopieren git switch \"templates\" 1 git switch \"templates\" Lade den Source-Code zu den Übungen herunter und entpacke ihn im Root-Verzeichnis deines lokalen Repositories:\n[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\nDen Source-Code findest du hier: Download | Online anschauen\nCommitte den originalen Source-Code, damit er sicher im Repository gespeichert ist:\nKopieren git add . git commit -m \"Add it-ninja_02_java_03_java-grundlagen_09_exception_handling\" git push 1 2 3 git add . git commit -m \"Add it-ninja_02_java_03_java-grundlagen_09_exception_handling\" git push Erstelle einen neuen Branch, um deine Lösung zu implementieren: Kopieren git checkout -b \"labs/it-ninja_02_java_03_java-grundlagen_09_exception_handling\" 1 git checkout -b \"labs/it-ninja_02_java_03_java-grundlagen_09_exception_handling\" Hier kannst du auch einen kürzeren Namen wählen. Verwende labs am Anfang des Branch-Namens für Branches, die deinen eigenen Code enthalten.\nStelle dir einen Branch vorerst als Ordner vor. Jeder Ordner enthält eine Version oder einen Stand von deinem Quellcode. Du kannst dann mit git zwischen diesen Ordern hin und her wechseln, sie vergleichen aber später auch zusammenführen.\nPro-Tipp:\nDu kannst jederzeit einen weiteren Branch erstellen – z. B. wenn du etwas ausprobieren möchtest. Alternativ kannst du auch in der Git-History einen alten Stand wiederherstellen, was aber weniger flexibel ist. Starte IntelliJ und öffne mit File → Open das Verzeichnis mit dem Source-Code. Du musst mit IntelliJ den Ordner suchen, welches einen Ordner src oder die Datei pom.xml enthält. Ansonsten wird IntelliJ Mühe haben, dir das Programm zu kompilieren. Wenn du alles korrekt gemacht hast, findest du das Projekt hier:\nKopieren `[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\\02_java\\03_java-grundlagen\\09_exception_handling` 1 `[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\\02_java\\03_java-grundlagen\\09_exception_handling` Kopieren `[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\\02_java/03_java-grundlagen/09_exception_handling` 1 `[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\\02_java/03_java-grundlagen/09_exception_handling` Falls du zum ersten Mal mit IntelliJ arbeitest, findest du !*hier eine Anleitung, wie man ein Programm startet. Um das Programm zu starten musst du jeweils die Datei Main.java öffenen. Dann sollte in IntelliJ oben rechts ein grünes Dreieck vorhanden sein, welches das Programm startet. Nun bist du bereit, die untenstehenden Aufgaben zu lösen.\nWenn du alle Änderungen gemacht hast und mit der Übung fertig bist, oder einen ‘Zwischenstand’ festhalten willst, führe die folgenden Befehle aus um das Repository auf dem Server zu speichern (von wo du es geklont hast):\nKopieren cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git add --all git commit -m \"Kurzer Kommentar\" 1 2 3 cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git add --all git commit -m \"Kurzer Kommentar\" Kopieren cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git add . git commit -m \"Kurzer Kommentar\" 1 2 3 cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git add . git commit -m \"Kurzer Kommentar\" Wenn du deine Änderungen auf dem Git-Server sichern willst, musst du das mit einem push machen.\nBeim ersten mal musst du git noch mitteilen, wie der Branch auf dem Git-Server heissen soll:\nKopieren git push --set-upstream origin labs/it-ninja_02_java_03_java-grundlagen_09_exception_handling 1 git push --set-upstream origin labs/it-ninja_02_java_03_java-grundlagen_09_exception_handling Bei weiteren pushes wird es dann einfacher:\nKopieren git push 1 git push Die meisten Übungen sind professionell strukturiert – so wie in echten Softwareprojekten. Zu gutem Code gehören auch Tests, die sicherstellen, dass dein Code wie erwartet funktioniert. Sofern nicht anders erwähnt, kannst du mit folgendem Befehl im Root-Verzeichnis des Projekts (dort, wo sich auch die pom.xml befindet) überprüfen, ob du die Aufgabe korrekt gelöst hast:\n1 mvn test Viel Erfolg!\nAufgabe 1 – Sichere Division Passe untenstehenden Quellcode an und füge folgende Methode hinzu:\nName der Methode: Bestimme selber einen passenden Namen für die Methode\nFunktion: Liefert das Resultat der Divsion von a durch b. Bei einer Divsion durch 0 wird der Wert Integer.MAX_VALUE zurückgeben.\nParameter1: a [int]\nParameter2: b [int]\nRückgabewert: Resultat der Berechnung [int], Integer,MAX_VALUE bei Division durch 0.\nBedingungen: Verwende try / catch, um Division durch 0 korrekt abzufangen. if darf nicht verwendet werden.\nHalte die Coding Guidelines ein!\nIm zur Übung gehörendem Source kannst Du die Änderung an folgender Stelle machen:\nsrc\\main\\java\\ch\\itninja\\labs\\basicexercises\\Calculator.java:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Calculator { private Calculator() { // Prevent instantiation } // Place here the methode for \"Sichere Division\". // IT-Ninja: Füge hier Deinen Code ein: // Place here the methode for \"Mindestwert sicherstellen\". // IT-Ninja: Füge hier Deinen Code ein: } Wenn du die Methode implementiert hast, kannst du sie aus main aufrufen.\nIm zur Übung gehörendem Source kannst Du die Änderung an folgender Stelle machen:\nsrc\\main\\java\\ch\\itninja\\labs\\Main.java:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public static void main(String[] args) { // Sample call for \"Sichere Division\" // IT-Ninja: Füge hier Deinen Code ein: try { int age = 16; // Sample call for \"Alter prüfen\" // IT-Ninja: Füge hier Deinen Code ein: System.out.printf(\"Das Alter %d ist gültig.%n\", age); } catch (IllegalArgumentException e) { System.out.println(\"Fehler: \" + e.getMessage()); } // Sample call for \"Mindestwert sicherstellen\" // IT-Ninja: Füge hier Deinen Code ein: } Falls du sie testen willst, kannst du sie aus dem vorbereiteten Test aufrufen.\nIm zur Übung gehörendem Source kannst Du die Änderung an folgender Stelle machen:\nsrc\\test\\java\\ch\\itninja\\labs\\CalculatorTest.java:\n1 2 3 4 5 6 try { // WHEN // Aufruf der Methode für \"Sichere Division\", welche wir testen wollen (etwas wie: res = methode(a, b);): // IT-Ninja: Füge hier Deinen Code ein: } finally { } Aufgabe 2 – Alter prüfen Passe untenstehenden Quellcode an und füge folgende Methode hinzu:\nName der Methode: Bestimme selber einen passenden Namen für die Methode\nFunktion: Prüft das Alter und wirft eine IllegalArgumentException, wenn das Alter kleiner 0 oder grösser 130 ist. Für gültige Werte passiert nichts.\nParameter1: age [int]\nRückgabewert: keiner, IllegalArgumentException wenn Alter ausserhalb des erlaubten Bereichs ist.\nHalte die Coding Guidelines ein!\nIm zur Übung gehörendem Source kannst Du die Änderung an folgender Stelle machen:\nsrc\\main\\java\\ch\\itninja\\labs\\basicexercises\\AgeValidator.java:\n1 2 3 4 5 6 7 8 9 10 public class AgeValidator { // IT-Ninja: Füge hier Deinen Code ein: private AgeValidator() { // Prevent instantiation } // IT-Ninja: Füge hier Deinen Code ein: } Wenn du die Methode implementiert hast, kannst du sie aus main aufrufen.\nIm zur Übung gehörendem Source kannst Du die Änderung an folgender Stelle machen:\nsrc\\main\\java\\ch\\itninja\\labs\\Main.java:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public static void main(String[] args) { // Sample call for \"Sichere Division\" // IT-Ninja: Füge hier Deinen Code ein: try { int age = 16; // Sample call for \"Alter prüfen\" // IT-Ninja: Füge hier Deinen Code ein: System.out.printf(\"Das Alter %d ist gültig.%n\", age); } catch (IllegalArgumentException e) { System.out.println(\"Fehler: \" + e.getMessage()); } // Sample call for \"Mindestwert sicherstellen\" // IT-Ninja: Füge hier Deinen Code ein: } Falls du sie testen willst, kannst du sie aus dem vorbereiteten Test aufrufen.\nIm zur Übung gehörendem Source kannst Du die Änderung an folgender Stelle machen:\nsrc\\test\\java\\ch\\itninja\\labs\\AgeValidatorTest.java:\n1 2 3 4 5 6 7 8 try { // WHEN // Aufruf der Methode für \"Sichere Division\", welche wir testen wollen (etwas wie: res = methode(a, b);): // IT-Ninja: Füge hier Deinen Code ein: } catch (IllegalArgumentException e) { excptionOccured = true; exceptionMessage = e.getMessage(); } Aufgabe 3 – Mindestwert sicherstellen Passe untenstehenden Quellcode an und füge folgende Methode hinzu:\nName der Methode: Bestimme selber einen passenden Namen für die Methode\nFunktion: Dividiert a durch b und danach c durch d. Das Resultat wird jeweils zum Total hinzugefügt. Fehler werden mit einem einzigen try / catch abgefangen. Im finally-Block wird abschliessend sichergestellt, dass das Total mindestens 100 beträgt.\nParameter1: a [int]\nParameter2: b [int]\nParameter3: c [int]\nParameter4: b [int]\nRückgabewert: Total der Berechnung [int]\nBei dieser Aufgabe ist es wichtig, dass du die Funktion genau umsetzt auch wenn sie eigentlich keinen Sinn macht oder besser implementiert werden könnte.\nHalte die Coding Guidelines trotzdem ein!\nIm zur Übung gehörendem Source kannst Du die Änderung an folgender Stelle machen:\nsrc\\main\\java\\ch\\itninja\\labs\\basicexercises\\Calculator.java:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Calculator { private Calculator() { // Prevent instantiation } // Place here the methode for \"Sichere Division\". // IT-Ninja: Füge hier Deinen Code ein: // Place here the methode for \"Mindestwert sicherstellen\". // IT-Ninja: Füge hier Deinen Code ein: } Wenn du die Methode implementiert hast, kannst du sie aus main aufrufen.\nIm zur Übung gehörendem Source kannst Du die Änderung an folgender Stelle machen:\nsrc\\main\\java\\ch\\itninja\\labs\\Main.java:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public static void main(String[] args) { // Sample call for \"Sichere Division\" // IT-Ninja: Füge hier Deinen Code ein: try { int age = 16; // Sample call for \"Alter prüfen\" // IT-Ninja: Füge hier Deinen Code ein: System.out.printf(\"Das Alter %d ist gültig.%n\", age); } catch (IllegalArgumentException e) { System.out.println(\"Fehler: \" + e.getMessage()); } // Sample call for \"Mindestwert sicherstellen\" // IT-Ninja: Füge hier Deinen Code ein: } Falls du sie testen willst, kannst du sie aus dem vorbereiteten Test aufrufen.\nIm zur Übung gehörendem Source kannst Du die Änderung an folgender Stelle machen:\nsrc\\test\\java\\ch\\itninja\\labs\\CalculatorTest.java:\n1 2 3 4 5 6 try { // WHEN // Aufruf der Methode für \"Mindestwert sicherstellen\", welche wir testen wollen (etwas wie: min = methode(a, b, c);): // IT-Ninja: Füge hier Deinen Code ein: } finally { } ","categories":"","description":"Mit diesen Übungen kannst du erste Erfahrungen beim behandeln von Exceptions sammeln.\n","excerpt":"Mit diesen Übungen kannst du erste Erfahrungen beim behandeln von …","ref":"/labs/02_java/03_java-grundlagen/09_exception_handling/","tags":"","title":"Java Exercises - Exception Handling"},{"body":" Dieses Kapitel gehört zum Modul #J1 des Ausbildungsplans Ziele Ich verstehe den Unterschied zwischen Fehlern (Errors) und Ausnahmen (Exceptions). Ich kenne den Unterschied zwischen Checked und Unchecked Exceptions. Ich kann try, catch, finally, throw und throws korrekt verwenden. Ich weiss, wie ich NullPointerExceptions vermeide. Ich weiss, warum Exceptions nicht als Kontrollstruktur verwendet werden sollten. ⏱️ Geschätzte Lesezeit: 30 Minuten Was ist ein Fehler? In Java unterscheidet man zwei grundlegende Arten von Fehlern:\nError: nicht abfangbare Fehler wie z. B. Speicherüberläufe Exception: abfangbare Ausnahmen, die während der Programmausführung auftreten Exceptions kann man behandeln – Errors nicht.\nChecked vs. Unchecked Checked Exceptions: werden vom Compiler geprüft (z. B. IOException) Unchecked Exceptions: entstehen zur Laufzeit (z. B. NullPointerException, ArithmeticException) Unchecked Exceptions sind oft auf Programmierfehler zurückzuführen und müssen nicht deklariert oder abgefangen werden.\ntry / catch / finally Mit try und catch kann man eine Exception abfangen:\n1 2 3 4 5 try { int result = 10 / 0; } catch (ArithmeticException e) { System.err.println(\"Division durch 0 ist nicht erlaubt!\"); } Optional kann ein finally-Block folgen, der immer ausgeführt wird:\n1 2 3 finally { System.out.println(\"Ich werde auf jeden Fall ausgeführt.\"); } throw und throws Mit throw wird eine Exception ausgelöst. Mit throws gibt man an, dass eine Methode eine Exception auslösen könnte:\n1 2 3 4 5 public void checkAge(int age) throws IllegalArgumentException { if (age \u003c 0) { throw new IllegalArgumentException(\"Alter darf nicht negativ sein\"); } } NullPointerException vermeiden Ein häufiger Fehler ist das Zugreifen auf null:\n1 2 String name = null; System.out.println(name.length()); // NullPointerException! Abhilfe schafft ein Guard:\n1 2 3 if (name != null) { System.out.println(name.length()); } Oder ein else-Zweig für den Fehlerfall:\n1 2 3 4 5 if (name != null) { System.out.println(name.length()); } else { System.out.println(\"Kein Name vorhanden.\"); } Auch der Ternary-Operator ist möglich:\n1 System.out.println(name != null ? name.length() : 0); Exceptions ≠ Kontrollstruktur Falsch:\n1 2 3 4 5 try { int value = Integer.parseInt(\"abc\"); } catch (NumberFormatException e) { value = 0; } Richtig:\n1 2 3 4 5 if (input.matches(\"\\d+\")) { value = Integer.parseInt(input); } else { value = 0; } Und assert? Mit assert kann man Annahmen prüfen – bricht aber bei Fehlschlag mit einem AssertionError ab:\n1 assert age \u003e= 0 : \"Alter darf nicht negativ sein\"; Das funktioniert nur, wenn Java mit -ea gestartet wird (enable assertions). assert ist ein Tool zur Fehlersuche, kein Ersatz für echtes Exception Handling.\nJetzt bist du dran. Löse bitte die folgenden !*Aufgaben in den Labs. ","categories":"","description":"Du lernst die Grundlagen des Exception Handlings kennen: try, catch, throw, throws sowie typische Fehlerarten und wie du sie vermeidest.\n","excerpt":"Du lernst die Grundlagen des Exception Handlings kennen: try, catch, …","ref":"/docs/02_java/03_java-grundlagen/09_exception_handling/","tags":"","title":"Fehlerbehandlung mit Exceptions"},{"body":"Ziele Ich kenne die Schlüsselwörter try, catch, finally, throw und throws. Ich weiss, was “Unchecked” und “Checked” Exceptions sind. Ich kann auftretende Exceptions behandeln. Ich kann eigene Exceptions definieren und anwenden. Ich kenne Multicatch und Try-With-Resources und kann die beiden Konstrukte anwenden. Ich kenne die beiden Interfaces AutoCloseable und Closeable. Ich kenne eine Möglichkeit, um anzugeben, dass bestimmte Werte “nullable” bzw. nicht “nullable” sind. Ich verstehe, wie Optional meinen Code sicherer gegenüber null-Werten macht. Theorie / Einleitung In jeder Applikation können erwartete oder unerwartete Fehler auftreten. In Java werden solche Fehler durch das Exception Handling abgefangen. Ziel des Exception Handlings ist es, durch gezieltes Behandeln von auftretenden Exceptions, Abstürze der Anwendung zu verhindern. Jeder Softwareentwickler sollte sich bewusst sein, dass unbehandelte Exceptions eine Anwendung jederzeit beenden können.\nIn Java unterscheidet man zwischen zwei Arten von Fehlern:\nError: Dies sind nicht reparierbare Laufzeitfehler oder Hardware-Probleme, die zum Absturz des Programms führen. Exception: Dies sind Fehler oder unvorhergesehene Ereignisse, die während der Programmausführung auftreten und den normalen Ablauf stören. Eine Java-Applikation sollte nicht versuchen, Errors abzufangen, da diese Fehler in der Regel aufgrund abnormaler Bedingungen (wie z. B. zu wenig Speicher) auftreten und unter normalen Umständen nicht behoben werden können. Exceptions hingegen sind unerwartete Fehler, auf die das Programm reagieren muss.\nInnerhalb des Java Exception Handling unterscheiden wir zwei Arten von Exceptions:\nUnchecked Exceptions: Laufzeitfehler, die vom Compiler nicht erkannt werden. Checked Exceptions: Fehler, die vom Compiler zur Kompilierungszeit erkannt werden. Unchecked Exceptions sind oft Fehler, welche bei der Implementation übersehen werden. Der häufigste Laufzeitfehler ist die NullPointerException. Diese kann erst zur Laufzeit auftreten, da nur zur Laufzeit Objekte erzeugt werden und damit eine Referenz überhaupt null sein kann.\nDie einzige Möglichkeit, Laufzeitfehler abzuhandeln, ist “Safe Programming”. Das heisst, dass wir während der Implementation Prüfungen und sog. “Guards” im Code einbauen (z.B. prüfen, ob eine Referenz nicht null ist bevor wir darauf zugreifen) um sicherzustellen, dass solche Situationen zur Laufzeit nicht auftreten. Hier ein Beispiel mit einer NullPointerException: ```java public static void main(String[] args) { Person person = null; // könnte stattdessen auch eine Methode sein, welche null zurückgibt person.getName(); // hier wird eine NullPointerException geworfen, da person == null } ``` Checked Exceptions müssen entweder am Ort des Auftretens abgefangen oder an den Aufrufer der Methode weitergegeben werden. Dadurch wird die Verantwortung zur Behandlung der Exception an den Aufrufer weitergegeben.\nDazu ein kleines Beispiel:\n1 2 3 4 5 public static void main(String[] args) { PhoneBook phoneBook = new PhoneBook(); Person person = phoneBook.findByPhoneNumber(\"079 654 32 10\"); System.out.println(person.getName()); } Ohne die Implementierung der Methode findByPhoneNumber zu kennen, muss ein Softwareentwickler das zurückgelieferte Objekt vom Typ Person zunächst auf null prüfen. Schauen wir uns daher die Implementierung dieser Methode genauer an:\n1 2 3 4 5 6 7 8 9 10 11 12 public class PhoneBook { private List\u003cPerson\u003e entries = new ArrayList\u003c\u003e(); public Person findByPhoneNumber(String number) { for (Person p: this.entries) { if (p.getPhoneNumber().equals(number)) { return p; } } return null; } } Wie (vielleicht) erwartet, liefert die Methode null zurück, falls kein Eintrag mit der gesuchten Nummer gefunden wird. Dies führt in der Main-Methode im obigen Code auf der letzten Zeile zu einer NullPointerException, da die Referenz person auf null zeigt. Ein einfaches if-Statement kann hier Abhilfe schaffen:\n1 2 3 4 5 6 7 public static void main(String[] args) { AddressBook addressBook = new AddressBook(); Person person = addressBook.findByPhoneNumber(\"079 654 32 10\"); if (person != null) { System.out.println(person.getName()); } } Der Laufzeitfehler kann nun nicht mehr auftreten. Es stellt sich jedoch die Frage, ob diese Lösung zufriedenstellend ist. Prinzipiell sollten wir zumindest informiert werden, wenn keine Person mit dieser Nummer gefunden wird. Eine Möglichkeit besteht darin, ein else-Statement hinzuzufügen:\n1 2 3 4 5 6 7 8 9 public static void main(String[] args) { AddressBook addressBook = new AddressBook(); Person person = addressBook.findByPhoneNumber(\"079 654 32 10\"); if (person != null) { System.out.println(person.getName()); } else { System.out.println(\"Es wurde keine Person mit dieser Nummer gefunden!\"); } } Eine alternative Lösung könnte darin bestehen, das Null-Object-Pattern oder ein Optional-Objekt zu verwenden, um ein gültiges Objekt anstelle von null zurückzugeben.\ntry / catch / finally Um eine Checked Exception zu behandeln, muss der Codeblock, der die Exception erzeugen könnte, innerhalb eines try-Blocks stehen. Der Exception-Typ, der abgefangen werden soll, wird in den zugehörigen catch-Block geschrieben:\n1 2 3 4 5 try { // Code, welcher eine IOException werfen könnte } catch (IOException e) { // Code zur Behandlung der IOException } Ein try-Statement kann beliebig viele catch-Blöcke haben:\n1 2 3 4 5 6 7 8 9 try { FileReader fileReader = new FileReader(\"nonexistent.txt\"); // Hier würde noch Code kommen, welcher vom File lesen würde. } catch (FileNotFoundException e) { // Hier wird nun die FileNotFoundException gehandhabt System.err.println(\"File not found: \" + e.getMessage()); } catch (IOException e) { System.err.println(\"Error reading from file: \" + e.getMessage()); } Bei mehreren catch-Blöcken muss die spezifischste Exception stets zuerst stehen. Je weiter unten der catch-Block steht, desto allgemeiner ist die Exception, die abgefangen wird. Der Grund dafür ist, dass alle Checked Exceptions von der Klasse Exception abgeleitet sind. Befindet sich eine allgemeinere Exception weiter oben, wird der catch-Block der spezifischeren Exception weiter unten nicht mehr erreichbar sein.\n1 2 3 4 5 6 7 8 9 try { // Code, der eine Ausnahme auslösen könnte int[] zahlen = {1, 2, 3}; System.out.println(zahlen[5]); // Dies wird eine ArrayIndexOutOfBoundsException auslösen } catch (ArrayIndexOutOfBoundsException e) { // Spezifische Ausnahme System.out.println(\"Spezifische Ausnahme abgefangen: ArrayIndexOutOfBoundsException\"); } catch (Exception e) { // Allgemeinere Ausnahme System.out.println(\"Allgemeine Ausnahme abgefangen: Exception\"); } Ein try-Block (ob mit oder ohne catch-Block) kann zusätzlich einen finally-Block haben. Der finally-Block wird nach der Bearbeitung der Exception ausgeführt. Falls keine Exception aufgetreten ist, wird der Code im finally-Block direkt nach dem try-Block ausgeführt. Der finally-Block wird also auf jeden Fall ausgeführt. Er muss deshalb so geschrieben werden, das auf jeden Fall funktioniert, auch wenn der Try-Block nicht komplett ausgeführt wird oder der catch-Block nie ausgeführt wurde.\n1 2 3 4 5 6 7 try { // Code, welcher eine IOException werfen könnte } catch (IOException e) { // Code für die Abhandlung der IOException } finally { // Code, welcher nach der Abhandlung der Exception ausgeführt werden soll } Wie oben erwähnt, kann der catch-Block weggelassen werden:\n1 2 3 4 5 try { // Code, welcher eine beliebige Exception werfen könnte } finally { // Code, welcher nach der Abhandlung der Exception ausgeführt werden soll } Vorsicht bei return-Anweisungen innerhalb von catch- oder finally-Blöcken: Da der finally-Block immer zuletzt ausgeführt wird, ist ein return-Statement in diesem Block massgeblich für die Funktionalität.\nthrow / throws Eine Exception muss nicht immer dort behandelt werden, wo sie auftritt. Falls die Behandlung in andere Klassen verlagert werden soll, kann mit dem Schlüsselwort throws angegeben werden, dass die aufrufende Komponente die Exception abfangen und behandeln muss.\nDazu ein kurzes Beispiel:\n1 2 3 public class EntryForbiddenException extends Exception { // Optionale Erweiterungen für diese Exception } 1 2 3 4 5 6 7 8 public class Saloon { public void checkAge(int age) throws EntryForbiddenException { if (age \u003c 18) { throw new EntryForbiddenException(); } // Zusätzlicher Code ... } } 1 2 3 4 5 6 7 8 9 10 public class Main { public static void main(String[] args) { Saloon saloon = new Saloon(); try { saloon.checkAge(15); } catch (EntryForbiddenException e) { // Behandlung der EntryForbiddenException } } } In diesem Beispiel wird die Behandlung in die main-Methode verlagert. Exceptions können über beliebig viele Stufen weitergegeben werden. Wenn jedoch die “oberste” Stufe (hier die main-Methode) die Exception nicht behandelt, wird die Anwendung mit einer entsprechenden Fehlermeldung beendet, da die Exception unbehandelt bleibt.\nUmwandlung Laufzeitfehler in Checked Exception Mit der Lösung aus dem vorherigen Beispiel können wir noch nicht vollständig zufrieden sein. Anstatt den Rückgabewert der Methode findByPhoneNumber auf null zu prüfen, wählen wir nun einen anderen Ansatz:\nWir erweitern die Anwendung so, dass die Methode keine null-Werte mehr als Rückgabewert liefert. Da der Compiler jedoch einen Rückgabewert erzwingt, bleibt uns nur die Möglichkeit, eine Exception zu werfen, wenn kein Ergebnis gefunden wird.\nZu diesem Zweck definieren wir zuerst eine entsprechende Exception:\n1 2 3 public class PersonNotFoundException extends Exception { // Optional: Erweiterungen für die Exception } Diese Exception wird nun an der entsprechenden Stelle im Code geworfen. Die Methode wird zusätzlich mit dem Schlüsselwort throws versehen:\n1 2 3 4 5 6 7 8 9 10 11 12 public class PhoneBook { private List\u003cPerson\u003e entries = new ArrayList\u003c\u003e(); public Person findByPhoneNumber(String number) throws PersonNotFoundException { for (Person p: this.entries) { if (p.getPhoneNumber().equals(number)) { return p; } } throw new PersonNotFoundException(); } } Beim Aufruf der Methode sind wir nun gezwungen, die Exception zu behandeln:\n1 2 3 4 5 6 7 8 9 10 public static void main(String[] args) { AddressBook addressBook = new AddressBook(); try { Person person = addressBook.findByPhoneNumber(\"079 654 32 10\"); System.out.println(person.getName()); } catch (PersonNotFoundException e) { System.out.println(\"Es wurde keine Person mit dieser Nummer gefunden!\"); throw new RuntimeException(); } } Aus dem ursprünglichen Laufzeitfehler ist nun eine behandelte Exception geworden. Diese Implementierung vermeidet, wo immer möglich, die Rückgabe von null-Werten.\nMulti-Catch Seit Java 7 gibt es die Möglichkeit, mehrere Exceptions in einem sogenannten Multi-Catch zu behandeln. Schauen wir uns das folgende Beispiel an:\nOhne Multi-Catch 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public static void main(String[] args) { String filename = \"example.txt\"; BufferedReader reader = null; try { reader = new BufferedReader(new FileReader(filename)); String line; while ((line = reader.readLine()) != null) { System.out.println(line); } } catch (IOException e) { System.err.println(\"Ein-/Ausgabefehler beim Lesen der Datei: \" + e.getMessage()); } catch (ParseException e) { System.err.println(\"Fehler beim Parsen der Daten: \" + e.getMessage()); } finally { reader.close(); } } Mit Multi-Catch 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public static void main(String[] args) { String filename = \"example.txt\"; BufferedReader reader = null; try { reader = new BufferedReader(new FileReader(filename)); String line; while ((line = reader.readLine()) != null) { System.out.println(line); } } catch (IOException | ParseException e) { System.err.println(\"Ein-/Ausgabefehler oder Fehler beim Parsen der Daten: \" + e.getMessage()); } finally { reader.close(); } } Die beiden Exceptions werden hier in einem einzigen catch-Block zusammengefasst. Zu beachten ist, dass die Exceptions innerhalb eines Multi-Catch nicht in einer Vererbungsbeziehung zueinander stehen dürfen. Das bedeutet, dass ihre Basistypen unterschiedlich sein müssen.\nTry-With-Resources Ebenfalls seit Java 7 gibt es die Möglichkeit für automatisches Ressourcen-Management.\nBetrachten wir dazu zuerst ein Beispiel ohne automatisches Ressourcen-Management:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public static String readFirstLine(String path) { BufferedReader br = null; try { br = new BufferedReader(new FileReader(path)); return br.readLine(); } catch (IOException e) { // handle or rethrow } finally { try { if (br != null) { br.close(); } } catch (IOException e) { // ignore } } return \"\"; } Der finally-Block ist notwendig, um die verwendete Ressource des BufferedReaders zu schliessen.\nDa beim Schliessen eine IOException auftreten kann, benötigen wir im finally-Blocks einen zusätzlichen try-catch-Block.\nBetrachten wir nun das gleiche Beispiel mit automatischem Ressourcen-Management:\n1 2 3 4 5 6 7 8 public static String readFirstLine(String path) { try (FileReader fr = new FileReader(path); BufferedReader br = new BufferedReader(fr)) { return br.readLine(); } catch (IOException e) { // handle or rethrow } return \"\"; } Wie wir sehen, entfällt der finally-Block zum Schliessen der Ressourcen vollständig. Die Ressourcen FileReader und BufferedReader werden automatisch geschlossen. Dies geschieht im Hintergrund über die Methode close, die vom Interface AutoCloseable bereitgestellt wird. In einem try-with-resources-Statement dürfen daher nur Objekte verwendet werden, die das genannte Interface implementieren. Das Closeable-Interface stellt dabei die Abwärtskompatibilität zu älteren Java-Versionen sicher, da es ebenfalls die close-Methode definiert. Grundsätzlich sollte das Closeable-Interface für IO-Streams verwendet werden, da es mit IOException arbeitet.\nDas Schliessen der Ressourcen erfolgt immer in umgekehrter Reihenfolge. In unserem Beispiel wird also zuerst der BufferedReader geschlossen und danach der FileReader. Die Verkettung von Ressourcen innerhalb eines try-with-resources-Statements sollte vermieden werden. Besser ist die getrennte Deklaration wie im obigen Beispiel.\nNull-Safety Ein häufiger Laufzeitfehler in Java ist die NullPointerException. Diese Exception tritt auf, wenn\neine Methode auf einem null-Objekt aufgerufen wird, versucht wird, auf ein Feld (Variable) eines null-Objekts zuzugreifen. Oft wird schlicht übersehen, dass eine bestimmte Variable null sein könnte:\n1 2 3 4 5 6 7 public static void main(String[] args) { method(null); } private static void method(String parameter) { System.out.println(\"Länge des Wortes: \" + parameter.length()); } Im obigen Beispiel führt der Versuch, die Methode length() auf einem null-Objekt aufzurufen, zur NullPointerException.\nHier werden zwei typische Ursachen für das Auftreten einer NullPointerException deutlich:\nEiner Variable (hier parameter) wird null zugewiesen/übergeben, was in manchen Fällen unerwartet ist. Es wird vergessen zu prüfen, dass eine Variable den Wert null haben könnte. Diese beiden Fälle können in Java auf verschiedene Arten abgefangen werden.\nnull durch Check abfangen Die offensichtlichste Möglichkeit, NullPointerExceptions zu vermeiden, ist die Verwendung von null-Checks.\nIm folgenden Beispiel verhindern wir null, indem wir die Variable zu Beginn der Methode prüfen und eine Exception werfen, falls die Variable null ist:\n1 2 3 4 5 6 private static void method(String parameter) throws IllegalArgumentException { if (parameter == null) { throw new IllegalArgumentException(\"Parameter parameter must not be null.\"); } System.out.println(\"Länge des Wortes: \" + parameter.length()); } In diesem Beispiel ist sichergestellt, dass der Wert null für das Argument parameter nicht erlaubt ist. Ein Nachteil dieser Lösung ist, dass Entwickler von aussen nicht direkt erkennen können, dass null-Werte unzulässig sind. Diesen Fall könnte man stattdessen besser mit einer @NotNull-Annotation abdecken, wie später beschrieben.\nManchmal jedoch sollen null-Werte zulässig sein. In solchen Fällen verwenden wir Bedingungen, um den richtigen Code auszuführen:\n1 2 3 4 5 6 7 private static void method(String parameter) { if (parameter != null) { System.out.println(\"Länge des Wortes: \" + parameter.length()); } else { System.out.println(\"Länge fes Wortes: ist nicht definiert bzw. 0.\"); } } Um hier null-Sicherheit zu garantieren, wurden einige zusätzliche Zeilen eingefügt. In solchen Fällen kann auch der Ternary-Operator nützlich sein:\n1 2 3 4 private static void method(String parameter) { System.out.println(\"Länge des Wortes: \" + (parameter != null ? parameter.length() : \"ist nicht definiert bzw. 0.\")); } Der Ternary-Ausdruck ist hierbei der folgende:\n1 parameter != null ? parameter.length() : \"ist nicht definiert bzw. 0.\" Dieser Ausdruck gibt parameter.length() zurück, wenn parameter != null ist. Ansonsten gibt er den String \"ist nicht definiert bzw. 0.\" zurück.\nGanz allgemein ist der Ternary-Ausdruck wie folgt aufgebaut:\n1 Bedingung ? Wert-wenn-Bedingung-true : Wert-wenn-Bedingung-false Annotationen wie @NotNull und @Nullable Sicherlich ist dir schon einmal die Angabe @Nullable bei einem Argument von einer Methode aus einer externen Library aufgefallen.\nSolche Annotationen teilen mit,\ndass bei einer Variable erwartet wird, dass sie unter Umständen auch den Wert null haben kann (@Nullable) bzw. dass eine Variable nicht den Wert null aufweisen darf (@NotNull bzw. @NonNull). In den folgenden Beispielen verwenden wir die Bibliothek org.jetbrains.annotations. Es gibt jedoch auch andere Bibliotheken mit ähnlichen Annotationen. Da die Verwendung von Dependencies hier noch nicht behandelt wurde (Maven-Teil), bleibt dies ein theoretischer Hinweis.\nHier ein Beispiel, wie Annotationen zu mehr null-Sicherheit führen können:\n1 2 3 4 5 6 7 8 9 10 11 12 public static void main(String[] args) { method(\"Lightning Moon\", new String[]{\"Lightning\", \"Moon\"}); method(null, null); } private static void method(@Nullable String fullName, @NotNull String[] names) { System.out.println(fullName.length()); if (names != null) { System.out.println(Arrays.toString(names)); } } In diesem Beispiel wird\ndie Annotation @Nullable verwendet, um mitzuteilen, dass bei der Variable fullName der Wert null möglich ist. In IntelliJ Idea (von Jetbrains) wird dadurch die Methode length() gelb unterstrichen, weil für die Variable fullName der null-Check fehlt. die Annotation @NotNull verwendet, um mitzuteilen, dass die Variable names nicht den Wert null haben darf. Leider fügt diese Möglichkeit kein Warning beim Aufruf von method(..., null) hinzu. Dafür aber wird eine IllegalArgumentException zur Laufzeit geworfen, falls ihr null beim Methodenaufruf zugewiesen wird. Optionals In Java gibt es auch ohne externe Bibliothek eine Möglichkeit anzugeben, dass eine Variable den Wert null „repräsentieren“ kann. Hierfür wurde die generische Klasse Optional\u003cT\u003e eingeführt.\nDie Idee dabei ist, dass Variablen, die den Wert null haben könnten, den Typ Optional\u003c...\u003e erhalten. Ein nullable String hätte zum Beispiel den Typ Optional\u003cString\u003e:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import java.util.Optional; public static void main(String[] args) { // Richtige Verwendung von Optionals: method(Optional.of(\"Hello World\")); // Repräsentiert den Wert \"Hello World\". method(Optional.empty()); // Repräsentiert den Wert null. // Falsche Verwendung von Optionals: method(Optional.of(null)); // Null-Pointer, weil `Optional.of()` beim Wert `null` einen Fehler wirft. method(null); // Null-Pointer, weil `isPresent()` nicht auf `null` aufgerufen werden kann. } private static void method(Optional\u003cString\u003e parameter) { System.out.println(\"Länge des Wortes: \" + (parameter.isPresent() ? parameter.get().length() : \"ist nicht definiert bzw. 0.\")); } Der Vorteil von Optionals ist, dass man als Entwickler:in gezwungen wird, einen null-Check zu machen:\n1 2 3 if (optional.isPresent()) { System.out.println(\"Wert ist: \" + optional.get()); } Denn\nwenn kein null-Check vor dem Aufrufen von .get() (was den eigentlichen Wert zurückgibt) gemacht wird , dann reklamiert deine Entwicklungsumgebung (IntelliJ/VS Code) automatisch mit einer Warnung. wenn .get() aufgerufen wird, und der Wert null repräsentiert, dann wird bereits an dieser Stelle eine NullPointerException geworfen. Optionals sind daher eine gängige Möglichkeit, Entwickler zu einer Prüfung auf null zu verpflichten.\nDiese Technik wird z.B. bei Streams häufig eingesetzt:\n1 2 3 4 5 6 7 8 9 10 11 12 13 Optional\u003cInteger\u003e firstResult = Stream .of(1, 2, 3, 4, 5) .filter(x -\u003e x % 6 == 0) .findFirst(); // Die Verwendung des Optionals zwingt einen dazu, den `.isPresent()`-Check zu machen, da es vorkommen könnte, // dass kein solches Element vorhanden ist, welches die Bedingung erfüllt: if (firstResult.isPresent()) { System.out.println(\"Erste Zahl aus der 6er-Reihe: \" + firstResult.get()); } else { System.out.println(\"Keine Zahl aus der 6er-Reihe präsent.\"); } Zusammenfassung zu Null-Safety Die NullPointerException ist eine der häufigsten Exceptions in Java-Programmen. Deswegen lohnt es sich, besser mit null-Werten umzugehen bzw. besser sichtbar zu machen, dass Werte null sein können.\nDrei der häufigsten Möglichkeiten, um mehr Null-Sicherheit in deinen Code zu bringen, sind:\nnull-Checks Annotationen wie @NotNull und @Nullable und Optional\u003c...\u003e-Typen zu verwenden. Exceptions testen Wie regulären Java Code kann man natürlich auch Exceptions mit JUnit testen. Eine ausführliche Erklärung dazu ist hier zu finden. Das folgende Beispiel testet anhand assertThrows() dass die Methode testCheckAge() mit einem Alter unter 18 eine EntryForbiddenException wirft.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class SaloonTest { @Test public void testCheckAge() { Saloon saloon = new Saloon(); // Testet mit einem Alter unter 18 int age = 17; assertThrows(EntryForbiddenException.class, () -\u003e { saloon.checkAge(age); }); // Testet mit dem Alter 18 (sollt keine Exception werfen) age = 18; try { saloon.checkAge(age); } catch (EntryForbiddenException e) { fail(\"Unexpected EntryForbiddenException thrown\"); } } } Exceptions: Keine Kontrollstrukturen, sondern Fehlerbehandlung Nach den Prinzipien von Clean Code sollten Ausnahmen (Exceptions) nicht als normaler Programmfluss eingesetzt werden. Exceptions dienen dazu, Ausnahmesituationen zu behandeln, die unerwartet auftreten und oft nicht durch reguläre Überprüfungen abgefangen werden können, wie z. B. Netzwerk- oder Datenbankfehler. Wenn Exceptions jedoch als Ersatz für reguläre Kontrollstrukturen (wie if-Abfragen) verwendet werden, wird der Code schwerer lesbar, schlechter wartbar und häufig ineffizienter.\nWarum sollten Exceptions nicht für den Programmfluss genutzt werden?\nLesbarkeit: Die Verwendung von Exceptions für den Programmfluss macht den Code schwer verständlich, da andere Entwickler erwarten, dass Ausnahmen nur in Fehlerfällen auftreten. Performance: Exceptions sind in der Regel ressourcenintensiver, da das Erstellen und Verarbeiten von Exception-Objekten zusätzliche Leistung kostet. Das ist besonders problematisch, wenn Exceptions in Schleifen verwendet werden. Debugging: Der Missbrauch von Exceptions erschwert das Debugging, weil oft unklar ist, ob eine Ausnahme durch einen Fehler oder absichtlich durch eine Programmlogik ausgelöst wurde. Log-Analyse: Wenn Exceptions für den Programmfluss verwendet werden, kann die Log-Analyse erschwert werden, da die Logs mit unnötigen Ausnahme-Einträgen überflutet werden. Dies macht es schwierig, echte Fehler zu identifizieren, da sich Logs mit Informationen über erwartete oder absichtlich ausgelöste Ausnahmen füllen. Beispiel für falsche Verwendung:\nIn diesem Beispiel wird eine Exception missbräuchlich zur Kontrolle des Programmflusses verwendet:\n1 2 3 4 5 try { int value = Integer.parseInt(\"abc\"); // Wirft NumberFormatException } catch (NumberFormatException e) { value = 0; // Setzt einen Standardwert } Richtige Verwendung: Besser ist es, die Eingabe vor der Verarbeitung zu validieren und Exceptions nur für unerwartete Fehler zu nutzen:\n1 2 3 4 5 6 7 8 String input = \"abc\"; int value; if (input.matches(\"\\\\d+\")) { // Überprüfung, ob die Eingabe numerisch ist value = Integer.parseInt(input); } else { value = 0; // Standardwert setzen, ohne eine Exception auszulösen } Fazit: Durch die Verwendung von Kontrollstrukturen anstelle von Exceptions für den Programmfluss wird der Code nicht nur sauberer und verständlicher, sondern auch effizienter und robuster.\nJetzt bist du dran. Löse bitte die Aufgaben zu Exception Handling in den Labs.\n","categories":"","description":"Modul #J5 - Exception Handling und Optionals\n","excerpt":"Modul #J5 - Exception Handling und Optionals\n","ref":"/docs/02_java/09_java-exception_handling/","tags":"","title":"Exception Handling und Optionals"},{"body":"Ziele Ich kenne die Schlüsselwörter try, catch, finally, throw und throws. Ich weiss, was “Unchecked” und “Checked” Exceptions sind. Ich kann auftretende Exceptions behandeln. Ich kann eigene Exceptions definieren und anwenden. Ich kenne Multicatch und Try-With-Resources und kann die beiden Konstrukte anwenden. Ich kenne die beiden Interfaces AutoCloseable und Closeable. Ich kenne eine Möglichkeit, um anzugeben, dass bestimmte Werte “nullable” bzw. nicht “nullable” sind. Ich verstehe, wie Optional meinen Code sicherer gegenüber null-Werten macht. Theorie / Einleitung In jeder Applikation können erwartete oder unerwartete Fehler auftreten. In Java werden solche Fehler durch das Exception Handling abgefangen. Ziel des Exception Handlings ist es, durch gezieltes Behandeln von auftretenden Exceptions, Abstürze der Anwendung zu verhindern. Jeder Softwareentwickler sollte sich bewusst sein, dass unbehandelte Exceptions eine Anwendung jederzeit beenden können.\nIn Java unterscheidet man zwischen zwei Arten von Fehlern:\nError: Dies sind nicht reparierbare Laufzeitfehler oder Hardware-Probleme, die zum Absturz des Programms führen. Exception: Dies sind Fehler oder unvorhergesehene Ereignisse, die während der Programmausführung auftreten und den normalen Ablauf stören. Eine Java-Applikation sollte nicht versuchen, Errors abzufangen, da diese Fehler in der Regel aufgrund abnormaler Bedingungen (wie z. B. zu wenig Speicher) auftreten und unter normalen Umständen nicht behoben werden können. Exceptions hingegen sind unerwartete Fehler, auf die das Programm reagieren muss.\nInnerhalb des Java Exception Handling unterscheiden wir zwei Arten von Exceptions:\nUnchecked Exceptions: Laufzeitfehler, die vom Compiler nicht erkannt werden. Checked Exceptions: Fehler, die vom Compiler zur Kompilierungszeit erkannt werden. Unchecked Exceptions sind oft Fehler, welche bei der Implementation übersehen werden. Der häufigste Laufzeitfehler ist die NullPointerException. Diese kann erst zur Laufzeit auftreten, da nur zur Laufzeit Objekte erzeugt werden und damit eine Referenz überhaupt null sein kann.\nDie einzige Möglichkeit, Laufzeitfehler abzuhandeln, ist “Safe Programming”. Das heisst, dass wir während der Implementation Prüfungen und sog. “Guards” im Code einbauen (z.B. prüfen, ob eine Referenz nicht null ist bevor wir darauf zugreifen) um sicherzustellen, dass solche Situationen zur Laufzeit nicht auftreten. Hier ein Beispiel mit einer NullPointerException: ```java public static void main(String[] args) { Person person = null; // könnte stattdessen auch eine Methode sein, welche null zurückgibt person.getName(); // hier wird eine NullPointerException geworfen, da person == null } ``` Checked Exceptions müssen entweder am Ort des Auftretens abgefangen oder an den Aufrufer der Methode weitergegeben werden. Dadurch wird die Verantwortung zur Behandlung der Exception an den Aufrufer weitergegeben.\nDazu ein kleines Beispiel:\n1 2 3 4 5 public static void main(String[] args) { PhoneBook phoneBook = new PhoneBook(); Person person = phoneBook.findByPhoneNumber(\"079 654 32 10\"); System.out.println(person.getName()); } Ohne die Implementierung der Methode findByPhoneNumber zu kennen, muss ein Softwareentwickler das zurückgelieferte Objekt vom Typ Person zunächst auf null prüfen. Schauen wir uns daher die Implementierung dieser Methode genauer an:\n1 2 3 4 5 6 7 8 9 10 11 12 public class PhoneBook { private List\u003cPerson\u003e entries = new ArrayList\u003c\u003e(); public Person findByPhoneNumber(String number) { for (Person p: this.entries) { if (p.getPhoneNumber().equals(number)) { return p; } } return null; } } Wie (vielleicht) erwartet, liefert die Methode null zurück, falls kein Eintrag mit der gesuchten Nummer gefunden wird. Dies führt in der Main-Methode im obigen Code auf der letzten Zeile zu einer NullPointerException, da die Referenz person auf null zeigt. Ein einfaches if-Statement kann hier Abhilfe schaffen:\n1 2 3 4 5 6 7 public static void main(String[] args) { AddressBook addressBook = new AddressBook(); Person person = addressBook.findByPhoneNumber(\"079 654 32 10\"); if (person != null) { System.out.println(person.getName()); } } Der Laufzeitfehler kann nun nicht mehr auftreten. Es stellt sich jedoch die Frage, ob diese Lösung zufriedenstellend ist. Prinzipiell sollten wir zumindest informiert werden, wenn keine Person mit dieser Nummer gefunden wird. Eine Möglichkeit besteht darin, ein else-Statement hinzuzufügen:\n1 2 3 4 5 6 7 8 9 public static void main(String[] args) { AddressBook addressBook = new AddressBook(); Person person = addressBook.findByPhoneNumber(\"079 654 32 10\"); if (person != null) { System.out.println(person.getName()); } else { System.out.println(\"Es wurde keine Person mit dieser Nummer gefunden!\"); } } Eine alternative Lösung könnte darin bestehen, das Null-Object-Pattern oder ein Optional-Objekt zu verwenden, um ein gültiges Objekt anstelle von null zurückzugeben.\ntry / catch / finally Um eine Checked Exception zu behandeln, muss der Codeblock, der die Exception erzeugen könnte, innerhalb eines try-Blocks stehen. Der Exception-Typ, der abgefangen werden soll, wird in den zugehörigen catch-Block geschrieben:\n1 2 3 4 5 try { // Code, welcher eine IOException werfen könnte } catch (IOException e) { // Code zur Behandlung der IOException } Ein try-Statement kann beliebig viele catch-Blöcke haben:\n1 2 3 4 5 6 7 8 9 try { FileReader fileReader = new FileReader(\"nonexistent.txt\"); // Hier würde noch Code kommen, welcher vom File lesen würde. } catch (FileNotFoundException e) { // Hier wird nun die FileNotFoundException gehandhabt System.err.println(\"File not found: \" + e.getMessage()); } catch (IOException e) { System.err.println(\"Error reading from file: \" + e.getMessage()); } Bei mehreren catch-Blöcken muss die spezifischste Exception stets zuerst stehen. Je weiter unten der catch-Block steht, desto allgemeiner ist die Exception, die abgefangen wird. Der Grund dafür ist, dass alle Checked Exceptions von der Klasse Exception abgeleitet sind. Befindet sich eine allgemeinere Exception weiter oben, wird der catch-Block der spezifischeren Exception weiter unten nicht mehr erreichbar sein.\n1 2 3 4 5 6 7 8 9 try { // Code, der eine Ausnahme auslösen könnte int[] zahlen = {1, 2, 3}; System.out.println(zahlen[5]); // Dies wird eine ArrayIndexOutOfBoundsException auslösen } catch (ArrayIndexOutOfBoundsException e) { // Spezifische Ausnahme System.out.println(\"Spezifische Ausnahme abgefangen: ArrayIndexOutOfBoundsException\"); } catch (Exception e) { // Allgemeinere Ausnahme System.out.println(\"Allgemeine Ausnahme abgefangen: Exception\"); } Ein try-Block (ob mit oder ohne catch-Block) kann zusätzlich einen finally-Block haben. Der finally-Block wird nach der Bearbeitung der Exception ausgeführt. Falls keine Exception aufgetreten ist, wird der Code im finally-Block direkt nach dem try-Block ausgeführt. Der finally-Block wird also auf jeden Fall ausgeführt. Er muss deshalb so geschrieben werden, das auf jeden Fall funktioniert, auch wenn der Try-Block nicht komplett ausgeführt wird oder der catch-Block nie ausgeführt wurde.\n1 2 3 4 5 6 7 try { // Code, welcher eine IOException werfen könnte } catch (IOException e) { // Code für die Abhandlung der IOException } finally { // Code, welcher nach der Abhandlung der Exception ausgeführt werden soll } Wie oben erwähnt, kann der catch-Block weggelassen werden:\n1 2 3 4 5 try { // Code, welcher eine beliebige Exception werfen könnte } finally { // Code, welcher nach der Abhandlung der Exception ausgeführt werden soll } Vorsicht bei return-Anweisungen innerhalb von catch- oder finally-Blöcken: Da der finally-Block immer zuletzt ausgeführt wird, ist ein return-Statement in diesem Block massgeblich für die Funktionalität.\nthrow / throws Eine Exception muss nicht immer dort behandelt werden, wo sie auftritt. Falls die Behandlung in andere Klassen verlagert werden soll, kann mit dem Schlüsselwort throws angegeben werden, dass die aufrufende Komponente die Exception abfangen und behandeln muss.\nDazu ein kurzes Beispiel:\n1 2 3 public class EntryForbiddenException extends Exception { // Optionale Erweiterungen für diese Exception } 1 2 3 4 5 6 7 8 public class Saloon { public void checkAge(int age) throws EntryForbiddenException { if (age \u003c 18) { throw new EntryForbiddenException(); } // Zusätzlicher Code ... } } 1 2 3 4 5 6 7 8 9 10 public class Main { public static void main(String[] args) { Saloon saloon = new Saloon(); try { saloon.checkAge(15); } catch (EntryForbiddenException e) { // Behandlung der EntryForbiddenException } } } In diesem Beispiel wird die Behandlung in die main-Methode verlagert. Exceptions können über beliebig viele Stufen weitergegeben werden. Wenn jedoch die “oberste” Stufe (hier die main-Methode) die Exception nicht behandelt, wird die Anwendung mit einer entsprechenden Fehlermeldung beendet, da die Exception unbehandelt bleibt.\nUmwandlung Laufzeitfehler in Checked Exception Mit der Lösung aus dem vorherigen Beispiel können wir noch nicht vollständig zufrieden sein. Anstatt den Rückgabewert der Methode findByPhoneNumber auf null zu prüfen, wählen wir nun einen anderen Ansatz:\nWir erweitern die Anwendung so, dass die Methode keine null-Werte mehr als Rückgabewert liefert. Da der Compiler jedoch einen Rückgabewert erzwingt, bleibt uns nur die Möglichkeit, eine Exception zu werfen, wenn kein Ergebnis gefunden wird.\nZu diesem Zweck definieren wir zuerst eine entsprechende Exception:\n1 2 3 public class PersonNotFoundException extends Exception { // Optional: Erweiterungen für die Exception } Diese Exception wird nun an der entsprechenden Stelle im Code geworfen. Die Methode wird zusätzlich mit dem Schlüsselwort throws versehen:\n1 2 3 4 5 6 7 8 9 10 11 12 public class PhoneBook { private List\u003cPerson\u003e entries = new ArrayList\u003c\u003e(); public Person findByPhoneNumber(String number) throws PersonNotFoundException { for (Person p: this.entries) { if (p.getPhoneNumber().equals(number)) { return p; } } throw new PersonNotFoundException(); } } Beim Aufruf der Methode sind wir nun gezwungen, die Exception zu behandeln:\n1 2 3 4 5 6 7 8 9 10 public static void main(String[] args) { AddressBook addressBook = new AddressBook(); try { Person person = addressBook.findByPhoneNumber(\"079 654 32 10\"); System.out.println(person.getName()); } catch (PersonNotFoundException e) { System.out.println(\"Es wurde keine Person mit dieser Nummer gefunden!\"); throw new RuntimeException(); } } Aus dem ursprünglichen Laufzeitfehler ist nun eine behandelte Exception geworden. Diese Implementierung vermeidet, wo immer möglich, die Rückgabe von null-Werten.\nMulti-Catch Seit Java 7 gibt es die Möglichkeit, mehrere Exceptions in einem sogenannten Multi-Catch zu behandeln. Schauen wir uns das folgende Beispiel an:\nOhne Multi-Catch 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public static void main(String[] args) { String filename = \"example.txt\"; BufferedReader reader = null; try { reader = new BufferedReader(new FileReader(filename)); String line; while ((line = reader.readLine()) != null) { System.out.println(line); } } catch (IOException e) { System.err.println(\"Ein-/Ausgabefehler beim Lesen der Datei: \" + e.getMessage()); } catch (ParseException e) { System.err.println(\"Fehler beim Parsen der Daten: \" + e.getMessage()); } finally { reader.close(); } } Mit Multi-Catch 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public static void main(String[] args) { String filename = \"example.txt\"; BufferedReader reader = null; try { reader = new BufferedReader(new FileReader(filename)); String line; while ((line = reader.readLine()) != null) { System.out.println(line); } } catch (IOException | ParseException e) { System.err.println(\"Ein-/Ausgabefehler oder Fehler beim Parsen der Daten: \" + e.getMessage()); } finally { reader.close(); } } Die beiden Exceptions werden hier in einem einzigen catch-Block zusammengefasst. Zu beachten ist, dass die Exceptions innerhalb eines Multi-Catch nicht in einer Vererbungsbeziehung zueinander stehen dürfen. Das bedeutet, dass ihre Basistypen unterschiedlich sein müssen.\nTry-With-Resources Ebenfalls seit Java 7 gibt es die Möglichkeit für automatisches Ressourcen-Management.\nBetrachten wir dazu zuerst ein Beispiel ohne automatisches Ressourcen-Management:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public static String readFirstLine(String path) { BufferedReader br = null; try { br = new BufferedReader(new FileReader(path)); return br.readLine(); } catch (IOException e) { // handle or rethrow } finally { try { if (br != null) { br.close(); } } catch (IOException e) { // ignore } } return \"\"; } Der finally-Block ist notwendig, um die verwendete Ressource des BufferedReaders zu schliessen.\nDa beim Schliessen eine IOException auftreten kann, benötigen wir im finally-Blocks einen zusätzlichen try-catch-Block.\nBetrachten wir nun das gleiche Beispiel mit automatischem Ressourcen-Management:\n1 2 3 4 5 6 7 8 public static String readFirstLine(String path) { try (FileReader fr = new FileReader(path); BufferedReader br = new BufferedReader(fr)) { return br.readLine(); } catch (IOException e) { // handle or rethrow } return \"\"; } Wie wir sehen, entfällt der finally-Block zum Schliessen der Ressourcen vollständig. Die Ressourcen FileReader und BufferedReader werden automatisch geschlossen. Dies geschieht im Hintergrund über die Methode close, die vom Interface AutoCloseable bereitgestellt wird. In einem try-with-resources-Statement dürfen daher nur Objekte verwendet werden, die das genannte Interface implementieren. Das Closeable-Interface stellt dabei die Abwärtskompatibilität zu älteren Java-Versionen sicher, da es ebenfalls die close-Methode definiert. Grundsätzlich sollte das Closeable-Interface für IO-Streams verwendet werden, da es mit IOException arbeitet.\nDas Schliessen der Ressourcen erfolgt immer in umgekehrter Reihenfolge. In unserem Beispiel wird also zuerst der BufferedReader geschlossen und danach der FileReader. Die Verkettung von Ressourcen innerhalb eines try-with-resources-Statements sollte vermieden werden. Besser ist die getrennte Deklaration wie im obigen Beispiel.\nNull-Safety Ein häufiger Laufzeitfehler in Java ist die NullPointerException. Diese Exception tritt auf, wenn\neine Methode auf einem null-Objekt aufgerufen wird, versucht wird, auf ein Feld (Variable) eines null-Objekts zuzugreifen. Oft wird schlicht übersehen, dass eine bestimmte Variable null sein könnte:\n1 2 3 4 5 6 7 public static void main(String[] args) { method(null); } private static void method(String parameter) { System.out.println(\"Länge des Wortes: \" + parameter.length()); } Im obigen Beispiel führt der Versuch, die Methode length() auf einem null-Objekt aufzurufen, zur NullPointerException.\nHier werden zwei typische Ursachen für das Auftreten einer NullPointerException deutlich:\nEiner Variable (hier parameter) wird null zugewiesen/übergeben, was in manchen Fällen unerwartet ist. Es wird vergessen zu prüfen, dass eine Variable den Wert null haben könnte. Diese beiden Fälle können in Java auf verschiedene Arten abgefangen werden.\nnull durch Check abfangen Die offensichtlichste Möglichkeit, NullPointerExceptions zu vermeiden, ist die Verwendung von null-Checks.\nIm folgenden Beispiel verhindern wir null, indem wir die Variable zu Beginn der Methode prüfen und eine Exception werfen, falls die Variable null ist:\n1 2 3 4 5 6 private static void method(String parameter) throws IllegalArgumentException { if (parameter == null) { throw new IllegalArgumentException(\"Parameter parameter must not be null.\"); } System.out.println(\"Länge des Wortes: \" + parameter.length()); } In diesem Beispiel ist sichergestellt, dass der Wert null für das Argument parameter nicht erlaubt ist. Ein Nachteil dieser Lösung ist, dass Entwickler von aussen nicht direkt erkennen können, dass null-Werte unzulässig sind. Diesen Fall könnte man stattdessen besser mit einer @NotNull-Annotation abdecken, wie später beschrieben.\nManchmal jedoch sollen null-Werte zulässig sein. In solchen Fällen verwenden wir Bedingungen, um den richtigen Code auszuführen:\n1 2 3 4 5 6 7 private static void method(String parameter) { if (parameter != null) { System.out.println(\"Länge des Wortes: \" + parameter.length()); } else { System.out.println(\"Länge fes Wortes: ist nicht definiert bzw. 0.\"); } } Um hier null-Sicherheit zu garantieren, wurden einige zusätzliche Zeilen eingefügt. In solchen Fällen kann auch der Ternary-Operator nützlich sein:\n1 2 3 4 private static void method(String parameter) { System.out.println(\"Länge des Wortes: \" + (parameter != null ? parameter.length() : \"ist nicht definiert bzw. 0.\")); } Der Ternary-Ausdruck ist hierbei der folgende:\n1 parameter != null ? parameter.length() : \"ist nicht definiert bzw. 0.\" Dieser Ausdruck gibt parameter.length() zurück, wenn parameter != null ist. Ansonsten gibt er den String \"ist nicht definiert bzw. 0.\" zurück.\nGanz allgemein ist der Ternary-Ausdruck wie folgt aufgebaut:\n1 Bedingung ? Wert-wenn-Bedingung-true : Wert-wenn-Bedingung-false Annotationen wie @NotNull und @Nullable Sicherlich ist dir schon einmal die Angabe @Nullable bei einem Argument von einer Methode aus einer externen Library aufgefallen.\nSolche Annotationen teilen mit,\ndass bei einer Variable erwartet wird, dass sie unter Umständen auch den Wert null haben kann (@Nullable) bzw. dass eine Variable nicht den Wert null aufweisen darf (@NotNull bzw. @NonNull). In den folgenden Beispielen verwenden wir die Bibliothek org.jetbrains.annotations. Es gibt jedoch auch andere Bibliotheken mit ähnlichen Annotationen. Da die Verwendung von Dependencies hier noch nicht behandelt wurde (Maven-Teil), bleibt dies ein theoretischer Hinweis.\nHier ein Beispiel, wie Annotationen zu mehr null-Sicherheit führen können:\n1 2 3 4 5 6 7 8 9 10 11 12 public static void main(String[] args) { method(\"Lightning Moon\", new String[]{\"Lightning\", \"Moon\"}); method(null, null); } private static void method(@Nullable String fullName, @NotNull String[] names) { System.out.println(fullName.length()); if (names != null) { System.out.println(Arrays.toString(names)); } } In diesem Beispiel wird\ndie Annotation @Nullable verwendet, um mitzuteilen, dass bei der Variable fullName der Wert null möglich ist. In IntelliJ Idea (von Jetbrains) wird dadurch die Methode length() gelb unterstrichen, weil für die Variable fullName der null-Check fehlt. die Annotation @NotNull verwendet, um mitzuteilen, dass die Variable names nicht den Wert null haben darf. Leider fügt diese Möglichkeit kein Warning beim Aufruf von method(..., null) hinzu. Dafür aber wird eine IllegalArgumentException zur Laufzeit geworfen, falls ihr null beim Methodenaufruf zugewiesen wird. Optionals In Java gibt es auch ohne externe Bibliothek eine Möglichkeit anzugeben, dass eine Variable den Wert null „repräsentieren“ kann. Hierfür wurde die generische Klasse Optional\u003cT\u003e eingeführt.\nDie Idee dabei ist, dass Variablen, die den Wert null haben könnten, den Typ Optional\u003c...\u003e erhalten. Ein nullable String hätte zum Beispiel den Typ Optional\u003cString\u003e:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import java.util.Optional; public static void main(String[] args) { // Richtige Verwendung von Optionals: method(Optional.of(\"Hello World\")); // Repräsentiert den Wert \"Hello World\". method(Optional.empty()); // Repräsentiert den Wert null. // Falsche Verwendung von Optionals: method(Optional.of(null)); // Null-Pointer, weil `Optional.of()` beim Wert `null` einen Fehler wirft. method(null); // Null-Pointer, weil `isPresent()` nicht auf `null` aufgerufen werden kann. } private static void method(Optional\u003cString\u003e parameter) { System.out.println(\"Länge des Wortes: \" + (parameter.isPresent() ? parameter.get().length() : \"ist nicht definiert bzw. 0.\")); } Der Vorteil von Optionals ist, dass man als Entwickler:in gezwungen wird, einen null-Check zu machen:\n1 2 3 if (optional.isPresent()) { System.out.println(\"Wert ist: \" + optional.get()); } Denn\nwenn kein null-Check vor dem Aufrufen von .get() (was den eigentlichen Wert zurückgibt) gemacht wird , dann reklamiert deine Entwicklungsumgebung (IntelliJ/VS Code) automatisch mit einer Warnung. wenn .get() aufgerufen wird, und der Wert null repräsentiert, dann wird bereits an dieser Stelle eine NullPointerException geworfen. Optionals sind daher eine gängige Möglichkeit, Entwickler zu einer Prüfung auf null zu verpflichten.\nDiese Technik wird z.B. bei Streams häufig eingesetzt:\n1 2 3 4 5 6 7 8 9 10 11 12 13 Optional\u003cInteger\u003e firstResult = Stream .of(1, 2, 3, 4, 5) .filter(x -\u003e x % 6 == 0) .findFirst(); // Die Verwendung des Optionals zwingt einen dazu, den `.isPresent()`-Check zu machen, da es vorkommen könnte, // dass kein solches Element vorhanden ist, welches die Bedingung erfüllt: if (firstResult.isPresent()) { System.out.println(\"Erste Zahl aus der 6er-Reihe: \" + firstResult.get()); } else { System.out.println(\"Keine Zahl aus der 6er-Reihe präsent.\"); } Zusammenfassung zu Null-Safety Die NullPointerException ist eine der häufigsten Exceptions in Java-Programmen. Deswegen lohnt es sich, besser mit null-Werten umzugehen bzw. besser sichtbar zu machen, dass Werte null sein können.\nDrei der häufigsten Möglichkeiten, um mehr Null-Sicherheit in deinen Code zu bringen, sind:\nnull-Checks Annotationen wie @NotNull und @Nullable und Optional\u003c...\u003e-Typen zu verwenden. Exceptions testen Wie regulären Java Code kann man natürlich auch Exceptions mit JUnit testen. Eine ausführliche Erklärung dazu ist hier zu finden. Das folgende Beispiel testet anhand assertThrows() dass die Methode testCheckAge() mit einem Alter unter 18 eine EntryForbiddenException wirft.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class SaloonTest { @Test public void testCheckAge() { Saloon saloon = new Saloon(); // Testet mit einem Alter unter 18 int age = 17; assertThrows(EntryForbiddenException.class, () -\u003e { saloon.checkAge(age); }); // Testet mit dem Alter 18 (sollt keine Exception werfen) age = 18; try { saloon.checkAge(age); } catch (EntryForbiddenException e) { fail(\"Unexpected EntryForbiddenException thrown\"); } } } Exceptions: Keine Kontrollstrukturen, sondern Fehlerbehandlung Nach den Prinzipien von Clean Code sollten Ausnahmen (Exceptions) nicht als normaler Programmfluss eingesetzt werden. Exceptions dienen dazu, Ausnahmesituationen zu behandeln, die unerwartet auftreten und oft nicht durch reguläre Überprüfungen abgefangen werden können, wie z. B. Netzwerk- oder Datenbankfehler. Wenn Exceptions jedoch als Ersatz für reguläre Kontrollstrukturen (wie if-Abfragen) verwendet werden, wird der Code schwerer lesbar, schlechter wartbar und häufig ineffizienter.\nWarum sollten Exceptions nicht für den Programmfluss genutzt werden?\nLesbarkeit: Die Verwendung von Exceptions für den Programmfluss macht den Code schwer verständlich, da andere Entwickler erwarten, dass Ausnahmen nur in Fehlerfällen auftreten. Performance: Exceptions sind in der Regel ressourcenintensiver, da das Erstellen und Verarbeiten von Exception-Objekten zusätzliche Leistung kostet. Das ist besonders problematisch, wenn Exceptions in Schleifen verwendet werden. Debugging: Der Missbrauch von Exceptions erschwert das Debugging, weil oft unklar ist, ob eine Ausnahme durch einen Fehler oder absichtlich durch eine Programmlogik ausgelöst wurde. Log-Analyse: Wenn Exceptions für den Programmfluss verwendet werden, kann die Log-Analyse erschwert werden, da die Logs mit unnötigen Ausnahme-Einträgen überflutet werden. Dies macht es schwierig, echte Fehler zu identifizieren, da sich Logs mit Informationen über erwartete oder absichtlich ausgelöste Ausnahmen füllen. Beispiel für falsche Verwendung:\nIn diesem Beispiel wird eine Exception missbräuchlich zur Kontrolle des Programmflusses verwendet:\n1 2 3 4 5 try { int value = Integer.parseInt(\"abc\"); // Wirft NumberFormatException } catch (NumberFormatException e) { value = 0; // Setzt einen Standardwert } Richtige Verwendung: Besser ist es, die Eingabe vor der Verarbeitung zu validieren und Exceptions nur für unerwartete Fehler zu nutzen:\n1 2 3 4 5 6 7 8 String input = \"abc\"; int value; if (input.matches(\"\\\\d+\")) { // Überprüfung, ob die Eingabe numerisch ist value = Integer.parseInt(input); } else { value = 0; // Standardwert setzen, ohne eine Exception auszulösen } Fazit: Durch die Verwendung von Kontrollstrukturen anstelle von Exceptions für den Programmfluss wird der Code nicht nur sauberer und verständlicher, sondern auch effizienter und robuster.\nJetzt bist du dran. Löse bitte die Aufgaben zu Exception Handling in den Labs.\n","categories":"","description":"Modul #J5 - Exception Handling und Optionals\n","excerpt":"Modul #J5 - Exception Handling und Optionals\n","ref":"/de/docs/02_java/09_java-exception_handling/","tags":"","title":"Exception Handling und Optionals"},{"body":"Die folgenden Aufgaben bestehen zum Teil aus Exception Handling. Behandle die Exception also auch so, wie es in der Theorie erklärt wurde.\nAufgabe 1: File Reader Hier findest du eine Datei, welche eine Liste mit ungefähr 466 Tausend englischen Wörtern enthält.\nSchreibe eine Anwendung, welche diese Wörter einlesen kann, und schreibe jeweils eine Methode für die folgenden Aufgaben:\nZähle alle Wörter in dieser Liste Zähle alle Wörter, welche den Buchstaben Q benutzen Gib alle Sonderzeichen zurück, welche in der Liste vorkommen (jedes Zeichen wird nur einmal zurückgegeben) 2 weitere Methoden deiner Wahl Implementiere vorher ein Interface, um deine Methoden zu definieren. Zudem wird erwartet, dass ein eigenes Testing (wie in J4 Testing gelernt) zu der Umsetzung gehört.\nAufgabe 2: File Writing Die Verwendung von System.out.println() hat das Problem, dass nach einem Neustart der Applikation alle Logs aus der Konsole verschwinden, dies kann mit der Zeit mühsam werden. Schreibe eine Klasse mit mindestens einer öffentlichen Methode, welcher man einen Text als Parameter gibt. Die Methode soll diesen Text zuerst in eine Datei mit dem Namen application.log speichern und nachher mit System.out.println() in die Konsole schreiben. Achte auch hier wieder auf ein entsprechendes Exception Handling. Zudem wird erwartet, dass ein eigenes Testing (wie in J4 Testing gelernt) zu der Umsetzung gehört.\nAufgabe 3: ParseInt Wenn wir Zahlen von einem User über die Konsole entgegennehmen wollen, kann man scanner.nextLine() brauchen. Wir können aber nie sicher sein, ob es sich bei der Eingabe wirklich um eine Zahl handelt. Darum müssen wir mit einem Exception Handling die Programmlogik vor einem solchen Fall schützen.\nSchreibe eine Anwendung, welche den User einzeln für zwei Zahlen fragt und diese dann entweder addiert, subtrahiert, multipliziert, oder dividiert. Die Auswahl der Rechnungsmethode kann zufällig oder durch den Benutzer erfolgen. Zudem wird erwartet, dass ein eigenes Testing (wie in J4 Testing gelernt) zu der Umsetzung gehört.\nHier kannst du zurück zur Theorie.\n","categories":"","description":"Aufgaben zu Modul #J5 - [Exception Handling](../../../docs/02_java/09_java-exception_handling)\n","excerpt":"Aufgaben zu Modul #J5 - [Exception …","ref":"/labs/02_java/09_java-exception_handling/","tags":"","title":"Java Exercises - Exception Handling"},{"body":"Die folgenden Aufgaben bestehen zum Teil aus Exception Handling. Behandle die Exception also auch so, wie es in der Theorie erklärt wurde.\nAufgabe 1: File Reader Hier findest du eine Datei, welche eine Liste mit ungefähr 466 Tausend englischen Wörtern enthält.\nSchreibe eine Anwendung, welche diese Wörter einlesen kann, und schreibe jeweils eine Methode für die folgenden Aufgaben:\nZähle alle Wörter in dieser Liste Zähle alle Wörter, welche den Buchstaben Q benutzen Gib alle Sonderzeichen zurück, welche in der Liste vorkommen (jedes Zeichen wird nur einmal zurückgegeben) 2 weitere Methoden deiner Wahl Implementiere vorher ein Interface, um deine Methoden zu definieren. Zudem wird erwartet, dass ein eigenes Testing (wie in J4 Testing gelernt) zu der Umsetzung gehört.\nAufgabe 2: File Writing Die Verwendung von System.out.println() hat das Problem, dass nach einem Neustart der Applikation alle Logs aus der Konsole verschwinden, dies kann mit der Zeit mühsam werden. Schreibe eine Klasse mit mindestens einer öffentlichen Methode, welcher man einen Text als Parameter gibt. Die Methode soll diesen Text zuerst in eine Datei mit dem Namen application.log speichern und nachher mit System.out.println() in die Konsole schreiben. Achte auch hier wieder auf ein entsprechendes Exception Handling. Zudem wird erwartet, dass ein eigenes Testing (wie in J4 Testing gelernt) zu der Umsetzung gehört.\nAufgabe 3: ParseInt Wenn wir Zahlen von einem User über die Konsole entgegennehmen wollen, kann man scanner.nextLine() brauchen. Wir können aber nie sicher sein, ob es sich bei der Eingabe wirklich um eine Zahl handelt. Darum müssen wir mit einem Exception Handling die Programmlogik vor einem solchen Fall schützen.\nSchreibe eine Anwendung, welche den User einzeln für zwei Zahlen fragt und diese dann entweder addiert, subtrahiert, multipliziert, oder dividiert. Die Auswahl der Rechnungsmethode kann zufällig oder durch den Benutzer erfolgen. Zudem wird erwartet, dass ein eigenes Testing (wie in J4 Testing gelernt) zu der Umsetzung gehört.\nHier kannst du zurück zur Theorie.\n","categories":"","description":"Aufgaben zu Modul #J5 - [Exception Handling](../../../docs/02_java/09_java-exception_handling)\n","excerpt":"Aufgaben zu Modul #J5 - [Exception …","ref":"/de/labs/02_java/09_java-exception_handling/","tags":"","title":"Java Exercises - Exception Handling"},{"body":"Ziele Ich weiss, wofür Methoden sind. Ich weiss, wie eine Methode aufgebaut ist. Ich weiss, wie eine Methode mit Parameter aufgebaut ist. Ich weiss, wie eine Methode mit Rückgabewert aufgebaut ist. Ich kann Methoden gezielt in meinem Programm einsetzen. Was sind Methoden? In Java sind Methoden Blöcke von Code, die spezifische Aufgaben ausführen. Sie dienen zur Organisation und Wiederverwendung von Code. Methoden ermöglichen es, eine Gruppe von Anweisungen in einem eigenen Codeblock zu kapseln und diesen Codeblock durch einen Methodenaufruf auszuführen.\nAufbau einer Methode Eine Methode in Java ist wie folgt aufgebaut:\n1 2 3 Rückgabetyp methodName(Parameterliste) { // Methoden Code } Rückgabetyp: Dieser Typ gibt an, welchen Datentyp die Methode zurückgibt. Wenn die Methode keinen Rückgabewert hat, wird void verwendet. methodName: Der Name der Methode, über den sie aufgerufen wird. Parameterliste: Hier werden die Parameter aufgelistet, die die Methode erwartet. Methoden Code: Dies ist der Codeblock, der die spezifische Aufgabe der Methode ausführt. Methoden mit Parametern Methoden können auch Parameter akzeptieren, die beim Aufruf übergeben werden. Hier ist ein Beispiel:\n1 2 3 void greetUser(String name) { System.out.println(\"Hallo, \" + name + \"!\"); } In diesem Fall erwartet die Methode greetUser einen String-Parameter, der den Namen des Benutzers enthält.\nLernvideo Wenn du dir die Erklärung noch mit einem Video genauer anschauen möchtest, empfiehlt dir das Praxisbildner-Team dieses Video.\nMethoden mit Rückgabewert Methoden können einen Wert zurückgeben. Hier ist ein Beispiel:\n1 2 3 4 int addiere(int a, int b) { int summe = a + b; return summe; } In diesem Fall gibt die Methode addiere die Summe der beiden übergebenen Zahlen als int zurück.\nWieso brauche ich Methoden? Methoden bieten mehrere Vorteile, die deinen Code übersichtlicher und effizienter machen:\nWiederverwendbarkeit: Anstatt denselben Code mehrfach zu schreiben, kannst du ihn in einer Methode bündeln und diese Methode mehrmals aufrufen. Weniger Code-Duplikate: Durch das Verwenden von Methoden reduzierst du Duplikate im Code, was diesen leichter wartbar und fehlerresistenter macht. Sprechende Methodennamen: Methoden können selbsterklärende Namen haben, was den Code für andere (und dich selbst) verständlicher macht. Logische Trennung: Methoden helfen dabei, den Code in logische Abschnitte zu unterteilen, sodass jede Methode eine spezifische Aufgabe übernimmt. Beispiel: Division ohne Methoden Stell dir vor, du möchtest mehrere Zahlen dividieren und dabei vor jeder Division prüfen, ob der Divisor 0 ist. Ohne Methoden sieht der Code vielleicht so aus:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public static void main(String[] args) { Random random = new Random(); int a = random.nextInt(11); // eine zufällige Zahl zwischen 0 und 10 int b = random.nextInt(11); int c = random.nextInt(11); //Vor jeder Rechnung muss überprüft werden, ob der Divisor 0 ist if (b != 0) { //ist b == 0? int ergebnis1 = a / b; if (c != 0) { //ist c == 0? int ergebnis2 = ergebnis1 / c; System.out.println(\"Ergebnis: \" + ergebnis2); } else { System.out.println(\"Division durch 0 nicht erlaubt.\"); //falls c == 0 ist } } else { System.out.println(\"Division durch 0 nicht erlaubt.\"); //falls b == 0 ist } } Wie du hier sehen kannst, ist der Code schwierig zu lesen, da die Divisionen verstreut sind. Im Code muss man den Check auf 0 mehrmals definieren. Ebenfalls muss die gleiche Fehlermeldung mehrmals definiert werden. Möchtest du eine weitere Division durchführen, musst du den Check und die Fehlermeldung noch mal schreiben. Das kannst du dir alles durch eine Methode ersparen.\nBeispiel: Division mit Methoden Wenn du eine Methode erstellst, um die Division durchzuführen und die Prüfung auf 0 zu gruppieren, sieht der Code wesentlich sauberer aus:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public static void main(String[] args) { Random random = new Random(); int a = random.nextInt(11); // eine zufällige Zahl zwischen 0 und 10 int b = random.nextInt(11); int c = random.nextInt(11); int ergebnis1 = divide(a, b); int ergebnis2 = divide(ergebnis1, c); System.out.println(\"Ergebnis: \" + ergebnis2); } public int divide(int numerator, int denominator) { if (denominator == 0) { System.out.println(\"Division durch 0 nicht erlaubt.\"); return 0; } return numerator / denominator; } Durch die Verwendung einer Methode sparst du nicht nur Codezeilen, sondern stellst auch sicher, dass du die Prüfung auf 0 nur einmal schreibst und sie dennoch überall angewendet wird, wo es nötig ist. Das Gleiche gilt für die Fehlermeldung. Du kannst diese Methode so oft wie du willst für andere Zahlen aufrufen. Für den Leser ist auch klar, was in diesem Code passiert, da es einen sprechenden Namen (divide) hat.\nLernvideo Wenn du dir die Erklärung noch mit einem Video genauer anschauen möchtest, empfiehlt dir das Praxisbildner-Team dieses Video.\nJetzt bist du dran. Löse bitte die Aufgabe 5 in den Labs.\n","categories":"","description":"Modul #J1\n","excerpt":"Modul #J1\n","ref":"/de/docs/02_java/03_java-grundlagen/09_methods/","tags":"","title":"Methoden"},{"body":"Wenn du ein Backend schreibst - was du mit Spring in den meisten Fällen tust, dann möchtest du deinen Code auch ausführen können. Um deine HTTP-Schnittstellen zu triggern, musst du entsprechende HTTP-Anfragen an dein Backend schicken. Dies kannst du mit HTTP-Clients tun. Es gibt einen Haufen solcher Programme. In diesem Kapitel zeigen wir dir ein paar.\nWarum werden REST-Schnittstellen getestet? Das Testen von REST-Schnittstellen trägt dazu bei, die Qualität, Sicherheit und Leistung von APIs zu gewährleisten, sodass sie zuverlässig und effektiv genutzt werden können.\nSwagger Das erste Tool, das wir vorstellen, um HTTP-/REST-Schnittstellen zu triggern (und zu testen) ist Swagger. Das tolle an Swagger ist, dass viele Backends (auch Spring) dieses bereits integriert haben, ohne dass du ein weiteres Programm installieren musst.\nSwagger ist ein Open-Source-Framework, das zur Dokumentation und zum Testen von “RESTful” Webdiensten verwendet wird. REST steht für “Representational State Transfer” und bezieht sich auf ein Architekturstil für die Entwicklung von Netzwerkanwendungen. Swagger bietet Werkzeuge und Spezifikationen, die Entwicklern, Architekten und anderen Beteiligten dabei helfen, RESTful APIs zu entwerfen, zu erstellen, zu dokumentieren und die Interoperabilität zwischen verschiedenen Tools und Plattformen zu fördern. Es erleichtert die Kommunikation zwischen Frontend- und Backend-Entwicklern, da die API-Spezifikationen in einer einheitlichen, leicht verständlichen Form vorliegen und Beispiele zeigt, wie eine REST-Schnittstelle aufgerufen werden kann mit welchen Parametern.\nMit Spring Boot 3 wird neu nur noch einen Dependency benötigt, damit der Swagger läuft:\n1 2 3 4 5 \u003cdependency\u003e \u003cgroupId\u003eorg.springdoc\u003c/groupId\u003e \u003cartifactId\u003espringdoc-openapi-starter-webmvc-ui\u003c/artifactId\u003e \u003cversion\u003e2.2.0\u003c/version\u003e \u003c/dependency\u003e Wenn man nun die Applikation startet, kann man auf die URL http://localhost:8080/swagger-ui/index.html# zugreifen. Dort sieht man dan folgendes:\nSwaggerOverview\nAuf dem untenstehenden Bild kann man die API-Schnittstelle von einer GET-Anfrage sehen. Mit einem Klick auf den Try it out-Button kann man nachher diese Anfrage ausprobieren.\nNun erscheint ein grosser blauer Button mit der Aufschrift Execute. Auf Knopfdruck wird die GET-Anfrage gesendet und die Antwort wird nach Erhalt angezeigt.\nWas bei den GET-Anfragen galt, gilt auch für POST-Requests. Im Unterschied zur vorherigen Schnittstelle muss bei dieser zusätzlich ein Request Body im JSON-Format angegeben werden.\nMöchte man z.B. GetById ausführen, dann muss möglicherweise auch noch eine ID angegeben werden.\nDas Json für den Request-Body kann auch hier erst nach einem Klick auf “Try it out” spezifiziert werden:\nWenn deine API Zugriffsbeschränkungen oder Authentifizierungsschichten implementiert, ist eine Anpassung der Swagger-Konfiguration notwendig, um diese Sicherheitsmechanismen zu berücksichtigen.\nKonfigurationen von Swagger können in verschiedenen Aspekten angepasst werden. Hier sind einige allgemeine Anpassungen:\nPaketfilter für die API-Endpunkte festlegen .apis() API-Endpunkt-Pfade filtern .paths() Allgemeine API-Informationen konfigurieren .apiInfo() Globale Sicherheitsdefinitionen hinzufügen .securitySchemes(), .securityContexts() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 @Configuration public class SwaggerConfig { @Bean public Docket api() { return new Docket(DocumentationType.SWAGGER_2) .select() .apis(RequestHandlerSelectors.any()) .paths(PathSelectors.any()) .build() .apiInfo(apiInfo()); } private ApiInfo apiInfo() { ApiInfo apiInfo = new ApiInfo( \"Song API\", \"Swagger API for self project\", \"1.0\", \"\", \"Cédric rohrbach\", \"\", \"\" ); return apiInfo; } } IntelliJ HTTP Client Der IntelliJ HTTP Client ist ein eingebauter HTTP-Client, der Entwicklern ermöglicht, HTTP-Anfragen an Webdienste oder RESTful-APIs zu senden und die Antworten zu überprüfen. Dies ist nützlich, um Web-APIs schnell zu testen, ohne eine separate Anwendung von Drittanbietern installieren zu müssen.\nDamit man den HTTP Client verwenden kann, muss man zuerst ein solches File erstellen. Dies kann wie folgt getan werden:\nEinige Entwickler legen die HTTP-Dateien in einem separaten Ordner wie “http” oder “requests” im Hauptverzeichnis ihres Projekts ab. Andere bevorzugen es, die HTTP-Dateien im Verzeichnis des Moduls zu speichern, das sie verwenden.\nIm File kann man zum Beispiel eine Get Abfrage nach folgenden Schema erstellen.\n1 2 GET http://localhost:8080/api/student/subjects Accept: application/json Das api/student/subjects ist das RequestMapping, welchen in den Controllern festgelegt wurden für den API-Schnittpunkt.\nEine POST- oder PUT-Anfrage, welchen einen Request-Body benötigt, ist wie folgt aufgebaut:\n1 2 3 4 5 6 7 POST http://localhost:8080/api/admin/subjects Content-Type: application/json { \"key1\": \"value1\", \"key2\": \"value2\" } Wenn man nun die Applikation startet, kann man diese HTTP-Anfrage ausführen und sehen, was die Schnittstelle antwortet.\n","categories":"","description":"Modul #J8 - Spring Framework - Testing von REST-Schnittstellen\n","excerpt":"Modul #J8 - Spring Framework - Testing von REST-Schnittstellen\n","ref":"/docs/02_java/12_spring-framework/09_rest-testing/","tags":"","title":"Testing von REST-Schnittstellen"},{"body":"Wenn du ein Backend schreibst - was du mit Spring in den meisten Fällen tust, dann möchtest du deinen Code auch ausführen können. Um deine HTTP-Schnittstellen zu triggern, musst du entsprechende HTTP-Anfragen an dein Backend schicken. Dies kannst du mit HTTP-Clients tun. Es gibt einen Haufen solcher Programme. In diesem Kapitel zeigen wir dir ein paar.\nWarum werden REST-Schnittstellen getestet? Das Testen von REST-Schnittstellen trägt dazu bei, die Qualität, Sicherheit und Leistung von APIs zu gewährleisten, sodass sie zuverlässig und effektiv genutzt werden können.\nSwagger Das erste Tool, das wir vorstellen, um HTTP-/REST-Schnittstellen zu triggern (und zu testen) ist Swagger. Das tolle an Swagger ist, dass viele Backends (auch Spring) dieses bereits integriert haben, ohne dass du ein weiteres Programm installieren musst.\nSwagger ist ein Open-Source-Framework, das zur Dokumentation und zum Testen von “RESTful” Webdiensten verwendet wird. REST steht für “Representational State Transfer” und bezieht sich auf ein Architekturstil für die Entwicklung von Netzwerkanwendungen. Swagger bietet Werkzeuge und Spezifikationen, die Entwicklern, Architekten und anderen Beteiligten dabei helfen, RESTful APIs zu entwerfen, zu erstellen, zu dokumentieren und die Interoperabilität zwischen verschiedenen Tools und Plattformen zu fördern. Es erleichtert die Kommunikation zwischen Frontend- und Backend-Entwicklern, da die API-Spezifikationen in einer einheitlichen, leicht verständlichen Form vorliegen und Beispiele zeigt, wie eine REST-Schnittstelle aufgerufen werden kann mit welchen Parametern.\nMit Spring Boot 3 wird neu nur noch einen Dependency benötigt, damit der Swagger läuft:\n1 2 3 4 5 \u003cdependency\u003e \u003cgroupId\u003eorg.springdoc\u003c/groupId\u003e \u003cartifactId\u003espringdoc-openapi-starter-webmvc-ui\u003c/artifactId\u003e \u003cversion\u003e2.2.0\u003c/version\u003e \u003c/dependency\u003e Wenn man nun die Applikation startet, kann man auf die URL http://localhost:8080/swagger-ui/index.html# zugreifen. Dort sieht man dan folgendes:\nSwaggerOverview\nAuf dem untenstehenden Bild kann man die API-Schnittstelle von einer GET-Anfrage sehen. Mit einem Klick auf den Try it out-Button kann man nachher diese Anfrage ausprobieren.\nNun erscheint ein grosser blauer Button mit der Aufschrift Execute. Auf Knopfdruck wird die GET-Anfrage gesendet und die Antwort wird nach Erhalt angezeigt.\nWas bei den GET-Anfragen galt, gilt auch für POST-Requests. Im Unterschied zur vorherigen Schnittstelle muss bei dieser zusätzlich ein Request Body im JSON-Format angegeben werden.\nMöchte man z.B. GetById ausführen, dann muss möglicherweise auch noch eine ID angegeben werden.\nDas Json für den Request-Body kann auch hier erst nach einem Klick auf “Try it out” spezifiziert werden:\nWenn deine API Zugriffsbeschränkungen oder Authentifizierungsschichten implementiert, ist eine Anpassung der Swagger-Konfiguration notwendig, um diese Sicherheitsmechanismen zu berücksichtigen.\nKonfigurationen von Swagger können in verschiedenen Aspekten angepasst werden. Hier sind einige allgemeine Anpassungen:\nPaketfilter für die API-Endpunkte festlegen .apis() API-Endpunkt-Pfade filtern .paths() Allgemeine API-Informationen konfigurieren .apiInfo() Globale Sicherheitsdefinitionen hinzufügen .securitySchemes(), .securityContexts() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 @Configuration public class SwaggerConfig { @Bean public Docket api() { return new Docket(DocumentationType.SWAGGER_2) .select() .apis(RequestHandlerSelectors.any()) .paths(PathSelectors.any()) .build() .apiInfo(apiInfo()); } private ApiInfo apiInfo() { ApiInfo apiInfo = new ApiInfo( \"Song API\", \"Swagger API for self project\", \"1.0\", \"\", \"Cédric rohrbach\", \"\", \"\" ); return apiInfo; } } IntelliJ HTTP Client Der IntelliJ HTTP Client ist ein eingebauter HTTP-Client, der Entwicklern ermöglicht, HTTP-Anfragen an Webdienste oder RESTful-APIs zu senden und die Antworten zu überprüfen. Dies ist nützlich, um Web-APIs schnell zu testen, ohne eine separate Anwendung von Drittanbietern installieren zu müssen.\nDamit man den HTTP Client verwenden kann, muss man zuerst ein solches File erstellen. Dies kann wie folgt getan werden:\nEinige Entwickler legen die HTTP-Dateien in einem separaten Ordner wie “http” oder “requests” im Hauptverzeichnis ihres Projekts ab. Andere bevorzugen es, die HTTP-Dateien im Verzeichnis des Moduls zu speichern, das sie verwenden.\nIm File kann man zum Beispiel eine Get Abfrage nach folgenden Schema erstellen.\n1 2 GET http://localhost:8080/api/student/subjects Accept: application/json Das api/student/subjects ist das RequestMapping, welchen in den Controllern festgelegt wurden für den API-Schnittpunkt.\nEine POST- oder PUT-Anfrage, welchen einen Request-Body benötigt, ist wie folgt aufgebaut:\n1 2 3 4 5 6 7 POST http://localhost:8080/api/admin/subjects Content-Type: application/json { \"key1\": \"value1\", \"key2\": \"value2\" } Wenn man nun die Applikation startet, kann man diese HTTP-Anfrage ausführen und sehen, was die Schnittstelle antwortet.\n","categories":"","description":"Modul #J8 - Spring Framework - Testing von REST-Schnittstellen\n","excerpt":"Modul #J8 - Spring Framework - Testing von REST-Schnittstellen\n","ref":"/de/docs/02_java/12_spring-framework/09_rest-testing/","tags":"","title":"Testing von REST-Schnittstellen"},{"body":"Ziele Du weisst, was ein control flow ist und wofür dieser verwendet wird. Du kennst die relevanten Änderungen der control flows, die im Rahmen von Angular 17 entstanden sind. Control Flow Im Doc Directives hast du die Directives *ngIf, *ngFor, etc. kennengelernt. In Angular 17 wurde nun ein Built-in Control Flow hinzugefügt, was bedeutet, dass Angular eine eigene Struktur für diese Operationen erstellt hat. Diese Control Flows können in jedem Template (HTML) eingesetzt werden und lösen ab sofort die bisherigen Directives ab.\nVerwendung Wie bereits erwähnt können die Control Flows direkt in jeder HTML-Datei in einem Angular-Projekt eingesetzt werden. Aktuell gibt es folgende Control Flows:\n@if \u0026 @else Mit den beiden neuen @if- und @else-flows wird die Verwendung vereinfacht, sodass beim Lesen des Codes auch das else klar sichtbar ist. Bisher musste ein if-else also so umgesetzt werden:\n1 2 3 4 5 6 \u003cdiv *ngIf=\"loggedIn; else anonymousUser\"\u003e The user is logged in \u003c/div\u003e \u003cng-template #anonymousUser\u003e The user is not logged in \u003c/ng-template\u003e Mit dem neuen Control Flow vereinfacht sich der Code zu:\n1 2 3 4 5 @if (loggedIn) { The user is logged in } @else { The user is not logged in } Auch durch dieses Update ermöglich wurde der @else if-flow, was mit den alten directives nur sehr schwer und unschön umsetzbar war.\n@switch Der neue @switch-Flow in Angular 17 bietet eine verbesserte und vereinfachte Möglichkeit, mehrere Bedingungen in einem Template zu überprüfen. Hier ist ein Vergleich zwischen dem alten und dem neuen Ansatz:\nAngular 16:\n1 2 3 4 5 6 \u003cdiv [ngSwitch]=\"accessLevel\"\u003e \u003cadmin-dashboard *ngSwitchCase=\"admin\"/\u003e \u003cmoderator-dashboard *ngSwitchCase=\"moderator\"/\u003e \u003cuser-dashboard *ngSwitchDefault/\u003e \u003c/div\u003e Angular 17:\n1 2 3 4 5 @switch (accessLevel) { @case ('admin') { \u003cadmin-dashboard/\u003e } @case ('moderator') { \u003cmoderator-dashboard/\u003e } @default { \u003cuser-dashboard/\u003e } } Wie du siehst, ist der neue @switch-Flow einfacher lesbar und einfacher zu verwenden als der alte ngSwitch. Er ermöglicht eine klare und direkte Art, verschiedene Fälle in deinem Code zu behandeln.\n@for Der @for Control Flow in Angular 17 bietet eine verbesserte und vereinfachte Möglichkeit, über eine Sammlung von Elementen zu iterieren. Hier ist ein Vergleich zwischen dem alten und dem neuen Ansatz:\nAngular 16:\n1 2 3 \u003cdiv *ngFor=\"let item of items\"\u003e {{item}} \u003c/div\u003e Angular 17:\n1 2 3 @for (item of items; track item) { {{item}} } Wie du siehst, ist der neue @for-Flow einfacher verständlich und simpler in der Verwendung als der alte *ngFor-Flow. Er ermöglicht eine klare und direkte Art, über eine Sammlung von Elementen in deinem Code zu iterieren.\nEs ist auch möglich, den Index des aktuellen Elements zu erhalten, das wird mit track bewerkstelligt. Hier ist ein Beispiel:\n1 2 3 @for (item of items; track $index) { {{$index}}: {{item}} } In diesem Beispiel gibt {{$index}} den Index des aktuellen Elements in der Sammlung zurück und {{item}} gibt den Wert des aktuellen Elements zurück. Dies ist besonders nützlich, wenn du sowohl den Index als auch den Wert des Elements in deinem Template benötigst. Relevant ist hierbei, dass im Vergleich zu früher das Tracken des Index nicht mehr optional ist, sondern bei jeder Verwendung eines @for-Flows benötigt wird.\nPassend zum @for gibt es @empty, welches einen Standardwert für den Fall bereitstellt, dass es keine Elemente gibt, über die iteriert werden kann. Hier ein Beispiel dazu:\n1 2 3 4 5 @for (user of users; track user.id) { {{ user.name }} } @empty { Empty list of users } ","categories":"","description":"Modul #F6 - Angular - Neuer Control Flow in Angular\n","excerpt":"Modul #F6 - Angular - Neuer Control Flow in Angular\n","ref":"/docs/03_web/06_angular/02_9_control-flow/","tags":"","title":"Control Flow"},{"body":"Ziele Du weisst, was ein control flow ist und wofür dieser verwendet wird. Du kennst die relevanten Änderungen der control flows, die im Rahmen von Angular 17 entstanden sind. Control Flow Im Doc Directives hast du die Directives *ngIf, *ngFor, etc. kennengelernt. In Angular 17 wurde nun ein Built-in Control Flow hinzugefügt, was bedeutet, dass Angular eine eigene Struktur für diese Operationen erstellt hat. Diese Control Flows können in jedem Template (HTML) eingesetzt werden und lösen ab sofort die bisherigen Directives ab.\nVerwendung Wie bereits erwähnt können die Control Flows direkt in jeder HTML-Datei in einem Angular-Projekt eingesetzt werden. Aktuell gibt es folgende Control Flows:\n@if \u0026 @else Mit den beiden neuen @if- und @else-flows wird die Verwendung vereinfacht, sodass beim Lesen des Codes auch das else klar sichtbar ist. Bisher musste ein if-else also so umgesetzt werden:\n1 2 3 4 5 6 \u003cdiv *ngIf=\"loggedIn; else anonymousUser\"\u003e The user is logged in \u003c/div\u003e \u003cng-template #anonymousUser\u003e The user is not logged in \u003c/ng-template\u003e Mit dem neuen Control Flow vereinfacht sich der Code zu:\n1 2 3 4 5 @if (loggedIn) { The user is logged in } @else { The user is not logged in } Auch durch dieses Update ermöglich wurde der @else if-flow, was mit den alten directives nur sehr schwer und unschön umsetzbar war.\n@switch Der neue @switch-Flow in Angular 17 bietet eine verbesserte und vereinfachte Möglichkeit, mehrere Bedingungen in einem Template zu überprüfen. Hier ist ein Vergleich zwischen dem alten und dem neuen Ansatz:\nAngular 16:\n1 2 3 4 5 6 \u003cdiv [ngSwitch]=\"accessLevel\"\u003e \u003cadmin-dashboard *ngSwitchCase=\"admin\"/\u003e \u003cmoderator-dashboard *ngSwitchCase=\"moderator\"/\u003e \u003cuser-dashboard *ngSwitchDefault/\u003e \u003c/div\u003e Angular 17:\n1 2 3 4 5 @switch (accessLevel) { @case ('admin') { \u003cadmin-dashboard/\u003e } @case ('moderator') { \u003cmoderator-dashboard/\u003e } @default { \u003cuser-dashboard/\u003e } } Wie du siehst, ist der neue @switch-Flow einfacher lesbar und einfacher zu verwenden als der alte ngSwitch. Er ermöglicht eine klare und direkte Art, verschiedene Fälle in deinem Code zu behandeln.\n@for Der @for Control Flow in Angular 17 bietet eine verbesserte und vereinfachte Möglichkeit, über eine Sammlung von Elementen zu iterieren. Hier ist ein Vergleich zwischen dem alten und dem neuen Ansatz:\nAngular 16:\n1 2 3 \u003cdiv *ngFor=\"let item of items\"\u003e {{item}} \u003c/div\u003e Angular 17:\n1 2 3 @for (item of items; track item) { {{item}} } Wie du siehst, ist der neue @for-Flow einfacher verständlich und simpler in der Verwendung als der alte *ngFor-Flow. Er ermöglicht eine klare und direkte Art, über eine Sammlung von Elementen in deinem Code zu iterieren.\nEs ist auch möglich, den Index des aktuellen Elements zu erhalten, das wird mit track bewerkstelligt. Hier ist ein Beispiel:\n1 2 3 @for (item of items; track $index) { {{$index}}: {{item}} } In diesem Beispiel gibt {{$index}} den Index des aktuellen Elements in der Sammlung zurück und {{item}} gibt den Wert des aktuellen Elements zurück. Dies ist besonders nützlich, wenn du sowohl den Index als auch den Wert des Elements in deinem Template benötigst. Relevant ist hierbei, dass im Vergleich zu früher das Tracken des Index nicht mehr optional ist, sondern bei jeder Verwendung eines @for-Flows benötigt wird.\nPassend zum @for gibt es @empty, welches einen Standardwert für den Fall bereitstellt, dass es keine Elemente gibt, über die iteriert werden kann. Hier ein Beispiel dazu:\n1 2 3 4 5 @for (user of users; track user.id) { {{ user.name }} } @empty { Empty list of users } ","categories":"","description":"Modul #F6 - Angular - Neuer Control Flow in Angular\n","excerpt":"Modul #F6 - Angular - Neuer Control Flow in Angular\n","ref":"/de/docs/03_web/06_angular/02_9_control-flow/","tags":"","title":"Control Flow"},{"body":"Ziele Du kennst die verschiedenen Arten, um Objekte zu erstellen. Du kennst die unterschiedlichen Arten, die Attribute eines Objektes abzufragen. Du kannst Objekt-Eigenschaften anpassen und Objekten auch neue Eigenschaften beifügen. Du kannst Objekte in einen JSON-String kodieren und einen JSON-String in ein Objekt dekodieren. Du, weisst, wofür der Spread-Operator gebraucht wird und wie er angewandt wird. Objekte Ein Objekt ist eine Sammlung von Eigenschaften, die eine Entität repräsentieren.\nObjekte können verschiedene Datentypen enthalten, einschließlich anderen Objekten, Arrays, Strings, Zahlen und booleschen Werten.\n1 2 3 4 5 const person = { name: \"Max\", age: 20, isStudent: true, }; Objekt erstellen Man kann Objekte auf zwei unterschiedliche Arten erstellen. Zum einen mit der Objektliteral-Syntax und zum anderen mit der Konstruktor-Syntax.\nObjektliteral-Syntax Die einfachere und auch gängigere Methode ist die Objektliteral-Syntax. Bei dieser Methode können die Eigenschaften und Werte direkt innerhalb geschweifter Klammern angeben werden:\n1 2 3 4 5 const person = { name: \"Max\", age: 20, isStudent: true, }; Konstruktor-Syntax. Die zweite Möglichkeit, ein neues Objekt zu erstellen, besteht darin, einen Konstruktor zu verwenden:\n1 2 3 4 const person = new Object(); person.name = \"Max\"; person.age = 20; person.isStudent = true; Man kann auch Methoden (Funktionen) innerhalb eines Objekts hinzufügen, indem man sie als Eigenschaften definiert:\n1 2 3 4 5 6 7 8 const person = { name: \"Max\", age: 20, isStudent: true, sayHello: function () { console.log(\"Hello, my name is \" + this.name); }, }; Eigenschaften von Objekten abfragen Um die Eigenschaften eines Objekts abzurufen, gibt es zwei Möglichkeiten:\nDie Punkt-Notation, und die Klammern-Notation. Punkt-Notation Eine bestimmte Eigenschaft (property) kann abgefragt werden, indem nach dem Objektaufruf ein Punkt . angehängt wird und der Name der Eigenschaft folgt:\n1 2 3 4 5 6 7 8 9 const person = { name: \"Max\", age: 20, isStudent: true, }; console.log(person.name); // 'Max' console.log(person.age); // 20 console.log(person.isStudent); // true Klammern-Notation Im Gegensatz zur Punkt-Notation wird bei der Klammern-Notation der Name der Eigenschaft als String übergeben:\n1 2 3 4 5 6 7 8 9 const person = { name: \"Max\", age: 20, isStudent: true, }; console.log(person[\"name\"]); // 'Max' console.log(person[\"age\"]); // 20 console.log(person[\"isStudent\"]); // true Auch Methoden (Funktionen) innerhalb eines Objekts können über die Punkt- oder Klammer-Notation aufgerufen werden:\n1 2 3 4 5 6 7 8 9 10 11 let person = { name: \"Max\", age: 20, isStudent: true, sayHello: function () { console.log(\"Hello, my name is \" + this.name); }, }; console.log(person.sayHello()); // 'Hello, my name is Max' console.log(person[\"sayHello\"]()); // 'Hello, my name is Max' Die Klammer-Notation kann zu mehr Flexibilität und Wiederverwendbarkeit von Code führen. Wenn wir beispielsweise eine Funktion generell für Objekte schreiben und bestimmte Dinge mit bestimmten Eigenschaften durchführen möchten, die wir später separat angeben können möchten:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 let person = { name: \"Max\", age: 20, isStudent: true, }; function printProperties(object, properties) { for (const property of properties) { console.log(object[property]); } } printProperties(person, [\"name\", \"age\", \"isStudent\"]); // Max // 20 // true In den meisten Fällen empfiehlt es sich aber, auf so ein “Gebastel” zu verzichten, da der Code für andere Personen so schnell sehr unverständlich wird.\nObjekte updaten Um Eigenschaften von Objekten anzupassen, können wieder sowohl die Punkt-Notation als auch die Klammer-Notation verwendet werden:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 let person = { name: \"Max\", age: 20, isStudent: true, sayHello: function () { console.log(\"Hello, my name is \" + this.name); }, }; person.age = 30; console.log(person.age); // 30 person[\"age\"] = 40; console.log(person.age); // 40 person.sayHello = function () { console.log( \"Hello, my name is \" + this.name + \" and I am \" + this.age + \" years old.\", ); }; person.sayHello(); // 'Hello, my name is Max and I am 40 years old.' Hinzufügen neuer Eigenschaften Um eine neue Eigenschaft zu einem Objekt hinzuzufügen, muss lediglich ein Wert mit einem neuen Eigenschaftsnamen zugewiesen werden:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 let person = { name: \"Max\", age: 20, isStudent: true, sayHello: function () { console.log(\"Hello, my name is \" + this.name); }, }; person.job = \"programmer\"; console.log(person.job); // 'programmer person[\"hobby\"] = \"hockey\"; console.log(person.hobby); // 'hockey person.sayGoodbye = function () { console.log(\"Bye!\"); }; person.sayGoodbye(); // 'Bye!' JSON JSON (JavaScript Object Notation) ist ein Textformat zum Austausch von Daten. Es wird oft in der Webprogrammierung verwendet, um Daten zwischen einem Client und einem Server auszutauschen.\nObjekte können in JavaScript mittels JSON serialisiert und deserialisiert werden. Ein JavaScript-Objekt besteht wesentlich aus einer Sammlung von Schlüssel-Wert-Paaren. Ein JSON-Objekt ist ein String, der diese Schlüssel-Wert-Paare in einem strukturierten JSON-Format enthält.\nEs ist wichtig zu beachten, dass JSON nur bestimmte Datentypen unterstützt, darunter Zeichenfolgen, Zahlen, Booleans, null, Arrays und Objekte. Funktionen und undefinierte Werte können nicht in JSON serialisiert werden.\nObjekt in JSON-String umwandeln Um ein JavaScript-Objekt in JSON zu kodieren, kann die Methode JSON.stringify() verwendet werden. Diese Methode nimmt das JavaScript-Objekt als Argument und gibt einen String zurück, der das Objekt im JSON-Format darstellt:\n1 2 3 4 5 6 7 8 9 const person = { name: \"Max\", age: 20, isStudent: true, }; const jsonString = JSON.stringify(person); console.log(jsonString); // '{\"name\":\"Max\",\"age\":20,\"isStudent\":true}' JSON-String in Objekt dekodieren Um eine JSON-Zeichenfolge in ein JavaScript-Objekt zu dekodieren, kann die Methode JSON.parse() verwendet werden. Diese Methode nimmt die JSON-Zeichenfolge als Argument und gibt ein JavaScript-Objekt zurück:\n1 2 3 4 5 const jsonString = '{\"name\":\"Max\",\"age\":20,\"isStudent\":true}'; const person = JSON.parse(jsonString); console.log(person); // Object { name: \"Max\", age: 20, isStudent: true } Spread Operator Der Spread-Operator ist ein Operator in JavaScript, der es ermöglicht, ein Array oder einen Objekt-Literal-Ausdruck in eine Liste von Argumenten zu “entpacken”. Der Operator wird durch drei Punkte (...) dargestellt.\nDer Spread-Operator wird in diesem Beispiel verwendet, um die Arrays in eine Liste von Elementen zu “entpacken”. Dadurch können diese einfach zusammengeführt oder kopiert werden.\n1 2 3 4 5 6 const array1 = [1, 2, 3]; const array2 = [4, 5, 6]; const combinedArray = [...array1, ...array2]; console.log(combinedArray); // [1, 2, 3, 4, 5, 6] Das Gleiche gilt auch für Objekte.\n1 2 3 4 5 6 const person = { name: \"Max\", age: 20 }; const address = { city: \"New York\", country: \"USA\" }; const combinedObject = { ...person, ...address }; console.log(combinedObject); // { name: 'Max', age: 20, city: 'New York', country: 'USA' } Der Operator kann auch zum Erstellen von Kopien von Arrays oder Objekten verwendet werden, anstatt sie zu ändern.\n1 2 3 4 5 6 7 8 9 const originalArray = [1, 2, 3]; const copiedArray = [...originalArray]; console.log(copiedArray); // [1, 2, 3] copiedArray.push(4); console.log(originalArray); // [1, 2, 3] console.log(copiedArray); // [1, 2, 3, 4] Der Operator kann auch als Parameter in einem Funktionsaufruf verwendet werden. Dadurch können Argumente einer Funktion als einzelne Werte an die Funktion übergeben werden, anstatt als Array oder Objekt.\nWenn der Spread-Operator als Parameter verwendet wird, müssen die anderen Parameter vor ihm stehen, da er alle verbleibenden Argumente “entpackt”.\n1 2 3 4 5 6 7 8 9 function sumNumbers(x, y, z) { return x + y + z; } const numbers = [1, 2, 3]; const result = sumNumbers(...numbers); console.log(result); // 6 Im Parameter ist er besonders nützlich, wenn eine Funktion eine variable Anzahl von Argumenten akzeptieren soll:\n1 2 3 4 5 6 7 function concatenateStrings(separator, ...strings) { return strings.join(separator); } const result = concatenateStrings(\"-\", \"hello\", \"world\"); console.log(result); // 'hello-world' ","categories":"","description":"Modul #F4 - JavaScript - Objekte in JavaScript.\n","excerpt":"Modul #F4 - JavaScript - Objekte in JavaScript.\n","ref":"/docs/03_web/03_javascript/10_objects/","tags":"","title":"Objekte"},{"body":"Ziele Du kennst die verschiedenen Arten, um Objekte zu erstellen. Du kennst die unterschiedlichen Arten, die Attribute eines Objektes abzufragen. Du kannst Objekt-Eigenschaften anpassen und Objekten auch neue Eigenschaften beifügen. Du kannst Objekte in einen JSON-String kodieren und einen JSON-String in ein Objekt dekodieren. Du, weisst, wofür der Spread-Operator gebraucht wird und wie er angewandt wird. Objekte Ein Objekt ist eine Sammlung von Eigenschaften, die eine Entität repräsentieren.\nObjekte können verschiedene Datentypen enthalten, einschließlich anderen Objekten, Arrays, Strings, Zahlen und booleschen Werten.\n1 2 3 4 5 const person = { name: \"Max\", age: 20, isStudent: true, }; Objekt erstellen Man kann Objekte auf zwei unterschiedliche Arten erstellen. Zum einen mit der Objektliteral-Syntax und zum anderen mit der Konstruktor-Syntax.\nObjektliteral-Syntax Die einfachere und auch gängigere Methode ist die Objektliteral-Syntax. Bei dieser Methode können die Eigenschaften und Werte direkt innerhalb geschweifter Klammern angeben werden:\n1 2 3 4 5 const person = { name: \"Max\", age: 20, isStudent: true, }; Konstruktor-Syntax. Die zweite Möglichkeit, ein neues Objekt zu erstellen, besteht darin, einen Konstruktor zu verwenden:\n1 2 3 4 const person = new Object(); person.name = \"Max\"; person.age = 20; person.isStudent = true; Man kann auch Methoden (Funktionen) innerhalb eines Objekts hinzufügen, indem man sie als Eigenschaften definiert:\n1 2 3 4 5 6 7 8 const person = { name: \"Max\", age: 20, isStudent: true, sayHello: function () { console.log(\"Hello, my name is \" + this.name); }, }; Eigenschaften von Objekten abfragen Um die Eigenschaften eines Objekts abzurufen, gibt es zwei Möglichkeiten:\nDie Punkt-Notation, und die Klammern-Notation. Punkt-Notation Eine bestimmte Eigenschaft (property) kann abgefragt werden, indem nach dem Objektaufruf ein Punkt . angehängt wird und der Name der Eigenschaft folgt:\n1 2 3 4 5 6 7 8 9 const person = { name: \"Max\", age: 20, isStudent: true, }; console.log(person.name); // 'Max' console.log(person.age); // 20 console.log(person.isStudent); // true Klammern-Notation Im Gegensatz zur Punkt-Notation wird bei der Klammern-Notation der Name der Eigenschaft als String übergeben:\n1 2 3 4 5 6 7 8 9 const person = { name: \"Max\", age: 20, isStudent: true, }; console.log(person[\"name\"]); // 'Max' console.log(person[\"age\"]); // 20 console.log(person[\"isStudent\"]); // true Auch Methoden (Funktionen) innerhalb eines Objekts können über die Punkt- oder Klammer-Notation aufgerufen werden:\n1 2 3 4 5 6 7 8 9 10 11 let person = { name: \"Max\", age: 20, isStudent: true, sayHello: function () { console.log(\"Hello, my name is \" + this.name); }, }; console.log(person.sayHello()); // 'Hello, my name is Max' console.log(person[\"sayHello\"]()); // 'Hello, my name is Max' Die Klammer-Notation kann zu mehr Flexibilität und Wiederverwendbarkeit von Code führen. Wenn wir beispielsweise eine Funktion generell für Objekte schreiben und bestimmte Dinge mit bestimmten Eigenschaften durchführen möchten, die wir später separat angeben können möchten:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 let person = { name: \"Max\", age: 20, isStudent: true, }; function printProperties(object, properties) { for (const property of properties) { console.log(object[property]); } } printProperties(person, [\"name\", \"age\", \"isStudent\"]); // Max // 20 // true In den meisten Fällen empfiehlt es sich aber, auf so ein “Gebastel” zu verzichten, da der Code für andere Personen so schnell sehr unverständlich wird.\nObjekte updaten Um Eigenschaften von Objekten anzupassen, können wieder sowohl die Punkt-Notation als auch die Klammer-Notation verwendet werden:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 let person = { name: \"Max\", age: 20, isStudent: true, sayHello: function () { console.log(\"Hello, my name is \" + this.name); }, }; person.age = 30; console.log(person.age); // 30 person[\"age\"] = 40; console.log(person.age); // 40 person.sayHello = function () { console.log( \"Hello, my name is \" + this.name + \" and I am \" + this.age + \" years old.\", ); }; person.sayHello(); // 'Hello, my name is Max and I am 40 years old.' Hinzufügen neuer Eigenschaften Um eine neue Eigenschaft zu einem Objekt hinzuzufügen, muss lediglich ein Wert mit einem neuen Eigenschaftsnamen zugewiesen werden:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 let person = { name: \"Max\", age: 20, isStudent: true, sayHello: function () { console.log(\"Hello, my name is \" + this.name); }, }; person.job = \"programmer\"; console.log(person.job); // 'programmer person[\"hobby\"] = \"hockey\"; console.log(person.hobby); // 'hockey person.sayGoodbye = function () { console.log(\"Bye!\"); }; person.sayGoodbye(); // 'Bye!' JSON JSON (JavaScript Object Notation) ist ein Textformat zum Austausch von Daten. Es wird oft in der Webprogrammierung verwendet, um Daten zwischen einem Client und einem Server auszutauschen.\nObjekte können in JavaScript mittels JSON serialisiert und deserialisiert werden. Ein JavaScript-Objekt besteht wesentlich aus einer Sammlung von Schlüssel-Wert-Paaren. Ein JSON-Objekt ist ein String, der diese Schlüssel-Wert-Paare in einem strukturierten JSON-Format enthält.\nEs ist wichtig zu beachten, dass JSON nur bestimmte Datentypen unterstützt, darunter Zeichenfolgen, Zahlen, Booleans, null, Arrays und Objekte. Funktionen und undefinierte Werte können nicht in JSON serialisiert werden.\nObjekt in JSON-String umwandeln Um ein JavaScript-Objekt in JSON zu kodieren, kann die Methode JSON.stringify() verwendet werden. Diese Methode nimmt das JavaScript-Objekt als Argument und gibt einen String zurück, der das Objekt im JSON-Format darstellt:\n1 2 3 4 5 6 7 8 9 const person = { name: \"Max\", age: 20, isStudent: true, }; const jsonString = JSON.stringify(person); console.log(jsonString); // '{\"name\":\"Max\",\"age\":20,\"isStudent\":true}' JSON-String in Objekt dekodieren Um eine JSON-Zeichenfolge in ein JavaScript-Objekt zu dekodieren, kann die Methode JSON.parse() verwendet werden. Diese Methode nimmt die JSON-Zeichenfolge als Argument und gibt ein JavaScript-Objekt zurück:\n1 2 3 4 5 const jsonString = '{\"name\":\"Max\",\"age\":20,\"isStudent\":true}'; const person = JSON.parse(jsonString); console.log(person); // Object { name: \"Max\", age: 20, isStudent: true } Spread Operator Der Spread-Operator ist ein Operator in JavaScript, der es ermöglicht, ein Array oder einen Objekt-Literal-Ausdruck in eine Liste von Argumenten zu “entpacken”. Der Operator wird durch drei Punkte (...) dargestellt.\nDer Spread-Operator wird in diesem Beispiel verwendet, um die Arrays in eine Liste von Elementen zu “entpacken”. Dadurch können diese einfach zusammengeführt oder kopiert werden.\n1 2 3 4 5 6 const array1 = [1, 2, 3]; const array2 = [4, 5, 6]; const combinedArray = [...array1, ...array2]; console.log(combinedArray); // [1, 2, 3, 4, 5, 6] Das Gleiche gilt auch für Objekte.\n1 2 3 4 5 6 const person = { name: \"Max\", age: 20 }; const address = { city: \"New York\", country: \"USA\" }; const combinedObject = { ...person, ...address }; console.log(combinedObject); // { name: 'Max', age: 20, city: 'New York', country: 'USA' } Der Operator kann auch zum Erstellen von Kopien von Arrays oder Objekten verwendet werden, anstatt sie zu ändern.\n1 2 3 4 5 6 7 8 9 const originalArray = [1, 2, 3]; const copiedArray = [...originalArray]; console.log(copiedArray); // [1, 2, 3] copiedArray.push(4); console.log(originalArray); // [1, 2, 3] console.log(copiedArray); // [1, 2, 3, 4] Der Operator kann auch als Parameter in einem Funktionsaufruf verwendet werden. Dadurch können Argumente einer Funktion als einzelne Werte an die Funktion übergeben werden, anstatt als Array oder Objekt.\nWenn der Spread-Operator als Parameter verwendet wird, müssen die anderen Parameter vor ihm stehen, da er alle verbleibenden Argumente “entpackt”.\n1 2 3 4 5 6 7 8 9 function sumNumbers(x, y, z) { return x + y + z; } const numbers = [1, 2, 3]; const result = sumNumbers(...numbers); console.log(result); // 6 Im Parameter ist er besonders nützlich, wenn eine Funktion eine variable Anzahl von Argumenten akzeptieren soll:\n1 2 3 4 5 6 7 function concatenateStrings(separator, ...strings) { return strings.join(separator); } const result = concatenateStrings(\"-\", \"hello\", \"world\"); console.log(result); // 'hello-world' ","categories":"","description":"Modul #F4 - JavaScript - Objekte in JavaScript.\n","excerpt":"Modul #F4 - JavaScript - Objekte in JavaScript.\n","ref":"/de/docs/03_web/03_javascript/10_objects/","tags":"","title":"Objekte"},{"body":"Was ist CSS? Inzwischen haben wir gelernt, was HTML ist, und wie es angewendet werden kann. Wie euch wahrscheinlich bereits aufgefallen ist, sieht pures HTML jedoch nicht besonders schön aus.\nUnd genau da kommt CSS (kurz für “Cascading Style Sheets”) ins Spiel. CSS wird eingesetzt, um unsere HTML-Elemente zu designen, ihnen also das von uns gewünschte Aussehen/Verhalten zu verleihen.\n","categories":"","description":"Modul #F3 - HTML und CSS - Einführung in CSS.\n","excerpt":"Modul #F3 - HTML und CSS - Einführung in CSS.\n","ref":"/docs/03_web/02_html_css/09_css-intro/","tags":"","title":"CSS"},{"body":"Was ist CSS? Inzwischen haben wir gelernt, was HTML ist, und wie es angewendet werden kann. Wie euch wahrscheinlich bereits aufgefallen ist, sieht pures HTML jedoch nicht besonders schön aus.\nUnd genau da kommt CSS (kurz für “Cascading Style Sheets”) ins Spiel. CSS wird eingesetzt, um unsere HTML-Elemente zu designen, ihnen also das von uns gewünschte Aussehen/Verhalten zu verleihen.\n","categories":"","description":"Modul #F3 - HTML und CSS - Einführung in CSS.\n","excerpt":"Modul #F3 - HTML und CSS - Einführung in CSS.\n","ref":"/de/docs/03_web/02_html_css/09_css-intro/","tags":"","title":"CSS"},{"body":"","categories":"","description":"Aufgaben zu Modul #J6 - Collections\n","excerpt":"Aufgaben zu Modul #J6 - Collections\n","ref":"/labs/02_java/10_java-collections/","tags":"","title":"Aufgaben zu Java - Collections"},{"body":"","categories":"","description":"Aufgaben zu Modul #J6 - Collections\n","excerpt":"Aufgaben zu Modul #J6 - Collections\n","ref":"/de/labs/02_java/10_java-collections/","tags":"","title":"Aufgaben zu Java - Collections"},{"body":"Ziele Du verstehst, was Debugging ist und warum es wichtig ist. Du kannst zwischen Debugging und einfachem Logging unterscheiden. Du kennst verschiedene Wege, Fehler im Code zu analysieren. Wieso ist Debuggen wichtig? Es gibt viele Gründe, warum Programme Fehler enthalten können – z. B. falsche Annahmen, vergessene Sonderfälle oder unerwartete Eingaben. Typische Fehler sind:\nfalsche Berechnungen NullPointerException Endlosschleifen falsche Bedingungen (if falsch herum) Methoden werden nicht aufgerufen oder liefern falsche Werte zurück Mittels debuggen kannst du den Fehler einkreisen und dann jede Anweisung Schritt für Schritt ausführen und prüfen, ob die Anweisung wie erwartet Funktioniert.\nWas bringt Debuggen? Fehler gezielt finden, indem man den Code Schritt für Schritt durchläuft Werte von Variablen und den Kontrollfluss beobachten Besseres Verständnis für fremden oder komplexen Code Debugging vs. Logging Viele Anfänger schreiben System.out.println(...), um zu sehen, was im Code passiert. Das funktioniert, hat aber Nachteile:\nKonsolenausgaben verlangsamen das Programm Der Code wird unübersichtlicher Logs werden oft vergessen zu entfernen und gelangen so in Git oder sogar auf den Server In IntelliJ kannst du stattdessen einen sogenannten Log-Breakpoint setzen. Das ist wie ein System.out.println, aber ohne den Code zu verändern. Wie kann man debuggen – auch ohne Tool? Code genau lesen – viele Fehler erkennt man durch genaues Nachdenken. Tests schreiben – zeigen sofort, wenn etwas nicht stimmt. Logs schreiben – gezielt und kontrolliert. Assertions verwenden – helfen, Annahmen zu überprüfen. Debugging vs. Fehlersuche im Feld Beim Entwickeln am eigenen Rechner kann man den Code komfortabel debuggen – z. B. mit einem Debugger wie in IntelliJ. Im Produktivbetrieb (im Feld) ist das aber nicht möglich:\nMan kann keine Breakpoints setzen, weil das Programm bereits läuft. Man hat keinen Zugriff auf eine Entwicklungsumgebung. Das Verhalten darf nicht unterbrochen oder verändert werden. Logging im Feld Deshalb ist Logging im Feld die wichtigste Methode, um Fehler zu finden:\nMan loggt gezielt Informationen (z. B. Zustände, Fehlermeldungen, Eingabewerte) Diese Logs werden in eine Datei oder Datenbank geschrieben und später analysiert Logging sollte sparsam, aber gezielt eingesetzt werden Auch Logging kann das Verhalten eines Programms verändern – vor allem in zeitkritischen oder nebenläufigen Systemen. Jeder Log-Eintrag braucht Rechenzeit und kann z. B. Threads blockieren oder IO-Prozesse verlangsamen. In zeitkritischen Methoden (z. B. bei Hardware-Ansteuerung oder Animationen) sollte Logging nur mit Bedacht oder gar nicht eingesetzt werden. Stattdessen kann man Zustände puffern und später gesammelt ausgeben. Für die Java Grundlagen reichen vorderhand die Debug-Möglichkeiten aus, welche IntelliJ bietet. Das Logging werden wir erst in einem späteren Modul einsetzen.\nAuch während der Entwicklung ist es nicht falsch, den Programmfluss per Ausgabe auf die Konsole oder mittels Logging festzuhalten. Dies Informationen liefern wertvolle Informationen, wo man mit dem Debugen effektiv beginnen soll. Vor allem bei grösseren Programmen ist es ineffizient, das gesamte Programm bis zum Fehler Schritt für Schritt abzuarbeiten. Nächste Schritte Wenn du Java mit IntelliJ verwendest, solltest du das integrierte Debugging-Tool kennenlernen:\nDebugging in IntelliJ\nJetzt bist du dran. Löse bitte die folgenden !*Aufgaben in den Labs. ","categories":"","description":"Du lernst, wie du mit Debugging-Strategien und einfachen Hilfsmitteln Fehler in deinem Code findest – auch ohne IDE.\n","excerpt":"Du lernst, wie du mit Debugging-Strategien und einfachen Hilfsmitteln …","ref":"/docs/02_java/03_java-grundlagen/10_debugging/","tags":"","title":"Debugging – Fehler finden und verstehen"},{"body":" Voraussetzung Du weisst was ein Breakpoint ist. Du kannst den Debugger starten und den Code Schritt für Schritt ausführen Wir stellen dir bei den Übungen jeweils komplette Projekte zur Verfügung. Du musst grundsätzlich nur dort was anpassen, wo die folgende Kommentarzeile steht:\nKopieren // IT-Ninja: Füge hier Deinen Code ein: 1 // IT-Ninja: Füge hier Deinen Code ein: Alles andere kannst du für den Moment ignorieren. Wir erklären dir die einzelnen Zeilen Schritt für Schritt in den Modulen.\nVorbereitungsarbeiten Drücke auf den Pfeil links um eine detaillierte Anleitung zu erhalten, wie Du den Quellcode auf deinem Rechner ablegen sollst.\nDiese Schritte musst du bei jeder Übung erneut machen. Jede Übung hat ein eigenes ZIP-File, welches du bei dir an die richtige Stelle kopieren musst. Die Anleitung zeigt dir ziemlich gut, wie das geht… Liess vor allem am Anfang die detaillierte Anleitung gut durch und befolge die Schritte exakt. Sie helfen dir, deinen Quellcode gut organisiert, strukturiert und sicher zu verwalten. Falls du die Anleitung schon auswendig kennst, findest du den Quellcode zur Übung direkt hier: Download | Online anschauen\nNeu bei it-ninja?\nDie Anleitung enthält einige Befehle und Fachbegriffe, die dir möglicherweise noch nichts sagen. Mach dir deswegen keine Sorgen – in den kommenden Modulen erklären wir dir alles Schritt für Schritt. Schon bald wirst auch du ein it-ninja sein. Um die folgenden Aufgaben erfolgreich umzusetzen, führe diese Schritte aus:\nBeim ersten Mal:\nIntelliJ IDEA installieren → !*IntelliJ IDEA einrichten Git-Repository einrichten → !*Persönliches Git-Repository Öffne eine !*CMD-Shell und wechsle ins Verzeichnis deines Git-Repositories:\nKopieren cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git status 1 2 cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git status Kopieren cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git status 1 2 cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git status Stelle sicher, dass alle Dateien im Git-Repository committed sind. Mit git status erhältst du eine Übersicht: Kopieren git status 1 git status Falls du bei diesem Befehl einen roten Text siehst, musst du zuerst die aktuellen Dateien sichern:\nKopieren git add . git commit -m \"[gescheiter Kommentar]\" 1 2 git add . git commit -m \"[gescheiter Kommentar]\" Erstelle oder wechsle in den Template Branch:\nBeim ersten Mal musst du einen Template Branch erstellen:\nKopieren git checkout -b \"templates\" 1 git checkout -b \"templates\" Falls er bereits existiert, kannst du einfach switchen:\nKopieren git switch \"templates\" 1 git switch \"templates\" Lade den Source-Code zu den Übungen herunter und entpacke ihn im Root-Verzeichnis deines lokalen Repositories:\n[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\nDen Source-Code findest du hier: Download | Online anschauen\nCommitte den originalen Source-Code, damit er sicher im Repository gespeichert ist:\nKopieren git add . git commit -m \"Add it-ninja_02_java_03_java-grundlagen_10_debugging\" git push 1 2 3 git add . git commit -m \"Add it-ninja_02_java_03_java-grundlagen_10_debugging\" git push Erstelle einen neuen Branch, um deine Lösung zu implementieren: Kopieren git checkout -b \"labs/it-ninja_02_java_03_java-grundlagen_10_debugging\" 1 git checkout -b \"labs/it-ninja_02_java_03_java-grundlagen_10_debugging\" Hier kannst du auch einen kürzeren Namen wählen. Verwende labs am Anfang des Branch-Namens für Branches, die deinen eigenen Code enthalten.\nStelle dir einen Branch vorerst als Ordner vor. Jeder Ordner enthält eine Version oder einen Stand von deinem Quellcode. Du kannst dann mit git zwischen diesen Ordern hin und her wechseln, sie vergleichen aber später auch zusammenführen.\nPro-Tipp:\nDu kannst jederzeit einen weiteren Branch erstellen – z. B. wenn du etwas ausprobieren möchtest. Alternativ kannst du auch in der Git-History einen alten Stand wiederherstellen, was aber weniger flexibel ist. Starte IntelliJ und öffne mit File → Open das Verzeichnis mit dem Source-Code. Du musst mit IntelliJ den Ordner suchen, welches einen Ordner src oder die Datei pom.xml enthält. Ansonsten wird IntelliJ Mühe haben, dir das Programm zu kompilieren. Wenn du alles korrekt gemacht hast, findest du das Projekt hier:\nKopieren `[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\\02_java\\03_java-grundlagen\\10_debugging` 1 `[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\\02_java\\03_java-grundlagen\\10_debugging` Kopieren `[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\\02_java/03_java-grundlagen/10_debugging` 1 `[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\\02_java/03_java-grundlagen/10_debugging` Falls du zum ersten Mal mit IntelliJ arbeitest, findest du !*hier eine Anleitung, wie man ein Programm startet. Um das Programm zu starten musst du jeweils die Datei Main.java öffenen. Dann sollte in IntelliJ oben rechts ein grünes Dreieck vorhanden sein, welches das Programm startet. Nun bist du bereit, die untenstehenden Aufgaben zu lösen.\nWenn du alle Änderungen gemacht hast und mit der Übung fertig bist, oder einen ‘Zwischenstand’ festhalten willst, führe die folgenden Befehle aus um das Repository auf dem Server zu speichern (von wo du es geklont hast):\nKopieren cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git add --all git commit -m \"Kurzer Kommentar\" 1 2 3 cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git add --all git commit -m \"Kurzer Kommentar\" Kopieren cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git add . git commit -m \"Kurzer Kommentar\" 1 2 3 cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git add . git commit -m \"Kurzer Kommentar\" Wenn du deine Änderungen auf dem Git-Server sichern willst, musst du das mit einem push machen.\nBeim ersten mal musst du git noch mitteilen, wie der Branch auf dem Git-Server heissen soll:\nKopieren git push --set-upstream origin labs/it-ninja_02_java_03_java-grundlagen_10_debugging 1 git push --set-upstream origin labs/it-ninja_02_java_03_java-grundlagen_10_debugging Bei weiteren pushes wird es dann einfacher:\nKopieren git push 1 git push Die meisten Übungen sind professionell strukturiert – so wie in echten Softwareprojekten. Zu gutem Code gehören auch Tests, die sicherstellen, dass dein Code wie erwartet funktioniert. Sofern nicht anders erwähnt, kannst du mit folgendem Befehl im Root-Verzeichnis des Projekts (dort, wo sich auch die pom.xml befindet) überprüfen, ob du die Aufgabe korrekt gelöst hast:\n1 mvn test Viel Erfolg!\nZum Lösen der folgenden Aufgaben darfst du den Quellcode nicht verändern! Aufgabe 1 - Wert in Zwischenberechnung herausfinden Finde heraus, welcher Wert z hat, wenn x = 500 ist.\nIm zur Übung gehörendem Source kannst Du die Änderung an folgender Stelle machen:\nsrc\\main\\java\\ch\\itninja\\labs\\basicexercises\\MagicNumber.java:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public static int generate(int iterations) throws InterruptedException { // IT-Ninja: Zum Lösen der folgenden Aufgaben darfst du den Quellcode nicht verändern! // IT-Ninja: Aufgabe 1 - Finde heraus, welcher Wert z hat, wenn x = 500 ist. // IT-Ninja: Aufgabe 2 - Hat z am Ende immer den gleichen Wert, auch wenn du in der 'for'-Schleife einen // Breakpoint gesetzt hast? // IT-Ninja: Erstelle Screenshots und diskutiere deine Resultate und Erkenntnisse mit deinem Praxisbildner. int z = 0; for(int x = 0; x \u003c iterations; x++) { z = MagicNumberHelper.getSecretValue(x); } return z; } Aufgabe 2 - Verhalten des Programms beim Debuggen Beantworte folgende Frage: Hat z am Ende immer den gleichen Wert, auch wenn du in der ‘for’-Schleife einen Breakpoint gesetzt hast?\nIm zur Übung gehörendem Source kannst Du die Änderung an folgender Stelle machen:\nsrc\\main\\java\\ch\\itninja\\labs\\basicexercises\\MagicNumber.java:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public static int generate(int iterations) throws InterruptedException { // IT-Ninja: Zum Lösen der folgenden Aufgaben darfst du den Quellcode nicht verändern! // IT-Ninja: Aufgabe 1 - Finde heraus, welcher Wert z hat, wenn x = 500 ist. // IT-Ninja: Aufgabe 2 - Hat z am Ende immer den gleichen Wert, auch wenn du in der 'for'-Schleife einen // Breakpoint gesetzt hast? // IT-Ninja: Erstelle Screenshots und diskutiere deine Resultate und Erkenntnisse mit deinem Praxisbildner. int z = 0; for(int x = 0; x \u003c iterations; x++) { z = MagicNumberHelper.getSecretValue(x); } return z; } Beispiel:\nEingabe:\n1 MagicNumber.generate(1000); Ausgabe:\n1 -32414486 Erstelle ScreenShots und diskutiere deine Resultate und Erkenntnisse mit deinem Praxisbildner. ","categories":"","description":"Mit diesen Übungen kannst du dein Wissen zum Thema Debuggen vertiefen.\n","excerpt":"Mit diesen Übungen kannst du dein Wissen zum Thema Debuggen vertiefen. …","ref":"/labs/02_java/03_java-grundlagen/10_debugging/","tags":"","title":"Java Exercises - Debugging"},{"body":"Ziele Ich kann erklären, was Collections sind. Ich kenne grob den Aufbau des Collections-Frameworks. Ich kenne die wichtigsten Interfaces und ihre Merkmale: List, Set, Queue, Map. Ich verstehe den Einsatz der Hash-Funktion zur Performance-Verbesserung. Ich kenne die wichtigsten Implementierungen und ihre Einsatzmöglichkeiten: ArrayList, HashSet, HashMap. Ich verstehe die Funktionsweise und Anwendung der Klasse ArrayList. Ich verstehe die Funktionsweise und Anwendung der Klasse HashSet. Ich verstehe die Funktionsweise und Anwendung der Klasse HashMap. Ich verstehe die Funktionsweise und Anwendung der Klasse Stack. Ich kenne die Funktionsweise und den Unterschied zwischen den Klassen Queue und Deque und kann diese anwenden. Ich verstehe die Funktionsweise und Anwendung der Klasse LinkedList. Voraussetzungen Gute Grundlagenkenntnisse von Java-Anwendungen. Einleitung Beim Programmieren müssen wir oft Daten speichern bzw. Informationen verwalten, um gewisse Probleme zu lösen. In diesem Modul werden wir das Java Collections Framework anschauen, weil dieses Framework uns die Werkzeuge zum effizienten Verwalten von Informationen liefert.\nEine Collection ist ein Objekt, das eine Sammlung von Objekten darstellt, d.h. mehrere Elemente zu einer Einheit zusammenfasst. In der Regel enthält eine Collection Datenelemente, die zusammen eine natürliche Gruppe bilden, wie z.B. eine Fussballmannschaft, die eine “Sammlung” von Fussballspielern ist, d.h. Fussballspieler enthält. Collections bieten uns im Allgemeinen die Möglichkeit neue Elemente hinzuzufügen, Elemente zu löschen und sonst die Elemente zu verwalten.\nEin bekanntes Beispiel für eine Collection ist die ArrayList Klasse, wobei eine ArrayList eine Liste von Objekten darstellt, welche skalierbar ist. Die ArrayList Klasse liefert uns beispielsweise die Methode add, mit welcher Elemente an das Ende einer Liste angefügt werden kann:\n1 2 3 4 5 List\u003cString\u003e farben=new ArrayList\u003cString\u003e(); farben.add(\"rot\"); farben.add(\"blau\"); farben.add(\"gelb\"); farben.add(\"orange\"); Oder sie liefert uns die Methode remove, welche Elemente aus der Liste entfernt:\n1 2 3 4 5 List\u003cString\u003e farben=new ArrayList\u003cString\u003e(); farben.add(\"rot\"); farben.add(\"blau\"); farben.add(\"gelb\"); farben.remove(\"blau\"); Wir werden die ArrayList Klasse später noch genauer anschauen.\nDas Java Collections Framework ist eine Menge von Interfaces und Klassen, die allgemein wiederverwendbare Collection-Datenstrukturen liefern. Es bietet uns also sowohl Interfaces, die Collection-Typen definieren, als auch Klassen, die diese implementieren an. Obwohl es als Framework bezeichnet wird, funktioniert es im Grunde wie eine Library.\nDas Java Collections Frameworks stellt für uns Hochleistungsimplementierungen von Datenstrukturen und Algorithmen bereit, um Sammlungen von Objekten beliebiger Datentypen darzustellen. Da wir diese Funktionalität nicht immer selbst programmieren müssen, reduziert sich für uns der Programmieraufwand markant.\nDas Java Collections Framework befindet sich im Paket java.util.\nWir haben die ArrayList Klasse (java.util.ArrayList) als Beispiel für eine Collection gesehen. Die ArrayList Klasse repräsentiert eine Collection vom Typ List (implementiert also das Interface java.util.List) und wird mithilfe von zugrunde liegenden Arrays implementiert, deshalb auch der Name ArrayList. Es gibt aber auch andere Klassen, die Collections vom Typ List darstellen. Wir werden später einige davon noch kennenlernen.\nTheorie Das Java Collections Framework ist eine einheitliche Architektur zur Darstellung und Bearbeitung von Collections, welche folgendes enthält:\nInterfaces: Dies sind abstrakte Datentypen, die verschiedene Collections darstellen. Mithilfe von Interfaces können Collections unabhängig von den Details ihrer Implementierung bearbeitet werden. Die Interfaces bilden in Java die Hierarchie aller Collections.\nImplementierungen/Klassen: Dies sind die konkreten Implementierungen der Collection-Interfaces. Im Grunde handelt es sich um wiederverwendbare Datenstrukturen mit konkreten Implementierungen.\nAlgorithmen/Methoden: Dies sind die Methoden, die nützliche Algorithmen, wie z. B. Hinzufügen, Löschen, Suchen und Sortieren, von Objekten in Collections durchführen. Viele Methoden und Algorithmen sind für verschiedene Arten der Collections wiederverwendbar.\nDie Interfaces in der folgenden Abbildung (Collection, Set, List, Queue, Deque, Map …) bilden die Grundlage des Collection Frameworks. Durch diese grundlegenden Interfaces bildet sich eine Hierarchie innerhalb des Collection Frameworks:\nAuf dieser Grafik ist zu sehen, dass zum Beispiel:\nSets spezielle Typen von Collections sind. SortedSets wiederum sind spezielle Typen von Sets. Lists sind spezielle Typen von Collections. ArrayLists sind spezielle Typen von Lists. In der Abbildung sieht man zudem, dass das Collection Framework aus zwei verschiedenen Teilen besteht: Zum einen die Collections und zum anderen die Maps. Maps stellen somit keine “echten” Collections dar. Maps sind trotzdem Datenstrukturen zur Darstellung von Sammlungen von Objekten als eine Einheit.\nCollection Eine Collection ist ein Objekt, dass eine Sammlung von Objekten darstellt, d.h. mehrere Elemente zu einer Einheit zusammenfasst. In der Regel enthält eine Collection Datenelemente, die zusammen eine natürliche Gruppe bilden, wie z.B. eine Fussballmannschaft, die eine “Sammlung” von Fussballspielern ist, d.h. Fussballspieler enthält. Collections bieten uns im Allgemeinen die Möglichkeit neue Elemente hinzuzufügen, Elemente zu löschen und sonst die Elemente zu verwalten.\nAllgemeine Methoden:\nsize(), isEmpty(), contains(Object element), add(E element), remove(Object element), clear(), iterator()\nSammelmethoden:\ncontainsAll(Collection\u003c?\u003e c), addAll(Collection\u003c? extends E\u003e c), removeAll(Collection\u003c?\u003e c), retainAll(Collection\u003c?\u003e c)\nList Eine List ist eine geordnete Sequenz, welche duplizierte Elemente erlaubt. Zusätzlich zu den geerbten Methoden der Collection bietet die List folgende an:\nElemente auf Basis ihrer Position zugreifen:\nget, set\nSuche nach einem bestimmten Element in der Liste:\nindexOf, lastIndexOf\nIteriert durch die Liste:\nlistIterator\nEin Teilbereich der Liste erstellen:\nsublist\nFolgend sind zwei gängige List Implementierungen:\nArrayList welche in Normalfall die leistungsfähigere Implementation ist. Sie basiert auf einem primitiven Array. LinkedList welche in bestimmten Situation die effizientere Lösung sein kann. Set Ein Set ist eine Collection, in welche man ein Element nur einmal hinzufügen kann. Das Set enthält die Funktionen der Collection, stellt aber sicher, dass Elemente nicht doppelt vorkommen können. Die equals und hashCode Funktionen spielen dabei eine wichtige Rolle. Sie definieren, wann zwei Elemente als gleich gelten.\nElemente hinzufügen, löschen und Infos abfragen:\nadd(), contains(), remove(), clear(), size(), isEmpty()\nSammelmethoden:\naddAll(), removeAll(), containsAll()\nZugriff wie auf eine Collection:\niterator()\nFolgend sind 3 gängige Set Implementationen:\nHashSet - Schnell, aber unsortiert\nSpeichert Elemente in keiner bestimmten Reihenfolge. Sehr schnell beim Einfügen und Suchen. TreeSet – Sortiert, aber langsamer\nSpeichert Elemente aufsteigend sortiert. Einfügen und Suchen dauert länger. LinkedHashSet – Reihenfolge bleibt erhalten\nSpeichert Elemente in der Reihenfolge, in der sie hinzugefügt wurden. Schneller als TreeSet, aber etwas langsamer als HashSet. Map Eine Map ist ein Objekt, dass Schüssel (keys) auf Werte (values) zuordnet. Eine Map kann nicht zwei gleiche Schlüssel enthalten. Jeder Schlüssel zeigt genau auf einen Wert. Das Interface Map definiert Grundfunktionen für das Einfügen, Lesen, Löschen, Abfragen von Schlüsseln usw.\nZusätzlich zu den vererbten Methoden der Collection bietet die List folgende an:\nElemente auf Basis ihrer Position zugreifen:\nput(), get(), containsKey(), containsValue()\nSammelmethoden:\nputAll()\nZugriff wie auf eine Collection:\nkeySet(), entrySet(), values()\nFolgend sind 3 gängige Implementationen von Map:\nHashMap – Schnell, aber unsortiert\nSpeichert Schlüssel-Wert-Paare in keiner bestimmten Reihenfolge. Sehr schnell beim Einfügen und Suchen. TreeMap – Sortiert, aber langsamer\nSpeichert Schlüssel nach ihrer natürlichen Ordnung oder mit einem Comparator. Einfügen und Suchen dauert länger. LinkedHashMap – Reihenfolge bleibt erhalten\nSpeichert Schlüssel in der Reihenfolge, in der sie hinzugefügt wurden. Schneller als TreeMap, aber etwas langsamer als HashMap. Performanz Das Collections-Framework nutzt intensiv die Hash-Funktion. Klassen wie HashSet oder HashMap verwenden die Hash-Funktion zur Steigerung der Performanz.\nHash-Funktion Alle Java Klassen erben von der Klasse java.lang.Object die Methode public int hashCode(). Diese liefert ein Hash Code von der eigenen Instanz zurück. Bei Java ist dieser ein Integer.\nHashing bezeichnet die Umwandlung einer Zeichenfolge in einen numerischen Wert oder Schlüssel mit fester Länge, der in der Regel kürzer ist. Das bedeutet also, aus einem Java Objekt mit verschiedenen Attributen wird eine Zahl berechnet. Immer, wenn das gleiche Objekt wieder berechnet wird, erhält man die gleiche Zahl.\nDer Java Hash Code ist nicht immer eindeutig. Es kann also vorkommen, dass unterschiedliche Instanzen verschiedener Klassen denselben Hash-Code zurückgeben. In der Praxis ist das jedoch kein Problem, da der Hash-Code lediglich für eine Vorselektion genutzt wird. Das bedeutet, wenn die Hash Codes nicht gleich sind, sind die Objekte definitiv nicht gleich. Sind die Hash Codes gleich, werden trotzdem noch die Objekte direkt vergleicht.\nVerwendung Schauen wir uns die Verwendung von Set an: Bei einem Set können wir mit der Methode contains(Object o) abfragen, ob ein Objekt in einem Set vorhanden ist. Das Set muss somit jedes Objekt mit dem Objekt vergleichen, welches wir der Methode contains übergeben. Falls ein Objekt jedoch viele Instanzvariablen (oder Attribute) besitzt – die wiederum Objekte sein können –, wäre ein direkter Vergleich potenziell aufwendig.\nBei einer Handvoll Objekte im Set ist das vernachlässigbar. Bei mehreren tausend Objekten würde die Suche jedoch deutlich ineffizienter. Die Klasse HashSet verfolgt daher eine optimierte Strategie:\nBeim Hinzufügen eines neuen Objekts berechnet HashSet dessen Hash-Code mit der Methode hashCode(). Dieser Hash-Code wird gespeichert. Bei der Methode contains(Object o) wird der Hash-Code des übergebenen Vergleichsobjekts berechnet. Anschliessend wird dieser mit den gespeicherten Hash-Codes verglichen (Integer-Vergleich). Da der Java-Hash-Code nicht eindeutig ist, erfolgt bei Übereinstimmung zusätzlich ein Vergleich mit der Methode equals(Object o), um sicherzustellen, dass es sich tatsächlich um dasselbe Objekt handelt. Mit der Hash-Code Strategie kann das HashSet die allermeisten Vergleiche auf einen Integer-Vergleich reduzieren.\nAnforderung an die Hash Berechnung Was ist die Anforderung an die Java hashCode() Methode?\nDie Berechnung muss schnell sein. Der Hash Code sollte in der Praxis meistens eindeutig sein. ","categories":"","description":"Modul #J6\n","excerpt":"Modul #J6\n","ref":"/docs/02_java/10_java-collections/","tags":"","title":"Java Collections"},{"body":"Ziele Ich kann erklären, was Collections sind. Ich kenne grob den Aufbau des Collections-Frameworks. Ich kenne die wichtigsten Interfaces und ihre Merkmale: List, Set, Queue, Map. Ich verstehe den Einsatz der Hash-Funktion zur Performance-Verbesserung. Ich kenne die wichtigsten Implementierungen und ihre Einsatzmöglichkeiten: ArrayList, HashSet, HashMap. Ich verstehe die Funktionsweise und Anwendung der Klasse ArrayList. Ich verstehe die Funktionsweise und Anwendung der Klasse HashSet. Ich verstehe die Funktionsweise und Anwendung der Klasse HashMap. Ich verstehe die Funktionsweise und Anwendung der Klasse Stack. Ich kenne die Funktionsweise und den Unterschied zwischen den Klassen Queue und Deque und kann diese anwenden. Ich verstehe die Funktionsweise und Anwendung der Klasse LinkedList. Voraussetzungen Gute Grundlagenkenntnisse von Java-Anwendungen. Einleitung Beim Programmieren müssen wir oft Daten speichern bzw. Informationen verwalten, um gewisse Probleme zu lösen. In diesem Modul werden wir das Java Collections Framework anschauen, weil dieses Framework uns die Werkzeuge zum effizienten Verwalten von Informationen liefert.\nEine Collection ist ein Objekt, das eine Sammlung von Objekten darstellt, d.h. mehrere Elemente zu einer Einheit zusammenfasst. In der Regel enthält eine Collection Datenelemente, die zusammen eine natürliche Gruppe bilden, wie z.B. eine Fussballmannschaft, die eine “Sammlung” von Fussballspielern ist, d.h. Fussballspieler enthält. Collections bieten uns im Allgemeinen die Möglichkeit neue Elemente hinzuzufügen, Elemente zu löschen und sonst die Elemente zu verwalten.\nEin bekanntes Beispiel für eine Collection ist die ArrayList Klasse, wobei eine ArrayList eine Liste von Objekten darstellt, welche skalierbar ist. Die ArrayList Klasse liefert uns beispielsweise die Methode add, mit welcher Elemente an das Ende einer Liste angefügt werden kann:\n1 2 3 4 5 List\u003cString\u003e farben=new ArrayList\u003cString\u003e(); farben.add(\"rot\"); farben.add(\"blau\"); farben.add(\"gelb\"); farben.add(\"orange\"); Oder sie liefert uns die Methode remove, welche Elemente aus der Liste entfernt:\n1 2 3 4 5 List\u003cString\u003e farben=new ArrayList\u003cString\u003e(); farben.add(\"rot\"); farben.add(\"blau\"); farben.add(\"gelb\"); farben.remove(\"blau\"); Wir werden die ArrayList Klasse später noch genauer anschauen.\nDas Java Collections Framework ist eine Menge von Interfaces und Klassen, die allgemein wiederverwendbare Collection-Datenstrukturen liefern. Es bietet uns also sowohl Interfaces, die Collection-Typen definieren, als auch Klassen, die diese implementieren an. Obwohl es als Framework bezeichnet wird, funktioniert es im Grunde wie eine Library.\nDas Java Collections Frameworks stellt für uns Hochleistungsimplementierungen von Datenstrukturen und Algorithmen bereit, um Sammlungen von Objekten beliebiger Datentypen darzustellen. Da wir diese Funktionalität nicht immer selbst programmieren müssen, reduziert sich für uns der Programmieraufwand markant.\nDas Java Collections Framework befindet sich im Paket java.util.\nWir haben die ArrayList Klasse (java.util.ArrayList) als Beispiel für eine Collection gesehen. Die ArrayList Klasse repräsentiert eine Collection vom Typ List (implementiert also das Interface java.util.List) und wird mithilfe von zugrunde liegenden Arrays implementiert, deshalb auch der Name ArrayList. Es gibt aber auch andere Klassen, die Collections vom Typ List darstellen. Wir werden später einige davon noch kennenlernen.\nTheorie Das Java Collections Framework ist eine einheitliche Architektur zur Darstellung und Bearbeitung von Collections, welche folgendes enthält:\nInterfaces: Dies sind abstrakte Datentypen, die verschiedene Collections darstellen. Mithilfe von Interfaces können Collections unabhängig von den Details ihrer Implementierung bearbeitet werden. Die Interfaces bilden in Java die Hierarchie aller Collections.\nImplementierungen/Klassen: Dies sind die konkreten Implementierungen der Collection-Interfaces. Im Grunde handelt es sich um wiederverwendbare Datenstrukturen mit konkreten Implementierungen.\nAlgorithmen/Methoden: Dies sind die Methoden, die nützliche Algorithmen, wie z. B. Hinzufügen, Löschen, Suchen und Sortieren, von Objekten in Collections durchführen. Viele Methoden und Algorithmen sind für verschiedene Arten der Collections wiederverwendbar.\nDie Interfaces in der folgenden Abbildung (Collection, Set, List, Queue, Deque, Map …) bilden die Grundlage des Collection Frameworks. Durch diese grundlegenden Interfaces bildet sich eine Hierarchie innerhalb des Collection Frameworks:\nAuf dieser Grafik ist zu sehen, dass zum Beispiel:\nSets spezielle Typen von Collections sind. SortedSets wiederum sind spezielle Typen von Sets. Lists sind spezielle Typen von Collections. ArrayLists sind spezielle Typen von Lists. In der Abbildung sieht man zudem, dass das Collection Framework aus zwei verschiedenen Teilen besteht: Zum einen die Collections und zum anderen die Maps. Maps stellen somit keine “echten” Collections dar. Maps sind trotzdem Datenstrukturen zur Darstellung von Sammlungen von Objekten als eine Einheit.\nCollection Eine Collection ist ein Objekt, dass eine Sammlung von Objekten darstellt, d.h. mehrere Elemente zu einer Einheit zusammenfasst. In der Regel enthält eine Collection Datenelemente, die zusammen eine natürliche Gruppe bilden, wie z.B. eine Fussballmannschaft, die eine “Sammlung” von Fussballspielern ist, d.h. Fussballspieler enthält. Collections bieten uns im Allgemeinen die Möglichkeit neue Elemente hinzuzufügen, Elemente zu löschen und sonst die Elemente zu verwalten.\nAllgemeine Methoden:\nsize(), isEmpty(), contains(Object element), add(E element), remove(Object element), clear(), iterator()\nSammelmethoden:\ncontainsAll(Collection\u003c?\u003e c), addAll(Collection\u003c? extends E\u003e c), removeAll(Collection\u003c?\u003e c), retainAll(Collection\u003c?\u003e c)\nList Eine List ist eine geordnete Sequenz, welche duplizierte Elemente erlaubt. Zusätzlich zu den geerbten Methoden der Collection bietet die List folgende an:\nElemente auf Basis ihrer Position zugreifen:\nget, set\nSuche nach einem bestimmten Element in der Liste:\nindexOf, lastIndexOf\nIteriert durch die Liste:\nlistIterator\nEin Teilbereich der Liste erstellen:\nsublist\nFolgend sind zwei gängige List Implementierungen:\nArrayList welche in Normalfall die leistungsfähigere Implementation ist. Sie basiert auf einem primitiven Array. LinkedList welche in bestimmten Situation die effizientere Lösung sein kann. Set Ein Set ist eine Collection, in welche man ein Element nur einmal hinzufügen kann. Das Set enthält die Funktionen der Collection, stellt aber sicher, dass Elemente nicht doppelt vorkommen können. Die equals und hashCode Funktionen spielen dabei eine wichtige Rolle. Sie definieren, wann zwei Elemente als gleich gelten.\nElemente hinzufügen, löschen und Infos abfragen:\nadd(), contains(), remove(), clear(), size(), isEmpty()\nSammelmethoden:\naddAll(), removeAll(), containsAll()\nZugriff wie auf eine Collection:\niterator()\nFolgend sind 3 gängige Set Implementationen:\nHashSet - Schnell, aber unsortiert\nSpeichert Elemente in keiner bestimmten Reihenfolge. Sehr schnell beim Einfügen und Suchen. TreeSet – Sortiert, aber langsamer\nSpeichert Elemente aufsteigend sortiert. Einfügen und Suchen dauert länger. LinkedHashSet – Reihenfolge bleibt erhalten\nSpeichert Elemente in der Reihenfolge, in der sie hinzugefügt wurden. Schneller als TreeSet, aber etwas langsamer als HashSet. Map Eine Map ist ein Objekt, dass Schüssel (keys) auf Werte (values) zuordnet. Eine Map kann nicht zwei gleiche Schlüssel enthalten. Jeder Schlüssel zeigt genau auf einen Wert. Das Interface Map definiert Grundfunktionen für das Einfügen, Lesen, Löschen, Abfragen von Schlüsseln usw.\nZusätzlich zu den vererbten Methoden der Collection bietet die List folgende an:\nElemente auf Basis ihrer Position zugreifen:\nput(), get(), containsKey(), containsValue()\nSammelmethoden:\nputAll()\nZugriff wie auf eine Collection:\nkeySet(), entrySet(), values()\nFolgend sind 3 gängige Implementationen von Map:\nHashMap – Schnell, aber unsortiert\nSpeichert Schlüssel-Wert-Paare in keiner bestimmten Reihenfolge. Sehr schnell beim Einfügen und Suchen. TreeMap – Sortiert, aber langsamer\nSpeichert Schlüssel nach ihrer natürlichen Ordnung oder mit einem Comparator. Einfügen und Suchen dauert länger. LinkedHashMap – Reihenfolge bleibt erhalten\nSpeichert Schlüssel in der Reihenfolge, in der sie hinzugefügt wurden. Schneller als TreeMap, aber etwas langsamer als HashMap. Performanz Das Collections-Framework nutzt intensiv die Hash-Funktion. Klassen wie HashSet oder HashMap verwenden die Hash-Funktion zur Steigerung der Performanz.\nHash-Funktion Alle Java Klassen erben von der Klasse java.lang.Object die Methode public int hashCode(). Diese liefert ein Hash Code von der eigenen Instanz zurück. Bei Java ist dieser ein Integer.\nHashing bezeichnet die Umwandlung einer Zeichenfolge in einen numerischen Wert oder Schlüssel mit fester Länge, der in der Regel kürzer ist. Das bedeutet also, aus einem Java Objekt mit verschiedenen Attributen wird eine Zahl berechnet. Immer, wenn das gleiche Objekt wieder berechnet wird, erhält man die gleiche Zahl.\nDer Java Hash Code ist nicht immer eindeutig. Es kann also vorkommen, dass unterschiedliche Instanzen verschiedener Klassen denselben Hash-Code zurückgeben. In der Praxis ist das jedoch kein Problem, da der Hash-Code lediglich für eine Vorselektion genutzt wird. Das bedeutet, wenn die Hash Codes nicht gleich sind, sind die Objekte definitiv nicht gleich. Sind die Hash Codes gleich, werden trotzdem noch die Objekte direkt vergleicht.\nVerwendung Schauen wir uns die Verwendung von Set an: Bei einem Set können wir mit der Methode contains(Object o) abfragen, ob ein Objekt in einem Set vorhanden ist. Das Set muss somit jedes Objekt mit dem Objekt vergleichen, welches wir der Methode contains übergeben. Falls ein Objekt jedoch viele Instanzvariablen (oder Attribute) besitzt – die wiederum Objekte sein können –, wäre ein direkter Vergleich potenziell aufwendig.\nBei einer Handvoll Objekte im Set ist das vernachlässigbar. Bei mehreren tausend Objekten würde die Suche jedoch deutlich ineffizienter. Die Klasse HashSet verfolgt daher eine optimierte Strategie:\nBeim Hinzufügen eines neuen Objekts berechnet HashSet dessen Hash-Code mit der Methode hashCode(). Dieser Hash-Code wird gespeichert. Bei der Methode contains(Object o) wird der Hash-Code des übergebenen Vergleichsobjekts berechnet. Anschliessend wird dieser mit den gespeicherten Hash-Codes verglichen (Integer-Vergleich). Da der Java-Hash-Code nicht eindeutig ist, erfolgt bei Übereinstimmung zusätzlich ein Vergleich mit der Methode equals(Object o), um sicherzustellen, dass es sich tatsächlich um dasselbe Objekt handelt. Mit der Hash-Code Strategie kann das HashSet die allermeisten Vergleiche auf einen Integer-Vergleich reduzieren.\nAnforderung an die Hash Berechnung Was ist die Anforderung an die Java hashCode() Methode?\nDie Berechnung muss schnell sein. Der Hash Code sollte in der Praxis meistens eindeutig sein. ","categories":"","description":"Modul #J6\n","excerpt":"Modul #J6\n","ref":"/de/docs/02_java/10_java-collections/","tags":"","title":"Java Collections"},{"body":"Was ist eine Programmiersprache? Eine Programmiersprache ist ein Werkzeug, mit dem man Computern mitteilt, was sie tun sollen.\nSie folgt dabei festen Regeln – ähnlich wie Grammatik in einer menschlichen Sprache – und erlaubt es dir, deine Gedanken in ausführbaren Code zu verwandeln.\nProgrammiersprachen unterscheiden sich in Syntax, Konzepten und Einsatzzwecken.\nJava, Python, JavaScript oder C# sind nur einige davon.\nWenn du eine Programmiersprache lernst, lernst du nicht nur Befehle auswendig, sondern auch logisches Denken, Strukturieren und Problemlösen. Entschuldige, da fehlt noch was...\n--\u003e Hier soll gezeigt werden, warum wir Programmiersprachen benötigen um einen Computer zu programmieren (Hex-Code ist nicht jedermanns Sache). Auch eine kleine Einführung wie ein Computer funktioniert hilft, zu verstehen, was bei der Software Entwicklung wichtig ist. ","categories":"","description":"Was ist eine Programmiersprache?\n","excerpt":"Was ist eine Programmiersprache?\n","ref":"/docs/99_tools/programmiersprachen/","tags":"","title":"Programmiersprachen"},{"body":"Ziele Ich weiss, was ein regulärer Ausdruck (RegEx) ist und wofür er verwendet wird. Ich kenne die wichtigsten RegEx-Symbole und deren Bedeutung. Ich kann einfache RegEx-Ausdrücke lesen und verstehen. Ich weiss, wo RegEx typischerweise eingesetzt werden. Ich kenne grundlegende Sicherheits- und Performance-Aspekte bei RegEx. ⏱️ Geschätzte Lesezeit: 15 Minuten Einführung Reguläre Ausdrücke (englisch: Regular Expressions, kurz RegEx) sind eine formale Sprache, um Muster in Texten zu beschreiben. Mit ihnen kannst du prüfen, ob ein Text einem bestimmten Muster entspricht, oder gezielt Textteile daraus extrahieren.\nTypische Einsatzgebiete:\nValidierung von Benutzereingaben (z. B. E-Mail, Telefonnummer, Postleitzahl) Durchsuchen und Ersetzen von Texten Analyse und Extraktion von Daten aus Dateien oder Log-Einträgen Grundsyntax (Cheat-Tabelle) Zeichen Bedeutung Beispiel Trifft z. B. . beliebiges Zeichen a.b a1b, a_b * 0 oder mehr Wiederholungen ab* a, abb + 1 oder mehr Wiederholungen ab+ ab, abb ? 0 oder 1 Wiederholung (optional) ab? a, ab {3} genau 3 Wiederholungen X{3} XXX {3,5} 3 bis 5 Wiederholungen X{3,5} XXX…XXXXX [] Zeichenauswahl [abc] a oder b [^...] Negation in Klasse [^abc] x, 1 … () Gruppierung / Capturing (abc)+ abcabc (?:...) Gruppe ohne Capturing (?:ab){2} abab | Oder (Alternation) rot|blau rot/blau \\d Ziffer \\d+ 123 \\D keine Ziffer \\D+ abc_ \\w Wortzeichen (A-Za-z0-9_) \\w+ Test_1 \\W kein Wortzeichen \\W+ - ! \\s Whitespace \\s+ ␠, \\t \\S kein Whitespace \\S+ abc_1 Greedy vs. Lazy: *?, +?, {m,n}? sind faule Varianten → sie matchen so wenig wie möglich.\nAnker \u0026 Wortgrenzen Zeilen vs. ganze Eingabe ^ = Anfang einer Zeile (oder Stringanfang, wenn multiline aus) $ = Ende einer Zeile (oder Stringende, wenn multiline aus) \\A = Beginn der gesamten Eingabe (unabhängig von multiline) \\z = Ende der gesamten Eingabe (wirklich letztes Zeichen) (Oft existiert auch \\Z = Ende oder direkt vor letztem Zeilenumbruch.) Faustregel:\nGanze Eingabe validieren? → \\A … \\z. Zeilenweise prüfen (Logs, CSV)? → ^ … $ mit multiline-Flag. Wortgrenzen \\b = Wortgrenze (Wechsel zwischen \\w und Nicht-\\w) – zero-width. Beispiel: \\bERROR\\b findet „ERROR“ als eigenständiges Wort. \\B = keine Wortgrenze. Unicode-Hinweis: In vielen Engines ist \\w standardmässig ASCII-basiert. Für Sprachen mit Umlauten/anderen Schriftsystemen prüfe Unicode-Optionen/Property-Klassen deiner Engine (z. B. \\p{L}, \\p{N}).\nLookaheads (Vorausschau) Lookaheads prüfen Bedingungen an der aktuellen Position, schauen nach vorn, verbrauchen keine Zeichen und verschieben die Match-Position nicht (zero-width assertions).\nPositiv (?=X): Ab hier muss X folgen. Negativ (?!X): Ab hier darf nicht X folgen. UND-Logik: Mehrere Lookaheads hintereinander sind UND (alle Bedingungen müssen erfüllt sein). ODER: Im Inneren eines Lookaheads mit | arbeiten.\nBeispiele (neutral):\nLokale Bedingung:\n1 foo(?!bar) → foo nur, wenn nicht bar folgt.\nReihenfolge egal (global prüfen):\n1 \\A(?=.*\\bAlpha\\b)(?=.*\\bBeta\\b)[\\s\\S]*\\z „Nur wenn gefolgt von …“ (Suffix prüfen):\n1 \\b[A-Z]{2}\\d{4}(?=-\\d{2}\\b) X im Lookahead kann ein vollwertiges Teil-Regex sein (Gruppen, Alternativen, Quantifizierer, Wortgrenzen, Anker …).\nWeitere Beispiele:\nRegex Bedeutung (?=.*TaFy) schau rechts ob irgend ein Zeichen vorkommt und dann TaFy (?=\\STaFy) schau rechts ob kein Lehrzeichen vorkommt und dann TaFy (?=[^s,]*TaFy) schau rechts ob kein Lehrzeichen und kein Komma vorkommt und dann TaFy (?=[^s,]*[A-Z]) schau rechts ob kein Lehrzeichen und kein Komma vorkommt und dann ein Grossbuchstaben Mehrere Treffer in einer Zeile finden Verwende eine „find all / global“-Suche (nicht „ganze Zeile matchen“). Überlappende Treffer erhältst du per Lookahead-Trick, z. B. (?=(aa)) findet in aaaa die drei überlappenden aa. Hinweis: Wie „global“ aktiviert wird, hängt von der Engine ab (Flag, API-Methode). Für dieses Modul genügt: global suchen und bei Bedarf Lookahead für überlappende Matches.\nBeispiele (neutral \u0026 kurz) Ganzes Wort „ERROR“:\n1 \\bERROR\\b Zeile enthält zwei Begriffe (Reihenfolge egal):\n1 ^(?=.*Alpha)(?=.*Beta).* Nur Ziffern (ganze Eingabe):\n1 \\A[0-9]+\\z Token nicht von einem bestimmten Zeichen gefolgt:\n1 TOKEN(?!\\)) Flags (Modifikatoren, engine‑neutral) Flags beeinflussen, wie der RegEx interpretiert wird. Bezeichnungen/Schreibweise variieren je nach Engine. Häufige Konzepte (inline meist als (?i), (?m), (?s) … verfügbar):\nCase‑insensitive (i): Gross/Kleinschreibung ignorieren. Multiline (m): ^ und $ matchen an Zeilenanfang/-ende statt nur am ganzen String. Dotall / Singleline (s): . matcht auch Zeilenumbrüche. Free‑spacing / Verbose (x): Whitespace/Kommentare im Muster ignorieren (für Lesbarkeit). Unicode‑Optionen: Verhalten von \\w, \\b, Klassen wie \\p{L} engineabhängig aktivieren. Ungreedy/Default‑lazy (U, PCRE): Kehrt Greedy/Lazy-Standard um (vorsichtig einsetzen). Details und exakte Namen sind engineabhängig (Java, .NET, PCRE, JavaScript). Schau in die Dokumentation deiner Engine.\nPerformance \u0026 Sicherheit (kurz \u0026 wichtig) 1) Catastrophic Backtracking Problem: Bestimmte Muster werden bei ungünstigen Eingaben extrem langsam. Ursache: Viele Backtracking-Wege (z. B. verschachtelte „weite“ Quantifizierer). Beispiel: (a+)+$ mit langer a…a!-Eingabe. Gegenmittel (engine‑abhängig): Muster präzisieren, lazy sinnvoll einsetzen, atomare Gruppen (?\u003e...), possessive Quantifizierer *+, ++, {m,n}+, Eingaben begrenzen. 2) Dynamische RegEx Problem: Ungeprüfte Benutzereingaben in Muster → Manipulation/Verlangsamung. Lösung: Eingaben escapen/whitelisten, Längenlimits setzen, ggf. Timeouts (falls vorhanden). 3) Überkomplexität Problem: Sehr komplexe RegEx sind schwer wartbar. Lösung: Aufteilen (Vorverarbeitung), kommentieren, möglichst einfach halten. 4) Engine‑Unterschiede Lookarounds: Moderne Engines (PCRE, .NET, Java) unterstützen Lookaheads; Lookbehind teils eingeschränkt. Manche Engines (z. B. RE2) unterstützen keine Lookarounds. Unicode: Verhalten von \\w, \\b variiert. Prüfe Flags/Optionen deiner Engine. Best Practices So einfach wie möglich. Erst dann optimieren/erweitern. Eingabe begrenzen. Länge, Inhalt, Vorverarbeitung (Trim, Normalisierung). Global testen. Einschliesslich Worst-Cases (lange Strings ohne Treffer). Anker bewusst setzen. \\A … \\z für „ganze Eingabe“, ^ … $ für Zeilen. Keine unnötigen „weiten“ Teile. Unpräzises .* vor/um Lookarounds sparsam einsetzen. Dokumentation lesen, wenn du Lookarounds, Unicode-Klassen, Flags nutzt (engine-spezifisch). Tipp Nutze einen RegEx-Tester (z. B. regex101) zum Ausprobieren und Debuggen (mit Erklärungen \u0026 Match-Schritten).\n","categories":"","description":"In diesem Modul lernst du die Grundlagen von regulären Ausdrücken, unabhängig von einer Programmiersprache.\n","excerpt":"In diesem Modul lernst du die Grundlagen von regulären Ausdrücken, …","ref":"/docs/99_tools/diverses/regex/","tags":"","title":"Reguläre Ausdrücke"},{"body":"Ziele Ich kann eine Eingabe von der Konsole lesen und in einer Variablen speichern. Scanner Eine Möglichkeit, Benutzereingaben in Java vorzunehmen, besteht in der Verwendung der Scanner-Klasse, die verwendet wird, indem zuerst die Definition der Klasse wie in Zeile 1 importiert und dann ein Objekt dieser Klasse wie in Zeile 6 erstellt wird.\n1 2 3 4 5 6 7 8 9 10 import java.util.Scanner; public class TakeInput { public static void main (String[] args) { Scanner scanner = new Scanner(System.in); System.out.println(\"Enter your name: \"); String name = scanner.nextLine(); System.out.println(\"Your name is: \" + name); } } Zeile 1\nDer erste Schritt besteht darin, die Scanner-Klasse zu importieren, damit sie im folgenden Code verwendet werden kann. Die Java Scanner-Klasse stammt aus dem Paket java.util. Es ist einfach zu bedienen, muss jedoch importiert werden, damit die Klasse funktioniert.\nZeile 6\nWir deklarieren den Datentyp als Scanner und geben ihm den Bezeichner scanner Wir weisen der Variable scanner ein neues Objekt zu, welches den System-Eingabestream enthält (System.in) Zeile 8\nWir deklarieren eine Variable vom Datentyp String mit dem Bezeichner name Wir weisen der Variable name das Resultat der Methode scanner.nextLine() zu Diese Methode nimmt die Tastatureingabe vom Benutzer auf der Kommandozeile entgegen. Sie wird beendet, wenn der Benutzer die Enter-Taste drückt. Zahlen einlesen Oft möchtest du, dass der Benutzer Zahlen in der Konsole eingeben kann. Hierfür bietet der Scanner eine passende Methode an:\n1 2 System.out.print(\"Enter an integer: \"); int number = scanner.nextInt(); Die Scanner.nextInt()-Methode gibt dir die letzte Zahl vor dem Enter und nach dem letzten Leerzeichen zurück.\nWie du es bereits an der mühsamen Formulierung des letzten Satzes siehst, hat diese Methode komische Eigenheiten. Wenn du z.B. nach dem Aufruf von nextInt() wieder nextLine() aufrufst, so gibt die zweit genannte Methode sofort einen leeren String zurück, weil das Enter von der Zahl noch nicht konsumiert wurde. Um dieses Problem in Java zu beheben, kannst du nextLine() 2 mal hintereinander aufrufen.\nFür die Labs und das Exams im Modul #J1 kannst du diese Methode gut brauchen. Spiele aber trotzdem ein bisschen mit dieser nextInt()-Methode, damit du die komischen Eigenheiten dieser Methode einmal kennenlernst.\nJetzt bist du dran. Löse bitte die Aufgabe 8 in den Labs.\n","categories":"","description":"Modul #J1\n","excerpt":"Modul #J1\n","ref":"/de/docs/02_java/03_java-grundlagen/10_scanner/","tags":"","title":"Scanner"},{"body":"Spring Boot Testing In diesem Kapitel lernst du verschiedene Testarten kennen, um eine Spring Boot Applikation auf Herz und Nieren zu prüfen.\nZiele Ich kenne die verschiedenen Testarten, um Spring Boot Applikationen zu testen und weiss, bei welchen Testszenarien diese anzuwenden sind. Ich kann verschiedene Testarten anwenden und Testfälle dazu schreiben. Ich kann Tests selektiv aktivieren/deaktivieren. Das Demo-Projekt und sein Setup Damit du den folgenden Erklärungen einfacher folgen und laufenden Code untersuchen kannst, klone bitte das folgende GitHub-Repo und öffne das Projekt in deiner IDE (Branch: master): https://github.com/it-ninjas/springboottesting/tree/master\nDas Repo beinhaltet eine laufende Spring Boot Applikation (wen wundert’s ;-)), die Personen verwaltet. Via REST-Schnittstelle können neue Personen erstellt werden (createPerson) und es gibt die Möglichkeit, alle Personen abzufragen (getAllPersons). Zur Verwaltung der Daten wird JPA verwendet. Damit du möglichst einfach Requests machen kannst, ist ein SwaggerUI vorhanden: http://localhost:8082/swagger-ui/index.html\nDatenbank: Die Applikation benötigt eine laufende JDBC Verbindung auf eine Maria-DB mit Namen ’testDB’. Die weiteren Verbindungs-Informationen entnimmst du /src/main/resources/application.properties.\nDatenbank Setup Du kannst entweder eine bestehende Datenbank verwenden oder dann mittels Docker/Podman einen Maria-DB Container hochfahren: Bestelle/Aktiviere dir die temporären Adminrechte. Als Grund kannst du die Installation von Podman angeben. Führe die Podman-Installation gemäss https://github.com/containers/podman/blob/main/docs/tutorials/podman-for-windows.md durch. Hier ist die Anleitung für Windows verlinkt. Du musst nur das Kapitel Installing Podman durchführen. Falls du eine Fehlermeldung im Sinne von “WSL 2 erfordert ein Update der Kernelkomponente.” erhältst, folge diesem Link: https://aka.ms/wsl2kernel und führe mindestens die Schritte 4 und 5 aus. Anschliessend führst du in der Kommando-Zeile podman machine init aus. Öffne die Kommando-Zeile (cmd, powershell, etc.). Podman starten (muss nach jedem Neustart des Geräts gemacht werden): podman machine start Maria-DB Container erstellen und starten: Wechsle ins Projektverzeichnis und erstelle einen Ordner ‘maria-db’: mkdir maria-db Starte den Container unter dem Namen mdb: podman run -d --name=mdb -p 3306:3306 -e MYSQL_USER=admin -e MYSQL_PASSWORD=saysoyeah -e MYSQL_ROOT_PASSWORD=SQLp4ss -e MYSQL_DATABASE=testDB -v ./maria-db:/var/lib/mysql docker.io/mariadb:latest Wenn du bereits eine Maria-DB auf Port 3306 am Laufen hast, musst du diese stoppen oder hier einen anderen Port verwenden: Ändere die erste Zahl 3306 auf einen neuen Port und anschliessend musst du auch die beiden application.properties Dateien anpassen. Prüfe, ob der Container läuft mittels: podman ps -a Ab jetzt kannst du den Container mittels podman stop mdb und podman start mdb stoppen und starten. Die Applikation ist minimalistisch aber mit den wichtigsten Spring-Boot-Layers aufgebaut:\nWir haben 1 Entity: Person Das PersonRepo basiert auf JpaRepository und definiert keine zusätzlichen Methoden. Auch der PersonService ist sehr kompliziert :-). Wichtig ist aber, dass er die @Component MyUtilityBean verwendet. So haben wir auch noch eine Utility-Bean, die wir beim Testen berücksichtigen können. Der PersonController bietet zwei REST API Methoden an: /persons (liefert alle Personen) /createPerson (so kannst du eine neue Person anlegen) Der PersonController verwendet den PersonService, welcher auf das PersonRepo zugreift, das die Person-Entity nutzt. Das Zwiebelprinzip in Reinkultur ;-).\nWährend du die Doku hier liest, schaust du dir parallel dazu die erwähnten Code-Stellen an, lässt die beschriebenen Tests laufen und versuchst so, die Erkärungen nachzuvollziehen.\nTestarten und Best Practices Wir wollen alle Layers (von der Entity bis zum Controller) testen. Dazu gibt es verschiedene Möglichkeiten und Best-Practices.\nNatürlich kannst du jeden Layer mit JUnit/Mockito testen. Das hast du ja bereits früher gelernt. Dazu nimmst du deine Unit-Under-Test (UUT) und mockst alles, was “darunter” liegt. Je nachdem kann das aber ganz schön mühsam sein resp. praktisch nicht möglich: Stell dir vor, du willst ein @Repository mit Mockito testen. Wie kommst du da an die automatisch durch den Spring-Container generierten Methoden (z.B. findAll())? Die Antwort lautet: Gar nicht.\nDeshalb gibt es Möglichkeiten, je nach Anwendungsfall den Spring Application-Context teilweise oder ganz hochzufahren. Wollen wir nur den Daten-Teil (Entity und Repo) hochfahren ist das ein @DataJpaTest, wenn du mit JPA arbeitest, oder ein @DataJdbcTest für eine Anwendung, die mit JDBC auf die Datenbank zugreift. Hier werden keine Services und auch keine Controller instanziiert.\nWollen wir nur den Controller-Teil (inkl. Security, Filter, Converter) hochfahren, ist das ein @WebMvcTest. Es werden keine Services, keine Repos und keine Entities instanziiert.\nBei @DataJpaTest, @DataJdbcTest und @WebMvcTest sprechen wir von sogenannten Slice-Tests, weil wir nur einen Teil-Bereich (intergrations-)testen.\nNatürlich können wir auch den ganzen Spring Application Context hochfahren. Dann verwenden wir @SpringBootTest.\nFür Services gibt es keine spezielle Slice-Test-Annotation oder Umgebung. Da nehmen wir entweder Mockito oder dann @SpringBootTest.\n@DataJpaTest, @DataJdbcTest, @WebMvcTest und @SpringBootTest fahren den Application-Context (oder zumindest Teile davon) hoch. Das ist langsamer bei der Ausführung, als pure Unit-Tests. Wir werden daher später lernen, nur gewisse Tests zu starten.\nBei @DataJpaTest, @DataJdbcTest, @WebMvcTest und @SpringBootTest kann man von ‘Integration-Tests’ sprechen, weil verschiedene Komponenten im Zusammenspiel untersucht werden. Wir könnten nun mit Maven das Failsave Plugin verwenden, das für Integrations-Tests verwendet wird. Das Failsave-Plugin springt in der Maven Phase ‘integraton-test’ an, also nach der Unit-Test-Phase ’test’. Es funktioniert anders als Unit-Tests. Um die Komplexität zu reduzieren, fahren wir in diesem Projekt aber alle Tests als Unit-Tests (Maven Phase ’test’).\nHier nochmals in der Übersicht, welche Testarten sich für welchen Layer eignen:\nLayer Testart(en) Begründung Entity/Repo @DataJpaTest oder @DataJdbcTest Wir wollen Queries bis auf die DB “runter” testen. Es gibt viel DB-Interaktion, nicht aber Logik. Service Mockito und @SpringBootTest Services beinhalten die Logik, daher mit Mockito. Services verbinden Repo und Controller, daher @SpringBootTest. Controller @WebMvcTest Es geht primär darum, Anfragen entgegenzunehmen und zurückzugeben, also Eingabe- und Ausgabe-Formate zu testen. Security etc. können ein Thema sein, nicht aber Logik. Utility-Klasse (hier MyUtilityBean) Mockito Reine Logik-Tests resp. “tun die Helper-Methoden, was sie sollen?\"-Tests. Hinweise: Im Demo-Projekt gibt es keinen Unit-Test für die MyUtilityBean. Tests ausführen, SpringBoot-Tests ignorieren Du kannst alle Tests mit mvn clean test ausführen.\nEvtl. schlägt der Test PersonRepoTestContainerDataJpaTest fehl. Das hat damit zu tun, dass bei dir Docker/Podman noch nicht installiert ist. Wir schauen das weiter unten im Abschnitt Testcontainers an.\nWie bereits weiter oben erwähnt, sind @DataJpaTest-, @DataJdbcTest-, @WebMvcTest- und @SpringBootTest-Tests zeitaufwändig bei der Ausführung. Deshalb wird auf diese Tests manchmal in einem ersten Testlauf auch verzichtet. Dazu gibt es verschiedene Wege, der einfachste ist aber so:\n1 mvn clean test -Dsurefire.excludes=**/*WebMvcTest*,**/*DataJpaTest*,**/*DataJdbcTest*,**/*SpringBootTest* Mit -Dsurefire.excludes=... kannst du festlegen, welche Unit-Tests ignoriert werden sollen. Das obige Beispiel bezieht sich auf die Bennenung der Tests im Demo-Projekt: Alle Tests die WebMvcTest oder DataJpaTest oder DataJdbcTest oder SpringBootTest im Klassenamen haben werden so ignoriert.\nService testen mit Mockito Nun schauen wir an, wie die einzelnen Layers getestet werden können. Starten wir mit dem PersonService!\nHier die UUT:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package com.demo.springboottesting.services; import com.demo.springboottesting.entities.Person; import com.demo.springboottesting.repos.PersonRepo; import com.demo.springboottesting.utilities.MyUtilityBean; import java.util.List; import lombok.RequiredArgsConstructor; import org.springframework.stereotype.Service; @Service @RequiredArgsConstructor public class PersonService { private final PersonRepo repo; private final MyUtilityBean myUtilityBean; public List\u003cPerson\u003e getAllPerson() { return repo.findAll(); } public Person createPerson(Person person) { myUtilityBean.addPerson(person); return repo.save(person); } } Wir schreiben zuerst Mockito-Tests. Wie das geht, sollte dir bereits bekannt sein. So sieht unser Testaufbau aus:\nDamit Mockito funktioniert, verwende die folgende Dependency im pom.xml 1 2 3 4 5 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 package com.demo.springboottesting.services; import static org.assertj.core.api.Assertions.assertThat; import static org.mockito.ArgumentMatchers.any; import static org.mockito.BDDMockito.given; import static org.mockito.Mockito.times; import static org.mockito.Mockito.verify; import com.demo.springboottesting.entities.Person; import com.demo.springboottesting.repos.PersonRepo; import com.demo.springboottesting.utilities.MyUtilityBean; import java.util.List; import org.junit.jupiter.api.Test; import org.junit.jupiter.api.extension.ExtendWith; import org.mockito.ArgumentCaptor; import org.mockito.InjectMocks; import org.mockito.Mock; import org.mockito.Spy; import org.mockito.junit.jupiter.MockitoExtension; @ExtendWith(MockitoExtension.class) class PersonServiceTest { @Mock private PersonRepo personRepo; @Spy private MyUtilityBean myUtilityBean; @InjectMocks private PersonService personService; @Test void getAllPerson() { //Given Person person = new Person(1, \"Ahnis\", \"Gotham\"); Person person2 = new Person(2, \"Saksham\", \"New york\"); given(personRepo.findAll()) .willReturn(List.of(person, person2)); //When var personList = personService.getAllPerson(); //Then assertThat(personList).hasSize(2); } @Test void createPersons() { //Given Person person = new Person(1, \"Ahnis\", \"Gotham\"); Person person2 = new Person(2, \"Saksham\", \"New york\"); given(personRepo.save(any())) .willReturn(any()); //When personService.createPerson(person); personService.createPerson(person2); //Then ArgumentCaptor\u003cPerson\u003e personCaptor = ArgumentCaptor.forClass(Person.class); verify(myUtilityBean, times(2)).addPerson(personCaptor.capture()); assertThat(personCaptor.getAllValues().get(0)).isEqualTo(person); } } Wichtige Punkte zum Test:\nDas PersonRepo wird gemockt. createPerson(): Die MyUtilityBean wird gespied, ob sie 2x aufgerufen wird und gleichzeitig wird gecaptured, ob die Bean auch die korrekten Person-Objekte übergeben bekommt. Service mit @SpringBootTest testen Wir testen erneut den PersonService, jetzt aber mit dem kompletten Application-Context. Auf Mocks verzichten wir. Es gibt keine spezielle Annotation für Slice-Tests mit Services. Deshalb fahren wir den gesamten Application-Context hoch:\nWir verwenden eine H2 In-Memory Datenbank.\nVerwende die folgenden Dependencies im pom.xml 1 2 3 4 5 6 7 8 9 10 11 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.h2database\u003c/groupId\u003e \u003cartifactId\u003eh2\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 package com.demo.springboottesting.services; import static org.assertj.core.api.Assertions.assertThat; import static org.mockito.Mockito.times; import static org.mockito.Mockito.verify; import com.demo.springboottesting.entities.Person; import com.demo.springboottesting.repos.PersonRepo; import com.demo.springboottesting.utilities.MyUtilityBean; import org.junit.jupiter.api.Test; import org.mockito.ArgumentCaptor; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.bean.override.mockito.MockitoSpyBean; import org.springframework.test.annotation.DirtiesContext; import org.springframework.test.context.jdbc.Sql; @SpringBootTest class PersonServiceSpringBootTest { @Autowired private PersonRepo personRepo; @MockitoSpyBean private MyUtilityBean myUtilityBean; @Autowired private PersonService personService; @Test @Sql(scripts = {\"/data_personservice.sql\"}) @DirtiesContext void getAllPerson() { //When var personList = personService.getAllPerson(); //Then assertThat(personList).hasSize(2); } @Test @DirtiesContext void createPersons() { //Given Person person = new Person(null, \"Fritz\", \"Thun\"); Person person2 = new Person(null, \"Alexandra\", \"Biel/Bienne\"); //When personService.createPerson(person); personService.createPerson(person2); //Then assertThat(personRepo.findAll()).hasSize(2); ArgumentCaptor\u003cPerson\u003e personCaptor = ArgumentCaptor.forClass(Person.class); verify(myUtilityBean, times(2)).addPerson(personCaptor.capture()); assertThat(personCaptor.getAllValues().get(0)).isEqualTo(person); } } Wichtige Punkte zum Test:\nZur DB-Konfiguration verwenden wir das application.properties aus /src/test/resources. Wird ein Test gestartet, scannt Spring zuerst die Dateien in /src/test. Da dort ein application.properties vorhanden ist, wird dieses verwenden. Falls nicht, würde in einem zweiten Schritt /src/main gescannt und die entsprechende application.properties Datei verwendet werden. Anstelle von @Spy (und @Mock) wird @MockitoSpyBean (und @MockitoBean) verwendet. Du kannst jedoch dieselben Assertions und Verifys verwenden. @MockitoBean wird eingesetzt, damit der Mock die effektive Bean im Application-Context ersetzt und so überall der Mock verwendet wird. @MockitoSpyBean wird genutzt, um die bestehende Bean innerhalb des Applikation-Contexts auszuspionieren und nicht isoliert zu betrachten. Für den Test getAllPersons() verwenden wir ein spezifisches @Sql Script data_personservice.sql. Die Annotation @DirtiesContext bewirkt, dass nach dem Test die DB zurückgesetzt wird. Andernfalls hätten wir noch die Daten aus dem vorherigen Test in der DB. Im Test createPersons() verwenden wir einen ArgumentCaptor auf der myUtilityBean und zählen, ob auf ihr 2x die Methode addPerson() aufgerufen wird und ob die erste Person auch unseren Testdaten entspricht. WebEnvironment deaktivieren: Falls du verhindern möchtest, dass das WebEnvironment (u.a. Controller) hochgefahren wird, kannst du die Annoation @SpringBootTest erweitern um @SpringBootTest(webEnvironment = WebEnvironment.NONE). In diesem Szenario hier wäre das sicher sinnvoll, da wir den Controller sowieso nicht verwenden. Also los, ändere die Annotation! Controller mit @WebMvcTest testen Nun testen wir den PersonController. Dazu fahren wir einen Slice-Test mit @WebMvcTest. Es werden weder Services, noch Repos, noch Entities hochgefahren. Deshalb mocken wir den PersonService:\nVerwende die folgenden Dependencies im pom.xml 1 2 3 4 5 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e Hier die UUT:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package com.demo.springboottesting.controllers; import com.demo.springboottesting.entities.Person; import com.demo.springboottesting.services.PersonService; import jakarta.validation.Valid; import java.util.List; import lombok.RequiredArgsConstructor; import org.springframework.http.ResponseEntity; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RestController; @RestController @RequiredArgsConstructor public class PersonController { private final PersonService personService; @GetMapping(\"/persons\") public ResponseEntity\u003cList\u003cPerson\u003e\u003e getAllPersons() { return ResponseEntity.ok(personService.getAllPerson()); } @PostMapping(\"/createPerson\") public ResponseEntity\u003cPerson\u003e createPerson(@Valid @RequestBody Person person) { return ResponseEntity.ok(personService.createPerson(person)); } } Und hier die Test-Klasse:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 package com.demo.springboottesting.controllers; import static org.mockito.ArgumentMatchers.any; import static org.mockito.Mockito.when; import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get; import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post; import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status; import com.demo.springboottesting.entities.Person; import com.demo.springboottesting.services.PersonService; import java.util.List; import org.hamcrest.core.StringContains; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest; import org.springframework.test.context.bean.override.mockito.MockitoBean; import org.springframework.http.MediaType; import org.springframework.test.web.servlet.MockMvc; @WebMvcTest class PersonControllerWebMvcTest { @Autowired private MockMvc mockMvc; @Autowired private ObjectMapper objectMapper; @MockitoBean private PersonService personService; @Test void getAllPersons() throws Exception { //given Person person = new Person(1, \"Ahnis\", \"Gotham\"); Person person2 = new Person(2, \"Saksham\", \"New york\"); when(personService.getAllPerson()).thenReturn(List.of(person, person2)); //when mockMvc.perform(get(\"/persons\")) //then .andDo(print()) .andExpect(status().isOk()) .andExpect(content().string(StringContains.containsString(\"Ahnis\"))) .andExpect(content().string(StringContains.containsString(\"Saksham\"))) ; } @Test void createPerson() throws Exception { //given when(personService.createPerson(any())).thenAnswer(invocationOnMock -\u003e { Person p = invocationOnMock.getArgument(0); p.setPersonId(1); return p; }); Person dto = new Person(1, \"Alexandra\", \"Biel\"); //when mockMvc.perform(post(\"/createPerson\") .contentType(MediaType.APPLICATION_JSON) .content(objectMapper.writeValueAsString(dto))) //then .andDo(print()) .andExpect(jsonPath(\"$.personName\").value(\"Alexandra\")) .andExpect(jsonPath(\"$.personCity\").value(\"Biel\")) .andExpect(jsonPath(\"$.personId\").isNumber()); } } Wichtige Punkte zum Test:\nDer PersonService wird gemockt. Wir verwenden einen MockMvc. Damit können wir (REST-)Requests absetzen und die Antworten auswerten. getAllPersons() mockMvc.perform(get(\"/persons\")).andDo(print()).andExcpect(...)...: Zuerst wird die Rest Schnittstelle /persons aufgerufen. andDo(print()) gibt die Response in der Konsole aus. Alle weiteren andExpect(...) arbeiten mit der Reponse. content().string(...) holt den Body der Reponse und konvertiert ihn in einen String. Danach wird geschaut, ob der Body gewisse Strings enthält. createPerson() wertet die JSON-Response detailliert aus. objectMapper.writeValueAsString(dto): Wir konvertieren das Person-Objekt automatisch nach JSON. Bei jsonPath(\"$.personName\") bezieht sich $ auf das zurückgegebene einzelne Objekt. Erwarten wir eine Liste von Objekten kann über den Index auf ein entsprechendes Objekt zugegriffen werden. Wollen wir z.B. auf das 2te Objekt in der Liste zugreifen, verwenden wir $[1].personName . (Tipp am Rande: Falls du trotzdem eine DB verwenden würdest: Es gibt kein automatisches Rollback der Daten nach jedem Test.) Repo/Entity mit @DataJpaTest oder @DataJdbcTest testen Jetzt ist das PersonRepo inkl. Person (Entität) und DB dran. Wir fahren den Slice-Test mit @DataJpaTest.\nFalls deine Applikation mit JDBC implementiert ist, kannst du einfach @DataJpaTest durch @DataJdbcTest ersetzen, da sich beide Slice-Tests gleich verhalten.\nEs werden nur DB, Entities und Repositories initialisert, keine Services, keine Controller:\nAuch hier verwenden wir die H2 In-Memory DB.\nVerwende die folgenden Dependencies im pom.xml 1 2 3 4 5 6 7 8 9 10 11 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.h2database\u003c/groupId\u003e \u003cartifactId\u003eh2\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e Hier die UUT:\n1 2 3 4 5 6 7 8 package com.demo.springboottesting.repos; import com.demo.springboottesting.entities.Person; import org.springframework.data.jpa.repository.JpaRepository; public interface PersonRepo extends JpaRepository\u003cPerson, Integer\u003e { } Und hier die Test-Klasse:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package com.demo.springboottesting.repos; import static org.assertj.core.api.Assertions.assertThat; import static org.junit.jupiter.api.Assertions.assertTrue; import com.demo.springboottesting.entities.Person; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest; @DataJpaTest(showSql = true) class PersonRepoDataJpaTest { @Autowired private PersonRepo personRepo; private Person testPerson; @BeforeEach public void setUp() { // Initialize test data before each test method testPerson = new Person(null, \"Maria\", \"Bern\"); personRepo.save(testPerson); } //Not needed, DB is reset after every test run // @AfterEach // public void tearDown() { // // Release test data after each test method // personRepo.delete(testPerson); // } @Test void existsById() { assertTrue(personRepo.existsById(testPerson.getPersonId())); } @Test void findAll() { assertThat(personRepo.findAll()).hasSize(1); } } Wichtige Punkte zum Test:\nZur DB-Konfiguration verwenden wir das application.properties aus /src/test/resources. Dieses wird zuerst verwendet, weil es vorhanden ist. @BeforeEach: vor jedem Test füllen wir die DB mit einer Person ab. Nach jedem Test müssen wir die DB nicht manuell (oder mit tearDown()) resetten oder den Test mit @DirtiesContext annotieren. Dies passiert bei @DataJpaTest automatisch. Testcontainers Mit Testcontainers kannst du beliebige Umsysteme einbinden. Das System basiert auf Docker/Podman-Containern, die für den Test hochgefahren und initalisiert werden. Der Vorteil ist, dass du für den Test exakt dieselben Umsysteme wie in der Produktion verwenden kannst. Beispiel: Anstelle einer H2 In-Memory-DB können wir nun eine Maria-DB verwenden, wie sie auch in der deployten App genutzt wird. Grundsätzlich kannst du alle Container verwenden, die auf https://hub.docker.com/ zur Verfügung gestellt werden oder die du selber erstellt hast.\nDamit Testcontainers funktionieren, musst du zuerst Podman/Docker installieren. Falls noch nicht gemacht, führe die Schritte 1-4 aus im oben beschriebenen Datenbank Setup. Nun hast du Podman installiert und gestartet.\nWir testen erneut das PersonRepo mit einem @DataJpaTest.\nVerwende die folgenden Dependencies im pom.xml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-testcontainers\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.testcontainers\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter\u003c/artifactId\u003e \u003cversion\u003e1.20.2\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.testcontainers\u003c/groupId\u003e \u003cartifactId\u003emariadb\u003c/artifactId\u003e \u003cversion\u003e1.20.2\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 package com.demo.springboottesting.repos; import static org.assertj.core.api.Assertions.assertThat; import static org.junit.jupiter.api.Assertions.assertTrue; import com.demo.springboottesting.entities.Person; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase; import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase.Replace; import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest; import org.springframework.test.context.DynamicPropertyRegistry; import org.springframework.test.context.DynamicPropertySource; import org.springframework.test.context.TestPropertySource; import org.testcontainers.containers.MariaDBContainer; import org.testcontainers.junit.jupiter.Container; import org.testcontainers.junit.jupiter.Testcontainers; @DataJpaTest(showSql = true) //Optional: We specify to use only our own DB connection settings below. //If you still want to use DB settings from /src/test/resources/application.properties comment out the following line: @AutoConfigureTestDatabase( replace = Replace.ANY ) //Set properties for these specific tests: @TestPropertySource( properties = {\"spring.jpa.hibernate.ddl-auto=create-drop\"} ) //Tell the testrunner to use testcontainers: @Testcontainers class PersonRepoTestContainerDataJpaTest { //Create the container with other properties (here related to the base DB-connection): @Container static MariaDBContainer\u003c?\u003e testContainer = new MariaDBContainer\u003c\u003e( \"mariadb:latest\" ); @DynamicPropertySource static void properties( DynamicPropertyRegistry registry ) { registry.add(\"spring.datasource.driver-class-name\", testContainer::getDriverClassName); registry.add( \"spring.datasource.url\", testContainer::getJdbcUrl ); registry.add( \"spring.datasource.username\", testContainer::getUsername ); registry.add( \"spring.datasource.password\", testContainer::getPassword ); } @Autowired private PersonRepo personRepo; private Person testPerson; @BeforeEach public void setUp() { // Initialize test data before each test method testPerson = new Person(null, \"Maria\", \"Bern\"); personRepo.save(testPerson); } @Test void existsById() { assertTrue(personRepo.existsById(testPerson.getPersonId())); } @Test void findAll() { assertThat(personRepo.findAll()).hasSize(1); } } Wichtige Punkte zum Test:\n@AutoConfigureTestDatabase( replace = Replace.ANY ): Wir deaktivieren die Konfiguration aus /src/test/resources/application.properties komplett. @TestPropertySource( properties = {\"spring.jpa.hibernate.ddl-auto=create-drop\"} ): Wir übergeben für diese Test-Klasse spezifische Properties, d.h. die DB wird komplett gelöscht und das Schema neu erzeugt. @Testcontainers: Wird benötigt, damit der Test mit Testcontainers überhaupt funktioniert. Container erstellen und Config-Daten aus dem gestarteten Container ins application.properties übernehmen: 1 2 3 4 5 6 7 8 9 @Container static MariaDBContainer\u003c?\u003e testContainer = new MariaDBContainer\u003c\u003e( \"mariadb:latest\" ); @DynamicPropertySource static void properties( DynamicPropertyRegistry registry ) { registry.add(\"spring.datasource.driver-class-name\", testContainer::getDriverClassName); registry.add( \"spring.datasource.url\", testContainer::getJdbcUrl ); registry.add( \"spring.datasource.username\", testContainer::getUsername ); registry.add( \"spring.datasource.password\", testContainer::getPassword ); } @Container: Wir instanzieren einen Maria-DB Container. Falls der Container lokal noch nicht vorhanden ist im Docker/Podman wird er zuerst heruntergeladen. Hier verwenden wir jeweils die latest-Version von Maria-DB. In einer echten Applikation sollte hier stattdessen eine konkrete Version definiert werden. Wie du siehst, definieren wir an verschiedenen Orten die benötigten Properties. Standard-Properties werden hier über @DynamicPropertySource hinzugefügt. Wir übernehmen aus dem testContainer die DB-Verbindungs-Properties. Solange wir diese nicht überschreiben, werden Default-Werte zurückgegeben. Test-spezifische Properties werden über die Klassen-Annotation @TestPropertySource gesetzt. Grundsätzlich könntest du aber auch nur mit der DynamicPropertySource arbeiten. Jetzt bist du dran. Löse die Aufgaben in Spring Boot Testing - Aufgaben!\n","categories":"","description":"Modul #J08 - Spring Framework - Spring Boot Testing\n","excerpt":"Modul #J08 - Spring Framework - Spring Boot Testing\n","ref":"/docs/02_java/12_spring-framework/10_spring-boot-testing/","tags":"","title":"Spring Boot Testing"},{"body":"Spring Boot Testing In diesem Kapitel lernst du verschiedene Testarten kennen, um eine Spring Boot Applikation auf Herz und Nieren zu prüfen.\nZiele Ich kenne die verschiedenen Testarten, um Spring Boot Applikationen zu testen und weiss, bei welchen Testszenarien diese anzuwenden sind. Ich kann verschiedene Testarten anwenden und Testfälle dazu schreiben. Ich kann Tests selektiv aktivieren/deaktivieren. Das Demo-Projekt und sein Setup Damit du den folgenden Erklärungen einfacher folgen und laufenden Code untersuchen kannst, klone bitte das folgende GitHub-Repo und öffne das Projekt in deiner IDE (Branch: master): https://github.com/it-ninjas/springboottesting/tree/master\nDas Repo beinhaltet eine laufende Spring Boot Applikation (wen wundert’s ;-)), die Personen verwaltet. Via REST-Schnittstelle können neue Personen erstellt werden (createPerson) und es gibt die Möglichkeit, alle Personen abzufragen (getAllPersons). Zur Verwaltung der Daten wird JPA verwendet. Damit du möglichst einfach Requests machen kannst, ist ein SwaggerUI vorhanden: http://localhost:8082/swagger-ui/index.html\nDatenbank: Die Applikation benötigt eine laufende JDBC Verbindung auf eine Maria-DB mit Namen ’testDB’. Die weiteren Verbindungs-Informationen entnimmst du /src/main/resources/application.properties.\nDatenbank Setup Du kannst entweder eine bestehende Datenbank verwenden oder dann mittels Docker/Podman einen Maria-DB Container hochfahren: Bestelle/Aktiviere dir die temporären Adminrechte. Als Grund kannst du die Installation von Podman angeben. Führe die Podman-Installation gemäss https://github.com/containers/podman/blob/main/docs/tutorials/podman-for-windows.md durch. Hier ist die Anleitung für Windows verlinkt. Du musst nur das Kapitel Installing Podman durchführen. Falls du eine Fehlermeldung im Sinne von “WSL 2 erfordert ein Update der Kernelkomponente.” erhältst, folge diesem Link: https://aka.ms/wsl2kernel und führe mindestens die Schritte 4 und 5 aus. Anschliessend führst du in der Kommando-Zeile podman machine init aus. Öffne die Kommando-Zeile (cmd, powershell, etc.). Podman starten (muss nach jedem Neustart des Geräts gemacht werden): podman machine start Maria-DB Container erstellen und starten: Wechsle ins Projektverzeichnis und erstelle einen Ordner ‘maria-db’: mkdir maria-db Starte den Container unter dem Namen mdb: podman run -d --name=mdb -p 3306:3306 -e MYSQL_USER=admin -e MYSQL_PASSWORD=saysoyeah -e MYSQL_ROOT_PASSWORD=SQLp4ss -e MYSQL_DATABASE=testDB -v ./maria-db:/var/lib/mysql docker.io/mariadb:latest Wenn du bereits eine Maria-DB auf Port 3306 am Laufen hast, musst du diese stoppen oder hier einen anderen Port verwenden: Ändere die erste Zahl 3306 auf einen neuen Port und anschliessend musst du auch die beiden application.properties Dateien anpassen. Prüfe, ob der Container läuft mittels: podman ps -a Ab jetzt kannst du den Container mittels podman stop mdb und podman start mdb stoppen und starten. Die Applikation ist minimalistisch aber mit den wichtigsten Spring-Boot-Layers aufgebaut:\nWir haben 1 Entity: Person Das PersonRepo basiert auf JpaRepository und definiert keine zusätzlichen Methoden. Auch der PersonService ist sehr kompliziert :-). Wichtig ist aber, dass er die @Component MyUtilityBean verwendet. So haben wir auch noch eine Utility-Bean, die wir beim Testen berücksichtigen können. Der PersonController bietet zwei REST API Methoden an: /persons (liefert alle Personen) /createPerson (so kannst du eine neue Person anlegen) Der PersonController verwendet den PersonService, welcher auf das PersonRepo zugreift, das die Person-Entity nutzt. Das Zwiebelprinzip in Reinkultur ;-).\nWährend du die Doku hier liest, schaust du dir parallel dazu die erwähnten Code-Stellen an, lässt die beschriebenen Tests laufen und versuchst so, die Erkärungen nachzuvollziehen.\nTestarten und Best Practices Wir wollen alle Layers (von der Entity bis zum Controller) testen. Dazu gibt es verschiedene Möglichkeiten und Best-Practices.\nNatürlich kannst du jeden Layer mit JUnit/Mockito testen. Das hast du ja bereits früher gelernt. Dazu nimmst du deine Unit-Under-Test (UUT) und mockst alles, was “darunter” liegt. Je nachdem kann das aber ganz schön mühsam sein resp. praktisch nicht möglich: Stell dir vor, du willst ein @Repository mit Mockito testen. Wie kommst du da an die automatisch durch den Spring-Container generierten Methoden (z.B. findAll())? Die Antwort lautet: Gar nicht.\nDeshalb gibt es Möglichkeiten, je nach Anwendungsfall den Spring Application-Context teilweise oder ganz hochzufahren. Wollen wir nur den Daten-Teil (Entity und Repo) hochfahren ist das ein @DataJpaTest, wenn du mit JPA arbeitest, oder ein @DataJdbcTest für eine Anwendung, die mit JDBC auf die Datenbank zugreift. Hier werden keine Services und auch keine Controller instanziiert.\nWollen wir nur den Controller-Teil (inkl. Security, Filter, Converter) hochfahren, ist das ein @WebMvcTest. Es werden keine Services, keine Repos und keine Entities instanziiert.\nBei @DataJpaTest, @DataJdbcTest und @WebMvcTest sprechen wir von sogenannten Slice-Tests, weil wir nur einen Teil-Bereich (intergrations-)testen.\nNatürlich können wir auch den ganzen Spring Application Context hochfahren. Dann verwenden wir @SpringBootTest.\nFür Services gibt es keine spezielle Slice-Test-Annotation oder Umgebung. Da nehmen wir entweder Mockito oder dann @SpringBootTest.\n@DataJpaTest, @DataJdbcTest, @WebMvcTest und @SpringBootTest fahren den Application-Context (oder zumindest Teile davon) hoch. Das ist langsamer bei der Ausführung, als pure Unit-Tests. Wir werden daher später lernen, nur gewisse Tests zu starten.\nBei @DataJpaTest, @DataJdbcTest, @WebMvcTest und @SpringBootTest kann man von ‘Integration-Tests’ sprechen, weil verschiedene Komponenten im Zusammenspiel untersucht werden. Wir könnten nun mit Maven das Failsave Plugin verwenden, das für Integrations-Tests verwendet wird. Das Failsave-Plugin springt in der Maven Phase ‘integraton-test’ an, also nach der Unit-Test-Phase ’test’. Es funktioniert anders als Unit-Tests. Um die Komplexität zu reduzieren, fahren wir in diesem Projekt aber alle Tests als Unit-Tests (Maven Phase ’test’).\nHier nochmals in der Übersicht, welche Testarten sich für welchen Layer eignen:\nLayer Testart(en) Begründung Entity/Repo @DataJpaTest oder @DataJdbcTest Wir wollen Queries bis auf die DB “runter” testen. Es gibt viel DB-Interaktion, nicht aber Logik. Service Mockito und @SpringBootTest Services beinhalten die Logik, daher mit Mockito. Services verbinden Repo und Controller, daher @SpringBootTest. Controller @WebMvcTest Es geht primär darum, Anfragen entgegenzunehmen und zurückzugeben, also Eingabe- und Ausgabe-Formate zu testen. Security etc. können ein Thema sein, nicht aber Logik. Utility-Klasse (hier MyUtilityBean) Mockito Reine Logik-Tests resp. “tun die Helper-Methoden, was sie sollen?\"-Tests. Hinweise: Im Demo-Projekt gibt es keinen Unit-Test für die MyUtilityBean. Tests ausführen, SpringBoot-Tests ignorieren Du kannst alle Tests mit mvn clean test ausführen.\nEvtl. schlägt der Test PersonRepoTestContainerDataJpaTest fehl. Das hat damit zu tun, dass bei dir Docker/Podman noch nicht installiert ist. Wir schauen das weiter unten im Abschnitt Testcontainers an.\nWie bereits weiter oben erwähnt, sind @DataJpaTest-, @DataJdbcTest-, @WebMvcTest- und @SpringBootTest-Tests zeitaufwändig bei der Ausführung. Deshalb wird auf diese Tests manchmal in einem ersten Testlauf auch verzichtet. Dazu gibt es verschiedene Wege, der einfachste ist aber so:\n1 mvn clean test -Dsurefire.excludes=**/*WebMvcTest*,**/*DataJpaTest*,**/*DataJdbcTest*,**/*SpringBootTest* Mit -Dsurefire.excludes=... kannst du festlegen, welche Unit-Tests ignoriert werden sollen. Das obige Beispiel bezieht sich auf die Bennenung der Tests im Demo-Projekt: Alle Tests die WebMvcTest oder DataJpaTest oder DataJdbcTest oder SpringBootTest im Klassenamen haben werden so ignoriert.\nService testen mit Mockito Nun schauen wir an, wie die einzelnen Layers getestet werden können. Starten wir mit dem PersonService!\nHier die UUT:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package com.demo.springboottesting.services; import com.demo.springboottesting.entities.Person; import com.demo.springboottesting.repos.PersonRepo; import com.demo.springboottesting.utilities.MyUtilityBean; import java.util.List; import lombok.RequiredArgsConstructor; import org.springframework.stereotype.Service; @Service @RequiredArgsConstructor public class PersonService { private final PersonRepo repo; private final MyUtilityBean myUtilityBean; public List\u003cPerson\u003e getAllPerson() { return repo.findAll(); } public Person createPerson(Person person) { myUtilityBean.addPerson(person); return repo.save(person); } } Wir schreiben zuerst Mockito-Tests. Wie das geht, sollte dir bereits bekannt sein. So sieht unser Testaufbau aus:\nDamit Mockito funktioniert, verwende die folgende Dependency im pom.xml 1 2 3 4 5 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 package com.demo.springboottesting.services; import static org.assertj.core.api.Assertions.assertThat; import static org.mockito.ArgumentMatchers.any; import static org.mockito.BDDMockito.given; import static org.mockito.Mockito.times; import static org.mockito.Mockito.verify; import com.demo.springboottesting.entities.Person; import com.demo.springboottesting.repos.PersonRepo; import com.demo.springboottesting.utilities.MyUtilityBean; import java.util.List; import org.junit.jupiter.api.Test; import org.junit.jupiter.api.extension.ExtendWith; import org.mockito.ArgumentCaptor; import org.mockito.InjectMocks; import org.mockito.Mock; import org.mockito.Spy; import org.mockito.junit.jupiter.MockitoExtension; @ExtendWith(MockitoExtension.class) class PersonServiceTest { @Mock private PersonRepo personRepo; @Spy private MyUtilityBean myUtilityBean; @InjectMocks private PersonService personService; @Test void getAllPerson() { //Given Person person = new Person(1, \"Ahnis\", \"Gotham\"); Person person2 = new Person(2, \"Saksham\", \"New york\"); given(personRepo.findAll()) .willReturn(List.of(person, person2)); //When var personList = personService.getAllPerson(); //Then assertThat(personList).hasSize(2); } @Test void createPersons() { //Given Person person = new Person(1, \"Ahnis\", \"Gotham\"); Person person2 = new Person(2, \"Saksham\", \"New york\"); given(personRepo.save(any())) .willReturn(any()); //When personService.createPerson(person); personService.createPerson(person2); //Then ArgumentCaptor\u003cPerson\u003e personCaptor = ArgumentCaptor.forClass(Person.class); verify(myUtilityBean, times(2)).addPerson(personCaptor.capture()); assertThat(personCaptor.getAllValues().get(0)).isEqualTo(person); } } Wichtige Punkte zum Test:\nDas PersonRepo wird gemockt. createPerson(): Die MyUtilityBean wird gespied, ob sie 2x aufgerufen wird und gleichzeitig wird gecaptured, ob die Bean auch die korrekten Person-Objekte übergeben bekommt. Service mit @SpringBootTest testen Wir testen erneut den PersonService, jetzt aber mit dem kompletten Application-Context. Auf Mocks verzichten wir. Es gibt keine spezielle Annotation für Slice-Tests mit Services. Deshalb fahren wir den gesamten Application-Context hoch:\nWir verwenden eine H2 In-Memory Datenbank.\nVerwende die folgenden Dependencies im pom.xml 1 2 3 4 5 6 7 8 9 10 11 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.h2database\u003c/groupId\u003e \u003cartifactId\u003eh2\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 package com.demo.springboottesting.services; import static org.assertj.core.api.Assertions.assertThat; import static org.mockito.Mockito.times; import static org.mockito.Mockito.verify; import com.demo.springboottesting.entities.Person; import com.demo.springboottesting.repos.PersonRepo; import com.demo.springboottesting.utilities.MyUtilityBean; import org.junit.jupiter.api.Test; import org.mockito.ArgumentCaptor; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.bean.override.mockito.MockitoSpyBean; import org.springframework.test.annotation.DirtiesContext; import org.springframework.test.context.jdbc.Sql; @SpringBootTest class PersonServiceSpringBootTest { @Autowired private PersonRepo personRepo; @MockitoSpyBean private MyUtilityBean myUtilityBean; @Autowired private PersonService personService; @Test @Sql(scripts = {\"/data_personservice.sql\"}) @DirtiesContext void getAllPerson() { //When var personList = personService.getAllPerson(); //Then assertThat(personList).hasSize(2); } @Test @DirtiesContext void createPersons() { //Given Person person = new Person(null, \"Fritz\", \"Thun\"); Person person2 = new Person(null, \"Alexandra\", \"Biel/Bienne\"); //When personService.createPerson(person); personService.createPerson(person2); //Then assertThat(personRepo.findAll()).hasSize(2); ArgumentCaptor\u003cPerson\u003e personCaptor = ArgumentCaptor.forClass(Person.class); verify(myUtilityBean, times(2)).addPerson(personCaptor.capture()); assertThat(personCaptor.getAllValues().get(0)).isEqualTo(person); } } Wichtige Punkte zum Test:\nZur DB-Konfiguration verwenden wir das application.properties aus /src/test/resources. Wird ein Test gestartet, scannt Spring zuerst die Dateien in /src/test. Da dort ein application.properties vorhanden ist, wird dieses verwenden. Falls nicht, würde in einem zweiten Schritt /src/main gescannt und die entsprechende application.properties Datei verwendet werden. Anstelle von @Spy (und @Mock) wird @MockitoSpyBean (und @MockitoBean) verwendet. Du kannst jedoch dieselben Assertions und Verifys verwenden. @MockitoBean wird eingesetzt, damit der Mock die effektive Bean im Application-Context ersetzt und so überall der Mock verwendet wird. @MockitoSpyBean wird genutzt, um die bestehende Bean innerhalb des Applikation-Contexts auszuspionieren und nicht isoliert zu betrachten. Für den Test getAllPersons() verwenden wir ein spezifisches @Sql Script data_personservice.sql. Die Annotation @DirtiesContext bewirkt, dass nach dem Test die DB zurückgesetzt wird. Andernfalls hätten wir noch die Daten aus dem vorherigen Test in der DB. Im Test createPersons() verwenden wir einen ArgumentCaptor auf der myUtilityBean und zählen, ob auf ihr 2x die Methode addPerson() aufgerufen wird und ob die erste Person auch unseren Testdaten entspricht. WebEnvironment deaktivieren: Falls du verhindern möchtest, dass das WebEnvironment (u.a. Controller) hochgefahren wird, kannst du die Annoation @SpringBootTest erweitern um @SpringBootTest(webEnvironment = WebEnvironment.NONE). In diesem Szenario hier wäre das sicher sinnvoll, da wir den Controller sowieso nicht verwenden. Also los, ändere die Annotation! Controller mit @WebMvcTest testen Nun testen wir den PersonController. Dazu fahren wir einen Slice-Test mit @WebMvcTest. Es werden weder Services, noch Repos, noch Entities hochgefahren. Deshalb mocken wir den PersonService:\nVerwende die folgenden Dependencies im pom.xml 1 2 3 4 5 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e Hier die UUT:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package com.demo.springboottesting.controllers; import com.demo.springboottesting.entities.Person; import com.demo.springboottesting.services.PersonService; import jakarta.validation.Valid; import java.util.List; import lombok.RequiredArgsConstructor; import org.springframework.http.ResponseEntity; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RestController; @RestController @RequiredArgsConstructor public class PersonController { private final PersonService personService; @GetMapping(\"/persons\") public ResponseEntity\u003cList\u003cPerson\u003e\u003e getAllPersons() { return ResponseEntity.ok(personService.getAllPerson()); } @PostMapping(\"/createPerson\") public ResponseEntity\u003cPerson\u003e createPerson(@Valid @RequestBody Person person) { return ResponseEntity.ok(personService.createPerson(person)); } } Und hier die Test-Klasse:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 package com.demo.springboottesting.controllers; import static org.mockito.ArgumentMatchers.any; import static org.mockito.Mockito.when; import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get; import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post; import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status; import com.demo.springboottesting.entities.Person; import com.demo.springboottesting.services.PersonService; import java.util.List; import org.hamcrest.core.StringContains; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest; import org.springframework.test.context.bean.override.mockito.MockitoBean; import org.springframework.http.MediaType; import org.springframework.test.web.servlet.MockMvc; @WebMvcTest class PersonControllerWebMvcTest { @Autowired private MockMvc mockMvc; @Autowired private ObjectMapper objectMapper; @MockitoBean private PersonService personService; @Test void getAllPersons() throws Exception { //given Person person = new Person(1, \"Ahnis\", \"Gotham\"); Person person2 = new Person(2, \"Saksham\", \"New york\"); when(personService.getAllPerson()).thenReturn(List.of(person, person2)); //when mockMvc.perform(get(\"/persons\")) //then .andDo(print()) .andExpect(status().isOk()) .andExpect(content().string(StringContains.containsString(\"Ahnis\"))) .andExpect(content().string(StringContains.containsString(\"Saksham\"))) ; } @Test void createPerson() throws Exception { //given when(personService.createPerson(any())).thenAnswer(invocationOnMock -\u003e { Person p = invocationOnMock.getArgument(0); p.setPersonId(1); return p; }); Person dto = new Person(1, \"Alexandra\", \"Biel\"); //when mockMvc.perform(post(\"/createPerson\") .contentType(MediaType.APPLICATION_JSON) .content(objectMapper.writeValueAsString(dto))) //then .andDo(print()) .andExpect(jsonPath(\"$.personName\").value(\"Alexandra\")) .andExpect(jsonPath(\"$.personCity\").value(\"Biel\")) .andExpect(jsonPath(\"$.personId\").isNumber()); } } Wichtige Punkte zum Test:\nDer PersonService wird gemockt. Wir verwenden einen MockMvc. Damit können wir (REST-)Requests absetzen und die Antworten auswerten. getAllPersons() mockMvc.perform(get(\"/persons\")).andDo(print()).andExcpect(...)...: Zuerst wird die Rest Schnittstelle /persons aufgerufen. andDo(print()) gibt die Response in der Konsole aus. Alle weiteren andExpect(...) arbeiten mit der Reponse. content().string(...) holt den Body der Reponse und konvertiert ihn in einen String. Danach wird geschaut, ob der Body gewisse Strings enthält. createPerson() wertet die JSON-Response detailliert aus. objectMapper.writeValueAsString(dto): Wir konvertieren das Person-Objekt automatisch nach JSON. Bei jsonPath(\"$.personName\") bezieht sich $ auf das zurückgegebene einzelne Objekt. Erwarten wir eine Liste von Objekten kann über den Index auf ein entsprechendes Objekt zugegriffen werden. Wollen wir z.B. auf das 2te Objekt in der Liste zugreifen, verwenden wir $[1].personName . (Tipp am Rande: Falls du trotzdem eine DB verwenden würdest: Es gibt kein automatisches Rollback der Daten nach jedem Test.) Repo/Entity mit @DataJpaTest oder @DataJdbcTest testen Jetzt ist das PersonRepo inkl. Person (Entität) und DB dran. Wir fahren den Slice-Test mit @DataJpaTest.\nFalls deine Applikation mit JDBC implementiert ist, kannst du einfach @DataJpaTest durch @DataJdbcTest ersetzen, da sich beide Slice-Tests gleich verhalten.\nEs werden nur DB, Entities und Repositories initialisert, keine Services, keine Controller:\nAuch hier verwenden wir die H2 In-Memory DB.\nVerwende die folgenden Dependencies im pom.xml 1 2 3 4 5 6 7 8 9 10 11 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.h2database\u003c/groupId\u003e \u003cartifactId\u003eh2\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e Hier die UUT:\n1 2 3 4 5 6 7 8 package com.demo.springboottesting.repos; import com.demo.springboottesting.entities.Person; import org.springframework.data.jpa.repository.JpaRepository; public interface PersonRepo extends JpaRepository\u003cPerson, Integer\u003e { } Und hier die Test-Klasse:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package com.demo.springboottesting.repos; import static org.assertj.core.api.Assertions.assertThat; import static org.junit.jupiter.api.Assertions.assertTrue; import com.demo.springboottesting.entities.Person; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest; @DataJpaTest(showSql = true) class PersonRepoDataJpaTest { @Autowired private PersonRepo personRepo; private Person testPerson; @BeforeEach public void setUp() { // Initialize test data before each test method testPerson = new Person(null, \"Maria\", \"Bern\"); personRepo.save(testPerson); } //Not needed, DB is reset after every test run // @AfterEach // public void tearDown() { // // Release test data after each test method // personRepo.delete(testPerson); // } @Test void existsById() { assertTrue(personRepo.existsById(testPerson.getPersonId())); } @Test void findAll() { assertThat(personRepo.findAll()).hasSize(1); } } Wichtige Punkte zum Test:\nZur DB-Konfiguration verwenden wir das application.properties aus /src/test/resources. Dieses wird zuerst verwendet, weil es vorhanden ist. @BeforeEach: vor jedem Test füllen wir die DB mit einer Person ab. Nach jedem Test müssen wir die DB nicht manuell (oder mit tearDown()) resetten oder den Test mit @DirtiesContext annotieren. Dies passiert bei @DataJpaTest automatisch. Testcontainers Mit Testcontainers kannst du beliebige Umsysteme einbinden. Das System basiert auf Docker/Podman-Containern, die für den Test hochgefahren und initalisiert werden. Der Vorteil ist, dass du für den Test exakt dieselben Umsysteme wie in der Produktion verwenden kannst. Beispiel: Anstelle einer H2 In-Memory-DB können wir nun eine Maria-DB verwenden, wie sie auch in der deployten App genutzt wird. Grundsätzlich kannst du alle Container verwenden, die auf https://hub.docker.com/ zur Verfügung gestellt werden oder die du selber erstellt hast.\nDamit Testcontainers funktionieren, musst du zuerst Podman/Docker installieren. Falls noch nicht gemacht, führe die Schritte 1-4 aus im oben beschriebenen Datenbank Setup. Nun hast du Podman installiert und gestartet.\nWir testen erneut das PersonRepo mit einem @DataJpaTest.\nVerwende die folgenden Dependencies im pom.xml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-testcontainers\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.testcontainers\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter\u003c/artifactId\u003e \u003cversion\u003e1.20.2\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.testcontainers\u003c/groupId\u003e \u003cartifactId\u003emariadb\u003c/artifactId\u003e \u003cversion\u003e1.20.2\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 package com.demo.springboottesting.repos; import static org.assertj.core.api.Assertions.assertThat; import static org.junit.jupiter.api.Assertions.assertTrue; import com.demo.springboottesting.entities.Person; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase; import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase.Replace; import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest; import org.springframework.test.context.DynamicPropertyRegistry; import org.springframework.test.context.DynamicPropertySource; import org.springframework.test.context.TestPropertySource; import org.testcontainers.containers.MariaDBContainer; import org.testcontainers.junit.jupiter.Container; import org.testcontainers.junit.jupiter.Testcontainers; @DataJpaTest(showSql = true) //Optional: We specify to use only our own DB connection settings below. //If you still want to use DB settings from /src/test/resources/application.properties comment out the following line: @AutoConfigureTestDatabase( replace = Replace.ANY ) //Set properties for these specific tests: @TestPropertySource( properties = {\"spring.jpa.hibernate.ddl-auto=create-drop\"} ) //Tell the testrunner to use testcontainers: @Testcontainers class PersonRepoTestContainerDataJpaTest { //Create the container with other properties (here related to the base DB-connection): @Container static MariaDBContainer\u003c?\u003e testContainer = new MariaDBContainer\u003c\u003e( \"mariadb:latest\" ); @DynamicPropertySource static void properties( DynamicPropertyRegistry registry ) { registry.add(\"spring.datasource.driver-class-name\", testContainer::getDriverClassName); registry.add( \"spring.datasource.url\", testContainer::getJdbcUrl ); registry.add( \"spring.datasource.username\", testContainer::getUsername ); registry.add( \"spring.datasource.password\", testContainer::getPassword ); } @Autowired private PersonRepo personRepo; private Person testPerson; @BeforeEach public void setUp() { // Initialize test data before each test method testPerson = new Person(null, \"Maria\", \"Bern\"); personRepo.save(testPerson); } @Test void existsById() { assertTrue(personRepo.existsById(testPerson.getPersonId())); } @Test void findAll() { assertThat(personRepo.findAll()).hasSize(1); } } Wichtige Punkte zum Test:\n@AutoConfigureTestDatabase( replace = Replace.ANY ): Wir deaktivieren die Konfiguration aus /src/test/resources/application.properties komplett. @TestPropertySource( properties = {\"spring.jpa.hibernate.ddl-auto=create-drop\"} ): Wir übergeben für diese Test-Klasse spezifische Properties, d.h. die DB wird komplett gelöscht und das Schema neu erzeugt. @Testcontainers: Wird benötigt, damit der Test mit Testcontainers überhaupt funktioniert. Container erstellen und Config-Daten aus dem gestarteten Container ins application.properties übernehmen: 1 2 3 4 5 6 7 8 9 @Container static MariaDBContainer\u003c?\u003e testContainer = new MariaDBContainer\u003c\u003e( \"mariadb:latest\" ); @DynamicPropertySource static void properties( DynamicPropertyRegistry registry ) { registry.add(\"spring.datasource.driver-class-name\", testContainer::getDriverClassName); registry.add( \"spring.datasource.url\", testContainer::getJdbcUrl ); registry.add( \"spring.datasource.username\", testContainer::getUsername ); registry.add( \"spring.datasource.password\", testContainer::getPassword ); } @Container: Wir instanzieren einen Maria-DB Container. Falls der Container lokal noch nicht vorhanden ist im Docker/Podman wird er zuerst heruntergeladen. Hier verwenden wir jeweils die latest-Version von Maria-DB. In einer echten Applikation sollte hier stattdessen eine konkrete Version definiert werden. Wie du siehst, definieren wir an verschiedenen Orten die benötigten Properties. Standard-Properties werden hier über @DynamicPropertySource hinzugefügt. Wir übernehmen aus dem testContainer die DB-Verbindungs-Properties. Solange wir diese nicht überschreiben, werden Default-Werte zurückgegeben. Test-spezifische Properties werden über die Klassen-Annotation @TestPropertySource gesetzt. Grundsätzlich könntest du aber auch nur mit der DynamicPropertySource arbeiten. Jetzt bist du dran. Löse die Aufgaben in Spring Boot Testing - Aufgaben!\n","categories":"","description":"Modul #J08 - Spring Framework - Spring Boot Testing\n","excerpt":"Modul #J08 - Spring Framework - Spring Boot Testing\n","ref":"/de/docs/02_java/12_spring-framework/10_spring-boot-testing/","tags":"","title":"Spring Boot Testing"},{"body":"Ziele Ich kenne den Unterschied zwischen statischen und nicht statischen Elementen. Ich weiss, wann ich das Schlüsselwort static verwenden sollte und wann nicht. Ich kenne den Zugriff auf statische und nicht statische Elemente. Ich weiss, was eine statische Methode ist und kann sie aufrufen. Ich weiss, was eine Utility-Klasse ist und kenne deren wichtigste Bestandteile. Ich verstehe den Unterschied zwischen Methoden mit und ohne Rückgabewert. Ich kann eine Methodensignatur für Methoden mit und ohne Rückgabewert richtig schreiben. Ich kann Methoden schreiben, die Parameter entgegennehmen. Static / Non-Static Statische Elemente (Variablen und Methoden) existieren innerhalb des Java-Ökosystems pro Klasse nur einmal. Es spielt also keine Rolle wie viele Objekte einer Klasse erzeugt werden, eine statische Variable bleibt über alle Instanzen stets gleich.\nDas folgende Beispiel soll dies zeigen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Student { public static int numberOfStudents = 0; private String name; public Student(String name) { this.name = name; numberOfStudents++; } public String getName() { return this.name; } } Die Variable numberOfStudents gibt es in Bezug auf die Klasse Student nur einmal. Der Zugriff erfolgt über den Namen der Klasse.\n1 2 3 4 5 6 7 8 9 public class Main { public static void main(String[] args) { Student maria = new Student(\"Maria\"); System.out.println(Student.numberOfStudents); // output will be 1 Student rick = new Student(\"Rick\"); System.out.println(Student.numberOfStudents); // output will be 2 } } Will man hingegen den Namen von einem Studenten holen, so erfolgt der Zugriff über die Instanz des entsprechenden Objektes:\n1 2 3 4 5 6 7 8 9 public class Main { public static void main(String[] args) { Student maria = new Student(\"Maria\"); System.out.println(maria.getName()); // output will be \"Maria\" Student rick = new Student(\"Rick\"); System.out.println(rick.getName()); // output will be \"Rick\" } } Die Verwendung des Schlüsselworts this ist in einem statischen Kontext nicht möglich, da dieser ja wie erwähnt keine Referenzen verwendet.\nStatische Methoden Mittlerweile hast du bereits einige statische Methoden kennengelernt, wie zum Beispiel die Main-Methode oder die Methode println() der Klasse System oder die Methode valueOf() der String-Klasse. Hier wollen wir uns nun genauer anschauen, was statische Methoden sind, denn diese wirst du unter anderem für das Lösen der Übungen benötigen. Das Keyword static ist ein sehr nützliches Werkzeug in Java. Bei statischen Methoden sind einige wichtige Punkte zu beachten.\nDiese Methoden gehören nicht zu einer Referenz von einem bestimmten Objekt Diese Methoden werden über den Klassennamen aufgerufen und nicht über eine Referenz von einem bestimmten Objekt Wenn also in einem Methodenkopf das Keyword static steht, dann weisst du, dass es sich um eine statische Methode handeln muss. Schauen wir uns unterschiedliche Methodendeklarationen an (folgendes gilt für statische Methoden wie auch für nicht-statische Methoden): Wenn eine Methode einen Wert an ihren Aufrufer zurückgeben soll, sprechen wir von einer Methode mit einem Rückgabewert:\n1 2 3 public static returnType methodName() { return returnValue; // der Typ des Rückgabewerts muss vom Typ sein, welcher im Methodenkopf steht } Wir sehen, dass in der Methodendeklaration angeben werden muss, welcher Typ zurückgegeben wird.\nWenn eine Methode keinen Wert zurückgeben soll, verwenden wir das Keyword void:\n1 2 3 public static void methodName() { } Das Keyword return ist in Methoden ohne Rückgabewert weiterhin zulässig um die Methode zu verlassen. Die Angabe eines Rückgabewerts entfällt in diesem Fall.\nWir können auch Werte einer Methode übergeben – hierbei sprechen wir von Parametern.\n1 2 3 public static void methodName(type identifier) { } Ein Parameter besteht immer aus dem Datentyp und einem Bezeichner. Wir können beliebig viele Parameter an eine Methode übergeben. Gemäss den SBB Code Conventions (Regeln für den Programmcode) sollte eine Methode nicht mehr als acht Parameter haben.\nRegeln Die Reihenfolge der Schlüsselwörter im Methodenkopf darf nicht verändert werden Bei der Auswahl des Methodennamens müssen die gleichen Regeln wie bei der Benennung einer Variablen eingehalten werden Keine doppelten Methoden: Jede Methodensignatur darf in einer Klasse nur einmal vorkommen Aufruf Innerhalb der gleichen Klasse\n1 methodName(); Ausserhalb:\n1 ClassName.methodName(); Utility-Klassen Eine Klasse, welche ausschliesslich statische Elemente besitzt, nennt man Utility-Klasse. Ein gutes Beispiel dafür ist die Klasse Math. Eine solche Klasse sollte einen privaten Konstruktor aufweisen, da es keinen Sinn macht, von ihr eine Referenz zu erstellen. Zudem sollte die Klasse als final deklariert werden, da eine Vererbung aufgrund des statischen Kontextes ebenfalls keinen Sinn ergibt.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public final class SpeedConverter { private SpeedConverter() { // Utility class } public static double toMilesPerHour(double kmh) { return kmh * 0.621; } public static double toKilometersPerHour(double mph) { return mph * 1.609; } } Jetzt bist du dran. Löse bitte die NinjaCups in den Labs.\n","categories":"","description":"Modul #J2\n","excerpt":"Modul #J2\n","ref":"/docs/02_java/04_java-oop/10_static-non_static/","tags":"","title":"Statische und nicht-statische Elemente"},{"body":"Ziele Ich kenne den Unterschied zwischen statischen und nicht statischen Elementen. Ich weiss, wann ich das Schlüsselwort static verwenden sollte und wann nicht. Ich kenne den Zugriff auf statische und nicht statische Elemente. Ich weiss, was eine statische Methode ist und kann sie aufrufen. Ich weiss, was eine Utility-Klasse ist und kenne deren wichtigste Bestandteile. Ich verstehe den Unterschied zwischen Methoden mit und ohne Rückgabewert. Ich kann eine Methodensignatur für Methoden mit und ohne Rückgabewert richtig schreiben. Ich kann Methoden schreiben, die Parameter entgegennehmen. Static / Non-Static Statische Elemente (Variablen und Methoden) existieren innerhalb des Java-Ökosystems pro Klasse nur einmal. Es spielt also keine Rolle wie viele Objekte einer Klasse erzeugt werden, eine statische Variable bleibt über alle Instanzen stets gleich.\nDas folgende Beispiel soll dies zeigen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Student { public static int numberOfStudents = 0; private String name; public Student(String name) { this.name = name; numberOfStudents++; } public String getName() { return this.name; } } Die Variable numberOfStudents gibt es in Bezug auf die Klasse Student nur einmal. Der Zugriff erfolgt über den Namen der Klasse.\n1 2 3 4 5 6 7 8 9 public class Main { public static void main(String[] args) { Student maria = new Student(\"Maria\"); System.out.println(Student.numberOfStudents); // output will be 1 Student rick = new Student(\"Rick\"); System.out.println(Student.numberOfStudents); // output will be 2 } } Will man hingegen den Namen von einem Studenten holen, so erfolgt der Zugriff über die Instanz des entsprechenden Objektes:\n1 2 3 4 5 6 7 8 9 public class Main { public static void main(String[] args) { Student maria = new Student(\"Maria\"); System.out.println(maria.getName()); // output will be \"Maria\" Student rick = new Student(\"Rick\"); System.out.println(rick.getName()); // output will be \"Rick\" } } Die Verwendung des Schlüsselworts this ist in einem statischen Kontext nicht möglich, da dieser ja wie erwähnt keine Referenzen verwendet.\nStatische Methoden Mittlerweile hast du bereits einige statische Methoden kennengelernt, wie zum Beispiel die Main-Methode oder die Methode println() der Klasse System oder die Methode valueOf() der String-Klasse. Hier wollen wir uns nun genauer anschauen, was statische Methoden sind, denn diese wirst du unter anderem für das Lösen der Übungen benötigen. Das Keyword static ist ein sehr nützliches Werkzeug in Java. Bei statischen Methoden sind einige wichtige Punkte zu beachten.\nDiese Methoden gehören nicht zu einer Referenz von einem bestimmten Objekt Diese Methoden werden über den Klassennamen aufgerufen und nicht über eine Referenz von einem bestimmten Objekt Wenn also in einem Methodenkopf das Keyword static steht, dann weisst du, dass es sich um eine statische Methode handeln muss. Schauen wir uns unterschiedliche Methodendeklarationen an (folgendes gilt für statische Methoden wie auch für nicht-statische Methoden): Wenn eine Methode einen Wert an ihren Aufrufer zurückgeben soll, sprechen wir von einer Methode mit einem Rückgabewert:\n1 2 3 public static returnType methodName() { return returnValue; // der Typ des Rückgabewerts muss vom Typ sein, welcher im Methodenkopf steht } Wir sehen, dass in der Methodendeklaration angeben werden muss, welcher Typ zurückgegeben wird.\nWenn eine Methode keinen Wert zurückgeben soll, verwenden wir das Keyword void:\n1 2 3 public static void methodName() { } Das Keyword return ist in Methoden ohne Rückgabewert weiterhin zulässig um die Methode zu verlassen. Die Angabe eines Rückgabewerts entfällt in diesem Fall.\nWir können auch Werte einer Methode übergeben – hierbei sprechen wir von Parametern.\n1 2 3 public static void methodName(type identifier) { } Ein Parameter besteht immer aus dem Datentyp und einem Bezeichner. Wir können beliebig viele Parameter an eine Methode übergeben. Gemäss den SBB Code Conventions (Regeln für den Programmcode) sollte eine Methode nicht mehr als acht Parameter haben.\nRegeln Die Reihenfolge der Schlüsselwörter im Methodenkopf darf nicht verändert werden Bei der Auswahl des Methodennamens müssen die gleichen Regeln wie bei der Benennung einer Variablen eingehalten werden Keine doppelten Methoden: Jede Methodensignatur darf in einer Klasse nur einmal vorkommen Aufruf Innerhalb der gleichen Klasse\n1 methodName(); Ausserhalb:\n1 ClassName.methodName(); Utility-Klassen Eine Klasse, welche ausschliesslich statische Elemente besitzt, nennt man Utility-Klasse. Ein gutes Beispiel dafür ist die Klasse Math. Eine solche Klasse sollte einen privaten Konstruktor aufweisen, da es keinen Sinn macht, von ihr eine Referenz zu erstellen. Zudem sollte die Klasse als final deklariert werden, da eine Vererbung aufgrund des statischen Kontextes ebenfalls keinen Sinn ergibt.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public final class SpeedConverter { private SpeedConverter() { // Utility class } public static double toMilesPerHour(double kmh) { return kmh * 0.621; } public static double toKilometersPerHour(double mph) { return mph * 1.609; } } Jetzt bist du dran. Löse bitte die NinjaCups in den Labs.\n","categories":"","description":"Modul #J2\n","excerpt":"Modul #J2\n","ref":"/de/docs/02_java/04_java-oop/10_static-non_static/","tags":"","title":"Statische und nicht-statische Elemente"},{"body":"Ziele Du weisst, wozu Services in Angular verwendet werden und kannst diese genauer erläutern. Services Angular-Services sind in Angular eine wichtige Art, Code zu organisieren und wiederzuverwenden. Sie bieten eine Möglichkeit, Funktionen und Daten zu teilen, die von mehreren Components innerhalb einer Anwendung benötigt werden. Ein Service ist eine Klasse, die von anderen Components injiziert werden kann, um auf seine Funktionen und Daten zuzugreifen.\nServices können beispielsweise Daten von einem Backend-Server abrufen, eine benutzerdefinierte Logik ausführen, eine Konfiguration bereitstellen oder andere Arbeiten erledigen, die für mehrere Komponenten relevant sind. Im Gegensatz zu Komponenten haben Services normalerweise keine visuelle Darstellung, sondern dienen als reine “Helfer”-Instanzen.\n1 2 3 4 5 6 7 8 9 10 11 12 import { Injectable } from \"@angular/core\"; @Injectable({ providedIn: \"root\", }) export class WeaponService { private weapons: string[] = [\"Sword\", \"Bow\", \"Axe\", \"Staff\", \"Dagger\"]; getWeapons(): string[] { return this.weapons; } } providedIn Innerhalb der @Injectable-Annotation findet sich immer die Konfiguration providedIn. Diese bestimmt, innerhalb welchen Scopes sich der Service injizieren lässt. Standardmässig hat die Konfiguration den Wert root inne, der aussagt, dass der Service innerhalb der gesamten Applikation injiziert werden kann. Insofern ein Service nur in einem bestimmten Teil der Applikation injiziert werden soll, kann der Scope mithilfe von providedIn angepasst werden.\n","categories":"","description":"Modul #F6 - Angular - Services\n","excerpt":"Modul #F6 - Angular - Services\n","ref":"/docs/03_web/06_angular/02_10_services/","tags":"","title":"Services"},{"body":"Ziele Du weisst, wozu Services in Angular verwendet werden und kannst diese genauer erläutern. Services Angular-Services sind in Angular eine wichtige Art, Code zu organisieren und wiederzuverwenden. Sie bieten eine Möglichkeit, Funktionen und Daten zu teilen, die von mehreren Components innerhalb einer Anwendung benötigt werden. Ein Service ist eine Klasse, die von anderen Components injiziert werden kann, um auf seine Funktionen und Daten zuzugreifen.\nServices können beispielsweise Daten von einem Backend-Server abrufen, eine benutzerdefinierte Logik ausführen, eine Konfiguration bereitstellen oder andere Arbeiten erledigen, die für mehrere Komponenten relevant sind. Im Gegensatz zu Komponenten haben Services normalerweise keine visuelle Darstellung, sondern dienen als reine “Helfer”-Instanzen.\n1 2 3 4 5 6 7 8 9 10 11 12 import { Injectable } from \"@angular/core\"; @Injectable({ providedIn: \"root\", }) export class WeaponService { private weapons: string[] = [\"Sword\", \"Bow\", \"Axe\", \"Staff\", \"Dagger\"]; getWeapons(): string[] { return this.weapons; } } providedIn Innerhalb der @Injectable-Annotation findet sich immer die Konfiguration providedIn. Diese bestimmt, innerhalb welchen Scopes sich der Service injizieren lässt. Standardmässig hat die Konfiguration den Wert root inne, der aussagt, dass der Service innerhalb der gesamten Applikation injiziert werden kann. Insofern ein Service nur in einem bestimmten Teil der Applikation injiziert werden soll, kann der Scope mithilfe von providedIn angepasst werden.\n","categories":"","description":"Modul #F6 - Angular - Services\n","excerpt":"Modul #F6 - Angular - Services\n","ref":"/de/docs/03_web/06_angular/02_10_services/","tags":"","title":"Services"},{"body":"Ziele Du weisst, wie Loops funktionieren. Du kennst die verschiedenen Typen Loops und kannst diese anwenden. Loops Ein Loop ist eine Struktur, mit der man einen Block Code wiederholt ausführen kann, solange eine bestimmte Bedingung erfüllt ist. Loops sind nützlich, wenn man eine bestimmte Aktion mehrmals ausführen möchten, ohne den Code zu duplizieren.\nEs ist möglich, Loops zu verschachteln, um komplexe Iterationsprozesse durchzuführen. Dabei wird ein Loop innerhalb eines anderen Loops ausgeführt.\nWichtig bei der Verwendung von Loops ist es, darauf zu achten, dass die Bedingung, die man verwenden, letztendlich erfüllt wird, um eine Endlosschleife zu vermeiden. Eine Endlosschleife führt dazu, dass der Code in einem Loop stecken bleibt und den Rest des Programms nicht ausführt.\nfor-Loops for, forEach, for…of Im Kapitel Arrays werden die Loops for, forEach und for...of erklärt. Du kannst dort nochmal die Informationen nachlesen, wenn du dich im Thema nicht mehr so sicher fühlst.\nfor…in-Loop Der for...in-Loop wird verwendet, um über die Eigenschaften eines Objekts zu iterieren.\n1 2 3 4 5 6 7 8 9 10 const person = { name: \"Max\", age: 30, city: \"Berlin\" }; for (let personProperty in person) { console.log(personProperty + \": \" + person[personProperty]); } // Output: // name: Max // age: 30 // city: Berlin while-Loops while-Loop Der while-Loop wird verwendet, um einen Code-Block so lange auszuführen, wie die angegebene Bedingung wahr ist. Die Bedingung ist ein boolescher Ausdruck, der ausgewertet wird, bevor jeder Durchlauf des Loops beginnt.\n1 2 3 4 5 6 7 8 9 10 11 12 let i = 0; while (i \u003c 5) { console.log(i); i++; } // 0 // 1 // 2 // 3 // 4 do…while-Loop Der do...while-Loop funktioniert ähnlich wie der while-Loop, jedoch wird der Code-Block jeweils immer vor der Überprüfung der Kondition ausgeführt.\n1 2 3 4 5 6 7 8 9 10 11 12 let i = 0; do { console.log(i); i++; } while (i \u003c 5); // 0 // 1 // 2 // 3 // 4 ","categories":"","description":"Modul #F4 - JavaScript - Loops.\n","excerpt":"Modul #F4 - JavaScript - Loops.\n","ref":"/docs/03_web/03_javascript/11_loops/","tags":"","title":"Loops"},{"body":"Ziele Du weisst, wie Loops funktionieren. Du kennst die verschiedenen Typen Loops und kannst diese anwenden. Loops Ein Loop ist eine Struktur, mit der man einen Block Code wiederholt ausführen kann, solange eine bestimmte Bedingung erfüllt ist. Loops sind nützlich, wenn man eine bestimmte Aktion mehrmals ausführen möchten, ohne den Code zu duplizieren.\nEs ist möglich, Loops zu verschachteln, um komplexe Iterationsprozesse durchzuführen. Dabei wird ein Loop innerhalb eines anderen Loops ausgeführt.\nWichtig bei der Verwendung von Loops ist es, darauf zu achten, dass die Bedingung, die man verwenden, letztendlich erfüllt wird, um eine Endlosschleife zu vermeiden. Eine Endlosschleife führt dazu, dass der Code in einem Loop stecken bleibt und den Rest des Programms nicht ausführt.\nfor-Loops for, forEach, for…of Im Kapitel Arrays werden die Loops for, forEach und for...of erklärt. Du kannst dort nochmal die Informationen nachlesen, wenn du dich im Thema nicht mehr so sicher fühlst.\nfor…in-Loop Der for...in-Loop wird verwendet, um über die Eigenschaften eines Objekts zu iterieren.\n1 2 3 4 5 6 7 8 9 10 const person = { name: \"Max\", age: 30, city: \"Berlin\" }; for (let personProperty in person) { console.log(personProperty + \": \" + person[personProperty]); } // Output: // name: Max // age: 30 // city: Berlin while-Loops while-Loop Der while-Loop wird verwendet, um einen Code-Block so lange auszuführen, wie die angegebene Bedingung wahr ist. Die Bedingung ist ein boolescher Ausdruck, der ausgewertet wird, bevor jeder Durchlauf des Loops beginnt.\n1 2 3 4 5 6 7 8 9 10 11 12 let i = 0; while (i \u003c 5) { console.log(i); i++; } // 0 // 1 // 2 // 3 // 4 do…while-Loop Der do...while-Loop funktioniert ähnlich wie der while-Loop, jedoch wird der Code-Block jeweils immer vor der Überprüfung der Kondition ausgeführt.\n1 2 3 4 5 6 7 8 9 10 11 12 let i = 0; do { console.log(i); i++; } while (i \u003c 5); // 0 // 1 // 2 // 3 // 4 ","categories":"","description":"Modul #F4 - JavaScript - Loops.\n","excerpt":"Modul #F4 - JavaScript - Loops.\n","ref":"/de/docs/03_web/03_javascript/11_loops/","tags":"","title":"Loops"},{"body":"Wie funktioniert CSS? Um CSS anwenden zu können, müssen wir als Erstes das Grundprinzip von CSS verstehen:\nMit CSS wird das Aussehen (und zum Teil auch das Verhalten) von HTML-Elementen definiert. Diese Styledefinition wird nur auf passende HTML-elemente angewendet. Wenn kein passendes HTML-Element vorhanden ist, bleibt die Definition wirkungslos. Hierfür gibt es verschiedene Möglichkeiten, welche wir im Verlaufe des Kurses kennenlernen werden.\nCSS hält sich dabei an die folgende Syntax:\n1 2 3 4 p { color: blue; background-color: red; } Die Zeichenfolge vor den geschweiften Klammern ist der sogenannte Selektor (Englisch: Selector). Er definiert, auf welche Elemente das Styling angewendet werden soll. In diesem Fall würde das Styling auf alle \u003cp\u003e-Elemente angewandt werden. Die Zeilen innerhalb der geschweiften Klammern definieren, welche Art von Styling angewandt werden soll. Beim gezeigten Beispiel wird die Textfarbe auf Blau und die Hintergrundfarbe rot eingestellt. Wie kann ich CSS anwenden? Als Nächstes schauen wir an, wie man CSS in eine Webseite (bzw. in ein HTML File) einbinden kann.\nDirektes einbinden in HTML-Elemente Die wohl schnellste Möglichkeit CSS auf ein HTML-Element anzuwenden, ist, das “style”-Attribut des HTML-Elements anzupassen. Dies würde wie folgt ausschauen:\n1 2 3 \u003cp style=\"color: blue; background-color: red\"\u003e Hier steht blauer Text auf rotem Hintergrund \u003c/p\u003e Dabei ist anzumerken, dass sich die Syntax gegenüber der herkömmlichen Syntax (siehe erstes Beispiel) etwas unterscheidet. Einerseits müssen wir den Selektor nicht angeben und andererseits gibt es keine geschweiften Klammern mehr.\nEinbinden über einen Style-Tag Man kann CSS aber auch über einen sogenannten “Style” Tag direkt in die HTML-Datei einbinden. Dies sähe dann aus wie folgt:\n1 2 3 4 5 6 7 8 9 10 \u003chead\u003e ... \u003cstyle\u003e p { color: blue; background-color: red; } \u003c/style\u003e ... \u003c/head\u003e Hierbei können wir innerhalb des Style-Tags herkömmliches CSS anwenden, wie wir es bereits aus dem ersten Beispiel kennen. Der Style-Tag kann irgendwo (auch verschachtelt) irgendwo im \u003chead\u003e oder \u003cbody\u003e stehen, wo genau macht funktionstechnisch aber keinen Unterschied. Am meisten Sinn macht es aber, den Style-Tag im \u003chead\u003e nach den \u003cmeta\u003e-Tags einzubinden, da er dort am besten sichtbar ist.\nEinbinden über ein externes CSS-File Die wohl am weitesten verbreitete und “schönste” Methode CSS in eine Webseite einzubinden ist es, das CSS in ein CSS-File auszulagern und dann im HTML auf dieses zu verweisen. Nachfolgend ein Beispiel, wie man das machen kann:\nDatei: index.html\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u003c!doctype html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\" /\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /\u003e \u003ctitle\u003eDocument\u003c/title\u003e /* Verweis auf das CSS-File */ \u003clink rel=\"stylesheet\" href=\"styles.css\" /\u003e \u003c/head\u003e \u003cbody\u003e \u003cp\u003eHier steht blauer Text auf rotem Hintergrund\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e Datei: styles.css\n1 2 3 4 p { color: blue; background-color: red; } Der wichtigste Teil des HTML-Codes in diesem Beispiel ist dabei folgender Tag im Head:\n1 \u003clink rel=\"stylesheet\" href=\"styles.css\" /\u003e Dieser Link-Tag definiert, dass der CSS-Code der Datei mit dem Pfad “styles.css” auf die aktuelle HTML-Datei als “stylesheet” angewandt werden soll.\nWas gibt es für CSS-Styling-Properties? Es gibt unzählige CSS-Properties. Zu viele, um auf jedes detailliert einzugehen. Auf dieser Seite findet ihr eine ganze Reihe CSS-Properties.\nAuf die wichtigsten dieser Properties werden wir nachfolgend konkreter eingehen.\n","categories":"","description":"Modul #F3 - HTML und CSS - Grundlagen von CSS.\n","excerpt":"Modul #F3 - HTML und CSS - Grundlagen von CSS.\n","ref":"/docs/03_web/02_html_css/10_css-basics/","tags":"","title":"CSS-Grundlagen"},{"body":"Wie funktioniert CSS? Um CSS anwenden zu können, müssen wir als Erstes das Grundprinzip von CSS verstehen:\nMit CSS wird das Aussehen (und zum Teil auch das Verhalten) von HTML-Elementen definiert. Diese Styledefinition wird nur auf passende HTML-elemente angewendet. Wenn kein passendes HTML-Element vorhanden ist, bleibt die Definition wirkungslos. Hierfür gibt es verschiedene Möglichkeiten, welche wir im Verlaufe des Kurses kennenlernen werden.\nCSS hält sich dabei an die folgende Syntax:\n1 2 3 4 p { color: blue; background-color: red; } Die Zeichenfolge vor den geschweiften Klammern ist der sogenannte Selektor (Englisch: Selector). Er definiert, auf welche Elemente das Styling angewendet werden soll. In diesem Fall würde das Styling auf alle \u003cp\u003e-Elemente angewandt werden. Die Zeilen innerhalb der geschweiften Klammern definieren, welche Art von Styling angewandt werden soll. Beim gezeigten Beispiel wird die Textfarbe auf Blau und die Hintergrundfarbe rot eingestellt. Wie kann ich CSS anwenden? Als Nächstes schauen wir an, wie man CSS in eine Webseite (bzw. in ein HTML File) einbinden kann.\nDirektes einbinden in HTML-Elemente Die wohl schnellste Möglichkeit CSS auf ein HTML-Element anzuwenden, ist, das “style”-Attribut des HTML-Elements anzupassen. Dies würde wie folgt ausschauen:\n1 2 3 \u003cp style=\"color: blue; background-color: red\"\u003e Hier steht blauer Text auf rotem Hintergrund \u003c/p\u003e Dabei ist anzumerken, dass sich die Syntax gegenüber der herkömmlichen Syntax (siehe erstes Beispiel) etwas unterscheidet. Einerseits müssen wir den Selektor nicht angeben und andererseits gibt es keine geschweiften Klammern mehr.\nEinbinden über einen Style-Tag Man kann CSS aber auch über einen sogenannten “Style” Tag direkt in die HTML-Datei einbinden. Dies sähe dann aus wie folgt:\n1 2 3 4 5 6 7 8 9 10 \u003chead\u003e ... \u003cstyle\u003e p { color: blue; background-color: red; } \u003c/style\u003e ... \u003c/head\u003e Hierbei können wir innerhalb des Style-Tags herkömmliches CSS anwenden, wie wir es bereits aus dem ersten Beispiel kennen. Der Style-Tag kann irgendwo (auch verschachtelt) irgendwo im \u003chead\u003e oder \u003cbody\u003e stehen, wo genau macht funktionstechnisch aber keinen Unterschied. Am meisten Sinn macht es aber, den Style-Tag im \u003chead\u003e nach den \u003cmeta\u003e-Tags einzubinden, da er dort am besten sichtbar ist.\nEinbinden über ein externes CSS-File Die wohl am weitesten verbreitete und “schönste” Methode CSS in eine Webseite einzubinden ist es, das CSS in ein CSS-File auszulagern und dann im HTML auf dieses zu verweisen. Nachfolgend ein Beispiel, wie man das machen kann:\nDatei: index.html\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u003c!doctype html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\" /\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /\u003e \u003ctitle\u003eDocument\u003c/title\u003e /* Verweis auf das CSS-File */ \u003clink rel=\"stylesheet\" href=\"styles.css\" /\u003e \u003c/head\u003e \u003cbody\u003e \u003cp\u003eHier steht blauer Text auf rotem Hintergrund\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e Datei: styles.css\n1 2 3 4 p { color: blue; background-color: red; } Der wichtigste Teil des HTML-Codes in diesem Beispiel ist dabei folgender Tag im Head:\n1 \u003clink rel=\"stylesheet\" href=\"styles.css\" /\u003e Dieser Link-Tag definiert, dass der CSS-Code der Datei mit dem Pfad “styles.css” auf die aktuelle HTML-Datei als “stylesheet” angewandt werden soll.\nWas gibt es für CSS-Styling-Properties? Es gibt unzählige CSS-Properties. Zu viele, um auf jedes detailliert einzugehen. Auf dieser Seite findet ihr eine ganze Reihe CSS-Properties.\nAuf die wichtigsten dieser Properties werden wir nachfolgend konkreter eingehen.\n","categories":"","description":"Modul #F3 - HTML und CSS - Grundlagen von CSS.\n","excerpt":"Modul #F3 - HTML und CSS - Grundlagen von CSS.\n","ref":"/de/docs/03_web/02_html_css/10_css-basics/","tags":"","title":"CSS-Grundlagen"},{"body":"Ziele Ich kenne Arrays und kann diese instantiieren, ihnen Werte von Indexen entnehmen und Werte an Indexe zuweisen. Arrays Definition Häufig benötigen Software-Entwickler mehrere zusammengehörige Variablen desselben Datentyps, die logisch oder verwaltungstechnisch zusammengehören. Es wäre aber sehr aufwendig, diese Variablen alle einzeln zu deklarieren und zu verarbeiten. Zudem ist es möglich, dass die Anzahl an Objekten noch unbekannt ist und erst bei der Ausführung des Programms definiert wird. Deswegen wird in Java, wie in anderen Programmiersprachen auch, die Verwendung von Arrays unterstützt. In Arrays lassen sich beliebige primitive Datentypen und Objekte speichern und systematisch bearbeiten. Alle Variablen haben einen gemeinsamen Namen, werden aber über unterschiedliche Indizes angesprochen. Unter Arrays kannst du dir so etwas wie eine Liste vorstellen.\nDeklaration Die Deklaration eines Arrays enthält folgende Bestandteile:\nReihenfolge Bedeutung Beispiel 1. Typ String, int, double, char, ... 2. Eckige Klammern [] 3. Bezeichner / Namen words, numbers, values, letters... Konkret können wir so ein String-Array deklarieren:\n1 String[] words; Syntax In Java müssen wir zum Zeitpunkt der Deklaration eines Arrays folgendes angeben:\nden Datentyp den Namen und zum Zeitpunkt der Initialisierung:\ndie Grösse Das Code-Beispiel von der “Deklaration” deklariert die Variable words, erstellt das Array-Objekt jedoch noch nicht. Der Operator new wird in Java zum Erstellen von neuen Objekten verwendet:\n1 String[] words = new String[5]; Damit wird ein Array-Objekt der Länge 5 (also mit 5 Elementen) instantiiert. Die fünf Elemente dieses Arrays wurden mit Standardwerten initialisiert. Bei einem Array des Datentyps String ist der Default-Wert null. Alle Werte im Array werden also mit null aufgefüllt.\nWir können die Werte der Array-Elemente auch gleich direkt angeben:\n1 String[] words = { \"Hai\", \"Oktopus\", \"Rochen\", \"Wal\", \"Fisch\" }; Es wird also ein Array mit der Grösse 5 und den angegebenen Werten erstellt.\nLänge eines Arrays Die Anzahl der Elemente in einem Array wird als Länge eines Arrays bezeichnet. Diese Länge wird zum Zeitpunkt der Erstellung eines Arrays einmal festgelegt. Sie kann später in einem Programm nur durch Definition eines neuen Arrays und dem Kopieren von Werten geändert werden.\nWir können die Länge eines Arrays mithilfe einer in Java integrierten Funktionalität überprüfen:\n1 words.length Indizierung Die Indizes in einem Array reichen immer von 0 bis length-1. Ein Array mit den ersten 100 natürlichen Zahlen hat beispielsweise eine Länge von 100 und Indizes von 0 bis 99.\nZugriff auf Elemente Wenn wir den Wert eines Elements in unserem Array verändern möchten, geschieht dies folgendermassen:\n1 words[index] = value; Wenn du also das 4. Element (Index 3) mit dem Wert \"Delfin\" ersetzen möchtest, dann kannst du das wie folgt tun:\n1 words[index] = \"Delfin\"; Und wenn wir den Wert eines Array-Elements in einer Variablen ausserhalb des Arrays speichern wollen:\n1 String value = words[index]; Durch alle Elemente durchgehen Im Kapitel der “Kontrollstrukturen” hast du die for- und “foreach”-Schlaufe kennengelernt. Beide Schlaufen eignen sich, um ein Array durchzugehen (“iterieren”). Hier ein kleiner Reminder:\n1 2 3 4 5 6 7 8 9 System.out.println(\"Wörter ausgegeben in der for-Schlaufe\"); for (int i = 0; i \u003c words.length; i++) { System.out.print(words[i] + \"\\t\"); } System.out.println(\"\\nWörter ausgegeben in der forEach-Schlaufe\"); for (String word : words) { System.out.print(word + \"\\t\"); } Lernvideo Wenn du dir die Erklärung noch mit Videos genauer anschauen möchtest, empfiehlt dir das Praxisbildner-Team diese Videos: Theoretische Erklärung, Anwendung in Java\nZweidimensionale Arrays (2D Array) Bis jetzt hast du ausschliesslich Arrays gesehen, die auf eine Dimension beschränkt waren. Diese Arrays sind praktisch, um Listen-Artige Daten zu speichern. Zweidimensionale Arrays haben wie es der Name schon verrät eine zweite Dimension. Diese Art von Arrays sind praktisch für tabellarische Daten.\nDu kannst dir ein 2D-Array wie eine Excel vorstellen. Es besteht aus Reihen und Spalten die gleich wie im normalen Array mit einem Index/einer Position definiert werden.\nSyntax Für die Deklaration eines zweidimensionalen Arrays wird eine Angabe von der Anzahl Reihen und Spalten benötigt. Bei dieser Art von Array können die gleichen Datentypen wie bei den normalen Arrays verwendet werden. So sieht schliesslich die Syntax aus:\n1 2 3 4 int anzahlReihen = 4; int anzahlSpalten = 3; int[][] zweiDArray = new int[anzahlReihen][anzahlSpalten]; Zugriff auf Elemente Da wir jetzt im zweidimensionalen Bereich unterwegs sind, müssen wir für den Zugriff auf Elemente beide Dimensionen beachten. Das bedeutet, dass wir anders als bei einfachen Arrays 2 verschiedene indexe angeben müssen. Hier ein Beispiel dazu:\n1 2 3 4 5 6 int[][] zweiDArray = new int[4][2]; zweiDArray[0][1] = 69; // Wert 69 zuweisen int output = zweiDArray[0][1]; // Wert auf position 0 1 in zweiDArray in output variable speichern System.out.println(output); // Ausgabe: 69 Lernvideo Wenn du dir die Erklärung noch mit einem Video genauer anschauen möchtest, empfiehlt dir das Praxisbildner-Team dieses Video.\nJetzt bist du dran. Löse bitte die Aufgabe 9 in den Labs.\n","categories":"","description":"Modul #J1\n","excerpt":"Modul #J1\n","ref":"/de/docs/02_java/03_java-grundlagen/11_arrays/","tags":"","title":"Arrays"},{"body":"","categories":"","description":"Exercises zu Modul #J7 - JDBC\n","excerpt":"Exercises zu Modul #J7 - JDBC\n","ref":"/labs/02_java/11_java-jdbc/","tags":"","title":"Java Exercises - JDBC"},{"body":"","categories":"","description":"Exercises zu Modul #J7 - JDBC\n","excerpt":"Exercises zu Modul #J7 - JDBC\n","ref":"/de/labs/02_java/11_java-jdbc/","tags":"","title":"Java Exercises - JDBC"},{"body":"Ziele Ich kann in eigenen Worten erklären, was mit Generics in Java gemeint ist und wozu diese angewendet werden. Ich kann alle Vorteile, die die Arbeit mit Generics mit sich bringt, vollständig nennen. Ich kann in eigenen Worten erklären, was Typsicherheit ist. Ich kann anhand eines Beispiels aufzeigen, wie eine Typverletzung entsteht. Ich kann in eigenen Worten erklären, wozu “bounded types” verwendet werden. Ich kann in eigenen Worten erklären, was Wildcards im Kontext von Generics sind und wie sie verwendet werden. Ich kann in eigenen Worten erklären, was “type erasure” ist und wann dieser Vorgang stattfindet. Ich setzte generische Klassen und Methoden in Code-Aufgaben korrekt ein. Einführung Mit Generics sind im Java-Umfeld parametrisierte Datentypen gemeint. So werden mit Generics Datentypen (Integer, String oder auch benutzerdefinierte Datentypen) als Parameter für Klassen, Interfaces und Methoden mitgegeben. Mit Generics ist es also möglich Klassen, Interfaces und Methoden zu schreiben, welche mit unterschiedlichen Datentypen arbeiten können.\nGenerics funktionieren nur mit Referenz-Datentypen (also nicht mit primitiven Datentypen) und werden nur während der Kompilierung ausgewertet.\nTypsicherheit Typsicherheit ist einen Zustand, bei dem Datentypen gemäss ihren Definitionen verwendet werden und keine sog. Typverletzungen auftreten.\nIn der Regel wird bei einer Variable der Datentyp festgelegt. Diesen Datentyp schränkt die Menge der konkreten, zulässigen Werte für diese Variable ein. Versucht man der Variable nun einen Wert ausserhalb diesen zulässigen Bereich zuzuweisen, so liegt eine Typverletzung vor.\nDie Überprüfung der Typsicherheit in Java ist eine Aufgabe des Java-Compilers. Wenn der Compiler eine Typverletzung zur “Compile-Zeit” entdeckt gibt es einen sog. Kompilierfehler, welcher davor warnt. Wenn eine Typverletzung unentdeckt bleibt, können zur Laufzeit des Programms schwer analysierbare Fehler auftreten.\nBeispiel einer Typverletzung, welche vom Compiler entdeckt wird\nIn der folgenden Klasse wird versucht, ein String zu einer Variable des Typs Integer zuzuweisen\n1 2 3 4 5 6 public class Test { public static void main(String[] args) { Integer myInteger; myInteger = \"this is not an integer...\"; } } Beim Versuch, die Klasse zu kompilieren erscheint folgende Fehlermeldung:\n1 2 3 4 5 PS: C\\devsbb\\source\\examples\u003e javac Test.java Test.java:4: error: incompatible types: String cannot be converted to Integer myInteger = \"this is not an integer...\"; ^ 1 error Warum Generics? Programme, welche Generics verwenden, haben mehrere Vorteile gegenüber Programmen ohne Generics:\nWiederverwendbarer Code: eine Klasse oder eine Methode kann einmal geschrieben werden und mit unterschiedlichen Datentypen verwendet werden. Typsicherheit: Generics lösen Fehler während der Kompilierung aus, welche ansonsten erst zur Laufzeit ausgelöst wären. Individuelle Typ-Casting ist nicht nötig: Wenn bei der Anwendung von Generics der konkrete Typ angegeben wird, muss danach kein Typ-Casting stattfinden. Wiederverwendbarkeit Generics helfen uns wiederverwendbaren Code zu schreiben. Das gefällt uns als Informatiker natürlich sehr, da wir so weniger zu tun haben.\nAngenommen wir haben eine Methode um das erste Element aus einem Array zu extrahieren:\n1 2 3 4 5 6 public String getFirstElement(String[] array){ if(array == null || array.length == 0){ throw new ArrayIndexOutOfBoundsException(\"Array cant be empty\"); } return array[0]; } Diese Funktion kann aber nur mit String-Arrays umgehen. Wollen wir noch eine für Integer-Arrays haben brauchen wir eine Methode Integer getFirstElement(Integer[] array), für Double-Arrays eine Methode Double getFirstElement(Double[] array) und so weiter und so fort …\n1 2 getFirstElement(new String[]{\"Uno\", \"Due\"}) //Funktioniert getFirstElement(new Integer[]{1,2,3}) //Führt zu einem Compiler-Fehler Stattdessen können wir aber auch eine Funktion mit Generics schreiben. Diese funktioniert dann für alle nicht-primitiven Typen. Wie genau so eine Methode aufgebaut ist und wofür T steht, erfährst du weiter unten.\n1 2 3 4 5 6 7 8 9 public static \u003cT\u003e T getFirstElement(T[] array) {//T is hier der Ersatz von String/Double/Integer/... if (array == null || array.length == 0) { throw new ArrayIndexOutOfBoundsException(\"Array cant be empty\"); } return array[0]; } getFirstElement(new String[]{\"Uno\", \"Due\"}) //Funktioniert getFirstElement(new Integer[]{1,2,3}) //Funktioniert ebenfalls Wir könnten natürlich auch eine Methode schreiben, die einfach ein Object-Array als Argument hat und ein Object zurückgibt. Weshalb das nicht so eine gute Idee ist, erfährts du im nächsten Kapitel.\"\nTypsicherheit Auch die Typsicherheit eines Programms kann mit Generics verbessert werden.\nDie Object-Klasse in Java ist die Super-Klasse aller anderen Klassen und eine Object-Referenz kann beliebige Objekte referenzieren. Diese Features sind nicht typsicher. Auch durch das Verwenden von Polymorphismus können Typverletzungen entstehen.\nBeispiel Typverletzung, welche nicht zu einem Compiler-Fehler führt\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import java.util.ArrayList; class Test { public static void main(String[] args) { // ArrayList erstellen ohne den Typ der Daten darin zu definieren ArrayList hitchhikersInfo = new ArrayList(); hitchhikersInfo.add(\"Douglas\"); hitchhikersInfo.add(\"Adams\"); hitchhikersInfo.add(42); // Der Compiler erlaubt diese Zuweisung, da wir den Datentyp in der ArrayList nicht definiert haben for (int i=0; i\u003c=hitchhikersInfo.size(); i++) { System.out.println((String) hitchhikersInfo.get(i)); // diesen Typ-Casting wäre nicht nötig gewesen, wenn wir die ArrayListe richtig definiert hätten! } } } Diese Klasse kompiliert ohne Fehler. Der Compiler warnt zwar, dass hier eine unsichere Operation durchgeführt wird, aber er erlaubt diese Operation und die Kompilation ist erfolgreich. Beim Ausführen des Programms kommt es jedoch zu einem Laufzeitfehler vom Typ ClassCastException, weil versucht wird ein Integer in einen String umzuwandeln (Typ-Casting):\n1 2 3 4 5 6 7 PS C:\\devsbb\\sources\\examples\u003e java Test.java Note: Test.java uses unchecked or unsafe operations. Note: recompile with -Xlint:unchecked for details. PS:\\devsbb\\sources\\examples\u003e java Test Douglas Adams Exception in thread \"main\" java.lang.ClassCastException: class java.lang.Integer cannot be cast to class java.lang.String (java.lang.Integer and java.lang.String are in module java.base of loader 'bootstrap' at Test.main(Test.java:13)) Generics helfen solche Laufzeitfehler mit sog. Typvariablen zu vermeiden. Diese Typvariablen werden zur Zeit der Implementierung zunächst durch Platzhalter repräsentiert und dann zum Zeitpunkt der Anwendung konkretisiert. Im obigen Beispiel hätte der Laufzeitfehler vermieden werden können, in dem wir die ArrayList als eine Liste von Strings definiert hätten:\n1 2 3 4 // ArrayList mit Elementen vom Typ String ArrayList\u003cString\u003e hitchhikersInfo = new ArrayList\u003c\u003e(); ... hitchhikersInfo.add(42); // Der Compiler erlaubt diese Zuweisung nicht mehr Beim Versuch, die Klasse erneut zu kompilieren, kommt es zum folgenden Fehler und die Kompilierung schlägt fehl. Mit javac kann der Java Compiler aus der Kommandozeile ausgeführt werden:\n1 2 3 4 5 6 7 PS C:\\devsbb\\sources\\examples\u003e javac Test.java Test.java:10: error: incompatible types: int cannot be converted to String hitchhikersInfo.add(42); //Der Compiler erlaubt diese Zuweisung nicht! ^ Note: Test.java uses unchecked or unsafe operations. Note: Recompile with -Xlint:unchecked for details. Note: Some messages have been simplieied; recompile with X-diags:verbose to get full output 1 error Generics in der Praxis In Java gibt es zwei Typen von Generics: generische Methoden und generische Klassen.\nEine generische Methode kann - wie andere “normale” Methoden auch - Parameter und einen Rückgabewert enthalten. Der Unterschied zu einer “normalen” Methode liegt darin, dass eine generische Methode sog. Typparameter bearbeitet. Somit kann eine generische Methode mit unterschiedlichen Datentypen benutzt werden.\nEine generische Klasse wird genau gleich wie eine nicht-generische Klasse umgesetzt. Der Unterschied liegt darin, dass die generische Klasse einen oder mehrere Typparameter definiert.\nTypparameter definieren In generischen Klassen wie auch in generischen Methoden, werden Typparameter mittels eines Grossbuchstabens definiert, welcher innerhalb spitziger Klammern geschrieben wird z.B: \u003cT\u003e oder \u003cI\u003e.\nMultiple Typparameter werden durch ein Komma getrennt: \u003cT,V\u003e\nTypparameter Namenskonvention Die Buchstaben, welche für die Definition von Typparametern verwendet werden, nutzen die folgende Namenskonvention:\nTypname Zweck T Type E Element K Key N Number V Value Generische Klasse Um generische Klassen zu verwenden, wird zunächst die Klasse mit einem Typparameter definiert und bei der Anwendung dieser Klasse (bei der Instanziierung) wird innerhalb der spitzigen Klammern der konkrete Datentyp geschrieben.\nBeispiel einer benutzer-definierten, generischen Klasse\nIn diesem Beispiel haben wir eine Klasse, welche ein Kartonbox darstellt. Jede Box kann einen Typ von Objekt aufnehmen. Es gibt also z.B. eine Box für String, eine Box für Integer. Natürlich können auch mehrere Boxen für z.B. Integer exisiteren, jede Box kann aber nur einen Typ an Objekt enthalten.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // \u003cT\u003e definiert einen Typparameter class Box\u003cT\u003e { // Deklaration einer Member-Variable vom Typ T T obj; // Konstruktor, erhält ein Object vom Typ T und initialisiert die Member-Variable damit Test(T obj) { this.obj = obj; } // die Getter-Methode liefert ein Objekt vom Typ T zurück public T getObject() { return this.obj; } } Sofern sich die obige Klasse auf dem Klassenpfad befindet, kann sie nun wie folgt verwendet werden:\n1 2 3 4 5 6 7 8 9 10 11 class MyProgram { public static void main(String[] args) { // Instanziieren der generischen Klasse und setzen den Typ auf Integer Box\u003cInteger\u003e integerObject = new Box\u003cInteger\u003e(42); System.out.println(integerObject.getObject()); // Output: 42 // instance of String type Box\u003cString\u003e stringObject = new Box\u003cString\u003e(\"Generics are great!\"); System.out.println(stringObject.getObject()); // Output: Generics are great! } } In diesem Beispiel wurde dieselbe generische Klasse einmal mit einem Integer und einmal mit String verwendet. Dabei wurde die Typsicherheit sichergestellt.\nGenerische Methode Wie bei generischen Klassen werden auch bei generischen Methoden zunächst die Typparameter als Argumente für die Methode definiert und beim Aufruf der Methode werden die konkreten Datentypen mitgegeben.\nBeispiel einer generischen Methode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class Test { // Definition einer generischen Methode static \u003cT\u003e void genericDisplay(T element) { System.out.println(element.getClass().getName() + \" = \" + element); } public static void main(String[] args) { // Die generische Methode wird mit einem Integer-Argument aufgerufen // Achtung: hier wird nicht das primitive Typ \"int\" verwendet sondern die Wrapper-Klasse Integer! genericDisplay(42); // Output: java.lang.Integer = 42 // Die generische Methode wird mit einem String-Argument aufgerufen genericDisplay(\"Generics are great!!\"); // Output: java.lang.String = Generics are great!! // Die generische Methode wird mit einem Double-Argument aufgerufen // Achtung: hier wird nicht das primitive Typ \"double\" verwendet sondern die Wrapper-Klasse Double! genericDisplay(42.0); // Output: java.lang.Double = 42.0 // Primitive Typen können nicht mit Generics verwendet werden // aber eine ArrayList aus einem Array mit primitiven Typen ist erlaubt, weil Arrays Referenz-Typen sind! ArrayList\u003cint[]\u003e arrayListOfIntArray = new ArrayList\u003c\u003e(); int[] oneAndTwo = {1, 2}; int[] threeAndFour = {3, 4}; arrayListOfIntArray.add(oneAndTwo); arrayListOfIntArray.add(threeAndFour); genericDisplay(arrayListOfIntArray); // Output: java.util.ArrayList = [[I@6b2fad11, [I@79698539] } } Bei der Definition von generischen Methoden gibt es einen Unterschied zwischen statischen Methoden und Member-Methoden einer Klasse.\nBei Member-Methoden, wird die generische Deklaration aus der Klassendefinition verwendet. Das heisst, der Typparameter, welche bei der Klassendefinition deklariert wird, wird dasselbe sein wie denjenigen, welche in der Member-Methode verwendet wird.\nStatische Methoden brauchen jedoch ihre eigen generische Deklaration - vor dem Rückgabewert-Typ. Das bedeutet, dass der Typparameter einer statischen Methode nicht vom selben Typ sein muss wie demjenigen aus der Klassendefinition (auch wenn beide Typparameter gleich heissen!).\n1 2 3 4 5 6 7 8 9 10 11 public class Test\u003cT\u003e { T obj; // Hier ist T nicht zwingend gleicher Typ wie denjenigen aus der Klassendefinition public static \u003cT\u003e void staticMethod(T element) {...} // Hier entspricht der Rückgabewert-Typ denjenigen aus der Klassendefinition public T getObject() { return this.obj; } } Bounded Typparameter Es gibt Situationen, in denen es Sinn macht die Datentypen, welche als Argument in einem parametrisierten Typ verwendet werden dürfen, einzuschränken. Zum Beispiel, eine Methode, welche nur mit Zahlen funktionieren kann, sollte keine Datentypen zulassen, welche keine Zahl darstellen. Zu diesem Zweck werden sog. Bounded Type-Parameter verwendet.\nBounded Typparameter schränken die möglichen Typen schon bei der Erstellung der generischen Klasse/Methode ein.\nUm ein Bounded Typparameter zu definieren wird bei der Definition des Typparameters noch das Wort “extends” und der begrenzende Typ (“upper bound type”) hinzugefügt:\nBeispiel: \u003cT extends Number\u003e: T muss zwingend vom Typ Number sein\nIm folgenden Beispiel wird die Klasse “ZooExhibit” (Zoogehege) definiert, welche unterschiedlichen Arten von Tieren beherbergen kann:\n1 2 3 4 public class ZooExhibit\u003cT\u003e { private List\u003cT\u003e animals; ... } Wenn wir die Klasse so definieren, könnte T durch alle mögliche Datentypen ersetzt werden:\n1 2 3 4 5 6 7 public class Main { public static void main(String[] args) { // T kann gemäss Definition auch z.B ein Integer sein! // auch wenn ein Integer im Zoogehege nichts verloren hat... ZooExhibit\u003cInteger\u003e zooExhibit = new ZooExhibit\u003c\u003e(); } } Angenommen, wir haben eine Klasse “Animal” (mit Subklassen wie “Elephant”, “Zebra” usw.), können wir unsere ZooExhibit-Klasse so definieren, dass nur Animal-Typen verwendet werden dürfen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class Animal { } public class Elephant extends Animal { } public class Zebra extends Animal { } public class ZooExhibit\u003cT extends Animal\u003e { private List\u003cT\u003e animals; ... } Wenn wir nun unserem ZooExhibit befüllen möchten, erlaubt uns der Compiler dies nur mit Animal oder mit einer seinen Subklassen zu tun:\n1 2 3 4 5 6 7 8 9 10 11 12 public class Main { public static void main(String[] args) { // Die folgende Zeile wird nun vom Compiler nicht akzeptiert: ZooExhibit\u003cInteger\u003e zooExhibit = new ZooExhibit\u003c\u003e(); // Zoogehege für Elefanten ist erlaubt, da Elephant ein Animal ist: ZooExhibit\u003cElephant\u003e elephantExhibit = new ZooExhibit\u003c\u003e(); // Dasselbe gilt für Zebras: ZooExhibit\u003cZebra\u003e zebraExhibit = new ZooExhibit\u003c\u003e(); } } Wildcards In der generischen Programmierung wird das Fragezeichen (?) als Wildcard bezeichnet. Es repräsentiert eine Referenz auf einen unbekannten Typ.\nUm zu verstehen, wozu es Wildcards braucht, schauen wir uns ein Beispiel an: Angenommen, wir haben die Animal, Elephant und Zebra Klassen vom vorherigen Abschnitt definiert und dazu auch die folgende generische Klasse:\n1 2 3 4 public class AnimalList\u003cT extends Animal\u003e { private final List\u003cT\u003e animals = new ArrayList\u003c\u003e(); ... } Nun möchten wir diese Klasse in einer anderen Klasse wie folgt verwenden:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Zoo { public static void main(String[] args) { AnimalList\u003cElephant\u003e elephants = new AnimalList\u003c\u003e(); AnimalList\u003cZebra\u003e zebras = new AnimalList\u003c\u003e(); // Der Compiler gibt bei folgenden Zeilen eine Fehlermeldung! printAnimalList(elephants); printAnimalList(zebras); } private static void printAnimalList(AnimalList\u003cAnimal\u003e animals) { System.out.println(animals) } } Obwohl Elephant und auch Zebra beide ein Animal sind, gibt der Compiler eine Fehlermeldung beim Versuch, die Methode printAnimalList mit AnimalList resp. mit AnimalList aufzurufen.\nDieser Ansatz (die Super-Klasse zu verwenden, damit die Subklassen auch am gleichen Ort verwendet sein dürfen), funktioniert zwar mit Arrays, nicht aber mit generischen Klassen.\nDer Grund dafür ist der Zeitpunkt der Typ-Prüfung: Bei Arrays wird erst zur Laufzeit auf den richtigen Typ geprüft (und darum werden allfällige Fehler erst zur Laufzeit entdeckt). Bei Generics wird diese Prüfung durch den Compiler übernommen da sie zur Laufzeit wegen dem sog. Type-Erasure (dazu später) nicht erfolgen kann.\nDer Einsatz von Wildcards ermöglicht es, jeden beliebigen generischen Typ zu akzeptieren. Wenn wir nun die Methode printAnimalList mit einer Wildcard definieren, kompiliert der Rest vom Code einwandfrei:\n1 2 3 private static void printAnimalList(AnimalList\u003c?\u003e animals) { System.out.println(animals) } Wenn man \u003c?\u003e verwendet, wird dies “unbeschränkter Wildcard Typ” (“unbounded wildcard”) genannt. Es besteht aber auch die Möglichkeit, Wildcards zu beschränken und zwar in zwei verschiedene Arten:\nUpper-Bound Beschränkung: Beschränkung auf einen Typ und dessen Kindtypen. Die Syntax sieht dann z.B. so aus: \u003c? extends Number\u003e (also irgendein Typ, solange er vom Typ Number oder einer Subklasse davon ist) Lower-Bound Beschränkung: Beschränkung auf einen Typ und dessen Supertypen. Die Syntax sieht dann z.B. so aus: \u003c? super Integer\u003e (also irgendein Typ, solange er vom Typ Integer oder einer Superklasse davon ist) Type Erasure Generics werden nur vom Compiler behandelt und verschwinden zur Laufzeit. Das heisst, der Compiler entfernt beim Kompilieren alle Informationen, die durch Generics definiert wurden. Das bedeutet, dass zur Laufzeit nicht bestimmt werden kann, welcher generische Typ verwendet wurde. Grund für dieses Verhalten war die Notwendigkeit zur Bewahrung der Abwärtskompatibilität zu älteren Java-Versionen, welche keine Generics kennen.\nDas Entfernen der generischen Informationen heisst “type erasure” und der Compiler wendet dies an um:\nAlle Typparameter in generischen Typen mit ihren “bound”-Typen (falls definiert) oder mit Object umzutauschen. Der prduzierte Bytecode beinhaltet dann nur “normale” Klassen, Interfaces und Methoden. Type-Casting dort wo nötig hinzuzufügen, um die Typsicherheit bewahren zu können Sog. Bridge-Methoden zu generieren, um Polymorphismus in erweiterte generische Typen zu bewahren Jetzt bist du dran. Löse bitte die Aufgaben in den Generics-Labs.\n","categories":"","description":"Modul #J2\n","excerpt":"Modul #J2\n","ref":"/docs/02_java/04_java-oop/11_java-generics/","tags":"","title":"Java Generics Grundlagen"},{"body":"Ziele Ich kann in eigenen Worten erklären, was mit Generics in Java gemeint ist und wozu diese angewendet werden. Ich kann alle Vorteile, die die Arbeit mit Generics mit sich bringt, vollständig nennen. Ich kann in eigenen Worten erklären, was Typsicherheit ist. Ich kann anhand eines Beispiels aufzeigen, wie eine Typverletzung entsteht. Ich kann in eigenen Worten erklären, wozu “bounded types” verwendet werden. Ich kann in eigenen Worten erklären, was Wildcards im Kontext von Generics sind und wie sie verwendet werden. Ich kann in eigenen Worten erklären, was “type erasure” ist und wann dieser Vorgang stattfindet. Ich setzte generische Klassen und Methoden in Code-Aufgaben korrekt ein. Einführung Mit Generics sind im Java-Umfeld parametrisierte Datentypen gemeint. So werden mit Generics Datentypen (Integer, String oder auch benutzerdefinierte Datentypen) als Parameter für Klassen, Interfaces und Methoden mitgegeben. Mit Generics ist es also möglich Klassen, Interfaces und Methoden zu schreiben, welche mit unterschiedlichen Datentypen arbeiten können.\nGenerics funktionieren nur mit Referenz-Datentypen (also nicht mit primitiven Datentypen) und werden nur während der Kompilierung ausgewertet.\nTypsicherheit Typsicherheit ist einen Zustand, bei dem Datentypen gemäss ihren Definitionen verwendet werden und keine sog. Typverletzungen auftreten.\nIn der Regel wird bei einer Variable der Datentyp festgelegt. Diesen Datentyp schränkt die Menge der konkreten, zulässigen Werte für diese Variable ein. Versucht man der Variable nun einen Wert ausserhalb diesen zulässigen Bereich zuzuweisen, so liegt eine Typverletzung vor.\nDie Überprüfung der Typsicherheit in Java ist eine Aufgabe des Java-Compilers. Wenn der Compiler eine Typverletzung zur “Compile-Zeit” entdeckt gibt es einen sog. Kompilierfehler, welcher davor warnt. Wenn eine Typverletzung unentdeckt bleibt, können zur Laufzeit des Programms schwer analysierbare Fehler auftreten.\nBeispiel einer Typverletzung, welche vom Compiler entdeckt wird\nIn der folgenden Klasse wird versucht, ein String zu einer Variable des Typs Integer zuzuweisen\n1 2 3 4 5 6 public class Test { public static void main(String[] args) { Integer myInteger; myInteger = \"this is not an integer...\"; } } Beim Versuch, die Klasse zu kompilieren erscheint folgende Fehlermeldung:\n1 2 3 4 5 PS: C\\devsbb\\source\\examples\u003e javac Test.java Test.java:4: error: incompatible types: String cannot be converted to Integer myInteger = \"this is not an integer...\"; ^ 1 error Warum Generics? Programme, welche Generics verwenden, haben mehrere Vorteile gegenüber Programmen ohne Generics:\nWiederverwendbarer Code: eine Klasse oder eine Methode kann einmal geschrieben werden und mit unterschiedlichen Datentypen verwendet werden. Typsicherheit: Generics lösen Fehler während der Kompilierung aus, welche ansonsten erst zur Laufzeit ausgelöst wären. Individuelle Typ-Casting ist nicht nötig: Wenn bei der Anwendung von Generics der konkrete Typ angegeben wird, muss danach kein Typ-Casting stattfinden. Wiederverwendbarkeit Generics helfen uns wiederverwendbaren Code zu schreiben. Das gefällt uns als Informatiker natürlich sehr, da wir so weniger zu tun haben.\nAngenommen wir haben eine Methode um das erste Element aus einem Array zu extrahieren:\n1 2 3 4 5 6 public String getFirstElement(String[] array){ if(array == null || array.length == 0){ throw new ArrayIndexOutOfBoundsException(\"Array cant be empty\"); } return array[0]; } Diese Funktion kann aber nur mit String-Arrays umgehen. Wollen wir noch eine für Integer-Arrays haben brauchen wir eine Methode Integer getFirstElement(Integer[] array), für Double-Arrays eine Methode Double getFirstElement(Double[] array) und so weiter und so fort …\n1 2 getFirstElement(new String[]{\"Uno\", \"Due\"}) //Funktioniert getFirstElement(new Integer[]{1,2,3}) //Führt zu einem Compiler-Fehler Stattdessen können wir aber auch eine Funktion mit Generics schreiben. Diese funktioniert dann für alle nicht-primitiven Typen. Wie genau so eine Methode aufgebaut ist und wofür T steht, erfährst du weiter unten.\n1 2 3 4 5 6 7 8 9 public static \u003cT\u003e T getFirstElement(T[] array) {//T is hier der Ersatz von String/Double/Integer/... if (array == null || array.length == 0) { throw new ArrayIndexOutOfBoundsException(\"Array cant be empty\"); } return array[0]; } getFirstElement(new String[]{\"Uno\", \"Due\"}) //Funktioniert getFirstElement(new Integer[]{1,2,3}) //Funktioniert ebenfalls Wir könnten natürlich auch eine Methode schreiben, die einfach ein Object-Array als Argument hat und ein Object zurückgibt. Weshalb das nicht so eine gute Idee ist, erfährts du im nächsten Kapitel.\"\nTypsicherheit Auch die Typsicherheit eines Programms kann mit Generics verbessert werden.\nDie Object-Klasse in Java ist die Super-Klasse aller anderen Klassen und eine Object-Referenz kann beliebige Objekte referenzieren. Diese Features sind nicht typsicher. Auch durch das Verwenden von Polymorphismus können Typverletzungen entstehen.\nBeispiel Typverletzung, welche nicht zu einem Compiler-Fehler führt\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import java.util.ArrayList; class Test { public static void main(String[] args) { // ArrayList erstellen ohne den Typ der Daten darin zu definieren ArrayList hitchhikersInfo = new ArrayList(); hitchhikersInfo.add(\"Douglas\"); hitchhikersInfo.add(\"Adams\"); hitchhikersInfo.add(42); // Der Compiler erlaubt diese Zuweisung, da wir den Datentyp in der ArrayList nicht definiert haben for (int i=0; i\u003c=hitchhikersInfo.size(); i++) { System.out.println((String) hitchhikersInfo.get(i)); // diesen Typ-Casting wäre nicht nötig gewesen, wenn wir die ArrayListe richtig definiert hätten! } } } Diese Klasse kompiliert ohne Fehler. Der Compiler warnt zwar, dass hier eine unsichere Operation durchgeführt wird, aber er erlaubt diese Operation und die Kompilation ist erfolgreich. Beim Ausführen des Programms kommt es jedoch zu einem Laufzeitfehler vom Typ ClassCastException, weil versucht wird ein Integer in einen String umzuwandeln (Typ-Casting):\n1 2 3 4 5 6 7 PS C:\\devsbb\\sources\\examples\u003e java Test.java Note: Test.java uses unchecked or unsafe operations. Note: recompile with -Xlint:unchecked for details. PS:\\devsbb\\sources\\examples\u003e java Test Douglas Adams Exception in thread \"main\" java.lang.ClassCastException: class java.lang.Integer cannot be cast to class java.lang.String (java.lang.Integer and java.lang.String are in module java.base of loader 'bootstrap' at Test.main(Test.java:13)) Generics helfen solche Laufzeitfehler mit sog. Typvariablen zu vermeiden. Diese Typvariablen werden zur Zeit der Implementierung zunächst durch Platzhalter repräsentiert und dann zum Zeitpunkt der Anwendung konkretisiert. Im obigen Beispiel hätte der Laufzeitfehler vermieden werden können, in dem wir die ArrayList als eine Liste von Strings definiert hätten:\n1 2 3 4 // ArrayList mit Elementen vom Typ String ArrayList\u003cString\u003e hitchhikersInfo = new ArrayList\u003c\u003e(); ... hitchhikersInfo.add(42); // Der Compiler erlaubt diese Zuweisung nicht mehr Beim Versuch, die Klasse erneut zu kompilieren, kommt es zum folgenden Fehler und die Kompilierung schlägt fehl. Mit javac kann der Java Compiler aus der Kommandozeile ausgeführt werden:\n1 2 3 4 5 6 7 PS C:\\devsbb\\sources\\examples\u003e javac Test.java Test.java:10: error: incompatible types: int cannot be converted to String hitchhikersInfo.add(42); //Der Compiler erlaubt diese Zuweisung nicht! ^ Note: Test.java uses unchecked or unsafe operations. Note: Recompile with -Xlint:unchecked for details. Note: Some messages have been simplieied; recompile with X-diags:verbose to get full output 1 error Generics in der Praxis In Java gibt es zwei Typen von Generics: generische Methoden und generische Klassen.\nEine generische Methode kann - wie andere “normale” Methoden auch - Parameter und einen Rückgabewert enthalten. Der Unterschied zu einer “normalen” Methode liegt darin, dass eine generische Methode sog. Typparameter bearbeitet. Somit kann eine generische Methode mit unterschiedlichen Datentypen benutzt werden.\nEine generische Klasse wird genau gleich wie eine nicht-generische Klasse umgesetzt. Der Unterschied liegt darin, dass die generische Klasse einen oder mehrere Typparameter definiert.\nTypparameter definieren In generischen Klassen wie auch in generischen Methoden, werden Typparameter mittels eines Grossbuchstabens definiert, welcher innerhalb spitziger Klammern geschrieben wird z.B: \u003cT\u003e oder \u003cI\u003e.\nMultiple Typparameter werden durch ein Komma getrennt: \u003cT,V\u003e\nTypparameter Namenskonvention Die Buchstaben, welche für die Definition von Typparametern verwendet werden, nutzen die folgende Namenskonvention:\nTypname Zweck T Type E Element K Key N Number V Value Generische Klasse Um generische Klassen zu verwenden, wird zunächst die Klasse mit einem Typparameter definiert und bei der Anwendung dieser Klasse (bei der Instanziierung) wird innerhalb der spitzigen Klammern der konkrete Datentyp geschrieben.\nBeispiel einer benutzer-definierten, generischen Klasse\nIn diesem Beispiel haben wir eine Klasse, welche ein Kartonbox darstellt. Jede Box kann einen Typ von Objekt aufnehmen. Es gibt also z.B. eine Box für String, eine Box für Integer. Natürlich können auch mehrere Boxen für z.B. Integer exisiteren, jede Box kann aber nur einen Typ an Objekt enthalten.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // \u003cT\u003e definiert einen Typparameter class Box\u003cT\u003e { // Deklaration einer Member-Variable vom Typ T T obj; // Konstruktor, erhält ein Object vom Typ T und initialisiert die Member-Variable damit Test(T obj) { this.obj = obj; } // die Getter-Methode liefert ein Objekt vom Typ T zurück public T getObject() { return this.obj; } } Sofern sich die obige Klasse auf dem Klassenpfad befindet, kann sie nun wie folgt verwendet werden:\n1 2 3 4 5 6 7 8 9 10 11 class MyProgram { public static void main(String[] args) { // Instanziieren der generischen Klasse und setzen den Typ auf Integer Box\u003cInteger\u003e integerObject = new Box\u003cInteger\u003e(42); System.out.println(integerObject.getObject()); // Output: 42 // instance of String type Box\u003cString\u003e stringObject = new Box\u003cString\u003e(\"Generics are great!\"); System.out.println(stringObject.getObject()); // Output: Generics are great! } } In diesem Beispiel wurde dieselbe generische Klasse einmal mit einem Integer und einmal mit String verwendet. Dabei wurde die Typsicherheit sichergestellt.\nGenerische Methode Wie bei generischen Klassen werden auch bei generischen Methoden zunächst die Typparameter als Argumente für die Methode definiert und beim Aufruf der Methode werden die konkreten Datentypen mitgegeben.\nBeispiel einer generischen Methode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class Test { // Definition einer generischen Methode static \u003cT\u003e void genericDisplay(T element) { System.out.println(element.getClass().getName() + \" = \" + element); } public static void main(String[] args) { // Die generische Methode wird mit einem Integer-Argument aufgerufen // Achtung: hier wird nicht das primitive Typ \"int\" verwendet sondern die Wrapper-Klasse Integer! genericDisplay(42); // Output: java.lang.Integer = 42 // Die generische Methode wird mit einem String-Argument aufgerufen genericDisplay(\"Generics are great!!\"); // Output: java.lang.String = Generics are great!! // Die generische Methode wird mit einem Double-Argument aufgerufen // Achtung: hier wird nicht das primitive Typ \"double\" verwendet sondern die Wrapper-Klasse Double! genericDisplay(42.0); // Output: java.lang.Double = 42.0 // Primitive Typen können nicht mit Generics verwendet werden // aber eine ArrayList aus einem Array mit primitiven Typen ist erlaubt, weil Arrays Referenz-Typen sind! ArrayList\u003cint[]\u003e arrayListOfIntArray = new ArrayList\u003c\u003e(); int[] oneAndTwo = {1, 2}; int[] threeAndFour = {3, 4}; arrayListOfIntArray.add(oneAndTwo); arrayListOfIntArray.add(threeAndFour); genericDisplay(arrayListOfIntArray); // Output: java.util.ArrayList = [[I@6b2fad11, [I@79698539] } } Bei der Definition von generischen Methoden gibt es einen Unterschied zwischen statischen Methoden und Member-Methoden einer Klasse.\nBei Member-Methoden, wird die generische Deklaration aus der Klassendefinition verwendet. Das heisst, der Typparameter, welche bei der Klassendefinition deklariert wird, wird dasselbe sein wie denjenigen, welche in der Member-Methode verwendet wird.\nStatische Methoden brauchen jedoch ihre eigen generische Deklaration - vor dem Rückgabewert-Typ. Das bedeutet, dass der Typparameter einer statischen Methode nicht vom selben Typ sein muss wie demjenigen aus der Klassendefinition (auch wenn beide Typparameter gleich heissen!).\n1 2 3 4 5 6 7 8 9 10 11 public class Test\u003cT\u003e { T obj; // Hier ist T nicht zwingend gleicher Typ wie denjenigen aus der Klassendefinition public static \u003cT\u003e void staticMethod(T element) {...} // Hier entspricht der Rückgabewert-Typ denjenigen aus der Klassendefinition public T getObject() { return this.obj; } } Bounded Typparameter Es gibt Situationen, in denen es Sinn macht die Datentypen, welche als Argument in einem parametrisierten Typ verwendet werden dürfen, einzuschränken. Zum Beispiel, eine Methode, welche nur mit Zahlen funktionieren kann, sollte keine Datentypen zulassen, welche keine Zahl darstellen. Zu diesem Zweck werden sog. Bounded Type-Parameter verwendet.\nBounded Typparameter schränken die möglichen Typen schon bei der Erstellung der generischen Klasse/Methode ein.\nUm ein Bounded Typparameter zu definieren wird bei der Definition des Typparameters noch das Wort “extends” und der begrenzende Typ (“upper bound type”) hinzugefügt:\nBeispiel: \u003cT extends Number\u003e: T muss zwingend vom Typ Number sein\nIm folgenden Beispiel wird die Klasse “ZooExhibit” (Zoogehege) definiert, welche unterschiedlichen Arten von Tieren beherbergen kann:\n1 2 3 4 public class ZooExhibit\u003cT\u003e { private List\u003cT\u003e animals; ... } Wenn wir die Klasse so definieren, könnte T durch alle mögliche Datentypen ersetzt werden:\n1 2 3 4 5 6 7 public class Main { public static void main(String[] args) { // T kann gemäss Definition auch z.B ein Integer sein! // auch wenn ein Integer im Zoogehege nichts verloren hat... ZooExhibit\u003cInteger\u003e zooExhibit = new ZooExhibit\u003c\u003e(); } } Angenommen, wir haben eine Klasse “Animal” (mit Subklassen wie “Elephant”, “Zebra” usw.), können wir unsere ZooExhibit-Klasse so definieren, dass nur Animal-Typen verwendet werden dürfen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class Animal { } public class Elephant extends Animal { } public class Zebra extends Animal { } public class ZooExhibit\u003cT extends Animal\u003e { private List\u003cT\u003e animals; ... } Wenn wir nun unserem ZooExhibit befüllen möchten, erlaubt uns der Compiler dies nur mit Animal oder mit einer seinen Subklassen zu tun:\n1 2 3 4 5 6 7 8 9 10 11 12 public class Main { public static void main(String[] args) { // Die folgende Zeile wird nun vom Compiler nicht akzeptiert: ZooExhibit\u003cInteger\u003e zooExhibit = new ZooExhibit\u003c\u003e(); // Zoogehege für Elefanten ist erlaubt, da Elephant ein Animal ist: ZooExhibit\u003cElephant\u003e elephantExhibit = new ZooExhibit\u003c\u003e(); // Dasselbe gilt für Zebras: ZooExhibit\u003cZebra\u003e zebraExhibit = new ZooExhibit\u003c\u003e(); } } Wildcards In der generischen Programmierung wird das Fragezeichen (?) als Wildcard bezeichnet. Es repräsentiert eine Referenz auf einen unbekannten Typ.\nUm zu verstehen, wozu es Wildcards braucht, schauen wir uns ein Beispiel an: Angenommen, wir haben die Animal, Elephant und Zebra Klassen vom vorherigen Abschnitt definiert und dazu auch die folgende generische Klasse:\n1 2 3 4 public class AnimalList\u003cT extends Animal\u003e { private final List\u003cT\u003e animals = new ArrayList\u003c\u003e(); ... } Nun möchten wir diese Klasse in einer anderen Klasse wie folgt verwenden:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Zoo { public static void main(String[] args) { AnimalList\u003cElephant\u003e elephants = new AnimalList\u003c\u003e(); AnimalList\u003cZebra\u003e zebras = new AnimalList\u003c\u003e(); // Der Compiler gibt bei folgenden Zeilen eine Fehlermeldung! printAnimalList(elephants); printAnimalList(zebras); } private static void printAnimalList(AnimalList\u003cAnimal\u003e animals) { System.out.println(animals) } } Obwohl Elephant und auch Zebra beide ein Animal sind, gibt der Compiler eine Fehlermeldung beim Versuch, die Methode printAnimalList mit AnimalList resp. mit AnimalList aufzurufen.\nDieser Ansatz (die Super-Klasse zu verwenden, damit die Subklassen auch am gleichen Ort verwendet sein dürfen), funktioniert zwar mit Arrays, nicht aber mit generischen Klassen.\nDer Grund dafür ist der Zeitpunkt der Typ-Prüfung: Bei Arrays wird erst zur Laufzeit auf den richtigen Typ geprüft (und darum werden allfällige Fehler erst zur Laufzeit entdeckt). Bei Generics wird diese Prüfung durch den Compiler übernommen da sie zur Laufzeit wegen dem sog. Type-Erasure (dazu später) nicht erfolgen kann.\nDer Einsatz von Wildcards ermöglicht es, jeden beliebigen generischen Typ zu akzeptieren. Wenn wir nun die Methode printAnimalList mit einer Wildcard definieren, kompiliert der Rest vom Code einwandfrei:\n1 2 3 private static void printAnimalList(AnimalList\u003c?\u003e animals) { System.out.println(animals) } Wenn man \u003c?\u003e verwendet, wird dies “unbeschränkter Wildcard Typ” (“unbounded wildcard”) genannt. Es besteht aber auch die Möglichkeit, Wildcards zu beschränken und zwar in zwei verschiedene Arten:\nUpper-Bound Beschränkung: Beschränkung auf einen Typ und dessen Kindtypen. Die Syntax sieht dann z.B. so aus: \u003c? extends Number\u003e (also irgendein Typ, solange er vom Typ Number oder einer Subklasse davon ist) Lower-Bound Beschränkung: Beschränkung auf einen Typ und dessen Supertypen. Die Syntax sieht dann z.B. so aus: \u003c? super Integer\u003e (also irgendein Typ, solange er vom Typ Integer oder einer Superklasse davon ist) Type Erasure Generics werden nur vom Compiler behandelt und verschwinden zur Laufzeit. Das heisst, der Compiler entfernt beim Kompilieren alle Informationen, die durch Generics definiert wurden. Das bedeutet, dass zur Laufzeit nicht bestimmt werden kann, welcher generische Typ verwendet wurde. Grund für dieses Verhalten war die Notwendigkeit zur Bewahrung der Abwärtskompatibilität zu älteren Java-Versionen, welche keine Generics kennen.\nDas Entfernen der generischen Informationen heisst “type erasure” und der Compiler wendet dies an um:\nAlle Typparameter in generischen Typen mit ihren “bound”-Typen (falls definiert) oder mit Object umzutauschen. Der prduzierte Bytecode beinhaltet dann nur “normale” Klassen, Interfaces und Methoden. Type-Casting dort wo nötig hinzuzufügen, um die Typsicherheit bewahren zu können Sog. Bridge-Methoden zu generieren, um Polymorphismus in erweiterte generische Typen zu bewahren Jetzt bist du dran. Löse bitte die Aufgaben in den Generics-Labs.\n","categories":"","description":"Modul #J2\n","excerpt":"Modul #J2\n","ref":"/de/docs/02_java/04_java-oop/11_java-generics/","tags":"","title":"Java Generics Grundlagen"},{"body":"Ziele Ich weiss was die JDBC-Schnittstelle ist und wofür sie benutzt wird Ich weiss was JDBC-Treiber sind und warum sie benötigt werden Ich kenne die wichtigsten Interfaces der JDBC-Schnittstelle Ich weiss wie parametrisierte SQL-Anweisungen verwendet werden können Ich kann eine Datenbank-Verbindung aus einer Java-Anwendung herstellen Ich kann CRUD-Operationen aus einer Java-Anwendung ausführen Einleitung Die meisten Apps und Webseiten, welche wir heutzutage fast täglich verwenden, dienen lediglich der Datenverarbeitung.\nSobald du ein Bild deines Freundes likest, den Fahrplan abrufst oder eine neue Tastatur bestellst, es werden immer Daten gelesen, geschrieben, bearbeitet oder gelöscht.\nEs gibt Frameworks (darunter z.B. Spring), welche die Verbindung zu Datenbanken verwalten und die sog. “Boiler-Plate”-Details dazu von den Entwicklern verbergen. Diese Frameworks bieten auch einfache Interaktion mit der Datenbank z.B. im Form von CRUD-Operationen. Durch das Verwenden solcher Frameworks kann auf “Boiler-Plate” Code verzichtet werden. Die Entwicklung von Business-Logik ist somit von infrastrukturellen Details getrennt.\nEs gibt jedoch Situationen, wo solche Frameworks nicht benutzt werden können oder man muss bestimmte Aktivitäten, welche diese Frameworks out-of-the-box anbieten, anders gestalten. In solchen Situationen kann die JDBC-Bibliothek von Java verwendet werden.\nWas ist JDBC JDBC ist eine Schnittstelle, welche dafür benutzt wird, um aus einer Java Anwendung eine Verbindung zu einer Datenbank herzustellen und Queries auf den Daten darin (z.B. lesen oder bearbeiten) ausführen zu können.\nDie JDBC-Schnittstelle stellt eine Datenbank unabhängige API zur Verfügung und trägt damit dazu bei, dass die Anwendung nicht an einer bestimmten Datenbank stark gekoppelt ist (sprich, die Anwendung muss die unterliegende Datenbank, theoretisch, gar nicht kennen).\nUm die eigentliche Verbindung mit der Datenbank zu ermöglichen, werden JDBC-Treiber eingesetzt. Ein JDBC-Treiber ist eine Software-Komponente, welche die Zugriffstechnik für eine bestimmte Datenbank (z.B. Oracle, Postgres usw.) kennt und somit in der Lage ist, Anfragen an der Datenbank weiterzuleiten wie auch die Ergebnisse zurückzuliefern. Solche Treiber können umgetauscht werden, wenn die unterliegende Datenbank geändert werden soll, ohne dass es zu einer Anpassung in der Anwendung-Code kommt.\nEine vereinfachte Darstellung der JDBC-Architektur sieht also wie folgt aus:\nJDBC in der Praxis Die Klassen und Interfaces der JDBC-Schnittstelle befinden sich im Paket “java.sql”. Entsprechend reicht ein “import”-Statement um mit diesen Klassen/Interfaces arbeiten zu können. Die JDBC-Treiber sind jedoch separate und proprietäre Komponenten, welche zur Laufzeit vorhanden sein müssen damit der Classloader sie wirklich laden kann. Bei einem Maven-Projekt wird dies mittels einer Maven-Abhängigkeit erledigt. Ansonsten muss die Jar-Datei des Treibers auf dem Klassenpfad vorhanden sein.\nDie ersten Schritte bei der Arbeit mit der JDBC-Schnittstelle beinhalten die nötige Konfiguration um die Verbindung zur Datenbank herstellen zu können. Anschliessend können Abfragen und sonstige SQL-Anweisungen ausgeführt werden.\nDie folgenden Abschnitte zeigen die nötigen Schritte anhand von Beispielen. Diese Beispiele wurden in einem Maven-Projekt ohne das Spring-Framework erstellt.\nMaven-Dependency Sobald die gewünschte Datenbank festgelegt wurde, kann der dazugehörende JDBC-Treiber als Maven-Abhängigkeit herangezogen werden.\nDas folgende Beispiel zeigt eine Abhängigkeit zu einem MySql-Treiber:\nDie restlichen Schritte erfolgen im Java-Code.\nTreiber laden/registrieren Hinweis\nDieser Schritt wird nur bei JDBC-Versionen benötigt, welche älter sind als die Version 4! Bei neueren Versionen, werden alle Treiber geladen, welche auf dem Klassenpfad gefunden werden und somit braucht es diesen Schritt nicht mehr.\nMit der statischen Methode forName von Class wird die Klasse Driver geladen. Hier geht es um die Datenbank spezifischer Treiber, welche es der Anwendung den Datenzugriff auf der gewünschten Datenbank ermöglicht.\nIm folgenden Beispiel wird der JDBC-Treiber für MySql registriert:\nDatenbankverbindung herstellen Der Zugriff auf einer Datenbank erfordert die Konfiguration folgender Elemente:\nurl: eine JDBC-URL, welche auf die gewünschte Datenquelle zeigt Benutzername: einer, für den Zugriff auf die Datenbank, autorisierter Benutzer Passwort: das Passwort des autorisierten Benutzers, womit er sich authentifizieren kann Die Konfiguration wird hier einfachheitshalber als Klartext im Code geschrieben. Selbstverständlich dürfen vertrauliche Informationen wie z.B. das Passwort nicht als Klartext im Code stehen. Für diesen Zweck, wie auch für die Konfiguration unterschiedlichen Umgebungen, eignen sich System- oder Umgebungsvariablen (mit oder ohne Verschlüsselung) besser.\nDie obige Konfiguration kann nun für die Herstellung einer Datenbankverbindung verwendet werden. Dazu wird die statische Methode getConnection der Klasse DriverManager verwendet:\nAb diesem Punkt repräsentiert das Connection-Objekt die Verbindung zur Datenbank.\nSQL-Anweisung vorbereiten Die SQL-Anweisung kann als String vor der Ausführung vorbereitet werden:\nWenn eine IDE wie z.B. IntelliJ verwendet wird und eine Datasource mit der richtigen Datenbank definiert wird, erkennt die IDE, dass es sich um eine SQL-Anweisung handelt und liefert entsprechend Vorschläge und formatiert die Anweisung richtig und gut leserlich.\nDie obige SQL-Anweisung dient dazu alle Daten aus einer bestehenden Tabelle zu Lesen. SQL-Anweisungen können aber auch Operationen wie Tabellen erstellen, Daten einfügen, löschen oder bearbeiten usw. beinhalten.\nAls Beispiel, erstellt die folgende SQL-Anweisung eine Tabelle - falls diese noch nicht existiert - mit ein paar gewünschten Attributen (Spalten):\nSQL-Anweisung ausführen Um SQL-Anweisungen ausführen zu können wird zunächst ein Statement-Objekt aus dem vorhandenen Connection-Objekt erzeugt. Dieses Statement-Objekt wird verwendet, um die SQL-Anweisung an die Datenbank zu richten. Dazu wird eine der execute Methoden des Statement-Objektes verwendet.\nIm folgenden Beispiel wird die ein Statement-Objekt mithilfe des Connection-Objekt erstellt. Danach wird die Methode executeQuery verwendet, welche eine SQL-Anweisung als Parameter entgegennimmt, diese ausführt und eine Referenz auf die Ergebnismenge (sog. ResultSet) zurückliefert:\nParametrisierte SQL-Anweisungen Bis jetzt haben wir SQL-Anweisungen ausgeführt, welche keine Einschränkungen beinhaltet haben. Oft werden jedoch SQL-Anweisungen mit bestimmten Kriterien oder Einschränkungen benötigt damit die zurückgelieferten Daten anhand dieser Kriterien gefiltert werden können. In solchen Situationen wird der SQL “WHERE”-Befehl benutzt. Zum Beispiel:\nSELECT * FROM user WHERE username = ‘gandalf’ and age \u003e 20;\nIn diesem Beispiel, werden nur Einträge zurückgeliefert, welche die Kriterien username = ‘gandalf’ und age \u003e 20 erfüllen. Wenn nun dieselbe Anweisung mehrmals ausgeführt werden soll aber jeweils mit anderen Parameter (also mit unterschiedlichen username und age), wird die Anweisung mit Platzhaltern wie folgt geschrieben (ein Fragezeichen dient als einen Platzhalter):\nFür das eigentliche Ausführen der Anweisung müssen alle Platzhalter durch konkrete Werte ersetzt werden. Dazu wird ein PreparedStatement verwendet, welche es erlaubt, alle Platzhalter anhand ihrer Position (beginnend mit 1) mittels setXXX Methoden anzusprechen und mit den konkreten Werten zu ersetzen. Anschliessend, kann auch hier eine der executeXXX Methoden verwendet werden, um die Anweisung auszuführen:\nRückgabewerte verarbeiten Bei der Ausführung von bestimmten SQL-Anweisungen (z.B. bei SELECT Operationen), wird eine Ergebnismenge zurückgeliefert. Ein ResultSet repräsentiert einen sog. Cursor auf diese Ergebnismenge. Die Methoden des ResultSets, bewegen den Cursor (je nach Art des Cursors) vorwärts, rückwärts, zur ersten oder zur letzten Position usw. Somit kann über die gesamte Ergebnismenge, Zeile bei Zeile, iteriert werden, um die Werte zu lesen.\nIm obigen Beispiel wird die next Methode verwendet um den Cursor jeweils eine Zeile vorwärtszubewegen. Aus jeder Zeile werden aus dem ResultSet mittels getXXX Methoden (XXX steht für den Typ des Wertes) die Werte, welche in dieser aktuellen Zeile vorhanden sind. Die getXXX Methoden, bekommen als Parameter entweder die Spaltenposition oder den Spaltennamen, welche gelesen werden soll. Bei einer Spaltenposition hat die erste zurückgelieferte Spalte die Position 1. Hinter der letzten Zeile liefert die next Methode false zurück und somit wird die Schleife beendet, nachdem alle Zeilen bearbeitet worden sind.\nVerbindungen schliessen Objekte der Typ Connection, Statement oder auch PreparedStatement sind sog. Ressourcen. Solche Ressourcen müssen nach Verbrauch wieder explizit geschlossen werden:\nWenn diese Ressourcen innerhalb eines try-with-resources Befehls erstellt werden, entfällt diese explizite Schliessung der Ressourcen.\nDie Arbeit mit try-with-resources ist immer vorzuziehen, wenn es um Closable-Ressourcen geht.\nZusammenfassung Die folgende Beispiel-Methode fasst die oben erwähnten Arbeitsschritte mit JDBC (aktuelle Version) zusammen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 private static void findByUsernameAndAge(String url, String dbUsername, String password, String username, int age) throws SQLException { try(Connection connection = DriverManager.getConnection(url, dbUsername, password)) { String query = \"SELECT * FROM user WHERE username = ? and age \u003e ?\"; try(PreparedStatement statement = connection.prepareStatement(query)){ statement.setString(1, username); statement.setInt(2, age); ResultSet resultSet = statement.executeQuery(); while(resultSet.next()){ String data = resultSet.getInt(1) + \":\" + resultSet.getString(2); System.out.println(data); } } } } Jetzt bist du dran. Löse bitte diese Aufgabe in den Labs.\n","categories":"","description":"Modul #J7 - JDBC\n","excerpt":"Modul #J7 - JDBC\n","ref":"/docs/02_java/11_java-jdbc/","tags":"","title":"JDBC (Java Database connection)"},{"body":"Ziele Ich weiss was die JDBC-Schnittstelle ist und wofür sie benutzt wird Ich weiss was JDBC-Treiber sind und warum sie benötigt werden Ich kenne die wichtigsten Interfaces der JDBC-Schnittstelle Ich weiss wie parametrisierte SQL-Anweisungen verwendet werden können Ich kann eine Datenbank-Verbindung aus einer Java-Anwendung herstellen Ich kann CRUD-Operationen aus einer Java-Anwendung ausführen Einleitung Die meisten Apps und Webseiten, welche wir heutzutage fast täglich verwenden, dienen lediglich der Datenverarbeitung.\nSobald du ein Bild deines Freundes likest, den Fahrplan abrufst oder eine neue Tastatur bestellst, es werden immer Daten gelesen, geschrieben, bearbeitet oder gelöscht.\nEs gibt Frameworks (darunter z.B. Spring), welche die Verbindung zu Datenbanken verwalten und die sog. “Boiler-Plate”-Details dazu von den Entwicklern verbergen. Diese Frameworks bieten auch einfache Interaktion mit der Datenbank z.B. im Form von CRUD-Operationen. Durch das Verwenden solcher Frameworks kann auf “Boiler-Plate” Code verzichtet werden. Die Entwicklung von Business-Logik ist somit von infrastrukturellen Details getrennt.\nEs gibt jedoch Situationen, wo solche Frameworks nicht benutzt werden können oder man muss bestimmte Aktivitäten, welche diese Frameworks out-of-the-box anbieten, anders gestalten. In solchen Situationen kann die JDBC-Bibliothek von Java verwendet werden.\nWas ist JDBC JDBC ist eine Schnittstelle, welche dafür benutzt wird, um aus einer Java Anwendung eine Verbindung zu einer Datenbank herzustellen und Queries auf den Daten darin (z.B. lesen oder bearbeiten) ausführen zu können.\nDie JDBC-Schnittstelle stellt eine Datenbank unabhängige API zur Verfügung und trägt damit dazu bei, dass die Anwendung nicht an einer bestimmten Datenbank stark gekoppelt ist (sprich, die Anwendung muss die unterliegende Datenbank, theoretisch, gar nicht kennen).\nUm die eigentliche Verbindung mit der Datenbank zu ermöglichen, werden JDBC-Treiber eingesetzt. Ein JDBC-Treiber ist eine Software-Komponente, welche die Zugriffstechnik für eine bestimmte Datenbank (z.B. Oracle, Postgres usw.) kennt und somit in der Lage ist, Anfragen an der Datenbank weiterzuleiten wie auch die Ergebnisse zurückzuliefern. Solche Treiber können umgetauscht werden, wenn die unterliegende Datenbank geändert werden soll, ohne dass es zu einer Anpassung in der Anwendung-Code kommt.\nEine vereinfachte Darstellung der JDBC-Architektur sieht also wie folgt aus:\nJDBC in der Praxis Die Klassen und Interfaces der JDBC-Schnittstelle befinden sich im Paket “java.sql”. Entsprechend reicht ein “import”-Statement um mit diesen Klassen/Interfaces arbeiten zu können. Die JDBC-Treiber sind jedoch separate und proprietäre Komponenten, welche zur Laufzeit vorhanden sein müssen damit der Classloader sie wirklich laden kann. Bei einem Maven-Projekt wird dies mittels einer Maven-Abhängigkeit erledigt. Ansonsten muss die Jar-Datei des Treibers auf dem Klassenpfad vorhanden sein.\nDie ersten Schritte bei der Arbeit mit der JDBC-Schnittstelle beinhalten die nötige Konfiguration um die Verbindung zur Datenbank herstellen zu können. Anschliessend können Abfragen und sonstige SQL-Anweisungen ausgeführt werden.\nDie folgenden Abschnitte zeigen die nötigen Schritte anhand von Beispielen. Diese Beispiele wurden in einem Maven-Projekt ohne das Spring-Framework erstellt.\nMaven-Dependency Sobald die gewünschte Datenbank festgelegt wurde, kann der dazugehörende JDBC-Treiber als Maven-Abhängigkeit herangezogen werden.\nDas folgende Beispiel zeigt eine Abhängigkeit zu einem MySql-Treiber:\nDie restlichen Schritte erfolgen im Java-Code.\nTreiber laden/registrieren Hinweis\nDieser Schritt wird nur bei JDBC-Versionen benötigt, welche älter sind als die Version 4! Bei neueren Versionen, werden alle Treiber geladen, welche auf dem Klassenpfad gefunden werden und somit braucht es diesen Schritt nicht mehr.\nMit der statischen Methode forName von Class wird die Klasse Driver geladen. Hier geht es um die Datenbank spezifischer Treiber, welche es der Anwendung den Datenzugriff auf der gewünschten Datenbank ermöglicht.\nIm folgenden Beispiel wird der JDBC-Treiber für MySql registriert:\nDatenbankverbindung herstellen Der Zugriff auf einer Datenbank erfordert die Konfiguration folgender Elemente:\nurl: eine JDBC-URL, welche auf die gewünschte Datenquelle zeigt Benutzername: einer, für den Zugriff auf die Datenbank, autorisierter Benutzer Passwort: das Passwort des autorisierten Benutzers, womit er sich authentifizieren kann Die Konfiguration wird hier einfachheitshalber als Klartext im Code geschrieben. Selbstverständlich dürfen vertrauliche Informationen wie z.B. das Passwort nicht als Klartext im Code stehen. Für diesen Zweck, wie auch für die Konfiguration unterschiedlichen Umgebungen, eignen sich System- oder Umgebungsvariablen (mit oder ohne Verschlüsselung) besser.\nDie obige Konfiguration kann nun für die Herstellung einer Datenbankverbindung verwendet werden. Dazu wird die statische Methode getConnection der Klasse DriverManager verwendet:\nAb diesem Punkt repräsentiert das Connection-Objekt die Verbindung zur Datenbank.\nSQL-Anweisung vorbereiten Die SQL-Anweisung kann als String vor der Ausführung vorbereitet werden:\nWenn eine IDE wie z.B. IntelliJ verwendet wird und eine Datasource mit der richtigen Datenbank definiert wird, erkennt die IDE, dass es sich um eine SQL-Anweisung handelt und liefert entsprechend Vorschläge und formatiert die Anweisung richtig und gut leserlich.\nDie obige SQL-Anweisung dient dazu alle Daten aus einer bestehenden Tabelle zu Lesen. SQL-Anweisungen können aber auch Operationen wie Tabellen erstellen, Daten einfügen, löschen oder bearbeiten usw. beinhalten.\nAls Beispiel, erstellt die folgende SQL-Anweisung eine Tabelle - falls diese noch nicht existiert - mit ein paar gewünschten Attributen (Spalten):\nSQL-Anweisung ausführen Um SQL-Anweisungen ausführen zu können wird zunächst ein Statement-Objekt aus dem vorhandenen Connection-Objekt erzeugt. Dieses Statement-Objekt wird verwendet, um die SQL-Anweisung an die Datenbank zu richten. Dazu wird eine der execute Methoden des Statement-Objektes verwendet.\nIm folgenden Beispiel wird die ein Statement-Objekt mithilfe des Connection-Objekt erstellt. Danach wird die Methode executeQuery verwendet, welche eine SQL-Anweisung als Parameter entgegennimmt, diese ausführt und eine Referenz auf die Ergebnismenge (sog. ResultSet) zurückliefert:\nParametrisierte SQL-Anweisungen Bis jetzt haben wir SQL-Anweisungen ausgeführt, welche keine Einschränkungen beinhaltet haben. Oft werden jedoch SQL-Anweisungen mit bestimmten Kriterien oder Einschränkungen benötigt damit die zurückgelieferten Daten anhand dieser Kriterien gefiltert werden können. In solchen Situationen wird der SQL “WHERE”-Befehl benutzt. Zum Beispiel:\nSELECT * FROM user WHERE username = ‘gandalf’ and age \u003e 20;\nIn diesem Beispiel, werden nur Einträge zurückgeliefert, welche die Kriterien username = ‘gandalf’ und age \u003e 20 erfüllen. Wenn nun dieselbe Anweisung mehrmals ausgeführt werden soll aber jeweils mit anderen Parameter (also mit unterschiedlichen username und age), wird die Anweisung mit Platzhaltern wie folgt geschrieben (ein Fragezeichen dient als einen Platzhalter):\nFür das eigentliche Ausführen der Anweisung müssen alle Platzhalter durch konkrete Werte ersetzt werden. Dazu wird ein PreparedStatement verwendet, welche es erlaubt, alle Platzhalter anhand ihrer Position (beginnend mit 1) mittels setXXX Methoden anzusprechen und mit den konkreten Werten zu ersetzen. Anschliessend, kann auch hier eine der executeXXX Methoden verwendet werden, um die Anweisung auszuführen:\nRückgabewerte verarbeiten Bei der Ausführung von bestimmten SQL-Anweisungen (z.B. bei SELECT Operationen), wird eine Ergebnismenge zurückgeliefert. Ein ResultSet repräsentiert einen sog. Cursor auf diese Ergebnismenge. Die Methoden des ResultSets, bewegen den Cursor (je nach Art des Cursors) vorwärts, rückwärts, zur ersten oder zur letzten Position usw. Somit kann über die gesamte Ergebnismenge, Zeile bei Zeile, iteriert werden, um die Werte zu lesen.\nIm obigen Beispiel wird die next Methode verwendet um den Cursor jeweils eine Zeile vorwärtszubewegen. Aus jeder Zeile werden aus dem ResultSet mittels getXXX Methoden (XXX steht für den Typ des Wertes) die Werte, welche in dieser aktuellen Zeile vorhanden sind. Die getXXX Methoden, bekommen als Parameter entweder die Spaltenposition oder den Spaltennamen, welche gelesen werden soll. Bei einer Spaltenposition hat die erste zurückgelieferte Spalte die Position 1. Hinter der letzten Zeile liefert die next Methode false zurück und somit wird die Schleife beendet, nachdem alle Zeilen bearbeitet worden sind.\nVerbindungen schliessen Objekte der Typ Connection, Statement oder auch PreparedStatement sind sog. Ressourcen. Solche Ressourcen müssen nach Verbrauch wieder explizit geschlossen werden:\nWenn diese Ressourcen innerhalb eines try-with-resources Befehls erstellt werden, entfällt diese explizite Schliessung der Ressourcen.\nDie Arbeit mit try-with-resources ist immer vorzuziehen, wenn es um Closable-Ressourcen geht.\nZusammenfassung Die folgende Beispiel-Methode fasst die oben erwähnten Arbeitsschritte mit JDBC (aktuelle Version) zusammen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 private static void findByUsernameAndAge(String url, String dbUsername, String password, String username, int age) throws SQLException { try(Connection connection = DriverManager.getConnection(url, dbUsername, password)) { String query = \"SELECT * FROM user WHERE username = ? and age \u003e ?\"; try(PreparedStatement statement = connection.prepareStatement(query)){ statement.setString(1, username); statement.setInt(2, age); ResultSet resultSet = statement.executeQuery(); while(resultSet.next()){ String data = resultSet.getInt(1) + \":\" + resultSet.getString(2); System.out.println(data); } } } } Jetzt bist du dran. Löse bitte diese Aufgabe in den Labs.\n","categories":"","description":"Modul #J7 - JDBC\n","excerpt":"Modul #J7 - JDBC\n","ref":"/de/docs/02_java/11_java-jdbc/","tags":"","title":"JDBC (Java Database connection)"},{"body":" Dieses Kapitel gehört zum Modul #J1 des Ausbildungsplans Ziele Ich verstehe den Unterschied zwischen primitiven und Referenztypen. Ich weiss, dass Referenzvariablen nicht den Wert, sondern einen Verweis speichern. Ich kenne null als möglichen Wert einer Referenz. Ich kann einfache Beispiele von Referenztypen (z. B. String, Array) erkennen. ⏱️ Geschätzte Lesezeit: 10 Minuten Primitive und Referenztypen Als Auffrischung. Du hast bereits gelernt, dass es in Java zwei Arten von Datentypen gibt:\nKategorie Beispiele Beschreibung Primitive Typen int, double, char, boolean Speichern den Wert direkt Referenztypen String, Array, eigene Klassen Speichern nur einen Verweis auf den Wert Vergleich von int zu String Folgendes Beispiel zeigt die Initialisierung eines primitiven Datentypes und eines Referenztypes:\n1 2 int a = 42; String text = \"Hallo\"; a enthält direkt die Zahl 42 text enthält nur eine Referenz auf ein String-Objekt im Speicher null als Wert Wenn eine Referenzvariable noch auf kein Objekt zeigt, ist sie null:\n1 String name = null; Versucht man, auf name zuzugreifen, ohne vorher etwas zuzuweisen, gibt es einen Fehler zur Laufzeit.\nHier verhalten sich die Referenztypen wie primitive Datentypen. Auch bei den Referenztypen muss zuerst ein Wert zugewiesen werden, bevor die Variable benutzt werden darf. Vorsicht bei Vergleichen Bei Referenztypen vergleicht == nicht den Inhalt, sondern ob es dieselbe Referenz ist (auf das gleiche Objekt verweist):\n1 2 String s1 = \"Hallo\"; String s2 = s1; s1 und s2 beinhalten nur eine Zahl, auch Adresse oder Verweis genannt, welche dem Programm mitteilt, wo sich der eigentliche String im Speicher befindet.\nHinweis: Verbindung zu Objekten Referenztypen werden vor allem im Zusammenhang mit Objekten verwendet. In diesem Grundlagenmodul lernst du zwar noch nicht, wie man eigene Objekte erstellt – aber du wirst schon erste Referenztypen wie String und Arrays kennenlernen.\nString ist intern bereits ein Objekt – deshalb verhält es sich wie ein Referenztyp.\nMehr zu Objekten und Klassen erfährst du später im Modul Java OOP.\nBekannte Referenztypen Diese Referenztypen wirst du bald näher kennenlernen:\nString – für Text Arrays – Sammlung von Werten (z. B. mehrere Zahlen) Beide speichern nicht direkt die Werte, sondern sind Referenztypen.\nUnterschied deklarieren und initialisieren Es gibt einen wichtigen Unterschied zwischen einer expliziten Initialisierung mit null und einer nicht initialisierten Referenzvariable.\nExplizite Initialisierung 1 String name = null; Die Variable name ist deklariert und explizit mit null initialisiert. null bedeutet: Die Variable verweist auf kein Objekt. Zugriff auf Methoden oder Eigenschaften führt zu einer NullPointerException. 1 2 3 String name = null; System.out.println(name); // Ausgabe: null System.out.println(name.length()); // NullPointerException Nicht initialisierte Referenzvariable 1 String name; Die Variable name ist deklariert, aber nicht initialisiert. Ein Zugriff ohne vorherige Zuweisung führt zu einem Compilerfehler. 1 2 String name; System.out.println(name); // Fehler: Variable might not have been initialized Zusammenfassung Ausdruck Status Verwendung möglich? Zugriff erlaubt? String name = null; Initialisiert mit null ✅ ja ⚠️ Vorsicht bei Methodenaufrufen String name; Nur deklariert ❌ nein (Compilerfehler) ❌ nicht erlaubt Was passiert bei String text = \"Hallo\";? Wenn du einen String direkt mit einem Text initialisierst, dann wird der Text im sogenannten String-Literal-Pool gespeichert:\n1 String text = \"Hallo\"; // \"Hallo\" ist ein String-Literal Der String-Literal-Pool ist ein spezieller Bereich im Heap-Speicher, in dem alle konstanten Textwerte verwaltet werden. \"Hallo\" wird dort nur einmal gespeichert, auch wenn du es mehrfach verwendest.\nBeispiel:\n1 2 3 4 5 6 String a = \"Hallo\"; String b = \"Hallo\"; System.out.println(a == b); // true – gleiche Referenz im Literal-Pool String c = new String(\"Hallo\"); System.out.println(a == c); // false – c zeigt auf neues Objekt im Heap Vorteil:\nSpart Speicher Macht String-Vergleiche mit == in einfachen Fällen möglich Wenn du bewusst neue String-Objekte erzeugst (mit new String(...)), liegen diese zusätzlich im Heap – auch wenn der Inhalt gleich ist.\nAuch wenn String-Literals eingesetzt werden sollte man Strings immer mit .equals() vergleichen. Das Risiko ist sonst gross, dass ein Vergleich nicht korrekt funktioniert.\n1 2 3 4 5 6 7 String a = \"Hallo\" + \"\"; // Jave Kompiler optimiert das zu \"Hallo\" String b = \"Hallo\"; System.out.println(a == b); // true – gleiche Referenz im Literal-Pool String c = \"\"; String d = \"Hallo\" + c; // Java kann das nicht optimieren. Wert von d wird zur Laufzeit berechnet. System.out.println(a == d); // false – d zeigt auf neues Objekt im Heap Vergleich von Referenztypen: == vs .equals() Wenn du zwei Referenzvariablen vergleichst, musst du unterscheiden:\nVergleichen von Referenzen (Speicheradresse) Das folgende Beispiel vergleicht die Adressen der beiden Strings, nicht den Inhalt:\n1 2 3 4 String a = new String(\"Hallo\"); String b = new String(\"Hallo\"); System.out.println(a == b); // false – verschiedene Objekte im Speicher Vergleichen der Inhalte Das folgende Beispiel vergleicht den Inhalt der beiden Strings:\n1 2 3 4 String a = new String(\"Hallo\"); String b = new String(\"Hallo\"); System.out.println(a.equals(b)); // true – gleiche Zeichenfolge Zwei Strings, welche den gleichen Inhalt (Text) haben gelten als equal.\nDie Methode .equals() ist in der Klasse String (und vielen anderen Klassen) so programmiert, dass sie den Inhalt vergleicht. Vorsicht bei null Wenn eine Variable null ist, darfst du nicht .equals() darauf aufrufen, sonst gibt es eine NullPointerException:\n1 2 String a = null; System.out.println(a.equals(\"Test\")); // NullPointerException Besser so:\n1 System.out.println(\"Test\".equals(a)); // false, aber kein Fehler Zusammenfassung Primitive Typen speichern Werte direkt. Referenztypen speichern nur einen Verweis. null bedeutet: keine Referenz vorhanden. String und Array sind die ersten Referenztypen, die du kennenlernen wirst. ","categories":"","description":"In diesem Modul lernst du den Unterschied zwischen primitiven Typen und Referenztypen kennen.\n","excerpt":"In diesem Modul lernst du den Unterschied zwischen primitiven Typen …","ref":"/docs/02_java/03_java-grundlagen/11_reference_types/","tags":"","title":"Referenztypen"},{"body":"Ziele Du weisst, was Modules in Angular sind. Du kannst erklären, was in einem Module alles enthalten ist und wie es aufgebaut ist. Modules Wichtig: Dieser Abschnitt ist im Rahmen der Veröffentlichung von Angular 18 inzwischen mehr oder weniger überflüssig, da seit Angular 18 alle Komponenten standardmässig als standalone behandelt werden. Da es aber nach wie vor möglich ist, mit Modulen zu arbeiten, ist es dennoch empfehlenswert, sich diesen Abschnitt kurz zu Gemüte zu führen.\nIn Angular ist ein Modul ein Mechanismus, um Components, Directives und Pipes und Services zu gruppieren, die miteinander zusammenhängen. Auf diese Weise können sie mit anderen Modulen kombiniert werden, um eine Anwendung zu erstellen.\nEin Angular-Modul wird mit dem @NgModule-Decorator definiert und kann die folgenden Eigenschaften haben:\ndeclarations: Die Components, Directives und Pipes, die zum Modul gehören. imports: Andere Module, die in diesem Modul verwendet werden können. exports: Die Components, Directives und Pipes, die von diesem Modul exportiert werden und von anderen Modulen verwendet werden können. providers: Services, die in diesem Modul verfügbar sein sollen. bootstrap: Die Components, die beim Anwendungsstart gerendert werden sollen. 1 2 3 4 5 6 7 8 9 10 11 12 import { NgModule } from \"@angular/core\"; import { BrowserModule } from \"@angular/platform-browser\"; import { AppComponent } from \"./app.component\"; @NgModule({ declarations: [AppComponent], imports: [BrowserModule, AppRoutingModule], providers: [], bootstrap: [AppComponent], }) export class AppModule {} ","categories":"","description":"Modul #F6 - Angular - Module\n","excerpt":"Modul #F6 - Angular - Module\n","ref":"/docs/03_web/06_angular/02_11_angular_modules/","tags":"","title":"Modules"},{"body":"Ziele Du weisst, was Modules in Angular sind. Du kannst erklären, was in einem Module alles enthalten ist und wie es aufgebaut ist. Modules Wichtig: Dieser Abschnitt ist im Rahmen der Veröffentlichung von Angular 18 inzwischen mehr oder weniger überflüssig, da seit Angular 18 alle Komponenten standardmässig als standalone behandelt werden. Da es aber nach wie vor möglich ist, mit Modulen zu arbeiten, ist es dennoch empfehlenswert, sich diesen Abschnitt kurz zu Gemüte zu führen.\nIn Angular ist ein Modul ein Mechanismus, um Components, Directives und Pipes und Services zu gruppieren, die miteinander zusammenhängen. Auf diese Weise können sie mit anderen Modulen kombiniert werden, um eine Anwendung zu erstellen.\nEin Angular-Modul wird mit dem @NgModule-Decorator definiert und kann die folgenden Eigenschaften haben:\ndeclarations: Die Components, Directives und Pipes, die zum Modul gehören. imports: Andere Module, die in diesem Modul verwendet werden können. exports: Die Components, Directives und Pipes, die von diesem Modul exportiert werden und von anderen Modulen verwendet werden können. providers: Services, die in diesem Modul verfügbar sein sollen. bootstrap: Die Components, die beim Anwendungsstart gerendert werden sollen. 1 2 3 4 5 6 7 8 9 10 11 12 import { NgModule } from \"@angular/core\"; import { BrowserModule } from \"@angular/platform-browser\"; import { AppComponent } from \"./app.component\"; @NgModule({ declarations: [AppComponent], imports: [BrowserModule, AppRoutingModule], providers: [], bootstrap: [AppComponent], }) export class AppModule {} ","categories":"","description":"Modul #F6 - Angular - Module\n","excerpt":"Modul #F6 - Angular - Module\n","ref":"/de/docs/03_web/06_angular/02_11_angular_modules/","tags":"","title":"Modules"},{"body":"Ziele Du kennst den Unterschied zwischen Maps und Sets. Du kannst Maps erstellen, bearbeiten und Daten abrufen. Du kannst Map-Iteratoren verwenden. Map Maps sind spezielle Objekte, die eine Zuordnung eines Keys zu einem Value ermöglichen. Der Key kann ein beliebiges Objekt sein, während der Value beliebig sein kann. Eine Map speichert keine Duplikat-Keys.\n1 const map = new Map(); Eintrag hinzufügen Mit der set()-Methode wird ein neues Key-Value-Paar zur Map hinzugefügt. Der erste Parameter der Methode ist der Key und der zweite Parameter ist der Value, der mit dem Key assoziiert werden soll. Wenn die Map bereits einen Eintrag mit dem angegebenen Key enthält, wird der neue Value anstelle des alten Values gespeichert.\n1 2 3 4 5 6 7 8 9 10 11 const map = new Map(); map.set(\"key1\", \"value1\"); map.set(\"key2\", \"value2\"); map.set(\"key3\", \"value3\"); console.log(map); // Map {'key1' =\u003e 'value1', 'key2' =\u003e 'value2', 'key3' =\u003e 'value3'} map.set(\"key1\", \"value4\"); console.log(map); // Map {'key1' =\u003e 'value4', 'key2' =\u003e 'value2', 'key3' =\u003e 'value3'} Wert (value) für Key ermitteln Die get(key) Methode gibt den Value zurück, der mit einem bestimmten Key in der Map assoziiert wird. Wenn der Key nicht vorhanden ist, gibt die Methode undefined zurück.\n1 2 3 4 5 6 7 8 const map = new Map(); map.set(\"key1\", \"value1\"); map.set(\"key2\", \"value2\"); map.set(\"key3\", \"value3\"); console.log(map.get(\"key1\")); // 'value1' console.log(map.get(\"key4\")); // undefined Prüfen, ob Key vorhanden ist Die has(key) Methode wird verwendet, um zu überprüfen, ob ein bestimmter Key in der Map vorhanden ist. Die Methode gibt, je nachdem ob der Key gefunden wurde oder nicht, einen entsprechenden booleschen Wert zurück.\n1 2 3 4 5 6 7 8 const map = new Map(); map.set(\"key1\", \"value1\"); map.set(\"key2\", \"value2\"); map.set(\"key3\", \"value3\"); console.log(map.has(\"key1\")); // true console.log(map.has(\"key4\")); // false Eintrag löschen Die Methode delete(key) löscht den angegebenen Key und den zugehörigen Value aus der Map. Wenn der Key in der Map vorhanden ist, wird er zusammen mit dem Value entfernt, und die Methode gibt “true” zurück. Wenn der Key nicht vorhanden ist, wird die Map nicht verändert und die Methode gibt “false” zurück.\n1 2 3 4 5 6 7 8 9 const map = new Map(); map.set(\"key1\", \"value1\"); map.set(\"key2\", \"value2\"); map.set(\"key3\", \"value3\"); console.log(map.delete(\"key1\")); // true console.log(map.delete(\"key4\")); // false console.log(map.get(\"key1\")); // undefined Map zurücksetzen Die clear()-Methode kann verwendet werden, um alle Key-Value-Paare aus einer Map zu entfernen und diese somit auf den Zustand einer leeren Map zurückzusetzen.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const map = new Map(); map.set(\"key1\", \"value1\"); map.set(\"key2\", \"value2\"); map.set(\"key3\", \"value3\"); console.log(map.get(\"key1\")); // 'value1' console.log(map.get(\"key2\")); // 'value2' console.log(map.get(\"key3\")); // 'value2' map.clear(); console.log(map.get(\"key1\")); // undefined console.log(map.get(\"key2\")); // undefined console.log(map.get(\"key3\")); // undefined Anzahl Elemente Die size Methode einer Map gibt die Anzahl der Key-Value-Paare in der Map zurück.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const map = new Map(); map.set(\"key1\", \"value1\"); map.set(\"key2\", \"value2\"); map.set(\"key3\", \"value3\"); console.log(map.size); // 3 map.delete(\"key1\"); console.log(map.size); // 2 map.clear(); console.log(map.size); // 0 Map Iteratoren Iteratoren sind Objekte, die eine Möglichkeit bereitstellen, auf die Elemente einer Sammlung nacheinander zuzugreifen. Ein Iterator bietet also eine sequenzielle Schnittstelle, die es einem ermöglicht, die Elemente einer Sammlung in einer bestimmten Reihenfolge abzurufen.\nentries() Die entries()-Methode gibt einen Iterator zurück, der alle Key-Value-Paare der Map in der Reihenfolge ihrer Hinzufügung enthält. Jedes Element des Iterators ist ein Array mit zwei Elementen, dem Key und dem zugehörigen Value.\n1 2 3 4 5 6 7 8 9 10 11 12 13 const map = new Map(); map.set(\"key1\", \"value1\"); map.set(\"key2\", \"value2\"); map.set(\"key3\", \"value3\"); for (const [key, value] of map.entries()) { console.log([key, value]); } // Array [ \"key1\", \"value1\" ] // Array [ \"key2\", \"value2\" ] // Array [ \"key3\", \"value3\" ] keys() Die keys()-Methode gibt einen Iterator zurück, der nur die Keys der Map enthält.\n1 2 3 4 5 6 7 8 9 10 11 12 13 const map = new Map(); map.set(\"key1\", \"value1\"); map.set(\"key2\", \"value2\"); map.set(\"key3\", \"value3\"); for (const key of map.keys()) { console.log(key); } // key1 // key2 // key3 values() Die values()-Methode gibt einen Iterator zurück, der im Gegensatz zu der keys()-Methode nur die Values der Map enthält.\n1 2 3 4 5 6 7 8 9 10 11 12 13 const map = new Map(); map.set(\"key1\", \"value1\"); map.set(\"key2\", \"value2\"); map.set(\"key3\", \"value3\"); for (const value of map.values()) { console.log(value); } // value1 // value2 // value3 Der Unterschied zwischen Maps und Sets Maps und Sets funktionieren relativ ähnlich, haben aber trotzdem ein paar Unterschiede zueinander, welche die beiden Datenstrukturen unterscheiden. Auf die genaue Funktionsweise von Sets wird im nächsten Kapitel der Dokumentation genauer eingegangen.\nNutzen Maps werden verwendet, um Werte zu speichern, welche jeweils ein key-value-Paar beinhalten. Sets hingegen werden verwendet, um Werte zu speichern, bei denen der value einzigartig ist.\nEinzigartigkeit Maps erzwingen die Einzigartigkeit des key-Elements, während Sets die Einzigartigkeit des value-Elements erzwingen.\nZugriff auf den Inhalt Um auf die Daten einer Map zuzugreifen, wird das key-Element verwendet. Um auf den Inhalt eines Sets zuzugreifen, wird das value-Element verwendet.\n","categories":"","description":"Modul #F4 - JavaScript - Maps.\n","excerpt":"Modul #F4 - JavaScript - Maps.\n","ref":"/docs/03_web/03_javascript/12_maps/","tags":"","title":"Maps"},{"body":"Ziele Du kennst den Unterschied zwischen Maps und Sets. Du kannst Maps erstellen, bearbeiten und Daten abrufen. Du kannst Map-Iteratoren verwenden. Map Maps sind spezielle Objekte, die eine Zuordnung eines Keys zu einem Value ermöglichen. Der Key kann ein beliebiges Objekt sein, während der Value beliebig sein kann. Eine Map speichert keine Duplikat-Keys.\n1 const map = new Map(); Eintrag hinzufügen Mit der set()-Methode wird ein neues Key-Value-Paar zur Map hinzugefügt. Der erste Parameter der Methode ist der Key und der zweite Parameter ist der Value, der mit dem Key assoziiert werden soll. Wenn die Map bereits einen Eintrag mit dem angegebenen Key enthält, wird der neue Value anstelle des alten Values gespeichert.\n1 2 3 4 5 6 7 8 9 10 11 const map = new Map(); map.set(\"key1\", \"value1\"); map.set(\"key2\", \"value2\"); map.set(\"key3\", \"value3\"); console.log(map); // Map {'key1' =\u003e 'value1', 'key2' =\u003e 'value2', 'key3' =\u003e 'value3'} map.set(\"key1\", \"value4\"); console.log(map); // Map {'key1' =\u003e 'value4', 'key2' =\u003e 'value2', 'key3' =\u003e 'value3'} Wert (value) für Key ermitteln Die get(key) Methode gibt den Value zurück, der mit einem bestimmten Key in der Map assoziiert wird. Wenn der Key nicht vorhanden ist, gibt die Methode undefined zurück.\n1 2 3 4 5 6 7 8 const map = new Map(); map.set(\"key1\", \"value1\"); map.set(\"key2\", \"value2\"); map.set(\"key3\", \"value3\"); console.log(map.get(\"key1\")); // 'value1' console.log(map.get(\"key4\")); // undefined Prüfen, ob Key vorhanden ist Die has(key) Methode wird verwendet, um zu überprüfen, ob ein bestimmter Key in der Map vorhanden ist. Die Methode gibt, je nachdem ob der Key gefunden wurde oder nicht, einen entsprechenden booleschen Wert zurück.\n1 2 3 4 5 6 7 8 const map = new Map(); map.set(\"key1\", \"value1\"); map.set(\"key2\", \"value2\"); map.set(\"key3\", \"value3\"); console.log(map.has(\"key1\")); // true console.log(map.has(\"key4\")); // false Eintrag löschen Die Methode delete(key) löscht den angegebenen Key und den zugehörigen Value aus der Map. Wenn der Key in der Map vorhanden ist, wird er zusammen mit dem Value entfernt, und die Methode gibt “true” zurück. Wenn der Key nicht vorhanden ist, wird die Map nicht verändert und die Methode gibt “false” zurück.\n1 2 3 4 5 6 7 8 9 const map = new Map(); map.set(\"key1\", \"value1\"); map.set(\"key2\", \"value2\"); map.set(\"key3\", \"value3\"); console.log(map.delete(\"key1\")); // true console.log(map.delete(\"key4\")); // false console.log(map.get(\"key1\")); // undefined Map zurücksetzen Die clear()-Methode kann verwendet werden, um alle Key-Value-Paare aus einer Map zu entfernen und diese somit auf den Zustand einer leeren Map zurückzusetzen.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const map = new Map(); map.set(\"key1\", \"value1\"); map.set(\"key2\", \"value2\"); map.set(\"key3\", \"value3\"); console.log(map.get(\"key1\")); // 'value1' console.log(map.get(\"key2\")); // 'value2' console.log(map.get(\"key3\")); // 'value2' map.clear(); console.log(map.get(\"key1\")); // undefined console.log(map.get(\"key2\")); // undefined console.log(map.get(\"key3\")); // undefined Anzahl Elemente Die size Methode einer Map gibt die Anzahl der Key-Value-Paare in der Map zurück.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const map = new Map(); map.set(\"key1\", \"value1\"); map.set(\"key2\", \"value2\"); map.set(\"key3\", \"value3\"); console.log(map.size); // 3 map.delete(\"key1\"); console.log(map.size); // 2 map.clear(); console.log(map.size); // 0 Map Iteratoren Iteratoren sind Objekte, die eine Möglichkeit bereitstellen, auf die Elemente einer Sammlung nacheinander zuzugreifen. Ein Iterator bietet also eine sequenzielle Schnittstelle, die es einem ermöglicht, die Elemente einer Sammlung in einer bestimmten Reihenfolge abzurufen.\nentries() Die entries()-Methode gibt einen Iterator zurück, der alle Key-Value-Paare der Map in der Reihenfolge ihrer Hinzufügung enthält. Jedes Element des Iterators ist ein Array mit zwei Elementen, dem Key und dem zugehörigen Value.\n1 2 3 4 5 6 7 8 9 10 11 12 13 const map = new Map(); map.set(\"key1\", \"value1\"); map.set(\"key2\", \"value2\"); map.set(\"key3\", \"value3\"); for (const [key, value] of map.entries()) { console.log([key, value]); } // Array [ \"key1\", \"value1\" ] // Array [ \"key2\", \"value2\" ] // Array [ \"key3\", \"value3\" ] keys() Die keys()-Methode gibt einen Iterator zurück, der nur die Keys der Map enthält.\n1 2 3 4 5 6 7 8 9 10 11 12 13 const map = new Map(); map.set(\"key1\", \"value1\"); map.set(\"key2\", \"value2\"); map.set(\"key3\", \"value3\"); for (const key of map.keys()) { console.log(key); } // key1 // key2 // key3 values() Die values()-Methode gibt einen Iterator zurück, der im Gegensatz zu der keys()-Methode nur die Values der Map enthält.\n1 2 3 4 5 6 7 8 9 10 11 12 13 const map = new Map(); map.set(\"key1\", \"value1\"); map.set(\"key2\", \"value2\"); map.set(\"key3\", \"value3\"); for (const value of map.values()) { console.log(value); } // value1 // value2 // value3 Der Unterschied zwischen Maps und Sets Maps und Sets funktionieren relativ ähnlich, haben aber trotzdem ein paar Unterschiede zueinander, welche die beiden Datenstrukturen unterscheiden. Auf die genaue Funktionsweise von Sets wird im nächsten Kapitel der Dokumentation genauer eingegangen.\nNutzen Maps werden verwendet, um Werte zu speichern, welche jeweils ein key-value-Paar beinhalten. Sets hingegen werden verwendet, um Werte zu speichern, bei denen der value einzigartig ist.\nEinzigartigkeit Maps erzwingen die Einzigartigkeit des key-Elements, während Sets die Einzigartigkeit des value-Elements erzwingen.\nZugriff auf den Inhalt Um auf die Daten einer Map zuzugreifen, wird das key-Element verwendet. Um auf den Inhalt eines Sets zuzugreifen, wird das value-Element verwendet.\n","categories":"","description":"Modul #F4 - JavaScript - Maps.\n","excerpt":"Modul #F4 - JavaScript - Maps.\n","ref":"/de/docs/03_web/03_javascript/12_maps/","tags":"","title":"Maps"},{"body":"Ziele Ich weiss, was CSS-Selektoren sind und wofür sie verwendet werden. Ich kenne die verschiedenen Arten von CSS-Selektoren und ihre jeweiligen spezifischen Anwendungsfälle. Ich kann CSS-Selektoren gezielt in HTML-Dokumenten anwenden. Welche CSS-Selektoren gibt es? Nun da wir die Grundlagen von CSS gelernt haben, können wir uns die Selektoren genauer anschauen. Die Selektoren bestimmen, für welche HTML-Elemente die definierten CSS-Regeln gelten.\nSelektoren im Überblick Es gibt verschiedenste Selektoren, welche alle ihren eigenen Nutzen erfüllen. In der folgenden Tabelle werden die gängigsten aufgezählt und erklärt:\nName Anwendung in HTML Anwendung in CSS Beschreibung Klasse class=\"demo-class\" .demo-class {...} CSS-Klassen können mit dem “class”-Attribut auf jedes beliebige HTML-Element angewendet und dann in CSS referenziert werden. Klassen können dabei auf mehrere Elemente angewandt werden, was das Wiederverwenden der CSS-Regeln ermöglicht. Ein HTML-Element kann auch mehrere Klassen haben. ID id=\"demo-id\" #demo-class {...} IDs können mit dem “id”-Attribut auf jedes beliebige HTML-Element angewendet werden. Grundsätzlich sollten IDs eindeutig sein, also nicht an mehreren Orten verwendet werden. Element \u003celement-name\u003e\u003c/element-name\u003e element-name {...} Um alle HTML-Elemente eines Types auszuwählen, muss man nichts Spezielles in HTML anpassen. Es muss lediglich der Umstand gegeben sein, dass die angesprochenen Elemente auch tatsächlich vorhanden sind. Im CSS muss man dann nur noch den Element-Namen angeben (im Beispiel zu ersetzen mit z.B. a, p, input, body etc.), wobei keine Prefixes notwendig sind. Im nächsten Beispiel werden alle 3 Möglichkeiten einmal angewandt:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u003cform class=\"round-container\"\u003e \u003cp\u003eBitte gib deinen Namen ein:\u003c/p\u003e \u003clabel for=\"your-name\"\u003eName\u003c/label\u003e \u003cinput type=\"text\" id=\"your-name\" name=\"name\" /\u003e \u003cinput type=\"submit\" /\u003e \u003c/form\u003e \u003cstyle\u003e .round-container { width: 20em; background-color: lightgrey; border-radius: 2em; padding: 1em; } #your-name { background-color: orange; } label { font-weight: bold; } \u003c/style\u003e In diesem Beispiel wurden das \u003cform\u003e-Element mit der Klasse round-container, das \u003cinput\u003e-Element mit der ID your-name und das Element label mit einer Designanpassung per CSS versehen.\nSpezifischere Selektoren Element aufgrund eines spezifischen Attributes stylen Es kann vorkommen, dass du ein Element mit einem spezifischen Attribut stylen willst. Möchtest du z.B. alle Submit-Buttons stylen, kannst du das mit diesem Selektor bewerkstelligen: input[type=submit] {...}\nEs besteht aber auch die Möglichkeit, dass der Attribut-Wert einen bestimmten Text enthält, damit beginnt oder damit endet. Für diesen Fall sei auf diese Seite verwiesen: https://www.w3schools.com/cssref/css_selectors.asp\nSpezifisches Element per Klasse stylen Möchtest du alle \u003cform\u003e-Elemente stylen, denen die Klasse round-container zugewiesen ist, dann kannst du den folgenden Selektor verwenden: form.round-container {...}\nElemente, die sich in einem anderen Element befinden müssen Möchtest du alle label-Elemente stylen, die sich in einem form-Element befinden, dann verwende den folgenden Selektor: form label {...}. Zuerst kommt das übergeordnete Element, dann dasjenige, das tiefer verschachtelt ist. Die Elemente werden mit einem Leerzeichen voneinander getrennt. Bei diesem Selektor spielt es keine Rolle, ob label genau eine Stufe innerhalb von form ist. Es ist lediglich die Frage, ob sich überhaupt ein \u003clabel\u003e-Element darin befindet.\nIst es hingegen relevant, dass das label direkt als erste weitere Stufe in der form vorkommt (also keinen anderen Parent hat als form), dann benutze folgende Regel: form \u003e label {...}. Bei diesem Selektor bedeutet das \u003e, dass das erste Element der Parent vom zweiten Element sein muss.\nPseudoklassen Mithilfe von Pseudoklassen kann ein besonderer Zustand abgefragt werden. Mit :hover können CSS-Regeln beispielsweise auf Elemente beschränkt werden, über welchen sich derzeit der Mauszeiger befindet. Dazu nachfolgend ein Beispiel:\n1 2 3 4 input[type=\"submit\"]:hover { background-color: orange; color: white; } Für \u003cinput\u003e-Elemente sind Pseudoklassen wie :disabled oder :checked (für Checkboxen) relevant, welche den Zustand des \u003cinput\u003e-Elements als Kondition haben.\nDu hast des Weiteren aber auch Zugriff auf völlig andere Aspekte! Du kannst zum Beispiel auch den ersten Buchstaben einem Paragrafen automatisch grossschreiben lassen:\n1 2 3 p:first-letter { font-size: 200%; } Viele weitere Pseudoklassen findest du hier beschrieben: https://web.dev/learn/css/pseudo-classes/\n","categories":"","description":"Modul #F3 - HTML und CSS - Die verschiedenen CSS-Selektoren.\n","excerpt":"Modul #F3 - HTML und CSS - Die verschiedenen CSS-Selektoren.\n","ref":"/docs/03_web/02_html_css/11_css-selectors/","tags":"","title":"CSS-Selektoren"},{"body":"Ziele Ich weiss, was CSS-Selektoren sind und wofür sie verwendet werden. Ich kenne die verschiedenen Arten von CSS-Selektoren und ihre jeweiligen spezifischen Anwendungsfälle. Ich kann CSS-Selektoren gezielt in HTML-Dokumenten anwenden. Welche CSS-Selektoren gibt es? Nun da wir die Grundlagen von CSS gelernt haben, können wir uns die Selektoren genauer anschauen. Die Selektoren bestimmen, für welche HTML-Elemente die definierten CSS-Regeln gelten.\nSelektoren im Überblick Es gibt verschiedenste Selektoren, welche alle ihren eigenen Nutzen erfüllen. In der folgenden Tabelle werden die gängigsten aufgezählt und erklärt:\nName Anwendung in HTML Anwendung in CSS Beschreibung Klasse class=\"demo-class\" .demo-class {...} CSS-Klassen können mit dem “class”-Attribut auf jedes beliebige HTML-Element angewendet und dann in CSS referenziert werden. Klassen können dabei auf mehrere Elemente angewandt werden, was das Wiederverwenden der CSS-Regeln ermöglicht. Ein HTML-Element kann auch mehrere Klassen haben. ID id=\"demo-id\" #demo-class {...} IDs können mit dem “id”-Attribut auf jedes beliebige HTML-Element angewendet werden. Grundsätzlich sollten IDs eindeutig sein, also nicht an mehreren Orten verwendet werden. Element \u003celement-name\u003e\u003c/element-name\u003e element-name {...} Um alle HTML-Elemente eines Types auszuwählen, muss man nichts Spezielles in HTML anpassen. Es muss lediglich der Umstand gegeben sein, dass die angesprochenen Elemente auch tatsächlich vorhanden sind. Im CSS muss man dann nur noch den Element-Namen angeben (im Beispiel zu ersetzen mit z.B. a, p, input, body etc.), wobei keine Prefixes notwendig sind. Im nächsten Beispiel werden alle 3 Möglichkeiten einmal angewandt:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u003cform class=\"round-container\"\u003e \u003cp\u003eBitte gib deinen Namen ein:\u003c/p\u003e \u003clabel for=\"your-name\"\u003eName\u003c/label\u003e \u003cinput type=\"text\" id=\"your-name\" name=\"name\" /\u003e \u003cinput type=\"submit\" /\u003e \u003c/form\u003e \u003cstyle\u003e .round-container { width: 20em; background-color: lightgrey; border-radius: 2em; padding: 1em; } #your-name { background-color: orange; } label { font-weight: bold; } \u003c/style\u003e In diesem Beispiel wurden das \u003cform\u003e-Element mit der Klasse round-container, das \u003cinput\u003e-Element mit der ID your-name und das Element label mit einer Designanpassung per CSS versehen.\nSpezifischere Selektoren Element aufgrund eines spezifischen Attributes stylen Es kann vorkommen, dass du ein Element mit einem spezifischen Attribut stylen willst. Möchtest du z.B. alle Submit-Buttons stylen, kannst du das mit diesem Selektor bewerkstelligen: input[type=submit] {...}\nEs besteht aber auch die Möglichkeit, dass der Attribut-Wert einen bestimmten Text enthält, damit beginnt oder damit endet. Für diesen Fall sei auf diese Seite verwiesen: https://www.w3schools.com/cssref/css_selectors.asp\nSpezifisches Element per Klasse stylen Möchtest du alle \u003cform\u003e-Elemente stylen, denen die Klasse round-container zugewiesen ist, dann kannst du den folgenden Selektor verwenden: form.round-container {...}\nElemente, die sich in einem anderen Element befinden müssen Möchtest du alle label-Elemente stylen, die sich in einem form-Element befinden, dann verwende den folgenden Selektor: form label {...}. Zuerst kommt das übergeordnete Element, dann dasjenige, das tiefer verschachtelt ist. Die Elemente werden mit einem Leerzeichen voneinander getrennt. Bei diesem Selektor spielt es keine Rolle, ob label genau eine Stufe innerhalb von form ist. Es ist lediglich die Frage, ob sich überhaupt ein \u003clabel\u003e-Element darin befindet.\nIst es hingegen relevant, dass das label direkt als erste weitere Stufe in der form vorkommt (also keinen anderen Parent hat als form), dann benutze folgende Regel: form \u003e label {...}. Bei diesem Selektor bedeutet das \u003e, dass das erste Element der Parent vom zweiten Element sein muss.\nPseudoklassen Mithilfe von Pseudoklassen kann ein besonderer Zustand abgefragt werden. Mit :hover können CSS-Regeln beispielsweise auf Elemente beschränkt werden, über welchen sich derzeit der Mauszeiger befindet. Dazu nachfolgend ein Beispiel:\n1 2 3 4 input[type=\"submit\"]:hover { background-color: orange; color: white; } Für \u003cinput\u003e-Elemente sind Pseudoklassen wie :disabled oder :checked (für Checkboxen) relevant, welche den Zustand des \u003cinput\u003e-Elements als Kondition haben.\nDu hast des Weiteren aber auch Zugriff auf völlig andere Aspekte! Du kannst zum Beispiel auch den ersten Buchstaben einem Paragrafen automatisch grossschreiben lassen:\n1 2 3 p:first-letter { font-size: 200%; } Viele weitere Pseudoklassen findest du hier beschrieben: https://web.dev/learn/css/pseudo-classes/\n","categories":"","description":"Modul #F3 - HTML und CSS - Die verschiedenen CSS-Selektoren.\n","excerpt":"Modul #F3 - HTML und CSS - Die verschiedenen CSS-Selektoren.\n","ref":"/de/docs/03_web/02_html_css/11_css-selectors/","tags":"","title":"CSS-Selektoren"},{"body":"Ziele Du weisst, wie du in IntelliJ Java Code debuggen kannst. Wieso ist Debuggen wichtig? Es gibt eine Vielzahl von Gründen, warum Java-Anwendungen Fehler enthalten können. Typische Fehler sind zum Beispiel unerwartete Exceptions oder auch eine fehlerhafte Logik innerhalb des Codes. Mit Debugging kann man das Program systematisch analysieren und so die entsprechenden Fehler identifizieren und beheben.\nDebuggen kann Entwicklern auch helfen den Ablauf eines Programms besser zu verstehen. Mit dem Debugger kann man den Code Schritt für Schritt durchlaufen und sieht, wie Daten sich verändern und wo welche Entscheidungen getroffen werden. Gerade wenn man eine Methode zum ersten Mal sieht, kann dies stark zum Verständnis der Funktionsweise des Programms beitragen.\nWarum debuggen und nicht System.out.println() verwenden? Die Antwort ist ziemlich einfach, die gleiche Logik wie beim Loggen eines Wertes kannst du mit einem einfach programmierten Breakpoint erreichen. Dazu gleich mehr.\nDas Problem beim Loggen von Nachrichten und Werten ist nicht, dass es nicht funktioniert. Es ist, dass es die Lesbarkeit des geschriebenen Codes beeinträchtigt und die Konsole mit sinnlosen Logs überfüllt. Ausserdem birgt jedes geschriebene Log das Risiko, dass es bei einem git push vergessen wird und so auf die produktiven Umgebungen gelangen könnte.\nZudem kann der Debugger deutlich mehr als nur Logs zu schreiben. Er wird benutzt, um mithilfe von Breakpoints den Code während der Ausführung anzuhalten, zu analysieren und Fehler im Code zu finden. Somit ist es besser mit Tools von IntelliJ zu debuggen.\nDebuggen in IntelliJ Um in IntelliJ zu debuggen, muss man nicht zuerst ein File erstellen oder eine Extension haben. Es reicht, bereits wenn man die Breakpoints setzt. Dafür kann man, links neben der Zeilenzahl mittels Links-Klick einen normalen Breakpoint setzen oder mit Rechts-Klick die Optionen ansehen:\nDie Optionen zeigen folgende zwei Breakpoints:\nBreakpoints: Breakpoints sind die am häufigsten verwendeten. Sie ermöglichen es, den Programmfluss an einer bestimmten Zeile zu unterbrechen und den Code schrittweise zu debuggen. Conditional Breakpoints: Conditional Breakpoints ermöglichen es, einen Breakpoint zu setzen, der nur unter bestimmten Bedingungen ausgelöst wird. Um weitere Arten von Breakpoints zu definieren, muss man in der Auswahl den Conditional Breakpoint auswählen und anschliessend auf more klicken.\nEs öffnet sich ein Pop-Up, in welchem man weitere Möglichkeiten hat um Breakpoints zu definieren.\nHier kann beispielsweise, wie im Bild ersichtlich, einen Log definieren, so fungiert der Breakpoint zusätzlich als System.out.println(). Man kann auch einstellen, dass der Breakpoint entfernt werden soll, sobald er einmal aufgerufen wurde. Oder dass er solang inaktiv sein soll bis ein anderer Breakpoint ausgelöst wurde.\nUm den Debug-Modus zu starten, kann man in IntelliJ oben rechts das Icon das wie ein Käfer aussieht verwenden:\nDas Debugging-Panel unten auf der Benutzeroberfläche besitzt verschiedene nützliche Tools:\nDebugger Controls Debug Console Frames Variables Watches Debugger Controls: Rerun: Dieser Button startet das Programm im Debug-Modus neu.\nStop: Mit diesem Button stoppt man den Debug-Modus.\nPause: Dieser Button unterbricht den Programmablauf und hält den Debugger an. Man benutzt es, um das Programm zu pausieren und den aktuellen Zustand der Variablen und Objekte zu überprüfen.\nResume Program: Mit diesem Button kann man das Programm im Debug-Modus fortsetzen, nachdem es unterbrochen wurde.\nStep Over: Dieser Button führt das aktuelle Statement im Code aus und hält an der nächsten Zeile an. Wenn das Statement eine Methode aufruft, wird die Methode ausgeführt und der Debugger hält an der nächsten Zeile an.\nStep Into: Diese Schaltfläche führt das aktuelle Statement im Code aus und hält an der nächsten Zeile an. Wenn das Statement eine Methode aufruft, wird der Debugger in die Methode hineinspringen und an der ersten Zeile der Methode anhalten.\nStep Out: Mit dieser Schaltfläche kann man aus einer Methode heraus zurückkehren und den Debugger an der nächsten Zeile nach der Methode anhalten.\nView Breakpoints: Mit diesem Button kann man alle Breakpoints anzeigen und konfigurieren, einschliesslich Bedingungen und Aktionen, die bei der Unterbrechung ausgelöst werden sollen.\nMute Breakpoint: Mit diesem Button kann man einen Breakpoint stumm schalten, ohne ihn zu entfernen. Dies ist nützlich, wenn man schnell durch den Code navigieren möchten, ohne dass der Debugger bei jedem Breakpoint stoppt.\nDebug Console: Hier kann man interaktiv mit dem Code interagieren, indem man JS-Befehle eingibt und ihre Ausgabe sieht. Man kann auch Fehlermeldungen oder Ausnahmen sehen, die während der Ausführung des Codes auftreten.\nFrames: In diesem Bereich werden die Stack-Frames angezeigt, die den aktuellen Programmablauf darstellen. Man kann durch die Frames navigieren, indem man auf den Namen des Frames klicken.\nVariables: Hier kann man die Werte von Variablen während des Debugging-Prozesses überwachen. Man kann die Variablen auswählen, um ihre aktuellen Werte anzuzeigen, oder man kann Ausdrücke eingeben, um ihre Werte zu berechnen.\nWatches: Man kann eine Liste von Variablen erstellen, die man überwachen möchten. Man kann Variablen zur Watcherlist hinzufügen, indem man mit der rechten Maustaste auf die Variable klicken und “Add to Watches” auswählen. Die Variable kann man auch im Inputfeld eingeben und auf das Plusicon am Ende klicken, um sie in die Watcherlist hinzuzufügen:\nDie Watcher werden dann über den Variablen aufgelistet:\nGenau wie beim Hinzufügen kann man einen Watcher entfernen, indem man einem rechten Mausklick auf die Variabel tätigt und “Remove Watch” anklickt.\nMehr Informationen bezüglich Debuggen in IntelliJ findest du unter folgenden Link: Debug Code\n","categories":"","description":"Modul #J1 - Debugging von Java Code\n","excerpt":"Modul #J1 - Debugging von Java Code\n","ref":"/de/docs/02_java/03_java-grundlagen/12_debugging/","tags":"","title":"Debugging"},{"body":" Dieses Kapitel gehört zum Modul #J1 des Ausbildungsplans Ziele Ich weiss, was ein Package ist und wozu man es verwendet. Ich kann eigene Packages deklarieren und verstehen, wie sie im Dateisystem aufgebaut sind. Ich kenne die Sichtbarkeiten public, protected, private und (default) und deren Bedeutung im Zusammenhang mit Packages. Ich weiss, wie man Packages importiert und wann dies notwendig ist. Ich verstehe den Unterschied zwischen eingebauten, externen und selbst geschriebenen Packages. Ich weiss, woher externe Packages stammen können (lokal, Maven Central, GitHub …). Ich kann ein Java-Package lokal so bereitstellen, dass es in anderen Projekten verwendet werden kann. Ich weiss, was eine API ist und warum eine gute JavaDoc wichtig ist. Ich habe eine erste Vorstellung, was static bedeutet und wofür man es nutzt. ⏱️ Geschätzte Lesezeit: 15 Minuten Was ist ein Package? Ein Package ist ein Namensraum zur Gruppierung von Klassen und anderen Programmteilen. In einem späteren Modul wirst du Klassen auch in einem anderen Zusammenhang begegnen. Klassen benötigt man später auch, um Objekte zu beschreiben. Vorerst helfen uns die Klassen, Methoden zu gruppieren.\nIn Java beginnt jede Datei optional mit einer package-Anweisung:\n1 package ch.itninja.tool; Damit sagst du, dass sich die Datei im Package ch.itninja.tool befindet. Entsprechend muss die Datei im Verzeichnis ch/itninja/tool liegen.\nEin Package entspricht einem Verzeichnis im Dateisystem. Achte auf die korrekte Ordnerstruktur und wähle den Namen eines Packages mit bedacht. Ein guter Name hilft dir später, den Zusammenhang komplexer Software schneller zu verstehen und das passende Packet für eine Problemstellung schneller zu finden. Packages helfen, deinen Code zu strukturieren und Wiederverwendung zu ermöglichen. Auch Bibliotheken wie java.util oder java.io sind Packages.\nPackages eröffnen dir eine Welt ungeahnter Möglichkeiten: Bis jetzt hast du Aufgaben meist mit mathematischen und logischen Operationen sowie bedingten Anweisungen gelöst. Das kann bei komplexeren Problemen sehr aufwändig werden.\nHier kommen Packages ins Spiel: Für viele wiederkehrende Aufgaben gibt es bereits fertige Hilfsklassen – sogenannte Utility-Klassen. Du musst das Rad nicht neu erfinden!\nBeispiele für nützliche Packages:\njava.lang.Math: Mathematische Methoden wie max(), min(), pow() oder sqrt() java.lang.String: Zeichenketten-Verarbeitung (nächstes Modul) java.util.Scanner: Einfache Konsoleneingabe (folgt bald) java.io.File: Arbeiten mit Dateien Die Methoden dieser Klassen kannst du direkt verwenden – oft ohne objektorientierte Programmierung.\nPackages vs. Bibliotheken Begriff Bedeutung Package Logische Gruppierung von Klassen im Quellcode Bibliothek Weitergabe eines oder mehrerer Packages als .jar Datei Package Ein Package ist eine logische Gruppierung von Klassen, um Code zu strukturieren. Beispiel:\n1 package ch.itninja.util; Das Package hilft, Code zu ordnen und wiederzuverwenden. Es zeigt, wo man den Quellcode findet (der Package Name entspricht dem Pfad, wo der Quellcode abgelegt ist)\nBibliothek (Library) Eine Bibliothek ist ein weitergegebenes .jar-Archiv mit einem oder mehreren Packages.\nBeispiel: Du exportierst MathUtils im Package ch.itninja.util als math-utils.jar.\nSichtbarkeiten verstehen In Java steuerst du über Sichtbarkeiten, von wo auf eine Klasse, Methode oder Variable zugegriffen werden darf:\nSichtbarkeit Bedeutung public Überall sichtbar – auch von anderen Packages protected Sichtbar für Unterklassen und innerhalb desselben Packages (default) Sichtbar nur innerhalb desselben Packages (kein Modifier angegeben) private Sichtbar nur innerhalb derselben Klasse public ist nötig, wenn eine Klasse oder Methode von einem anderen Package aus genutzt werden soll.\nMit (default) (kein Modifier) ist die Nutzung nur innerhalb desselben Packages erlaubt, das ist sehr praktisch für interne Hilfsmethoden oder Klassen.\nWähle die Sichtbarkeit so restriktiv wie möglich – am besten in dieser Reihenfolge:\nprivate protected (default) (package-intern) public Begründung:\nJe offener die Sichtbarkeit, desto größer das Risiko von ungewollten Abhängigkeiten und Nebenwirkungen.\nWenn etwas public ist, kann es von beliebigen anderen Packages (auch außerhalb deines Projekts) genutzt werden.\nÄnderungen an einer public-Schnittstelle können daher weitreichende Folgen haben, die du nicht immer abschätzen kannst.\nMit (default), protected oder private bleiben die Auswirkungen auf dein eigenes Package oder sogar nur auf die eigene Klasse beschränkt. Das verringert das Risiko erheblich.\nImportieren von Packages Wenn du eine public-Klasse aus einem anderen Package brauchst, musst du sie importieren:\n1 import java.util.Scanner; Oder mit Wildcard (nicht empfohlen):\n1 import java.util.*; Manche Klassen stehen dir ohne Import zur Verfügung, z. B. String oder System. Das sind Klassen aus dem Package java.lang, welches automatisch importiert wird.\nWoher kommen Packages? Es gibt drei Arten von Packages:\nJava-eigene Packages – z. B. java.util, java.io, java.math Externe Packages – z. B. org.apache.commons.math3 Eigene Packages – z. B. ch.itninja.util Externe Packages müssen zuerst zum Projekt hinzugefügt werden, z. B.:\naus dem lokalen Dateisystem (z. B. .jar-Datei) aus einem Maven-Repository (z. B. Maven Central) aus einem GitHub Release oder privaten Server Eigene Packages erstellen Wenn du eigenen Code schreibst, sollte:\nzu Beginn der Datei der Name des Packages mit package definiert werden, z. B. package ch.itninja.math; die Datei in einen gleichnamigen Ordner legen: ch/itninja/math Verwende keine Klassen ohne package-Deklaration! Nur mit einer package-Zeile liegt deine Datei in einem benannten Package – das ist wichtig für Struktur, Wiederverwendbarkeit und Importierbarkeit. Die src-Struktur eines Projekts sieht z. B. so aus:\n1 2 3 4 5 6 7 8 myproject/ ├── src/ │ └── main/ │ └── java/ │ └── ch/ │ └── itninja/ │ └── math/ │ └── Calculator.java src/main/java ist eine weitverbreitete Abmachung, welche hilft, dass Tools wie Maven mit dem Quellcode arbeiten können. Java selbst kann auch ohne diese Verzeichnisse kompilieren.\nPackages weitergeben und wiederverwenden Wenn du ein Package (z. B. eine Hilfsklasse) in einem anderen Projekt verwenden willst, hast du zwei Möglichkeiten:\nDu erstellst eine .jar-Datei deines Projekts (Java-Archiv) Du kopierst den Sourcecode (temporär, nicht empfohlen) Ein .jar kannst du in anderen Projekten verwenden, z. B. per “Add as Library”.\nDu kannst eine .jar auch weitergeben:\nals lokale Datei oder ZIP über ein gemeinsames Netzlaufwerk über einen lokalen Maven-Server (kommt später) Wenn du IntelliJ nutzt und eine .jar-Datei ohne Maven erzeugen und in ein anderes Projekt einbinden willst, lernst du im Modul Packages lokal verwenden wie das geht. API und JavaDoc Ein API (Application Programming Interface) ist die Schnittstelle deines Codes nach außen.\nZur API gehören alle public-Klassen und public-Methoden, die von anderen Packages oder Projekten aus genutzt werden können.\nWichtig:\nAlles, was public ist, wird Teil deiner API – egal, ob du es als „offizielle Schnittstelle“ geplant hast oder nicht.\nDarum solltest du public nur dort verwenden, wo die Nutzung von außen gewollt und langfristig stabil sein soll.\nDamit andere deinen Code verstehen und richtig verwenden können, solltest du deine API mit JavaDoc gut dokumentieren:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 /** * Diese Klasse stellt mathematische Hilfsmethoden bereit. */ public class Calculator { /** * Addiert zwei Zahlen. * @param a erste Zahl * @param b zweite Zahl * @return Summe von a und b */ public static int add(int a, int b) { return a + b; } } JavaDoc-Kommentare beginnen mit /** ... */ und können von Tools wie IntelliJ oder javadoc automatisch in eine HTML-Dokumentation umgewandelt werden.\nDenke daran:\nprivate, (default) und protected sind nicht Teil der öffentlichen API.\nNur public definiert, was andere Packages direkt nutzen können.\nÜberlege gut, bevor du etwas public machst, denn jede API-Änderung kann externe Nutzer deines Codes betreffen.\nWas bedeutet static? Vielleicht hast du bereits public static void main(String[] args) gesehen.\nstatic bedeutet:\nDiese Methode oder Variable gehört nicht zu einem Objekt, sondern direkt zur Klasse. Du kannst sie verwenden, ohne zuerst etwas zu erzeugen. Das ist praktisch für Hilfsmethoden, z. B. Math.max(5, 10) oder System.out.println(...).\nIn Grundlagenprojekten verwendest du fast nur static Methoden. Die Objekt Orientiert Programmier Welt (OOP-Welt) kommt später.\nKlassen, die nur static-Methoden enthalten, nennt man Utility-Klassen oder Helper-Klassen. Damit programmiert man eher modular und weniger objektorientiert.\nDer Begriff Modul ist in Java jedoch offiziell vergeben: Ab Java 9 steht er für ein Set von Packages mit eigener module-info.java.\nDaher spricht man bei dieser Art der modularen Strukturierung besser von Utility-Klassen und nicht von Modulen.\nJetzt bist du dran. Löse bitte die folgenden !*Aufgaben in den Labs. ","categories":"","description":"In diesem Modul lernst du, wie man Java-Packages strukturiert, importiert, wiederverwendet und weitergeben kann.\n","excerpt":"In diesem Modul lernst du, wie man Java-Packages strukturiert, …","ref":"/docs/02_java/03_java-grundlagen/12_packages/","tags":"","title":"Packages"},{"body":" Voraussetzung Du weisst was ein Package ist. Wir stellen dir bei den Übungen jeweils komplette Projekte zur Verfügung. Du musst grundsätzlich nur dort was anpassen, wo die folgende Kommentarzeile steht:\nKopieren // IT-Ninja: Füge hier Deinen Code ein: 1 // IT-Ninja: Füge hier Deinen Code ein: Alles andere kannst du für den Moment ignorieren. Wir erklären dir die einzelnen Zeilen Schritt für Schritt in den Modulen.\nVorbereitungsarbeiten Drücke auf den Pfeil links um eine detaillierte Anleitung zu erhalten, wie Du den Quellcode auf deinem Rechner ablegen sollst.\nDiese Schritte musst du bei jeder Übung erneut machen. Jede Übung hat ein eigenes ZIP-File, welches du bei dir an die richtige Stelle kopieren musst. Die Anleitung zeigt dir ziemlich gut, wie das geht… Liess vor allem am Anfang die detaillierte Anleitung gut durch und befolge die Schritte exakt. Sie helfen dir, deinen Quellcode gut organisiert, strukturiert und sicher zu verwalten. Falls du die Anleitung schon auswendig kennst, findest du den Quellcode zur Übung direkt hier: Download | Online anschauen\nNeu bei it-ninja?\nDie Anleitung enthält einige Befehle und Fachbegriffe, die dir möglicherweise noch nichts sagen. Mach dir deswegen keine Sorgen – in den kommenden Modulen erklären wir dir alles Schritt für Schritt. Schon bald wirst auch du ein it-ninja sein. Um die folgenden Aufgaben erfolgreich umzusetzen, führe diese Schritte aus:\nBeim ersten Mal:\nIntelliJ IDEA installieren → !*IntelliJ IDEA einrichten Git-Repository einrichten → !*Persönliches Git-Repository Öffne eine !*CMD-Shell und wechsle ins Verzeichnis deines Git-Repositories:\nKopieren cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git status 1 2 cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git status Kopieren cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git status 1 2 cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git status Stelle sicher, dass alle Dateien im Git-Repository committed sind. Mit git status erhältst du eine Übersicht: Kopieren git status 1 git status Falls du bei diesem Befehl einen roten Text siehst, musst du zuerst die aktuellen Dateien sichern:\nKopieren git add . git commit -m \"[gescheiter Kommentar]\" 1 2 git add . git commit -m \"[gescheiter Kommentar]\" Erstelle oder wechsle in den Template Branch:\nBeim ersten Mal musst du einen Template Branch erstellen:\nKopieren git checkout -b \"templates\" 1 git checkout -b \"templates\" Falls er bereits existiert, kannst du einfach switchen:\nKopieren git switch \"templates\" 1 git switch \"templates\" Lade den Source-Code zu den Übungen herunter und entpacke ihn im Root-Verzeichnis deines lokalen Repositories:\n[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\nDen Source-Code findest du hier: Download | Online anschauen\nCommitte den originalen Source-Code, damit er sicher im Repository gespeichert ist:\nKopieren git add . git commit -m \"Add it-ninja_02_java_03_java-grundlagen_12_packages\" git push 1 2 3 git add . git commit -m \"Add it-ninja_02_java_03_java-grundlagen_12_packages\" git push Erstelle einen neuen Branch, um deine Lösung zu implementieren: Kopieren git checkout -b \"labs/it-ninja_02_java_03_java-grundlagen_12_packages\" 1 git checkout -b \"labs/it-ninja_02_java_03_java-grundlagen_12_packages\" Hier kannst du auch einen kürzeren Namen wählen. Verwende labs am Anfang des Branch-Namens für Branches, die deinen eigenen Code enthalten.\nStelle dir einen Branch vorerst als Ordner vor. Jeder Ordner enthält eine Version oder einen Stand von deinem Quellcode. Du kannst dann mit git zwischen diesen Ordern hin und her wechseln, sie vergleichen aber später auch zusammenführen.\nPro-Tipp:\nDu kannst jederzeit einen weiteren Branch erstellen – z. B. wenn du etwas ausprobieren möchtest. Alternativ kannst du auch in der Git-History einen alten Stand wiederherstellen, was aber weniger flexibel ist. Starte IntelliJ und öffne mit File → Open das Verzeichnis mit dem Source-Code. Du musst mit IntelliJ den Ordner suchen, welches einen Ordner src oder die Datei pom.xml enthält. Ansonsten wird IntelliJ Mühe haben, dir das Programm zu kompilieren. Wenn du alles korrekt gemacht hast, findest du das Projekt hier:\nKopieren `[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\\02_java\\03_java-grundlagen\\12_packages` 1 `[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\\02_java\\03_java-grundlagen\\12_packages` Kopieren `[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\\02_java/03_java-grundlagen/12_packages` 1 `[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\\02_java/03_java-grundlagen/12_packages` Falls du zum ersten Mal mit IntelliJ arbeitest, findest du !*hier eine Anleitung, wie man ein Programm startet. Um das Programm zu starten musst du jeweils die Datei Main.java öffenen. Dann sollte in IntelliJ oben rechts ein grünes Dreieck vorhanden sein, welches das Programm startet. Nun bist du bereit, die untenstehenden Aufgaben zu lösen.\nWenn du alle Änderungen gemacht hast und mit der Übung fertig bist, oder einen ‘Zwischenstand’ festhalten willst, führe die folgenden Befehle aus um das Repository auf dem Server zu speichern (von wo du es geklont hast):\nKopieren cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git add --all git commit -m \"Kurzer Kommentar\" 1 2 3 cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git add --all git commit -m \"Kurzer Kommentar\" Kopieren cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git add . git commit -m \"Kurzer Kommentar\" 1 2 3 cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git add . git commit -m \"Kurzer Kommentar\" Wenn du deine Änderungen auf dem Git-Server sichern willst, musst du das mit einem push machen.\nBeim ersten mal musst du git noch mitteilen, wie der Branch auf dem Git-Server heissen soll:\nKopieren git push --set-upstream origin labs/it-ninja_02_java_03_java-grundlagen_12_packages 1 git push --set-upstream origin labs/it-ninja_02_java_03_java-grundlagen_12_packages Bei weiteren pushes wird es dann einfacher:\nKopieren git push 1 git push Die meisten Übungen sind professionell strukturiert – so wie in echten Softwareprojekten. Zu gutem Code gehören auch Tests, die sicherstellen, dass dein Code wie erwartet funktioniert. Sofern nicht anders erwähnt, kannst du mit folgendem Befehl im Root-Verzeichnis des Projekts (dort, wo sich auch die pom.xml befindet) überprüfen, ob du die Aufgabe korrekt gelöst hast:\n1 mvn test Viel Erfolg!\nAufgabe 1 Erstelle ein eigenes Package, welches dir ein paar mathematische Hilfsfunktionen zur Verfügung stellt:\nKleinerer Wert von 2 Integerzahlen Grösserer Wert von 2 Integerzahlen Absoluter Wert von einer Integerzahl Abstand von 2 Integerzahlen Achtung: Das von dir erstellte Package darf nicht ch.itninja.labs enthalten.\nPasse main an, damit deine Package verwendet wird. Erstelle ein paar Aufrufe und gib das Resultat auf der Konsole aus.\nIm zur Übung gehörendem Source kannst Du die Änderung an folgender Stelle machen:\nsrc\\main\\java\\ch\\itninja\\labs\\Main.java:\n1 2 3 4 public static void main(String[] args) { // IT-Ninja: rufe hier deine Methoden auf und gib die Resultate auf der Konsole aus } Aufgabe 2 Erstelle ein weiteres Package im gleichen Projekt, welches einen Zähler verwaltet. Der Zähler ist statisch und der Datentyp soll int sein. Der Zähler kann mit folgenden Methoden verändert werden:\nIncrement -\u003e Zähler um eins erhöhen Decrement -\u003e Zähler um eins reduzieren Add -\u003e Wert zu Zähler hinzufügen Subtract -\u003e Wert vom Zähler abziehen. Reset -\u003e Wert vom Zähler auf 0 setzen. Bei allen Operationen darf der Zähler den Bereich 0..1000 nicht verlassen. Würde bei einer Operation der Zähler den Bereich verlassen, wird er auf die Grenze des Bereichs gesetzt (limitiert).\nAchtung: Das von dir erstellte Package darf nicht ch.itninja.labs enthalten.\nPasse main an, damit deine Package verwendet wird. Erstelle ein paar Aufrufe und gib das Resultat auf der Konsole aus.\nAufgabe 3 **Zusätzliche Vorbereitung: ** Erstelle 2 Kopien des IntelliJ-Projekts. Kopiere dazu den Ordner welcher das pom.xml beinhaltet. Normalerweise sollte der Ordner 12_packages heissen und die Kopie zum Beispiel 12_packages.create und 12_packages.use. Passe die beiden Projekte so an, dass du mit dem Projekt 12_packages.create ein Java Package erstellst und dieses im Projekt 12_packages.use verwendest.\nEs wird erwartet, dass dein Package JavaDoc beinhaltet.\nAm Ende der Übung soll deine Ausgabe auf der Konsole bei Aufgabe 3 dasselbe ausgeben, was auch bei Aufgabe 1 und 2 ausgegeben wird.\n","categories":"","description":"Mit diesen Übungen kannst du dein Wissen zum Thema Packages vertiefen.\n","excerpt":"Mit diesen Übungen kannst du dein Wissen zum Thema Packages vertiefen. …","ref":"/labs/02_java/03_java-grundlagen/12_packages/","tags":"","title":"Java Exercises - Packages"},{"body":"","categories":"","description":"Modul #J8 - Spring Framework\n","excerpt":"Modul #J8 - Spring Framework\n","ref":"/docs/02_java/12_spring-framework/","tags":"","title":"Spring Framework"},{"body":"","categories":"","description":"Modul #J8 - Spring Framework\n","excerpt":"Modul #J8 - Spring Framework\n","ref":"/de/docs/02_java/12_spring-framework/","tags":"","title":"Spring Framework"},{"body":"","categories":"","description":"Exercises zu den Modulen #J8 - Spring und Spring Boot\n","excerpt":"Exercises zu den Modulen #J8 - Spring und Spring Boot\n","ref":"/labs/02_java/12_spring-framework/","tags":"","title":"Spring Framework"},{"body":"","categories":"","description":"Exercises zu den Modulen #J8 - Spring und Spring Boot\n","excerpt":"Exercises zu den Modulen #J8 - Spring und Spring Boot\n","ref":"/de/labs/02_java/12_spring-framework/","tags":"","title":"Spring Framework"},{"body":"Ziele Ich kann eine Möglichkeit aufzeigen, wie Felder nie überschrieben werden dürfen. Ich kann erklären, wie die Objekte von eigenen Klassen “unveränderlich” gemacht werden können. Ich kann auswendig erklären, welche Vorteile unveränderliche Klassen bieten. Felder unveränderlich machen Manchmal wirst du in Klassen Felder haben, die sich nie ändern werden - und auch nie sollten. Damit sich ein Feld nicht ändern kann, kannst du das Keyword final vor dem Datentyp angeben. Im folgenden Beispiel haben wir eine Klasse für einen Schweizer Staatsbürger, der einen Namen besitzen kann, der sich ändern kann. Zusätzlich müssen alle BürgerInnen eine AHV-Nummer (socialSecurityNumber), die sich (im Normalfall) nie ändert:\n1 2 3 4 5 6 7 8 9 public class SwissCitizen { private String name; private final String socialSecurityNumber; // AHV-Nummer public SwissCitizen(String name, String socialSecurityNumber) { this.name = name; this.socialSecurityNumber = socialSecurityNumber; } } Das final-Keyword bewirkt bei Instanzvariablen, dass sie nur einmal gesetzt werden können - entweder direkt oder spätestens im Konstruktor.\nNachher darf der Wert dieser Variable nicht mehr geändert werden, wieso folgender Code zu einem Kompilierfehler führt:\n1 2 3 4 5 6 7 8 9 10 11 public class SwissCitizen { ... public static void main(String[] args) { var person = new SwissCitizen(\"Hans-Ruede Meier\", \"756.1234.5678.90\"); // Hans-Ruedi hat geheiratet :D person.name = \"Hans-Ruedi Müller\"; person.socialSecurityNumber = \"756.0000.0000.01\"; // Gibt einen Compiler-Fehler } } Somit bietet das final-Keyword eine gute Möglichkeit an zu garantieren, dass ein Feld nicht später aus Versehen verändert wird.\nVeränderungen an Objekten - Immutable \u0026 mutable objects In der Programmierung gibt es ein wichtiges Konzept, das “Unveränderlichkeit” (Englisch: Immutability) genannt wird. Unveränderlichkeit bedeutet, dass ein Objekt nie seine Werte ändert. Wenn wir diese Werte ändern wollen, müssen wir ein neues Objekt erstellen.\nDas klassische Beispiel ist die Klasse String. Zeichenfolgen sind unveränderliche Objekte, sodass alle String-Operationen einen neuen String erzeugen.\n1 2 3 4 5 6 String alice = \"alice\"; alice.toUpperCase(); System.out.println(alice); // Output: alice --\u003e unveränderlich! String aliceCapitalLetters = alice.toUpperCase(); System.out.println(aliceCapitalLetters); // Output: ALICE Unsere neudefinierte Klasse Color hingegen ist nicht unveränderlich:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Color { private int red; private int green; private int blue; public Color(int red, int green, int blue) { this.red = red; this.green = green; this.blue = blue; } @Override public String toString() { return String.format(\"Color(%s, %s, %s)\", red, green, blue); } // Konstanten(?), damit Farben beim Namen genannt werden können: public static final Color RED = new Color(255, 0, 0); public static final Color GREEN = new Color(0, 255, 0); public static final Color BLUE = new Color(255, 0, 255); public static final Color YELLOW = new Color(255, 255, 0); public static final Color WHITE = new Color(255, 255, 255); public static final Color BLACK = new Color(0, 0, 0); } Da Color in diesem Beispiel veränderlich ist, kann jedes Feld verändert werden:\n1 2 3 4 5 6 7 8 9 10 11 // print color red: Color color = Color.RED; System.out.println(\"Rot:\\t\" + color); // Print white: color.green = 255; color.blue = 255; System.out.println(\"Weiss:\\t\" + color); // print red again: System.out.println(\"Rot:\\t\" + Color.RED); Die letzte Zeile führt zu dieser Ausgabe, die falsch ist:\n1 Rot: Color(255, 255, 255) Das Problem mit unserem Code ist, dass wir erwarten, dass Color.RED dem Wert von new Color(255, 0, 0) entspricht, da die statische Variable sogar mit final deklariert wurde. Und das würde auch jede(r) andere Entwickler(in) erwarten!\nDas Problem war, dass wir immer wieder auf das gleiche Objekt zugegriffen haben, das wir auch bearbeitet haben, was dieses Diagramm verdeutlicht:\nMöchten wir, dass Color diesen Erwartungen gerecht wird, dann müssen wir sie unveränderlich (immutable) machen. Dann ist jedes ihrer Felder unveränderlich. Dies geschieht mit dem final-Key-Word vor allen Feldern innerhalb der Klasse:\n1 2 3 4 5 6 7 public class Color { private final int red; private final int green; private final int blue; ... } Nun führt die Anweisung color.green = 255; zu einem Fehler, weil das Feld green unveränderlich ist und deshalb nicht geändert werden kann.\nDer Vorteil von diesem Code ist nun, dass Color.RED immer einen Wert zurückgibt, der wirklich die Farbe Rot repräsentiert.\nEin zweites Beispiel Oft lohnt es sich, Klassen die dafür verwendet werden, um Daten in einem Objekt zwischen zu speichern, immutable zu definieren. Nehmen wir hierzu wieder die Klasse Color, die genau diesem Zweck dient.\nIm ersten Beispiel gehen wir davon aus, dass Color veränderlich ist (also keine final-Keywords vor den Instanzvariablen). Hier bieten wir eine statische Methode an, die aus einer Farbe einen Grau-Wert produziert:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public static Color convertToGrayScale(Color color) { // Helligkeit berechnen (Grün wird als Heller empfunden als z.B. Blau): int luminance = (int) ( 0.299 * color.red + 0.587 * color.green + 0.114 * color.blue); // Bei einem Grauton haben alle Farbwerte den gleichen Wert: color.red = luminance; color.green = luminance; color.blue = luminance; return color; } public static void main(String[] args) { Color color = Color.RED; Color grayScale = convertToGrayScale(color); System.out.println(\"Rot:\\t\" + color); System.out.println(\"Gray Scale:\\t\" + grayScale); } Logischer Weise führt dieser Code zu einer unerwünschten Ausgabe in der Konsole. Offensichtlich ist der Fehler in der convertToGrayScale(...)-Methode, wo wir die Instanz-Variablen vom Parameter überschreiben, was wir nicht sollten. Obwohl dieses Beispiel den Fehler sehr offensichtlich begeht, ist das ein Fehler, der sehr oft passiert:\nMethoden, die einen neuen Wert berechnen oder holen (get), sollten im Normalfall bestehende Werte nicht bearbeiten. Sehr oft führt das dazu, dass Dinge passieren, die man als Aufrufer nicht erwartet und man muss Fehler an unerwarteten Stellen suchen, weil die Methode mehr macht als zu erwarten ist.\nSolche convert...- bzw. get...-Methoden sollten einen neuen Wert zurückgeben, anstatt einen bestehenden zu verändern. Ein Indiz dafür, dass dieses Prinzip verletzt wird, ist oft, dass eine get...()-Methode den Rückgabe-Wert void besitzt (hier nicht der Fall).\nOft ist es nicht so offensichtlich wie hier. Schreibt man die Klassen von Anfang an immutable, so ist der Code ganz generell viel weniger Fehler anfällig (erst recht, wenn der Code parallel auf mehreren Prozessoren läuft) und das Vorgehen führt dazu, dass zukünftiger Code automatisch lesbarer (aka “schöner”) wird - was dir in Zukunft sicherlich viel Zeit ersparen wird.\nDie gleiche convertToGrayScale(color) müsste mit der immutable-Version der Klasse umgeschrieben werden, damit kein Kompilierfehler auftritt (und nun funktioniert sie wie erwartet):\n1 2 3 4 5 6 7 public static Color convertToGrayScale(Color color) { // Helligkeit berechnen (Grün wird als Heller empfunden als z.B. Blau): int luminance = (int) (0.299 * color.red + 0.587 * color.green + 0.114 * color.blue); // Bei einem Grauton haben alle Farbwerte den gleichen Wert: return new Color(luminance, luminance, luminance); } Der Hauptunterschied mit immutable Klassen ist daher, dass so viel öfters neue Instanzen generiert werden.\nJetzt bist du dran. Löse alle verbleibenden OOP Aufgaben.\n","categories":"","description":"Modul #J2\n","excerpt":"Modul #J2\n","ref":"/docs/02_java/04_java-oop/12_mutable-objects/","tags":"","title":"Veränderbarkeit"},{"body":"Ziele Ich kann eine Möglichkeit aufzeigen, wie Felder nie überschrieben werden dürfen. Ich kann erklären, wie die Objekte von eigenen Klassen “unveränderlich” gemacht werden können. Ich kann auswendig erklären, welche Vorteile unveränderliche Klassen bieten. Felder unveränderlich machen Manchmal wirst du in Klassen Felder haben, die sich nie ändern werden - und auch nie sollten. Damit sich ein Feld nicht ändern kann, kannst du das Keyword final vor dem Datentyp angeben. Im folgenden Beispiel haben wir eine Klasse für einen Schweizer Staatsbürger, der einen Namen besitzen kann, der sich ändern kann. Zusätzlich müssen alle BürgerInnen eine AHV-Nummer (socialSecurityNumber), die sich (im Normalfall) nie ändert:\n1 2 3 4 5 6 7 8 9 public class SwissCitizen { private String name; private final String socialSecurityNumber; // AHV-Nummer public SwissCitizen(String name, String socialSecurityNumber) { this.name = name; this.socialSecurityNumber = socialSecurityNumber; } } Das final-Keyword bewirkt bei Instanzvariablen, dass sie nur einmal gesetzt werden können - entweder direkt oder spätestens im Konstruktor.\nNachher darf der Wert dieser Variable nicht mehr geändert werden, wieso folgender Code zu einem Kompilierfehler führt:\n1 2 3 4 5 6 7 8 9 10 11 public class SwissCitizen { ... public static void main(String[] args) { var person = new SwissCitizen(\"Hans-Ruede Meier\", \"756.1234.5678.90\"); // Hans-Ruedi hat geheiratet :D person.name = \"Hans-Ruedi Müller\"; person.socialSecurityNumber = \"756.0000.0000.01\"; // Gibt einen Compiler-Fehler } } Somit bietet das final-Keyword eine gute Möglichkeit an zu garantieren, dass ein Feld nicht später aus Versehen verändert wird.\nVeränderungen an Objekten - Immutable \u0026 mutable objects In der Programmierung gibt es ein wichtiges Konzept, das “Unveränderlichkeit” (Englisch: Immutability) genannt wird. Unveränderlichkeit bedeutet, dass ein Objekt nie seine Werte ändert. Wenn wir diese Werte ändern wollen, müssen wir ein neues Objekt erstellen.\nDas klassische Beispiel ist die Klasse String. Zeichenfolgen sind unveränderliche Objekte, sodass alle String-Operationen einen neuen String erzeugen.\n1 2 3 4 5 6 String alice = \"alice\"; alice.toUpperCase(); System.out.println(alice); // Output: alice --\u003e unveränderlich! String aliceCapitalLetters = alice.toUpperCase(); System.out.println(aliceCapitalLetters); // Output: ALICE Unsere neudefinierte Klasse Color hingegen ist nicht unveränderlich:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Color { private int red; private int green; private int blue; public Color(int red, int green, int blue) { this.red = red; this.green = green; this.blue = blue; } @Override public String toString() { return String.format(\"Color(%s, %s, %s)\", red, green, blue); } // Konstanten(?), damit Farben beim Namen genannt werden können: public static final Color RED = new Color(255, 0, 0); public static final Color GREEN = new Color(0, 255, 0); public static final Color BLUE = new Color(255, 0, 255); public static final Color YELLOW = new Color(255, 255, 0); public static final Color WHITE = new Color(255, 255, 255); public static final Color BLACK = new Color(0, 0, 0); } Da Color in diesem Beispiel veränderlich ist, kann jedes Feld verändert werden:\n1 2 3 4 5 6 7 8 9 10 11 // print color red: Color color = Color.RED; System.out.println(\"Rot:\\t\" + color); // Print white: color.green = 255; color.blue = 255; System.out.println(\"Weiss:\\t\" + color); // print red again: System.out.println(\"Rot:\\t\" + Color.RED); Die letzte Zeile führt zu dieser Ausgabe, die falsch ist:\n1 Rot: Color(255, 255, 255) Das Problem mit unserem Code ist, dass wir erwarten, dass Color.RED dem Wert von new Color(255, 0, 0) entspricht, da die statische Variable sogar mit final deklariert wurde. Und das würde auch jede(r) andere Entwickler(in) erwarten!\nDas Problem war, dass wir immer wieder auf das gleiche Objekt zugegriffen haben, das wir auch bearbeitet haben, was dieses Diagramm verdeutlicht:\nMöchten wir, dass Color diesen Erwartungen gerecht wird, dann müssen wir sie unveränderlich (immutable) machen. Dann ist jedes ihrer Felder unveränderlich. Dies geschieht mit dem final-Key-Word vor allen Feldern innerhalb der Klasse:\n1 2 3 4 5 6 7 public class Color { private final int red; private final int green; private final int blue; ... } Nun führt die Anweisung color.green = 255; zu einem Fehler, weil das Feld green unveränderlich ist und deshalb nicht geändert werden kann.\nDer Vorteil von diesem Code ist nun, dass Color.RED immer einen Wert zurückgibt, der wirklich die Farbe Rot repräsentiert.\nEin zweites Beispiel Oft lohnt es sich, Klassen die dafür verwendet werden, um Daten in einem Objekt zwischen zu speichern, immutable zu definieren. Nehmen wir hierzu wieder die Klasse Color, die genau diesem Zweck dient.\nIm ersten Beispiel gehen wir davon aus, dass Color veränderlich ist (also keine final-Keywords vor den Instanzvariablen). Hier bieten wir eine statische Methode an, die aus einer Farbe einen Grau-Wert produziert:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public static Color convertToGrayScale(Color color) { // Helligkeit berechnen (Grün wird als Heller empfunden als z.B. Blau): int luminance = (int) ( 0.299 * color.red + 0.587 * color.green + 0.114 * color.blue); // Bei einem Grauton haben alle Farbwerte den gleichen Wert: color.red = luminance; color.green = luminance; color.blue = luminance; return color; } public static void main(String[] args) { Color color = Color.RED; Color grayScale = convertToGrayScale(color); System.out.println(\"Rot:\\t\" + color); System.out.println(\"Gray Scale:\\t\" + grayScale); } Logischer Weise führt dieser Code zu einer unerwünschten Ausgabe in der Konsole. Offensichtlich ist der Fehler in der convertToGrayScale(...)-Methode, wo wir die Instanz-Variablen vom Parameter überschreiben, was wir nicht sollten. Obwohl dieses Beispiel den Fehler sehr offensichtlich begeht, ist das ein Fehler, der sehr oft passiert:\nMethoden, die einen neuen Wert berechnen oder holen (get), sollten im Normalfall bestehende Werte nicht bearbeiten. Sehr oft führt das dazu, dass Dinge passieren, die man als Aufrufer nicht erwartet und man muss Fehler an unerwarteten Stellen suchen, weil die Methode mehr macht als zu erwarten ist.\nSolche convert...- bzw. get...-Methoden sollten einen neuen Wert zurückgeben, anstatt einen bestehenden zu verändern. Ein Indiz dafür, dass dieses Prinzip verletzt wird, ist oft, dass eine get...()-Methode den Rückgabe-Wert void besitzt (hier nicht der Fall).\nOft ist es nicht so offensichtlich wie hier. Schreibt man die Klassen von Anfang an immutable, so ist der Code ganz generell viel weniger Fehler anfällig (erst recht, wenn der Code parallel auf mehreren Prozessoren läuft) und das Vorgehen führt dazu, dass zukünftiger Code automatisch lesbarer (aka “schöner”) wird - was dir in Zukunft sicherlich viel Zeit ersparen wird.\nDie gleiche convertToGrayScale(color) müsste mit der immutable-Version der Klasse umgeschrieben werden, damit kein Kompilierfehler auftritt (und nun funktioniert sie wie erwartet):\n1 2 3 4 5 6 7 public static Color convertToGrayScale(Color color) { // Helligkeit berechnen (Grün wird als Heller empfunden als z.B. Blau): int luminance = (int) (0.299 * color.red + 0.587 * color.green + 0.114 * color.blue); // Bei einem Grauton haben alle Farbwerte den gleichen Wert: return new Color(luminance, luminance, luminance); } Der Hauptunterschied mit immutable Klassen ist daher, dass so viel öfters neue Instanzen generiert werden.\nJetzt bist du dran. Löse alle verbleibenden OOP Aufgaben.\n","categories":"","description":"Modul #J2\n","excerpt":"Modul #J2\n","ref":"/de/docs/02_java/04_java-oop/12_mutable-objects/","tags":"","title":"Veränderbarkeit"},{"body":"Ziele Du weisst, was Routing in Angular ist. Du kannst Routing anwenden und weisst, wie man es einsetzt. Du kennst die verschiedenen Arten von Routen. Du weisst, was RouteGuards sind und kannst diese anwenden. Du kennst die Navigation Directive und kannst sie anwenden. Routing Der Angular Router ist ein leistungsstarker JavaScript-Router, der vom Angular Core Team erstellt und gewartet wird. Der Router wird über das Paket @angular/router installiert. Das Paket bietet eine vollständige Routing-Library inklusive:\nMehreren Router-Outlets Verschiedenen Strategien für Path-Matching Einem Einfachen Zugriff auf Route-Parameter und Route-Guards, um Components vor unbefugtem Zugriff zu schützen. Der Angular-Router ist ein zentraler Bestandteil der Angular-Plattform. Entwickler können damit Single Page Applications mit mehreren Views erstellen und zwischen diesen navigieren.\nRouter-Outlet Die Router-Library stellt uns die Router-Outlet Direktive zur Verfügung. In dieser Direktive fügt der Router den Component ein, der anhand der URL abgeglichen wird. Wir können in einer Angular-Applikation mehrere Outlets hinzufügen, um erweiterte Routing-Szenarien zu implementieren. Für den Anfang werden wir uns jedoch auf einen einzelnen Outlet beschränken.\n1 2 3 4 \u003c!--app.component.html--\u003e \u003cdiv\u003e \u003crouter-outlet\u003e\u003c/router-outlet\u003e \u003c/div\u003e Routen und Pfade Routen sind Objekte, die aus mindestens einem Pfad- und einem Component-Attribut bestehen. Das Pfad-Attribut bezieht sich auf den Teil der URL, der eine eindeutige View festlegt, die angezeigt werden soll. Das Component-Attribut bezieht sich auf den Angular-Component, der dem Pfad zugeordnet wird.\nJede Route ordnet einem Component einen URL-Pfad zu.\nDer Router kann, basierend auf einer von uns bereitgestellten Routendefinition, den Benutzer zu einer bestimmten View navigieren.\nSchauen wir uns ein Beispiel einer Route an:\n1 2 3 4 5 6 7 8 import { Routes } from \"@angular/router\"; import { TriumphsComponent } from \"./components/triumphs/triumphs.component\"; import { WeaponComponent } from \"./components/weapon/weapon.component\"; const routes: Routes = [ { path: \"triumph\", component: TriumphsComponent }, { path: \"weapon\", component: WeaponComponent }, ]; Seit Angular 18 muss in der app.component.ts-Datei RouterOutlet in den imports hinzugefügt werden, da das Routing ansonsten nicht funktioniert.\n1 2 3 4 5 6 7 8 9 10 11 import { Component } from '@angular/core'; import { RouterOutlet } from '@angular/router'; @Component({ selector: 'app-root', standalone: true, imports: [RouterOutlet], providers: [], templateUrl: './app.component.html', styleUrl: './app.component.css' }) Falls diese Route so in der Router Konfiguration festgelegt wird, wird der Router den Component TriumphsComponent rendern, sobald die URL des Browsers /triumph beinhaltet.\nStandard Route Der Pfad kann auch leer sein. Dieser gibt den Standardpfad einer Applikation an und ist normalerweise auch der Startpunkt der Applikation.\nWichtig ist, dass die Route mit dem leeren Pfad vor anderen Routen definiert ist, da Angular die Routen in der Reihenfolge überprüft, in der sie definiert sind. Dadurch wird sichergestellt, dass die Standardroute für den leeren Pfad richtig erkannt wird.\nBeispiel:\n1 { path: '', component: GreetingComponent } Wildcard Route Der Pfad kann einen Wildcard String (**) enthalten. Der Router wählt diese Route aus, wenn die angeforderte URL keinen Pfaden der definierten Routen entspricht. Wenn keine Übereinstimmung gefunden wird, kann dies zum Anzeigen einer “Nicht gefunden”-View oder zum Umleiten zu einer bestimmten View verwendet werden.\nEs ist wichtig sicherzustellen, dass die Catch-All-Route am Ende der Route-Konfiguration platziert wird, da Angular die Routen in der Reihenfolge überprüft, in der sie definiert sind. Dadurch wird sichergestellt, dass zuerst nach übereinstimmenden Pfaden gesucht wird, bevor die Standardroute zum Einsatz kommt.\nBeispiel:\n1 { path: '**', component: NotFoundComponent } dynamische Route Routen können mit Variablen verwendet werden, um dynamische Routen zu ermöglichen. Man kann zum Beispiel den Platzhalter :id in der Routendefinition verwenden, um eine Variable (hier eine ID) in den Pfad einzufügen. Diese Variable kann dann von dem entsprechenden Component abgerufen werden.\n1 { path: 'triumph/:id', component: TriumphsComponent }, Um die Variable im Component zu verwenden, musst du den ActivatedRoute-Service von Angular importieren und im Component verwenden.\nHier ist ein Beispiel, wie man die ID-Variable im UserComponent abrufen kann:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import { Component } from \"@angular/core\"; import { ActivatedRoute } from \"@angular/router\"; @Component({ // .. }) export class TriumphsComponent { // .. id: string = \"\"; constructor(private route: ActivatedRoute) { const idParam = this.route.snapshot.paramMap.get(\"id\"); this.id = idParam ? idParam : \"\"; } } Wichtig ist, dass der String innerhalb des this.route.snapshot.paramMap.get(''); gleich geschrieben ist wie die Variable, welche man im path der Route gegeben hat. Das beduetet, dass man beliebige Variablen setzen kann und nicht nur “id” wie im Beispiel.\nRoute Guards Ein Route Guard ist ein Feature des Angular Routers, mit der wir Logik ausführen können, wenn eine Route angefordert wird. Es wird häufig verwendet, um zu überprüfen, ob ein Benutzer angemeldet ist und über die nötigen Berechtigungen verfügt, bevor er zugreifen kann. Somit können wir also dem Benutzer den Zugriff auf die Route ermöglichen oder verweigern.\nFür den Route Guard müssen wir das CanActivateFn-Interface implementieren, welches im @angular/router Paket verfügbar ist. Die canActivateFn() Methode des Interfaces enthält die Logik, um den Zugriff auf die Route zuzulassen oder zu verweigern.\nBeispielsweise ermöglicht folgender Guard immer den Zugriff auf eine Route, wenn im WeaponService die Methode getWeapons() keine Waffe zurückliefert:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import { ActivatedRouteSnapshot, CanActivateFn, RouterStateSnapshot, } from \"@angular/router\"; import { inject } from \"@angular/core\"; import { WeaponService } from \"../services/weapon.service\"; export const WeaponGuard: CanActivateFn = ( route: ActivatedRouteSnapshot, state: RouterStateSnapshot, ): boolean =\u003e { return inject(WeaponService).getWeapons().length === 0; }; return inject(WeaponService) in Angular bedeutet, dass die Instanz des WeaponService mithilfe der inject-Funktion abgerufen wird. Diese Vorgehensweise wird typischerweise in Szenarien angewendet, in denen die Dependency Injection nicht direkt im Konstruktor verfügbar ist.\nEine Route können wir nun anhand dieses Guards schützen, indem wir das “canActivate”-Attribut des Pfades benutzen:\n1 { path: \"weapon\", canActivate: [WeaponGuard], component: WeaponComponent } Wichtig Wenn man nun auf der Webseite auf die Route navigieren möchte, wird folgender Error in der Konsole erscheinen: NullInjectorError: No provider for Component!.\nWenn in diesem Fall ein Guard einen Component verwenden möchte, muss dieser als Abhängigkeit im Guard aufgelöst werden können. Dies kann durch die Verwendung von Dependency Injection gemacht werden.\nDie Providers in Angular dienen dazu, Dependency Injection zu konfigurieren, indem sie angeben, welche Objekte (Services, Components, etc.) zur Verfügung gestellt werden und wie sie instanziiert werden sollen. Wenn ein Component oder ein Service als Provider registriert ist, kann darauf zugegriffen werden, indem es als Parameter in den Konstruktor von anderen Components, Services oder Guards eingefügt wird.\nEs ist wichtig zu beachten, dass das Registrieren eines Components als Provider in einem Module nicht bedeutet, dass der Component überall automatisch erzeugt wird. Es bedeutet lediglich, dass der Component im Dependency Injection-System verfügbar ist und bei Bedarf instanziiert werden kann.\n1 2 3 4 5 6 7 8 import { WeaponComponent } from \"./components/weapon/weapon.component\"; @NgModule({ // .. providers: [WeaponComponent], // .. }) export class AppModule {} Navigation Directive Der Angular Router stellt die routerLink-Directive zum Erstellen von Navigationslinks bereit. Dieses Directive navigiert anhand des Pfads, welcher dem Component zugeordnet ist.\nBeispielsweise:\n1 \u003ca [routerLink]=\"'/weapon'\"\u003eWeapon\u003c/a\u003e Resolvers Ein Resolver ist ein Interface, welches von Klassen als Daten-Provider implementiert werden kann. Ein solcher Provider kann in zusammenarbeit mit dem Router verwendet werden, um Daten während der navigation zu liefern. Es gibt in jedem Resolver eine resolve()-Methode. Der Router wartet jeweils, bis die Daten geliefert sind, bevor die Route aktiviert wird. Nachfolgend ein Beispiel für einen Resolver:\n1 2 3 4 5 6 interface Resolve\u003cT\u003e { resolve( route: ActivatedRouteSnapshot, state: RouterStateSnapshot, ): MaybeAsync\u003cT | RedirectCommand\u003e; } Genauere Infos zu Resolvern findest du in der Angular-Dokumentation: Resolvers\n","categories":"","description":"Modul #F6 - Angular - Routing\n","excerpt":"Modul #F6 - Angular - Routing\n","ref":"/docs/03_web/06_angular/02_12_angular_routing/","tags":"","title":"Routing"},{"body":"Ziele Du weisst, was Routing in Angular ist. Du kannst Routing anwenden und weisst, wie man es einsetzt. Du kennst die verschiedenen Arten von Routen. Du weisst, was RouteGuards sind und kannst diese anwenden. Du kennst die Navigation Directive und kannst sie anwenden. Routing Der Angular Router ist ein leistungsstarker JavaScript-Router, der vom Angular Core Team erstellt und gewartet wird. Der Router wird über das Paket @angular/router installiert. Das Paket bietet eine vollständige Routing-Library inklusive:\nMehreren Router-Outlets Verschiedenen Strategien für Path-Matching Einem Einfachen Zugriff auf Route-Parameter und Route-Guards, um Components vor unbefugtem Zugriff zu schützen. Der Angular-Router ist ein zentraler Bestandteil der Angular-Plattform. Entwickler können damit Single Page Applications mit mehreren Views erstellen und zwischen diesen navigieren.\nRouter-Outlet Die Router-Library stellt uns die Router-Outlet Direktive zur Verfügung. In dieser Direktive fügt der Router den Component ein, der anhand der URL abgeglichen wird. Wir können in einer Angular-Applikation mehrere Outlets hinzufügen, um erweiterte Routing-Szenarien zu implementieren. Für den Anfang werden wir uns jedoch auf einen einzelnen Outlet beschränken.\n1 2 3 4 \u003c!--app.component.html--\u003e \u003cdiv\u003e \u003crouter-outlet\u003e\u003c/router-outlet\u003e \u003c/div\u003e Routen und Pfade Routen sind Objekte, die aus mindestens einem Pfad- und einem Component-Attribut bestehen. Das Pfad-Attribut bezieht sich auf den Teil der URL, der eine eindeutige View festlegt, die angezeigt werden soll. Das Component-Attribut bezieht sich auf den Angular-Component, der dem Pfad zugeordnet wird.\nJede Route ordnet einem Component einen URL-Pfad zu.\nDer Router kann, basierend auf einer von uns bereitgestellten Routendefinition, den Benutzer zu einer bestimmten View navigieren.\nSchauen wir uns ein Beispiel einer Route an:\n1 2 3 4 5 6 7 8 import { Routes } from \"@angular/router\"; import { TriumphsComponent } from \"./components/triumphs/triumphs.component\"; import { WeaponComponent } from \"./components/weapon/weapon.component\"; const routes: Routes = [ { path: \"triumph\", component: TriumphsComponent }, { path: \"weapon\", component: WeaponComponent }, ]; Seit Angular 18 muss in der app.component.ts-Datei RouterOutlet in den imports hinzugefügt werden, da das Routing ansonsten nicht funktioniert.\n1 2 3 4 5 6 7 8 9 10 11 import { Component } from '@angular/core'; import { RouterOutlet } from '@angular/router'; @Component({ selector: 'app-root', standalone: true, imports: [RouterOutlet], providers: [], templateUrl: './app.component.html', styleUrl: './app.component.css' }) Falls diese Route so in der Router Konfiguration festgelegt wird, wird der Router den Component TriumphsComponent rendern, sobald die URL des Browsers /triumph beinhaltet.\nStandard Route Der Pfad kann auch leer sein. Dieser gibt den Standardpfad einer Applikation an und ist normalerweise auch der Startpunkt der Applikation.\nWichtig ist, dass die Route mit dem leeren Pfad vor anderen Routen definiert ist, da Angular die Routen in der Reihenfolge überprüft, in der sie definiert sind. Dadurch wird sichergestellt, dass die Standardroute für den leeren Pfad richtig erkannt wird.\nBeispiel:\n1 { path: '', component: GreetingComponent } Wildcard Route Der Pfad kann einen Wildcard String (**) enthalten. Der Router wählt diese Route aus, wenn die angeforderte URL keinen Pfaden der definierten Routen entspricht. Wenn keine Übereinstimmung gefunden wird, kann dies zum Anzeigen einer “Nicht gefunden”-View oder zum Umleiten zu einer bestimmten View verwendet werden.\nEs ist wichtig sicherzustellen, dass die Catch-All-Route am Ende der Route-Konfiguration platziert wird, da Angular die Routen in der Reihenfolge überprüft, in der sie definiert sind. Dadurch wird sichergestellt, dass zuerst nach übereinstimmenden Pfaden gesucht wird, bevor die Standardroute zum Einsatz kommt.\nBeispiel:\n1 { path: '**', component: NotFoundComponent } dynamische Route Routen können mit Variablen verwendet werden, um dynamische Routen zu ermöglichen. Man kann zum Beispiel den Platzhalter :id in der Routendefinition verwenden, um eine Variable (hier eine ID) in den Pfad einzufügen. Diese Variable kann dann von dem entsprechenden Component abgerufen werden.\n1 { path: 'triumph/:id', component: TriumphsComponent }, Um die Variable im Component zu verwenden, musst du den ActivatedRoute-Service von Angular importieren und im Component verwenden.\nHier ist ein Beispiel, wie man die ID-Variable im UserComponent abrufen kann:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import { Component } from \"@angular/core\"; import { ActivatedRoute } from \"@angular/router\"; @Component({ // .. }) export class TriumphsComponent { // .. id: string = \"\"; constructor(private route: ActivatedRoute) { const idParam = this.route.snapshot.paramMap.get(\"id\"); this.id = idParam ? idParam : \"\"; } } Wichtig ist, dass der String innerhalb des this.route.snapshot.paramMap.get(''); gleich geschrieben ist wie die Variable, welche man im path der Route gegeben hat. Das beduetet, dass man beliebige Variablen setzen kann und nicht nur “id” wie im Beispiel.\nRoute Guards Ein Route Guard ist ein Feature des Angular Routers, mit der wir Logik ausführen können, wenn eine Route angefordert wird. Es wird häufig verwendet, um zu überprüfen, ob ein Benutzer angemeldet ist und über die nötigen Berechtigungen verfügt, bevor er zugreifen kann. Somit können wir also dem Benutzer den Zugriff auf die Route ermöglichen oder verweigern.\nFür den Route Guard müssen wir das CanActivateFn-Interface implementieren, welches im @angular/router Paket verfügbar ist. Die canActivateFn() Methode des Interfaces enthält die Logik, um den Zugriff auf die Route zuzulassen oder zu verweigern.\nBeispielsweise ermöglicht folgender Guard immer den Zugriff auf eine Route, wenn im WeaponService die Methode getWeapons() keine Waffe zurückliefert:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import { ActivatedRouteSnapshot, CanActivateFn, RouterStateSnapshot, } from \"@angular/router\"; import { inject } from \"@angular/core\"; import { WeaponService } from \"../services/weapon.service\"; export const WeaponGuard: CanActivateFn = ( route: ActivatedRouteSnapshot, state: RouterStateSnapshot, ): boolean =\u003e { return inject(WeaponService).getWeapons().length === 0; }; return inject(WeaponService) in Angular bedeutet, dass die Instanz des WeaponService mithilfe der inject-Funktion abgerufen wird. Diese Vorgehensweise wird typischerweise in Szenarien angewendet, in denen die Dependency Injection nicht direkt im Konstruktor verfügbar ist.\nEine Route können wir nun anhand dieses Guards schützen, indem wir das “canActivate”-Attribut des Pfades benutzen:\n1 { path: \"weapon\", canActivate: [WeaponGuard], component: WeaponComponent } Wichtig Wenn man nun auf der Webseite auf die Route navigieren möchte, wird folgender Error in der Konsole erscheinen: NullInjectorError: No provider for Component!.\nWenn in diesem Fall ein Guard einen Component verwenden möchte, muss dieser als Abhängigkeit im Guard aufgelöst werden können. Dies kann durch die Verwendung von Dependency Injection gemacht werden.\nDie Providers in Angular dienen dazu, Dependency Injection zu konfigurieren, indem sie angeben, welche Objekte (Services, Components, etc.) zur Verfügung gestellt werden und wie sie instanziiert werden sollen. Wenn ein Component oder ein Service als Provider registriert ist, kann darauf zugegriffen werden, indem es als Parameter in den Konstruktor von anderen Components, Services oder Guards eingefügt wird.\nEs ist wichtig zu beachten, dass das Registrieren eines Components als Provider in einem Module nicht bedeutet, dass der Component überall automatisch erzeugt wird. Es bedeutet lediglich, dass der Component im Dependency Injection-System verfügbar ist und bei Bedarf instanziiert werden kann.\n1 2 3 4 5 6 7 8 import { WeaponComponent } from \"./components/weapon/weapon.component\"; @NgModule({ // .. providers: [WeaponComponent], // .. }) export class AppModule {} Navigation Directive Der Angular Router stellt die routerLink-Directive zum Erstellen von Navigationslinks bereit. Dieses Directive navigiert anhand des Pfads, welcher dem Component zugeordnet ist.\nBeispielsweise:\n1 \u003ca [routerLink]=\"'/weapon'\"\u003eWeapon\u003c/a\u003e Resolvers Ein Resolver ist ein Interface, welches von Klassen als Daten-Provider implementiert werden kann. Ein solcher Provider kann in zusammenarbeit mit dem Router verwendet werden, um Daten während der navigation zu liefern. Es gibt in jedem Resolver eine resolve()-Methode. Der Router wartet jeweils, bis die Daten geliefert sind, bevor die Route aktiviert wird. Nachfolgend ein Beispiel für einen Resolver:\n1 2 3 4 5 6 interface Resolve\u003cT\u003e { resolve( route: ActivatedRouteSnapshot, state: RouterStateSnapshot, ): MaybeAsync\u003cT | RedirectCommand\u003e; } Genauere Infos zu Resolvern findest du in der Angular-Dokumentation: Resolvers\n","categories":"","description":"Modul #F6 - Angular - Routing\n","excerpt":"Modul #F6 - Angular - Routing\n","ref":"/de/docs/03_web/06_angular/02_12_angular_routing/","tags":"","title":"Routing"},{"body":"Ziele Du kennst den Unterschied zwischen Maps und Sets. Du kannst Sets erstellen, bearbeiten und Daten aus diesen abrufen. Du kannst Set-Iteratoren erklären. Set Oft möchte man eine Liste haben, in der gegeben sein soll, dass jedes Element nur einmal vorkommen kann.\nGenau diesen Zweck erfüllt die Set-Datenstruktur.\n1 const set = new Set(); Wert hinzufügen Die add(value)-Methode fügt einen Wert zu einem Set hinzu.\nWenn der Wert bereits im Set vorkommt, wird der Wert kein weiteres Mal hinzugefügt, wie im folgenden Beispiel gezeigt wird:\n1 2 3 4 5 6 7 8 9 10 11 12 const set = new Set(); set.add(\"value1\"); set.add(\"value2\"); set.add(\"value3\"); console.log(set); // Set {'value1', 'value2', 'value3'} set.add(\"value2\"); set.add(\"value4\"); console.log(set); // Set {'value1', 'value2', 'value3', 'value4'} Wert löschen Die delete()-Methode löscht den angegebenen Wert aus dem Set, wenn dieser enthalten ist und gibt als Rückgabewert true aus, ansonsten false.\n1 2 3 4 5 6 7 8 const set = new Set(); set.add(\"value1\"); set.add(\"value2\"); set.add(\"value3\"); console.log(set.delete(\"value1\")); // true console.log(set.delete(\"value1\")); // false Prüfen, ob ein Wert vorhanden ist Die has()-Methode gibt zurück, ob der angegebene Value im Set enthalten ist oder nicht. Die Methode gibt true zurück, wenn der Value im Set vorhanden ist, andernfalls gibt sie false zurück.\n1 2 3 4 5 6 7 8 const set = new Set(); set.add(\"value1\"); set.add(\"value2\"); set.add(\"value3\"); console.log(set.has(\"value1\")); // true console.log(set.has(\"value4\")); // false Set zurücksetzen Die clear()-Methode löscht alle Elemente aus dem Set.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const set = new Set(); set.add(\"value1\"); set.add(\"value2\"); set.add(\"value3\"); console.log(set.has(\"value1\")); // true console.log(set.has(\"value2\")); // true console.log(set.has(\"value2\")); // true set.clear(); console.log(set.has(\"value1\")); // false console.log(set.has(\"value2\")); // false console.log(set.has(\"value3\")); // false Anzahl Elemente Die size()-Methode gibt die Anzahl der Elemente in einem Set zurück.\n1 2 3 4 5 6 7 8 9 10 11 const set = new Set(); set.add(\"value1\"); set.add(\"value2\"); set.add(\"value3\"); console.log(set.size); // 3 set.clear(); console.log(set.size); // 0 Set Iteratoren Im Set existieren im Grunde beinahe die gleichen Iteratoren wie bei einer Map. Jedoch gibt es bei keys() und entries() Unterschiede, welche nachfolgend genauer beschrieben werden.\nvalues() values() gibt einen Iterator zurück, der die Werte des Sets in der Reihenfolge des Einfügens zurückgibt:\n1 2 3 4 5 6 7 8 9 10 11 12 13 const set = new Set(); set.add(\"value1\"); set.add(\"value2\"); set.add(\"value3\"); for (const value of set.values()) { console.log(value); } // value1 // value2 // value3 keys() und entries() keys() gibt einen Iterator zurück, der dieselben Values wie der values()-Iterator zurück gibt. Der keys()-Iterator ist jedoch nur aus Gründen der Kompatibilität mit der Map-Datenstruktur verfügbar und existiert für Sets nur, weil Sets auf der gleichen Grundlage wie Maps implementiert sind.\nDasselbe gilt auch für die entries()-Methode.\n","categories":"","description":"Modul #F4 - JavaScript - Sets.\n","excerpt":"Modul #F4 - JavaScript - Sets.\n","ref":"/docs/03_web/03_javascript/13_sets/","tags":"","title":"Sets"},{"body":"Ziele Du kennst den Unterschied zwischen Maps und Sets. Du kannst Sets erstellen, bearbeiten und Daten aus diesen abrufen. Du kannst Set-Iteratoren erklären. Set Oft möchte man eine Liste haben, in der gegeben sein soll, dass jedes Element nur einmal vorkommen kann.\nGenau diesen Zweck erfüllt die Set-Datenstruktur.\n1 const set = new Set(); Wert hinzufügen Die add(value)-Methode fügt einen Wert zu einem Set hinzu.\nWenn der Wert bereits im Set vorkommt, wird der Wert kein weiteres Mal hinzugefügt, wie im folgenden Beispiel gezeigt wird:\n1 2 3 4 5 6 7 8 9 10 11 12 const set = new Set(); set.add(\"value1\"); set.add(\"value2\"); set.add(\"value3\"); console.log(set); // Set {'value1', 'value2', 'value3'} set.add(\"value2\"); set.add(\"value4\"); console.log(set); // Set {'value1', 'value2', 'value3', 'value4'} Wert löschen Die delete()-Methode löscht den angegebenen Wert aus dem Set, wenn dieser enthalten ist und gibt als Rückgabewert true aus, ansonsten false.\n1 2 3 4 5 6 7 8 const set = new Set(); set.add(\"value1\"); set.add(\"value2\"); set.add(\"value3\"); console.log(set.delete(\"value1\")); // true console.log(set.delete(\"value1\")); // false Prüfen, ob ein Wert vorhanden ist Die has()-Methode gibt zurück, ob der angegebene Value im Set enthalten ist oder nicht. Die Methode gibt true zurück, wenn der Value im Set vorhanden ist, andernfalls gibt sie false zurück.\n1 2 3 4 5 6 7 8 const set = new Set(); set.add(\"value1\"); set.add(\"value2\"); set.add(\"value3\"); console.log(set.has(\"value1\")); // true console.log(set.has(\"value4\")); // false Set zurücksetzen Die clear()-Methode löscht alle Elemente aus dem Set.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const set = new Set(); set.add(\"value1\"); set.add(\"value2\"); set.add(\"value3\"); console.log(set.has(\"value1\")); // true console.log(set.has(\"value2\")); // true console.log(set.has(\"value2\")); // true set.clear(); console.log(set.has(\"value1\")); // false console.log(set.has(\"value2\")); // false console.log(set.has(\"value3\")); // false Anzahl Elemente Die size()-Methode gibt die Anzahl der Elemente in einem Set zurück.\n1 2 3 4 5 6 7 8 9 10 11 const set = new Set(); set.add(\"value1\"); set.add(\"value2\"); set.add(\"value3\"); console.log(set.size); // 3 set.clear(); console.log(set.size); // 0 Set Iteratoren Im Set existieren im Grunde beinahe die gleichen Iteratoren wie bei einer Map. Jedoch gibt es bei keys() und entries() Unterschiede, welche nachfolgend genauer beschrieben werden.\nvalues() values() gibt einen Iterator zurück, der die Werte des Sets in der Reihenfolge des Einfügens zurückgibt:\n1 2 3 4 5 6 7 8 9 10 11 12 13 const set = new Set(); set.add(\"value1\"); set.add(\"value2\"); set.add(\"value3\"); for (const value of set.values()) { console.log(value); } // value1 // value2 // value3 keys() und entries() keys() gibt einen Iterator zurück, der dieselben Values wie der values()-Iterator zurück gibt. Der keys()-Iterator ist jedoch nur aus Gründen der Kompatibilität mit der Map-Datenstruktur verfügbar und existiert für Sets nur, weil Sets auf der gleichen Grundlage wie Maps implementiert sind.\nDasselbe gilt auch für die entries()-Methode.\n","categories":"","description":"Modul #F4 - JavaScript - Sets.\n","excerpt":"Modul #F4 - JavaScript - Sets.\n","ref":"/de/docs/03_web/03_javascript/13_sets/","tags":"","title":"Sets"},{"body":"Ziele Ich kenne die verschiedenen Familien der Schriftarten und kenne ihre Eigenheiten. Ich weiss, wie man verschiedene Schriftarten in CSS einbindet und verstehe die Bedeutung und den Nutzen von Fallback-Schriftarten. Ich kann CSS-Properties anwenden, um Text und Schriftarten zu stylen. Arten von Schriftarten Jeder Browser unterstützt mindestens die folgenden 5 Familien von Schriftarten:\nDie wichtigste Unterscheidung liegt zwischen Serif- und Sans-Serif-Schriftarten. Serif-Schriftarten haben Serifs (also dünne Linien auf den Buchstabenlinien). Eine detailliertere Beschreibung findest du hier: https://de.wikipedia.org/wiki/Serife\nSans-Serif-Schriftarten haben diese Serifs nicht.\nBei Monospace-Schriftarten beanspruchen alle Buchstaben genau gleich viel Platz. Ein bekanntes Beispiel hierfür ist Consolas. Diese Schriftarten werden oft für Code verwendet.\nKursive Schriftarten imitieren Handschrift.\nFantasy-Schriftarten werden oft für kreative Zwecke eingesetzt.\nWelche Schriftart tatsächlich im Browser angezeigt wird, hängt davon ab, welche Fonts auf dem jeweiligen System installiert sind. Unter Windows sind es für serifenlose Schriftarten meist Arial und Verdana, währen Linux Helvetica als Standard nutzt.\nSchriftarten in CSS Im CSS kannst du Schriftarten wie folgt einbinden:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 .p1 { font-family: \"Times New Roman\", Times, serif; } .p2 { font-family: Arial, Helvetica, sans-serif; } .p3 { font-family: \"Consolas\", monospace; } .p4 { font-family: \"Lucida Handwriting\", cursive; } .p5 { font-family: \"Comic Sans MS\", fantasy; } Als CSS-Property (=Eigenschaft) für das Ändern der Schriftart wird font-family verwendet. Dabei können mehrere Schriftarten übergeben werden, was aufgrund unterschiedlicher Browser-Kompatibilitäten empfohlen wird. Die erste Schriftart ist die wichtigste und wird, sofern möglich, auch immer verwendet. Sollte diese nicht geladen werden können, so wird die nächste Schriftart verwendet. Als Fallback für den Fall, dass keine der angegebenen Schriftarten geladen werden kann, kann man serif, sans-serif, monospace, cursive oder fantasy verwenden.\nWeitere Informationen darüber findest du auf dieser Seite: https://www.w3schools.com/css/css_font.asp\nWeitere Font-Eigenschaften Text kann auf viele weitere Arten gestylt werden:\nCSS-Property Code Beschreibung Beispiel color color: blue Schriftfarbe sample Text\nbackground-color background-color: red Hintergrundfarbe (~Anstreichen) sample Text\nfont-size font-size: 26px Schriftgrösse sample Text\nfont-weight font-weight: bold Schriftgrösse sample Text\ntext-align text-align: center Einen Text zentrieren sample Text\nAuftrag Im Rahmen des Auftrags zu den Semantic-Tags hast du ein HTML-Dokument erstellt.\nVersuche alle auf dieser Seite beschriebenen Properties in deinem HTML-Dokument zu verwenden.\n","categories":"","description":"Modul #F3 - HTML und CSS - Typen von Schriftarten.\n","excerpt":"Modul #F3 - HTML und CSS - Typen von Schriftarten.\n","ref":"/docs/03_web/02_html_css/12_css-fonts/","tags":"","title":"Schriftarten"},{"body":"Ziele Ich kenne die verschiedenen Familien der Schriftarten und kenne ihre Eigenheiten. Ich weiss, wie man verschiedene Schriftarten in CSS einbindet und verstehe die Bedeutung und den Nutzen von Fallback-Schriftarten. Ich kann CSS-Properties anwenden, um Text und Schriftarten zu stylen. Arten von Schriftarten Jeder Browser unterstützt mindestens die folgenden 5 Familien von Schriftarten:\nDie wichtigste Unterscheidung liegt zwischen Serif- und Sans-Serif-Schriftarten. Serif-Schriftarten haben Serifs (also dünne Linien auf den Buchstabenlinien). Eine detailliertere Beschreibung findest du hier: https://de.wikipedia.org/wiki/Serife\nSans-Serif-Schriftarten haben diese Serifs nicht.\nBei Monospace-Schriftarten beanspruchen alle Buchstaben genau gleich viel Platz. Ein bekanntes Beispiel hierfür ist Consolas. Diese Schriftarten werden oft für Code verwendet.\nKursive Schriftarten imitieren Handschrift.\nFantasy-Schriftarten werden oft für kreative Zwecke eingesetzt.\nWelche Schriftart tatsächlich im Browser angezeigt wird, hängt davon ab, welche Fonts auf dem jeweiligen System installiert sind. Unter Windows sind es für serifenlose Schriftarten meist Arial und Verdana, währen Linux Helvetica als Standard nutzt.\nSchriftarten in CSS Im CSS kannst du Schriftarten wie folgt einbinden:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 .p1 { font-family: \"Times New Roman\", Times, serif; } .p2 { font-family: Arial, Helvetica, sans-serif; } .p3 { font-family: \"Consolas\", monospace; } .p4 { font-family: \"Lucida Handwriting\", cursive; } .p5 { font-family: \"Comic Sans MS\", fantasy; } Als CSS-Property (=Eigenschaft) für das Ändern der Schriftart wird font-family verwendet. Dabei können mehrere Schriftarten übergeben werden, was aufgrund unterschiedlicher Browser-Kompatibilitäten empfohlen wird. Die erste Schriftart ist die wichtigste und wird, sofern möglich, auch immer verwendet. Sollte diese nicht geladen werden können, so wird die nächste Schriftart verwendet. Als Fallback für den Fall, dass keine der angegebenen Schriftarten geladen werden kann, kann man serif, sans-serif, monospace, cursive oder fantasy verwenden.\nWeitere Informationen darüber findest du auf dieser Seite: https://www.w3schools.com/css/css_font.asp\nWeitere Font-Eigenschaften Text kann auf viele weitere Arten gestylt werden:\nCSS-Property Code Beschreibung Beispiel color color: blue Schriftfarbe sample Text\nbackground-color background-color: red Hintergrundfarbe (~Anstreichen) sample Text\nfont-size font-size: 26px Schriftgrösse sample Text\nfont-weight font-weight: bold Schriftgrösse sample Text\ntext-align text-align: center Einen Text zentrieren sample Text\nAuftrag Im Rahmen des Auftrags zu den Semantic-Tags hast du ein HTML-Dokument erstellt.\nVersuche alle auf dieser Seite beschriebenen Properties in deinem HTML-Dokument zu verwenden.\n","categories":"","description":"Modul #F3 - HTML und CSS - Typen von Schriftarten.\n","excerpt":"Modul #F3 - HTML und CSS - Typen von Schriftarten.\n","ref":"/de/docs/03_web/02_html_css/12_css-fonts/","tags":"","title":"Schriftarten"},{"body":"Ziele Ich kann String-Variablen deklarieren und initialisieren. Ich kann mehrere Strings miteinander in eine String-Variable verknüpfen (String Concatenation). Ich weiss, wann man einen StringBuilder verwenden sollte. Ich weiss, wie ich herausfinde, wie viele Zeichen eine String-Variable enthält. Ich weiss, dass String-Variablen nicht mit == sondern equals verglichen werden sollten. Ich kann von der Klasse String folgende Methode anwenden: toUpperCase(), toLowerCase(), charAt(...), indexOf(...), contains(...), substring(...), replace(...), split(...). String Eine Variable, die eine Zeichenkette repräsentiert, hat den Typ String und kann wie folgt initialisiert werden:\n1 String hello = \"Hello, Java\"; Diese Zeichenkette besteht aus 11 Zeichen, einschliesslich eines Leerzeichens. Wie wir hier ebenfalls sehen, müssen String-Literale von doppelten Anführungszeichen umgeben sein.\nEin Objekt des Typs String ist unveränderlich, die Werte innerhalb eines Strings können also nach dessen Erstellung nicht mehr verändert werden - der Variable kann aber ein neuer String-Wert zugewiesen werden:\n1 2 String hello = \"Hello, Java\"; hello = \"Hello, how are you?\"; Ausserdem ist es möglich, Strings mit mehreren Zeilen zu definieren, indem du einen String mit 3 \" beginnst und beendest und den String auf einer neuen Zeile beginnst:\n1 2 3 4 5 String poem = \"\"\" Strings dürfen mehreren Zeilen enthalten. So kannst du auch einfach eine Auflistung notieren: 1. Element 2. Element.\"\"\"; Strings verknüpfen (String Concatenation) Oft generierst du aus verschiedenen Variablen EINEN neuen String. Angenommen du hast eine Variable für “name” und “age” (Alter), dann kannst du wie folgt den String “Hallo {name}, du bist {age} Jahre alt.” generieren:\n1 2 3 4 String name = \"Leonardo\"; int age = 68; String greeting = \"Hallo \" + name +\", du bist \" + age + \" Jahre alt.\"; Alternativ kannst du statt die vielen + auch von der String.format()-Methode Gebrauch machen:\n1 String greeting = String.format( \"Hallo %s, du bist %d Jahre alt.\", name, age); Bei der String.format()-Methode übergeben wir dann die einzelnen Werte als Argumente. Beachte hierbei, dass %s für String- und %d für Integer-Werte verwendet werden.\nWenn Performance (also wie schnell, dass ein Programm läuft) eine übergeordnete Rolle einnimmt, dann wird die Methode mit einem StringBuilder bevorzugt:\n1 2 3 4 5 6 7 8 StringBuilder sb = new StringBuilder(); sb.append(\"Hallo \") .append(name) .append(\", du bist \") .append(age) .append(\" Jahre alt.\"); String greeting = sb.toString(); Hierbei musst du aber zuerst ein neues StringBuilder-Objekt erstellen. (Im Modul #J1 musst du solche Objekte noch nicht verstehen.) Anschliessend fügst du alle einzelnen Strings via .append(...) hinzu. Den gewünschten String kannst du dann mit .toString() generieren lassen.\nNeue Zeilen oder Tabs Beim Verknüpfen von Strings ist es oft praktisch, wenn man Zeilenumbrüche hinzufügen kann. Dies kannst du mit dem Character '\\n' (new line) tun:\n1 String greeting = \" name: \" + name + \", \\n nage: \" + age; Achtung, es gibt einen Unterschied zwischen Linux und Windows. Bei Windows hat ein Zeilenumbruch meistens die Zeichenfolge \\r\\n. Das führt oft zu Problemen, wenn zum Beispiel Konfigurationsdateien zwischen Linux und Windows Systemen getauscht werden. Das Gleiche ist auch mit Einrückungen (Tabulatoren) möglich mit dem Character '\\t' (tab):\n1 2 3 4 System.out.println(\"weapon name \\t ranges (m)\"); System.out.println(\"Shuriken \\t 5-10\"); System.out.println(\"Nunchaku \\t 1-1.5\"); System.out.println(\"Naginata \\t 3-4\"); Im Java fungiert das Zeichen \\ als “escape character”. Das bedeutet, dass spezielle Zeichen, die in einem String regulär nicht möglich wären, oft irgendwie mit einem \\ “escaped” werden. Neben der “New-Line” und dem “Tabulator” gibt es noch weitere, die oft verwendet werden:\n\\\\: Das \\-Zeichen (“Backslash) selber. \\\": Ein Anführungszeichen in einem String. Hier ein Beispiel, wie das Anführungszeichen und Backslash in einem String verwendet werden können:\n1 System.out.println(\"Die Datei \\\"Main.java\\\" befindet sich im Ordner C:\\\\Users\\\\Ninja\\\\Documents.\"); Methoden Nachfolgend sind einige der wichtigsten Methoden der Klasse String beschrieben. Alle Methoden sind detailliertet beschrieben unter java.lang.String zu finden.\nAnzahl Zeichen (String.length()) Bei Strings sind dessen Länge (also Anzahl Zeichen) oft von Interesse.\nIm folgenden Beispiel wird eine Nachricht ausgegeben, wenn eine Dummy-Usereingabe nicht mindestens 6 Zeichen enthält:\n1 2 3 4 String nickname = \"peter\"; if (nickname.length() \u003c 6) System.out.println(\"Der Nickname muss mindestens 6 Zeichen enthalten!\"); Strings miteinander vergleichen (String.equals(String)) Sehr oft wirst du überprüfen, ob ein String einem anderen entspricht. Dies kannst du mit der equals()-Methode tun:\n1 2 3 4 5 String a = \"hello\"; String b = \"hello\"; if (a.equals(b)) System.out.println(\"A ist gleich B.\"); Beachte hierbei, dass du zum Vergleichen von Strings in Java immer equals() nun nie == verwenden solltest, weil String kein primitiver Datentyp ist. == funktioniert in einfacheren Beispielen, führt aber in vielen Fällen trotzdem nicht zum gewünschten Resultat.\nIn Gross-/Kleinbuchstaben umwandeln In bestimmten Fällen soll die Gross- und Klein-Schreibung keine Rolle spielen. Nehmen wir hierfür noch einmal das Beispiel von der equals-Methode:\n1 2 3 4 String input = \"hello\"; if (input.toUpperCase().equals(\"HELLO\")) System.out.println(\"Der Input entspricht 'hello'.\"); Die relevanten String-Methoden bezüglich Gross- und Klein-Schreibung sind hierbei:\ntoUpperCase(): Gibt die Zeichenkette in Grossbuchstaben zurück. toLowerCase(): Gibt die Zeichenkette in Kleinbuchstaben zurück. Eine häufige Fehlerquelle ist es zu denken, dass eine dieser beiden Methoden den String verändert. Strings können sich aber nicht verändern. Deswegen geben diese beide Funktionen einen neuen String zurück, der Wert in der Variable bleibt also unverändert:\n1 2 3 4 5 6 7 8 String myString = \"Hello\"; myString.toUpperCase(); System.out.println(myString); // Ausgabe: // Hello Damit dieses Beispiel wie gewollt funktioniert, müsste es so geschrieben werden:\n1 2 3 4 5 6 7 8 String myString = \"Hello\"; myString = myString.toUpperCase(); System.out.println(myString); // Ausgabe: // HELLO Buchstaben an bestimmter Position ermitteln (String.charAt(int)) Wenn du z.B. alle Buchstaben in einem String durchgehen willst, dann musst du irgendwie den Buchstaben (char) an einer bestimmten Position des Strings ermitteln können. Dies kannst du mit charAt(int).\nDas folgende Beispiel liest den ersten Buchstaben aus einem String aus und gibt in aus:\n1 2 3 4 5 6 7 8 String word = \"Hello\"; char firstLetter = word.charAt(0); System.out.println(\"Erster Buchstabe: '\" + firstLetter + \"'\"); // Ausgabe: // Erster Buchstabe: 'H' Beachte, dass die Nummerierung in Java generell bei 0 beginnt. Für das erste Element übergibst du 0, für das zweite 1, für das vierte 3, für n das (n-1)-te, usw. Für charAt(...) bedeutet das, dass du wie folgt Buchstaben an bestimmten Positionen ermittelst:\n1 2 3 4 5 6 7 8 9 10 11 // erstes Zeichen: word.charAt(0); // zweites Zeichen: word.charAt(1); // viertes Zeichen: word.charAt(3); // letztes Zeichen: word.charAt(word.length() - 1); Nach Strings in Strings suchen (String.indexOf() und String.contains()) In seltenen Fällen möchtest du wissen, an welcher Position ein kleinerer String (oder char) in einem grösseren String vorkommt. Diese Information erhältst du mit indexOf(String/char).\nMöchtest du z.B. herausfinden, an welcher Stelle in einer Email-Adresse das “@” steht, dann könnte das wie folgt aussehen:\n1 2 3 4 5 String email = \"wallace@gmail.com\"; int indexOfAt = email.indexOf(\"@gmail\"); System.out.println(\"Der Teil vor dem @ ist \" + indexOfAt + \" Zeichen lang.\"); In diesem Fall gibt die Methode 7 zurück, weil sich das @ an der 8. Stelle befindet.\nAllgemein gibt indexOf(...) folgendes zurück:\nWenn der Suchbegriff vorkommt, dann die Position, wo der Suchbegriff zum ersten Mal beginnt. Wenn der Suchbegriff nie vorkommt: -1. Weil -1 zurückgeben wird, wenn der Suchbegriff nicht vorkommt, könnte diese Methode auch dafür verwendet werden, um herauszufinden, ob ein bestimmter Text in einem String vorkommt. Java bietet aber für diesen Fall bereits eine praktischere Methode:\n1 2 3 4 String email = \"wallace@gmail.com\"; if (email.contains(\"@gmail.\")) System.out.println(\"Diese Email-Adresse ist ein Gmail-Adresse.\"); Der Vorteil von der contains()-Methode ist, dass sie bereits einen boolean zurückgibt, was die if-Anweisung einfacher macht als das Überprüfen nach -1.\nText aus einem String ausschneiden Die substring()-Methode ist nützlich, wenn ein Text aus einem String ausgeschnitten werden soll.\nIn diesem Beispiel interessiert uns die Information nach dem “:”, welches sich immer an 6. Stelle befindet:\n1 2 3 4 5 6 7 8 String systemInfo = \"power: on\"; String status = systemInfo.substring(7); System.out.println(\"The system is \" + status + \".\"); // Ausgabe: // The system is on. In diesem Beispiel haben wir mit dem Schneiden an 7. Stelle begonnen. Wir können aber auch angeben, wie viele Zeichen ausgeschnitten werden sollen:\n1 2 3 4 5 6 7 8 String sentence = \"Today is Wed, 9th August 2023\"; String dayOfWeek = sentence.substring(9, 12); System.out.println(\"Day of Week: \" + dayOfWeek); // Ausgabe: // Day of Week: Wed In diesem Beispiel beginnt das Ausschneiden bei Index 9 und hört 1 Zeichen VOR Index 12 auf.\nIn all diesen Beispielen sind wir davon ausgegangen, dass wir wissen, ab welcher Stelle das Ausschneiden beginnt. Oft ist diese Stelle aber dynamisch. Hier kann daher eine Kombination mit indexOf() weiterhelfen:\n1 2 3 4 5 6 7 String dadJoke = \"Warum dürfen Geister keine Lügen erzählen? Weil man durch sie hindurchsieht!\"; String punchline = dadJoke.substring(dadJoke.indexOf(\"Weil \")); System.out.println(\"Pointe: \" + punchline); // Ausgabe: // Weil man durch sie hindurchsieht! Teile eines Strings ersetzen (String.replace()) Ein bestimmter Teil eines Strings kannst du mit replace ersetzen:\n1 2 3 4 5 String classicPhrase = \"To be or not to be, that's the question.\"; System.out.println(classicPhrase.replace(\"o be\", \"o beer\")); // Ausgabe: // To beer or not to beer, that's the question Beachte auch hier, dass replace den ursprünglichen String nicht verändert, sondern einen neuen zurückgibt.\nJetzt bist du dran. Löse bitte die folgenden !*Aufgaben in den Labs. ","categories":"","description":"In diesem Modul lernst du, wie man mit Strings Texte erstellen und verändern kann.\n","excerpt":"In diesem Modul lernst du, wie man mit Strings Texte erstellen und …","ref":"/docs/02_java/03_java-grundlagen/13_strings/","tags":"","title":"String"},{"body":" Voraussetzung Du weisst was ein String ist. Du kannst eigene Packages und Methoden erstellen Wir stellen dir bei den Übungen jeweils komplette Projekte zur Verfügung. Du musst grundsätzlich nur dort was anpassen, wo die folgende Kommentarzeile steht:\nKopieren // IT-Ninja: Füge hier Deinen Code ein: 1 // IT-Ninja: Füge hier Deinen Code ein: Alles andere kannst du für den Moment ignorieren. Wir erklären dir die einzelnen Zeilen Schritt für Schritt in den Modulen.\nVorbereitungsarbeiten Drücke auf den Pfeil links um eine detaillierte Anleitung zu erhalten, wie Du den Quellcode auf deinem Rechner ablegen sollst.\nDiese Schritte musst du bei jeder Übung erneut machen. Jede Übung hat ein eigenes ZIP-File, welches du bei dir an die richtige Stelle kopieren musst. Die Anleitung zeigt dir ziemlich gut, wie das geht… Liess vor allem am Anfang die detaillierte Anleitung gut durch und befolge die Schritte exakt. Sie helfen dir, deinen Quellcode gut organisiert, strukturiert und sicher zu verwalten. Falls du die Anleitung schon auswendig kennst, findest du den Quellcode zur Übung direkt hier: Download | Online anschauen\nNeu bei it-ninja?\nDie Anleitung enthält einige Befehle und Fachbegriffe, die dir möglicherweise noch nichts sagen. Mach dir deswegen keine Sorgen – in den kommenden Modulen erklären wir dir alles Schritt für Schritt. Schon bald wirst auch du ein it-ninja sein. Um die folgenden Aufgaben erfolgreich umzusetzen, führe diese Schritte aus:\nBeim ersten Mal:\nIntelliJ IDEA installieren → !*IntelliJ IDEA einrichten Git-Repository einrichten → !*Persönliches Git-Repository Öffne eine !*CMD-Shell und wechsle ins Verzeichnis deines Git-Repositories:\nKopieren cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git status 1 2 cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git status Kopieren cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git status 1 2 cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git status Stelle sicher, dass alle Dateien im Git-Repository committed sind. Mit git status erhältst du eine Übersicht: Kopieren git status 1 git status Falls du bei diesem Befehl einen roten Text siehst, musst du zuerst die aktuellen Dateien sichern:\nKopieren git add . git commit -m \"[gescheiter Kommentar]\" 1 2 git add . git commit -m \"[gescheiter Kommentar]\" Erstelle oder wechsle in den Template Branch:\nBeim ersten Mal musst du einen Template Branch erstellen:\nKopieren git checkout -b \"templates\" 1 git checkout -b \"templates\" Falls er bereits existiert, kannst du einfach switchen:\nKopieren git switch \"templates\" 1 git switch \"templates\" Lade den Source-Code zu den Übungen herunter und entpacke ihn im Root-Verzeichnis deines lokalen Repositories:\n[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\nDen Source-Code findest du hier: Download | Online anschauen\nCommitte den originalen Source-Code, damit er sicher im Repository gespeichert ist:\nKopieren git add . git commit -m \"Add it-ninja_02_java_03_java-grundlagen_13_strings\" git push 1 2 3 git add . git commit -m \"Add it-ninja_02_java_03_java-grundlagen_13_strings\" git push Erstelle einen neuen Branch, um deine Lösung zu implementieren: Kopieren git checkout -b \"labs/it-ninja_02_java_03_java-grundlagen_13_strings\" 1 git checkout -b \"labs/it-ninja_02_java_03_java-grundlagen_13_strings\" Hier kannst du auch einen kürzeren Namen wählen. Verwende labs am Anfang des Branch-Namens für Branches, die deinen eigenen Code enthalten.\nStelle dir einen Branch vorerst als Ordner vor. Jeder Ordner enthält eine Version oder einen Stand von deinem Quellcode. Du kannst dann mit git zwischen diesen Ordern hin und her wechseln, sie vergleichen aber später auch zusammenführen.\nPro-Tipp:\nDu kannst jederzeit einen weiteren Branch erstellen – z. B. wenn du etwas ausprobieren möchtest. Alternativ kannst du auch in der Git-History einen alten Stand wiederherstellen, was aber weniger flexibel ist. Starte IntelliJ und öffne mit File → Open das Verzeichnis mit dem Source-Code. Du musst mit IntelliJ den Ordner suchen, welches einen Ordner src oder die Datei pom.xml enthält. Ansonsten wird IntelliJ Mühe haben, dir das Programm zu kompilieren. Wenn du alles korrekt gemacht hast, findest du das Projekt hier:\nKopieren `[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\\02_java\\03_java-grundlagen\\13_strings` 1 `[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\\02_java\\03_java-grundlagen\\13_strings` Kopieren `[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\\02_java/03_java-grundlagen/13_strings` 1 `[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\\02_java/03_java-grundlagen/13_strings` Falls du zum ersten Mal mit IntelliJ arbeitest, findest du !*hier eine Anleitung, wie man ein Programm startet. Um das Programm zu starten musst du jeweils die Datei Main.java öffenen. Dann sollte in IntelliJ oben rechts ein grünes Dreieck vorhanden sein, welches das Programm startet. Nun bist du bereit, die untenstehenden Aufgaben zu lösen.\nWenn du alle Änderungen gemacht hast und mit der Übung fertig bist, oder einen ‘Zwischenstand’ festhalten willst, führe die folgenden Befehle aus um das Repository auf dem Server zu speichern (von wo du es geklont hast):\nKopieren cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git add --all git commit -m \"Kurzer Kommentar\" 1 2 3 cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git add --all git commit -m \"Kurzer Kommentar\" Kopieren cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git add . git commit -m \"Kurzer Kommentar\" 1 2 3 cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git add . git commit -m \"Kurzer Kommentar\" Wenn du deine Änderungen auf dem Git-Server sichern willst, musst du das mit einem push machen.\nBeim ersten mal musst du git noch mitteilen, wie der Branch auf dem Git-Server heissen soll:\nKopieren git push --set-upstream origin labs/it-ninja_02_java_03_java-grundlagen_13_strings 1 git push --set-upstream origin labs/it-ninja_02_java_03_java-grundlagen_13_strings Bei weiteren pushes wird es dann einfacher:\nKopieren git push 1 git push Die meisten Übungen sind professionell strukturiert – so wie in echten Softwareprojekten. Zu gutem Code gehören auch Tests, die sicherstellen, dass dein Code wie erwartet funktioniert. Sofern nicht anders erwähnt, kannst du mit folgendem Befehl im Root-Verzeichnis des Projekts (dort, wo sich auch die pom.xml befindet) überprüfen, ob du die Aufgabe korrekt gelöst hast:\n1 mvn test Viel Erfolg!\nAusgangslage Du hast den folgenden String:\n1 2 3 4 5 6 7 8 9 String poem = \"\"\" Ein Ninja leise wie der Wind, Seine Waffen stets geschwind. \"Shurikens\" fliegen, scharf und schnell, Klingen funkeln, furchterregend hell. \"Nunchakus\" wirbeln im Tanz, Mit jedem Schlag, im Vorteil er ganz. Seine Waffen, geheim und klug, Begleiten ihn bei jedem Zug.\"\"\"; Schreibe für jede Aufgabe eine eigene Methode, welche den String als Parameter nimmt. Passe die main(...) Methode an, um deinen Quellcode aufzurufen. Aufgabe 1 - Wörter zählen Gib in der Konsole die Anzahl Wörtern aus. Als Wort gilt alles was eine Folge von Buchstaben und Zahlen sind.\nDie Methode String.split(...) darf in dieser Aufgabe nicht verwendet werden. String.split(...) wird erst in einem späteren Modul behandelt. Im zur Übung gehörendem Source kannst Du die Änderung an folgender Stelle machen:\nsrc\\main\\java\\ch\\itninja\\labs\\Main.java:\n1 2 3 4 public static void main(String[] args) { // IT-Ninja: rufe hier deine Methoden auf und gib die Resultate auf der Konsole aus } Aufgabe 2 - Grossbuchstaben Gib den Text in Grossbuchstaben aus.\nIm zur Übung gehörendem Source kannst Du die Änderung an folgender Stelle machen:\nsrc\\main\\java\\ch\\itninja\\labs\\Main.java:\n1 2 3 4 public static void main(String[] args) { // IT-Ninja: rufe hier deine Methoden auf und gib die Resultate auf der Konsole aus } Aufgabe 3 - Punkte setzen Gib den Text so aus, dass jedes Leerzeichen mit einem Punkt ersetzt wurde.\nIm zur Übung gehörendem Source kannst Du die Änderung an folgender Stelle machen:\nsrc\\main\\java\\ch\\itninja\\labs\\Main.java:\n1 2 3 4 public static void main(String[] args) { // IT-Ninja: rufe hier deine Methoden auf und gib die Resultate auf der Konsole aus } Aufgabe 4 - Wort ausschneiden Schneide das Wort “Shurikens” aus. Ermittle hierfür die Position des Wortes anhand des “-Zeichens.\nHinweis: Die indexOf()-Methode bietet ein optionales Argument fromIndex an. Übergibst du die Position des ersten Anführungszeichen + 1, dann wird die Position des zweiten zurückgegeben.\nDie Methode String.replace(...) darf in dieser Aufgabe nicht verwendet werden. Im zur Übung gehörendem Source kannst Du die Änderung an folgender Stelle machen:\nsrc\\main\\java\\ch\\itninja\\labs\\Main.java:\n1 2 3 4 public static void main(String[] args) { // IT-Ninja: rufe hier deine Methoden auf und gib die Resultate auf der Konsole aus } ","categories":"","description":"Mit diesen Übungen kannst du dein Wissen zum Thema Strings vertiefen.\n","excerpt":"Mit diesen Übungen kannst du dein Wissen zum Thema Strings vertiefen.\n","ref":"/labs/02_java/03_java-grundlagen/13_strings/","tags":"","title":"Java Exercises - Strings"},{"body":"Ziele Du weisst, was Server Side Rendering ist und welche Vorteile dieses bietet. Du weisst, was Static Site Generation ist und welche Vorteile diese bietet. Du kennst das Konzept der Hydration und weisst, wie man diese für ein Angular-Projekt aktiviert. Server Side Rendering (SSR) Das serverseitige Rendering (SSR) ist ein Prozess, bei dem Seiten einer Webseite auf dem Server gerendert werden, was zu einem anfänglichen HTML-Inhalt führt, der den anfänglichen Zustand der Seite enthält. Sobald der HTML-Inhalt an einen Browser übermittelt wird, initialisiert Angular die Anwendung und nutzt die im HTML enthaltenen Daten.\nDie Hauptvorteile von SSR im Vergleich zu clientseitigem Rendering (CSR) sind:\nVerbesserte Leistung: SSR kann die Leistung von Webanwendungen verbessern, indem es vollständig gerendertes HTML an den Client liefert, welches der Browser parsen und anzeigen kann, bevor er die JavaScript-Anwendung herunterlädt. Dies kann besonders vorteilhaft für Benutzer mit geringer Bandbreite oder mobilen Geräten sein. Verbesserte Core Web Vitals: SSR führt zu Leistungsverbesserungen, die mit Core Web Vitals (CWV)-Statistiken gemessen werden können, wie z. B. reduziertem First Contentful Paint (FCP) und Largest Contentful Paint (LCP) sowie Cumulative Layout Shift (CLS). Besseres SEO: SSR kann die Suchmaschinenoptimierung (SEO) von Webanwendungen verbessern, indem es es Suchmaschinen erleichtert, den Inhalt der Anwendung zu durchsuchen und zu indexieren. Seit Angular 17 muss man keine speziellen Schritte mehr durchführen, um das Server-Side-Rendering in seine Angular-Applikaton zu integrieren. Wird ein neues Angular-Projekt mit ng new \u003c\u003e generiert, wird seit Angular 17 direkt beim Generieren gefragt, ob SSR für das Projekt aktiviert werden soll.\nUm SSR zu einem bereits existierenden Angular-Projekt hinzuzufügen, kann man den folgenden Befehl ausführen:\n1 ng add @angular/ssr Diese Befehle erstellen und aktualisieren den Anwendungscode, um SSR zu aktivieren, und fügen dem Projekt strukturspezifische Dateien hinzu.\nProjektstruktur 1 2 3 4 5 6 my-app |-- server.ts # Anwendungsserver └── src |-- app | └── app.config.server.ts # Konfiguration für den Server └── main.server.ts # Haupt-Bootstrapping für den Anwendungsserver Static Site Generation (SSG) Prerendering, häufig als Static Site Generation (SSG) bezeichnet, stellt die Methode dar, bei der Seiten während des Build-Prozesses zu statischen HTML-Dateien gerendert werden.\nPrerendering behält die Leistungsvorteile des serverseitigen Renderings (SSR) bei, erreicht jedoch eine reduzierte Time to First Byte (TTFB), was letztendlich die Benutzererfahrung verbessert. Der wesentliche Unterschied liegt im Ansatz, dass Seiten als statischer Inhalt bereitgestellt werden und kein anfragebasiertes Rendern erfolgt.\nWenn die für das serverseitige Rendering erforderlichen Daten bei allen Benutzern konsistent bleiben, erweist sich die Strategie des Prerenderings als wertvolle Alternative. Anstatt Seiten dynamisch für jede Benutzeranfrage zu rendern, geht das Prerendering proaktiv vor und rendert sie im Voraus.\nInsofern ein Angular-Projekt mit SSR-Funktionalitäten erstellt wird oder SSR zu einem bestehenden Angular-Projekt hinzugefügt wird, wird auch automatisch SSG aktiviert. Es ist möglich, SSG je nach Wunsch ein- oder auszuschalten. Das lässt sich in der angular.json-Datei bewerkstelligen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \"architect\": { \"build\": { \"options\": { \"server\": \"src/main.server.ts\", //Mithilfe des \"prerender\"-Settings lässt sich SSG für das Projekt ein- oder ausschalten \"prerender\": false, \"ssr\": { \"entry\": \"server.ts\" } } } } } Es ist ebenfalls möglich, nur SSG ohne SSR zu verwenden. Die Konfiguration sieht dabei ähnlich aus wie beim Fall oben:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { \"architect\": { \"build\": { \"options\": { \"server\": \"src/main.server.ts\", \"prerender\": { \"routesFile\": \"prerender-routes.txt\" \"discoverRoutes\": false }, //Mithilfe des \"ssr\"-Settings lässt sich SSR für das Projekt ein- oder ausschalten \"ssr\": false } } } } Um zu prüfen, ob alles funktioniert wie gewünscht, kannst du das Projekt mit dem folgenden Befehl lokal builden.\n1 ng build Hydration Als Hydration beschreibt man den Vorgang, der die serverseitig gerenderte Anwendung auf dem Client wiederherstellt. Dazu gehört das Wiederverwenden der serverseitig gerenderten DOM-Strukturen, das Beibehalten des Anwendungszustands, das Übertragen von bereits vom Server abgerufenen Anwendungsdaten und andere Prozessen.\nDie Hydration verbessert die Leistung der Anwendung, indem zusätzliche Arbeit zur Neuerstellung von DOM-Knoten vermieden wird. Stattdessen versucht Angular, vorhandene DOM-Elemente zur Laufzeit mit der Anwendungsstruktur abzugleichen und verwendet DOM-Knoten wieder, wenn möglich. Dies führt zu einer Leistungsverbesserung, die anhand von Core Web Vitals (CWV)-Statistiken gemessen werden kann, z.B. der Reduzierung des First Input Delay (FID) und Largest Contentful Paint (LCP) sowie des Cumulative Layout Shift (CLS). Eine Verbesserung dieser Kennzahlen wirkt sich auch auf Aspekte wie die SEO-Leistung aus.\nOhne aktivierte Hydration werden serverseitig gerenderte Angular-Anwendungen die DOM der Anwendung zerstören und erneut rendern, was zu einem sichtbaren Flackern der Benutzeroberfläche führen kann. Dieses erneute Rendern kann sich negativ auf Core Web Vitals wie LCP auswirken und zu einem Layout-Shift führen. Durch Aktivieren der Hydration können die vorhandenen DOM-Elemente wiederverwendet werden, wodurch ein Flackern verhindert wird.\nWie man die Hydratisierung in Angular aktiviert Bevor man mit der Hydration beginnen kann, muss man eine serverseitig gerenderte (SSR) Anwendung besitzen. Sobald die Anwendung mit SSR zum Laufen gebracht wurde, kann die Hydration aktiviert werden. Indem die Hauptanwendungskomponente oder das Hauptmodul besucht wird und provideClientHydration von @angular/platform-browser importiert wird. Anschliessend fügt man diesen Provider zur Liste der Bootstrapping-Provider in der App hinzu.\n1 2 3 4 5 6 7 8 9 10 import { bootstrapApplication, provideClientHydration, } from '@angular/platform-browser'; ... bootstrapApplication(AppComponent, { providers: [provideClientHydration()] }); Alternativ, insofern man NgModules verwendet, fügt man provideClientHydration zur Provider-Liste im Root-App-Module hinzu.\n1 2 3 4 5 6 7 8 9 10 import { provideClientHydration } from \"@angular/platform-browser\"; import { NgModule } from \"@angular/core\"; @NgModule({ declarations: [AppComponent], exports: [AppComponent], bootstrap: [AppComponent], providers: [provideClientHydration()], }) export class AppModule {} WICHTIG: Es muss sichergestellt werden, dass der Aufruf von provideClientHydration() auch in einer Liste von Providern enthalten ist, die zum Bootstrappen einer Anwendung auf dem Server verwendet wird. In Anwendungen mit der standardmässigen Projektstruktur (generiert durch den Befehl ng new), sollte es ausreichen, den Aufruf im Root-App-Modul hinzuzufügen, da dieser vom Servermodul importiert wird. Wenn man eine benutzerdefinierte Konfiguration verwendet, sollte man den Aufruf von provideClientHydration() zur Provider-Liste in der Konfiguration zum Server-Bootstrapping hinzufügen.\n","categories":"","description":"Modul #F6 - Angular - Rendering in Angular\n","excerpt":"Modul #F6 - Angular - Rendering in Angular\n","ref":"/docs/03_web/06_angular/02_13_rendering/","tags":"","title":"Rendering"},{"body":"Ziele Du weisst, was Server Side Rendering ist und welche Vorteile dieses bietet. Du weisst, was Static Site Generation ist und welche Vorteile diese bietet. Du kennst das Konzept der Hydration und weisst, wie man diese für ein Angular-Projekt aktiviert. Server Side Rendering (SSR) Das serverseitige Rendering (SSR) ist ein Prozess, bei dem Seiten einer Webseite auf dem Server gerendert werden, was zu einem anfänglichen HTML-Inhalt führt, der den anfänglichen Zustand der Seite enthält. Sobald der HTML-Inhalt an einen Browser übermittelt wird, initialisiert Angular die Anwendung und nutzt die im HTML enthaltenen Daten.\nDie Hauptvorteile von SSR im Vergleich zu clientseitigem Rendering (CSR) sind:\nVerbesserte Leistung: SSR kann die Leistung von Webanwendungen verbessern, indem es vollständig gerendertes HTML an den Client liefert, welches der Browser parsen und anzeigen kann, bevor er die JavaScript-Anwendung herunterlädt. Dies kann besonders vorteilhaft für Benutzer mit geringer Bandbreite oder mobilen Geräten sein. Verbesserte Core Web Vitals: SSR führt zu Leistungsverbesserungen, die mit Core Web Vitals (CWV)-Statistiken gemessen werden können, wie z. B. reduziertem First Contentful Paint (FCP) und Largest Contentful Paint (LCP) sowie Cumulative Layout Shift (CLS). Besseres SEO: SSR kann die Suchmaschinenoptimierung (SEO) von Webanwendungen verbessern, indem es es Suchmaschinen erleichtert, den Inhalt der Anwendung zu durchsuchen und zu indexieren. Seit Angular 17 muss man keine speziellen Schritte mehr durchführen, um das Server-Side-Rendering in seine Angular-Applikaton zu integrieren. Wird ein neues Angular-Projekt mit ng new \u003c\u003e generiert, wird seit Angular 17 direkt beim Generieren gefragt, ob SSR für das Projekt aktiviert werden soll.\nUm SSR zu einem bereits existierenden Angular-Projekt hinzuzufügen, kann man den folgenden Befehl ausführen:\n1 ng add @angular/ssr Diese Befehle erstellen und aktualisieren den Anwendungscode, um SSR zu aktivieren, und fügen dem Projekt strukturspezifische Dateien hinzu.\nProjektstruktur 1 2 3 4 5 6 my-app |-- server.ts # Anwendungsserver └── src |-- app | └── app.config.server.ts # Konfiguration für den Server └── main.server.ts # Haupt-Bootstrapping für den Anwendungsserver Static Site Generation (SSG) Prerendering, häufig als Static Site Generation (SSG) bezeichnet, stellt die Methode dar, bei der Seiten während des Build-Prozesses zu statischen HTML-Dateien gerendert werden.\nPrerendering behält die Leistungsvorteile des serverseitigen Renderings (SSR) bei, erreicht jedoch eine reduzierte Time to First Byte (TTFB), was letztendlich die Benutzererfahrung verbessert. Der wesentliche Unterschied liegt im Ansatz, dass Seiten als statischer Inhalt bereitgestellt werden und kein anfragebasiertes Rendern erfolgt.\nWenn die für das serverseitige Rendering erforderlichen Daten bei allen Benutzern konsistent bleiben, erweist sich die Strategie des Prerenderings als wertvolle Alternative. Anstatt Seiten dynamisch für jede Benutzeranfrage zu rendern, geht das Prerendering proaktiv vor und rendert sie im Voraus.\nInsofern ein Angular-Projekt mit SSR-Funktionalitäten erstellt wird oder SSR zu einem bestehenden Angular-Projekt hinzugefügt wird, wird auch automatisch SSG aktiviert. Es ist möglich, SSG je nach Wunsch ein- oder auszuschalten. Das lässt sich in der angular.json-Datei bewerkstelligen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \"architect\": { \"build\": { \"options\": { \"server\": \"src/main.server.ts\", //Mithilfe des \"prerender\"-Settings lässt sich SSG für das Projekt ein- oder ausschalten \"prerender\": false, \"ssr\": { \"entry\": \"server.ts\" } } } } } Es ist ebenfalls möglich, nur SSG ohne SSR zu verwenden. Die Konfiguration sieht dabei ähnlich aus wie beim Fall oben:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { \"architect\": { \"build\": { \"options\": { \"server\": \"src/main.server.ts\", \"prerender\": { \"routesFile\": \"prerender-routes.txt\" \"discoverRoutes\": false }, //Mithilfe des \"ssr\"-Settings lässt sich SSR für das Projekt ein- oder ausschalten \"ssr\": false } } } } Um zu prüfen, ob alles funktioniert wie gewünscht, kannst du das Projekt mit dem folgenden Befehl lokal builden.\n1 ng build Hydration Als Hydration beschreibt man den Vorgang, der die serverseitig gerenderte Anwendung auf dem Client wiederherstellt. Dazu gehört das Wiederverwenden der serverseitig gerenderten DOM-Strukturen, das Beibehalten des Anwendungszustands, das Übertragen von bereits vom Server abgerufenen Anwendungsdaten und andere Prozessen.\nDie Hydration verbessert die Leistung der Anwendung, indem zusätzliche Arbeit zur Neuerstellung von DOM-Knoten vermieden wird. Stattdessen versucht Angular, vorhandene DOM-Elemente zur Laufzeit mit der Anwendungsstruktur abzugleichen und verwendet DOM-Knoten wieder, wenn möglich. Dies führt zu einer Leistungsverbesserung, die anhand von Core Web Vitals (CWV)-Statistiken gemessen werden kann, z.B. der Reduzierung des First Input Delay (FID) und Largest Contentful Paint (LCP) sowie des Cumulative Layout Shift (CLS). Eine Verbesserung dieser Kennzahlen wirkt sich auch auf Aspekte wie die SEO-Leistung aus.\nOhne aktivierte Hydration werden serverseitig gerenderte Angular-Anwendungen die DOM der Anwendung zerstören und erneut rendern, was zu einem sichtbaren Flackern der Benutzeroberfläche führen kann. Dieses erneute Rendern kann sich negativ auf Core Web Vitals wie LCP auswirken und zu einem Layout-Shift führen. Durch Aktivieren der Hydration können die vorhandenen DOM-Elemente wiederverwendet werden, wodurch ein Flackern verhindert wird.\nWie man die Hydratisierung in Angular aktiviert Bevor man mit der Hydration beginnen kann, muss man eine serverseitig gerenderte (SSR) Anwendung besitzen. Sobald die Anwendung mit SSR zum Laufen gebracht wurde, kann die Hydration aktiviert werden. Indem die Hauptanwendungskomponente oder das Hauptmodul besucht wird und provideClientHydration von @angular/platform-browser importiert wird. Anschliessend fügt man diesen Provider zur Liste der Bootstrapping-Provider in der App hinzu.\n1 2 3 4 5 6 7 8 9 10 import { bootstrapApplication, provideClientHydration, } from '@angular/platform-browser'; ... bootstrapApplication(AppComponent, { providers: [provideClientHydration()] }); Alternativ, insofern man NgModules verwendet, fügt man provideClientHydration zur Provider-Liste im Root-App-Module hinzu.\n1 2 3 4 5 6 7 8 9 10 import { provideClientHydration } from \"@angular/platform-browser\"; import { NgModule } from \"@angular/core\"; @NgModule({ declarations: [AppComponent], exports: [AppComponent], bootstrap: [AppComponent], providers: [provideClientHydration()], }) export class AppModule {} WICHTIG: Es muss sichergestellt werden, dass der Aufruf von provideClientHydration() auch in einer Liste von Providern enthalten ist, die zum Bootstrappen einer Anwendung auf dem Server verwendet wird. In Anwendungen mit der standardmässigen Projektstruktur (generiert durch den Befehl ng new), sollte es ausreichen, den Aufruf im Root-App-Modul hinzuzufügen, da dieser vom Servermodul importiert wird. Wenn man eine benutzerdefinierte Konfiguration verwendet, sollte man den Aufruf von provideClientHydration() zur Provider-Liste in der Konfiguration zum Server-Bootstrapping hinzufügen.\n","categories":"","description":"Modul #F6 - Angular - Rendering in Angular\n","excerpt":"Modul #F6 - Angular - Rendering in Angular\n","ref":"/de/docs/03_web/06_angular/02_13_rendering/","tags":"","title":"Rendering"},{"body":"Ziele Du weisst, was JSON ist und weisst, woraus JSON-Daten bestehen. Du weisst, wie geordnete Listen ist JSON dargestellt werden können. JSON (JavaScript Object Notation) JSON ist ein weit verbreitetes Datenformat zur Repräsentation strukturierter Informationen. Es basiert auf einer einfachen Syntax, die sowohl von Menschen als auch von Maschinen leicht verstanden werden kann. JSON-Daten bestehen aus Schlüssel-Wert-Paaren und geordneten Listen von Werten. Hier ist eine grundlegende Übersicht der JSON-Syntax:\nSchlüssel-Wert-Paare Ein JSON-Objekt besteht aus einer Sammlung von Schlüssel-Wert-Paaren. Ein Schlüssel ist eine Zeichenfolge (String), gefolgt von einem Doppelpunkt und einem zugehörigen Wert. Die Paare sind durch Kommas getrennt und in geschweiften Klammern eingeschlossen:\n1 2 3 4 5 { \"name\": \"John Doe\", \"age\": 30, \"city\": \"New York\" } Geordnete Listen In JSON können auch geordnete Listen von Werten dargestellt werden. Diese Listen sind durch eckige Klammern gekennzeichnet und die Werte sind durch Kommas getrennt:\n1 2 3 { \"fruits\": [\"apple\", \"banana\", \"orange\"] } Beispiel Hier ist ein einfaches Beispiel, das ein JSON-Objekt darstellt:\n1 2 3 4 5 6 { \"name\": \"Alice\", \"age\": 25, \"isStudent\": true, \"grades\": [95, 89, 78] } JSON wird häufig in der Webentwicklung, in APIs und beim Datenaustausch verwendet, da es leicht zu verarbeiten ist. Es ist eine effektive Möglichkeit, Daten in einer strukturierten Form zu speichern und zwischen verschiedenen Systemen auszutauschen.\n","categories":"","description":"Modul #F4 - JavaScript - JSON\n","excerpt":"Modul #F4 - JavaScript - JSON\n","ref":"/docs/03_web/03_javascript/14_json/","tags":"","title":"JSON"},{"body":"Ziele Du weisst, was JSON ist und weisst, woraus JSON-Daten bestehen. Du weisst, wie geordnete Listen ist JSON dargestellt werden können. JSON (JavaScript Object Notation) JSON ist ein weit verbreitetes Datenformat zur Repräsentation strukturierter Informationen. Es basiert auf einer einfachen Syntax, die sowohl von Menschen als auch von Maschinen leicht verstanden werden kann. JSON-Daten bestehen aus Schlüssel-Wert-Paaren und geordneten Listen von Werten. Hier ist eine grundlegende Übersicht der JSON-Syntax:\nSchlüssel-Wert-Paare Ein JSON-Objekt besteht aus einer Sammlung von Schlüssel-Wert-Paaren. Ein Schlüssel ist eine Zeichenfolge (String), gefolgt von einem Doppelpunkt und einem zugehörigen Wert. Die Paare sind durch Kommas getrennt und in geschweiften Klammern eingeschlossen:\n1 2 3 4 5 { \"name\": \"John Doe\", \"age\": 30, \"city\": \"New York\" } Geordnete Listen In JSON können auch geordnete Listen von Werten dargestellt werden. Diese Listen sind durch eckige Klammern gekennzeichnet und die Werte sind durch Kommas getrennt:\n1 2 3 { \"fruits\": [\"apple\", \"banana\", \"orange\"] } Beispiel Hier ist ein einfaches Beispiel, das ein JSON-Objekt darstellt:\n1 2 3 4 5 6 { \"name\": \"Alice\", \"age\": 25, \"isStudent\": true, \"grades\": [95, 89, 78] } JSON wird häufig in der Webentwicklung, in APIs und beim Datenaustausch verwendet, da es leicht zu verarbeiten ist. Es ist eine effektive Möglichkeit, Daten in einer strukturierten Form zu speichern und zwischen verschiedenen Systemen auszutauschen.\n","categories":"","description":"Modul #F4 - JavaScript - JSON\n","excerpt":"Modul #F4 - JavaScript - JSON\n","ref":"/de/docs/03_web/03_javascript/14_json/","tags":"","title":"JSON"},{"body":"Ziele Ich kenne die verschiedenen Möglichkeiten, Farben in CSS zu definieren. Ich verstehe die Unterschiede zwischen der Farbangabe über Namen, RGB und HEX in CSS. Ich kann Farben in CSS korrekt und gezielt einsetzen. Zuweisen von Farben Um einem Text eine Schriftfarbe zuzuweisen, kannst du das color-Attribut verwenden.\n1 2 3 4 span { /*font color:*/ color: orange; } Den Hintergrund von einem Element kann mit dem background-color-Attribut bestimmt werden.\n1 2 3 4 div { /*Color of the container*/ background-color: orange; } Arten von Farben In den oberen Beispielen wurde die Farbe mit dem Wort orange bestimmt. Es gibt aber viele Arten, diese Farbe zu übergeben:\nvia (vordefiniertem) Color-Name: orange via RGB-Angaben (Red-Green-Blue-Wert): rgb(255,165,0) via hexadezimalen Wert (HEX color): #ffa500 Es gibt noch weitere Möglichkeiten, Farben in CSS anzugeben. Diese findest du auf dieser Seite: https://www.w3schools.com/colors/default.asp\nJede dieser CSS-Zeilen setzt die Schriftfarbe jeweils auf Orange:\n1 2 3 4 5 .orange { color: orange; color: rgb(255, 165, 0); color: #ffa500; } Da diese Farbe in CSS bereits einen Namen hat (\"orange\"), wäre in diesem Fall die Angabe via Farbnamen empfehlenswert.\nObwohl die Angabe mit RGB in CSS ebenfalls möglich ist, sieht man in der Webentwicklung häufiger die hexadezimale Schreibweise.\nNachfolgend sind diese 3 Varianten genauer beschrieben.\nVia Color-Name Am besten lesbar ist die Angabe der Farben via Namen. Es werden mindestens 140 Farben mit Namen unterstützt. Diese Art der Farbangabe ist aber stark eingeschränkt, da man im Gegensatz zu RGB oder HEX keine Anpassungen an der Farbe vornehmen kann. Häufig verwendete Farben sind z.B.:\nblack white gray (American) oder grey (British), lightgray blue, lightblue cornflowerblue red orange yellow Hier findest du eine Liste der Farben: https://www.w3schools.com/colors/colors_names.asp\nvia RGB RGB steht für Rot, Grün und Blau. Bei der Angabe einer Farbe über RGB-Werte wird festgelegt, wie stark jede dieser drei Grundfarben vertreten ist. Der Wert 0 bedeutet, dass die aktuelle Farbe nicht präsent ist, während 255 eine vollständige Sättigung der jeweiligen Farbe darstellt, also die Farbe in voller Intensität angezeigt wird. Zusätzlich kann ein vierter Wert, der Alpha-Wert, angegeben werden, der die Transparenz der Farbe bestimmt. Der Alpha-Wert liegt zwischen 0 und 1, wobei 0 vollständige Transparenz (also unsichtbar) bedeutet und 1 vollständige Deckkraft (völlig undurchsichtig). Du kannst das als prozentuale Zahl betrachten: So entspricht 0,5 einem prozentualen Wert von 50%. Wenn kein Alpha-Wert angegeben wird, ist der Standardwert 1.\nFolgende RGB-Werte solltest du als Informatiker:in kennen:\nName RGB red rgb(255, 0, 0) green rgb(0, 255, 0) blue rgb(0, 0, 255) yellow rgb(255, 255, 0) white rgb(255, 255, 255) black rgb(0, 0, 0) In RGB (oder HEX) gibst du Farben an, die der Browser nicht per Namen kennt. Ein Beispiel hierfür wäre die Farbe ‘amber’, die es leider noch nicht in die offizielle Liste geschafft hat.\nMöchtest du herausfinden, wie der RGB- oder HEX-Wert einer Farbe ist, so kannst du dafür Online-Tools wie https://www.color-hex.com/color-names.html verwenden. Dort kannst du den Namen der Farbe eingeben und dann nachschauen, wie die Werte für diese Farben sind. Im Beispiel der Farbe ‘amber’ erhältst du folgende Werte:\nName RGB HEX amber rgb(255, 191, 0) #ffbf00 Das folgende Beispiel definiert einen schwarzen Hintergrund, der halbtransparent ist. Das hat den effekt, dass der darüberliegende Inhalt zwar noch sichtbar ist, aber verdunkelt wirkt.\n1 background-color: rgb(0, 0, 0, 128); via HEX color Am häufigsten werden in der Web-Entwicklung die Farben via Hex-Code angegeben, da sie mit der ausreichenden Erfahrung relativ einfach lesbar sind und eine praktisch endlose Range an Farben bieten.\nFarben in Hexadezimalen sind auch nach dem RGB-Konzept aufgebaut, wobei jeweils 2 Stellen des Codes eine Farbe ausmachen.\nKennen solltest du sicher:\nFarbe HEX color red #ff0000 oder #f00 grenn #00ff00 oder #0f0 blue #0000ff oder #00f yellow #ffff00 oder #ff0 white #ffffff oder #fff black #000000 oder #000 gray #808080 Wenn bei allen Farben die beiden Ziffern gleich sind, dann kann bei jeder Farbe jeweils die zweite Ziffer weggelassen werden (siehe Tabelle).\n1 background-color: #b2222280; /*dunkles Rot, zur Hälfte transparent*/ ","categories":"","description":"Modul #F3 - HTML und CSS - Arten, Farben anzugeben.\n","excerpt":"Modul #F3 - HTML und CSS - Arten, Farben anzugeben.\n","ref":"/docs/03_web/02_html_css/13_css-colors/","tags":"","title":"Farben"},{"body":"Ziele Ich kenne die verschiedenen Möglichkeiten, Farben in CSS zu definieren. Ich verstehe die Unterschiede zwischen der Farbangabe über Namen, RGB und HEX in CSS. Ich kann Farben in CSS korrekt und gezielt einsetzen. Zuweisen von Farben Um einem Text eine Schriftfarbe zuzuweisen, kannst du das color-Attribut verwenden.\n1 2 3 4 span { /*font color:*/ color: orange; } Den Hintergrund von einem Element kann mit dem background-color-Attribut bestimmt werden.\n1 2 3 4 div { /*Color of the container*/ background-color: orange; } Arten von Farben In den oberen Beispielen wurde die Farbe mit dem Wort orange bestimmt. Es gibt aber viele Arten, diese Farbe zu übergeben:\nvia (vordefiniertem) Color-Name: orange via RGB-Angaben (Red-Green-Blue-Wert): rgb(255,165,0) via hexadezimalen Wert (HEX color): #ffa500 Es gibt noch weitere Möglichkeiten, Farben in CSS anzugeben. Diese findest du auf dieser Seite: https://www.w3schools.com/colors/default.asp\nJede dieser CSS-Zeilen setzt die Schriftfarbe jeweils auf Orange:\n1 2 3 4 5 .orange { color: orange; color: rgb(255, 165, 0); color: #ffa500; } Da diese Farbe in CSS bereits einen Namen hat (\"orange\"), wäre in diesem Fall die Angabe via Farbnamen empfehlenswert.\nObwohl die Angabe mit RGB in CSS ebenfalls möglich ist, sieht man in der Webentwicklung häufiger die hexadezimale Schreibweise.\nNachfolgend sind diese 3 Varianten genauer beschrieben.\nVia Color-Name Am besten lesbar ist die Angabe der Farben via Namen. Es werden mindestens 140 Farben mit Namen unterstützt. Diese Art der Farbangabe ist aber stark eingeschränkt, da man im Gegensatz zu RGB oder HEX keine Anpassungen an der Farbe vornehmen kann. Häufig verwendete Farben sind z.B.:\nblack white gray (American) oder grey (British), lightgray blue, lightblue cornflowerblue red orange yellow Hier findest du eine Liste der Farben: https://www.w3schools.com/colors/colors_names.asp\nvia RGB RGB steht für Rot, Grün und Blau. Bei der Angabe einer Farbe über RGB-Werte wird festgelegt, wie stark jede dieser drei Grundfarben vertreten ist. Der Wert 0 bedeutet, dass die aktuelle Farbe nicht präsent ist, während 255 eine vollständige Sättigung der jeweiligen Farbe darstellt, also die Farbe in voller Intensität angezeigt wird. Zusätzlich kann ein vierter Wert, der Alpha-Wert, angegeben werden, der die Transparenz der Farbe bestimmt. Der Alpha-Wert liegt zwischen 0 und 1, wobei 0 vollständige Transparenz (also unsichtbar) bedeutet und 1 vollständige Deckkraft (völlig undurchsichtig). Du kannst das als prozentuale Zahl betrachten: So entspricht 0,5 einem prozentualen Wert von 50%. Wenn kein Alpha-Wert angegeben wird, ist der Standardwert 1.\nFolgende RGB-Werte solltest du als Informatiker:in kennen:\nName RGB red rgb(255, 0, 0) green rgb(0, 255, 0) blue rgb(0, 0, 255) yellow rgb(255, 255, 0) white rgb(255, 255, 255) black rgb(0, 0, 0) In RGB (oder HEX) gibst du Farben an, die der Browser nicht per Namen kennt. Ein Beispiel hierfür wäre die Farbe ‘amber’, die es leider noch nicht in die offizielle Liste geschafft hat.\nMöchtest du herausfinden, wie der RGB- oder HEX-Wert einer Farbe ist, so kannst du dafür Online-Tools wie https://www.color-hex.com/color-names.html verwenden. Dort kannst du den Namen der Farbe eingeben und dann nachschauen, wie die Werte für diese Farben sind. Im Beispiel der Farbe ‘amber’ erhältst du folgende Werte:\nName RGB HEX amber rgb(255, 191, 0) #ffbf00 Das folgende Beispiel definiert einen schwarzen Hintergrund, der halbtransparent ist. Das hat den effekt, dass der darüberliegende Inhalt zwar noch sichtbar ist, aber verdunkelt wirkt.\n1 background-color: rgb(0, 0, 0, 128); via HEX color Am häufigsten werden in der Web-Entwicklung die Farben via Hex-Code angegeben, da sie mit der ausreichenden Erfahrung relativ einfach lesbar sind und eine praktisch endlose Range an Farben bieten.\nFarben in Hexadezimalen sind auch nach dem RGB-Konzept aufgebaut, wobei jeweils 2 Stellen des Codes eine Farbe ausmachen.\nKennen solltest du sicher:\nFarbe HEX color red #ff0000 oder #f00 grenn #00ff00 oder #0f0 blue #0000ff oder #00f yellow #ffff00 oder #ff0 white #ffffff oder #fff black #000000 oder #000 gray #808080 Wenn bei allen Farben die beiden Ziffern gleich sind, dann kann bei jeder Farbe jeweils die zweite Ziffer weggelassen werden (siehe Tabelle).\n1 background-color: #b2222280; /*dunkles Rot, zur Hälfte transparent*/ ","categories":"","description":"Modul #F3 - HTML und CSS - Arten, Farben anzugeben.\n","excerpt":"Modul #F3 - HTML und CSS - Arten, Farben anzugeben.\n","ref":"/de/docs/03_web/02_html_css/13_css-colors/","tags":"","title":"Farben"},{"body":"Ziele Ich kann eine Eingabe von der Konsole lesen und in einer Variablen speichern. ⏱️ Geschätzte Lesezeit: 10 Minuten Scanner Um Benutzereingaben in Java vorzunehmen, kann die Scanner-Klasse verwendet werden. Dazu wird sie zuerst importiert und danach ein Objekt erstellt:\n1 2 3 4 5 6 7 8 9 10 import java.util.Scanner; public class TakeInput { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.println(\"Enter your name: \"); String name = scanner.nextLine(); System.out.println(\"Your name is: \" + name); } } Erklärung zum Code Zeile 1:\nDie Scanner-Klasse stammt aus dem Paket java.util. Damit sie im Programm verwendet werden kann, muss sie importiert werden.\nZeile 5:\nWir deklarieren eine Variable mit dem Datentyp Scanner und dem Namen scanner. Anschliessend erstellen wir ein neues Objekt, das den Eingabestream System.in (Tastatureingaben) nutzt.\nZeile 7:\nWir deklarieren eine Variable name vom Typ String. Ihr wird der Rückgabewert der Methode scanner.nextLine() zugewiesen.\nDiese Methode liest die gesamte Zeile ein, die der Benutzer in die Konsole eingibt, und liefert sie als String zurück, sobald Enter gedrückt wird.\nZahlen einlesen Häufig möchtest du Zahlen von der Konsole einlesen. Dafür bietet Scanner passende Methoden an:\n1 2 System.out.print(\"Enter an integer: \"); int number = scanner.nextInt(); Die Methode nextInt() liest die nächste Zahl und liefert sie als int zurück.\nWichtig:\nnextInt() hat eine Eigenheit: Das gedrückte Enter nach der Zahl wird nicht automatisch verarbeitet. Wenn du danach nextLine() aufrufst, bekommst du einen leeren String zurück. Um dieses Verhalten zu umgehen, rufst du nach nextInt() einfach ein zusätzliches nextLine() auf.\nFür die Labs und das Exam im Modul #J1 kannst du nextInt() gut verwenden. Spiele aber ruhig ein wenig damit, um die Eigenheiten selbst kennenzulernen.\n","categories":"","description":"In diesem Modul lernst du, wie man mit der Scanner-Klasse Eingaben von der Konsole liest und in Variablen speichert.\n","excerpt":"In diesem Modul lernst du, wie man mit der Scanner-Klasse Eingaben von …","ref":"/docs/02_java/03_java-grundlagen/14_scanner/","tags":"","title":"Scanner"},{"body":"Ziele Du weisst, wie man Web-Requests macht und die Antworten weiterverwenden kann. Webanfragen mit JavaScript Wenn du eine Webanwendung schreibst, dann muss deine Website (=Frontend) wahrscheinlich Daten von (d)einem Backend abfragen.\nIn den meisten Fällen werden hierfür HTTP(S)-Requests verwendet, die du bereits kennengelernt hast (REST API in Spring und HTML Forms).\nUm das einmal auszuprobieren, wollen wir testweise eine API anfragen, die als Antwort zufällige “Fakten” über Chuck Norris zurückschickt. Wenn wir diese URL im Browser per HTTP (GET) aufrufen, erhalten wir als Antwort einen Witz in Form eines JSON:\nGET https://api.chucknorris.io/jokes/random\n1 2 3 4 5 6 7 8 9 { \"categories\": [], \"created_at\": \"2020-01-05 13:42:20.262289\", \"icon_url\": \"https://assets.chucknorris.host/img/avatar/chuck-norris.png\", \"id\": \"6F3bv9fIRUGCPTcma6Je1w\", \"updated_at\": \"2020-01-05 13:42:20.262289\", \"url\": \"https://api.chucknorris.io/jokes/6F3bv9fIRUGCPTcma6Je1w\", \"value\": \"Albert Einstein's hair used to be neatly combed...until the day he met Chuck Norris.\" } Damit für dich das Vorgehen verständlicher ist, führen wir einmal Schritt für Schritt alles in der Browser-Konsole aus.\nDie Abfrage kannst du wie folgt manuell durchführen:\n1 fetch(\"https://api.chucknorris.io/jokes/random\", { method: \"get\" }); Du wirst sehen, dass dieser Funktionsaufruf ein Promise {\u003cpending\u003e} zurückgibt (Promises sind im Kapitel JS_Async zu finden). Wir sehen, dass die Anfrage noch nicht beendet ist (pending = anstehend). Dieses Promise-Objekt wird die Antwort enthalten, sobald die Antwort verfügbar ist. Da wir sowieso erst weiterfahren möchten, wenn die Antwort bereit ist, interessieren wir uns noch nicht für das Promise. Daher können wir mit der Fortsetzung des Scripts solange warten, bis wir die Antwort hätten. Das können wir wie folgt machen:\n1 await fetch(\"https://api.chucknorris.io/jokes/random\", { method: \"get\" }); Das await-Keyword führt dazu, dass das Script erst weiter durchläuft, wenn die Antwort angekommen ist. Zusätzlich wird die Antwort automatisch aus dem Promise-Objekt entpackt, womit wir direkt ein Objekt vom Typ Response erhalten. In diesem Objekt sind mehrere wichtige Informationen enthalten, beispielsweise, ob die Request überhaupt erfolgreich war (ok: true), wie der HTTP-Statuscode aussieht und so weiter. Zu beachten ist, dass body im unteren Beispiel als ReadableStream definiert ist, da es sich um einen Stream handelt und der tatsächliche Inhalt des Antwort-Body nicht direkt im JSON-Format angezeigt wird. Um den Inhalt des Antwort-Body zu lesen, müssen die entsprechenden Methoden wie json(), text() oder blob() verwendet werden, je nachdem welches Format der Inhalt hat.\n1 2 3 4 5 6 7 8 9 10 11 { \"body\": \"ReadableStream\", \"bodyUsed\": true, \"headers\": {}, \"ok\": true, \"redirected\": false, \"status\": 200, \"statusText\": \"\", \"type\": \"cors\", \"url\": \"https://api.chucknorris.io/jokes/random\" } Theoretisch haben wir nun die Daten, die wir wollen. Da wir als Antwort ein JSON-Objekt erwarten, können wir diese direkt als solches anfordern:\n1 2 3 4 5 let response = await fetch(\"https://api.chucknorris.io/jokes/random\", { method: \"get\", }); response.json(); Komischerweise erhalten wir wieder ein Promise {\u003cpending\u003e} als Ergebnis. Was fehlt noch, um das JSON aus diesem Promise zu extrahieren?\nGenau: Wir müssen es awaiten:\n1 2 3 4 5 let response = await fetch(\"https://api.chucknorris.io/jokes/random\", { method: \"get\", }); let jokeObject = await response.json(); Das ist notwendig, da die Methode json() asynchron den Response-Stream ausliest.\nWenn du nun das jokeObject loggst (z.B. mit console.log(jokeObject)), siehst du, dass wir nun das gleiche Objekt, das wir ganz oben erwartet haben, einsehen können.\nDen Witz kannst du wie folgt ausgeben:\n1 console.log(jokeObject.value); Anfrage in eine Funktion einbinden Im Normalfall packt man Logik wie die oben beschriebene in eine Funktion. Den obenstehenden Code könntest du beispielsweise wie folgt in eine Methode einbinden:\n1 2 3 4 5 6 7 8 9 10 11 12 /** * Requests a random Chuck Norris joke and returns it. * @return {Promise\u003cstring\u003e} a random Chuck Norris joke. */ async function fetchJoke() { const response = await fetch(\"https://api.chucknorris.io/jokes/random\", { method: \"get\", }); const jokeObject = await response.json(); return jokeObject.value; } Dir ist sicher aufgefallen, dass wir in diesem Beispiel das async-Keyword vor function geschrieben haben. Das ist erforderlich, wenn man await in einer Funktion verwenden möchte. Dieses async-Keyword führt auch dazu, dass die Methode ein Objekt des Typen Promise\u003c...\u003e zurückgibt.\nWenn du diese Funktion definiert hast, kannst du den Rückgabewert von ihr wie folgt loggen:\n1 console.log(await fetchJoke()); await umgehen Du wirst in die Situation kommen, wo du eine Antwort auf eine asynchrone Anfrage erhältst, aber kein await brauchen darfst, weil du dich nicht in einer mit async gekennzeichneten Funktion befindest.\nStatt ein Promise mit await zu erwarten, kannst du auch definieren, dass eine bestimmte Aktion durchgeführt werden soll, sobald die Antwort da ist. Das kannst du mit Promise.then(...) machen:\n1 2 3 fetchJoke().then(function (joke) { console.log(joke); }); Das kannst du auch schöner schreiben, gewisse Browser (beispielsweise der Internet Explorer) unterstützen diese Schreibweise aber nicht:\n1 fetchJoke().then((joke) =\u003e console.log(joke)); Was genau haben wir hier gemacht?\nWir haben fetchJoke() asynchron aufgerufen, ohne auf die Antwort zu warten. Deswegen erhalten wir ein Promise-Objekt. Promise-Objekte enthalten implizit eine then-Methode. In dieser Methode kannst du eine Funktion übergeben. Die übergebene Funktion wird aufgerufen, sobald die Antwort erhalten wurde.\nException-Handling bei HTTP-Anfragen Während einer HTTP-Anfrage passieren oft folgende typische Fehler:\nDer angefragte Server kann nicht erreicht werden bzw. der Browser erhält keine Antwort (Response). Die Anfrage wurde durch den Browser blockiert (zum Beispiel durch die CORS Policy). Der Server gibt eine Antwort mit einem Status-Code zurück, der einen Fehler beschreibt. In den ersten beiden Fällen würde die fetch()-Funktion einen Error asynchron werfen. Diesen Fall könntest du mit einem try und catch abfangen.\nHingegen wird kein Fehler geworfen, wenn eine Antwort erhalten wird. Trotzdem kann die Response auf einen Fehler hindeuten, beispielsweise wenn der Status-Code 404 wäre. In diesem Fall hätten wir eine Antwort vom Server erhalten, die darauf hindeutet, dass die Seite hinter der URL nicht gefunden werden konnte.\nDaher macht es Sinn, die response jeweils auf den Status Code zu überprüfen. Hierfür bietet das response-Objekt ein praktisches Property an: ok. Wenn ok true ist, dann liegt der Status-Code zwischen 200 und 299 (erfolgreiche Status-Codes).\nBeide Fälle kombiniert resultieren in einem Error-Handling, das ungefähr so aussehen könnte:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 async function fetchJoke() { try { const response = await fetch(\"https://api.chucknorris.io/jokes/random\", { method: \"get\", }); if (!response.ok) { throw new Error(`Fehlerhafte Antwort. Status: ${response.status}`); } return await response.json(); } catch (error) { console.error(error); // Hier müsste noch der Fehler behandelt werden und evtl. eine Nachricht dem User angezeigt werden. return null; // etwas zurückgebe, das auf einen Fehler hindeutet. } } Möchte man eine genauere Prüfung des Status-Codes vornehmen, dann könnte man statt response.ok das Property response.status überprüfen.\nHier noch ein Beispiel, wie es mit .then() und .catch() aussehen könnte:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 function fetchJoke() { return fetch(\"https://api.chucknorris.io/jokes/random\", { method: \"get\" }) .then((response) =\u003e { if (!response.ok) throw Error(\"API not reachable\"); return response.json(); }) .then((data) =\u003e { return data.value; }) .catch((error) =\u003e { console.error(\"Error in fetchJoke:\", error); return null; // etwas zurückgebe, das auf einen Fehler hindeutet. }); } Ganz generell: Bei der Verwendung von fetch() kann man darüber diskutieren, ob es überhaupt Sinn ergibt, einen fetch()-Befehl überhaupt in einen try-catch-Block hereinzunehmen. In den meisten Fällen reicht es vollkommen aus, die response auf den Status-Code zu überprüfen. In Frameworks wie Angular wird oft auf einen try-catch-Block verzichtet, da das Framework einen “globalen Exception-Handler” besitzt, der den User dann über den Fehler informieren würde.\nHierzu findest du zwei Aufgaben im Lab.\nFrüher war alles besser? Die fetch-Funktion hat Web-Requests stark vereinfacht. Früher durfte man sich noch mit XML HTTP Requests herumschlagen. Schau dir das auf der folgenden Seite kurz an: https://www.w3schools.com/xml/xml_http.asp\n","categories":"","description":"Modul #F4 - JavaScript - Web-Requests in JavaScript.\n","excerpt":"Modul #F4 - JavaScript - Web-Requests in JavaScript.\n","ref":"/docs/03_web/03_javascript/15_web_request/","tags":"","title":"Web Request"},{"body":"Ziele Du weisst, wie man Web-Requests macht und die Antworten weiterverwenden kann. Webanfragen mit JavaScript Wenn du eine Webanwendung schreibst, dann muss deine Website (=Frontend) wahrscheinlich Daten von (d)einem Backend abfragen.\nIn den meisten Fällen werden hierfür HTTP(S)-Requests verwendet, die du bereits kennengelernt hast (REST API in Spring und HTML Forms).\nUm das einmal auszuprobieren, wollen wir testweise eine API anfragen, die als Antwort zufällige “Fakten” über Chuck Norris zurückschickt. Wenn wir diese URL im Browser per HTTP (GET) aufrufen, erhalten wir als Antwort einen Witz in Form eines JSON:\nGET https://api.chucknorris.io/jokes/random\n1 2 3 4 5 6 7 8 9 { \"categories\": [], \"created_at\": \"2020-01-05 13:42:20.262289\", \"icon_url\": \"https://assets.chucknorris.host/img/avatar/chuck-norris.png\", \"id\": \"6F3bv9fIRUGCPTcma6Je1w\", \"updated_at\": \"2020-01-05 13:42:20.262289\", \"url\": \"https://api.chucknorris.io/jokes/6F3bv9fIRUGCPTcma6Je1w\", \"value\": \"Albert Einstein's hair used to be neatly combed...until the day he met Chuck Norris.\" } Damit für dich das Vorgehen verständlicher ist, führen wir einmal Schritt für Schritt alles in der Browser-Konsole aus.\nDie Abfrage kannst du wie folgt manuell durchführen:\n1 fetch(\"https://api.chucknorris.io/jokes/random\", { method: \"get\" }); Du wirst sehen, dass dieser Funktionsaufruf ein Promise {\u003cpending\u003e} zurückgibt (Promises sind im Kapitel JS_Async zu finden). Wir sehen, dass die Anfrage noch nicht beendet ist (pending = anstehend). Dieses Promise-Objekt wird die Antwort enthalten, sobald die Antwort verfügbar ist. Da wir sowieso erst weiterfahren möchten, wenn die Antwort bereit ist, interessieren wir uns noch nicht für das Promise. Daher können wir mit der Fortsetzung des Scripts solange warten, bis wir die Antwort hätten. Das können wir wie folgt machen:\n1 await fetch(\"https://api.chucknorris.io/jokes/random\", { method: \"get\" }); Das await-Keyword führt dazu, dass das Script erst weiter durchläuft, wenn die Antwort angekommen ist. Zusätzlich wird die Antwort automatisch aus dem Promise-Objekt entpackt, womit wir direkt ein Objekt vom Typ Response erhalten. In diesem Objekt sind mehrere wichtige Informationen enthalten, beispielsweise, ob die Request überhaupt erfolgreich war (ok: true), wie der HTTP-Statuscode aussieht und so weiter. Zu beachten ist, dass body im unteren Beispiel als ReadableStream definiert ist, da es sich um einen Stream handelt und der tatsächliche Inhalt des Antwort-Body nicht direkt im JSON-Format angezeigt wird. Um den Inhalt des Antwort-Body zu lesen, müssen die entsprechenden Methoden wie json(), text() oder blob() verwendet werden, je nachdem welches Format der Inhalt hat.\n1 2 3 4 5 6 7 8 9 10 11 { \"body\": \"ReadableStream\", \"bodyUsed\": true, \"headers\": {}, \"ok\": true, \"redirected\": false, \"status\": 200, \"statusText\": \"\", \"type\": \"cors\", \"url\": \"https://api.chucknorris.io/jokes/random\" } Theoretisch haben wir nun die Daten, die wir wollen. Da wir als Antwort ein JSON-Objekt erwarten, können wir diese direkt als solches anfordern:\n1 2 3 4 5 let response = await fetch(\"https://api.chucknorris.io/jokes/random\", { method: \"get\", }); response.json(); Komischerweise erhalten wir wieder ein Promise {\u003cpending\u003e} als Ergebnis. Was fehlt noch, um das JSON aus diesem Promise zu extrahieren?\nGenau: Wir müssen es awaiten:\n1 2 3 4 5 let response = await fetch(\"https://api.chucknorris.io/jokes/random\", { method: \"get\", }); let jokeObject = await response.json(); Das ist notwendig, da die Methode json() asynchron den Response-Stream ausliest.\nWenn du nun das jokeObject loggst (z.B. mit console.log(jokeObject)), siehst du, dass wir nun das gleiche Objekt, das wir ganz oben erwartet haben, einsehen können.\nDen Witz kannst du wie folgt ausgeben:\n1 console.log(jokeObject.value); Anfrage in eine Funktion einbinden Im Normalfall packt man Logik wie die oben beschriebene in eine Funktion. Den obenstehenden Code könntest du beispielsweise wie folgt in eine Methode einbinden:\n1 2 3 4 5 6 7 8 9 10 11 12 /** * Requests a random Chuck Norris joke and returns it. * @return {Promise\u003cstring\u003e} a random Chuck Norris joke. */ async function fetchJoke() { const response = await fetch(\"https://api.chucknorris.io/jokes/random\", { method: \"get\", }); const jokeObject = await response.json(); return jokeObject.value; } Dir ist sicher aufgefallen, dass wir in diesem Beispiel das async-Keyword vor function geschrieben haben. Das ist erforderlich, wenn man await in einer Funktion verwenden möchte. Dieses async-Keyword führt auch dazu, dass die Methode ein Objekt des Typen Promise\u003c...\u003e zurückgibt.\nWenn du diese Funktion definiert hast, kannst du den Rückgabewert von ihr wie folgt loggen:\n1 console.log(await fetchJoke()); await umgehen Du wirst in die Situation kommen, wo du eine Antwort auf eine asynchrone Anfrage erhältst, aber kein await brauchen darfst, weil du dich nicht in einer mit async gekennzeichneten Funktion befindest.\nStatt ein Promise mit await zu erwarten, kannst du auch definieren, dass eine bestimmte Aktion durchgeführt werden soll, sobald die Antwort da ist. Das kannst du mit Promise.then(...) machen:\n1 2 3 fetchJoke().then(function (joke) { console.log(joke); }); Das kannst du auch schöner schreiben, gewisse Browser (beispielsweise der Internet Explorer) unterstützen diese Schreibweise aber nicht:\n1 fetchJoke().then((joke) =\u003e console.log(joke)); Was genau haben wir hier gemacht?\nWir haben fetchJoke() asynchron aufgerufen, ohne auf die Antwort zu warten. Deswegen erhalten wir ein Promise-Objekt. Promise-Objekte enthalten implizit eine then-Methode. In dieser Methode kannst du eine Funktion übergeben. Die übergebene Funktion wird aufgerufen, sobald die Antwort erhalten wurde.\nException-Handling bei HTTP-Anfragen Während einer HTTP-Anfrage passieren oft folgende typische Fehler:\nDer angefragte Server kann nicht erreicht werden bzw. der Browser erhält keine Antwort (Response). Die Anfrage wurde durch den Browser blockiert (zum Beispiel durch die CORS Policy). Der Server gibt eine Antwort mit einem Status-Code zurück, der einen Fehler beschreibt. In den ersten beiden Fällen würde die fetch()-Funktion einen Error asynchron werfen. Diesen Fall könntest du mit einem try und catch abfangen.\nHingegen wird kein Fehler geworfen, wenn eine Antwort erhalten wird. Trotzdem kann die Response auf einen Fehler hindeuten, beispielsweise wenn der Status-Code 404 wäre. In diesem Fall hätten wir eine Antwort vom Server erhalten, die darauf hindeutet, dass die Seite hinter der URL nicht gefunden werden konnte.\nDaher macht es Sinn, die response jeweils auf den Status Code zu überprüfen. Hierfür bietet das response-Objekt ein praktisches Property an: ok. Wenn ok true ist, dann liegt der Status-Code zwischen 200 und 299 (erfolgreiche Status-Codes).\nBeide Fälle kombiniert resultieren in einem Error-Handling, das ungefähr so aussehen könnte:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 async function fetchJoke() { try { const response = await fetch(\"https://api.chucknorris.io/jokes/random\", { method: \"get\", }); if (!response.ok) { throw new Error(`Fehlerhafte Antwort. Status: ${response.status}`); } return await response.json(); } catch (error) { console.error(error); // Hier müsste noch der Fehler behandelt werden und evtl. eine Nachricht dem User angezeigt werden. return null; // etwas zurückgebe, das auf einen Fehler hindeutet. } } Möchte man eine genauere Prüfung des Status-Codes vornehmen, dann könnte man statt response.ok das Property response.status überprüfen.\nHier noch ein Beispiel, wie es mit .then() und .catch() aussehen könnte:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 function fetchJoke() { return fetch(\"https://api.chucknorris.io/jokes/random\", { method: \"get\" }) .then((response) =\u003e { if (!response.ok) throw Error(\"API not reachable\"); return response.json(); }) .then((data) =\u003e { return data.value; }) .catch((error) =\u003e { console.error(\"Error in fetchJoke:\", error); return null; // etwas zurückgebe, das auf einen Fehler hindeutet. }); } Ganz generell: Bei der Verwendung von fetch() kann man darüber diskutieren, ob es überhaupt Sinn ergibt, einen fetch()-Befehl überhaupt in einen try-catch-Block hereinzunehmen. In den meisten Fällen reicht es vollkommen aus, die response auf den Status-Code zu überprüfen. In Frameworks wie Angular wird oft auf einen try-catch-Block verzichtet, da das Framework einen “globalen Exception-Handler” besitzt, der den User dann über den Fehler informieren würde.\nHierzu findest du zwei Aufgaben im Lab.\nFrüher war alles besser? Die fetch-Funktion hat Web-Requests stark vereinfacht. Früher durfte man sich noch mit XML HTTP Requests herumschlagen. Schau dir das auf der folgenden Seite kurz an: https://www.w3schools.com/xml/xml_http.asp\n","categories":"","description":"Modul #F4 - JavaScript - Web-Requests in JavaScript.\n","excerpt":"Modul #F4 - JavaScript - Web-Requests in JavaScript.\n","ref":"/de/docs/03_web/03_javascript/15_web_request/","tags":"","title":"Web Request"},{"body":"Ziele Ich verstehe den Unterschied zwischen Block- und Inline-Elementen und kann diese in HTML erkennen. Ich kann sowohl relative als auch absolute Einheiten in CSS verwenden, um die Größe von Elementen zu bestimmen. Ich kann Abstände zwischen und innerhalb von Elementen mithilfe von Margin und Padding in CSS gezielt einstellen. Block- und Inline-Elemente Bevor wir Elemente dimensionieren, müssen wir wissen, welche Elemente wir überhaupt dimensionieren können.\nIn CSS gibt es zwei grundlegende “Display”-Elemente:\nBlock-Elemente Inline-Elemente Im Normalfall können wir nur Block-Elemente dimensionieren (eine Grösse geben). Was ist aber genau der Unterschied zwischen den beiden Elementtypen?\nBlock-Elemente Block-Elemente starten im Normalfall immer auf einer neuen Zeile und haben per Default um sich selbst herum einen Abstand zu anderen Elementen.\nBlock-Elemente beanspruchen per Default die volle Breite an Platz (von links bis rechts).\nTypische Block-Elemente sind\n\u003cp\u003e \u003cdiv\u003e \u003caddress\u003e \u003carticle\u003e \u003caside\u003e \u003cblockquote\u003e \u003ccanvas\u003e \u003cdiv\u003e \u003cfooter\u003e \u003cform\u003e \u003ch1\u003e-\u003ch6\u003e \u003cheader\u003e \u003chr\u003e \u003cmain\u003e \u003cnav\u003e \u003cnoscript\u003e \u003col\u003e, \u003cul\u003e, \u003cdd\u003e, \u003cdl\u003e, \u003cdt\u003e, \u003cli\u003e \u003cpre\u003e \u003csection\u003e \u003ctable\u003e Um das zu verstehen, probiere diesen Code aus:\n1 2 3 4 5 6 7 8 9 10 \u003cp\u003eNur ein Paragraf\u003c/p\u003e \u003cp\u003eEin Paragraf mit einem \u003cspan\u003eSpan\u003c/span\u003e.\u003c/p\u003e \u003cstyle\u003e p { background-color: red; } span { background-color: yellow; } \u003c/style\u003e Dieser Code zeigt gut, dass das Block-Element (hier \u003cp\u003e) die ganze Breite (abzüglich eines kleinen Randes) eingenommen hat, während das \u003cspan\u003e-Element sich auf das Wort beschränkt.\nInline-Elemente Im obenstehenden Beispiel hast du bereits ein Inline-Element gesehen, nämlich das \u003cspan\u003e-Element.\nInline-Elemente kommen zumeist in einem Text vor. Inline-Elemente benötigen nur so viel Platz wie nötig. Im Gegensatz zu Block-Elementen beginnen Inline-Elemente also nicht auf einer neuen Zeile.\nTypische Inline-Elemente sind:\n\u003ca\u003e \u003cb\u003e \u003cbr\u003e \u003cbutton\u003e \u003ccode\u003e \u003cdfn\u003e \u003cem\u003e \u003ci\u003e \u003cimg\u003e \u003cinput\u003e \u003clabel\u003e \u003cscript\u003e \u003cselect\u003e \u003csmall\u003e \u003cspan\u003e \u003cstrong\u003e \u003ctextarea\u003e \u003ctime\u003e Wichtig zu wissen ist ausserdem, dass sich keine Block-Elemente in einem Inline-Element befinden dürfen.\nBlock-Elemente dimensionieren Bei Block-Elementen kannst du die Grösse verändern:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u003cdiv class=\"box\"\u003e \u003cp\u003eInside the first Box\u003c/p\u003e \u003c/div\u003e \u003cdiv class=\"box\"\u003e \u003cp\u003eInside the second Box\u003c/p\u003e \u003c/div\u003e \u003cstyle\u003e div.box { /*display: block;*/ width: 10em; height: 10em; background-color: cornflowerblue; } \u003c/style\u003e Wenn du diesen Code ausprobierst, siehst du zwei hellblaue Quadrate untereinander. Mit dem width-Property definiert man die Breite und mit dem height-Property die Höhe. Hiermit haben wir dem \u003cdiv class=\"box\"\u003e eine Höhe und Breite von 10em gegeben.\nEinheiten (Units) Im vorherigen Beispiel haben wir dem Quadrat eine Seitenlänge von 10em gegeben. Aber was sind überhaupt em?\n1em entspricht der Schriftgrösse des aktuellen Elements. Gibt man einem Text zum Beispiel font-size: 2em, so definiert man, dass die Schriftgrösse doppelt so gross sein soll wie beim übergeordneten Element. Somit ist die Grösseneinheit em proportional zur aktuellen Schriftgrösse.\nStatt em kann man auch rem verwenden: rem ist prinzipiell dasselbe wie em, nur dass es relativ zur Schriftgrösse des root-Elements ist (statt dem aktuellen Element). Somit ist rem auf der ganzen Seite immer gleich gross, em nicht.\nFür Seiten im Browser verwendet man am besten relative Einheiten wie em oder rem. Dennoch kommt man oft nicht an der absoluten Einheit px vorbei:\nOft möchte man nämlich beispielsweise den dünnsten möglichen Rand um ein Element haben, welcher einen Pixel breit ist. In diesem Fall würde man die Breite des Randes (Borders) gleich 1px setzen. Die Zuweisung sähe aus wie folgt:\n1 2 3 4 div.box { ... border: 1px solid black; } Dieses Beispiel fügt einen schwarzen Rand von einem Pixel Breite hinzu. Das solid bedeutet, dass es eine normale, durchgehende Linie sein soll (die Linie also beispielsweise nicht gestrichelt ist).\nEinheiten in der Übersicht Grundsätzlich empfehlen wir dir diese Übersicht: https://www.w3schools.com/cssref/css_units.asp\nVon den absoluten Einheiten musst du nur folgende kennen:\npx Die absoluten Einheiten sollten prinzipiell immer gleich gross sein. Sie sind aber nicht speziell für die Benutzung im Browser geeignet, da sich die Bildschirmgrössen der Benutzer untereinander teilweise stark unterscheiden.\nVon den relativen Einheiten solltest du mehrere kennen:\nEinheit Beschreibung em, rem Längeneinheit relativ zur Schriftgrösse des aktuellen bzw. des root-Elements vw 1vw = 1% der Weite des ViewPorts (angezeigter Teil der Browser-Seite) vh 1vh = 1% der Höhe des ViewPorts (angezeigter Teil der Browser-Seite) % Relativ zum Parent-Element. width: 50% bedeutet beispielsweise, dass das Element halb so breit wie das übergeordnete Element sein soll. % funktioniert gut im Zusammenhang mit Breiten, aber nicht immer so gut im Zusammenhang mit Höhen. Wenn du noch mehr über Einheiten erfahren möchtest, dann schaue dir diese Seite an: https://web.dev/learn/css/sizing/\nBlock-Elemente weiter dimensionieren (Box Model) Wir haben bereits CSS-Properties wie width, height und border verwendet. Nun wird es Zeit zu verstehen, wie diese Werte die Dimensionen von Block-Elementen beeinflussen. Probiere dieses Beispiel aus:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u003cdiv class=\"box\"\u003e \u003cp\u003eInside the first Box\u003c/p\u003e \u003c/div\u003e \u003cdiv class=\"box\"\u003e \u003cp\u003eInside the second Box\u003c/p\u003e \u003cp class=\"half-width\"\u003eHalbe Breite\u003c/p\u003e \u003c/div\u003e \u003cstyle\u003e div.box { /*display: block;*/ width: 10em; height: 10em; background-color: cornflowerblue; } .half-width { width: 50%; background-color: white; border: 2em solid gray; } \u003c/style\u003e Du wirst sehen, dass das weisse Feld mit “Halbe Breite” die halbe Breite der übergeordneten Box beansprucht. Zusammen mit dem Rand macht das aber mehr als die Hälfte aus! Somit schauen wir uns das Box-Modell in CSS an:\nDie “Content Box” ist sozusagen der Inhalt des Block-Elements. Die “Border Box” ist der Rahmen des Elements. Als wir die width gesetzt hatten, haben wir die Breite der Content Box gesetzt. Oft wollen wir aber, dass die Box inklusive Rand 50% der Breite einnimmt. Hierfür gibt es mehrere Möglichkeiten:\nTheoretisch könnten wir die Breite berechnen, indem wir einfach den Rand von der Breite subtrahieren:\n1 2 3 4 .half-width { width: calc(50% - 2 * 2em); ... } In den meisten Fällen ist das aber unnötig kompliziert. Es gibt aber eine Abkürzung, die einem diesen Umweg erspart:\n1 2 3 4 5 .half-width { box-sizing: border-box; width: 50%; ... } Auf diese Weise nimmt die Box nur noch 50% der gesamten Breite ein (inklusive Border). Der Default für box-sizing ist content-box.\nZur Vertiefung des Box Models kannst du gerne diese Seite studieren: https://web.dev/learn/css/box-model/.\nAbstände Abstände zu anderen Elementen (Margin) Oft gibt es die Anforderung, dass Elemente untereinander einen Abstand haben sollen. Genau dafür verwendet man das margin-Property. Spiel mit diesem Wert ein bisschen herum, um zu sehen, wie sich die Elemente je nach margin verhalten:\n1 2 3 4 div.box { ... margin: 2em; } Du kannst das margin-Property mit insgesamt vier Werten versehen, wobei jeder Wert für eine Richtung steht. (Top, Right, Bottom, Left)\n1 margin: 1em 2em 3em 4px; Die folgenden vier Zeilen sind dementsprechend äquivalent zum obenstehenden Beispiel:\n1 2 3 4 margin-top: 1em; margin-right: 2em; margin-bottom: 3em; margin-left: 4px; Beachte bei der kurzen Schreibweise, dass die Angabe der Werte oben beginnt und im Uhrzeigersinn weitergeht.\nEine gute Eselsbrücke, um sich das zu merken, ist das Wort TRouBLe. Anhand der Reihenfolge der Buchstaben lässt sich die Reihenfolge gut merken. (Top, Right, Bottom, Left)\nAbstand der Border zum Content (Padding) Oft sieht es unschön aus, wenn der Text direkt am Rand (am Border) aneckt. Das kann behoben werden, indem innerhalb des Elements ein Rand (Padding) eingefügt wird:\n1 2 3 4 5 6 7 8 .half-width { padding: 0.5em; ... box-sizing: border-box; width: 73%; background-color: white; border: 7px solid gray; } Beachte, dass bei einer Angabe wie width: 40% mit box-sizing: content-box die Weite sich nur auf den Content bezieht. Das Padding kommt in diesem Beispiel zu den 40% noch hinzu!\n","categories":"","description":"Modul #F3 - HTML und CSS - Dimensionierung von (Inline-)Block-Elementen mit CSS.\nAuf dieser Seite erfährst du, wie du die Grössen von Elementen definierst.\n","excerpt":"Modul #F3 - HTML und CSS - Dimensionierung von …","ref":"/docs/03_web/02_html_css/14_css-sizing/","tags":"","title":"Sizing"},{"body":"Ziele Ich verstehe den Unterschied zwischen Block- und Inline-Elementen und kann diese in HTML erkennen. Ich kann sowohl relative als auch absolute Einheiten in CSS verwenden, um die Größe von Elementen zu bestimmen. Ich kann Abstände zwischen und innerhalb von Elementen mithilfe von Margin und Padding in CSS gezielt einstellen. Block- und Inline-Elemente Bevor wir Elemente dimensionieren, müssen wir wissen, welche Elemente wir überhaupt dimensionieren können.\nIn CSS gibt es zwei grundlegende “Display”-Elemente:\nBlock-Elemente Inline-Elemente Im Normalfall können wir nur Block-Elemente dimensionieren (eine Grösse geben). Was ist aber genau der Unterschied zwischen den beiden Elementtypen?\nBlock-Elemente Block-Elemente starten im Normalfall immer auf einer neuen Zeile und haben per Default um sich selbst herum einen Abstand zu anderen Elementen.\nBlock-Elemente beanspruchen per Default die volle Breite an Platz (von links bis rechts).\nTypische Block-Elemente sind\n\u003cp\u003e \u003cdiv\u003e \u003caddress\u003e \u003carticle\u003e \u003caside\u003e \u003cblockquote\u003e \u003ccanvas\u003e \u003cdiv\u003e \u003cfooter\u003e \u003cform\u003e \u003ch1\u003e-\u003ch6\u003e \u003cheader\u003e \u003chr\u003e \u003cmain\u003e \u003cnav\u003e \u003cnoscript\u003e \u003col\u003e, \u003cul\u003e, \u003cdd\u003e, \u003cdl\u003e, \u003cdt\u003e, \u003cli\u003e \u003cpre\u003e \u003csection\u003e \u003ctable\u003e Um das zu verstehen, probiere diesen Code aus:\n1 2 3 4 5 6 7 8 9 10 \u003cp\u003eNur ein Paragraf\u003c/p\u003e \u003cp\u003eEin Paragraf mit einem \u003cspan\u003eSpan\u003c/span\u003e.\u003c/p\u003e \u003cstyle\u003e p { background-color: red; } span { background-color: yellow; } \u003c/style\u003e Dieser Code zeigt gut, dass das Block-Element (hier \u003cp\u003e) die ganze Breite (abzüglich eines kleinen Randes) eingenommen hat, während das \u003cspan\u003e-Element sich auf das Wort beschränkt.\nInline-Elemente Im obenstehenden Beispiel hast du bereits ein Inline-Element gesehen, nämlich das \u003cspan\u003e-Element.\nInline-Elemente kommen zumeist in einem Text vor. Inline-Elemente benötigen nur so viel Platz wie nötig. Im Gegensatz zu Block-Elementen beginnen Inline-Elemente also nicht auf einer neuen Zeile.\nTypische Inline-Elemente sind:\n\u003ca\u003e \u003cb\u003e \u003cbr\u003e \u003cbutton\u003e \u003ccode\u003e \u003cdfn\u003e \u003cem\u003e \u003ci\u003e \u003cimg\u003e \u003cinput\u003e \u003clabel\u003e \u003cscript\u003e \u003cselect\u003e \u003csmall\u003e \u003cspan\u003e \u003cstrong\u003e \u003ctextarea\u003e \u003ctime\u003e Wichtig zu wissen ist ausserdem, dass sich keine Block-Elemente in einem Inline-Element befinden dürfen.\nBlock-Elemente dimensionieren Bei Block-Elementen kannst du die Grösse verändern:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u003cdiv class=\"box\"\u003e \u003cp\u003eInside the first Box\u003c/p\u003e \u003c/div\u003e \u003cdiv class=\"box\"\u003e \u003cp\u003eInside the second Box\u003c/p\u003e \u003c/div\u003e \u003cstyle\u003e div.box { /*display: block;*/ width: 10em; height: 10em; background-color: cornflowerblue; } \u003c/style\u003e Wenn du diesen Code ausprobierst, siehst du zwei hellblaue Quadrate untereinander. Mit dem width-Property definiert man die Breite und mit dem height-Property die Höhe. Hiermit haben wir dem \u003cdiv class=\"box\"\u003e eine Höhe und Breite von 10em gegeben.\nEinheiten (Units) Im vorherigen Beispiel haben wir dem Quadrat eine Seitenlänge von 10em gegeben. Aber was sind überhaupt em?\n1em entspricht der Schriftgrösse des aktuellen Elements. Gibt man einem Text zum Beispiel font-size: 2em, so definiert man, dass die Schriftgrösse doppelt so gross sein soll wie beim übergeordneten Element. Somit ist die Grösseneinheit em proportional zur aktuellen Schriftgrösse.\nStatt em kann man auch rem verwenden: rem ist prinzipiell dasselbe wie em, nur dass es relativ zur Schriftgrösse des root-Elements ist (statt dem aktuellen Element). Somit ist rem auf der ganzen Seite immer gleich gross, em nicht.\nFür Seiten im Browser verwendet man am besten relative Einheiten wie em oder rem. Dennoch kommt man oft nicht an der absoluten Einheit px vorbei:\nOft möchte man nämlich beispielsweise den dünnsten möglichen Rand um ein Element haben, welcher einen Pixel breit ist. In diesem Fall würde man die Breite des Randes (Borders) gleich 1px setzen. Die Zuweisung sähe aus wie folgt:\n1 2 3 4 div.box { ... border: 1px solid black; } Dieses Beispiel fügt einen schwarzen Rand von einem Pixel Breite hinzu. Das solid bedeutet, dass es eine normale, durchgehende Linie sein soll (die Linie also beispielsweise nicht gestrichelt ist).\nEinheiten in der Übersicht Grundsätzlich empfehlen wir dir diese Übersicht: https://www.w3schools.com/cssref/css_units.asp\nVon den absoluten Einheiten musst du nur folgende kennen:\npx Die absoluten Einheiten sollten prinzipiell immer gleich gross sein. Sie sind aber nicht speziell für die Benutzung im Browser geeignet, da sich die Bildschirmgrössen der Benutzer untereinander teilweise stark unterscheiden.\nVon den relativen Einheiten solltest du mehrere kennen:\nEinheit Beschreibung em, rem Längeneinheit relativ zur Schriftgrösse des aktuellen bzw. des root-Elements vw 1vw = 1% der Weite des ViewPorts (angezeigter Teil der Browser-Seite) vh 1vh = 1% der Höhe des ViewPorts (angezeigter Teil der Browser-Seite) % Relativ zum Parent-Element. width: 50% bedeutet beispielsweise, dass das Element halb so breit wie das übergeordnete Element sein soll. % funktioniert gut im Zusammenhang mit Breiten, aber nicht immer so gut im Zusammenhang mit Höhen. Wenn du noch mehr über Einheiten erfahren möchtest, dann schaue dir diese Seite an: https://web.dev/learn/css/sizing/\nBlock-Elemente weiter dimensionieren (Box Model) Wir haben bereits CSS-Properties wie width, height und border verwendet. Nun wird es Zeit zu verstehen, wie diese Werte die Dimensionen von Block-Elementen beeinflussen. Probiere dieses Beispiel aus:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u003cdiv class=\"box\"\u003e \u003cp\u003eInside the first Box\u003c/p\u003e \u003c/div\u003e \u003cdiv class=\"box\"\u003e \u003cp\u003eInside the second Box\u003c/p\u003e \u003cp class=\"half-width\"\u003eHalbe Breite\u003c/p\u003e \u003c/div\u003e \u003cstyle\u003e div.box { /*display: block;*/ width: 10em; height: 10em; background-color: cornflowerblue; } .half-width { width: 50%; background-color: white; border: 2em solid gray; } \u003c/style\u003e Du wirst sehen, dass das weisse Feld mit “Halbe Breite” die halbe Breite der übergeordneten Box beansprucht. Zusammen mit dem Rand macht das aber mehr als die Hälfte aus! Somit schauen wir uns das Box-Modell in CSS an:\nDie “Content Box” ist sozusagen der Inhalt des Block-Elements. Die “Border Box” ist der Rahmen des Elements. Als wir die width gesetzt hatten, haben wir die Breite der Content Box gesetzt. Oft wollen wir aber, dass die Box inklusive Rand 50% der Breite einnimmt. Hierfür gibt es mehrere Möglichkeiten:\nTheoretisch könnten wir die Breite berechnen, indem wir einfach den Rand von der Breite subtrahieren:\n1 2 3 4 .half-width { width: calc(50% - 2 * 2em); ... } In den meisten Fällen ist das aber unnötig kompliziert. Es gibt aber eine Abkürzung, die einem diesen Umweg erspart:\n1 2 3 4 5 .half-width { box-sizing: border-box; width: 50%; ... } Auf diese Weise nimmt die Box nur noch 50% der gesamten Breite ein (inklusive Border). Der Default für box-sizing ist content-box.\nZur Vertiefung des Box Models kannst du gerne diese Seite studieren: https://web.dev/learn/css/box-model/.\nAbstände Abstände zu anderen Elementen (Margin) Oft gibt es die Anforderung, dass Elemente untereinander einen Abstand haben sollen. Genau dafür verwendet man das margin-Property. Spiel mit diesem Wert ein bisschen herum, um zu sehen, wie sich die Elemente je nach margin verhalten:\n1 2 3 4 div.box { ... margin: 2em; } Du kannst das margin-Property mit insgesamt vier Werten versehen, wobei jeder Wert für eine Richtung steht. (Top, Right, Bottom, Left)\n1 margin: 1em 2em 3em 4px; Die folgenden vier Zeilen sind dementsprechend äquivalent zum obenstehenden Beispiel:\n1 2 3 4 margin-top: 1em; margin-right: 2em; margin-bottom: 3em; margin-left: 4px; Beachte bei der kurzen Schreibweise, dass die Angabe der Werte oben beginnt und im Uhrzeigersinn weitergeht.\nEine gute Eselsbrücke, um sich das zu merken, ist das Wort TRouBLe. Anhand der Reihenfolge der Buchstaben lässt sich die Reihenfolge gut merken. (Top, Right, Bottom, Left)\nAbstand der Border zum Content (Padding) Oft sieht es unschön aus, wenn der Text direkt am Rand (am Border) aneckt. Das kann behoben werden, indem innerhalb des Elements ein Rand (Padding) eingefügt wird:\n1 2 3 4 5 6 7 8 .half-width { padding: 0.5em; ... box-sizing: border-box; width: 73%; background-color: white; border: 7px solid gray; } Beachte, dass bei einer Angabe wie width: 40% mit box-sizing: content-box die Weite sich nur auf den Content bezieht. Das Padding kommt in diesem Beispiel zu den 40% noch hinzu!\n","categories":"","description":"Modul #F3 - HTML und CSS - Dimensionierung von (Inline-)Block-Elementen mit CSS.\nAuf dieser Seite erfährst du, wie du die Grössen von Elementen definierst.\n","excerpt":"Modul #F3 - HTML und CSS - Dimensionierung von …","ref":"/de/docs/03_web/02_html_css/14_css-sizing/","tags":"","title":"Sizing"},{"body":"Ziele Du weisst, was Lazy-Loading ist und kannst es erklären. Du kannst Lazy Loading anwenden. Was ist Lazy Loading Lazy Loading bezeichnet im Allgemeinen eine Funktionalität in der Software-Entwicklung, bei der Daten erst ab dem Zeitpunkt geladen werden, in dem sie benötigt werden. Im Zusammenhang mit Websites geht es darum, Inhalte wie Bilder erst dann vom Server zu laden, wenn diese im sichtbaren Bereich und somit nötig sind. Dadurch wird die Ladezeit der Seite zu Beginn reduziert. Auf diese Weise wird dem User beispielsweise bereits eine Seite angezeigt, obwohl weitere Inhalte noch geladen werden. Lazy Loading in Angular Standardmässig lädt der Browser alle Angular-Module, bevor der Benutzer mit ihnen arbeiten kann. Natürlich gibt es auch einige, die nicht oder zumindest nicht sofort benötigt werden.\nGenau hier setzt das Lazy Loading an, um die Startgeschwindigkeit zu optimieren: Es stellt sicher, dass nur die wichtigsten Anwendungsbestandteile im Browser landen, der Rest wird später bei Bedarf angefordert.\nDazu muss man als erstes alle Module identifizieren welche man mittels lazy loading laden möchte. Danach erstellt man für jedes Modul eine neue separate Moduldatei (.module.ts). Jetzt kann man neuen Components, Services etc. welche zu diesem Modul gehören erstellen oder bestehende verschieben. Damit jedoch immer noch genau glich auf die Components zugegriffen werden können, muss man das routing anpassen. Die Routen müssen mit der Eigenschaft loadChildren verwendet werden, darin sagt man dann welches Modul geladen werden soll, wenn man auf diese Route zugreift.\n1 2 3 4 5 6 7 8 9 10 const routes: Routes = [ { path: \"\", component: GreetingComponent }, { path: \"triumph/:id\", component: TriumphsComponent }, { path: \"weapon\", canActivate: [WeaponGuard], loadChildren: () =\u003e import(\"./components/weapon/weapon.module\").then((m) =\u003e m.WeaponModule), }, ]; Das neue Modul muss jedoch im .module.ts-File, in welchem sich das Routing mit dem loadChildren befindet in den imports angegeben werden.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import { NgModule } from \"@angular/core\"; import { BrowserModule } from \"@angular/platform-browser\"; import { AppRoutingModule } from \"./app-routing.module\"; import { WeaponModule } from \"./components/weapon/weapon.module\"; @NgModule({ declarations: [ // .. ], imports: [ BrowserModule, AppRoutingModule, WeaponModule, // .. ], // .. }) export class AppModule {} Für das neuen Modul muss man nun auch dessen Routen verfassen. Dazu ein neues -routing.module.ts-File erstellen und eine Standart-Route definieren, dessen Component wird aufgerufen, wenn das Modul geladen wird, also genauer gesagt, wenn in einem anderen Routing die Route mit dem loadChildren aufruft wird. Wichtig hier ist man bei den imports im NgModule nicht mehr forRoot für die Routen benötigt sondern forChild.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import { NgModule } from \"@angular/core\"; import { RouterModule, Routes } from \"@angular/router\"; import { WeaponComponent } from \"./weapon.component\"; const routes: Routes = [ { path: \"\", component: WeaponComponent }, // Standart-Route wenn man vom AppModule auf das WeaponModul wechselt // .. ]; @NgModule({ imports: [RouterModule.forChild(routes)], exports: [RouterModule], }) export class WeaponRoutingModule {} Im .module.ts-File der neuen Moduls kann man alle Components, etc. des Moduls deklarieren und die imports angeben genau wie beim AppModul. Wichtig ist jedoch das man für das Routing hier dann das neu erstellt des Moduls verwendet und nicht mehr das AppRoutingModule.\n1 2 3 4 5 6 7 8 9 10 import { NgModule } from \"@angular/core\"; import { CommonModule } from \"@angular/common\"; import { WeaponComponent } from \"./weapon.component\"; import { WeaponRoutingModule } from \"./weapon-routing.module\"; @NgModule({ declarations: [WeaponComponent], imports: [CommonModule, WeaponRoutingModule], }) export class WeaponModule {} Lazy Loading mit Angular Material Einige Components von Angular Material unterstützen Lazy Loading.\nEin Beispiel hierzu ist das Expansion-Panel.\nDie Inhalte des Expansion Panels werden geladen, auch wenn das Expansion-Panel geschlossen ist. Wenn man auf einer Ansicht beispielsweise 30 dieser Expansion-Panels anzeigt und den jeweiligen Inhalt lädt, kann dies zu Performance-Problemen führen.\nJedoch unterstützt dieser Component Lazy Loading, wodurch man die Performance-Probleme sehr einfach umgehen kann. Inhalte werden erst geladen, wenn sich das Expansion-Panel öffnet.\nIn den meisten Fällen ist das Anwenden von Lazy Loading in Angular Material Components auch kein grosser Aufwand.\nSchaut also auf der Angular Material Website in “Overview” des Components immer gut nach, ob der Component Lazy Loading unterstützt.\nDeferrable Views Mit dem Update von Angular 17 wurde eine neue Art des Lazy Loadings hinzugefügt, nämlich die Deferrable Views. Mit der neuen Syntax @defer können Components oder andere Inhalte innerhalb eines spezifischen Component dynamisch geladen werden. Beispielsweise kann ein Component erst geladen werden, sobald er bereitsteht (Alle Dependencies würde aufgelöst). Das würde dann so aussehen:\n1 2 3 @defer { \u003cshopping-cart /\u003e } Zum @defer-Block gibt es noch einige zusätzliche erweiternden Blöcke, die das Laden und Anzeigen verschönern. Hier eine kurze Übersicht:\n@placeholder Standardmässig lädt der @defer-Block keinen Inhalt, was meist unschön ist. Dazu gibt es den @placeholder-Block. Dieser kann als normales Div verwendet werden und beliebigen Inhalt haben. Logischerweise sollte hier kein Inhalt platziert werden, der auch mit Lazy Loading geladen werden muss/soll.\n1 2 3 4 5 @defer { \u003cshopping-cart /\u003e } @placeholder { I'm a placeholder :D } Der Placeholder bleibt so lange stehen, bis der Inhalt des @defer geladen hat. Wenn es gewünscht ist kann eine Mindestzeit bestimmt werden, in der der Placeholder angezeigt werden muss:\n1 2 3 4 5 @defer { \u003cshopping-cart /\u003e } @placeholder (minimum 500ms){ I'm a placeholder :D I will stay here atleast 500ms ;) } @loading Der @loading-Block ähnelt sehr dem @placeholder-Block, jedoch ist im @loading noch eine zusätzliche Option verfügbar. Mit after kann definiert werden, wann der @loading-Block zusehen sein soll. Dieser überschreibt somit ab diesem Zeitpunkt auch den @placeholder-Block.\n1 2 3 4 5 6 7 @defer { \u003cshopping-cart /\u003e } @placeholder { I'm a placeholder :D I will be overwritten in 100ms :'( } @loading (after 100ms; minimum 1s) { \u003cimg alt=\"loading...\" src=\"loading.gif\" /\u003e } Der @loading-Block ist vor allem in Kombination mit den triggers sinnvoll.\n@error Auch der @error-Block macht das, was man sich unter dem Namen vorstellt, wenn das Laden des Inhalts fehlschlägt wird der Inhalt des @error-Blocks angezeigt.\n1 2 3 4 5 @defer { \u003cshopping-cart /\u003e } @error { \u003cp\u003eFailed to load shopping cart :( \u003c/p\u003e } Alle erwähnten Blöcke können natürlich auch aneinander gereiht werden und so eine klare Struktur abbilden: 1 2 3 4 5 6 7 8 9 @defer { \u003ccomment-list/\u003e } @loading { Loading… } @error { Loading failed :( } @placeholder { \u003cimg src=\"shopping-placeholder.png\"\u003e } Defer mit Trigger In einigen Fällen ist es hilfreich, wenn selbst bestimmt werden kann, wann das Lazy Loading beginnt. Dazu wurden den Deferrable Views zusätzlich Triggers hinzugefügt, die den Zeitpunkt des Ladens einschränken.\nViewport Einer dieser Trigger ist der Viewport. Dieser Trigger wird ausgelöst, wenn ein @placeholder im Viewport sichtbar ist. Der Code dazu würde dann ungefähr so aussehen:\n1 2 3 4 5 6 @defer (on viewport) { \u003cshopping-cart /\u003e } @placeholder { \u003c!-- A placeholder content to show until the shopping-cart loads --\u003e \u003cimg src=\"shopping-placeholder.png\"\u003e } Idle Der Trigger idle teilt Angular mit, dass der Inhalt erst geladen werden soll, wenn der Browser keine wichtigen Aufgaben mehr zu erledigen hat.\n1 2 3 4 5 6 @defer (on idle) { \u003cunimportant-info /\u003e } @placeholder { \u003c!-- A placeholder content to show until the unimportant-info loads --\u003e \u003cimg src=\"unimportant-info-placeholder.png\"\u003e } Interaction Der Name interaction verrät bereits, dass der Inhalt hier erst geladen wird, wenn eine Aktion (Klick oder Keydown) auf einem bestimmten Element durchgeführt wird. Standardmässig ist dieses Element der Placeholder.\n1 2 3 4 5 6 @defer (on interaction) { \u003cshopping-cart /\u003e } @placeholder { \u003c!-- A placeholder content to show until the shopping-cart loads --\u003e \u003cimg src=\"shopping-placeholder.png\"\u003e } Ein anderes Element kannst du so bestimmen:\n1 2 3 4 5 6 \u003cbutton type=\"button\" #greeting\u003eHello!\u003c/button\u003e @defer (on interaction(greeting)) { \u003cshopping-cart /\u003e } @placeholder { \u003cdiv\u003eShopping Cart placeholder\u003c/div\u003e } Hier wird also das shopping-cart erst geladen, wenn der Button geklickt wird.\nHover Gleich wie beim Trigger interaction wird hier der Inhalt geladen, wenn über ein Element gehovert wird. Auch hier ist Standardmässig der Placeholder dieses Element.\n1 2 3 4 5 6 @defer (on hover) { \u003cshopping-cart /\u003e } @placeholder { \u003c!-- A placeholder content to show until the shopping-cart loads --\u003e \u003cimg src=\"shopping-placeholder.png\"\u003e } Ein anderes Element kannst du so bestimmen:\n1 2 3 4 5 6 \u003cdiv #greeting\u003eHello!\u003c/div\u003e @defer (on hover(greeting)) { \u003cshopping-cart /\u003e } @placeholder { \u003cdiv\u003eShopping Cart placeholder\u003c/div\u003e } Hier wird also das shopping-cart erst geladen, wenn der über das Hello! gehovert wird.\nTimer Mit dem Timer Trigger kann eine bestimmte Zeit in Millisekunden angegeben werden, die gewartet werden soll, bis das Laden beginnt.\n1 2 3 4 5 6 @defer (on timer(500ms)) { \u003cshopping-cart /\u003e } @placeholder { \u003c!-- A placeholder content to show until the shopping-cart loads --\u003e \u003cimg src=\"shopping-placeholder.png\"\u003e } Immediate Anders als die anderen Trigger wird Immediate nicht verzögert durchgeführt, jedoch wird der Inhalt immer noch mit Lazy Loading geladen. Immediate kann hilfreich sein, wenn es Inhalte gibt, die priorität vor anderen Inhalten haben.\n1 2 3 4 5 6 @defer (on immediate) { \u003cshopping-cart /\u003e } @placeholder { \u003c!-- A placeholder content to show until the shopping-cart loads --\u003e \u003cimg src=\"shopping-placeholder.png\"\u003e } When Mit dem Trigger When kann selbst definiert werden unter welchen Bedingungen ein Inhalt geladen wird. Das When funktioniert grundsätzlich wie ein normales if.\n1 2 3 @defer (when bedingung) { \u003cshopping-cart /\u003e } Prefetching In einigen Anwendungsfällen kann es Sinn machen, wenn der Inhalt eines @defers bereits bei Möglichkeit vorgeladen wird. Wenn beispielsweise ein interaction-Trigger eingesetzt wird und dieser lange nicht ausgelöst wird. Dazu kann das Preloading wie folgt aktiviert werden:\n1 2 3 4 5 @defer (on interaction(greeting); prefetch on idle) { \u003cshopping-cart /\u003e } @placeholder { \u003cdiv\u003eShopping Cart placeholder\u003c/div\u003e } Hier wird zusätzlich zum Trigger noch ein zweiter Trigger für das prefetch eingesetzt. Alle verfügbaren Trigger (inkl. when) sind hier zulässig, jedoch macht z.B. interaction meist wenig Sinn.\n","categories":"","description":"Modul #F6 - Angular - Lazy Loading\n","excerpt":"Modul #F6 - Angular - Lazy Loading\n","ref":"/docs/03_web/06_angular/02_14_lazy_loading/","tags":"","title":"Lazy Loading"},{"body":"Ziele Du weisst, was Lazy-Loading ist und kannst es erklären. Du kannst Lazy Loading anwenden. Was ist Lazy Loading Lazy Loading bezeichnet im Allgemeinen eine Funktionalität in der Software-Entwicklung, bei der Daten erst ab dem Zeitpunkt geladen werden, in dem sie benötigt werden. Im Zusammenhang mit Websites geht es darum, Inhalte wie Bilder erst dann vom Server zu laden, wenn diese im sichtbaren Bereich und somit nötig sind. Dadurch wird die Ladezeit der Seite zu Beginn reduziert. Auf diese Weise wird dem User beispielsweise bereits eine Seite angezeigt, obwohl weitere Inhalte noch geladen werden. Lazy Loading in Angular Standardmässig lädt der Browser alle Angular-Module, bevor der Benutzer mit ihnen arbeiten kann. Natürlich gibt es auch einige, die nicht oder zumindest nicht sofort benötigt werden.\nGenau hier setzt das Lazy Loading an, um die Startgeschwindigkeit zu optimieren: Es stellt sicher, dass nur die wichtigsten Anwendungsbestandteile im Browser landen, der Rest wird später bei Bedarf angefordert.\nDazu muss man als erstes alle Module identifizieren welche man mittels lazy loading laden möchte. Danach erstellt man für jedes Modul eine neue separate Moduldatei (.module.ts). Jetzt kann man neuen Components, Services etc. welche zu diesem Modul gehören erstellen oder bestehende verschieben. Damit jedoch immer noch genau glich auf die Components zugegriffen werden können, muss man das routing anpassen. Die Routen müssen mit der Eigenschaft loadChildren verwendet werden, darin sagt man dann welches Modul geladen werden soll, wenn man auf diese Route zugreift.\n1 2 3 4 5 6 7 8 9 10 const routes: Routes = [ { path: \"\", component: GreetingComponent }, { path: \"triumph/:id\", component: TriumphsComponent }, { path: \"weapon\", canActivate: [WeaponGuard], loadChildren: () =\u003e import(\"./components/weapon/weapon.module\").then((m) =\u003e m.WeaponModule), }, ]; Das neue Modul muss jedoch im .module.ts-File, in welchem sich das Routing mit dem loadChildren befindet in den imports angegeben werden.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import { NgModule } from \"@angular/core\"; import { BrowserModule } from \"@angular/platform-browser\"; import { AppRoutingModule } from \"./app-routing.module\"; import { WeaponModule } from \"./components/weapon/weapon.module\"; @NgModule({ declarations: [ // .. ], imports: [ BrowserModule, AppRoutingModule, WeaponModule, // .. ], // .. }) export class AppModule {} Für das neuen Modul muss man nun auch dessen Routen verfassen. Dazu ein neues -routing.module.ts-File erstellen und eine Standart-Route definieren, dessen Component wird aufgerufen, wenn das Modul geladen wird, also genauer gesagt, wenn in einem anderen Routing die Route mit dem loadChildren aufruft wird. Wichtig hier ist man bei den imports im NgModule nicht mehr forRoot für die Routen benötigt sondern forChild.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import { NgModule } from \"@angular/core\"; import { RouterModule, Routes } from \"@angular/router\"; import { WeaponComponent } from \"./weapon.component\"; const routes: Routes = [ { path: \"\", component: WeaponComponent }, // Standart-Route wenn man vom AppModule auf das WeaponModul wechselt // .. ]; @NgModule({ imports: [RouterModule.forChild(routes)], exports: [RouterModule], }) export class WeaponRoutingModule {} Im .module.ts-File der neuen Moduls kann man alle Components, etc. des Moduls deklarieren und die imports angeben genau wie beim AppModul. Wichtig ist jedoch das man für das Routing hier dann das neu erstellt des Moduls verwendet und nicht mehr das AppRoutingModule.\n1 2 3 4 5 6 7 8 9 10 import { NgModule } from \"@angular/core\"; import { CommonModule } from \"@angular/common\"; import { WeaponComponent } from \"./weapon.component\"; import { WeaponRoutingModule } from \"./weapon-routing.module\"; @NgModule({ declarations: [WeaponComponent], imports: [CommonModule, WeaponRoutingModule], }) export class WeaponModule {} Lazy Loading mit Angular Material Einige Components von Angular Material unterstützen Lazy Loading.\nEin Beispiel hierzu ist das Expansion-Panel.\nDie Inhalte des Expansion Panels werden geladen, auch wenn das Expansion-Panel geschlossen ist. Wenn man auf einer Ansicht beispielsweise 30 dieser Expansion-Panels anzeigt und den jeweiligen Inhalt lädt, kann dies zu Performance-Problemen führen.\nJedoch unterstützt dieser Component Lazy Loading, wodurch man die Performance-Probleme sehr einfach umgehen kann. Inhalte werden erst geladen, wenn sich das Expansion-Panel öffnet.\nIn den meisten Fällen ist das Anwenden von Lazy Loading in Angular Material Components auch kein grosser Aufwand.\nSchaut also auf der Angular Material Website in “Overview” des Components immer gut nach, ob der Component Lazy Loading unterstützt.\nDeferrable Views Mit dem Update von Angular 17 wurde eine neue Art des Lazy Loadings hinzugefügt, nämlich die Deferrable Views. Mit der neuen Syntax @defer können Components oder andere Inhalte innerhalb eines spezifischen Component dynamisch geladen werden. Beispielsweise kann ein Component erst geladen werden, sobald er bereitsteht (Alle Dependencies würde aufgelöst). Das würde dann so aussehen:\n1 2 3 @defer { \u003cshopping-cart /\u003e } Zum @defer-Block gibt es noch einige zusätzliche erweiternden Blöcke, die das Laden und Anzeigen verschönern. Hier eine kurze Übersicht:\n@placeholder Standardmässig lädt der @defer-Block keinen Inhalt, was meist unschön ist. Dazu gibt es den @placeholder-Block. Dieser kann als normales Div verwendet werden und beliebigen Inhalt haben. Logischerweise sollte hier kein Inhalt platziert werden, der auch mit Lazy Loading geladen werden muss/soll.\n1 2 3 4 5 @defer { \u003cshopping-cart /\u003e } @placeholder { I'm a placeholder :D } Der Placeholder bleibt so lange stehen, bis der Inhalt des @defer geladen hat. Wenn es gewünscht ist kann eine Mindestzeit bestimmt werden, in der der Placeholder angezeigt werden muss:\n1 2 3 4 5 @defer { \u003cshopping-cart /\u003e } @placeholder (minimum 500ms){ I'm a placeholder :D I will stay here atleast 500ms ;) } @loading Der @loading-Block ähnelt sehr dem @placeholder-Block, jedoch ist im @loading noch eine zusätzliche Option verfügbar. Mit after kann definiert werden, wann der @loading-Block zusehen sein soll. Dieser überschreibt somit ab diesem Zeitpunkt auch den @placeholder-Block.\n1 2 3 4 5 6 7 @defer { \u003cshopping-cart /\u003e } @placeholder { I'm a placeholder :D I will be overwritten in 100ms :'( } @loading (after 100ms; minimum 1s) { \u003cimg alt=\"loading...\" src=\"loading.gif\" /\u003e } Der @loading-Block ist vor allem in Kombination mit den triggers sinnvoll.\n@error Auch der @error-Block macht das, was man sich unter dem Namen vorstellt, wenn das Laden des Inhalts fehlschlägt wird der Inhalt des @error-Blocks angezeigt.\n1 2 3 4 5 @defer { \u003cshopping-cart /\u003e } @error { \u003cp\u003eFailed to load shopping cart :( \u003c/p\u003e } Alle erwähnten Blöcke können natürlich auch aneinander gereiht werden und so eine klare Struktur abbilden: 1 2 3 4 5 6 7 8 9 @defer { \u003ccomment-list/\u003e } @loading { Loading… } @error { Loading failed :( } @placeholder { \u003cimg src=\"shopping-placeholder.png\"\u003e } Defer mit Trigger In einigen Fällen ist es hilfreich, wenn selbst bestimmt werden kann, wann das Lazy Loading beginnt. Dazu wurden den Deferrable Views zusätzlich Triggers hinzugefügt, die den Zeitpunkt des Ladens einschränken.\nViewport Einer dieser Trigger ist der Viewport. Dieser Trigger wird ausgelöst, wenn ein @placeholder im Viewport sichtbar ist. Der Code dazu würde dann ungefähr so aussehen:\n1 2 3 4 5 6 @defer (on viewport) { \u003cshopping-cart /\u003e } @placeholder { \u003c!-- A placeholder content to show until the shopping-cart loads --\u003e \u003cimg src=\"shopping-placeholder.png\"\u003e } Idle Der Trigger idle teilt Angular mit, dass der Inhalt erst geladen werden soll, wenn der Browser keine wichtigen Aufgaben mehr zu erledigen hat.\n1 2 3 4 5 6 @defer (on idle) { \u003cunimportant-info /\u003e } @placeholder { \u003c!-- A placeholder content to show until the unimportant-info loads --\u003e \u003cimg src=\"unimportant-info-placeholder.png\"\u003e } Interaction Der Name interaction verrät bereits, dass der Inhalt hier erst geladen wird, wenn eine Aktion (Klick oder Keydown) auf einem bestimmten Element durchgeführt wird. Standardmässig ist dieses Element der Placeholder.\n1 2 3 4 5 6 @defer (on interaction) { \u003cshopping-cart /\u003e } @placeholder { \u003c!-- A placeholder content to show until the shopping-cart loads --\u003e \u003cimg src=\"shopping-placeholder.png\"\u003e } Ein anderes Element kannst du so bestimmen:\n1 2 3 4 5 6 \u003cbutton type=\"button\" #greeting\u003eHello!\u003c/button\u003e @defer (on interaction(greeting)) { \u003cshopping-cart /\u003e } @placeholder { \u003cdiv\u003eShopping Cart placeholder\u003c/div\u003e } Hier wird also das shopping-cart erst geladen, wenn der Button geklickt wird.\nHover Gleich wie beim Trigger interaction wird hier der Inhalt geladen, wenn über ein Element gehovert wird. Auch hier ist Standardmässig der Placeholder dieses Element.\n1 2 3 4 5 6 @defer (on hover) { \u003cshopping-cart /\u003e } @placeholder { \u003c!-- A placeholder content to show until the shopping-cart loads --\u003e \u003cimg src=\"shopping-placeholder.png\"\u003e } Ein anderes Element kannst du so bestimmen:\n1 2 3 4 5 6 \u003cdiv #greeting\u003eHello!\u003c/div\u003e @defer (on hover(greeting)) { \u003cshopping-cart /\u003e } @placeholder { \u003cdiv\u003eShopping Cart placeholder\u003c/div\u003e } Hier wird also das shopping-cart erst geladen, wenn der über das Hello! gehovert wird.\nTimer Mit dem Timer Trigger kann eine bestimmte Zeit in Millisekunden angegeben werden, die gewartet werden soll, bis das Laden beginnt.\n1 2 3 4 5 6 @defer (on timer(500ms)) { \u003cshopping-cart /\u003e } @placeholder { \u003c!-- A placeholder content to show until the shopping-cart loads --\u003e \u003cimg src=\"shopping-placeholder.png\"\u003e } Immediate Anders als die anderen Trigger wird Immediate nicht verzögert durchgeführt, jedoch wird der Inhalt immer noch mit Lazy Loading geladen. Immediate kann hilfreich sein, wenn es Inhalte gibt, die priorität vor anderen Inhalten haben.\n1 2 3 4 5 6 @defer (on immediate) { \u003cshopping-cart /\u003e } @placeholder { \u003c!-- A placeholder content to show until the shopping-cart loads --\u003e \u003cimg src=\"shopping-placeholder.png\"\u003e } When Mit dem Trigger When kann selbst definiert werden unter welchen Bedingungen ein Inhalt geladen wird. Das When funktioniert grundsätzlich wie ein normales if.\n1 2 3 @defer (when bedingung) { \u003cshopping-cart /\u003e } Prefetching In einigen Anwendungsfällen kann es Sinn machen, wenn der Inhalt eines @defers bereits bei Möglichkeit vorgeladen wird. Wenn beispielsweise ein interaction-Trigger eingesetzt wird und dieser lange nicht ausgelöst wird. Dazu kann das Preloading wie folgt aktiviert werden:\n1 2 3 4 5 @defer (on interaction(greeting); prefetch on idle) { \u003cshopping-cart /\u003e } @placeholder { \u003cdiv\u003eShopping Cart placeholder\u003c/div\u003e } Hier wird zusätzlich zum Trigger noch ein zweiter Trigger für das prefetch eingesetzt. Alle verfügbaren Trigger (inkl. when) sind hier zulässig, jedoch macht z.B. interaction meist wenig Sinn.\n","categories":"","description":"Modul #F6 - Angular - Lazy Loading\n","excerpt":"Modul #F6 - Angular - Lazy Loading\n","ref":"/de/docs/03_web/06_angular/02_14_lazy_loading/","tags":"","title":"Lazy Loading"},{"body":" Dieses Kapitel gehört zum Modul #J1 des Ausbildungsplans Ziele Ich weiss, was ein Array ist und wozu es verwendet wird. Ich kann Arrays deklarieren, instantiieren und initialisieren. Ich kann Werte aus Arrays lesen und in Arrays schreiben. Ich kenne den Unterschied zwischen for und foreach beim Durchlaufen eines Arrays. Ich kann aus einem String mit .split(...) ein Array erzeugen. Ich weiss, wie ein zweidimensionales Array aufgebaut ist und wie man damit arbeitet. ⏱️ Geschätzte Lesezeit: 15 Minuten Einführung Oft müssen in einem Programm mehrere Werte desselben Datentyps zusammen gespeichert werden.\nAnstatt für jeden Wert eine eigene Variable zu erstellen, kann man Arrays verwenden.\nEin Array ist eine feste Sammlung von Elementen, die alle denselben Datentyp haben und über einen Index angesprochen werden. Die Länge eines Arrays wird einmal bei der Erstellung festgelegt.\nDeklaration und Initialisierung Ein Array wird in zwei Schritten erstellt:\nDeklaration – Festlegen des Datentyps und Namens Initialisierung – Erstellen des Array-Objekts und Festlegen der Länge Die Deklaration eines Arrays enthält folgende Bestandteile:\nReihenfolge Bedeutung Beispiel 1. Typ String, int, double, char, ... 2. Eckige Klammern [] 3. Bezeichner / Namen words, numbers, values, letters... In Java müssen wir zum Zeitpunkt der Deklaration eines Arrays folgendes angeben:\nden Datentyp den Namen Konkret können wir so ein String-Array deklarieren:\n1 2 // Deklaration String[] words; Zum Zeitpunkt der Initialisierung müssen wir folgendes angeben:\ndie Grösse Das Code-Beispiel von der “Deklaration” deklariert die Variable words, erstellt das Array-Objekt jedoch noch nicht. Der Operator new wird in Java zum Erstellen von neuen Objekten verwendet:\n1 String[] words = new String[5]; Damit wird ein Array-Objekt der Länge 5 (also mit 5 Elementen) instantiiert. Die fünf Elemente dieses Arrays wurden mit Standardwerten initialisiert. Bei einem Array des Datentyps String ist der Default-Wert null. Alle Werte im Array werden also mit null aufgefüllt.\nWir können die Werte der Array-Elemente auch gleich direkt angeben:\n1 String[] words = { \"Hai\", \"Oktopus\", \"Rochen\", \"Wal\", \"Fisch\" }; Es wird damit ein Array mit der Grösse 5 und den angegebenen Werten erstellt.\nLänge eines Arrays Die Anzahl der Elemente in einem Array wird als Länge eines Arrays bezeichnet. Diese Länge wird zum Zeitpunkt der Erstellung eines Arrays einmal festgelegt. Sie kann später in einem Programm nur durch Definition eines neuen Arrays und dem Kopieren von Werten geändert werden.\nWir können die Länge eines Arrays mithilfe einer in Java integrierten Funktionalität überprüfen:\n1 System.out.println(\"Anzahl Elemente: \" + words.length); Indizierung Die Indizes in einem Array reichen immer von 0 bis length-1. Ein Array mit den ersten 100 natürlichen Zahlen hat beispielsweise eine Länge von 100 und Indizes von 0 bis 99.\n1 2 System.out.println(words[0]); // Erstes Element -\u003e \"Hai\" System.out.println(words[words.length - 1]); // Letztes Element -\u003e \"Fisch\" Das ist eine häufige Fehlerquelle bei Programmen. Es passiert einem immer wieder, dass man für das letzte Element im Array als Index die Länge des Arrays nimmt. Das führt dann zu einer ArrayIndexOutOfBoundsException, welche erst zur Laufzeit auftritt. Werte schreiben Wenn wir den Wert eines Elements in unserem Array verändern möchten, geschieht dies folgendermassen:\n1 words[index] = value; Wenn du also das 4. Element (Index 3) mit dem Wert \"Delfin\" ersetzen möchtest, dann kannst du das wie folgt tun:\n1 2 3 4 5 6 7 8 9 // Aktueller Wert System.out.println(words[3]); // Ausgabe: Wal // Wert ändern words[3] = \"Delfin\"; // Wert lesen String word = words[3]; System.out.println(word); // Ausgabe: Delfin Arrays durchlaufen Im Modul Kontrollstrukturen hast du bereits die for-Schleife kennengelernt. Mit dieser kannst du mit einem index durch das ganze Array iterieren:\n1 2 3 for (int i = 0; i \u003c words.length; i++) { System.out.println(\"Tier: \" + words[i]); } Für Arrays gibt es aber auch noch die foreach-Schleife, welche kürzer und direkter ist:\n1 2 3 for (String word : words) { System.out.println(\"Tier: \" + animal); } foreach eignet sich besonders gut, wenn du alle Elemente durchgehen möchtest und den Index nicht benötigst. Lernvideo Wenn du dir die Erklärung noch mit einem Video anschauen möchtest, empfehlen wir dir dieses Video (Theoretische Erklärung). Lernvideo Wenn du dir die Erklärung noch mit einem Video anschauen möchtest, empfehlen wir dir dieses Video (Anwendung in Java). Arrays und Strings Du hast Strings bereits in einem Modul kennengelernt. Zwei nützliche Methoden welche Strings bieten haben wir dort noch nicht behandelt, weil sie Kentnisse über Arrays voraussetzen.\nStrings in Arrays umwandeln – .split(...) Mit .split(...) können Strings in Arrays aufgeteilt werden:\n1 2 3 4 5 6 String text = \"Apfel,Birne,Kirsche\"; String[] words = text.split(\",\"); for (String word : words) { System.out.println(\"Frucht: \" + word); } Ablauf:\nDer String \"Apfel,Birne,Kirsche\" wird beim Komma getrennt. Es entsteht ein Array mit drei Elementen. Das Array wird mit foreach ausgegeben. Anzufügen ist noch, dass es sich beim Suchbegriff um eine sogenannten Regülären Ausdruck (Regex) handelt welchen wir bald im Module “Reguläre Ausdrücke” behandeln werden.\nArrays in Strings umwandeln - String.join(...) Mit String.join(...) kann man aus einem Array einen String erzeugen.\n1 2 3 4 String[] words = {\"Apfel\", \"Birne\", \"Kirsche\"}; String text = String.join(\",\", words); System.out.println(\"Früchte: \" + text); // Ausgabe: \"Früchte: Apfel,Birne,Kirsche\" Zweidimensionale Arrays is jetzt hast du ausschliesslich Arrays gesehen, die auf eine Dimension beschränkt waren. Diese Arrays sind praktisch, um Listen-Artige Daten zu speichern. Zweidimensionale Arrays haben wie es der Name schon verrät eine zweite Dimension. Diese Art von Arrays sind praktisch für tabellarische Daten.\nDu kannst dir ein 2D-Array wie eine Excel vorstellen. Es besteht aus Reihen und Spalten die gleich wie im normalen Array mit einem Index/einer Position definiert werden.\nFür die Deklaration eines zweidimensionalen Arrays wird eine Angabe von der Anzahl Reihen und Spalten benötigt. Bei dieser Art von Array können die gleichen Datentypen wie bei den normalen Arrays verwendet werden. So sieht schliesslich die Syntax aus:\n1 2 3 int rows = 3; int cols = 2; int[][] matrix = new int[rows][cols]; Da wir jetzt im zweidimensionalen Bereich unterwegs sind, müssen wir für den Zugriff auf Elemente beide Dimensionen beachten. Das bedeutet, dass wir anders als bei einfachen Arrays 2 verschiedene indexe angeben müssen.\nHier ein Beispiel dazu:\n1 2 matrix[0][1] = 42; System.out.println(matrix[0][1]); // Ausgabe: 42 Durchlaufen mit verschachtelten Schleifen Um auf alle Elemente im zweidimensionalen Array zuzugreifen, müssen wir eine verschachtelte for-Schleife verwenden:\n1 2 3 4 5 6 for (int i = 0; i \u003c matrix.length; i++) { for (int j = 0; j \u003c matrix[i].length; j++) { System.out.print(matrix[i][j] + \"\\t\"); } System.out.println(); } Du kannst aber auch eine verschachtelte foreach-Schleife verwenden:\n1 2 3 4 5 6 foreach (int[] row: matrix) { for (int value: row) { System.out.print(value + \"\\t\"); } System.out.println(); } Lernvideo Wenn du dir die Erklärung noch mit einem Video anschauen möchtest, empfehlen wir dir dieses Video. Entschuldige, da fehlt noch was...\n--\u003e Labs konvertieren:\nAufgabe 9\n../../../../labs/02_java/03_java-grundlagen/#aufgabe-9—arrays\n","categories":"","description":"In diesem Modul lernst du, wie man Arrays in Java verwendet, durchläuft und Daten darin speichert oder daraus liest.\n","excerpt":"In diesem Modul lernst du, wie man Arrays in Java verwendet, …","ref":"/docs/02_java/03_java-grundlagen/15_arrays/","tags":"","title":"Arrays"},{"body":"Ziele Ich weiss, was Floating ist und wie es verwendet wird, um Elemente nebeneinander anzuordnen. Ich weiss, was Flexbox ist und wie man display: flex anwendet, um flexible Layouts zu erstellen. Ich kann Media-Queries nutzen, um Flexbox-Layouts auf unterschiedliche Bildschirmgrößen anpassen zu können. Du hast dich vielleicht schon gefragt, wie du mehrere Elemente nebeneinander anordnen kannst. Hierfür müssen zuerst ein paar Worte über Layouting verloren werden.\nFloating Vor dem Zeitalter von Flexboxen und Grids war das Layouting von Webseiten noch um einiges umständlicher. Es gab die Möglichkeit, die Elemente, die man nebeneinander haben wollte, mit float zu positionieren. Das kann aussehen wie folgt:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u003cdiv class=\"container\"\u003e \u003cdiv class=\"box\"\u003eElement 1\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 2\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 3\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 4\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 5\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 6\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 7\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 8\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 9\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 10\u003c/div\u003e \u003c/div\u003e \u003cstyle\u003e .container { overflow: auto; background-color: lightgray; } .box { display: block; float: left; margin: 1em; width: 10em; height: 10em; background-color: orange; } \u003c/style\u003e In diesem Beispiel wurde das Container-div nur zur Demonstration verwendet. Da du diese Technik wahrscheinlich nie benötigen wirst, musst du im Moment auch nicht verstehen, weshalb im Beispiel overflow: auto verwendet wurde.\nWas genau passiert hier? Wichtig ist, dass die mit float platzierten Elemente das Property display: block innehaben (was bei einem \u003cdiv\u003e bereits defaultmässig so ist). Mit float: left werden die Elemente der Reihe nach von links nach rechts angeordnet. Wenn die Elemente über den Rand hinausgehen würden, wird eine neue Zeile begonnen und das Element auf dieser platziert (wrap). Das ist im Grundsatz bereits die ganze Magie.\nÄndere den Wert auf float: right. Nun platziert das erste Element auf der rechten Seite. Was müsstest du machen, damit die Elemente zwar rechtsbündig sind, diese aber trotzdem jeweils links voneinander platziert werden?\nFlexboxen Wenn man das float-Property viel braucht, wird man schnell merken, dass die Anwendung dieser Technik teils sehr umständlich sein kann.\nDie gute Nachricht ist aber, dass man seit der Einführung von Flexboxen kaum mehr auf das manuelle Positionieren mit dem float-Property zurückgreifen muss. Das obenstehende Beispiel kann mithilfe von Flexbox auf die folgende Grösse verkleinert werden:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u003cdiv class=\"flex-container\"\u003e \u003cdiv class=\"box\"\u003eElement 1\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 2\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 3\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 4\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 5\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 6\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 7\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 8\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 9\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 10\u003c/div\u003e \u003c/div\u003e \u003cstyle\u003e .flex-container { display: flex; flex-wrap: wrap; gap: 1em; background-color: lightgray; } .box { width: 10em; height: 10em; background-color: orange; } \u003c/style\u003e Der grosse Unterschied hierbei ist, dass es einen Container braucht, den “flex-container”. Du kannst ein beliebiges Element als Flex-Container definieren, indem du display: flex auf dieses Element anwendest.\nDas flex-wrap-Property ist hingegen nicht zwingend nötig, ist aber in diesem Fall dafür verantwortlich, dass ein Zeilenumbruch gemacht wird, wenn die Elemente über den Rand hinausgehen würden, ansonsten war es das bereits. Interessanterweise müssen weder der Flex-Container noch die Flex-Items das display: block-Property innehaben. In diesem Beispiel könntest du also die \u003cdiv\u003e-Elemente mit \u003cspan\u003e-Elementen (Inline-Element) ersetzen, worauf nach wie vor dasselbe Ergebnis entstehen würde (ist aber grundsätzlich nicht empfehlenswert).\nWenn du keinen Zeilenumbruch (wrap) möchtest, dann kannst du die flex-wrap-Regel entfernen. Wenn du das machst, gilt die width: 10em-Regel nicht immer, beispielsweise wenn es zu wenig Platz gäbe. In diesem Fall kannst du width mit min-width ersetzen oder das flex-shrink: 0-Property auf den Items (.box) setzen. Das flex-shrink: 0-Property bewirkt, dass sich die Items nicht verkleinern, wenn zu wenig Platz vorhanden ist. Beachte in beiden Fällen, dass die Elemente über den Rand hinausgehen würden, wenn zu wenig Platz vorhanden ist!\nDieses Problem kannst du umgehen, indem du im Flex-Container definierst, dass der Teil, der über den Rand hinausgehen würde,\nentweder versteckt / abgeschnitten werden soll (overflow: hidden) oder eine Scrollbar angezeigt werden soll (overflow: auto oder overflow: scroll). Flex-Boxen mit flexiblen Items Prinzipiell sind Flex-Boxen nicht kompliziert, auch wenn man damit durchaus komplexe Layouts bewerkstelligen kann.\nSchaue dir das Video CSS Flexbox in 100 Seconds an. Dort ist die Technologie knackig und interessant zusammengefasst.\nOft möchte man mehrere Spalten nebeneinander positionieren, die alle den gleichen Platz beanspruchen sollen, wobei zugleich alle Spalten zusammen möglichst dynamisch die ganze Breite des Browsers ausnutzen sollen.\nFolgendes Beispiel bewirkt genau das:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \u003cp\u003e Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Maecenas porttitor congue massa. Fusce posuere, magna sed pulvinar ultricies, purus lectus malesuada libero, sit amet commodo magna eros quis urna. Nunc viverra imperdiet enim. Fusce est. \u003c/p\u003e \u003cdiv class=\"flex-container\"\u003e \u003cp style=\"flex: 1\"\u003e Vivamus a tellus. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpisegestas. Proin pharetra nonummy pede. Mauris et orci. Aenean nec lorem. In porttitor. \u003c/p\u003e \u003cp style=\"flex: 1\"\u003e Mauris eget neque at sem venenatis eleifend. Ut nonummy. Fusce aliquet pede non pede. Suspendisse dapibus lorem pellentesque magna. Integer nulla. \u003c/p\u003e \u003cdiv style=\"flex: 1\"\u003e \u003cimg src=\"https://it-ninjas.ch/img/png/Ninja%20Elements_ninja_phone.png\" alt=\"A picture\" style=\"max-width: 100%;\" /\u003e \u003cp\u003eMauris eget neque at sem venenatis eleifend. Ut nonummy.\u003c/p\u003e \u003c/div\u003e \u003c/div\u003e \u003cstyle\u003e .flex-container { display: flex; gap: 1em; } \u003c/style\u003e Mit flex: 1 sagen wir aus, dass jede dieser Spalten genau gleich viel Platz beanspruchen soll. Ändere testweise beim \u003cdiv\u003e mit dem Bild den flex-Wert auf 2. Du wirst sehen, dass dieses \u003cdiv\u003e nun anteilsmässig doppelt so viel Platz beansprucht wie die anderen.\nWelche Zahlen du genau verwendest, spielt keine grosse Rolle. Du kannst beispielsweise auch flex: 25% verwenden, was auch funktioniert. Wichtig zu wissen ist, dass sozusagen alle Flex-Werte zusammenaddiert werden. Wenn du also den flex-Wert des Bild-divs auf 2 geändert hast, so beansprucht dieses div-Element 2 / (1 + 2 + 1) = 2/4 = 50% der Breite. Wenn du diese Rechnung nicht verstehen solltest, frage unbedingt bei einem Praxisbildner nach!\nAusrichtung der Flex-Box Per Default werden die Elemente von links nach rechts angeordnet, was auch durchaus Sinn ergibt. Um Elemente vertikal (also von oben nach unten) anzuordnen, braucht man eigentlich kein spezielles Layout.\nMöchtest du aber beispielsweise bei einem grossen Bildschirm die Elemente horizontal nebeneinander haben, bei einem kleinen Bildschirm aber aus Platzgründen untereinander, so kannst du für kleinere Bildschirme die folgende Regel hinzufügen:\n1 2 3 4 5 @media (max-width: 600px) { .flex-container { flex-direction: column; } } Das @media (max-width: 600px)-Property wird “Media-Query” genannt. Wenn die Breite des Browsers einen bestimmten Wert(in diesem Beispiel 600 Pixel) unterschreitet, dann wird die Regel darin aktiv. Mehr über Media Queries erfährst du hier: https://www.w3schools.com/css/css_rwd_mediaqueries.asp\nBeide Richtungen Bevor wir zum praktischen Teil übergehen, musst du noch zwei Begriffe kennen:\nMainAxis und CrossAxis Hat dein Flex-Container eine horizontale Ausrichtung (default: flex-direction: row), so ist die MainAxis die x-Achse (von links nach rechts) und die CrossAxis die y-Achse (oben nach unten). Bei einer vertikalen Ausrichtung (flex-direction: column) ist das genau umgekehrt.\nFlex-Elemente ausrichten Flexboxen erleichtern das Ausrichten von Inhalten stark.\nDer Einfachheit halber nehmen wir einmal dieses Beispiel:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u003cdiv class=\"flex-container\"\u003e \u003cdiv\u003e1\u003c/div\u003e \u003cdiv\u003e2\u003c/div\u003e \u003cdiv\u003e3\u003c/div\u003e \u003c/div\u003e \u003cstyle\u003e .flex-container { display: flex; height: 20em; background-color: cornflowerblue; } .flex-container \u003e div { background-color: white; width: 100px; height: 100px; margin: 10px; } \u003c/style\u003e Da per Default flex-direction: row gilt, werden die Elemente von oben links nach rechts dargestellt. Um die Elemente horizontal (bzw. auf der MainAxis) zu zentrieren, kannst du folgende Regel auf den Flex-Container anwenden: justify-content: center.\nAuf horizontaler Ebene (MainAxis) kannst du die Elemente zudem auf viele andere Arten ausrichten. Probiere folgende Werte für justify-content (beispielsweise mithilfe der Entwickler-Tools deines Browsers via [F12]!) einmal aus:\ncenter space-around space-between space-evenly flex-start flex-end Möchtest du hingegen die Elemente vertikal (auf der CrossAxis) ausrichten, dann hilft dir die align-items-Regel weiter. Die Elemente kannst du vertikal mit align-items: center zentrieren. Die Elemente kannst du auch oben beziehungsweise unten ausrichten mithlfe von align-items: flex-start oder flex-end.\nHast du Zeilenumbrüche drin, dann kannst du vertikal (auf der CrossAxis) die Abstände noch genauer spezifizieren. Um das auszuprobieren, setze flex-wrap: wrap auf dem Flex-Container und erstelle weitere \u003cdiv\u003e-Elemente darin, damit es genug Elemente hat. Probiere im Flex-Container nun folgende Werte für align-content aus:\ncenter space-around space-between space-evenly flex-start flex-end Wie du gesehen hast, sind die Property-Namen für die Ausrichtung komplizierter, als sie es sein müssten. Deshalb hier noch einmal eine Übersicht:\nUm horizontal (also in der MainAxis) Elemente auszurichten:\njustify-content Um vertikal (also in der CrossAxis) Elemente auszurichten:\nalign-items align-content in Kombination mit flex-wrap: wrap Website-Layout mit Flex-Boxen Theoretisch reicht das Wissen über Flexboxen bereits aus, um eine ganze Seite zu layouten. Damit du ein Gefühl dafür bekommst, schaue dir das unterste Beispiel auf dieser Seite an: https://www.w3schools.com/css/css3_flexbox_responsive.asp\nHilfestellung Hier bekommst du eine gute visuelle Übersicht über die einzelnen Flex-Properties: https://css-tricks.com/snippets/css/a-guide-to-flexbox/#aa-flexbox-properties Hier findest du die von w3schools bereitgestellten wichtigsten Eigenschaften von Flex-Boxen beschrieben: https://www.w3schools.com/css/css3_flexbox.asp Die Definition von Dimensionen - besonders auch der Höhe von Elementen -, sowie Flexlayout und Gridlayout sind komplexe Themen, bei denen gerne Missverständnisse auftreten können. Hier wird die Dokumentation von https://wiki.selfhtml.org/wiki/CSS/Tutorials/Flexbox (deutsch) als Ergänzung empfohlen.\nDisplay-Flex-Properties üben Auf Flexbox Froggy kannst du dein Flexbox-Wissen auf lustige Art und Weise trainieren. Nimm dir kurz Zeit dafür.\n","categories":"","description":"Modul #F3 - HTML und CSS - Layouting von Block-Elementen.\n","excerpt":"Modul #F3 - HTML und CSS - Layouting von Block-Elementen.\n","ref":"/docs/03_web/02_html_css/15_layouting/","tags":"","title":"Layouting"},{"body":"Ziele Ich weiss, was Floating ist und wie es verwendet wird, um Elemente nebeneinander anzuordnen. Ich weiss, was Flexbox ist und wie man display: flex anwendet, um flexible Layouts zu erstellen. Ich kann Media-Queries nutzen, um Flexbox-Layouts auf unterschiedliche Bildschirmgrößen anpassen zu können. Du hast dich vielleicht schon gefragt, wie du mehrere Elemente nebeneinander anordnen kannst. Hierfür müssen zuerst ein paar Worte über Layouting verloren werden.\nFloating Vor dem Zeitalter von Flexboxen und Grids war das Layouting von Webseiten noch um einiges umständlicher. Es gab die Möglichkeit, die Elemente, die man nebeneinander haben wollte, mit float zu positionieren. Das kann aussehen wie folgt:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u003cdiv class=\"container\"\u003e \u003cdiv class=\"box\"\u003eElement 1\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 2\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 3\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 4\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 5\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 6\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 7\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 8\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 9\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 10\u003c/div\u003e \u003c/div\u003e \u003cstyle\u003e .container { overflow: auto; background-color: lightgray; } .box { display: block; float: left; margin: 1em; width: 10em; height: 10em; background-color: orange; } \u003c/style\u003e In diesem Beispiel wurde das Container-div nur zur Demonstration verwendet. Da du diese Technik wahrscheinlich nie benötigen wirst, musst du im Moment auch nicht verstehen, weshalb im Beispiel overflow: auto verwendet wurde.\nWas genau passiert hier? Wichtig ist, dass die mit float platzierten Elemente das Property display: block innehaben (was bei einem \u003cdiv\u003e bereits defaultmässig so ist). Mit float: left werden die Elemente der Reihe nach von links nach rechts angeordnet. Wenn die Elemente über den Rand hinausgehen würden, wird eine neue Zeile begonnen und das Element auf dieser platziert (wrap). Das ist im Grundsatz bereits die ganze Magie.\nÄndere den Wert auf float: right. Nun platziert das erste Element auf der rechten Seite. Was müsstest du machen, damit die Elemente zwar rechtsbündig sind, diese aber trotzdem jeweils links voneinander platziert werden?\nFlexboxen Wenn man das float-Property viel braucht, wird man schnell merken, dass die Anwendung dieser Technik teils sehr umständlich sein kann.\nDie gute Nachricht ist aber, dass man seit der Einführung von Flexboxen kaum mehr auf das manuelle Positionieren mit dem float-Property zurückgreifen muss. Das obenstehende Beispiel kann mithilfe von Flexbox auf die folgende Grösse verkleinert werden:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u003cdiv class=\"flex-container\"\u003e \u003cdiv class=\"box\"\u003eElement 1\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 2\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 3\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 4\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 5\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 6\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 7\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 8\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 9\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 10\u003c/div\u003e \u003c/div\u003e \u003cstyle\u003e .flex-container { display: flex; flex-wrap: wrap; gap: 1em; background-color: lightgray; } .box { width: 10em; height: 10em; background-color: orange; } \u003c/style\u003e Der grosse Unterschied hierbei ist, dass es einen Container braucht, den “flex-container”. Du kannst ein beliebiges Element als Flex-Container definieren, indem du display: flex auf dieses Element anwendest.\nDas flex-wrap-Property ist hingegen nicht zwingend nötig, ist aber in diesem Fall dafür verantwortlich, dass ein Zeilenumbruch gemacht wird, wenn die Elemente über den Rand hinausgehen würden, ansonsten war es das bereits. Interessanterweise müssen weder der Flex-Container noch die Flex-Items das display: block-Property innehaben. In diesem Beispiel könntest du also die \u003cdiv\u003e-Elemente mit \u003cspan\u003e-Elementen (Inline-Element) ersetzen, worauf nach wie vor dasselbe Ergebnis entstehen würde (ist aber grundsätzlich nicht empfehlenswert).\nWenn du keinen Zeilenumbruch (wrap) möchtest, dann kannst du die flex-wrap-Regel entfernen. Wenn du das machst, gilt die width: 10em-Regel nicht immer, beispielsweise wenn es zu wenig Platz gäbe. In diesem Fall kannst du width mit min-width ersetzen oder das flex-shrink: 0-Property auf den Items (.box) setzen. Das flex-shrink: 0-Property bewirkt, dass sich die Items nicht verkleinern, wenn zu wenig Platz vorhanden ist. Beachte in beiden Fällen, dass die Elemente über den Rand hinausgehen würden, wenn zu wenig Platz vorhanden ist!\nDieses Problem kannst du umgehen, indem du im Flex-Container definierst, dass der Teil, der über den Rand hinausgehen würde,\nentweder versteckt / abgeschnitten werden soll (overflow: hidden) oder eine Scrollbar angezeigt werden soll (overflow: auto oder overflow: scroll). Flex-Boxen mit flexiblen Items Prinzipiell sind Flex-Boxen nicht kompliziert, auch wenn man damit durchaus komplexe Layouts bewerkstelligen kann.\nSchaue dir das Video CSS Flexbox in 100 Seconds an. Dort ist die Technologie knackig und interessant zusammengefasst.\nOft möchte man mehrere Spalten nebeneinander positionieren, die alle den gleichen Platz beanspruchen sollen, wobei zugleich alle Spalten zusammen möglichst dynamisch die ganze Breite des Browsers ausnutzen sollen.\nFolgendes Beispiel bewirkt genau das:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \u003cp\u003e Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Maecenas porttitor congue massa. Fusce posuere, magna sed pulvinar ultricies, purus lectus malesuada libero, sit amet commodo magna eros quis urna. Nunc viverra imperdiet enim. Fusce est. \u003c/p\u003e \u003cdiv class=\"flex-container\"\u003e \u003cp style=\"flex: 1\"\u003e Vivamus a tellus. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpisegestas. Proin pharetra nonummy pede. Mauris et orci. Aenean nec lorem. In porttitor. \u003c/p\u003e \u003cp style=\"flex: 1\"\u003e Mauris eget neque at sem venenatis eleifend. Ut nonummy. Fusce aliquet pede non pede. Suspendisse dapibus lorem pellentesque magna. Integer nulla. \u003c/p\u003e \u003cdiv style=\"flex: 1\"\u003e \u003cimg src=\"https://it-ninjas.ch/img/png/Ninja%20Elements_ninja_phone.png\" alt=\"A picture\" style=\"max-width: 100%;\" /\u003e \u003cp\u003eMauris eget neque at sem venenatis eleifend. Ut nonummy.\u003c/p\u003e \u003c/div\u003e \u003c/div\u003e \u003cstyle\u003e .flex-container { display: flex; gap: 1em; } \u003c/style\u003e Mit flex: 1 sagen wir aus, dass jede dieser Spalten genau gleich viel Platz beanspruchen soll. Ändere testweise beim \u003cdiv\u003e mit dem Bild den flex-Wert auf 2. Du wirst sehen, dass dieses \u003cdiv\u003e nun anteilsmässig doppelt so viel Platz beansprucht wie die anderen.\nWelche Zahlen du genau verwendest, spielt keine grosse Rolle. Du kannst beispielsweise auch flex: 25% verwenden, was auch funktioniert. Wichtig zu wissen ist, dass sozusagen alle Flex-Werte zusammenaddiert werden. Wenn du also den flex-Wert des Bild-divs auf 2 geändert hast, so beansprucht dieses div-Element 2 / (1 + 2 + 1) = 2/4 = 50% der Breite. Wenn du diese Rechnung nicht verstehen solltest, frage unbedingt bei einem Praxisbildner nach!\nAusrichtung der Flex-Box Per Default werden die Elemente von links nach rechts angeordnet, was auch durchaus Sinn ergibt. Um Elemente vertikal (also von oben nach unten) anzuordnen, braucht man eigentlich kein spezielles Layout.\nMöchtest du aber beispielsweise bei einem grossen Bildschirm die Elemente horizontal nebeneinander haben, bei einem kleinen Bildschirm aber aus Platzgründen untereinander, so kannst du für kleinere Bildschirme die folgende Regel hinzufügen:\n1 2 3 4 5 @media (max-width: 600px) { .flex-container { flex-direction: column; } } Das @media (max-width: 600px)-Property wird “Media-Query” genannt. Wenn die Breite des Browsers einen bestimmten Wert(in diesem Beispiel 600 Pixel) unterschreitet, dann wird die Regel darin aktiv. Mehr über Media Queries erfährst du hier: https://www.w3schools.com/css/css_rwd_mediaqueries.asp\nBeide Richtungen Bevor wir zum praktischen Teil übergehen, musst du noch zwei Begriffe kennen:\nMainAxis und CrossAxis Hat dein Flex-Container eine horizontale Ausrichtung (default: flex-direction: row), so ist die MainAxis die x-Achse (von links nach rechts) und die CrossAxis die y-Achse (oben nach unten). Bei einer vertikalen Ausrichtung (flex-direction: column) ist das genau umgekehrt.\nFlex-Elemente ausrichten Flexboxen erleichtern das Ausrichten von Inhalten stark.\nDer Einfachheit halber nehmen wir einmal dieses Beispiel:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u003cdiv class=\"flex-container\"\u003e \u003cdiv\u003e1\u003c/div\u003e \u003cdiv\u003e2\u003c/div\u003e \u003cdiv\u003e3\u003c/div\u003e \u003c/div\u003e \u003cstyle\u003e .flex-container { display: flex; height: 20em; background-color: cornflowerblue; } .flex-container \u003e div { background-color: white; width: 100px; height: 100px; margin: 10px; } \u003c/style\u003e Da per Default flex-direction: row gilt, werden die Elemente von oben links nach rechts dargestellt. Um die Elemente horizontal (bzw. auf der MainAxis) zu zentrieren, kannst du folgende Regel auf den Flex-Container anwenden: justify-content: center.\nAuf horizontaler Ebene (MainAxis) kannst du die Elemente zudem auf viele andere Arten ausrichten. Probiere folgende Werte für justify-content (beispielsweise mithilfe der Entwickler-Tools deines Browsers via [F12]!) einmal aus:\ncenter space-around space-between space-evenly flex-start flex-end Möchtest du hingegen die Elemente vertikal (auf der CrossAxis) ausrichten, dann hilft dir die align-items-Regel weiter. Die Elemente kannst du vertikal mit align-items: center zentrieren. Die Elemente kannst du auch oben beziehungsweise unten ausrichten mithlfe von align-items: flex-start oder flex-end.\nHast du Zeilenumbrüche drin, dann kannst du vertikal (auf der CrossAxis) die Abstände noch genauer spezifizieren. Um das auszuprobieren, setze flex-wrap: wrap auf dem Flex-Container und erstelle weitere \u003cdiv\u003e-Elemente darin, damit es genug Elemente hat. Probiere im Flex-Container nun folgende Werte für align-content aus:\ncenter space-around space-between space-evenly flex-start flex-end Wie du gesehen hast, sind die Property-Namen für die Ausrichtung komplizierter, als sie es sein müssten. Deshalb hier noch einmal eine Übersicht:\nUm horizontal (also in der MainAxis) Elemente auszurichten:\njustify-content Um vertikal (also in der CrossAxis) Elemente auszurichten:\nalign-items align-content in Kombination mit flex-wrap: wrap Website-Layout mit Flex-Boxen Theoretisch reicht das Wissen über Flexboxen bereits aus, um eine ganze Seite zu layouten. Damit du ein Gefühl dafür bekommst, schaue dir das unterste Beispiel auf dieser Seite an: https://www.w3schools.com/css/css3_flexbox_responsive.asp\nHilfestellung Hier bekommst du eine gute visuelle Übersicht über die einzelnen Flex-Properties: https://css-tricks.com/snippets/css/a-guide-to-flexbox/#aa-flexbox-properties Hier findest du die von w3schools bereitgestellten wichtigsten Eigenschaften von Flex-Boxen beschrieben: https://www.w3schools.com/css/css3_flexbox.asp Die Definition von Dimensionen - besonders auch der Höhe von Elementen -, sowie Flexlayout und Gridlayout sind komplexe Themen, bei denen gerne Missverständnisse auftreten können. Hier wird die Dokumentation von https://wiki.selfhtml.org/wiki/CSS/Tutorials/Flexbox (deutsch) als Ergänzung empfohlen.\nDisplay-Flex-Properties üben Auf Flexbox Froggy kannst du dein Flexbox-Wissen auf lustige Art und Weise trainieren. Nimm dir kurz Zeit dafür.\n","categories":"","description":"Modul #F3 - HTML und CSS - Layouting von Block-Elementen.\n","excerpt":"Modul #F3 - HTML und CSS - Layouting von Block-Elementen.\n","ref":"/de/docs/03_web/02_html_css/15_layouting/","tags":"","title":"Layouting"},{"body":"Ziele Du weisst, was Promises sind und wozu sie verwendet werden. Du kannst Promises in Funktionen korrekt anwenden. Promises Ein Promise repräsentiert einen Wert, der möglicherweise in der Zukunft verfügbar sein wird.\nPromises werden oft verwendet, um asynchrone Operationen wie das Laden von Daten von einem Server oder das Ausführen eines HTTP-Requests zu verwalten. Ein Promise kann sich in einem von drei Zuständen befinden:\nPending (ausstehend): Das Promise ist noch nicht erfüllt (resolved) oder abgelehnt (rejected) worden. Fulfilled (erfüllt): Die asynchrone Operation wurde erfolgreich abgeschlossen (resolved) und der Promise enthält den gelieferten Wert. Rejected (abgelehnt): Die asynchrone Operation ist fehlgeschlagen und das Promise enthält den jeweiligen Fehler. Ein Promise kann mit der Funktion new Promise() erstellt werden. Diese Funktion nimmt eine Funktion als Argument, die zwei Parameter enthält: resolve und reject. resolve wird aufgerufen, wenn die Operation erfolgreich abgeschlossen wurde, und reject, wenn ein Fehler aufgetreten ist.\n1 2 3 4 5 6 7 const promise = new Promise((resolve, reject) =\u003e { if (success) { resolve(\"success\"); } else { reject(\"error\"); } }); Promises bieten zwei Methoden an, um mit dem Ergebnis oder dem Fehler der asynchronen Operation umzugehen:\nthen() catch() Die then() Methode wird verwendet, um eine Funktion zu registrieren, die ausgeführt wird, wenn das Promise erfolgreich erfüllt wird. Diese Funktion erhält das Ergebnis des erfüllten Promise als Parameter:\n1 2 3 4 5 const promise = new Promise((resolve, reject) =\u003e resolve(\"success\")); promise.then((result) =\u003e { console.log(result); // 'success' }); Die then()-Methode kann auch mehrmals hintereinander verwendet werden, um eine Kette von Funktionen zu erstellen, die nacheinander ausgeführt werden, wenn das Promise erfüllt wird.\nDurch die Verwendung von then() in Kombination mit return in jeder Funktion kann eine Kette von Funktionen erstellt werden, die nacheinander ausgeführt werden, wobei jedes Ergebnis das Argument für die nächste Funktion in der Kette ist.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 const promise = new Promise((resolve, reject) =\u003e resolve(2)); promise .then((result) =\u003e { console.log(result); // 2 return result * 2; }) .then((result) =\u003e { console.log(result); // 4 return result * 2; }) .then((result) =\u003e { console.log(result); // 8 }); Die catch() Methode wird verwendet, um eine Funktion zu registrieren, die ausgeführt wird, wenn das Promise fehlschlägt. Diese Funktion erhält den Fehler als Parameter.\n1 2 3 4 5 const promise = new Promise((resolve, reject) =\u003e reject(\"error\")); promise.catch((result) =\u003e { console.log(result); // 'error' }); then() und catch() werden fast immer zusammen verwendet:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const number = 10; const promise = new Promise((resolve, reject) =\u003e { if (number \u003e 0) { resolve(\"success\"); } else { reject(\"error\"); } }); promise .then((result) =\u003e { console.log(result); // 'success' }) .catch((error) =\u003e { console.error(error); // 'error' }); Promises als Function Promises in Funktionen zu integrieren ist eine gängige Praxis in JavaScript, um asynchrone Operationen und Callbacks zu verwalten. Indem man Promises in Funktionen einbettet, kann man sicherstellen, dass die asynchronen Operationen sequentiell ausgeführt werden und man eine klare Struktur im Code hat.\nDazu muss man das gesamte Promise in der Funktion returnen:\n1 2 3 4 5 6 7 8 9 function promiseFunction(number) { return new Promise((resolve, reject) =\u003e { if (number \u003e 0) { resolve(\"success\"); } else { reject(\"error\"); } }); } Nun kann man diese Funktion innerhalb von anderen Funktionen verwenden. Wichtig ist, dass diese mit await gekennzeichnet sein müssen, um auf das Ergebnis des Promises zu warten, bevor der Rest der Funktion fortgesetzt wird. So kann man sicher gehen, dass das Resultat aus dem Promise zur Verfügung steht und es danach in der Funktion verwendet werden kann. Wenn man jedoch ein await in einer Funktion verwendet, muss die gesamte Funktion asynchron sein. Dazu muss die Funktion mit async gekennzeichnet sein.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function promiseFunction(number) { return new Promise((resolve, reject) =\u003e { if (number \u003e 0) { resolve(\"success\"); } else { reject(\"error\"); } }); } async function callPromiseFunction() { const successResult = await promiseFunction(10); console.log(successResult); const errorResult = await promiseFunction(-5); console.log(errorResult); } callPromiseFunction(); // 'success' // Promise {\u003crejected\u003e: 'error'} Ohne das async-Keyword wäre es nämlich so, dass der Code je nachdem bereits weiter durchläuft, bevor das Promise erfüllt wurde und ein Resultat vorliegt.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 function promiseFunction(number) { return new Promise((resolve, reject) =\u003e { if (number \u003e 0) { resolve(\"success\"); } else { reject(\"error\"); } }); } function callPromiseFunction() { const promise = promiseFunction(10) .then((result) =\u003e { console.log(result); }) .catch((error) =\u003e { console.error(error); }); console.log(promise); } callPromiseFunction(); // Promise {\u003cpending\u003e} // 'success' ","categories":"","description":"Modul #F4 - JavaScript - Promises.\n","excerpt":"Modul #F4 - JavaScript - Promises.\n","ref":"/docs/03_web/03_javascript/16_async/","tags":"","title":"Promises"},{"body":"Ziele Du weisst, was Promises sind und wozu sie verwendet werden. Du kannst Promises in Funktionen korrekt anwenden. Promises Ein Promise repräsentiert einen Wert, der möglicherweise in der Zukunft verfügbar sein wird.\nPromises werden oft verwendet, um asynchrone Operationen wie das Laden von Daten von einem Server oder das Ausführen eines HTTP-Requests zu verwalten. Ein Promise kann sich in einem von drei Zuständen befinden:\nPending (ausstehend): Das Promise ist noch nicht erfüllt (resolved) oder abgelehnt (rejected) worden. Fulfilled (erfüllt): Die asynchrone Operation wurde erfolgreich abgeschlossen (resolved) und der Promise enthält den gelieferten Wert. Rejected (abgelehnt): Die asynchrone Operation ist fehlgeschlagen und das Promise enthält den jeweiligen Fehler. Ein Promise kann mit der Funktion new Promise() erstellt werden. Diese Funktion nimmt eine Funktion als Argument, die zwei Parameter enthält: resolve und reject. resolve wird aufgerufen, wenn die Operation erfolgreich abgeschlossen wurde, und reject, wenn ein Fehler aufgetreten ist.\n1 2 3 4 5 6 7 const promise = new Promise((resolve, reject) =\u003e { if (success) { resolve(\"success\"); } else { reject(\"error\"); } }); Promises bieten zwei Methoden an, um mit dem Ergebnis oder dem Fehler der asynchronen Operation umzugehen:\nthen() catch() Die then() Methode wird verwendet, um eine Funktion zu registrieren, die ausgeführt wird, wenn das Promise erfolgreich erfüllt wird. Diese Funktion erhält das Ergebnis des erfüllten Promise als Parameter:\n1 2 3 4 5 const promise = new Promise((resolve, reject) =\u003e resolve(\"success\")); promise.then((result) =\u003e { console.log(result); // 'success' }); Die then()-Methode kann auch mehrmals hintereinander verwendet werden, um eine Kette von Funktionen zu erstellen, die nacheinander ausgeführt werden, wenn das Promise erfüllt wird.\nDurch die Verwendung von then() in Kombination mit return in jeder Funktion kann eine Kette von Funktionen erstellt werden, die nacheinander ausgeführt werden, wobei jedes Ergebnis das Argument für die nächste Funktion in der Kette ist.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 const promise = new Promise((resolve, reject) =\u003e resolve(2)); promise .then((result) =\u003e { console.log(result); // 2 return result * 2; }) .then((result) =\u003e { console.log(result); // 4 return result * 2; }) .then((result) =\u003e { console.log(result); // 8 }); Die catch() Methode wird verwendet, um eine Funktion zu registrieren, die ausgeführt wird, wenn das Promise fehlschlägt. Diese Funktion erhält den Fehler als Parameter.\n1 2 3 4 5 const promise = new Promise((resolve, reject) =\u003e reject(\"error\")); promise.catch((result) =\u003e { console.log(result); // 'error' }); then() und catch() werden fast immer zusammen verwendet:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const number = 10; const promise = new Promise((resolve, reject) =\u003e { if (number \u003e 0) { resolve(\"success\"); } else { reject(\"error\"); } }); promise .then((result) =\u003e { console.log(result); // 'success' }) .catch((error) =\u003e { console.error(error); // 'error' }); Promises als Function Promises in Funktionen zu integrieren ist eine gängige Praxis in JavaScript, um asynchrone Operationen und Callbacks zu verwalten. Indem man Promises in Funktionen einbettet, kann man sicherstellen, dass die asynchronen Operationen sequentiell ausgeführt werden und man eine klare Struktur im Code hat.\nDazu muss man das gesamte Promise in der Funktion returnen:\n1 2 3 4 5 6 7 8 9 function promiseFunction(number) { return new Promise((resolve, reject) =\u003e { if (number \u003e 0) { resolve(\"success\"); } else { reject(\"error\"); } }); } Nun kann man diese Funktion innerhalb von anderen Funktionen verwenden. Wichtig ist, dass diese mit await gekennzeichnet sein müssen, um auf das Ergebnis des Promises zu warten, bevor der Rest der Funktion fortgesetzt wird. So kann man sicher gehen, dass das Resultat aus dem Promise zur Verfügung steht und es danach in der Funktion verwendet werden kann. Wenn man jedoch ein await in einer Funktion verwendet, muss die gesamte Funktion asynchron sein. Dazu muss die Funktion mit async gekennzeichnet sein.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function promiseFunction(number) { return new Promise((resolve, reject) =\u003e { if (number \u003e 0) { resolve(\"success\"); } else { reject(\"error\"); } }); } async function callPromiseFunction() { const successResult = await promiseFunction(10); console.log(successResult); const errorResult = await promiseFunction(-5); console.log(errorResult); } callPromiseFunction(); // 'success' // Promise {\u003crejected\u003e: 'error'} Ohne das async-Keyword wäre es nämlich so, dass der Code je nachdem bereits weiter durchläuft, bevor das Promise erfüllt wurde und ein Resultat vorliegt.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 function promiseFunction(number) { return new Promise((resolve, reject) =\u003e { if (number \u003e 0) { resolve(\"success\"); } else { reject(\"error\"); } }); } function callPromiseFunction() { const promise = promiseFunction(10) .then((result) =\u003e { console.log(result); }) .catch((error) =\u003e { console.error(error); }); console.log(promise); } callPromiseFunction(); // Promise {\u003cpending\u003e} // 'success' ","categories":"","description":"Modul #F4 - JavaScript - Promises.\n","excerpt":"Modul #F4 - JavaScript - Promises.\n","ref":"/de/docs/03_web/03_javascript/16_async/","tags":"","title":"Promises"},{"body":"Ziele Du weisst, was Interceptors in Angular sind und kannst diese anwenden. Interceptor Interceptors in Angular sind eine Funktionalität des Frameworks, die es ermöglicht, HTTP-Requests global abzufangen und zu verändern, bevor sie an den Server gesendet werden. Das ist sehr praktisch, wenn wir Authentifizierungs-Tokens konfigurieren, Protokolle der Requests erstellen und benutzerdefinierte Header zur Request hinzufügen wollen.\nUm einen Interceptor zu implementieren, müssen wir eine Klasse erstellen, die die Intercept Methode des HttpInterceptor Interface implementiert.\nDer folgende Interceptor ist sehr simpel gehalten. Er gibt jede generierte Request in der Konsole aus:\n1 2 3 4 5 6 7 8 9 10 @Injectable() export class RequestLogInterceptor implements HttpInterceptor { intercept( request: HttpRequest\u003cany\u003e, next: HttpHandler, ): Observable\u003cHttpEvent\u003cany\u003e\u003e { console.log(request.url); return next.handle(request); } } Die Intercept-Methode wandelt jede Request in Observables um, die später durch das Aufrufen von next.handle() aufgelöst werden. Für unsere Implementierung ist es also recht simpel: Wir nehmen den Request entgegen, protokollieren die URL und rufen next.handle() auf, um die Request an den Server zu senden, ohne Änderungen daran vorzunehmen.\nInterceptors unter der Benutzung von Modules Providen Da die Interceptors eine Dependency des HttpClients sind, müssen diese als Provider im gleichen Injektor wie der HttpClient bereitgestellt werden. Angenommen, wir haben unser HttpClientModule in das AppModule importiert, müssen wir die Interceptors hier zu den Providern hinzufügen.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //... import { HTTP_INTERCEPTORS } from \"@angular/common/http\"; import { RequestLogInterceptor } from \"...\"; @NgModule({ //.. imports: [ HttpClientModule, // .. ], providers: [ { provide: HTTP_INTERCEPTORS, useClass: RequestLogInterceptor, multi: true, }, // .. ], // .. }) export class AppModule {} Die Option multi: true teilt Angular mit, dass wir mehrere Interceptors bereitstellen. Diese Einstellung muss daher auch nur in diesem Fall gemacht werden. In unserem Beispielszenario wäre dies also nicht erforderlich, da wir nur einen Interceptor implementiert haben.\nEbenfalls wichtig zu berücksichtigen ist, dass Angular Interceptors in der Reihenfolge anwendet, in der sie bei den Providers des Moduls angegeben sind.\nInterceptors in Angular 19 Angular 17 brachte auch bei den Interceptors einige Änderungen mit sich. Da nun ja nicht mehr standardmässig mit modules gearbeitet wird, müssen sie anders angegeben werden. Das wird jetzt von der app.config.ts übernommen.\nIn der app.config.ts muss man nun den provideHttpClient(withInterceptors([AuthInterceptor]))-Teil angeben. in den eckigen klammern von withInterceptors gibt man die definierten Konstanten an.\n1 2 3 4 5 6 7 8 9 10 11 12 13 import { ApplicationConfig } from \"@angular/core\"; import { provideRouter } from \"@angular/router\"; import { routes } from \"./app.routes\"; import { provideHttpClient, withInterceptors } from \"@angular/common/http\"; import { AuthInterceptor } from \"./interceptors/auth.interceptor\"; export const appConfig: ApplicationConfig = { providers: [ provideRouter(routes), provideHttpClient(withInterceptors([AuthInterceptor])), ], }; Zudem ist der Interceptor keine class mehr, welche mit implements implementiert wird. Er ist nun einfach eine Konstante mit dem Typ eines Interceptors. Ansonsten funktioniert alles gleich wie zuvor.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { HttpRequest, HttpEvent, HttpInterceptorFn, HttpHandlerFn, } from \"@angular/common/http\"; import { Observable } from \"rxjs\"; export const AuthInterceptor: HttpInterceptorFn = ( req: HttpRequest\u003cany\u003e, next: HttpHandlerFn, ): Observable\u003cHttpEvent\u003cany\u003e\u003e =\u003e { console.log(request.url); return next.handle(request); }; Beispiel für eine Authentifizierung in der das Passwort und der Benutzer, welche mit Base64 verschlüsselt wurden (btoa), im Header versendet werden. Das jedoch nur, wenn es keine GET-Request ist.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import { HttpRequest, HttpEvent, HttpInterceptorFn, HttpHandlerFn, } from \"@angular/common/http\"; import { Observable } from \"rxjs\"; export const AuthInterceptor: HttpInterceptorFn = ( req: HttpRequest\u003cany\u003e, next: HttpHandlerFn, ): Observable\u003cHttpEvent\u003cany\u003e\u003e =\u003e { if (req.method !== \"GET\") { const authRequest = req.clone({ setHeaders: { \"Content-Type\": \"application/json\", Authorization: \"Basic \" + btoa(\"admin:admin\"), }, }); return next(authRequest); } return next(req); }; ","categories":"","description":"Modul #F6 - Angular - Interceptors\n","excerpt":"Modul #F6 - Angular - Interceptors\n","ref":"/docs/03_web/06_angular/02_15_interceptors/","tags":"","title":"Interceptors"},{"body":"Ziele Du weisst, was Interceptors in Angular sind und kannst diese anwenden. Interceptor Interceptors in Angular sind eine Funktionalität des Frameworks, die es ermöglicht, HTTP-Requests global abzufangen und zu verändern, bevor sie an den Server gesendet werden. Das ist sehr praktisch, wenn wir Authentifizierungs-Tokens konfigurieren, Protokolle der Requests erstellen und benutzerdefinierte Header zur Request hinzufügen wollen.\nUm einen Interceptor zu implementieren, müssen wir eine Klasse erstellen, die die Intercept Methode des HttpInterceptor Interface implementiert.\nDer folgende Interceptor ist sehr simpel gehalten. Er gibt jede generierte Request in der Konsole aus:\n1 2 3 4 5 6 7 8 9 10 @Injectable() export class RequestLogInterceptor implements HttpInterceptor { intercept( request: HttpRequest\u003cany\u003e, next: HttpHandler, ): Observable\u003cHttpEvent\u003cany\u003e\u003e { console.log(request.url); return next.handle(request); } } Die Intercept-Methode wandelt jede Request in Observables um, die später durch das Aufrufen von next.handle() aufgelöst werden. Für unsere Implementierung ist es also recht simpel: Wir nehmen den Request entgegen, protokollieren die URL und rufen next.handle() auf, um die Request an den Server zu senden, ohne Änderungen daran vorzunehmen.\nInterceptors unter der Benutzung von Modules Providen Da die Interceptors eine Dependency des HttpClients sind, müssen diese als Provider im gleichen Injektor wie der HttpClient bereitgestellt werden. Angenommen, wir haben unser HttpClientModule in das AppModule importiert, müssen wir die Interceptors hier zu den Providern hinzufügen.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //... import { HTTP_INTERCEPTORS } from \"@angular/common/http\"; import { RequestLogInterceptor } from \"...\"; @NgModule({ //.. imports: [ HttpClientModule, // .. ], providers: [ { provide: HTTP_INTERCEPTORS, useClass: RequestLogInterceptor, multi: true, }, // .. ], // .. }) export class AppModule {} Die Option multi: true teilt Angular mit, dass wir mehrere Interceptors bereitstellen. Diese Einstellung muss daher auch nur in diesem Fall gemacht werden. In unserem Beispielszenario wäre dies also nicht erforderlich, da wir nur einen Interceptor implementiert haben.\nEbenfalls wichtig zu berücksichtigen ist, dass Angular Interceptors in der Reihenfolge anwendet, in der sie bei den Providers des Moduls angegeben sind.\nInterceptors in Angular 19 Angular 17 brachte auch bei den Interceptors einige Änderungen mit sich. Da nun ja nicht mehr standardmässig mit modules gearbeitet wird, müssen sie anders angegeben werden. Das wird jetzt von der app.config.ts übernommen.\nIn der app.config.ts muss man nun den provideHttpClient(withInterceptors([AuthInterceptor]))-Teil angeben. in den eckigen klammern von withInterceptors gibt man die definierten Konstanten an.\n1 2 3 4 5 6 7 8 9 10 11 12 13 import { ApplicationConfig } from \"@angular/core\"; import { provideRouter } from \"@angular/router\"; import { routes } from \"./app.routes\"; import { provideHttpClient, withInterceptors } from \"@angular/common/http\"; import { AuthInterceptor } from \"./interceptors/auth.interceptor\"; export const appConfig: ApplicationConfig = { providers: [ provideRouter(routes), provideHttpClient(withInterceptors([AuthInterceptor])), ], }; Zudem ist der Interceptor keine class mehr, welche mit implements implementiert wird. Er ist nun einfach eine Konstante mit dem Typ eines Interceptors. Ansonsten funktioniert alles gleich wie zuvor.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { HttpRequest, HttpEvent, HttpInterceptorFn, HttpHandlerFn, } from \"@angular/common/http\"; import { Observable } from \"rxjs\"; export const AuthInterceptor: HttpInterceptorFn = ( req: HttpRequest\u003cany\u003e, next: HttpHandlerFn, ): Observable\u003cHttpEvent\u003cany\u003e\u003e =\u003e { console.log(request.url); return next.handle(request); }; Beispiel für eine Authentifizierung in der das Passwort und der Benutzer, welche mit Base64 verschlüsselt wurden (btoa), im Header versendet werden. Das jedoch nur, wenn es keine GET-Request ist.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import { HttpRequest, HttpEvent, HttpInterceptorFn, HttpHandlerFn, } from \"@angular/common/http\"; import { Observable } from \"rxjs\"; export const AuthInterceptor: HttpInterceptorFn = ( req: HttpRequest\u003cany\u003e, next: HttpHandlerFn, ): Observable\u003cHttpEvent\u003cany\u003e\u003e =\u003e { if (req.method !== \"GET\") { const authRequest = req.clone({ setHeaders: { \"Content-Type\": \"application/json\", Authorization: \"Basic \" + btoa(\"admin:admin\"), }, }); return next(authRequest); } return next(req); }; ","categories":"","description":"Modul #F6 - Angular - Interceptors\n","excerpt":"Modul #F6 - Angular - Interceptors\n","ref":"/de/docs/03_web/06_angular/02_15_interceptors/","tags":"","title":"Interceptors"},{"body":" Voraussetzung Ich kann mit Regex Zeichenketten im Text erkennen und extrahieren. Ich verstehe, wie man Regex schrittweise und sicher testet. Wir stellen dir bei den Übungen jeweils komplette Projekte zur Verfügung. Du musst grundsätzlich nur dort was anpassen, wo die folgende Kommentarzeile steht:\nKopieren // IT-Ninja: Füge hier Deinen Code ein: 1 // IT-Ninja: Füge hier Deinen Code ein: Alles andere kannst du für den Moment ignorieren. Wir erklären dir die einzelnen Zeilen Schritt für Schritt in den Modulen.\nVorbereitungsarbeiten Drücke auf den Pfeil links um eine detaillierte Anleitung zu erhalten, wie Du den Quellcode auf deinem Rechner ablegen sollst.\nDiese Schritte musst du bei jeder Übung erneut machen. Jede Übung hat ein eigenes ZIP-File, welches du bei dir an die richtige Stelle kopieren musst. Die Anleitung zeigt dir ziemlich gut, wie das geht… Liess vor allem am Anfang die detaillierte Anleitung gut durch und befolge die Schritte exakt. Sie helfen dir, deinen Quellcode gut organisiert, strukturiert und sicher zu verwalten. Falls du die Anleitung schon auswendig kennst, findest du den Quellcode zur Übung direkt hier: Download | Online anschauen\nNeu bei it-ninja?\nDie Anleitung enthält einige Befehle und Fachbegriffe, die dir möglicherweise noch nichts sagen. Mach dir deswegen keine Sorgen – in den kommenden Modulen erklären wir dir alles Schritt für Schritt. Schon bald wirst auch du ein it-ninja sein. Um die folgenden Aufgaben erfolgreich umzusetzen, führe diese Schritte aus:\nBeim ersten Mal:\nIntelliJ IDEA installieren → !*IntelliJ IDEA einrichten Git-Repository einrichten → !*Persönliches Git-Repository Öffne eine !*CMD-Shell und wechsle ins Verzeichnis deines Git-Repositories:\nKopieren cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git status 1 2 cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git status Kopieren cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git status 1 2 cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git status Stelle sicher, dass alle Dateien im Git-Repository committed sind. Mit git status erhältst du eine Übersicht: Kopieren git status 1 git status Falls du bei diesem Befehl einen roten Text siehst, musst du zuerst die aktuellen Dateien sichern:\nKopieren git add . git commit -m \"[gescheiter Kommentar]\" 1 2 git add . git commit -m \"[gescheiter Kommentar]\" Erstelle oder wechsle in den Template Branch:\nBeim ersten Mal musst du einen Template Branch erstellen:\nKopieren git checkout -b \"templates\" 1 git checkout -b \"templates\" Falls er bereits existiert, kannst du einfach switchen:\nKopieren git switch \"templates\" 1 git switch \"templates\" Lade den Source-Code zu den Übungen herunter und entpacke ihn im Root-Verzeichnis deines lokalen Repositories:\n[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\nDen Source-Code findest du hier: Download | Online anschauen\nCommitte den originalen Source-Code, damit er sicher im Repository gespeichert ist:\nKopieren git add . git commit -m \"Add it-ninja_02_java_03_java-grundlagen_16_regex\" git push 1 2 3 git add . git commit -m \"Add it-ninja_02_java_03_java-grundlagen_16_regex\" git push Erstelle einen neuen Branch, um deine Lösung zu implementieren: Kopieren git checkout -b \"labs/it-ninja_02_java_03_java-grundlagen_16_regex\" 1 git checkout -b \"labs/it-ninja_02_java_03_java-grundlagen_16_regex\" Hier kannst du auch einen kürzeren Namen wählen. Verwende labs am Anfang des Branch-Namens für Branches, die deinen eigenen Code enthalten.\nStelle dir einen Branch vorerst als Ordner vor. Jeder Ordner enthält eine Version oder einen Stand von deinem Quellcode. Du kannst dann mit git zwischen diesen Ordern hin und her wechseln, sie vergleichen aber später auch zusammenführen.\nPro-Tipp:\nDu kannst jederzeit einen weiteren Branch erstellen – z. B. wenn du etwas ausprobieren möchtest. Alternativ kannst du auch in der Git-History einen alten Stand wiederherstellen, was aber weniger flexibel ist. Starte IntelliJ und öffne mit File → Open das Verzeichnis mit dem Source-Code. Du musst mit IntelliJ den Ordner suchen, welches einen Ordner src oder die Datei pom.xml enthält. Ansonsten wird IntelliJ Mühe haben, dir das Programm zu kompilieren. Wenn du alles korrekt gemacht hast, findest du das Projekt hier:\nKopieren `[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\\02_java\\03_java-grundlagen\\16_regex` 1 `[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\\02_java\\03_java-grundlagen\\16_regex` Kopieren `[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\\02_java/03_java-grundlagen/16_regex` 1 `[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\\02_java/03_java-grundlagen/16_regex` Falls du zum ersten Mal mit IntelliJ arbeitest, findest du !*hier eine Anleitung, wie man ein Programm startet. Um das Programm zu starten musst du jeweils die Datei Main.java öffenen. Dann sollte in IntelliJ oben rechts ein grünes Dreieck vorhanden sein, welches das Programm startet. Nun bist du bereit, die untenstehenden Aufgaben zu lösen.\nWenn du alle Änderungen gemacht hast und mit der Übung fertig bist, oder einen ‘Zwischenstand’ festhalten willst, führe die folgenden Befehle aus um das Repository auf dem Server zu speichern (von wo du es geklont hast):\nKopieren cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git add --all git commit -m \"Kurzer Kommentar\" 1 2 3 cd /d \"[[itninja_localrepo|C:\\Users\\u123456\\repos.local\\it-ninjas-lab]]\" git add --all git commit -m \"Kurzer Kommentar\" Kopieren cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git add . git commit -m \"Kurzer Kommentar\" 1 2 3 cd \"[[itninja_localrepo|/home/u123456/repos.local/it-ninjas-lab]]\" git add . git commit -m \"Kurzer Kommentar\" Wenn du deine Änderungen auf dem Git-Server sichern willst, musst du das mit einem push machen.\nBeim ersten mal musst du git noch mitteilen, wie der Branch auf dem Git-Server heissen soll:\nKopieren git push --set-upstream origin labs/it-ninja_02_java_03_java-grundlagen_16_regex 1 git push --set-upstream origin labs/it-ninja_02_java_03_java-grundlagen_16_regex Bei weiteren pushes wird es dann einfacher:\nKopieren git push 1 git push Die meisten Übungen sind professionell strukturiert – so wie in echten Softwareprojekten. Zu gutem Code gehören auch Tests, die sicherstellen, dass dein Code wie erwartet funktioniert. Sofern nicht anders erwähnt, kannst du mit folgendem Befehl im Root-Verzeichnis des Projekts (dort, wo sich auch die pom.xml befindet) überprüfen, ob du die Aufgabe korrekt gelöst hast:\n1 mvn test Viel Erfolg!\nAufgabe 1 - E-Mail-Adressen aus einem Text extrahieren Schreibe eine Regex, die alle E-Mail-Adressen in einem Text findet. Nutze die bereitgestellte Beispieldatei data/mixed.txt. \u003c/itninja description\u003e\nBeispieleingabe: Meine Adresse: max.mustermann@example.com; Info: test@mail.de Erwartete Treffer: [\"max.mustermann@example.com\", \"test@mail.de\"] Im zur Übung gehörendem Source kannst Du die Änderung an folgender Stelle machen:\nsrc\\main\\java\\ch\\itninja\\labs\\regex\\RegexTasks.java:\n1 2 3 4 5 6 7 8 /** * Build a Pattern that matches email-like addresses. * Tip: local-part + \"@\" + domain + TLD of length \u003e= 2. */ public static Pattern buildEmailPattern() { // TODO: implement return Pattern.compile(\"\"); } Aufgabe 2 - IBAN formatvalidieren Validiere IBANs rein syntaktisch (ohne Mod-97-Prüfung). Akzeptiere optionale Leerzeichen zwischen Blöcken. Beispiele: CH93 0076 2011 6238 5295 7, DE89 3704 0044 0532 0130 00 Hinweis: Landeskürzel (2 Grossbuchstaben), 2 Ziffern Prüfsumme, restliche Zeichen: A–Z oder 0–9. Im zur Übung gehörendem Source kannst Du die Änderung an folgender Stelle machen:\nsrc\\main\\java\\ch\\itninja\\labs\\regex\\RegexTasks.java:\n1 2 3 4 5 6 7 8 9 /** * Build a Pattern that matches IBANs syntactically with optional spaces. * Examples: \"CH93 0076 2011 6238 5295 7\", \"DE89 3704 0044 0532 0130 00\" * Note: Only format validation here, not the Mod-97 checksum. */ public static Pattern buildIbanPattern() { // TODO: implement return Pattern.compile(\"\"); } Aufgabe 3 - Telefonnummern (Schweiz und international) Erkenne Telefonnummern mit optionalem Ländercode (z. B. +41) und unterschiedlichen Trennzeichen (Leerzeichen, Punkt, Bindestrich). Beispiele: +41 31 987 65 43, 031 987 65 43 Im zur Übung gehörendem Source kannst Du die Änderung an folgender Stelle machen:\nsrc\\main\\java\\ch\\itninja\\labs\\regex\\RegexTasks.java:\n1 2 3 4 5 6 7 8 /** * Build a Pattern for (Swiss/international) phone numbers with optional country code * and separators (space, dot, hyphen). Keep it reasonably permissive. */ public static Pattern buildPhonePattern() { // TODO: implement return Pattern.compile(\"\"); } Aufgabe 4 - URLs extrahieren Extrahiere http- und https-URLs aus einem Text, ohne ans Zeilenende zu laufen oder nachfolgende Satzzeichen mitzunehmen. Beispiele: https://it-ninjas.ch, http://example.org/test Im zur Übung gehörendem Source kannst Du die Änderung an folgender Stelle machen:\nsrc\\main\\java\\ch\\itninja\\labs\\regex\\RegexTasks.java:\n1 2 3 4 5 6 7 /** * Build a Pattern that captures http/https URLs without trailing punctuation. */ public static Pattern buildUrlPattern() { // TODO: implement return Pattern.compile(\"\"); } Aufgabe 5 - Passwort-Policy prüfen Mindestens 8 Zeichen, je 1 Klein- und Grossbuchstabe, 1 Ziffer, 1 Sonderzeichen. Prüfe mit einem einzigen Regex. Beispiel gültig: SecuRe!234 Beispiel ungültig: password1 Im zur Übung gehörendem Source kannst Du die Änderung an folgender Stelle machen:\nsrc\\main\\java\\ch\\itninja\\labs\\regex\\RegexTasks.java:\n1 2 3 4 5 6 7 8 /** * Build a Pattern enforcing: \u003e= 8 chars, at least 1 lowercase, 1 uppercase, 1 digit, 1 symbol. * Hint: lookaheads. */ public static Pattern buildPasswordPolicyPattern() { // TODO: implement return Pattern.compile(\"\"); } Aufgabe 6 - Schweizer Postleitzahlen (CH-PLZ) Erkenne CH-Postleitzahlen (genau 4 Ziffern, keine führende 0). Beachte, dass nach der PLZ eine Ortsbezeichnung kommen muss. Beispiele gültig: 3007, 1000 Beispiele ungültig: 0123, 12345 Im zur Übung gehörendem Source kannst Du die Änderung an folgender Stelle machen:\nsrc\\main\\java\\ch\\itninja\\labs\\regex\\RegexTasks.java:\n1 2 3 4 5 6 7 /** * Build a Pattern that matches Swiss postal codes (4 digits, no leading zero). */ public static Pattern buildChPostalCodePattern() { // TODO: implement return Pattern.compile(\"\"); } Hinweise Teste deine Regex iterativ, nutze Raw-Strings (z. B. in Java Pattern.compile(\"...\")) und kleine Testfälle. Achte darauf, bei Extraktion nicht zu gierig zu matchen und Mehrfachtreffer zu ermöglichen. Für IBANs ist eine vollständige Validierung inkl. Prüfziffernrechnung ausserhalb des Regex sinnvoll. ","categories":"","description":"Mit diesen Übungen kannst du dein Wissen zum Thema Regex vertiefen.\n","excerpt":"Mit diesen Übungen kannst du dein Wissen zum Thema Regex vertiefen.\n","ref":"/labs/02_java/03_java-grundlagen/16_regex/","tags":"","title":"Java Exercises - Regex"},{"body":" Dieses Kapitel gehört zum Modul #J1 des Ausbildungsplans Ziele Ich weiss, wie ich in Java reguläre Ausdrücke mit Pattern und Matcher verwende. Ich kann einfache RegEx-Ausdrücke in Java-Code integrieren. Ich kenne Sicherheitsaspekte bei der Verwendung von RegEx in Java. ⏱️ Geschätzte Lesezeit: 15 Minuten Einführung Lies zuerst das Modul !Regex, bevor du hier weitermachst.\nIn Java werden reguläre Ausdrücke über die Klassen java.util.regex.Pattern und java.util.regex.Matcher verwendet.\nTypische Anwendungsfälle:\nPrüfen, ob ein String einem Muster entspricht Teilstrings extrahieren Text mit Mustererkennung ersetzen Beispiel: Alle Zahlen aus einem Text extrahieren 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import java.util.regex.Pattern; import java.util.regex.Matcher; public class NumberExtractor { public static void main(String[] args) { String text = \"Artikel 123 kostet 45 CHF\"; Pattern pattern = Pattern.compile(\"\\\\d+\"); Matcher matcher = pattern.matcher(text); while (matcher.find()) { System.out.println(\"Gefunden: \" + matcher.group()); } } } Ausgabe:\n1 2 Gefunden: 123 Gefunden: 45 Beispiel: Text ersetzen 1 2 3 4 5 6 7 8 public class ReplaceExample { public static void main(String[] args) { String text = \"Meine Telefonnummer ist 079 123 45 67\"; String hidden = text.replaceAll(\"\\\\d\", \"X\"); System.out.println(hidden); } } Ausgabe:\n1 Meine Telefonnummer ist XXX XXX XX XX Sicherheitsaspekte bei RegEx in Java 1. Catastrophic Backtracking Problem: Auch in Java kann ein ungünstig formulierter RegEx zu extrem langer Laufzeit führen. Beispiel: 1 2 3 4 String regex = \"(a+)+$\"; Pattern pattern = Pattern.compile(regex); Matcher matcher = pattern.matcher(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa!\"); System.out.println(matcher.matches()); // dauert sehr lange Lösung: Verwende möglichst präzise Quantifizierer ({1,10} statt +), Atomic Groups ((?\u003e...)) oder possessive Quantifiers (++, *+). 2. Injection durch dynamische Muster Problem: Wenn der RegEx direkt aus Benutzereingaben besteht, kann er manipuliert werden. Unsicher: 1 Pattern pattern = Pattern.compile(userInput); Sicherer: Benutzereingabe escapen: 1 2 String safeInput = Pattern.quote(userInput); Pattern pattern = Pattern.compile(safeInput); 3. Übermäßige Komplexität Problem: Java-Entwickler neigen dazu, sehr komplexe RegEx zu schreiben, die kaum wartbar sind. Empfehlung: Komplexe Muster aufteilen, ggf. mit Kommentaren ((?x)-Flag) lesbarer machen. 4. Falsche Annahmen bei Validierung Problem: Nur weil ein String das Muster erfüllt, heißt das nicht, dass er inhaltlich gültig ist. Beispiel: a@b.c erfüllt viele E-Mail-RegEx, ist aber oft ungültig. Best Practices für RegEx in Java Immer testen – mit realistischen und Worst-Case-Eingaben. Komplexität reduzieren – ggf. mehrere kleine RegEx verwenden. Benutzereingaben escapen – Pattern.quote() nutzen. Performance im Blick behalten – keine unkontrollierten .* in Kombination mit .+. Tipp Testen von Java-RegEx-Ausdrücken online:\nregex101.com – Java-Modus auswählen RegExPlanet – Java-spezifischer RegEx-Tester Jetzt bist du dran. Löse bitte die folgenden !*Aufgaben in den Labs. ","categories":"","description":"In diesem Modul lernst du, wie du reguläre Ausdrücke in Java (regular expressions, kurz RegEx) einsetzt, um Text zu durchsuchen, zu prüfen oder zu verarbeiten.\n","excerpt":"In diesem Modul lernst du, wie du reguläre Ausdrücke in Java (regular …","ref":"/docs/02_java/03_java-grundlagen/16_regex/","tags":"","title":"Reguläre Ausdrücke in Java (RegEx)"},{"body":"Ziele Ich weiss, wozu ErrorHandler verwendet werden und wie ich selbst solche implementieren kann. ErrorHandler Da man try-catch laut Best-Practises ja so gut wie möglich vermeiden sollte, muss man einen anderen Weg finden, Errors abzufangen zu behandeln. Zudem wäre überaus ineffizient, für jeden einzelnen Fehler einen entsprechenden try-catch-Block hinzuzufügen. Praktischer wäre ein globales Handling von Fehlern. Und genau da kommt der ErrorHandler ins Spiel.\nDer ErrorHandler ist eine abstrakte Klasse, welche von Angular bereitgestellt wird und über die handleError()-Methode verfügt. Der Handler wird verwendet, um global Fehler in einer Anwendung abzufangen und entsprechend zu behandeln.\n1 2 3 4 5 6 7 8 9 import { ErrorHandler, Injectable } from \"@angular/core\"; class GlobalErrorHandler implements ErrorHandler { handleError(error: any): void { console.log(\"test\", error.message); // Weitere Aktionen ausführen, z.B. Fehlermeldung anzeigen oder Logging durchführen } } Seit der Änderung zu standardmässig als standalone gehandelten Komponenten muss der ErrorHandler nun nicht mehr im AppModule, sondern in der main.ts-Datei in den Providers hinzugefügt werden:\n1 2 3 bootstrapApplication(AppComponent, { providers: [{ provide: ErrorHandler, useClass: GlobalErrorHandler }], }); Wenn du aber trotzdem eine module-basierte entwickelst, musst du den Provider stattdessen innerhalb des @NgModule-Decorators des jeweiligen Moduls hinzufügen:\n1 2 3 4 @NgModule({ providers: [{ provide: ErrorHandler, useClass: GlobalErrorHandler }], }) class MyModule {} Jeder Fehler, der in der Anwendung auftritt, wird auf diese Weise automatisch durch den GlobalErrorHandler abgefangen und entsprechend behandelt.\n","categories":"","description":"Modul #F6 - Angular - Error Handling\n","excerpt":"Modul #F6 - Angular - Error Handling\n","ref":"/docs/03_web/06_angular/02_16_errorhandler/","tags":"","title":"Error Handling"},{"body":"Ziele Ich weiss, wozu ErrorHandler verwendet werden und wie ich selbst solche implementieren kann. ErrorHandler Da man try-catch laut Best-Practises ja so gut wie möglich vermeiden sollte, muss man einen anderen Weg finden, Errors abzufangen zu behandeln. Zudem wäre überaus ineffizient, für jeden einzelnen Fehler einen entsprechenden try-catch-Block hinzuzufügen. Praktischer wäre ein globales Handling von Fehlern. Und genau da kommt der ErrorHandler ins Spiel.\nDer ErrorHandler ist eine abstrakte Klasse, welche von Angular bereitgestellt wird und über die handleError()-Methode verfügt. Der Handler wird verwendet, um global Fehler in einer Anwendung abzufangen und entsprechend zu behandeln.\n1 2 3 4 5 6 7 8 9 import { ErrorHandler, Injectable } from \"@angular/core\"; class GlobalErrorHandler implements ErrorHandler { handleError(error: any): void { console.log(\"test\", error.message); // Weitere Aktionen ausführen, z.B. Fehlermeldung anzeigen oder Logging durchführen } } Seit der Änderung zu standardmässig als standalone gehandelten Komponenten muss der ErrorHandler nun nicht mehr im AppModule, sondern in der main.ts-Datei in den Providers hinzugefügt werden:\n1 2 3 bootstrapApplication(AppComponent, { providers: [{ provide: ErrorHandler, useClass: GlobalErrorHandler }], }); Wenn du aber trotzdem eine module-basierte entwickelst, musst du den Provider stattdessen innerhalb des @NgModule-Decorators des jeweiligen Moduls hinzufügen:\n1 2 3 4 @NgModule({ providers: [{ provide: ErrorHandler, useClass: GlobalErrorHandler }], }) class MyModule {} Jeder Fehler, der in der Anwendung auftritt, wird auf diese Weise automatisch durch den GlobalErrorHandler abgefangen und entsprechend behandelt.\n","categories":"","description":"Modul #F6 - Angular - Error Handling\n","excerpt":"Modul #F6 - Angular - Error Handling\n","ref":"/de/docs/03_web/06_angular/02_16_errorhandler/","tags":"","title":"Error Handling"},{"body":"Ziele Ich weiss, wie man mit position: relative HTML-Elemente positionieren kann, ohne den Textfluss zu beeinflussen. Ich weiss, wie man mit position: absolute Elemente an einer festen Position innerhalb eines Containers platziert. Ich kann position: fixed anwenden, um Elemente unabhängig vom Scrollen an einer festen Position zu halten. relative Positionierung: Element ein bisschen verschieben Angenommen, du hast ein Bild in einem Text:\n1 2 3 4 5 6 7 8 9 10 11 Are you a \u003cimg src=\"https://it-ninjas.ch/img/svg/Ninja%20Elements_kopf.svg\" alt=\"\" /\u003e? \u003cstyle\u003e body { font-size: 5em; } img { height: 1em; } \u003c/style\u003e In diesem Fall wird das Bild mit aller Wahrscheinlichkeit nicht perfekt im Text ausgerichtet sein. In diesem Beispiel setzen wir es uns zum Ziel, dass wir das Bild ein Stück weit nach unten verschieben. Das kannst du wie folgt bewerkstelligen:\n1 2 3 4 5 img { position: relative; top: 0.2em; ... } Mit position: relative bewirken wir, dass CSS-Properties wie top, bottom, left und right beachtet werden. Mithilfe der relativen Positionierung können wir dann das Element verschieben, ohne dass es andere Elemente bzw. den Textfluss verändert. Wir haben hier top verwendet, um oben einen Abstand einzufügen. Würdest du left verwenden, so würde sich das Element entsprechend nach rechts verschieben. Wichtig zu beachten ist hierbei, dass unter Verwendung von top, bottom, left und right der Abstand relativ zum Objekt selbst eingefügt wird.\nAbsolute Positionierung Möchtest du ein Element an einer bestimmten Position platzieren, dann kann dir position: absolute weiterhelfen:\n1 2 3 4 5 6 7 8 9 10 11 12 Are you a \u003cimg src=\"https://it-ninjas.ch/img/svg/Ninja%20Elements_kopf.svg\" alt=\"\" /\u003e? \u003cstyle\u003e img { position: absolute; top: 20em; right: 10em; height: 150px; } \u003c/style\u003e Bei der Verwendung von position: absolute wird das Element relativ vom nächsten ebenfalls positionierten Parent-Element positioniert. Gibt es kein solches, wird das Element relativ zum html-Element positioniert.\nMache deinen Browser mal ein wenig kleiner und beobachte, wie sich die Positionierung verhält, wenn du scrollst.\nMöchtest du, dass die Positionierung immer - unabhängig vom Scrollen - gleich ist? Dann versuche mal, das Bild mit position: fixed zu platzieren.\nLöse die Aufgaben 1 - 3 im Lab.\n","categories":"","description":"Modul #F3 - HTML und CSS - HTML-Elemente auf der Seite positionieren.\n","excerpt":"Modul #F3 - HTML und CSS - HTML-Elemente auf der Seite positionieren.\n","ref":"/docs/03_web/02_html_css/16_css-positioning/","tags":"","title":"Positionierung"},{"body":"Ziele Ich weiss, wie man mit position: relative HTML-Elemente positionieren kann, ohne den Textfluss zu beeinflussen. Ich weiss, wie man mit position: absolute Elemente an einer festen Position innerhalb eines Containers platziert. Ich kann position: fixed anwenden, um Elemente unabhängig vom Scrollen an einer festen Position zu halten. relative Positionierung: Element ein bisschen verschieben Angenommen, du hast ein Bild in einem Text:\n1 2 3 4 5 6 7 8 9 10 11 Are you a \u003cimg src=\"https://it-ninjas.ch/img/svg/Ninja%20Elements_kopf.svg\" alt=\"\" /\u003e? \u003cstyle\u003e body { font-size: 5em; } img { height: 1em; } \u003c/style\u003e In diesem Fall wird das Bild mit aller Wahrscheinlichkeit nicht perfekt im Text ausgerichtet sein. In diesem Beispiel setzen wir es uns zum Ziel, dass wir das Bild ein Stück weit nach unten verschieben. Das kannst du wie folgt bewerkstelligen:\n1 2 3 4 5 img { position: relative; top: 0.2em; ... } Mit position: relative bewirken wir, dass CSS-Properties wie top, bottom, left und right beachtet werden. Mithilfe der relativen Positionierung können wir dann das Element verschieben, ohne dass es andere Elemente bzw. den Textfluss verändert. Wir haben hier top verwendet, um oben einen Abstand einzufügen. Würdest du left verwenden, so würde sich das Element entsprechend nach rechts verschieben. Wichtig zu beachten ist hierbei, dass unter Verwendung von top, bottom, left und right der Abstand relativ zum Objekt selbst eingefügt wird.\nAbsolute Positionierung Möchtest du ein Element an einer bestimmten Position platzieren, dann kann dir position: absolute weiterhelfen:\n1 2 3 4 5 6 7 8 9 10 11 12 Are you a \u003cimg src=\"https://it-ninjas.ch/img/svg/Ninja%20Elements_kopf.svg\" alt=\"\" /\u003e? \u003cstyle\u003e img { position: absolute; top: 20em; right: 10em; height: 150px; } \u003c/style\u003e Bei der Verwendung von position: absolute wird das Element relativ vom nächsten ebenfalls positionierten Parent-Element positioniert. Gibt es kein solches, wird das Element relativ zum html-Element positioniert.\nMache deinen Browser mal ein wenig kleiner und beobachte, wie sich die Positionierung verhält, wenn du scrollst.\nMöchtest du, dass die Positionierung immer - unabhängig vom Scrollen - gleich ist? Dann versuche mal, das Bild mit position: fixed zu platzieren.\nLöse die Aufgaben 1 - 3 im Lab.\n","categories":"","description":"Modul #F3 - HTML und CSS - HTML-Elemente auf der Seite positionieren.\n","excerpt":"Modul #F3 - HTML und CSS - HTML-Elemente auf der Seite positionieren.\n","ref":"/de/docs/03_web/02_html_css/16_css-positioning/","tags":"","title":"Positionierung"},{"body":"Ziele Du weisst, was setTimeout(...) ist, wie man die Methode verwendet und wie man einen Timeout frühzeitig abbricht. Du weisst, was setInterval(...) ist, wie man die Methode verwendet und wie man ein Interval frühzeitig abbricht. Code verzögert ausführen: setTimeout(…) Manchmal möchte man eine Aktion verzögert ausführen. Das lässt sich einfach mit der Funktion setTimeout(callback, time) realisieren:\n1 2 3 setTimeout(function () { console.log(\"Thanks for waiting :)\"); }, 5000); Das erste Argument innerhalb der Funktion ist die Aktion/Funktion, die ausgeführt wird, sobald die angegebene Zeit abgelaufen ist. Das zweite Argument ist die Zeit (in Millisekunden), die verstreichen muss, bis die übergebene Funktion ausgeführt wird.\nCode immer wieder ausführen: setInterval(…) Folgender Code wird jede Sekunde ausgeführt:\n1 2 3 setInterval(function () { console.log(\"hey!\"); }, 1000); Vielleicht ist dir aufgefallen, dass setTimeout(...) und setInterval(...) jeweils eine Ganzzahl zurückgeben. Das ist die ID des Timeouts bzw. Intervalls. Es macht Sinn, diesen Wert zu behalten, damit das Intervall auch wieder beendet werden kann:\n1 2 3 4 const intervalId = setInterval(function(){}, 1000); ... clearInterval(intervalId); Es ist auch möglich, ein setTimeout(...) frühzeitig abzubrechen. Auch hierzu benötigen wir die jeweilige ID der jeweiligen setTimeout(...)-Instanz. Zum Abbrechen eines Timeouts wird die clearTimeout(...)-Methode verwendet:\n1 2 3 4 5 const timeoutId = setTimeout(function () { console.log(\"Cance me!\"); }, 10000); clearTimeout(timeoutId); Insofern der Timeout zum Zeitpunkt, in dem clearTimeout(timeoutId) aufgerufen wird, nicht bereits ausgelaufen ist, wird er so abgebrochen. Wichtig zu wissen ist hierbei, dass die callback-Function im Falle eines Abbruchs nicht ausgeführt wird.\nHierzu findest du eine Aufgabe im Lab.\n","categories":"","description":"Modul #F4 - JavaScript - Code verzögert ausführen.\n","excerpt":"Modul #F4 - JavaScript - Code verzögert ausführen.\n","ref":"/docs/03_web/03_javascript/17_timeout-and-interval/","tags":"","title":"Timeouts und Intervalle"},{"body":"Ziele Du weisst, was setTimeout(...) ist, wie man die Methode verwendet und wie man einen Timeout frühzeitig abbricht. Du weisst, was setInterval(...) ist, wie man die Methode verwendet und wie man ein Interval frühzeitig abbricht. Code verzögert ausführen: setTimeout(…) Manchmal möchte man eine Aktion verzögert ausführen. Das lässt sich einfach mit der Funktion setTimeout(callback, time) realisieren:\n1 2 3 setTimeout(function () { console.log(\"Thanks for waiting :)\"); }, 5000); Das erste Argument innerhalb der Funktion ist die Aktion/Funktion, die ausgeführt wird, sobald die angegebene Zeit abgelaufen ist. Das zweite Argument ist die Zeit (in Millisekunden), die verstreichen muss, bis die übergebene Funktion ausgeführt wird.\nCode immer wieder ausführen: setInterval(…) Folgender Code wird jede Sekunde ausgeführt:\n1 2 3 setInterval(function () { console.log(\"hey!\"); }, 1000); Vielleicht ist dir aufgefallen, dass setTimeout(...) und setInterval(...) jeweils eine Ganzzahl zurückgeben. Das ist die ID des Timeouts bzw. Intervalls. Es macht Sinn, diesen Wert zu behalten, damit das Intervall auch wieder beendet werden kann:\n1 2 3 4 const intervalId = setInterval(function(){}, 1000); ... clearInterval(intervalId); Es ist auch möglich, ein setTimeout(...) frühzeitig abzubrechen. Auch hierzu benötigen wir die jeweilige ID der jeweiligen setTimeout(...)-Instanz. Zum Abbrechen eines Timeouts wird die clearTimeout(...)-Methode verwendet:\n1 2 3 4 5 const timeoutId = setTimeout(function () { console.log(\"Cance me!\"); }, 10000); clearTimeout(timeoutId); Insofern der Timeout zum Zeitpunkt, in dem clearTimeout(timeoutId) aufgerufen wird, nicht bereits ausgelaufen ist, wird er so abgebrochen. Wichtig zu wissen ist hierbei, dass die callback-Function im Falle eines Abbruchs nicht ausgeführt wird.\nHierzu findest du eine Aufgabe im Lab.\n","categories":"","description":"Modul #F4 - JavaScript - Code verzögert ausführen.\n","excerpt":"Modul #F4 - JavaScript - Code verzögert ausführen.\n","ref":"/de/docs/03_web/03_javascript/17_timeout-and-interval/","tags":"","title":"Timeouts und Intervalle"},{"body":" Dieses Kapitel gehört zum Modul #J1 des Ausbildungsplans Ziele Ich kann typische Utility-Klassen wie Math, String, Arrays, System benennen und anwenden. Ich kann statische Methoden anhand der Schreibweise Klasse.Methode(...) erkennen. Ich weiss, dass viele Aufgaben mit bestehenden Klassen gelöst werden können ohne eigene Objekte zu bauen. Ich verstehe, dass Utility-Klassen in Java oft ohne new verwendet werden. ⏱️ Geschätzte Lesezeit: 15 Minuten Einführung Im Modul „Packages“ hast du bereits gelernt, was Utility-Klassen sind: Klassen mit statischen Methoden, die du direkt über ihren Klassennamen verwenden kannst.\nIn diesem Modul stellen wir dir nun einige besonders nützliche Utility-Klassen aus der Java-Standardbibliothek vor. Sie helfen dir dabei, viele typische Aufgaben zu lösen ohne dass du eigene Objekte oder Klassen bauen musst.\nJava enthält viele praktische Klassen, die du sofort verwenden kannst ohne zuerst eigene Klassen oder Objekte zu erstellen. Diese sogenannten Utility-Klassen stellen häufige Funktionen bereit, zum Beispiel um Zahlen zu runden, Strings zu verarbeiten, Zufallszahlen zu erzeugen oder Arrays zu sortieren.\nDie Methoden rufst du dabei, wie in früheren Modulen gelernt, direkt über den Klassennamen auf.\n1 int maximum = Math.max(10, 25); // kein Objekt nötig Das macht Utility-Klassen zu idealen Helfern.\nTypische Utility-Klassen Hier eine Auswahl von Klassen, die du sofort nutzen kannst:\nMath – Mathematische Funktionen 1 2 3 4 int betrag = Math.abs(-42); double wurzel = Math.sqrt(9); double zufall = Math.random(); double kreis = Math.PI * Math.pow(5, 2); // Fläche eines Kreises mit Radius 5 Integer / Double – Texte in Zahlen umwandeln 1 2 int zahl = Integer.parseInt(\"123\"); double komma = Double.parseDouble(\"3.14\"); Arrays – Hilfen für Arrays 1 2 3 4 5 6 7 8 int[] zahlen = {3, 5, 4, 1, 5}; Arrays.sort(zahlen); // sortieren → zahlen ist danach {1, 3, 4, 5, 5} System.out.println(Arrays.toString(zahlen)); // Ausgabe int[] kopie = Arrays.copyOf(zahlen, 10); // Array mit mehr Platz, kopie ist danach {1, 3, 4, 5, 5, 0, 0, 0, 0, 0} Arrays.fill(kopie, 5, 10, 99); // auffüllen ab Index 5 mit 99, kopie ist danach {1, 3, 4, 5, 5, 99, 99, 99, 99, 99} int index = Arrays.binarySearch(zahlen, 4); // sortiert → Index von der Zahl 4 ist 2 System – Ausgaben und Informationen Mit System kannst du zum Beispiel etwas auf die Konsole schreiben (System.out.println(...)), die aktuelle Zeit in Millisekunden abfragen oder Informationen über die Umgebung erhalten:\n1 2 3 4 System.out.println(\"Hallo Welt\"); // Kennst du schon lange :-) long zeit = System.currentTimeMillis(); String benutzer = System.getenv(\"USERNAME\"); // unter Windows String home = System.getenv(\"HOME\"); // unter Linux/macOS Die Methode System.getenv(...) liefert dir Umgebungsvariablen, die vom Betriebssystem gesetzt werden – z. B. dein Benutzername oder dein Home-Verzeichnis.\nThreadLocalRandom – Zufallszahlen ohne new 1 int augenzahl = java.util.concurrent.ThreadLocalRandom.current().nextInt(1, 7); LocalDate – mit Datum rechnen 1 2 java.time.LocalDate heute = java.time.LocalDate.now(); java.time.LocalDate geburtstag = java.time.LocalDate.of(2025, 9, 12); Files – Dateien und Verzeichnisse verwalten (ab Java 11) Mit der Klasse Files kannst du einfach auf Dateien und Verzeichnisse zugreifen: lesen, schreiben, anfügen, löschen oder auch Verzeichnisse erstellen.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 java.nio.file.Path pfad = java.nio.file.Path.of(\"daten.txt\"); // Datei lesen String inhalt = java.nio.file.Files.readString(pfad); // Datei überschreiben java.nio.file.Files.writeString(pfad, \"Neuer Inhalt\\n\"); // Datei erweitern (anhängen) java.nio.file.Files.writeString( pfad, \"Zusätzliche Zeile\\n\", java.nio.file.StandardOpenOption.APPEND ); // Datei löschen java.nio.file.Files.delete(pfad); Auch für Verzeichnisse gibt es einfache Methoden:\n1 2 3 4 5 6 7 java.nio.file.Path ordner = java.nio.file.Path.of(\"meinOrdner\"); // Verzeichnis erstellen java.nio.file.Files.createDirectory(ordner); // Verzeichnis löschen (nur wenn leer!) java.nio.file.Files.delete(ordner); Für häufig genutzte Pfade wie das aktuelle Verzeichnis oder das Home-Verzeichnis kannst du folgende Techniken nutzen:\n1 2 3 4 5 String aktuellerPfad = System.getProperty(\"user.dir\"); // aktuelles Projektverzeichnis String home = System.getProperty(\"user.home\"); // Home-Verzeichnis des Benutzers // Datei im Home-Verzeichnis ansprechen java.nio.file.Path logdatei = java.nio.file.Path.of(home, \"log.txt\"); Wichtig: Wenn du keinen absoluten Pfad angibst (z. B. C:\\Daten\\file.txt), dann wird der Pfad relativ zum aktuellen Verzeichnis interpretiert. Welches Verzeichnis das ist, erfährst du mit:\n1 System.out.println(System.getProperty(\"user.dir\")); Wichtige Merkmale Utility-Klassen haben nur statische Methoden → kein new nötig. Oft sind sie zustandslos: sie verändern keine internen Werte. Sie gehören zu bekannten Paketen wie java.lang, java.util, java.time oder java.nio.file. Viele Klassen sind sofort verfügbar, ohne import (z. B. Math, String, System). Wie findest du weitere Utility-Klassen? Java enthält Hunderte von Klassen, viele davon mit nützlichen statischen Methoden. Du kannst sie am besten so entdecken:\nSchau dir bekannte Pakete wie java.lang, java.util, java.time oder java.nio.file an. Verwende eine Liste von bekannten Klassen aus diesem Modul und erkunde weitere Klassen in der JavaDoc. Lies die JavaDoc, sie ist für jedes Java-Paket online verfügbar, z. B. unter: !https://docs.oracle.com/en/java/javase/17/docs/api/ Erkenntnis Du musst das Rad nicht neu erfinden.\nFür viele Probleme gibt es bereits eine Lösung in der Java-Standardbibliothek. Ob du einen Text umwandeln, eine Liste sortieren oder mit Datum/Zeit arbeiten möchtest. Es lohnt sich, zuerst zu prüfen, ob es bereits eine passende Utility-Methode gibt.\nAusblick Später wirst du eigene Klassen schreiben, um Objekte zu erzeugen und gezielt Verhalten zu kapseln. Für den Moment reicht es aber, diese vorhandenen Helfer gut zu kennen.\n","categories":"","description":"Häufig verwendete Java-Pakete mit statischen Hilfsmethoden (Utility-Klassen).\n","excerpt":"Häufig verwendete Java-Pakete mit statischen Hilfsmethoden …","ref":"/docs/02_java/03_java-grundlagen/17_utility_classes/","tags":"","title":"Utility Klassen"},{"body":"Ziele Du weisst, was eine Dependency Injection ist und wie man diese in Angular anwendet. Du kannst Dependency Injection anwenden. Was sind Dependencies (Abhängigkeiten)? Um eine loose Kopplung zu erreichen, werden verschiedene Aufgaben wie das Laden von Server-Daten in verschiedene Dateien ausgelagert. Die einzelnen Klassen haben Abhängigkeiten zueinander. In Angular gibt man die Abhängigkeiten zu anderen Klassen z.B. oft im Konstruktor an.\nAngular erstellt und übergibt dann automatisch Instanzen dieser Klassen beim Laden der entsprechenden Klasse. Auf diese Weise werden die Klassen wiederverwendbar und einfacher testbar.\nWas ist eine Dependency Injection? Dependency Injection ist ein Coding-Pattern, bei welchem Klassen alle Abhängigkeiten von externen Quellen erhalten, anstatt sie selbst zu erstellen.\nDependency Injection in Angular Der Angular Dependency Injector liefert uns Vorteile wie Skalierbarkeit, Testbarkeit und eine klare Trennung der Aufgaben.\nUm den Dependency Injector in Angular zu nutzen, müssen wir 3 Schritten folgen:\nDen @Injectable() Decorator der Klasse/ dem Service hinzufügen. Dem Injector davon erzählen, indem wir es als Provider aufzählen. Die Dependency injecten @Injectable importieren und nutzen: 1 2 3 4 5 6 import { Injectable } from \"./@angular/core\"; @Injectable({ providedIn: \"root\", }) export class WeaponService {} Den WeaponService als Provider registrieren: 1 2 3 4 5 6 // .. import { WeaponService } from \"./services/weapon.service\"; export const appConfig: ApplicationConfig = { providers: [{ provide: WeaponService }], }; Dann muss noch die folgende Einstellung in der main.ts-Datei gemacht werden:\n1 bootstrapApplication(AppComponent, appConfig); Dependency injecten wo (in unserem Beispiel) der Service genutzt wird: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import { WeaponService } from \"./services/weapon.service\"; @Component({ // .. }) export class WeaponComponent { weapons: string[] = []; constructor(private weaponService: WeaponService) {} ngOnInit() { this.weapons = this.weaponService.getWeapons(); } } Das Minibeispiel soll lediglich die 3 wichtigen Schritte etwas besser darstellen. Im gemachten Beispiel ist zudem die Dependency auf der root-Ebene verfügbar. (Sichtbar durch den Teil providedIn: \"root\" im @Injectable-Block) Das bedeutet, dass Angular für die gesamte Applikation genau eine Instanz des injizierbaren Services erstellt, welcher dann jeweils von allen Klassen verwendet wird, die ihn injecten.\nEs gibt aber auch eine andere Möglichkeit, einen solchen Service zu injecten. Im folgenden Beispiel wird der Service auf der Component-Ebene injected und wird für jede neue Instanz des Components neu instanziert:\nDependency im Service bereitstellen 1 2 @Injectable() class WeaponService {} Dependency in den gewünschten Component injizieren 1 2 3 4 5 6 7 @Component({ standalone: true, selector: \"weapon\", template: \"...\", providers: [WeaponService], }) class WeaponComponent {} Auf diese Weise wird für jede neue Instanz des Components auch eine neue Instanz des Service verwendet. Unter verwendung von providedIn: 'root' wird eine Instanz der inizierten Klasse für die gesamte Applikation verwendet. Es gibt für beide Möglichkeiten valide Anwendungsfälle, grundsätzlich empfiehlt es sich aber, injizierbare Klassen auf der root-Ebene zu providen, da so nicht unnötig viele Instanzen erstellt werden und die Instanz auch von Angular entfernt werden kann, wenn sie nirgendwo gebraucht wird.\nLernvideo Wenn du dir das Konzept der Dependency-Injection etwas genauer anschauen möchtest, kannst du dieses Video anschauen.\n","categories":"","description":"Modul #F6 - Angular - Dependency Injection\n","excerpt":"Modul #F6 - Angular - Dependency Injection\n","ref":"/docs/03_web/06_angular/02_17_dependency_injection/","tags":"","title":"Dependency Injection"},{"body":"Ziele Du weisst, was eine Dependency Injection ist und wie man diese in Angular anwendet. Du kannst Dependency Injection anwenden. Was sind Dependencies (Abhängigkeiten)? Um eine loose Kopplung zu erreichen, werden verschiedene Aufgaben wie das Laden von Server-Daten in verschiedene Dateien ausgelagert. Die einzelnen Klassen haben Abhängigkeiten zueinander. In Angular gibt man die Abhängigkeiten zu anderen Klassen z.B. oft im Konstruktor an.\nAngular erstellt und übergibt dann automatisch Instanzen dieser Klassen beim Laden der entsprechenden Klasse. Auf diese Weise werden die Klassen wiederverwendbar und einfacher testbar.\nWas ist eine Dependency Injection? Dependency Injection ist ein Coding-Pattern, bei welchem Klassen alle Abhängigkeiten von externen Quellen erhalten, anstatt sie selbst zu erstellen.\nDependency Injection in Angular Der Angular Dependency Injector liefert uns Vorteile wie Skalierbarkeit, Testbarkeit und eine klare Trennung der Aufgaben.\nUm den Dependency Injector in Angular zu nutzen, müssen wir 3 Schritten folgen:\nDen @Injectable() Decorator der Klasse/ dem Service hinzufügen. Dem Injector davon erzählen, indem wir es als Provider aufzählen. Die Dependency injecten @Injectable importieren und nutzen: 1 2 3 4 5 6 import { Injectable } from \"./@angular/core\"; @Injectable({ providedIn: \"root\", }) export class WeaponService {} Den WeaponService als Provider registrieren: 1 2 3 4 5 6 // .. import { WeaponService } from \"./services/weapon.service\"; export const appConfig: ApplicationConfig = { providers: [{ provide: WeaponService }], }; Dann muss noch die folgende Einstellung in der main.ts-Datei gemacht werden:\n1 bootstrapApplication(AppComponent, appConfig); Dependency injecten wo (in unserem Beispiel) der Service genutzt wird: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import { WeaponService } from \"./services/weapon.service\"; @Component({ // .. }) export class WeaponComponent { weapons: string[] = []; constructor(private weaponService: WeaponService) {} ngOnInit() { this.weapons = this.weaponService.getWeapons(); } } Das Minibeispiel soll lediglich die 3 wichtigen Schritte etwas besser darstellen. Im gemachten Beispiel ist zudem die Dependency auf der root-Ebene verfügbar. (Sichtbar durch den Teil providedIn: \"root\" im @Injectable-Block) Das bedeutet, dass Angular für die gesamte Applikation genau eine Instanz des injizierbaren Services erstellt, welcher dann jeweils von allen Klassen verwendet wird, die ihn injecten.\nEs gibt aber auch eine andere Möglichkeit, einen solchen Service zu injecten. Im folgenden Beispiel wird der Service auf der Component-Ebene injected und wird für jede neue Instanz des Components neu instanziert:\nDependency im Service bereitstellen 1 2 @Injectable() class WeaponService {} Dependency in den gewünschten Component injizieren 1 2 3 4 5 6 7 @Component({ standalone: true, selector: \"weapon\", template: \"...\", providers: [WeaponService], }) class WeaponComponent {} Auf diese Weise wird für jede neue Instanz des Components auch eine neue Instanz des Service verwendet. Unter verwendung von providedIn: 'root' wird eine Instanz der inizierten Klasse für die gesamte Applikation verwendet. Es gibt für beide Möglichkeiten valide Anwendungsfälle, grundsätzlich empfiehlt es sich aber, injizierbare Klassen auf der root-Ebene zu providen, da so nicht unnötig viele Instanzen erstellt werden und die Instanz auch von Angular entfernt werden kann, wenn sie nirgendwo gebraucht wird.\nLernvideo Wenn du dir das Konzept der Dependency-Injection etwas genauer anschauen möchtest, kannst du dieses Video anschauen.\n","categories":"","description":"Modul #F6 - Angular - Dependency Injection\n","excerpt":"Modul #F6 - Angular - Dependency Injection\n","ref":"/de/docs/03_web/06_angular/02_17_dependency_injection/","tags":"","title":"Dependency Injection"},{"body":"Ziele Du weisst, was Prototypen sind und dass JavaScript eine Prototyp-basierte Programmiersprache ist. Du weisst, was Klassen sind und wie man diese verwendet. Du weisst, was statische Methoden sind und wie man sie verwendet. Du weisst, was die Methoden typeOf und instanceOf bewirken, wie man sie verwendet und was die beiden Methoden voneinander unterscheidet. JavaScript ist eine Prototyp-basierte Programmiersprache JavaScript ist eine Prototyp-basierte Programmiersprache, was bedeutet, dass die Vererbung und die Erstellung von Objekten auf Prototypen basieren.\nEin Prototyp ist ein vordefiniertes Objekt, welches als Vorlage für die Erstellung neuer Objekte dient. Wenn ein neues Objekt erstellt wird, erbt es automatisch Eigenschaften und Methoden von seinem Prototypen.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // create Object-Prototyp const personProto = { name: \"\", age: 0, speak: function () { console.log(\"Hello World!\"); }, }; // Erstellen eines Objekts basierend auf einem Prototypen const person1 = Object.create(personProto); person1.name = \"John\"; person1.age = 30; // Erstellen eines weiteren Objekts basierend auf dem Prototypen const person2 = Object.create(personProto); person2.name = \"Jane\"; person2.age = 25; console.log(person1); // { name: \"John\", age: 30 } console.log(person2); // { name: \"Jane\", age: 25 } person1.speak(); //'Hello World!' Klassen in JavaScript Es gibt in JavaScript das Konzept von Klassen, das in der objektorientierten Programmierung verwendet wird.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // Klasse class Person { constructor(name, age) { this.name = name; this.age = age; } sayHello() { console.log(\"Hello, my name is \" + this.name); } } // Eine Instanz der Klasse erstellen const person = new Person(\"Max\", 30); // Eine Methode der Klasse aufrufen person1.sayHello(); // Hello, my name is Max static Methods Es gibt auch hier statische Methoden, welche in Klassen definiert werden, um Methoden aufzurufen, die nicht an eine bestimmte Instanz der Klasse gebunden sind, sondern direkt auf der Klasse selbst aufgerufen werden können.\nStatische Methoden sind hilfreich, um Hilfsfunktionen in einer Klasse zu definieren, die nicht auf eine bestimmte Instanz der Klasse angewiesen sind. Sie können auch verwendet werden, um Konstruktoren in einer Klasse zu definieren, die nur einmal ausgeführt werden müssen, unabhängig davon, wie viele Instanzen der Klasse erstellt werden.\nStatische Methoden werden mit dem Schlüsselbegriff static vor der Methodendefinition gekennzeichnet.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Person { constructor(name, age) { this.name = name; this.age = age; } sayHello() { console.log(\"Hello, my name is \" + this.name); } static sayBye() { console.log(\"Bye Bye\"); } } const person = new Person(\"Max\", 30); console.log(person.name); // Max console.log(person.age); // 30 person.sayHello(); // Hello, my name is Max Person.sayBye(); // Bye Bye Natürlich kann eine Klasse auch von einer anderen erben. Dazu wird der extends-Schlüsselbegriff verwendet:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Person { constructor(name, age) { this.name = name; this.age = age; } } class Student extends Person { constructor(name, age, major) { super(name, age); this.major = major; } } const person = new Person(\"Max\", 30); const student = new Student(\"John\", 20, \"Computer Science\"); console.log(person.name); // Max console.log(person.age); // 30 console.log(student.name); // John console.log(student.age); // 20 console.log(student.major); // Computer Science typeof vs instanceof bei Klassen Es gibt zwei Möglichkeiten, den Typ eines Objekts zu überprüfen: den typeof-Operator und den instanceof-Operator. Wenn es um Klassen geht, haben beide ihre eigenen Anwendungsfälle und Unterschiede:\ntypeof wird verwendet, um den Typen eines Werts zu überprüfen. Wenn eine Klasse definiert wird, wird ihr Typ als “function” angegeben. Für eine Instanz wird object zurückgegeben.\n1 2 3 4 5 6 7 8 9 10 11 class Person { constructor(name, age) { this.name = name; this.age = age; } } const person = new Person(\"Max\", 30); console.log(typeof Person); // \"function\" console.log(typeof person); // \"object\" instanceof wird verwendet, um zu überprüfen, ob eine Instanz einer bestimmten Klasse angehört.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Person { constructor(name, age) { this.name = name; this.age = age; } } class Student extends Person { constructor(name, age, major) { super(name, age); this.major = major; } } const person = new Person(\"Max\", 30); const student = new Student(\"John\", 20, \"Computer Science\"); console.log(student instanceof Person); // true console.log(student instanceof Student); // true console.log(person instanceof Student); // false ","categories":"","description":"Modul #F4 - JavaScript - Prototypen und Klassen.\n","excerpt":"Modul #F4 - JavaScript - Prototypen und Klassen.\n","ref":"/docs/03_web/03_javascript/18_prototyping-class-in-js/","tags":"","title":"Prototyping und Klassen"},{"body":"Ziele Du weisst, was Prototypen sind und dass JavaScript eine Prototyp-basierte Programmiersprache ist. Du weisst, was Klassen sind und wie man diese verwendet. Du weisst, was statische Methoden sind und wie man sie verwendet. Du weisst, was die Methoden typeOf und instanceOf bewirken, wie man sie verwendet und was die beiden Methoden voneinander unterscheidet. JavaScript ist eine Prototyp-basierte Programmiersprache JavaScript ist eine Prototyp-basierte Programmiersprache, was bedeutet, dass die Vererbung und die Erstellung von Objekten auf Prototypen basieren.\nEin Prototyp ist ein vordefiniertes Objekt, welches als Vorlage für die Erstellung neuer Objekte dient. Wenn ein neues Objekt erstellt wird, erbt es automatisch Eigenschaften und Methoden von seinem Prototypen.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // create Object-Prototyp const personProto = { name: \"\", age: 0, speak: function () { console.log(\"Hello World!\"); }, }; // Erstellen eines Objekts basierend auf einem Prototypen const person1 = Object.create(personProto); person1.name = \"John\"; person1.age = 30; // Erstellen eines weiteren Objekts basierend auf dem Prototypen const person2 = Object.create(personProto); person2.name = \"Jane\"; person2.age = 25; console.log(person1); // { name: \"John\", age: 30 } console.log(person2); // { name: \"Jane\", age: 25 } person1.speak(); //'Hello World!' Klassen in JavaScript Es gibt in JavaScript das Konzept von Klassen, das in der objektorientierten Programmierung verwendet wird.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // Klasse class Person { constructor(name, age) { this.name = name; this.age = age; } sayHello() { console.log(\"Hello, my name is \" + this.name); } } // Eine Instanz der Klasse erstellen const person = new Person(\"Max\", 30); // Eine Methode der Klasse aufrufen person1.sayHello(); // Hello, my name is Max static Methods Es gibt auch hier statische Methoden, welche in Klassen definiert werden, um Methoden aufzurufen, die nicht an eine bestimmte Instanz der Klasse gebunden sind, sondern direkt auf der Klasse selbst aufgerufen werden können.\nStatische Methoden sind hilfreich, um Hilfsfunktionen in einer Klasse zu definieren, die nicht auf eine bestimmte Instanz der Klasse angewiesen sind. Sie können auch verwendet werden, um Konstruktoren in einer Klasse zu definieren, die nur einmal ausgeführt werden müssen, unabhängig davon, wie viele Instanzen der Klasse erstellt werden.\nStatische Methoden werden mit dem Schlüsselbegriff static vor der Methodendefinition gekennzeichnet.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Person { constructor(name, age) { this.name = name; this.age = age; } sayHello() { console.log(\"Hello, my name is \" + this.name); } static sayBye() { console.log(\"Bye Bye\"); } } const person = new Person(\"Max\", 30); console.log(person.name); // Max console.log(person.age); // 30 person.sayHello(); // Hello, my name is Max Person.sayBye(); // Bye Bye Natürlich kann eine Klasse auch von einer anderen erben. Dazu wird der extends-Schlüsselbegriff verwendet:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Person { constructor(name, age) { this.name = name; this.age = age; } } class Student extends Person { constructor(name, age, major) { super(name, age); this.major = major; } } const person = new Person(\"Max\", 30); const student = new Student(\"John\", 20, \"Computer Science\"); console.log(person.name); // Max console.log(person.age); // 30 console.log(student.name); // John console.log(student.age); // 20 console.log(student.major); // Computer Science typeof vs instanceof bei Klassen Es gibt zwei Möglichkeiten, den Typ eines Objekts zu überprüfen: den typeof-Operator und den instanceof-Operator. Wenn es um Klassen geht, haben beide ihre eigenen Anwendungsfälle und Unterschiede:\ntypeof wird verwendet, um den Typen eines Werts zu überprüfen. Wenn eine Klasse definiert wird, wird ihr Typ als “function” angegeben. Für eine Instanz wird object zurückgegeben.\n1 2 3 4 5 6 7 8 9 10 11 class Person { constructor(name, age) { this.name = name; this.age = age; } } const person = new Person(\"Max\", 30); console.log(typeof Person); // \"function\" console.log(typeof person); // \"object\" instanceof wird verwendet, um zu überprüfen, ob eine Instanz einer bestimmten Klasse angehört.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Person { constructor(name, age) { this.name = name; this.age = age; } } class Student extends Person { constructor(name, age, major) { super(name, age); this.major = major; } } const person = new Person(\"Max\", 30); const student = new Student(\"John\", 20, \"Computer Science\"); console.log(student instanceof Person); // true console.log(student instanceof Student); // true console.log(person instanceof Student); // false ","categories":"","description":"Modul #F4 - JavaScript - Prototypen und Klassen.\n","excerpt":"Modul #F4 - JavaScript - Prototypen und Klassen.\n","ref":"/de/docs/03_web/03_javascript/18_prototyping-class-in-js/","tags":"","title":"Prototyping und Klassen"},{"body":"Ziele Du weisst, wie du bei Elementen Übergänge für CSS-Property-Änderungen hinzufügen kannst. Du weisst, wie du mit Keyframes sich wiederholende Animationen erstellen kannst. Übergänge Übergänge werden häufig eingesetzt, um zu visualisieren, dass eine Schaltfläche den Fokus erhalten oder verloren hat oder um Grössenänderungen (beispielsweise von Navigationsleisten) weniger abrupt und damit für das Auge angenehmer zu gestalten.\nIn CSS kannst du relativ leicht Übergänge erstellen. Zum Beispiel kannst du die Form eines \u003cdiv\u003e-Elements wie folgt verändern:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u003cdiv class=\"box\"\u003e\u003c/div\u003e \u003cstyle\u003e .box { /* Initialzustand: */ width: 10em; height: 10em; background-color: lightgrey; border: 5px solid black; border-radius: 50%; /* Übergang wird mittels `transition` angegeben: */ transition: width 1s, background-color 2s, border-radius 3s; } .box:hover { /* Zustand, wenn sich die Maus über dem Element befindet: */ width: 20em; background-color: #ffbf00; border-radius: 0; } \u003c/style\u003e Probiere das einmal selbst aus!\nAber wie funktioniert das genau? Beschränken wir uns für dieses Beispiel einmal auf die Änderung der Breite. Da in der regulären CSS-Regel (also .box) die Regel transition: width 1s steht, reagiert dieses HTML-Element auf eine Änderung in der Breite mit einem Übergang (transition). In dieser CSS-Regel war width der Name des CSS-Properties, auf welche der Übergang angewandt wurde. Die Angabe 1s spezifiziert, dass der Übergang 1 Sekunde lang dauern soll.\nOft lässt sich die Angabe der Transition in diesem Format beobachten:\n1 transition: width 1s ease; Das Keyword ease beschreibt, wie die Animation beschleunigt wird: ease-Animationen beginnen langsam, sind dann schneller und am Schluss wird sie “gebremst”. ease ist der Default-Wert und muss daher nicht explizit angegeben werden. Es gibt viele weitere Arten, die Geschwindigkeit der Animation zu gestalten:\nease linear ease-in ease-out ease-in-out cubic-bezier(n,n,n,n) Weitere Informationen zu Transitions erhältst du hier: https://www.w3schools.com/css/css3_transitions.asp\nAnimationen In CSS sind auch Animationen einfach realisierbar - auch ohne die Verwendung von JavaScript.\nIm folgenden Beispiel lassen wir eine Hand winken:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u003cspan class=\"hand\"\u003e🖐\u003c/div\u003e \u003cstyle\u003e .hand { /* transform geht nicht für inline-Elemente: */ display: inline-block; font-size: 72px; /* Animation properties: */ animation-name: wave; animation-duration: 2s; animation-direction: alternate; animation-iteration-count: infinite; } @keyframes wave { 0% {transform: rotate(-90deg);} 10% {transform: rotate(-90deg);} 90% {transform: rotate(90deg);} 100% {transform: rotate(90deg);} } \u003c/style\u003e Das Zentrale an diesem Code-Beispiel ist der @keyframes-Block. Das erste Wort nach diesem Schlüsselbegriff ist der Name, der du der Animation gibst.\nDas 0% steht für den Anfang der Animation, diese Prozentangaben beschreiben also eine Zeitangabe: Zu welchem Zeitpunkt der Animation soll das Element wie gestylt werden?\nDamit du die Animation (hier mit dem Namen wave) verwenden kannst, musst du diese referenzieren: Das hast du mit animation-name: wave gemacht. Anschliessend haben wir die Animation weiter konfiguriert:\nMit animation-direction: alternate haben wir angegeben, dass die Animation wieder rückwärts ablaufen soll, wenn sie durchgelaufen ist. Hierfür war Folgendes ebenfalls notwendig: animation-iteration-count: infinite bewirkt, dass die Animation unendlich wiederholt wird. Das ist bereits alles an Basis-Wissen, das es zu Animationen in CSS zu wissen gibt. Interessierst du dich weiter für Animationen, dann kannst du dein Wissen gerne hier vertiefen: https://www.w3schools.com/css/css3_animations.asp\nDamit du erkennst, wofür Animationen eingesetzt werden können, schaue dir dieses Beispiel an, wie einfach und ohne die Nutzung von Javascript ein Ladebalken implementiert werden kann: https://www.w3schools.com/howto/howto_css_loader.asp\nLöse die Aufgaben 4 und 5 im Lab.\n","categories":"","description":"Modul #F3 - HTML und CSS - Erstelle professionelle Animationen - nur mit CSS und komplett ohne JavaScript.\n","excerpt":"Modul #F3 - HTML und CSS - Erstelle professionelle Animationen - nur …","ref":"/docs/03_web/02_html_css/17_css-keyframes/","tags":"","title":"Übergänge und Animationen"},{"body":"Ziele Du weisst, wie du bei Elementen Übergänge für CSS-Property-Änderungen hinzufügen kannst. Du weisst, wie du mit Keyframes sich wiederholende Animationen erstellen kannst. Übergänge Übergänge werden häufig eingesetzt, um zu visualisieren, dass eine Schaltfläche den Fokus erhalten oder verloren hat oder um Grössenänderungen (beispielsweise von Navigationsleisten) weniger abrupt und damit für das Auge angenehmer zu gestalten.\nIn CSS kannst du relativ leicht Übergänge erstellen. Zum Beispiel kannst du die Form eines \u003cdiv\u003e-Elements wie folgt verändern:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u003cdiv class=\"box\"\u003e\u003c/div\u003e \u003cstyle\u003e .box { /* Initialzustand: */ width: 10em; height: 10em; background-color: lightgrey; border: 5px solid black; border-radius: 50%; /* Übergang wird mittels `transition` angegeben: */ transition: width 1s, background-color 2s, border-radius 3s; } .box:hover { /* Zustand, wenn sich die Maus über dem Element befindet: */ width: 20em; background-color: #ffbf00; border-radius: 0; } \u003c/style\u003e Probiere das einmal selbst aus!\nAber wie funktioniert das genau? Beschränken wir uns für dieses Beispiel einmal auf die Änderung der Breite. Da in der regulären CSS-Regel (also .box) die Regel transition: width 1s steht, reagiert dieses HTML-Element auf eine Änderung in der Breite mit einem Übergang (transition). In dieser CSS-Regel war width der Name des CSS-Properties, auf welche der Übergang angewandt wurde. Die Angabe 1s spezifiziert, dass der Übergang 1 Sekunde lang dauern soll.\nOft lässt sich die Angabe der Transition in diesem Format beobachten:\n1 transition: width 1s ease; Das Keyword ease beschreibt, wie die Animation beschleunigt wird: ease-Animationen beginnen langsam, sind dann schneller und am Schluss wird sie “gebremst”. ease ist der Default-Wert und muss daher nicht explizit angegeben werden. Es gibt viele weitere Arten, die Geschwindigkeit der Animation zu gestalten:\nease linear ease-in ease-out ease-in-out cubic-bezier(n,n,n,n) Weitere Informationen zu Transitions erhältst du hier: https://www.w3schools.com/css/css3_transitions.asp\nAnimationen In CSS sind auch Animationen einfach realisierbar - auch ohne die Verwendung von JavaScript.\nIm folgenden Beispiel lassen wir eine Hand winken:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u003cspan class=\"hand\"\u003e🖐\u003c/div\u003e \u003cstyle\u003e .hand { /* transform geht nicht für inline-Elemente: */ display: inline-block; font-size: 72px; /* Animation properties: */ animation-name: wave; animation-duration: 2s; animation-direction: alternate; animation-iteration-count: infinite; } @keyframes wave { 0% {transform: rotate(-90deg);} 10% {transform: rotate(-90deg);} 90% {transform: rotate(90deg);} 100% {transform: rotate(90deg);} } \u003c/style\u003e Das Zentrale an diesem Code-Beispiel ist der @keyframes-Block. Das erste Wort nach diesem Schlüsselbegriff ist der Name, der du der Animation gibst.\nDas 0% steht für den Anfang der Animation, diese Prozentangaben beschreiben also eine Zeitangabe: Zu welchem Zeitpunkt der Animation soll das Element wie gestylt werden?\nDamit du die Animation (hier mit dem Namen wave) verwenden kannst, musst du diese referenzieren: Das hast du mit animation-name: wave gemacht. Anschliessend haben wir die Animation weiter konfiguriert:\nMit animation-direction: alternate haben wir angegeben, dass die Animation wieder rückwärts ablaufen soll, wenn sie durchgelaufen ist. Hierfür war Folgendes ebenfalls notwendig: animation-iteration-count: infinite bewirkt, dass die Animation unendlich wiederholt wird. Das ist bereits alles an Basis-Wissen, das es zu Animationen in CSS zu wissen gibt. Interessierst du dich weiter für Animationen, dann kannst du dein Wissen gerne hier vertiefen: https://www.w3schools.com/css/css3_animations.asp\nDamit du erkennst, wofür Animationen eingesetzt werden können, schaue dir dieses Beispiel an, wie einfach und ohne die Nutzung von Javascript ein Ladebalken implementiert werden kann: https://www.w3schools.com/howto/howto_css_loader.asp\nLöse die Aufgaben 4 und 5 im Lab.\n","categories":"","description":"Modul #F3 - HTML und CSS - Erstelle professionelle Animationen - nur mit CSS und komplett ohne JavaScript.\n","excerpt":"Modul #F3 - HTML und CSS - Erstelle professionelle Animationen - nur …","ref":"/de/docs/03_web/02_html_css/17_css-keyframes/","tags":"","title":"Übergänge und Animationen"},{"body":"Ziele Ich kann in eigenen Worten erklären, was Enums sind und wann man sie nutzt. Ich kann ein Enum definieren und in Code korrekt verwenden (Zuweisung, Vergleich, switch). Ich kann alle Werte eines Enums iterieren (values) und den Namen ausgeben (name). ⏱️ Geschätzte Lesezeit: 10 Minuten Enums – was und wofür? Enums (von „enumeration“ / „Aufzählung“) fassen vordefinierte, feste Werte zu einem eigenen Datentyp zusammen. Typische Beispiele sind Wochentage, Himmelsrichtungen, Zustände (READY, RUNNING, FAILED).\nWann verwenden?\nWenn alle möglichen Werte zur Kompilierzeit bekannt sind und sich nicht dynamisch ändern.\nWichtigste Eigenschaften (Grundlagen):\nEnum-Konstanten sind typsicher (kein „magischer String“). Vergleich geht mit == (es sind einzelne, eindeutige Instanzen). In switch können Enum-Werte direkt verwendet werden. values() liefert alle Werte als Array; name() liefert den Konstantennamen als String. Hinweis: Intern sind Enums Spezialtypen. Die OOP-Details (Konstruktoren, Methoden) folgen im OOP-Modul.\nEnums definieren enum kann top-level (außerhalb einer Klasse) oder innerhalb einer Klasse stehen. Die erste Zeile enthält die Komma-Liste der Konstanten (Konvention: GROSSBUCHSTABEN). Jede Enum-Konstante ist implizit public static final.\nBeispiel: Definition außerhalb einer Klasse 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 enum Weekday { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY } public class DailyPlanner { private static void dailyMood(Weekday day) { switch (day) { case MONDAY: System.out.println(\"Montage sind nicht meine Lieblinge.\"); break; case FRIDAY: System.out.println(\"Zum Glück ist Freitag!\"); break; case SATURDAY: case SUNDAY: System.out.println(\"Wochenende ist zu kurz.\"); break; default: System.out.println(\"Irgendein Wochentag in der Mitte.\"); break; } } public static void main(String[] args) { dailyMood(Weekday.MONDAY); } } Beispiel: Definition innerhalb einer Klasse 1 2 3 4 5 6 7 8 9 public class DailyPlanner { enum Weekday { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY } public static void main(String[] args) { System.out.println(\"Ich mag \" + Weekday.SATURDAY + \" und \" + Weekday.SUNDAY + \".\"); } } Wann sind Enums besser als Strings? Ohne Enums werden oft Strings für Zustände verwendet. Das ist fehleranfällig:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class WebShop { public static void setOrderState(int orderId, String state) { System.out.println(\"Order \" + orderId + \" is now \" + state); } public static void setInvoiceState(int invoiceId, String state) { System.out.println(\"Invoice \" + invoiceId + \" is now \" + state); } } class Demo { public static void main(String[] args) { WebShop.setOrderState(42, \"shipped\"); WebShop.setOrderState(42, \"Shippped\"); // Tippfehler – trotzdem gültig! } } Mit Enums wird das typsicher und klarer:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 enum OrderState { NEW, PROCESSING, SHIPPED, CANCELLED } enum InvoiceState { OPEN, PAID, CANCELLED } public class WebShop { public static void setOrderState(int orderId, OrderState state) { System.out.println(\"Order \" + orderId + \" is now \" + state); } public static void setInvoiceState(int invoiceId, InvoiceState state) { System.out.println(\"Invoice \" + invoiceId + \" is now \" + state); } } class Demo { public static void main(String[] args) { WebShop.setOrderState(42, OrderState.SHIPPED); // WebShop.setOrderState(42, \"Shippped\"); // Compiler-Fehler! :) } } Vorteile:\nKeine Tippfehler möglich (Compiler prüft). Methodenparameter sind klar dokumentiert (welche States erlaubt sind). Typsicherheit: OrderState kann nicht mit InvoiceState verwechselt werden. Alle Werte iterieren \u0026 Namen ausgeben 1 2 3 4 5 6 7 8 9 public class EnumIterationDemo { enum Direction { NORTH, EAST, SOUTH, WEST } public static void main(String[] args) { for (Direction d : Direction.values()) { System.out.println(\"Richtung: \" + d.name()); } } } Merke: Wie Strings sind auch Enums bereits Klassen. Was man damit noch so alles machen kann erfährst Du im OOP-Module. ","categories":"","description":"Enums als typsichere Aufzählung: feste Werte definieren, verwenden und mit switch verarbeiten. Einsatzbereiche, Syntax und Best Practices in statischen Methoden (Utility-Klassen).\n","excerpt":"Enums als typsichere Aufzählung: feste Werte definieren, verwenden und …","ref":"/docs/02_java/03_java-grundlagen/18_enums/","tags":"","title":"Enums – Grundlagen"},{"body":"Ziele Du weisst, was der Angular Life Cycle Hook ist und wozu dieser verwendet wird. Du kennst die verschiedenen Hooks und weisst wozu diese zuständig sind. Angular Life Cycle Hook Lifecycle-Hooks ermöglichen es Entwicklern, Code zu spezifischen Zeitpunkten im Lebenszyklus eines Components auszuführen und somit den Component zu initialisieren, auf Änderungen zu reagieren und Aufräumarbeiten durchzuführen.\nngOnChanges: Wird aufgerufen, wenn einer oder mehrere Input-Properties eines Components sich ändern. Hier kann man auf die Änderungen reagieren und entsprechende Aktionen ausführen.\nngOnInit: Wird einmalig aufgerufen, nachdem Angular die Input-Properties initialisiert hat und bevor der Component gerendert wird. Hier kann man Initialisierungslogik ausführen, Daten abrufen oder Abhängigkeiten initialisieren.\nngDoCheck: Wird bei jedem Angular-Change-Detection-Durchlauf aufgerufen. Hier kann man benutzerdefinierte Änderungsüberprüfungen durchführen, um auf Änderungen zu reagieren, die Angular nicht automatisch erkennt.\nngAfterContentInit: Wird aufgerufen, nachdem der eingebettete Inhalt (Content) im Component initialisiert wurde. Hier kann man auf den eingebetteten Inhalt zugreifen und damit interagieren.\nngAfterContentChecked: Wird nach jedem Angular-Change-Detection-Durchlauf aufgerufen, nachdem der eingebettete Inhalt überprüft wurde. Hier kann man Aktionen ausführen, die nach der Überprüfung des eingebetteten Inhalts erforderlich sind.\nngAfterViewInit: Wird aufgerufen, nachdem die View (DOM) des Components initialisiert wurde. Hier kann man auf die gerenderte View zugreifen und damit interagieren.\nngAfterViewChecked: Wird nach jedem Angular-Change-Detection-Durchlauf aufgerufen, nachdem die View überprüft wurde. Hier kann man Aktionen ausführen, die nach der Überprüfung der View erforderlich sind.\nafterNextRender: Wird einmal ausgeführt, sobald alle Komponenten das nächste Mal im DOM gerendert wurden. Diese kann man verwenden, um manuelle DOM-Operationen durchzuführen.\nafterRender: Wird jedes Mal ausgeführt, wenn alle Komponenten im DOM gerendert wurden. Diese kann man verwenden, um manuelle DOM-Operationen durchzuführen.\nngOnDestroy: Wird aufgerufen, bevor ein Component zerstört wird. Hier kann man bereinigende Aktionen durchführen, Subscriptions beenden oder Ressourcen freigeben.\nafterNextRender \u0026 afterRender Diese Funktionen unterscheiden sich von den anderen beschriebenen Lebenszyklus-Hooks. Anstatt einer Klassenmethode handelt es sich um eigenständige Funktionen, die einen Callback akzeptieren. Die Ausführung von Render-Callbacks ist nicht an eine bestimmte Komponenteninstanz gebunden, sondern erfolgt stattdessen über einen anwendungsweiten Hook.\nDer afterNextRender-Hook wird einmal nach dem jeweiligen Change-Detection-Zyklus durchgeführt. Daher ist dieser Hook gut dazu geeeignet, einmalige Initialisierungen wie die Integration einer Third-Party-Library durchzuführen. Der afterRender-Hook funktioniert hingegen so, dass er nach jedem Change-Detection-Hook ausgeführt wird. Der Hook eignet sich daher also gut dazu, sich wiederholende, nach dem Change-Detection-Hook nötige Anweisungen auszuführen.\nGenauere Informationen zum afterNextRender-Hook und zum afterRender-Hook findest du in der offizielen Angular-Dokumentation: Dokumentation zu afterNextRender Dokumentation zu afterRender\n","categories":"","description":"Modul #F6 - Angular - Life Cycle Hook\n","excerpt":"Modul #F6 - Angular - Life Cycle Hook\n","ref":"/docs/03_web/06_angular/02_18_life_cycle_hook/","tags":"","title":"Life Cycle Hook"},{"body":"Ziele Du weisst, was der Angular Life Cycle Hook ist und wozu dieser verwendet wird. Du kennst die verschiedenen Hooks und weisst wozu diese zuständig sind. Angular Life Cycle Hook Lifecycle-Hooks ermöglichen es Entwicklern, Code zu spezifischen Zeitpunkten im Lebenszyklus eines Components auszuführen und somit den Component zu initialisieren, auf Änderungen zu reagieren und Aufräumarbeiten durchzuführen.\nngOnChanges: Wird aufgerufen, wenn einer oder mehrere Input-Properties eines Components sich ändern. Hier kann man auf die Änderungen reagieren und entsprechende Aktionen ausführen.\nngOnInit: Wird einmalig aufgerufen, nachdem Angular die Input-Properties initialisiert hat und bevor der Component gerendert wird. Hier kann man Initialisierungslogik ausführen, Daten abrufen oder Abhängigkeiten initialisieren.\nngDoCheck: Wird bei jedem Angular-Change-Detection-Durchlauf aufgerufen. Hier kann man benutzerdefinierte Änderungsüberprüfungen durchführen, um auf Änderungen zu reagieren, die Angular nicht automatisch erkennt.\nngAfterContentInit: Wird aufgerufen, nachdem der eingebettete Inhalt (Content) im Component initialisiert wurde. Hier kann man auf den eingebetteten Inhalt zugreifen und damit interagieren.\nngAfterContentChecked: Wird nach jedem Angular-Change-Detection-Durchlauf aufgerufen, nachdem der eingebettete Inhalt überprüft wurde. Hier kann man Aktionen ausführen, die nach der Überprüfung des eingebetteten Inhalts erforderlich sind.\nngAfterViewInit: Wird aufgerufen, nachdem die View (DOM) des Components initialisiert wurde. Hier kann man auf die gerenderte View zugreifen und damit interagieren.\nngAfterViewChecked: Wird nach jedem Angular-Change-Detection-Durchlauf aufgerufen, nachdem die View überprüft wurde. Hier kann man Aktionen ausführen, die nach der Überprüfung der View erforderlich sind.\nafterNextRender: Wird einmal ausgeführt, sobald alle Komponenten das nächste Mal im DOM gerendert wurden. Diese kann man verwenden, um manuelle DOM-Operationen durchzuführen.\nafterRender: Wird jedes Mal ausgeführt, wenn alle Komponenten im DOM gerendert wurden. Diese kann man verwenden, um manuelle DOM-Operationen durchzuführen.\nngOnDestroy: Wird aufgerufen, bevor ein Component zerstört wird. Hier kann man bereinigende Aktionen durchführen, Subscriptions beenden oder Ressourcen freigeben.\nafterNextRender \u0026 afterRender Diese Funktionen unterscheiden sich von den anderen beschriebenen Lebenszyklus-Hooks. Anstatt einer Klassenmethode handelt es sich um eigenständige Funktionen, die einen Callback akzeptieren. Die Ausführung von Render-Callbacks ist nicht an eine bestimmte Komponenteninstanz gebunden, sondern erfolgt stattdessen über einen anwendungsweiten Hook.\nDer afterNextRender-Hook wird einmal nach dem jeweiligen Change-Detection-Zyklus durchgeführt. Daher ist dieser Hook gut dazu geeeignet, einmalige Initialisierungen wie die Integration einer Third-Party-Library durchzuführen. Der afterRender-Hook funktioniert hingegen so, dass er nach jedem Change-Detection-Hook ausgeführt wird. Der Hook eignet sich daher also gut dazu, sich wiederholende, nach dem Change-Detection-Hook nötige Anweisungen auszuführen.\nGenauere Informationen zum afterNextRender-Hook und zum afterRender-Hook findest du in der offizielen Angular-Dokumentation: Dokumentation zu afterNextRender Dokumentation zu afterRender\n","categories":"","description":"Modul #F6 - Angular - Life Cycle Hook\n","excerpt":"Modul #F6 - Angular - Life Cycle Hook\n","ref":"/de/docs/03_web/06_angular/02_18_life_cycle_hook/","tags":"","title":"Life Cycle Hook"},{"body":"Ziele Du weisst, wie du Variablen deklarierst. Du weisst, wann du eine Variable mit var, let oder const deklarieren musst. Du kannst das “Object Destructuring Assignment” anwenden. Basics In JavaScript deklarierst du Variablen mit dem let- oder const-Keyword - egal welcher Typ die Variable haben wird.\nDie folgenden Beispiele zeigen auf, wie du Variablen deklarieren und zuweisen/assignen kannst:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 let a = \"A\"; const b = \"B\"; console.log(a); \u003e\u003e\u003e A console.log(b) \u003e\u003e\u003e B a = \"AA\" console.log(a); \u003e\u003e\u003e AA b = \"BB\" \u003e\u003e\u003e Uncaught TypeError: Assignment to constant variable. at \u003canonymous\u003e:1:3 Wie du siehst, kannst du eine mit let deklarierte Variable verändern. Versuchst du, eine const-Variable neu zu deklarieren, wird ein Fehler geworfen. Es ist jedoch durchaus möglich, einzelne Attribute einer const-Variable zu ändern.\nAls Grundsatz gilt: Verwende immer const, ausser du willst später der Variable im gleichen Scope (nächster Abschnitt) einen anderen Wert zuweisen. Dann verwende let.\nDie Verwendung von const per Default hat den Vorteil, dass so Side-Effects vermieden werden können, welche aufgrund der Neuzuweisung von Variablen auftreten können. Wenn du beispielsweise viele Variablen in einer Funktion hast, müsstest du zuerst sicherstellen, dass deine neue Variable keine bestehende Variable im gleichen Scope überschreibt. Verwendest du standardmässig const, wird im Falle einer Doppelzuweisung ein Fehler geworfen, der dir dann direkt ins Auge sticht.\nJavaScript besitzt keine Typisierung JavaScript ist eine dynamisch typisierte Sprache, was bedeutet, dass die Typen der Variablen und Ausdrücke erst zur Laufzeit und nicht zur Kompilierungszeit festgelegt werden. Im Gegensatz dazu haben andere Sprachen wie Java oder C++ eine statische Typisierung, bei der der Typ einer Variable oder eines Ausdrucks bereits zur Kompilierungszeit festgelegt wird.\nIn JavaScript können Variablen während der Laufzeit ohne Einschränkung ihren Typ ändern. Beispielsweise kann eine Variable zunächst als String initialisiert werden und später im Code auf einen numerischen Wert aktualisiert werden. Das liegt daran, dass JavaScript die Datentypen von Variablen dynamisch zuweist und ihnen erlaubt, sich während der Laufzeit zu ändern.\nObwohl diese Flexibilität ein Vorteil von JavaScript ist, kann sie auch zu unerwarteten Verhaltensweisen führen, wenn der/die Entwickler:in nicht aufpasst. In der Tat kann die mangelnde Typsicherheit in JavaScript ein Nachteil sein, da sie dazu führen kann, dass sich Fehler erst zur Laufzeit manifestieren, anstatt dass sie bereits beim Kompilieren erkannt werden.\nAn diesem Beispiel lässt sich gut erkennen, dass sich die Typen von Variablen während der Laufzeit verändern lassen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 let x = 5; // x = number x = \"Hello World;\"; // x = string const object = { name: \"Max\", age: 30 }; // object = Object object.hobbies = [\"Lesen\", \"Sport treiben\"]; // object kann ohne Probleme erweitert werden function addNumbers(a, b) { return a + b; } // addNumbers kann mit number-Parametern aufgerufen werden: console.log(addNumbers(5, 10)); // 15 // addNumbers kann auch mit string-Parametern aufgerufen werden: console.log(addNumbers(\"5\", \"10\")); // '510' Allerdings gibt es in modernen Versionen von JavaScript (ab ES6) die Möglichkeit, (optionale) Typisierung durch das Verwenden von Typ-Annotationen oder TypeScript hinzuzufügen, welche einer statische Typisierung ähneln können. Dies kann helfen, die Lesbarkeit und die Sicherheit deines Codes zu erhöhen. Wie du die Typen der Parameter in einer Funktion bestimmen kannst, wirst du im Kapitel JSDoc genauer sehen.\nES6 ES6, auch bezeichnet als ECMAScript 2015 oder ECMAScript 6, war die zweite grössere Revision von JavaScript als Sprache, man kann es auch als Update für JavaScript selbst betrachten. Im Rahmen der Einführung von ES6 wurden viele neue Funktionalitäten zur Sprache hinzugefügt, unter anderem:\nDer let-Schlüsselbegriff Der const-Schlüsselbegriff Arrow Functions Die for/of-Schlaufe Map Objects Set Objects Klassen Promises Verschiedene String-Operationen wie beispielsweise String.includes(), String.startsWith() etc. Verschiedene Array-Operationen wie beispielsweise Array.find(), Array.keys() etc. JavaScript-Module Und weitere. Eine vollständige Liste aller Neuerungen im Rahmen der Einführung von ES6 findest du auf der folgenden Webseite: Neuerungen in ES6\nScope Block-Scope Variablen, die mit const oder let definiert wurden, sind in ihrem jeweiligen Scope sichtbar und verwendbar.\nEs ist wichtig, dass du den folgenden Code komplett verstehst und weisst, wieso er zum entsprechenden Resultat führt - und warum die Verwendung von const nicht zu einem Fehler führt:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const a = \"File\"; console.log(1, a); function myFunction(a = \"Argument\") { console.log(2, a); if (true) { const a = \"if\"; console.log(3, a); } console.log(4, a); } myFunction(); console.log(5, a); Dies produziert folgenden Output:\n1 2 3 4 5 1 File 2 Argument 3 if 4 Argument 5 File Global Scope und Function Scope Vor ES6 kannte JavaScript keinen Block-Scope, sondern nur einen globalen Scope und einen Function Scope.\nUm das zu verstehen, lass diesen Code einmal laufen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 var a = 10; console.log(a); function myFunction(a = 20) { console.log(a); if (true) { var a = 21; console.log(a); for (var a = 30; a \u003c 33; a++) { console.log(a); for (var a = 40; a \u003c 44; a++) { console.log(a); } } console.log(a); } console.log(a); } myFunction(); console.log(a); var a = 11; console.log(a); Du solltest dann folgende Zahlen im Output erhalten:\n1 10, 20, 21, 30, 40, 41, 42, 43, 45, 45, 10, 11; Wie du siehst, haben alle Variablen, die innerhalb einer Funktion mit var deklariert werden, den gleichen Scope: Das bedeutet, wenn du beispielsweise eine var-Variable, die du ganz oben in der Funktion definierst, veränderst, wenn du eine gleichnamige später in einer for-Schleife mit var definierst.\nEinen solchen Function Scope haben nur Variablen, die mit var definiert wurden. Variablen, die mit let oder const definiert wurden, haben einen Block-Scope und sind daher innerhalb ihres Blocks (for/while-Schlaufe, if/else-Block, Funktion, Datei) definiert und sichtbar. In Java gilt der Block Scope immer.\nHierzu findest du eine Aufgabe im Lab (Aufgabe 4).\nWann var verwenden? Folgender Grundsatz gilt:\nVerwende nie var, ausser du musst sicherstellen, dass der Code in Browsern funktioniert, welche zuletzt vor 2015 aktualisiert wurden.\nWenn du wissen willst, wieso var nicht mehr verwendet werden sollte, dann kannst du dein Wissen auf dieser Seite vertiefen: https://medium.com/@codingsam/awesome-javascript-no-more-var-working-title-999428999994.\ntypeof Operator typeof ist ein Operator, der den Datentyp eines Ausdrucks oder einer Variable zurückgibt. Er kann verwendet werden, um zu überprüfen, ob eine Variable einen primitiven Datentypen (auch string) hat, bevor eine Operation durchgeführt wird, die nur für diesen Datentyp geeignet ist.\ntypeof gibt einen String zurück, der den Datentyp des Operanden darstellt. Die möglichen Rückgabewerte sind:\nundefined für undefined-Werte boolean für boolesche Werte number für Zahlen string für Zeichenketten object für Objekte (einschliesslich Arrays und null-Werte) function für Funktionen 1 2 3 4 5 6 7 8 typeof 42; // 'number' typeof \"hello\"; // 'string' typeof true; // 'boolean' typeof undefined; // 'undefined' typeof null; // 'object' typeof []; // 'object' typeof {}; // 'object' typeof function () {}; // 'function' Es ist wichtig zu beachten, dass typeof nicht immer genau den Datentyp zurückgibt, den man erwartet. Insbesondere gibt typeof(null) “object” aus, obwohl null eigentlich kein Objekt ist. Es ist daher oft besser, zusätzlich zu typeof andere Überprüfungen durchzuführen, um sicherzustellen, dass eine Variable den erwarteten Datentyp hat.\ninstanceof Operator Auch der instanceof Operator wird verwendet, um festzustellen, ob ein Objekt einen bestimmten Typ hat. Er gibt ein boolesches Ergebnis zurück, das angibt, ob das übergebene Objekt eine Instanz des angegebenen Typs ist.\nZu beachten ist zudem, dass instanceof bei primitive Datentypen nicht zur Überprüfung geeignet ist, da diese keine Objekte sind. In diesem Fall würde sich typeof besser eignen.\n1 2 3 4 5 6 7 8 9 const numberVar = 1; const stringVar = \"abc\"; const arrayVar = [1, 2, 3]; const objectVar = { name: \"Max\", age: 20 }; console.log(numberVar instanceof Number); // false console.log(stringVar instanceof String); // false console.log(arrayVar instanceof Array); // true console.log(objectVar instanceof Object); // true Man kann auch instanceof und typeof kombinieren, um sicherstellen, dass die Variable sowohl den erwarteten Datentyp als auch den erwarteten Wertebereich entspricht.\n1 2 3 4 5 6 7 8 9 const numberVar = 1; const stringVar = \"abc\"; const arrayVar = [1, 2, 3]; const objectVar = { name: \"Max\", age: 20 }; console.log(numberVar instanceof Number || typeof numberVar === \"number\"); // true console.log(stringVar instanceof String || typeof stringVar === \"string\"); // true console.log(arrayVar instanceof Array); // true console.log(objectVar instanceof Object); // true typeof vs. instanceof typeof ist besser geeignet, um primitive Datentypen wie Strings, numbers und Booleans zu überprüfen.\ninstanceof ist hingegen besser geeignet, um den Datentyp von Objekten zu überprüfen, einschliesslich Arrays, Funktionen und benutzerdefinierten Objekten. Damit lässt sich ebenfalls prüfen, ob ein Objekt auf Basis einer bestimmten Klasse erstellt wurde.\nDestructuring Assignment In JavaScript lässt sich oft beobachten, dass mehrere Variablen auf einmal definiert werden.\nWie in anderen Programmiersprachen kannst du mehrere Variablen in einem einzigen Statement definieren (das ist kein Destructuring Assignment!):\n1 2 const a = \"A\", b = \"B\"; So kommt es oft vor, dass du mit einem einzigen Methodenaufruf mehrere Werte zurückbekommst - zum Beispiel in Form eines Arrays/ einer Liste oder in Form eines Objekts. Oft willst du dann die einzelnen Werte in eigenen Variablen speichern. Wie du das machen kannst, wird in den nächsten zwei Abschnitten behandelt:\nDestructuring Arrays Hast du ein Array und willst zum Beispiel den ersten und zweiten Wert aus diesem je einer Variablen zuweisen, dann wäre die normale Vorgehensweise die folgende:\n1 2 3 const array = [\"A\", \"B\"]; const a = array[0], b = array[1]; Diese Schreibweise lässt sich aber mit folgender Syntax vereinfachen:\n1 const [a, b] = [\"A\", \"B\"]; Ist beispielsweise das erste Element ein Index/Key/Zeilen- beziehungsweise Spaltenname und der Rest das eigentliche Array, dann hilft dir vielleicht diese Schreibweise (achte hierbei auf die Nutzung des Spread-Operators (...):\n1 const [name, ...values] = [\"ColumnName\", 1, 2, 3, 4]; Hier hat name den Wert “ColumnName” und values ist das Array [1, 2, 3, 4].\nObject Destructuring Diese Schreibweise hast du sicher bereits einmal gesehen:\n1 const { a, b } = anotherObject; Das ist grundsätzich ein relativ einfaches Prinzip. Wenn du den nachfolgenden Code verstanden hast, dann weisst du alles, was du zu diesem Thema wissen musst:\n1 2 3 4 5 6 const object = {a: \"A\", b: \"B\", c: \"C\", d: \"D\"}; const {a: one, d, b} = object; console.log(one, b, d); \u003e\u003e\u003e A B D In diesem Beispiel haben wir den Wert für a in die Variable one kopiert.\nWie du siehst, spielt hier die Reihenfolge der Variablen keine Rolle.\nDie ersten zwei Anweisungen könnten auch in einer zusammengefasst werden:\n1 const { a: one, d, b } = { a: \"A\", b: \"B\", c: \"C\", d: \"D\" }; Ignorieren wir zuerst die Variable a bzw. one.\nAuf der linken Seite deklarieren wir die Variablen d und b. Die Felder d und b aus dem Objekt auf der rechten Seite werden in die Variablen d und b auf der linken Seite kopiert. Die Variablen auf der linken Seite müssen nicht zwingend in der gleichen Reihenfolge stehen wie auf der rechten Seite, sie müssen lediglich gleich heissen. Auf der linken Seite sieht a: one vielleicht noch verwirrend aus, vor allem wenn du bereits TypeScript kennst. Das bedeutet aber nur, dass du die Variable a von der rechten Seite in eine Variable mit einem anderen Namen one kopierst. Folglich hast du eine Variable one deklariert und zugewiesen. Eine Variable a hast du hier aber NICHT deklariert. Anschliessend gibst du die Werte von one, b und d mit console.log(one, b, d); aus. Hätten wir versucht, eine Variable a auszugeben, hätte das einen Fehler verursacht, weil keine solche Variable definiert wurde. ","categories":"","description":"Modul #F4 - JavaScript - Seit ES2015 (ES6) gibt es in JavaScript weitere neue Möglichkeiten, wie Variablen definiert werden können. Hier schauen wir uns einige davon an.\n","excerpt":"Modul #F4 - JavaScript - Seit ES2015 (ES6) gibt es in JavaScript …","ref":"/docs/03_web/03_javascript/19_variables/","tags":"","title":"ES6: Variablen deklarieren"},{"body":"Ziele Du weisst, wie du Variablen deklarierst. Du weisst, wann du eine Variable mit var, let oder const deklarieren musst. Du kannst das “Object Destructuring Assignment” anwenden. Basics In JavaScript deklarierst du Variablen mit dem let- oder const-Keyword - egal welcher Typ die Variable haben wird.\nDie folgenden Beispiele zeigen auf, wie du Variablen deklarieren und zuweisen/assignen kannst:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 let a = \"A\"; const b = \"B\"; console.log(a); \u003e\u003e\u003e A console.log(b) \u003e\u003e\u003e B a = \"AA\" console.log(a); \u003e\u003e\u003e AA b = \"BB\" \u003e\u003e\u003e Uncaught TypeError: Assignment to constant variable. at \u003canonymous\u003e:1:3 Wie du siehst, kannst du eine mit let deklarierte Variable verändern. Versuchst du, eine const-Variable neu zu deklarieren, wird ein Fehler geworfen. Es ist jedoch durchaus möglich, einzelne Attribute einer const-Variable zu ändern.\nAls Grundsatz gilt: Verwende immer const, ausser du willst später der Variable im gleichen Scope (nächster Abschnitt) einen anderen Wert zuweisen. Dann verwende let.\nDie Verwendung von const per Default hat den Vorteil, dass so Side-Effects vermieden werden können, welche aufgrund der Neuzuweisung von Variablen auftreten können. Wenn du beispielsweise viele Variablen in einer Funktion hast, müsstest du zuerst sicherstellen, dass deine neue Variable keine bestehende Variable im gleichen Scope überschreibt. Verwendest du standardmässig const, wird im Falle einer Doppelzuweisung ein Fehler geworfen, der dir dann direkt ins Auge sticht.\nJavaScript besitzt keine Typisierung JavaScript ist eine dynamisch typisierte Sprache, was bedeutet, dass die Typen der Variablen und Ausdrücke erst zur Laufzeit und nicht zur Kompilierungszeit festgelegt werden. Im Gegensatz dazu haben andere Sprachen wie Java oder C++ eine statische Typisierung, bei der der Typ einer Variable oder eines Ausdrucks bereits zur Kompilierungszeit festgelegt wird.\nIn JavaScript können Variablen während der Laufzeit ohne Einschränkung ihren Typ ändern. Beispielsweise kann eine Variable zunächst als String initialisiert werden und später im Code auf einen numerischen Wert aktualisiert werden. Das liegt daran, dass JavaScript die Datentypen von Variablen dynamisch zuweist und ihnen erlaubt, sich während der Laufzeit zu ändern.\nObwohl diese Flexibilität ein Vorteil von JavaScript ist, kann sie auch zu unerwarteten Verhaltensweisen führen, wenn der/die Entwickler:in nicht aufpasst. In der Tat kann die mangelnde Typsicherheit in JavaScript ein Nachteil sein, da sie dazu führen kann, dass sich Fehler erst zur Laufzeit manifestieren, anstatt dass sie bereits beim Kompilieren erkannt werden.\nAn diesem Beispiel lässt sich gut erkennen, dass sich die Typen von Variablen während der Laufzeit verändern lassen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 let x = 5; // x = number x = \"Hello World;\"; // x = string const object = { name: \"Max\", age: 30 }; // object = Object object.hobbies = [\"Lesen\", \"Sport treiben\"]; // object kann ohne Probleme erweitert werden function addNumbers(a, b) { return a + b; } // addNumbers kann mit number-Parametern aufgerufen werden: console.log(addNumbers(5, 10)); // 15 // addNumbers kann auch mit string-Parametern aufgerufen werden: console.log(addNumbers(\"5\", \"10\")); // '510' Allerdings gibt es in modernen Versionen von JavaScript (ab ES6) die Möglichkeit, (optionale) Typisierung durch das Verwenden von Typ-Annotationen oder TypeScript hinzuzufügen, welche einer statische Typisierung ähneln können. Dies kann helfen, die Lesbarkeit und die Sicherheit deines Codes zu erhöhen. Wie du die Typen der Parameter in einer Funktion bestimmen kannst, wirst du im Kapitel JSDoc genauer sehen.\nES6 ES6, auch bezeichnet als ECMAScript 2015 oder ECMAScript 6, war die zweite grössere Revision von JavaScript als Sprache, man kann es auch als Update für JavaScript selbst betrachten. Im Rahmen der Einführung von ES6 wurden viele neue Funktionalitäten zur Sprache hinzugefügt, unter anderem:\nDer let-Schlüsselbegriff Der const-Schlüsselbegriff Arrow Functions Die for/of-Schlaufe Map Objects Set Objects Klassen Promises Verschiedene String-Operationen wie beispielsweise String.includes(), String.startsWith() etc. Verschiedene Array-Operationen wie beispielsweise Array.find(), Array.keys() etc. JavaScript-Module Und weitere. Eine vollständige Liste aller Neuerungen im Rahmen der Einführung von ES6 findest du auf der folgenden Webseite: Neuerungen in ES6\nScope Block-Scope Variablen, die mit const oder let definiert wurden, sind in ihrem jeweiligen Scope sichtbar und verwendbar.\nEs ist wichtig, dass du den folgenden Code komplett verstehst und weisst, wieso er zum entsprechenden Resultat führt - und warum die Verwendung von const nicht zu einem Fehler führt:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const a = \"File\"; console.log(1, a); function myFunction(a = \"Argument\") { console.log(2, a); if (true) { const a = \"if\"; console.log(3, a); } console.log(4, a); } myFunction(); console.log(5, a); Dies produziert folgenden Output:\n1 2 3 4 5 1 File 2 Argument 3 if 4 Argument 5 File Global Scope und Function Scope Vor ES6 kannte JavaScript keinen Block-Scope, sondern nur einen globalen Scope und einen Function Scope.\nUm das zu verstehen, lass diesen Code einmal laufen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 var a = 10; console.log(a); function myFunction(a = 20) { console.log(a); if (true) { var a = 21; console.log(a); for (var a = 30; a \u003c 33; a++) { console.log(a); for (var a = 40; a \u003c 44; a++) { console.log(a); } } console.log(a); } console.log(a); } myFunction(); console.log(a); var a = 11; console.log(a); Du solltest dann folgende Zahlen im Output erhalten:\n1 10, 20, 21, 30, 40, 41, 42, 43, 45, 45, 10, 11; Wie du siehst, haben alle Variablen, die innerhalb einer Funktion mit var deklariert werden, den gleichen Scope: Das bedeutet, wenn du beispielsweise eine var-Variable, die du ganz oben in der Funktion definierst, veränderst, wenn du eine gleichnamige später in einer for-Schleife mit var definierst.\nEinen solchen Function Scope haben nur Variablen, die mit var definiert wurden. Variablen, die mit let oder const definiert wurden, haben einen Block-Scope und sind daher innerhalb ihres Blocks (for/while-Schlaufe, if/else-Block, Funktion, Datei) definiert und sichtbar. In Java gilt der Block Scope immer.\nHierzu findest du eine Aufgabe im Lab (Aufgabe 4).\nWann var verwenden? Folgender Grundsatz gilt:\nVerwende nie var, ausser du musst sicherstellen, dass der Code in Browsern funktioniert, welche zuletzt vor 2015 aktualisiert wurden.\nWenn du wissen willst, wieso var nicht mehr verwendet werden sollte, dann kannst du dein Wissen auf dieser Seite vertiefen: https://medium.com/@codingsam/awesome-javascript-no-more-var-working-title-999428999994.\ntypeof Operator typeof ist ein Operator, der den Datentyp eines Ausdrucks oder einer Variable zurückgibt. Er kann verwendet werden, um zu überprüfen, ob eine Variable einen primitiven Datentypen (auch string) hat, bevor eine Operation durchgeführt wird, die nur für diesen Datentyp geeignet ist.\ntypeof gibt einen String zurück, der den Datentyp des Operanden darstellt. Die möglichen Rückgabewerte sind:\nundefined für undefined-Werte boolean für boolesche Werte number für Zahlen string für Zeichenketten object für Objekte (einschliesslich Arrays und null-Werte) function für Funktionen 1 2 3 4 5 6 7 8 typeof 42; // 'number' typeof \"hello\"; // 'string' typeof true; // 'boolean' typeof undefined; // 'undefined' typeof null; // 'object' typeof []; // 'object' typeof {}; // 'object' typeof function () {}; // 'function' Es ist wichtig zu beachten, dass typeof nicht immer genau den Datentyp zurückgibt, den man erwartet. Insbesondere gibt typeof(null) “object” aus, obwohl null eigentlich kein Objekt ist. Es ist daher oft besser, zusätzlich zu typeof andere Überprüfungen durchzuführen, um sicherzustellen, dass eine Variable den erwarteten Datentyp hat.\ninstanceof Operator Auch der instanceof Operator wird verwendet, um festzustellen, ob ein Objekt einen bestimmten Typ hat. Er gibt ein boolesches Ergebnis zurück, das angibt, ob das übergebene Objekt eine Instanz des angegebenen Typs ist.\nZu beachten ist zudem, dass instanceof bei primitive Datentypen nicht zur Überprüfung geeignet ist, da diese keine Objekte sind. In diesem Fall würde sich typeof besser eignen.\n1 2 3 4 5 6 7 8 9 const numberVar = 1; const stringVar = \"abc\"; const arrayVar = [1, 2, 3]; const objectVar = { name: \"Max\", age: 20 }; console.log(numberVar instanceof Number); // false console.log(stringVar instanceof String); // false console.log(arrayVar instanceof Array); // true console.log(objectVar instanceof Object); // true Man kann auch instanceof und typeof kombinieren, um sicherstellen, dass die Variable sowohl den erwarteten Datentyp als auch den erwarteten Wertebereich entspricht.\n1 2 3 4 5 6 7 8 9 const numberVar = 1; const stringVar = \"abc\"; const arrayVar = [1, 2, 3]; const objectVar = { name: \"Max\", age: 20 }; console.log(numberVar instanceof Number || typeof numberVar === \"number\"); // true console.log(stringVar instanceof String || typeof stringVar === \"string\"); // true console.log(arrayVar instanceof Array); // true console.log(objectVar instanceof Object); // true typeof vs. instanceof typeof ist besser geeignet, um primitive Datentypen wie Strings, numbers und Booleans zu überprüfen.\ninstanceof ist hingegen besser geeignet, um den Datentyp von Objekten zu überprüfen, einschliesslich Arrays, Funktionen und benutzerdefinierten Objekten. Damit lässt sich ebenfalls prüfen, ob ein Objekt auf Basis einer bestimmten Klasse erstellt wurde.\nDestructuring Assignment In JavaScript lässt sich oft beobachten, dass mehrere Variablen auf einmal definiert werden.\nWie in anderen Programmiersprachen kannst du mehrere Variablen in einem einzigen Statement definieren (das ist kein Destructuring Assignment!):\n1 2 const a = \"A\", b = \"B\"; So kommt es oft vor, dass du mit einem einzigen Methodenaufruf mehrere Werte zurückbekommst - zum Beispiel in Form eines Arrays/ einer Liste oder in Form eines Objekts. Oft willst du dann die einzelnen Werte in eigenen Variablen speichern. Wie du das machen kannst, wird in den nächsten zwei Abschnitten behandelt:\nDestructuring Arrays Hast du ein Array und willst zum Beispiel den ersten und zweiten Wert aus diesem je einer Variablen zuweisen, dann wäre die normale Vorgehensweise die folgende:\n1 2 3 const array = [\"A\", \"B\"]; const a = array[0], b = array[1]; Diese Schreibweise lässt sich aber mit folgender Syntax vereinfachen:\n1 const [a, b] = [\"A\", \"B\"]; Ist beispielsweise das erste Element ein Index/Key/Zeilen- beziehungsweise Spaltenname und der Rest das eigentliche Array, dann hilft dir vielleicht diese Schreibweise (achte hierbei auf die Nutzung des Spread-Operators (...):\n1 const [name, ...values] = [\"ColumnName\", 1, 2, 3, 4]; Hier hat name den Wert “ColumnName” und values ist das Array [1, 2, 3, 4].\nObject Destructuring Diese Schreibweise hast du sicher bereits einmal gesehen:\n1 const { a, b } = anotherObject; Das ist grundsätzich ein relativ einfaches Prinzip. Wenn du den nachfolgenden Code verstanden hast, dann weisst du alles, was du zu diesem Thema wissen musst:\n1 2 3 4 5 6 const object = {a: \"A\", b: \"B\", c: \"C\", d: \"D\"}; const {a: one, d, b} = object; console.log(one, b, d); \u003e\u003e\u003e A B D In diesem Beispiel haben wir den Wert für a in die Variable one kopiert.\nWie du siehst, spielt hier die Reihenfolge der Variablen keine Rolle.\nDie ersten zwei Anweisungen könnten auch in einer zusammengefasst werden:\n1 const { a: one, d, b } = { a: \"A\", b: \"B\", c: \"C\", d: \"D\" }; Ignorieren wir zuerst die Variable a bzw. one.\nAuf der linken Seite deklarieren wir die Variablen d und b. Die Felder d und b aus dem Objekt auf der rechten Seite werden in die Variablen d und b auf der linken Seite kopiert. Die Variablen auf der linken Seite müssen nicht zwingend in der gleichen Reihenfolge stehen wie auf der rechten Seite, sie müssen lediglich gleich heissen. Auf der linken Seite sieht a: one vielleicht noch verwirrend aus, vor allem wenn du bereits TypeScript kennst. Das bedeutet aber nur, dass du die Variable a von der rechten Seite in eine Variable mit einem anderen Namen one kopierst. Folglich hast du eine Variable one deklariert und zugewiesen. Eine Variable a hast du hier aber NICHT deklariert. Anschliessend gibst du die Werte von one, b und d mit console.log(one, b, d); aus. Hätten wir versucht, eine Variable a auszugeben, hätte das einen Fehler verursacht, weil keine solche Variable definiert wurde. ","categories":"","description":"Modul #F4 - JavaScript - Seit ES2015 (ES6) gibt es in JavaScript weitere neue Möglichkeiten, wie Variablen definiert werden können. Hier schauen wir uns einige davon an.\n","excerpt":"Modul #F4 - JavaScript - Seit ES2015 (ES6) gibt es in JavaScript …","ref":"/de/docs/03_web/03_javascript/19_variables/","tags":"","title":"ES6: Variablen deklarieren"},{"body":"In Frontend-Projekten wirst du immer wieder mit der Frage konfrontiert sein, ob bereits ein Objekt gleich gestylt wurde wie eines, welches du gerade stylen möchtest. Wenn dem so ist, wirst du es aber eventuell nicht finden, womit du dieselbe Regel je nachdem zweimal schreiben müsstest. Das führt oft dazu, dass im Code viele “CSS-Leichen” zu finden sind.\nUm diesem Problem entgegenzuwirken, verwendet man oft eine CSS-Datei, die für das ganze Projekt gelten soll. (styles.css)\nWenn du aber oft das Projekt wechselst, wirst du nicht den Überblick behalten können, welche Konzepte vorgehend mit CSS umgesetzt wurden.\nAus diesem Grund kann es Sinn machen, projektübergreifend ein standardisiertes CSS-Framework zu verwenden, wo die gleichen CSS-Klassen auch immer den gleichen Namen verwenden.\nHier kommt Bootstrap ins Spiel: Das Framework stellt viele CSS-Klassen bereit und vereinfacht komplexes Styling zum Teil enorm. Du kannst beispielsweise komplett mühelos Accordions (beziehungsweise Tabs) erstellen, die dann beim Klick auf deren Titel ihren Inhalt jeweils anzeigen oder verstecken.\nBootstrap Bootstrap wird in sehr vielen Projekten bereits benutzt. Das Framework in eine HTML-Datei einzubinden ist relativ einfach:\n1 2 3 4 5 6 7 8 \u003c!-- Latest compiled and minified CSS --\u003e \u003clink href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css\" rel=\"stylesheet\" /\u003e \u003c!-- Latest compiled JavaScript --\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js\"\u003e\u003c/script\u003e Eine grosse Stärke von Bootstrap ist es, dass sich deine Seite ‘responsive’ verhält: Du kannst mit einer Bootstrap-Klasse (col-md-4) definieren, dass ein Element im Normalfall 4/12 der Breite einnehmen soll (4 ist in der Klasse angegeben, Bootstrap arbeitet mit 12 Spalten). Ist dein Browser weniger breit als eine bestimmte Weite (md -\u003e medium), so werden dann die Elemente automatisch untereinander angezeigt.\nDa wir vermehrt Bootstrap einsetzen möchten, empfehlen wir dir, das Framework genauer anzuschauen. Hier findest du ein Tutorial zur aktuellen Version: https://www.w3schools.com/bootstrap5/index.php.\nBitte schaue die folgenden Kapitel so weit an, dass du die behandelten Punkte praktisch anwenden kannst:\nGET Started Containers Grid Basic Tables Buttons Collapse Flex Von den folgenden Abschnitten solltest du lediglich mitnehmen, dass Bootstrap für die behandelten Fälle auch Lösungen bereitstellt:\nColors Images Alerts Button Groups Badges Progress Bars \u0026 Spinners Pagination List Groups Cards Dropdowns Navbar Carousel Modal Tooltip Popover Toast Scrollspy Utilities alles unter Forms Hierzu findest du die Aufgabe 6 im Lab.\n","categories":"","description":"Modul #F3 - HTML und CSS - Einmal CSS schreiben genügt! Brauch ein CSS-Framework, damit du nicht immer wieder die gleichen CSS-Regeln schreiben musst.\n","excerpt":"Modul #F3 - HTML und CSS - Einmal CSS schreiben genügt! Brauch ein …","ref":"/docs/03_web/02_html_css/18_css-bootstrap/","tags":"","title":"Bootstrap"},{"body":"In Frontend-Projekten wirst du immer wieder mit der Frage konfrontiert sein, ob bereits ein Objekt gleich gestylt wurde wie eines, welches du gerade stylen möchtest. Wenn dem so ist, wirst du es aber eventuell nicht finden, womit du dieselbe Regel je nachdem zweimal schreiben müsstest. Das führt oft dazu, dass im Code viele “CSS-Leichen” zu finden sind.\nUm diesem Problem entgegenzuwirken, verwendet man oft eine CSS-Datei, die für das ganze Projekt gelten soll. (styles.css)\nWenn du aber oft das Projekt wechselst, wirst du nicht den Überblick behalten können, welche Konzepte vorgehend mit CSS umgesetzt wurden.\nAus diesem Grund kann es Sinn machen, projektübergreifend ein standardisiertes CSS-Framework zu verwenden, wo die gleichen CSS-Klassen auch immer den gleichen Namen verwenden.\nHier kommt Bootstrap ins Spiel: Das Framework stellt viele CSS-Klassen bereit und vereinfacht komplexes Styling zum Teil enorm. Du kannst beispielsweise komplett mühelos Accordions (beziehungsweise Tabs) erstellen, die dann beim Klick auf deren Titel ihren Inhalt jeweils anzeigen oder verstecken.\nBootstrap Bootstrap wird in sehr vielen Projekten bereits benutzt. Das Framework in eine HTML-Datei einzubinden ist relativ einfach:\n1 2 3 4 5 6 7 8 \u003c!-- Latest compiled and minified CSS --\u003e \u003clink href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css\" rel=\"stylesheet\" /\u003e \u003c!-- Latest compiled JavaScript --\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js\"\u003e\u003c/script\u003e Eine grosse Stärke von Bootstrap ist es, dass sich deine Seite ‘responsive’ verhält: Du kannst mit einer Bootstrap-Klasse (col-md-4) definieren, dass ein Element im Normalfall 4/12 der Breite einnehmen soll (4 ist in der Klasse angegeben, Bootstrap arbeitet mit 12 Spalten). Ist dein Browser weniger breit als eine bestimmte Weite (md -\u003e medium), so werden dann die Elemente automatisch untereinander angezeigt.\nDa wir vermehrt Bootstrap einsetzen möchten, empfehlen wir dir, das Framework genauer anzuschauen. Hier findest du ein Tutorial zur aktuellen Version: https://www.w3schools.com/bootstrap5/index.php.\nBitte schaue die folgenden Kapitel so weit an, dass du die behandelten Punkte praktisch anwenden kannst:\nGET Started Containers Grid Basic Tables Buttons Collapse Flex Von den folgenden Abschnitten solltest du lediglich mitnehmen, dass Bootstrap für die behandelten Fälle auch Lösungen bereitstellt:\nColors Images Alerts Button Groups Badges Progress Bars \u0026 Spinners Pagination List Groups Cards Dropdowns Navbar Carousel Modal Tooltip Popover Toast Scrollspy Utilities alles unter Forms Hierzu findest du die Aufgabe 6 im Lab.\n","categories":"","description":"Modul #F3 - HTML und CSS - Einmal CSS schreiben genügt! Brauch ein CSS-Framework, damit du nicht immer wieder die gleichen CSS-Regeln schreiben musst.\n","excerpt":"Modul #F3 - HTML und CSS - Einmal CSS schreiben genügt! Brauch ein …","ref":"/de/docs/03_web/02_html_css/18_css-bootstrap/","tags":"","title":"Bootstrap"},{"body":"Motivation Seit ES2015 (ES6) gibt es in JavaScript die Möglichkeit, Exporte aus anderen JavaScript-Dateien zu importieren.\nZiele Du weisst, wann du in JavaScript das Keyword import brauchen kannst. Du weisst, wie du exports importieren kannst. Du weisst, welche Variablen, Klassen, Methoden etc. in einer Datei public sind. Du kennst die Unterschiede zwischen default und named Exports und Imports. Basics Was ist das Ergebnis, wenn ein Browser eine JavaScript-Datei mit folgendem Inhalt lädt?\n1 var x = \"Gugus\"; Diese Datei bewirkt, dass in allen anderen Dateien je nachdem die ominöse Variable x ebenfalls verfügbar ist, abhängig davon, was zuerst geladen wird.\nDas ist in vielerlei Hinsicht unvorteilhaft:\nWas, wenn in mehreren Dateien eine Variable x deklariert wird? Was, wenn wir diese Variable eigentlich gar nicht veröffentlichen wollten? Diese Variable ist möglicherweise in den Entwicklertools ([F12]-Taste) in der Konsole direkt ohne Aufwand auslesbar und manipulierbar. Was, wenn du eine gleichnamige Variable aus einer anderen Datei benötigst? Um eben diesen Problemen aus dem Weg zu gehen, wurden in ES6 JavaScript-Modules eingeführt.\nHast du in einer JavaScript-Datei Variablen, Funktionen oder Klassen, die du in einer anderen Datei brauchen willst, dann kannst du diese wie folgt deklarieren:\n1 2 3 4 5 6 7 8 9 export const a = \"A\"; export const b = \"B\"; export class Person { name; constructor(name) { this.name = name; } } Nun kannst du diese Variablen in einer anderen JavaScript-Datei wie folgt importieren:\n1 import { a, b, Person } from \"./path/to/your/file.js\"; Imports in HTML-Dateien Vielleicht kommst du mal in die Situation, dass du in einem Browser ohne JS-Framework wie React oder Angular ein JavaScript-Modul laden möchtest. Das kannst du in HTML wie folgt machen:\n1 2 3 4 \u003cscript type=\"module\"\u003e import { a, b, Person } from \"./file.js\"; console.log(a, b, new Person(\"Monkey Puppet\")); \u003c/script\u003e Beachte, dass die type-Angabe im \u003cscript\u003e-Tag zwingend ist und die Imports nur innerhalb dieses \u003cscript\u003e-Tags verfügbar sind.\nMöchtest du ohne die Angabe von type=\"module\" Variablen importieren (beispielsweise in den Entwicklertools deines Browsers), dann kannst du nicht wie gewohnt das import-Keyword benutzen. Importieren kannst du dann auf die folgende Art:\n1 const { a, b, Person } = await import(\"./file.js\"); In diesem Beispiel hast du import(...) wie eine Funktion verwendet. Weil diese “Funktion” ein Promise zurückgibt (da sie das Modul asynchron lädt), sollte hier der Import awaited werden. So kann sichergestellt werden, dass der später folgende Code erst aufgerufen wird, nachdem das Modul komplett geladen wurde. Falls du dich nicht mit async und await auskennst, solltest du den Abschnitt Promises noch einmal anschauen.\ndefault Ex- und Importe Das ES6-Modul-System unterscheidet zwischen default- und named-Exporten:\nEine Datei kann mehrere named-Exporte haben. Alle in den bisherigen Beispielen gemachten Exporte waren named-Exporte. Eine Datei kann hingegen nur einen default Export besitzen. Wenn eine Datei z.B. nur etwas exportieren soll, dann eignet sich ein default-Export hierfür. Angenommen, wir haben eine Datei person.js, die eine Klasse und ein paar Utility-Funktionen zu dieser Klasse anbietet, dann können die Exporte aussehen wie folgt:\n1 2 3 4 5 6 7 8 9 10 11 12 13 export default class Person { name; constructor(name) { this.name = name; } } export function personFromJson(jsonString) { const obj = JSON.parse(jsonString); return new Person(obj.name); } export function getNameOfPerson(person) { return person.name; } Dieses Beispiel wiederum kann beispielsweise importiert werden wie folgt:\n1 2 3 4 5 6 7 8 import ClassForPerson, { personFromJson, getNameOfPerson } from \"./person.js\"; const person = personFromJson('{\"name\": \"Mr. Incredible\"}'); console.log(getNameOfPerson(person)); \u003e\u003e\u003e Mr. Incredible console.log(person instanceof ClassForPerson); \u003e\u003e\u003e true Wie du hier sehen kannst, können wir den default-Export mit irgendeinem Namen importieren, der nicht mit dem Namen in der Export-Datei übereinstimmen muss.\n","categories":"","description":"Modul #F4 - JavaScript - Aus anderen JavaScript-Dateien importieren\n","excerpt":"Modul #F4 - JavaScript - Aus anderen JavaScript-Dateien importieren\n","ref":"/docs/03_web/03_javascript/20_imports/","tags":"","title":"ES6: Importe"},{"body":"Motivation Seit ES2015 (ES6) gibt es in JavaScript die Möglichkeit, Exporte aus anderen JavaScript-Dateien zu importieren.\nZiele Du weisst, wann du in JavaScript das Keyword import brauchen kannst. Du weisst, wie du exports importieren kannst. Du weisst, welche Variablen, Klassen, Methoden etc. in einer Datei public sind. Du kennst die Unterschiede zwischen default und named Exports und Imports. Basics Was ist das Ergebnis, wenn ein Browser eine JavaScript-Datei mit folgendem Inhalt lädt?\n1 var x = \"Gugus\"; Diese Datei bewirkt, dass in allen anderen Dateien je nachdem die ominöse Variable x ebenfalls verfügbar ist, abhängig davon, was zuerst geladen wird.\nDas ist in vielerlei Hinsicht unvorteilhaft:\nWas, wenn in mehreren Dateien eine Variable x deklariert wird? Was, wenn wir diese Variable eigentlich gar nicht veröffentlichen wollten? Diese Variable ist möglicherweise in den Entwicklertools ([F12]-Taste) in der Konsole direkt ohne Aufwand auslesbar und manipulierbar. Was, wenn du eine gleichnamige Variable aus einer anderen Datei benötigst? Um eben diesen Problemen aus dem Weg zu gehen, wurden in ES6 JavaScript-Modules eingeführt.\nHast du in einer JavaScript-Datei Variablen, Funktionen oder Klassen, die du in einer anderen Datei brauchen willst, dann kannst du diese wie folgt deklarieren:\n1 2 3 4 5 6 7 8 9 export const a = \"A\"; export const b = \"B\"; export class Person { name; constructor(name) { this.name = name; } } Nun kannst du diese Variablen in einer anderen JavaScript-Datei wie folgt importieren:\n1 import { a, b, Person } from \"./path/to/your/file.js\"; Imports in HTML-Dateien Vielleicht kommst du mal in die Situation, dass du in einem Browser ohne JS-Framework wie React oder Angular ein JavaScript-Modul laden möchtest. Das kannst du in HTML wie folgt machen:\n1 2 3 4 \u003cscript type=\"module\"\u003e import { a, b, Person } from \"./file.js\"; console.log(a, b, new Person(\"Monkey Puppet\")); \u003c/script\u003e Beachte, dass die type-Angabe im \u003cscript\u003e-Tag zwingend ist und die Imports nur innerhalb dieses \u003cscript\u003e-Tags verfügbar sind.\nMöchtest du ohne die Angabe von type=\"module\" Variablen importieren (beispielsweise in den Entwicklertools deines Browsers), dann kannst du nicht wie gewohnt das import-Keyword benutzen. Importieren kannst du dann auf die folgende Art:\n1 const { a, b, Person } = await import(\"./file.js\"); In diesem Beispiel hast du import(...) wie eine Funktion verwendet. Weil diese “Funktion” ein Promise zurückgibt (da sie das Modul asynchron lädt), sollte hier der Import awaited werden. So kann sichergestellt werden, dass der später folgende Code erst aufgerufen wird, nachdem das Modul komplett geladen wurde. Falls du dich nicht mit async und await auskennst, solltest du den Abschnitt Promises noch einmal anschauen.\ndefault Ex- und Importe Das ES6-Modul-System unterscheidet zwischen default- und named-Exporten:\nEine Datei kann mehrere named-Exporte haben. Alle in den bisherigen Beispielen gemachten Exporte waren named-Exporte. Eine Datei kann hingegen nur einen default Export besitzen. Wenn eine Datei z.B. nur etwas exportieren soll, dann eignet sich ein default-Export hierfür. Angenommen, wir haben eine Datei person.js, die eine Klasse und ein paar Utility-Funktionen zu dieser Klasse anbietet, dann können die Exporte aussehen wie folgt:\n1 2 3 4 5 6 7 8 9 10 11 12 13 export default class Person { name; constructor(name) { this.name = name; } } export function personFromJson(jsonString) { const obj = JSON.parse(jsonString); return new Person(obj.name); } export function getNameOfPerson(person) { return person.name; } Dieses Beispiel wiederum kann beispielsweise importiert werden wie folgt:\n1 2 3 4 5 6 7 8 import ClassForPerson, { personFromJson, getNameOfPerson } from \"./person.js\"; const person = personFromJson('{\"name\": \"Mr. Incredible\"}'); console.log(getNameOfPerson(person)); \u003e\u003e\u003e Mr. Incredible console.log(person instanceof ClassForPerson); \u003e\u003e\u003e true Wie du hier sehen kannst, können wir den default-Export mit irgendeinem Namen importieren, der nicht mit dem Namen in der Export-Datei übereinstimmen muss.\n","categories":"","description":"Modul #F4 - JavaScript - Aus anderen JavaScript-Dateien importieren\n","excerpt":"Modul #F4 - JavaScript - Aus anderen JavaScript-Dateien importieren\n","ref":"/de/docs/03_web/03_javascript/20_imports/","tags":"","title":"ES6: Importe"},{"body":"Bist du bereit für das Exam? Wenn nicht, dann darfst du gerne den CSS-Teil aus dem Intro to HTML and CSS - Udacity-Kurs anschauen.\nWenn du bereit bist, dann prüfe dein Wissen mit dem Exam.\n","categories":"","description":"Modul #F3 - HTML und CSS - Genug Theorie! Wage dich ans Exam!\n","excerpt":"Modul #F3 - HTML und CSS - Genug Theorie! Wage dich ans Exam!\n","ref":"/docs/03_web/02_html_css/19_css-finish/","tags":"","title":"Abschluss"},{"body":"Bist du bereit für das Exam? Wenn nicht, dann darfst du gerne den CSS-Teil aus dem Intro to HTML and CSS - Udacity-Kurs anschauen.\nWenn du bereit bist, dann prüfe dein Wissen mit dem Exam.\n","categories":"","description":"Modul #F3 - HTML und CSS - Genug Theorie! Wage dich ans Exam!\n","excerpt":"Modul #F3 - HTML und CSS - Genug Theorie! Wage dich ans Exam!\n","ref":"/de/docs/03_web/02_html_css/19_css-finish/","tags":"","title":"Abschluss"},{"body":"Ziele Du kennst die verschiedenen Angular Data Bindings und kannst diese umsetzen. Angular Data Bindings Interpolation Mithilfe dieses One-Way-Bindings kann man Properties(u.a. Variablen) des Components im Template anzeigen. Wenn sich das Property im Component ändert, wird das Template aktualisiert, um die neuen Änderungen anzuzeigen. 1 2 3 4 5 6 7 8 9 10 import { Component } from \"@angular/core\"; @Component({ selector: \"app-greeting\", templateUrl: \"./app-greeting.component.html\", styleUrls: [\"./app-greeting.component.scss\"], }) export class GreetingComponent { name: string = \"Dragon Warrior\"; } 1 2 \u003c!--app-greeting.component.html--\u003e \u003ch1\u003eHello, {{ name }}!\u003c/h1\u003e Event Binding Event Binding ist definiert als das Aktualisieren/Senden des Werts/der Information einer bestimmten Variable vom Template zum Component.\nZum Beispiel das Klicken eines Buttons. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import { Component } from \"@angular/core\"; import { WeaponService } from \"src/app/services/weapon.service\"; @Component({ // .. }) export class WeaponComponent { chosenWeapon: string = \"\"; weapons: string[] = []; constructor(private weaponService: WeaponService) {} ngOnInit() { this.weapons = this.weaponService.getWeapons(); const index = Math.floor(Math.random() * this.weapons.length); this.chosenWeapon = this.weapons[index]; } choseNewWeapon() { const index = Math.floor(Math.random() * this.weapons.length); this.chosenWeapon = this.weapons[index]; } } 1 2 \u003c!--app-weapon.component.html--\u003e \u003cbutton (click)=\"choseNewWeapon()\"\u003eChoose New Weapon\u003c/button\u003e Property Binding Mithilfe von Property Bindings können wir einen Wert unseres Components auf eine Eigenschaft eines Elements binden. Wenn sich also der bestimmte Wert im Component verändern sollte, wird dies im Template aktualisiert. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import { Component } from \"@angular/core\"; import { WeaponService } from \"src/app/services/weapon.service\"; @Component({ // .. }) export class WeaponComponent { // .. isButtonDisabled: boolean = false; // .. toggleButtonDisabled() { this.isButtonDisabled = !this.isButtonDisabled; } } 1 2 3 4 5 \u003c!--app-weapon.component.html--\u003e \u003cbutton (click)=\"chooseNewWeapon()\" [disabled]=\"isButtonDisabled\"\u003e Choose New Weapon \u003c/button\u003e \u003cbutton (click)=\"toggleButtonDisabled()\"\u003eToggle Button Disabled\u003c/button\u003e Two-Way-Binding Two-Way-Binding ist eine Kombination aus Property- und Eventbinding. Daten werden kontinuierlich synchronisiert: vom Template zum Component und vom Component zum Template. Dies bedeutet also, dass Änderungen, die an den Daten des Components vorgenommen wurden, werden mit dem Template synchronisiert und sofort aktualisiert. Umgekehrt funktioniert es auf dieselbe Weise, daher auch der Name “Two-Way-Binding”.\nAchte hierbei auf die Verwendung des @Input-Decorators im Component. Dieser markiert ein Feld als ein Input-Property, wodurch es an das DOM-Property angebunden wird. Damit erkennt Angular während der Change-Detection automatisch, ob sich das etwas geändert hat und passt in diesem Fall automatisch das Property im DOM an.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { Component } from \"@angular/core\"; @Component({ selector: \"app-ng-model\", templateUrl: \"./app-ng-model.component.html\", styleUrls: [\"./app-ng-model.component.scss\"], }) export class TriumphsComponent { @Input() title: string = \"\"; // .. getValue(event: Event): string { return (event.target as HTMLInputElement).value; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u003c!--app-triumphs.component.html--\u003e \u003cdiv\u003e \u003cp\u003e \u003cinput [value]=\"title\" (input)=\"title = getValue($event)\" /\u003e \u003c/p\u003e //Das folgende Beispiel ist eine kompakte Schreibweise für ein Input-Property. \u003cp\u003e \u003cinput [(ngModel)]=\"title\" /\u003e \u003c/p\u003e \u003cp\u003e \u003cinput [ngModel]=\"title\" (ngModelChange)=\"title = $event\" /\u003e \u003c/p\u003e \u003c/div\u003e ","categories":"","description":"Modul #F6 - Angular - Data Bindings\n","excerpt":"Modul #F6 - Angular - Data Bindings\n","ref":"/docs/03_web/06_angular/03_1_data-binding/","tags":"","title":"Data Bindings"},{"body":"Ziele Du kennst die verschiedenen Angular Data Bindings und kannst diese umsetzen. Angular Data Bindings Interpolation Mithilfe dieses One-Way-Bindings kann man Properties(u.a. Variablen) des Components im Template anzeigen. Wenn sich das Property im Component ändert, wird das Template aktualisiert, um die neuen Änderungen anzuzeigen. 1 2 3 4 5 6 7 8 9 10 import { Component } from \"@angular/core\"; @Component({ selector: \"app-greeting\", templateUrl: \"./app-greeting.component.html\", styleUrls: [\"./app-greeting.component.scss\"], }) export class GreetingComponent { name: string = \"Dragon Warrior\"; } 1 2 \u003c!--app-greeting.component.html--\u003e \u003ch1\u003eHello, {{ name }}!\u003c/h1\u003e Event Binding Event Binding ist definiert als das Aktualisieren/Senden des Werts/der Information einer bestimmten Variable vom Template zum Component.\nZum Beispiel das Klicken eines Buttons. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import { Component } from \"@angular/core\"; import { WeaponService } from \"src/app/services/weapon.service\"; @Component({ // .. }) export class WeaponComponent { chosenWeapon: string = \"\"; weapons: string[] = []; constructor(private weaponService: WeaponService) {} ngOnInit() { this.weapons = this.weaponService.getWeapons(); const index = Math.floor(Math.random() * this.weapons.length); this.chosenWeapon = this.weapons[index]; } choseNewWeapon() { const index = Math.floor(Math.random() * this.weapons.length); this.chosenWeapon = this.weapons[index]; } } 1 2 \u003c!--app-weapon.component.html--\u003e \u003cbutton (click)=\"choseNewWeapon()\"\u003eChoose New Weapon\u003c/button\u003e Property Binding Mithilfe von Property Bindings können wir einen Wert unseres Components auf eine Eigenschaft eines Elements binden. Wenn sich also der bestimmte Wert im Component verändern sollte, wird dies im Template aktualisiert. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import { Component } from \"@angular/core\"; import { WeaponService } from \"src/app/services/weapon.service\"; @Component({ // .. }) export class WeaponComponent { // .. isButtonDisabled: boolean = false; // .. toggleButtonDisabled() { this.isButtonDisabled = !this.isButtonDisabled; } } 1 2 3 4 5 \u003c!--app-weapon.component.html--\u003e \u003cbutton (click)=\"chooseNewWeapon()\" [disabled]=\"isButtonDisabled\"\u003e Choose New Weapon \u003c/button\u003e \u003cbutton (click)=\"toggleButtonDisabled()\"\u003eToggle Button Disabled\u003c/button\u003e Two-Way-Binding Two-Way-Binding ist eine Kombination aus Property- und Eventbinding. Daten werden kontinuierlich synchronisiert: vom Template zum Component und vom Component zum Template. Dies bedeutet also, dass Änderungen, die an den Daten des Components vorgenommen wurden, werden mit dem Template synchronisiert und sofort aktualisiert. Umgekehrt funktioniert es auf dieselbe Weise, daher auch der Name “Two-Way-Binding”.\nAchte hierbei auf die Verwendung des @Input-Decorators im Component. Dieser markiert ein Feld als ein Input-Property, wodurch es an das DOM-Property angebunden wird. Damit erkennt Angular während der Change-Detection automatisch, ob sich das etwas geändert hat und passt in diesem Fall automatisch das Property im DOM an.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { Component } from \"@angular/core\"; @Component({ selector: \"app-ng-model\", templateUrl: \"./app-ng-model.component.html\", styleUrls: [\"./app-ng-model.component.scss\"], }) export class TriumphsComponent { @Input() title: string = \"\"; // .. getValue(event: Event): string { return (event.target as HTMLInputElement).value; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u003c!--app-triumphs.component.html--\u003e \u003cdiv\u003e \u003cp\u003e \u003cinput [value]=\"title\" (input)=\"title = getValue($event)\" /\u003e \u003c/p\u003e //Das folgende Beispiel ist eine kompakte Schreibweise für ein Input-Property. \u003cp\u003e \u003cinput [(ngModel)]=\"title\" /\u003e \u003c/p\u003e \u003cp\u003e \u003cinput [ngModel]=\"title\" (ngModelChange)=\"title = $event\" /\u003e \u003c/p\u003e \u003c/div\u003e ","categories":"","description":"Modul #F6 - Angular - Data Bindings\n","excerpt":"Modul #F6 - Angular - Data Bindings\n","ref":"/de/docs/03_web/06_angular/03_1_data-binding/","tags":"","title":"Data Bindings"},{"body":"Motivation Seit ES2015 (ES6) gibt es in JavaScript die Möglichkeit, den Parametern von Methoden einen Default-Wert zu übergeben.\nZiele Du weisst, wie du in JavaScript optionalen Argumenten in einem Parameter einen Default-Wert zuweisen kannst. Du weisst, wie du named Arguments in Parameter verwenden kannst. Basics Methoden (und daher auch Konstruktoren) besitzen oft Werte, die zwingend übergeben werden müssen und welche, die optional sind.\nIm folgenden Beispiel ist der Name bei einer Person zwingend, das Alter, Geschlecht und sein/ihr Verhältnis zu JavaScript sind aber optional:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Person { name; age; gender; lovesJavaScript; constructor(name, age = undefined, gender = undefined, lovesJavaScript = true) { this.name = name; this.age = age; this.gender = gender; this.lovesJavaScript = lovesJavaScript; } } // Hier wollen wir eine Person erstellen, kennen aber das Alter, Geschlecht und seine Beziehung zu JS nicht: new Person(\"Colonel Toad\"); \u003e\u003e\u003e Person {name: 'Colonel Toad', age: undefined, gender: undefined, lovesJavaScript: true} // Hier wollen wir neben dem Namen nur das Alter setzen: new Person(\"Sweating Towel Guy\", 44); \u003e\u003e\u003e Person {name: 'Sweating Towel Guy', age: 44, gender: undefined, lovesJavaScript: true} /// Möchtest du das letzte Argument setzen, dann musst du die vorherigen Variablen auch setzen: new Person(\"Man Ray\", null, null, false); \u003e\u003e\u003e Person {name: 'Man Ray', age: null, gender: null, lovesJavaScript: false} Mit dieser Umsetzung hast du zwar eine Lösung, die die Präferenz einer Person bezüglich JavaScript speichert, auch wenn nur ein Name angegeben wird. Aber was wäre, wenn du eine Person mit einem Geschlecht erstellen möchtest, aber das Alter nicht angeben möchtest?\nHierfür bieten sich dann named Parameters an:\nNamed Parameters Dank dem Object Destructuring aus ES6 kannst du alle optionale Argument einzeln zuweisen beziehungsweise überspringen. Das könnte wie folgt aussehen:\n1 2 3 4 5 6 7 8 9 10 11 12 class Person { constructor(name, {age = undefined, gender = undefined, lovesJavaScript = true}) { this.name = name; this.age = age; this.gender = gender; this.lovesJavaScript = lovesJavaScript; } } new Person(\"Steven Crowder\", {gender: \"male\"}); \u003e\u003e\u003e Person {name: 'Steven Crowder', age: undefined, gender: 'male', lovesJavaScript: true} ","categories":"","description":"Modul #F4 - JavaScript - Funktionen mit optionalen Argumenten\n","excerpt":"Modul #F4 - JavaScript - Funktionen mit optionalen Argumenten\n","ref":"/docs/03_web/03_javascript/21_optional-args/","tags":"","title":"ES6: Optionale Argumente in Methoden und Konstruktoren"},{"body":"Motivation Seit ES2015 (ES6) gibt es in JavaScript die Möglichkeit, den Parametern von Methoden einen Default-Wert zu übergeben.\nZiele Du weisst, wie du in JavaScript optionalen Argumenten in einem Parameter einen Default-Wert zuweisen kannst. Du weisst, wie du named Arguments in Parameter verwenden kannst. Basics Methoden (und daher auch Konstruktoren) besitzen oft Werte, die zwingend übergeben werden müssen und welche, die optional sind.\nIm folgenden Beispiel ist der Name bei einer Person zwingend, das Alter, Geschlecht und sein/ihr Verhältnis zu JavaScript sind aber optional:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Person { name; age; gender; lovesJavaScript; constructor(name, age = undefined, gender = undefined, lovesJavaScript = true) { this.name = name; this.age = age; this.gender = gender; this.lovesJavaScript = lovesJavaScript; } } // Hier wollen wir eine Person erstellen, kennen aber das Alter, Geschlecht und seine Beziehung zu JS nicht: new Person(\"Colonel Toad\"); \u003e\u003e\u003e Person {name: 'Colonel Toad', age: undefined, gender: undefined, lovesJavaScript: true} // Hier wollen wir neben dem Namen nur das Alter setzen: new Person(\"Sweating Towel Guy\", 44); \u003e\u003e\u003e Person {name: 'Sweating Towel Guy', age: 44, gender: undefined, lovesJavaScript: true} /// Möchtest du das letzte Argument setzen, dann musst du die vorherigen Variablen auch setzen: new Person(\"Man Ray\", null, null, false); \u003e\u003e\u003e Person {name: 'Man Ray', age: null, gender: null, lovesJavaScript: false} Mit dieser Umsetzung hast du zwar eine Lösung, die die Präferenz einer Person bezüglich JavaScript speichert, auch wenn nur ein Name angegeben wird. Aber was wäre, wenn du eine Person mit einem Geschlecht erstellen möchtest, aber das Alter nicht angeben möchtest?\nHierfür bieten sich dann named Parameters an:\nNamed Parameters Dank dem Object Destructuring aus ES6 kannst du alle optionale Argument einzeln zuweisen beziehungsweise überspringen. Das könnte wie folgt aussehen:\n1 2 3 4 5 6 7 8 9 10 11 12 class Person { constructor(name, {age = undefined, gender = undefined, lovesJavaScript = true}) { this.name = name; this.age = age; this.gender = gender; this.lovesJavaScript = lovesJavaScript; } } new Person(\"Steven Crowder\", {gender: \"male\"}); \u003e\u003e\u003e Person {name: 'Steven Crowder', age: undefined, gender: 'male', lovesJavaScript: true} ","categories":"","description":"Modul #F4 - JavaScript - Funktionen mit optionalen Argumenten\n","excerpt":"Modul #F4 - JavaScript - Funktionen mit optionalen Argumenten\n","ref":"/de/docs/03_web/03_javascript/21_optional-args/","tags":"","title":"ES6: Optionale Argumente in Methoden und Konstruktoren"},{"body":"Ziele Du weisst, was Pipes sind und wozu man sie benötigt. Du kennst die verschiedenen Arten von Pipes und wie man sie anwendet. Du kannst selbst Custom Pipes erstellen. Pipes Jede Anwendung beginnt mit einer scheinbar einfachen Aufgabe: Daten abrufen, transformieren und den Benutzern anzeigen. Das Abrufen von Daten kann so einfach wie das Erstellen einer lokalen Variable oder so komplex wie das Streamen von Daten über einen WebSocket sein. Sobald Daten eingehen, könnte man ihre rohen toString-Werte direkt in die View übertragen. Das führt jedoch selten zu einer guten User Experience. In den meisten Anwendungsfällen bevorzugen Benutzer beispielsweise die Anzeige eines Datums in einem einfachen Format wie 15. January 1929 anstelle des rohen Stringformats Tu 15. January 1929 00:00:00 GMT-0700 (Pacific Daylight Time).\nEs ist daher klar, dass viele Werte von einer gewissen Verarbeitung profitieren. Viele der Transformationen werden sowohl innerhalb von als auch zwischen Anwendungen wiederholt. Dazu sind Pipes sehr praktisch. Man kann sie sich als Blaupausen für Daten vorstellen.\nEine Pipe nimmt Daten als Eingabe auf und wandelt sie in eine gewünschte Ausgabe um. In diesem Beispiel verwenden wir Pipes, um das Datum der Geburtstage eines Components in ein leserliches Datum umzuwandeln.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import { Component } from \"@angular/core\"; @Component({ // .. }) export class BirthdaysComponent { // .. datesOfBirth: Date[] = [ new Date(1412, 0, 23), new Date(1823, 2, 12), new Date(1945, 3, 20), new Date(2023, 10, 20), ]; // .. } 1 2 3 \u003cdiv *ngFor=\"let birthday of datesOfBirth; let i = index\"\u003e \u003cp\u003e{{birthday}}, {{ datesOfBirth[i] | date }}\u003c/p\u003e \u003c/div\u003e Parametrisierte Pipes Eine Pipe kann eine beliebige Anzahl optionaler Parameter akzeptieren, um ihre Ausgabe zu optimieren. Um einer Pipe Parameter hinzuzufügen, fügen wir nach dem Pipe-Namen einen Doppelpunkt (:) und danach den Parameterwert (z. B. date: MMM/dd/yy) hinzu. Wenn die Pipe mehrere Parameter akzeptiert, trennen wir die Werte durch Doppelpunkte (z. B. Slice: 1: 5).\nUnser Beispiel von vorher könnten wir z.B. so ausgeben:\n1 2 3 \u003cdiv *ngFor=\"let birthday of datesOfBirth; let i = index\"\u003e \u003cp\u003e{{ birthday }}, {{ datesOfBirth[i] | date:\"MM/dd/yy\" }}\u003c/p\u003e \u003c/div\u003e Chaining Pipes Wir können Pipes in nützlichen Kombinationen miteinander verketten. Im folgenden Beispiel wird der Geburtstag an die DatePipe und an die UpperCasePipe angekettet, um den Geburtstag in Grossbuchstaben anzuzeigen.\n1 2 3 \u003cdiv *ngFor=\"let birthday of datesOfBirth; let i = index\"\u003e \u003cp\u003e{{ birthday }}, {{ datesOfBirth[i] | date: \"MMM/dd/yy\" | uppercase }}\u003c/p\u003e \u003c/div\u003e Das Datum wird nun so angezeigt: APR/20/45\nAsyncPipe Die AsyncPipe wird verwendet, um Observables oder Promises im Template zu subscriben und automatisch zu aktualisieren, sobald neue Werte verfügbar sind. Was Observables und Promises sind, wird in einem späteren Kapitel behandelt.\n1 2 3 \u003cp\u003e{{ myObservableData$ | async }}\u003c/p\u003e \u003cp\u003e{{ myPromiseData | async }}\u003c/p\u003e \u003cp\u003e{{ myObservableData$ | async | uppercase }}\u003c/p\u003e Custom Pipes Für spezielle Anwendungsfälle können wir auch unsere eigenen Pipes schreiben.\nWir können Beispielsweise die Schreibweise eines Strings anhand einer Custom Pipe im Template verändern.\n1 \u003cli *ngFor=\"let birthday of datesOfBirth\"\u003e{{ birthday | capitalize }}\u003c/li\u003e Der Code für die Custom Pipe dieses Beispiels würde so aussehen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 import { Pipe, PipeTransform } from \"@angular/core\"; @Pipe({ name: \"capitalize\", }) export class CapitalizePipe implements PipeTransform { transform(value: string): string { if (value) { return value.charAt(0).toUpperCase() + value.slice(1); } return \"\"; } } Um Angular mitzuteilen, dass dies eine Pipe ist, wenden wir den @Pipe-Decorator an, welchen wir aus @angular/core importieren. Die Pipe-Klasse implementiert die Methode transform des PipeTransform-Interface, die einen Eingabewert gefolgt von optionalen Parametern akzeptiert und den transformierten Wert zurückgibt. Für jeden an die Pipe übergebenen Parameter gibt es ein zusätzliches Argument für die Methode transform. Mit dem @Pipe-Decorator können wir den Pipe-Namen definieren, welchen wir im Template verwenden. ","categories":"","description":"Modul #F6 - Angular - Pipes\n","excerpt":"Modul #F6 - Angular - Pipes\n","ref":"/docs/03_web/06_angular/03_2_pipes/","tags":"","title":"Pipes"},{"body":"Ziele Du weisst, was Pipes sind und wozu man sie benötigt. Du kennst die verschiedenen Arten von Pipes und wie man sie anwendet. Du kannst selbst Custom Pipes erstellen. Pipes Jede Anwendung beginnt mit einer scheinbar einfachen Aufgabe: Daten abrufen, transformieren und den Benutzern anzeigen. Das Abrufen von Daten kann so einfach wie das Erstellen einer lokalen Variable oder so komplex wie das Streamen von Daten über einen WebSocket sein. Sobald Daten eingehen, könnte man ihre rohen toString-Werte direkt in die View übertragen. Das führt jedoch selten zu einer guten User Experience. In den meisten Anwendungsfällen bevorzugen Benutzer beispielsweise die Anzeige eines Datums in einem einfachen Format wie 15. January 1929 anstelle des rohen Stringformats Tu 15. January 1929 00:00:00 GMT-0700 (Pacific Daylight Time).\nEs ist daher klar, dass viele Werte von einer gewissen Verarbeitung profitieren. Viele der Transformationen werden sowohl innerhalb von als auch zwischen Anwendungen wiederholt. Dazu sind Pipes sehr praktisch. Man kann sie sich als Blaupausen für Daten vorstellen.\nEine Pipe nimmt Daten als Eingabe auf und wandelt sie in eine gewünschte Ausgabe um. In diesem Beispiel verwenden wir Pipes, um das Datum der Geburtstage eines Components in ein leserliches Datum umzuwandeln.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import { Component } from \"@angular/core\"; @Component({ // .. }) export class BirthdaysComponent { // .. datesOfBirth: Date[] = [ new Date(1412, 0, 23), new Date(1823, 2, 12), new Date(1945, 3, 20), new Date(2023, 10, 20), ]; // .. } 1 2 3 \u003cdiv *ngFor=\"let birthday of datesOfBirth; let i = index\"\u003e \u003cp\u003e{{birthday}}, {{ datesOfBirth[i] | date }}\u003c/p\u003e \u003c/div\u003e Parametrisierte Pipes Eine Pipe kann eine beliebige Anzahl optionaler Parameter akzeptieren, um ihre Ausgabe zu optimieren. Um einer Pipe Parameter hinzuzufügen, fügen wir nach dem Pipe-Namen einen Doppelpunkt (:) und danach den Parameterwert (z. B. date: MMM/dd/yy) hinzu. Wenn die Pipe mehrere Parameter akzeptiert, trennen wir die Werte durch Doppelpunkte (z. B. Slice: 1: 5).\nUnser Beispiel von vorher könnten wir z.B. so ausgeben:\n1 2 3 \u003cdiv *ngFor=\"let birthday of datesOfBirth; let i = index\"\u003e \u003cp\u003e{{ birthday }}, {{ datesOfBirth[i] | date:\"MM/dd/yy\" }}\u003c/p\u003e \u003c/div\u003e Chaining Pipes Wir können Pipes in nützlichen Kombinationen miteinander verketten. Im folgenden Beispiel wird der Geburtstag an die DatePipe und an die UpperCasePipe angekettet, um den Geburtstag in Grossbuchstaben anzuzeigen.\n1 2 3 \u003cdiv *ngFor=\"let birthday of datesOfBirth; let i = index\"\u003e \u003cp\u003e{{ birthday }}, {{ datesOfBirth[i] | date: \"MMM/dd/yy\" | uppercase }}\u003c/p\u003e \u003c/div\u003e Das Datum wird nun so angezeigt: APR/20/45\nAsyncPipe Die AsyncPipe wird verwendet, um Observables oder Promises im Template zu subscriben und automatisch zu aktualisieren, sobald neue Werte verfügbar sind. Was Observables und Promises sind, wird in einem späteren Kapitel behandelt.\n1 2 3 \u003cp\u003e{{ myObservableData$ | async }}\u003c/p\u003e \u003cp\u003e{{ myPromiseData | async }}\u003c/p\u003e \u003cp\u003e{{ myObservableData$ | async | uppercase }}\u003c/p\u003e Custom Pipes Für spezielle Anwendungsfälle können wir auch unsere eigenen Pipes schreiben.\nWir können Beispielsweise die Schreibweise eines Strings anhand einer Custom Pipe im Template verändern.\n1 \u003cli *ngFor=\"let birthday of datesOfBirth\"\u003e{{ birthday | capitalize }}\u003c/li\u003e Der Code für die Custom Pipe dieses Beispiels würde so aussehen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 import { Pipe, PipeTransform } from \"@angular/core\"; @Pipe({ name: \"capitalize\", }) export class CapitalizePipe implements PipeTransform { transform(value: string): string { if (value) { return value.charAt(0).toUpperCase() + value.slice(1); } return \"\"; } } Um Angular mitzuteilen, dass dies eine Pipe ist, wenden wir den @Pipe-Decorator an, welchen wir aus @angular/core importieren. Die Pipe-Klasse implementiert die Methode transform des PipeTransform-Interface, die einen Eingabewert gefolgt von optionalen Parametern akzeptiert und den transformierten Wert zurückgibt. Für jeden an die Pipe übergebenen Parameter gibt es ein zusätzliches Argument für die Methode transform. Mit dem @Pipe-Decorator können wir den Pipe-Namen definieren, welchen wir im Template verwenden. ","categories":"","description":"Modul #F6 - Angular - Pipes\n","excerpt":"Modul #F6 - Angular - Pipes\n","ref":"/de/docs/03_web/06_angular/03_2_pipes/","tags":"","title":"Pipes"},{"body":"Ziele Du weisst, was Decorators in Angular sind. Du kennst die verschiedenen Decorators von Angular und kannst diese anwenden. Decorators Decorators sind spezielle Funktionen, die verwendet werden, um zusätzliche Informationen zu einer Klasse, Methode oder Eigenschaft hinzuzufügen oder das Verhalten davon zu ändern. Sie helfen dabei, den Code besser zu organisieren und bestimmte Aufgaben automatisch auszuführen.\nFolgende sieben Decorators sind in Angular die meistverwendeten:\n@Component: Der @Component-Decorator wird verwendet, um einen Component zu definieren.\n@Directive: Der @Directive-Decorator wird verwendet, um eine Directives zu definieren.\n@Injectable: Der @Injectable-Decorator wird verwendet, um einen Service zu definieren, er wird aber auch bei Dependency Injection verwendet.\n@Input: Der @Input-Decorator wird verwendet, um eine Eingabeeigenschaft in eines Components oder einer Directive zu definieren.\n@Output: Der @Output-Decorator wird verwendet, um eine Ausgabeeigenschaft in eines Components oder einer Directive zu definieren.\n@ViewChild: Der @ViewChild-Decorator wird verwendet, um auf ein Child-Element eines Components zuzugreifen.\n@ViewChildren: Der @ViewChildren-Decorator wird verwendet, um auf eine Liste von Child-Elementen eines Components zuzugreifen.\n@Component Der @Component-Decorator wird verwendet, um einen Component zu definieren. Er ist einer der wichtigsten Decorators und enthält Metadaten, die Angular dabei helfen, den Component zu verstehen und zu rendern.\nEr wird über der Klassen-Deklaration platziert und enthält ein Objekt mit verschiedenen Eigenschaften:\nselector: Der selector gibt an, wie der Component in HTML-Dateien referenziert wird. Im folgenden Beispiel wäre das \u003capp-my-component\u003e\u003c/app-my-component\u003e.\ntemplateUrl (oder template): Der templateUrl-Eigenschaftswert gibt den Pfad zur HTML-Datei an, die das Template des Components enthält. Alternativ kann man auch die template-Eigenschaft verwenden, um das Template direkt innerhalb des @Component-Decorators zu definieren, das sollte jedoch vermieden werden.\nstyleUrls (oder styles): Die styleUrls-Eigenschaft gibt ein Array von CSS-Dateipfaden an, die für den Component gelten sollen. Man kann auch die styles-Eigenschaft verwenden, um den CSS-Code direkt im @Component-Decorator einzufügen, dies sollte jedoch vermieden werden.\n1 2 3 4 5 6 7 8 9 10 import { Component } from \"@angular/core\"; @Component({ selector: \"app-greeting\", templateUrl: \"./greeting.component.html\", styleUrls: [\"./greeting.component.scss\"], }) export class GreetingComponent { // gesamte Compoenentlogik } @Input Der @Input-Decorator ermöglicht es, Daten von einem übergeordneten Component (Parent) an einen untergeordneten Component (Child) zu übergeben. Somit wird die Kommunikation zwischen den Components erleichtert:\n1 2 3 4 5 6 7 8 9 import { Component, Input } from \"@angular/core\"; @Component({ // .. }) export class TriumphsComponent { @Input() title: string = \"\"; @Input() triumphs: string[] = []; } Um die Eingabeeigenschaft zu verwenden und Daten vom Parent zu erhalten, verwendet man die Property-Binding-Syntax im Parent-Element.\n1 \u003capp-triumphs *ngIf=\"hasTriumphs\" [title]=\"'Triumphs'\" [triumphs]=\"triumphs\"\u003e\u003c/app-triumphs\u003e required Seit Angular 17 bietet @Input die Möglichkeit ein Input als benötigt zu markieren. Der Required-Status wird dadurch dann durch den Compiler geprüft und es wird ein Fehler geworfen, falls der Input nicht angegeben wird.\n1 2 3 4 5 6 7 8 9 import { Component, Input } from \"@angular/core\"; @Component({ // .. }) export class TriumphsComponent { @Input({ required: true }) title: string; @Input() triumphs?: string[]; } Somit wäre hier der Input triumphs nicht nötig, title hingegen schon.\n1 \u003capp-triumphs *ngIf=\"hasTriumphs\" [title]=\"'Triumphs'\"\u003e\u003c/app-triumphs\u003e transform Mit Angular 17 wurde auch transform hinzugefügt, diese Option kann den eingegebenen Wert ähnlich wie eine Pipe umwandeln. Ein gutes Beispiel dafür ist, wenn eine Grössenangabe gemacht werden muss. Im folgenden Beispiel kann einfach die Zahl angegeben werden und der Input wird automatisch in Pixel umgewandelt.\n1 2 3 4 5 6 7 @Component({...}) export class CustomSlider { @Input({transform: appendPx}) widthPx: string = ''; } function appendPx(value: number) { return `${value}px`; } @Output Mit dem @Output-Decorator kann ein Component Ereignisse an den übergeordneten Component (Parent) senden und mitteilen, dass etwas im Component (Child) geschehen ist.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { Component, Output, EventEmitter } from \"@angular/core\"; @Component({ // .. }) export class TriumphsComponent { // .. @Output() titleChange: EventEmitter\u003cstring\u003e = new EventEmitter\u003cstring\u003e(); // .. onTitleChange(value: string) { this.title = value; this.titleChange.emit(value); } } 1 \u003cinput [ngModel]=\"title\" (ngModelChange)=\"onTitleChange($event)\" /\u003e Um das Ereignis im Parent zu empfangen und darauf zu reagieren, wird das Event-Binding verwendet.\n1 2 3 4 5 6 7 \u003cp\u003eTriumphpage Titel: {{ triumphTitel }}\u003c/p\u003e \u003capp-triumphs *ngIf=\"hasTriumphs\" [title]=\"'Triumphs'\" [triumphs]=\"triumphs\" (titleChange)=\"handleTitleChange($event)\" \u003e\u003c/app-triumphs\u003e @ViewChild @ViewChild wird verwendet, um auf ein Element oder eine Directive in der View eines Components zuzugreifen. Der @ViewChild-Decorator wird normalerweise zusammen mit einer Template-Referenzvariable verwendet, um das gewünschte Element oder die gewünschte Directive zu identifizieren.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import { Component, ViewChild, ElementRef } from \"@angular/core\"; @Component({ // .. }) export class GreetingComponent implements AfterViewInit { @ViewChild(\"triumphsComponent\") triumphsComponent!: TriumphsComponent; ngAfterViewInit() { this.triumphsComponent.datesOfTriumph.forEach((date) =\u003e { console.log(date); }); } } 1 2 3 4 5 6 7 \u003capp-triumphs #triumphsComponent *ngIf=\"hasTriumphs\" [title]=\"'Triumphs'\" [triumphs]=\"triumphs\" (titleChange)=\"handleTitleChange($event)\" \u003e\u003c/app-triumphs\u003e Auf das Element sollte dann erst in der ngAfterViewInit-Lifecycle-Hook-Methode zugegriffen werden, da dieser Hook erst ausgelöst wird, wenn die View initialisiert wurde.\n@ViewChildren Es gibt auch den @ViewChildren-Decorator, der ähnlich wie der @ViewChild-Decorator funktioniert, jedoch verwendet wird, um auf mehrere Elemente oder Directives in der View eines Components zuzugreifen.\nDer @ViewChildren-Decorator wird normalerweise zusammen mit einem Selektor oder einer Klasse verwendet, um die gewünschten Elemente oder Directives zu identifizieren. Das Ergebnis ist eine QueryList, die eine Sammlung der gefundenen Elemente oder Directives darstellt.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import { Component, ViewChildren, QueryList, ElementRef } from \"@angular/core\"; @Component({ // .. }) export class TriumphsComponent implements AfterViewInit { @ViewChildren(\"triumphElements\") triumphElements!: QueryList\u003cElementRef\u003e; // .. triumphElements: Date[] = [ new Date(1412, 0, 23), new Date(1823, 2, 12), new Date(1945, 3, 20), new Date(2023, 10, 20), ]; // .. ngAfterViewInit(): void { this.triumphElements.forEach((triumph) =\u003e { console.log(triumph.nativeElement); }); } // .. } 1 \u003cdiv *ngFor=\"let element of datesOfTriumph\" #triumphElements\u003e{{ element }}\u003c/div\u003e ","categories":"","description":"Modul #F6 - Angular - Decorators.\n","excerpt":"Modul #F6 - Angular - Decorators.\n","ref":"/docs/03_web/06_angular/03_3_decorator/","tags":"","title":"Decorators"},{"body":"Ziele Du weisst, was Decorators in Angular sind. Du kennst die verschiedenen Decorators von Angular und kannst diese anwenden. Decorators Decorators sind spezielle Funktionen, die verwendet werden, um zusätzliche Informationen zu einer Klasse, Methode oder Eigenschaft hinzuzufügen oder das Verhalten davon zu ändern. Sie helfen dabei, den Code besser zu organisieren und bestimmte Aufgaben automatisch auszuführen.\nFolgende sieben Decorators sind in Angular die meistverwendeten:\n@Component: Der @Component-Decorator wird verwendet, um einen Component zu definieren.\n@Directive: Der @Directive-Decorator wird verwendet, um eine Directives zu definieren.\n@Injectable: Der @Injectable-Decorator wird verwendet, um einen Service zu definieren, er wird aber auch bei Dependency Injection verwendet.\n@Input: Der @Input-Decorator wird verwendet, um eine Eingabeeigenschaft in eines Components oder einer Directive zu definieren.\n@Output: Der @Output-Decorator wird verwendet, um eine Ausgabeeigenschaft in eines Components oder einer Directive zu definieren.\n@ViewChild: Der @ViewChild-Decorator wird verwendet, um auf ein Child-Element eines Components zuzugreifen.\n@ViewChildren: Der @ViewChildren-Decorator wird verwendet, um auf eine Liste von Child-Elementen eines Components zuzugreifen.\n@Component Der @Component-Decorator wird verwendet, um einen Component zu definieren. Er ist einer der wichtigsten Decorators und enthält Metadaten, die Angular dabei helfen, den Component zu verstehen und zu rendern.\nEr wird über der Klassen-Deklaration platziert und enthält ein Objekt mit verschiedenen Eigenschaften:\nselector: Der selector gibt an, wie der Component in HTML-Dateien referenziert wird. Im folgenden Beispiel wäre das \u003capp-my-component\u003e\u003c/app-my-component\u003e.\ntemplateUrl (oder template): Der templateUrl-Eigenschaftswert gibt den Pfad zur HTML-Datei an, die das Template des Components enthält. Alternativ kann man auch die template-Eigenschaft verwenden, um das Template direkt innerhalb des @Component-Decorators zu definieren, das sollte jedoch vermieden werden.\nstyleUrls (oder styles): Die styleUrls-Eigenschaft gibt ein Array von CSS-Dateipfaden an, die für den Component gelten sollen. Man kann auch die styles-Eigenschaft verwenden, um den CSS-Code direkt im @Component-Decorator einzufügen, dies sollte jedoch vermieden werden.\n1 2 3 4 5 6 7 8 9 10 import { Component } from \"@angular/core\"; @Component({ selector: \"app-greeting\", templateUrl: \"./greeting.component.html\", styleUrls: [\"./greeting.component.scss\"], }) export class GreetingComponent { // gesamte Compoenentlogik } @Input Der @Input-Decorator ermöglicht es, Daten von einem übergeordneten Component (Parent) an einen untergeordneten Component (Child) zu übergeben. Somit wird die Kommunikation zwischen den Components erleichtert:\n1 2 3 4 5 6 7 8 9 import { Component, Input } from \"@angular/core\"; @Component({ // .. }) export class TriumphsComponent { @Input() title: string = \"\"; @Input() triumphs: string[] = []; } Um die Eingabeeigenschaft zu verwenden und Daten vom Parent zu erhalten, verwendet man die Property-Binding-Syntax im Parent-Element.\n1 \u003capp-triumphs *ngIf=\"hasTriumphs\" [title]=\"'Triumphs'\" [triumphs]=\"triumphs\"\u003e\u003c/app-triumphs\u003e required Seit Angular 17 bietet @Input die Möglichkeit ein Input als benötigt zu markieren. Der Required-Status wird dadurch dann durch den Compiler geprüft und es wird ein Fehler geworfen, falls der Input nicht angegeben wird.\n1 2 3 4 5 6 7 8 9 import { Component, Input } from \"@angular/core\"; @Component({ // .. }) export class TriumphsComponent { @Input({ required: true }) title: string; @Input() triumphs?: string[]; } Somit wäre hier der Input triumphs nicht nötig, title hingegen schon.\n1 \u003capp-triumphs *ngIf=\"hasTriumphs\" [title]=\"'Triumphs'\"\u003e\u003c/app-triumphs\u003e transform Mit Angular 17 wurde auch transform hinzugefügt, diese Option kann den eingegebenen Wert ähnlich wie eine Pipe umwandeln. Ein gutes Beispiel dafür ist, wenn eine Grössenangabe gemacht werden muss. Im folgenden Beispiel kann einfach die Zahl angegeben werden und der Input wird automatisch in Pixel umgewandelt.\n1 2 3 4 5 6 7 @Component({...}) export class CustomSlider { @Input({transform: appendPx}) widthPx: string = ''; } function appendPx(value: number) { return `${value}px`; } @Output Mit dem @Output-Decorator kann ein Component Ereignisse an den übergeordneten Component (Parent) senden und mitteilen, dass etwas im Component (Child) geschehen ist.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { Component, Output, EventEmitter } from \"@angular/core\"; @Component({ // .. }) export class TriumphsComponent { // .. @Output() titleChange: EventEmitter\u003cstring\u003e = new EventEmitter\u003cstring\u003e(); // .. onTitleChange(value: string) { this.title = value; this.titleChange.emit(value); } } 1 \u003cinput [ngModel]=\"title\" (ngModelChange)=\"onTitleChange($event)\" /\u003e Um das Ereignis im Parent zu empfangen und darauf zu reagieren, wird das Event-Binding verwendet.\n1 2 3 4 5 6 7 \u003cp\u003eTriumphpage Titel: {{ triumphTitel }}\u003c/p\u003e \u003capp-triumphs *ngIf=\"hasTriumphs\" [title]=\"'Triumphs'\" [triumphs]=\"triumphs\" (titleChange)=\"handleTitleChange($event)\" \u003e\u003c/app-triumphs\u003e @ViewChild @ViewChild wird verwendet, um auf ein Element oder eine Directive in der View eines Components zuzugreifen. Der @ViewChild-Decorator wird normalerweise zusammen mit einer Template-Referenzvariable verwendet, um das gewünschte Element oder die gewünschte Directive zu identifizieren.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import { Component, ViewChild, ElementRef } from \"@angular/core\"; @Component({ // .. }) export class GreetingComponent implements AfterViewInit { @ViewChild(\"triumphsComponent\") triumphsComponent!: TriumphsComponent; ngAfterViewInit() { this.triumphsComponent.datesOfTriumph.forEach((date) =\u003e { console.log(date); }); } } 1 2 3 4 5 6 7 \u003capp-triumphs #triumphsComponent *ngIf=\"hasTriumphs\" [title]=\"'Triumphs'\" [triumphs]=\"triumphs\" (titleChange)=\"handleTitleChange($event)\" \u003e\u003c/app-triumphs\u003e Auf das Element sollte dann erst in der ngAfterViewInit-Lifecycle-Hook-Methode zugegriffen werden, da dieser Hook erst ausgelöst wird, wenn die View initialisiert wurde.\n@ViewChildren Es gibt auch den @ViewChildren-Decorator, der ähnlich wie der @ViewChild-Decorator funktioniert, jedoch verwendet wird, um auf mehrere Elemente oder Directives in der View eines Components zuzugreifen.\nDer @ViewChildren-Decorator wird normalerweise zusammen mit einem Selektor oder einer Klasse verwendet, um die gewünschten Elemente oder Directives zu identifizieren. Das Ergebnis ist eine QueryList, die eine Sammlung der gefundenen Elemente oder Directives darstellt.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import { Component, ViewChildren, QueryList, ElementRef } from \"@angular/core\"; @Component({ // .. }) export class TriumphsComponent implements AfterViewInit { @ViewChildren(\"triumphElements\") triumphElements!: QueryList\u003cElementRef\u003e; // .. triumphElements: Date[] = [ new Date(1412, 0, 23), new Date(1823, 2, 12), new Date(1945, 3, 20), new Date(2023, 10, 20), ]; // .. ngAfterViewInit(): void { this.triumphElements.forEach((triumph) =\u003e { console.log(triumph.nativeElement); }); } // .. } 1 \u003cdiv *ngFor=\"let element of datesOfTriumph\" #triumphElements\u003e{{ element }}\u003c/div\u003e ","categories":"","description":"Modul #F6 - Angular - Decorators.\n","excerpt":"Modul #F6 - Angular - Decorators.\n","ref":"/de/docs/03_web/06_angular/03_3_decorator/","tags":"","title":"Decorators"},{"body":"Motivation Wenn du existierende Funktionen benutzen möchtest, dann wäre es doch praktisch, wenn deine IDE dir direkt mitteilt, was die Funktion bewirkt und welche Typen die Parameter haben. Das lässt sich mit JSDoc erreichen.\nZiele Du weisst, wie du in JavaScript zu Klassen und Funktionen eine Beschreibung hinzufügen kannst, die dir deine Entwicklungsumgebung anzeigt, wenn du diese mittels Auto-Completion auswählst. Du weisst, wie du in JavaScript eine Typ-Angabe machen kannst (die aber zur Laufzeit nichts bewirkt). Basics In TypeScript kannst du jeder Variable einen Typ und jeder Funktion einen Rückgabewert zuweisen. Das geht in JavaScript nicht so einfach.\nTrotzdem kannst du dank des JSDoc-Projekts (https://jsdoc.app/about-getting-started.html) Typ-Angaben machen, damit deine Entwicklungsumgebung sich beschwert, wenn beispielsweise in einer Funktion ein Wert eines falschen Types übergeben wird.\nIn nächsten Beispiel siehst du, wie du in einer Funktion die Typen spezifizieren kannst:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 /** * Diese Funktion leitet die Argumente dem Konstruktor der Klasse `Person` weiter. * @param {string} name Der Name der Person * @param {Object} namedArgs (Eigentlich unnötig, wird aber als Label für die Referenz auf die named Parameter benötigt) * @param {number} [namedArgs.age] Alter * @param {string} [namedArgs.gender] Geschlecht, darf irgend ein String sein. * @returns {Person} Ein Personen-Objekt mit den übergebenen Werten. */ function createPerson(name, { age = undefined, gender = undefined }) { return new Person(name, { age: age, gender: gender, }); } Deine Entwicklungsumgebung kann diese Informationen nun auch anzeigen:\nTags Im vorherigen JSDoc wurden viele Tags verwendet. Hier eine kleine Übersicht zu den wichtigsten:\n@param: Damit wird ein Parameter beschrieben. @returns: Damit wird der Rückgabewert beschrieben. {number}: Das ist eine Typangabe. Im Beispiel muss das Argument eine Zahl sein. [namedArgs.gender]: Die eckigen Klammern spezifizieren das Argument als optional (nullable). Ansonsten sollten die Argumente nicht den Wert undefined oder null annehmen. Eine Auflistung aller JSDoc-Tags findest du hier: https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html\nFehler anzeigen, wenn Typen falsch sind In VS Code gibt es die Möglichkeit, dass die IDE eine Meldung ausgibt, wenn du Werte des falschen Typs übergibst.\nUm hiervon Gebrauch zu machen, kann im Projekt-Verzeichnis eine jsconfig.json-Datei angelegt werden. Folgende Konfiguration könnte für Browser-Anwendungen Sinn ergeben, wenn sich die JS-Dateien beispielsweise im Ordner “${workspaceFolder}/static/js/” befinden:\n1 2 3 4 5 6 7 8 9 10 11 12 { \"compilerOptions\": { \"module\": \"commonjs\", \"target\": \"es6\", \"baseUrl\": \".\", \"checkJs\": true, \"importHelpers\": true, \"lib\": [\"DOM\", \"ES2021\", \"DOM.Iterable\"] }, \"exclude\": [\"node_modules\"], \"include\": [\"static/js/*\"] } Dank dieser Konfiguration würde dir VS Code nun einen Fehler anzeigen, wenn du statt einem string eine number übergeben würdest:\n","categories":"","description":"Modul #F4 - JavaScript - Funktionen mit einer Beschreibung versehen.\n","excerpt":"Modul #F4 - JavaScript - Funktionen mit einer Beschreibung versehen.\n","ref":"/docs/03_web/03_javascript/22_jsdoc/","tags":"","title":"JSDoc"},{"body":"Motivation Wenn du existierende Funktionen benutzen möchtest, dann wäre es doch praktisch, wenn deine IDE dir direkt mitteilt, was die Funktion bewirkt und welche Typen die Parameter haben. Das lässt sich mit JSDoc erreichen.\nZiele Du weisst, wie du in JavaScript zu Klassen und Funktionen eine Beschreibung hinzufügen kannst, die dir deine Entwicklungsumgebung anzeigt, wenn du diese mittels Auto-Completion auswählst. Du weisst, wie du in JavaScript eine Typ-Angabe machen kannst (die aber zur Laufzeit nichts bewirkt). Basics In TypeScript kannst du jeder Variable einen Typ und jeder Funktion einen Rückgabewert zuweisen. Das geht in JavaScript nicht so einfach.\nTrotzdem kannst du dank des JSDoc-Projekts (https://jsdoc.app/about-getting-started.html) Typ-Angaben machen, damit deine Entwicklungsumgebung sich beschwert, wenn beispielsweise in einer Funktion ein Wert eines falschen Types übergeben wird.\nIn nächsten Beispiel siehst du, wie du in einer Funktion die Typen spezifizieren kannst:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 /** * Diese Funktion leitet die Argumente dem Konstruktor der Klasse `Person` weiter. * @param {string} name Der Name der Person * @param {Object} namedArgs (Eigentlich unnötig, wird aber als Label für die Referenz auf die named Parameter benötigt) * @param {number} [namedArgs.age] Alter * @param {string} [namedArgs.gender] Geschlecht, darf irgend ein String sein. * @returns {Person} Ein Personen-Objekt mit den übergebenen Werten. */ function createPerson(name, { age = undefined, gender = undefined }) { return new Person(name, { age: age, gender: gender, }); } Deine Entwicklungsumgebung kann diese Informationen nun auch anzeigen:\nTags Im vorherigen JSDoc wurden viele Tags verwendet. Hier eine kleine Übersicht zu den wichtigsten:\n@param: Damit wird ein Parameter beschrieben. @returns: Damit wird der Rückgabewert beschrieben. {number}: Das ist eine Typangabe. Im Beispiel muss das Argument eine Zahl sein. [namedArgs.gender]: Die eckigen Klammern spezifizieren das Argument als optional (nullable). Ansonsten sollten die Argumente nicht den Wert undefined oder null annehmen. Eine Auflistung aller JSDoc-Tags findest du hier: https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html\nFehler anzeigen, wenn Typen falsch sind In VS Code gibt es die Möglichkeit, dass die IDE eine Meldung ausgibt, wenn du Werte des falschen Typs übergibst.\nUm hiervon Gebrauch zu machen, kann im Projekt-Verzeichnis eine jsconfig.json-Datei angelegt werden. Folgende Konfiguration könnte für Browser-Anwendungen Sinn ergeben, wenn sich die JS-Dateien beispielsweise im Ordner “${workspaceFolder}/static/js/” befinden:\n1 2 3 4 5 6 7 8 9 10 11 12 { \"compilerOptions\": { \"module\": \"commonjs\", \"target\": \"es6\", \"baseUrl\": \".\", \"checkJs\": true, \"importHelpers\": true, \"lib\": [\"DOM\", \"ES2021\", \"DOM.Iterable\"] }, \"exclude\": [\"node_modules\"], \"include\": [\"static/js/*\"] } Dank dieser Konfiguration würde dir VS Code nun einen Fehler anzeigen, wenn du statt einem string eine number übergeben würdest:\n","categories":"","description":"Modul #F4 - JavaScript - Funktionen mit einer Beschreibung versehen.\n","excerpt":"Modul #F4 - JavaScript - Funktionen mit einer Beschreibung versehen.\n","ref":"/de/docs/03_web/03_javascript/22_jsdoc/","tags":"","title":"JSDoc"},{"body":"Ziele Du weisst was Angular Reactive Forms sind. Du weisst, was FormsControl, -Group und -Array sind und kannst diese anwenden. Du weisst, was der FormBuilder ist und kannst ihn anwenden. Du kennst die Validators, kannst sie verwenden und eigene schrieben. Angular Reactive Forms Angular Reactive Forms sind ein leistungsstarkes Feature von Angular, mit dem Entwickler Formulare erstellen, validieren und mit ihnen interagieren können. Im Gegensatz zu Template-driven Forms, bei denen die Formularlogik hauptsächlich im HTML-Template liegt, wird bei Reactive Forms die Formularlogik in den Components selbst geschrieben.\nDoch wieso sollte man Forms verwenden? Dies hört sich nun sehr ähnlich an wie ngModel, welches eine FormControl-Instanz erstellt und diese an ein FormControlElement anbindet. Genauere Infos zu ngModel kannst du dir hier anschauen. Wieso aber sollte man besser Reactive Forms verwenden? Dazu gibt es folgende Gründe:\nReactive Forms ermöglichen eine klare Trennung zwischen Datenmodell und View. Man erstellt ein separates FormGroup-Objekt, das die Struktur und Validierung der Formulardaten definiert. Dieses Datenmodell kann unabhängig von dem View-Component existieren und ermöglicht eine bessere Organisation und Wiederverwendbarkeit des Codes. Mit Reactive Forms hat man die volle Kontrolle über die Formulare, da man FormControls und FormGroups programmatisch erstellen und manipulieren kann. Man kann dynamisch Formularfelder hinzufügen, entfernen oder ändern, Validierungsregeln anpassen und auf Ereignisse reagieren. Reactive Forms bieten eine umfangreichere Unterstützung für komplexe Validierungsszenarien. Man kann benutzerdefinierte Validatoren erstellen oder viele bereits existierende verwenden. Insgesamt bietet die Verwendung von Reactive Forms eine flexiblere, leistungsfähigere und besser strukturierte Möglichkeit, Formulare in Angular zu verwalten. Sie ermöglichen eine bessere Kontrolle, erweiterte Validierungsoptionen und eine klarere Trennung zwischen Datenmodell und View-Komponenten.\nImportieren in Module Bevor man Reactive Forms verwenden kann, muss man die ReactiveFormsModule in das Modul / den Component importieren, in dem man Reactive Forms verwenden möchte.\n1 2 3 4 5 6 7 import { ReactiveFormsModule } from \"@angular/forms\"; @NgModule({ imports: [ReactiveFormsModule], // .. }) export class AppModule {} FormControl Ein FormControl ist ein Objekt, das ein einzelnes Formularelement repräsentiert und steuert. Es ermöglicht die Verwaltung des Werts, der Validierung und des Zustands des Formularelements.\nWenn man ein FormControl verwenden möchte, kann man dieses mittels new FormControl('') einer Variable zuweisen. Dadurch ist die Variable nun die FormControl. Damit man es nun im HTML verwenden kann, um es zu binden, muss man bei einem input-tag [formControl]=\"\" verwenden. In die \"\" kommt dann der Variabelname der FormControl.\n1 2 3 4 5 6 7 8 9 10 11 12 13 import { Component } from \"@angular/core\"; import { FormControl } from \"@angular/forms\"; @Component({ // .. }) export class TriumphsComponent implements AfterViewInit { // .. triumphForm: FormControl = new FormControl(\"\"); // .. } 1 2 3 4 5 \u003cdiv\u003e \u003clabel for=\"triumph\"\u003eTitel: \u003c/label\u003e \u003cinput id=\"triumph\" type=\"text\" [formControl]=\"triumphForm\" /\u003e \u003cp\u003eValue: {{ triumphForm.value }}\u003c/p\u003e \u003c/div\u003e Man kann der FormControl auch einen Defaultwert geben, dazu einfach innerhalb der runden Klammern anstelle von einem leeren String den Defaultwert einfügen. Auch den Value kann man manuell im Typescript verändern, das funktioniert mittels der setValue() Methode.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import { Component } from \"@angular/core\"; import { FormControl } from \"@angular/forms\"; @Component({ // .. }) export class TriumphsComponent implements AfterViewInit { // .. triumphForm: FormControl = new FormControl(\"default Title\"); // .. updateTitle() { this.triumphForm.setValue(\"Triumphs\"); } } 1 2 3 4 5 6 \u003cdiv\u003e \u003clabel for=\"triumph\"\u003eTitel: \u003c/label\u003e \u003cinput id=\"triumph\" type=\"text\" [formControl]=\"triumphForm\" /\u003e \u003cp\u003eValue: {{ triumphForm.value }}\u003c/p\u003e \u003cbutton type=\"button\" (click)=\"updateTitle()\"\u003eUpdate Title\u003c/button\u003e \u003c/div\u003e Wenn man in Typescript direkt auf Änderungen der FormControl subscriben möchte, damit man immer den aktuellen Value der FormControl hat, kann man valueChanges benutzen. Somit hat man im Typescript denselben aktuellen Value wie im HTML mittels {{ name.value }}.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import { Component } from \"@angular/core\"; import { FormControl } from \"@angular/forms\"; @Component({ // .. }) export class TriumphsComponent implements AfterViewInit { // .. triumphForm: FormControl = new FormControl(\"default Title\"); constructor() { this.triumphForm.valueChanges.subscribe((value) =\u003e { console.log(value); }); } // .. } 1 2 3 4 5 \u003cdiv\u003e \u003clabel for=\"triumph\"\u003eTitel: \u003c/label\u003e \u003cinput id=\"triumph\" type=\"text\" [formControl]=\"triumphForm\" /\u003e \u003cp\u003eValue: {{ triumphForm.value }}\u003c/p\u003e \u003c/div\u003e FormGroup Da ein Form-Element normalerweise aus mehr als einem Control-Element besteht, kann man FormControls jeweils zu einer gruppieren.\nFür die FormGroup erstellt man auch eine neue Instanz der FormGroup, in welcher sich die FormControl’s befinden. Die FormGroup wird in einer Variable gespeichert, die FormControls werden mit eindeutigem Key-Value-Prinzip definiert. Man kann auch hier auf die Group mittels valueChanges subscriben, nur dass hier dann nicht einfach der Value des Inputs ausgegeben wird, sondern ein Objekt mit den Controls als Key-Value geliefert wird. Um eine FormGroup im HTML zu verwenden, sollte der form-tag verwendet werden. In diesem muss man die FormGroup mittels [formGroup]=\"\" angeben, auch hier kommt in die \"\" der Variablenname der FormGroup. Um nun die FormControls anzugeben, verwendet man nicht mehr [formControl]=\"\", sondern formControlName=\"\", hier kommt in die \"\" der Key der FormControl.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import { Component } from \"@angular/core\"; import { FormGroup, FormControl } from \"@angular/forms\"; @Component({ // .. }) export class TriumphsComponent implements AfterViewInit { // .. triumphForm: FormGroup = new FormGroup({ name: new FormControl(\"\"), yearOfAchieving: new FormControl(\"\"), }); constructor() { this.triumphForm.valueChanges.subscribe((value) =\u003e { console.log(value); // {name: '', yearOfAchieving: ''} }); } // .. } 1 2 3 4 5 6 7 8 9 \u003cform [formGroup]=\"triumphForm\"\u003e \u003clabel for=\"name\"\u003eTitle Name: \u003c/label\u003e \u003cinput id=\"name\" type=\"text\" formControlName=\"name\" /\u003e \u003clabel for=\"yearOfAchieving\"\u003eYear of Achieving: \u003c/label\u003e \u003cinput id=\"yearOfAchieving\" type=\"number\" formControlName=\"yearOfAchieving\" /\u003e \u003c/form\u003e \u003cp\u003eValue Title Name: {{ triumphForm.value.name }}\u003c/p\u003e \u003cp\u003eValue Year of Achieving: {{ triumphForm.value.yearOfAchieving }}\u003c/p\u003e Es ist auch möglich, eine FormGroup innerhalb einer anderen FormGroup zu verwenden und so das gesamte zu verschachteln, um komplexe Forms mit hierarchischer Struktur zu erstellen. Das funktioniert genau gleich, hier muss dann einfach die zweite FormGroup auch als Key-Value angegeben werden. Die zweite FormGroup muss dann mit formGroupName=\"\" angegeben werden und nicht mehr mit [formGroup]=\"\", innerhalb der \"\" kommt hier dann auch der Key der zweiten FormGroup. Man sollte für die zweite FormGroup dann ein div-tag verwenden.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import { Component } from \"@angular/core\"; import { FormGroup, FormControl } from \"@angular/forms\"; @Component({ // .. }) export class TriumphsComponent implements AfterViewInit { // .. triumphForm: FormGroup = new FormGroup({ name: new FormControl(\"\"), yearOfAchieving: new FormControl(\"\"), placeOfAchieving: new FormGroup({ street: new FormControl(\"\"), city: new FormControl(\"\"), state: new FormControl(\"\"), zip: new FormControl(\"\"), }), }); constructor() { this.triumphForm.valueChanges.subscribe((value) =\u003e { console.log(value); // {name: '', yearOfAchieving: '', placeOfAchieving: {...}} }); } // .. } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u003cform [formGroup]=\"triumphForm\"\u003e \u003clabel for=\"name\"\u003eTitle Name: \u003c/label\u003e \u003cinput id=\"name\" type=\"text\" formControlName=\"name\" /\u003e \u003clabel for=\"yearOfAchieving\"\u003eYear of Achieving: \u003c/label\u003e \u003cinput id=\"yearOfAchieving\" type=\"number\" formControlName=\"yearOfAchieving\" /\u003e \u003cdiv formGroupName=\"placeOfAchieving\"\u003e \u003ch2\u003ePlace of Achieving\u003c/h2\u003e \u003clabel for=\"street\"\u003eStreet: \u003c/label\u003e \u003cinput id=\"street\" type=\"text\" formControlName=\"street\" /\u003e \u003clabel for=\"city\"\u003eCity: \u003c/label\u003e \u003cinput id=\"city\" type=\"text\" formControlName=\"city\" /\u003e \u003clabel for=\"state\"\u003eState: \u003c/label\u003e \u003cinput id=\"state\" type=\"text\" formControlName=\"state\" /\u003e \u003clabel for=\"zip\"\u003eZip Code: \u003c/label\u003e \u003cinput id=\"zip\" type=\"number\" formControlName=\"zip\" /\u003e \u003c/div\u003e \u003c/form\u003e \u003cp\u003eValue Title Name: {{ triumphForm.value.name }}\u003c/p\u003e \u003cp\u003eValue Year of Achieving: {{ triumphForm.value.yearOfAchieving }}\u003c/p\u003e \u003cp\u003eValue Street: {{ triumphForm.value.placeOfAchieving.street }}\u003c/p\u003e \u003cp\u003eValue City: {{ triumphForm.value.placeOfAchieving.city }}\u003c/p\u003e \u003cp\u003eValue State: {{ triumphForm.value.placeOfAchieving.state }}\u003c/p\u003e \u003cp\u003eValue Zip: {{ triumphForm.value.placeOfAchieving.zip }}\u003c/p\u003e Wenn man eine so grosse FormGroup hat und nun einen Wert über Typescript ändern möchte, kann man dies auch mittels setValue() tun. Das kann jedoch mühsam sein, da man bei dieser Methode alle Values (FormControls) der FormGroup angeben muss. Wenn man aber nur einzelne anpassen möchte, kann man die Methode patchValue() verwenden. Diese Methode erlaubt es nämlich, dass man nur einzelne der Values (FormControls) angeben muss.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import { Component } from \"@angular/core\"; import { FormGroup, FormControl } from \"@angular/forms\"; @Component({ // .. }) export class TriumphsComponent implements AfterViewInit { // .. triumphForm: FormGroup = new FormGroup({ name: new FormControl(\"\"), yearOfAchieving: new FormControl(\"\"), placeOfAchieving: new FormGroup({ street: new FormControl(\"\"), city: new FormControl(\"\"), state: new FormControl(\"\"), zip: new FormControl(\"\"), }), }); constructor() { this.triumphForm.valueChanges.subscribe((value) =\u003e { console.log(value); // {name: '', yearOfAchieving: '', placeOfAchieving: {...}} }); } // .. updateTriumph() { this.triumphForm.patchValue({ name: \"Assably\", placeOfAchieving: { street: \"123 Down Street\", }, }); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \u003cform [formGroup]=\"triumphForm\"\u003e \u003clabel for=\"name\"\u003eTitle Name: \u003c/label\u003e \u003cinput id=\"name\" type=\"text\" formControlName=\"name\" /\u003e \u003clabel for=\"yearOfAchieving\"\u003eYear of Achieving: \u003c/label\u003e \u003cinput id=\"yearOfAchieving\" type=\"number\" formControlName=\"yearOfAchieving\" /\u003e \u003cdiv formGroupName=\"placeOfAchieving\"\u003e \u003ch2\u003ePlace of Achieving\u003c/h2\u003e \u003clabel for=\"street\"\u003eStreet: \u003c/label\u003e \u003cinput id=\"street\" type=\"text\" formControlName=\"street\" /\u003e \u003clabel for=\"city\"\u003eCity: \u003c/label\u003e \u003cinput id=\"city\" type=\"text\" formControlName=\"city\" /\u003e \u003clabel for=\"state\"\u003eState: \u003c/label\u003e \u003cinput id=\"state\" type=\"text\" formControlName=\"state\" /\u003e \u003clabel for=\"zip\"\u003eZip Code: \u003c/label\u003e \u003cinput id=\"zip\" type=\"number\" formControlName=\"zip\" /\u003e \u003c/div\u003e \u003c/form\u003e \u003cbutton type=\"button\" (click)=\"updateTriumph()\"\u003eUpdate Triumph\u003c/button\u003e \u003cp\u003eValue Title Name: {{ triumphForm.value.name }}\u003c/p\u003e \u003cp\u003eValue Year of Achieving: {{ triumphForm.value.yearOfAchieving }}\u003c/p\u003e \u003cp\u003eValue Street: {{ triumphForm.value.placeOfAchieving.street }}\u003c/p\u003e \u003cp\u003eValue City: {{ triumphForm.value.placeOfAchieving.city }}\u003c/p\u003e \u003cp\u003eValue State: {{ triumphForm.value.placeOfAchieving.state }}\u003c/p\u003e \u003cp\u003eValue Zip: {{ triumphForm.value.placeOfAchieving.zip }}\u003c/p\u003e FormArray FormArray ist eine Alternative zu FormGroup, wird jedoch verwendet, wenn man eine unbestimmte Anzahl von FormControl-Elemente, FormGroups oder weiteren FormArrays haben möchte. Dadurch hat man die Möglichkeit, dynamisch Formularelemente während der Laufzeit hinzuzufügen oder zu löschen. Praktisch ist, dass man keinen Key für die Formularelemente definieren muss und man nicht weiss, wie viele Elemente es am Schluss sein werden.\nUm auf das FormArray zugreifen zu können muss man eine get-Methode schreiben, diese findet man im folgenden Code.\nWie man Elemente in das FormArray hinzufügt und löscht ist auch im untenstehenden Code zu finden.\nIm HTML muss man das FormArray mittels formArrayName=\"\" angeben, auch hier kommt innerhalb der \"\" der Key des FormArrays. Um an die einzelnen Elemente zu gelangen, muss man mittels einem *ngFor darüber iterieren. Im folgenden Beispiel wird die ID des Inputs dynamisch mittels des Index des Elements erstellt.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 import { Component } from \"@angular/core\"; import { FormGroup, FormControl, FormArray } from \"@angular/forms\"; @Component({ // .. }) export class TriumphsComponent implements AfterViewInit { // .. triumphForm: FormGroup = new FormGroup({ name: new FormControl(\"\"), yearOfAchieving: new FormControl(\"\"), placeOfAchieving: new FormGroup({ street: new FormControl(\"\"), city: new FormControl(\"\"), state: new FormControl(\"\"), zip: new FormControl(\"\"), }), aliases: new FormArray([new FormControl(\"\")]), }); constructor() { this.triumphForm.valueChanges.subscribe((value) =\u003e { console.log(value); // {name: '', yearOfAchieving: '', placeOfAchieving: {...}, aliases: Array[]} }); } get aliases() { return this.triumphForm.get(\"aliases\") as FormArray; } addAlias() { this.aliases.push(new FormControl(\"\")); } removeAlias(index: number): void { this.aliases.removeAt(index); } // .. } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 \u003cform [formGroup]=\"triumphForm\"\u003e \u003clabel for=\"name\"\u003eTitle Name: \u003c/label\u003e \u003cinput id=\"name\" type=\"text\" formControlName=\"name\" /\u003e \u003clabel for=\"yearOfAchieving\"\u003eYear of Achieving: \u003c/label\u003e \u003cinput id=\"yearOfAchieving\" type=\"number\" formControlName=\"yearOfAchieving\" /\u003e \u003cdiv formGroupName=\"placeOfAchieving\"\u003e \u003ch2\u003ePlace of Achieving\u003c/h2\u003e \u003clabel for=\"street\"\u003eStreet: \u003c/label\u003e \u003cinput id=\"street\" type=\"text\" formControlName=\"street\" /\u003e \u003clabel for=\"city\"\u003eCity: \u003c/label\u003e \u003cinput id=\"city\" type=\"text\" formControlName=\"city\" /\u003e \u003clabel for=\"state\"\u003eState: \u003c/label\u003e \u003cinput id=\"state\" type=\"text\" formControlName=\"state\" /\u003e \u003clabel for=\"zip\"\u003eZip Code: \u003c/label\u003e \u003cinput id=\"zip\" type=\"number\" formControlName=\"zip\" /\u003e \u003c/div\u003e \u003cdiv formArrayName=\"aliases\"\u003e \u003ch2\u003eAliases\u003c/h2\u003e \u003cdiv *ngFor=\"let alias of aliases.controls; let i=index\"\u003e \u003c!-- The repeated alias template --\u003e \u003clabel for=\"alias-{{ i }}\"\u003eAlias:\u003c/label\u003e \u003cinput id=\"alias-{{ i }}\" type=\"text\" [formControlName]=\"i\" /\u003e \u003cbutton type=\"button\" (click)=\"removeAlias(i)\"\u003e- Remove alias\u003c/button\u003e \u003c/div\u003e \u003cbutton type=\"button\" (click)=\"addAlias()\"\u003e+ Add another alias\u003c/button\u003e \u003c/div\u003e \u003c/form\u003e \u003cp\u003eValue Title Name: {{ triumphForm.value.name }}\u003c/p\u003e \u003cp\u003eValue Year of Achieving: {{ triumphForm.value.yearOfAchieving }}\u003c/p\u003e \u003cp\u003eValue Street: {{ triumphForm.value.placeOfAchieving.street }}\u003c/p\u003e \u003cp\u003eValue City: {{ triumphForm.value.placeOfAchieving.city }}\u003c/p\u003e \u003cp\u003eValue State: {{ triumphForm.value.placeOfAchieving.state }}\u003c/p\u003e \u003cp\u003eValue Zip: {{ triumphForm.value.placeOfAchieving.zip }}\u003c/p\u003e Form Builder Wie man bei der verschachtelten FormGroup gesehen hat, besteht der Code zum Teil aus einigen Duplikaten. Um dies zu vermeiden, kann man beim Erstellen einer Form einen Hilfsservice namens FormBuilder benutzen. Diesen muss man auch importieren und dann im Constructor injecten. Anstelle von new FormGroup() verwendet man nun this.formBuilder.group(), bei FormArray schreibt man mittels dem FormBuilder noch this.formBuilder.array(). Bei den Controls kann man jedoch einfach nur das Key-Value Paar angeben.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import { Component } from \"@angular/core\"; import { FormBuilder } from \"@angular/forms\"; @Component({ // .. }) export class TriumphsComponent implements AfterViewInit { // .. triumphForm = this.formBuilder.group({ name: [\"\"], yearOfAchieving: [\"\"], placeOfAchieving: this.formBuilder.group({ street: [\"\"], city: [\"\"], state: [\"\"], zip: [\"\"], }), aliases: this.formBuilder.array([this.formBuilder.control(\"\")]), }); constructor(private formBuilder: FormBuilder) { this.triumphForm.valueChanges.subscribe((value) =\u003e { console.log(value); // {name: '', yearOfAchieving: '', placeOfAchieving: {...}, aliases: Array[]} }); } // .. } Validators Es gibt eine Vielzahl von Validators, die man verwenden kann, um die Eingaben der Benutzer zu überprüfen und sicherzustellen, dass sie den gewünschten Anforderungen entsprechen. Die am häufigsten verwendeten Validators sind:\nValidators.required: Dieser Validator stellt sicher, dass das Formularelement einen Wert enthält und nicht leer ist.\nValidators.minLength(minLength): Dieser Validator überprüft, ob der Value des Formularelements einer Mindestlänge entspricht, die durch den Parameter minLength festgelegt wird.\nValidators.maxLength(maxLength): Dieser Validator überprüft, ob der Value des Formularelements einer Maximallänge entspricht, die durch den Parameter maxLength festgelegt wird.\nValidators.pattern(pattern): Dieser Validator überprüft den Value des Formularelements anhand eines regulären Ausdrucks, der durch den Parameter pattern definiert wird. Man kann damit bestimmte Muster wie z.B. eine gültige E-Mail-Adresse, Telefonnummer etc. voraussetzen. Das pattern funktioniert wie ein Regex und kann in diesem Format angegeben werden, z:B so: [a-zA-Z0-9]\nValidators.email: Dieser Validator überprüft, ob der Value des Formularelements eine gültige E-Mail-Adresse ist.\nValidators.min(min): Dieser Validator überprüft, ob der Value des Formularelements grösser oder gleich dem angegebenen Minimum (min) ist. Dieser Validator wird zumeist für numerische Eingabefelder verwendet.\nValidators.max(max): Dieser Validator überprüft, ob der Value des Formularelements kleiner oder gleich dem angegebenen Maximum (max) ist. Auch dieser Validator wird zumeist für numerische Eingabefelder verwendet.\nEs können auch mehrere Validators eingesetzt werden, dazu muss man diese einfach in Form eines Arrays angeben. Grundsätzlich setzen die Validators jeweils die CSS-Klassen ng-valid (bei einer positiven Validierung) und ng-invalid (bei einer negativen Validierung) auf des entsprechende Element. Das Ergebnis hingegen muss aber jeweils vom Entwickler visualisiert werden.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import { Component } from \"@angular/core\"; import { FormBuilder, Validators } from \"@angular/forms\"; @Component({ // .. }) export class TriumphsComponent implements AfterViewInit { // .. triumphForm = this.formBuilder.group({ name: [\"\"], yearOfAchieving: [\"\", Validators.required], placeOfAchieving: this.formBuilder.group({ street: [\"\", Validators.required], city: [\"\", Validators.required], state: [\"\", Validators.required], zip: [\"\", [Validators.required, Validators.min(1000)]], }), aliases: this.formBuilder.array([ this.formBuilder.control(\"\", Validators.required), ]), }); constructor(private formBuilder: FormBuilder) { this.triumphForm.valueChanges.subscribe((value) =\u003e { console.log(value); // {name: '', yearOfAchieving: '', placeOfAchieving: {...}, aliases: Array[]} }); } // .. } Custom Validators Man hat zudem die Möglichkeit, benutzerdefinierte Validators zu erstellen, um spezifische Validierungslogik für Formularelements zu implementieren.\nDer Ausdruck /bob/i wird verwendet, um nach dem Namen “Bob” im Eingabewert zu suchen, und das “i” am Ende steht für “case insensitive” (Gross- und Kleinschreibung wird ignoriert).\n1 2 3 4 5 6 export function forbiddenNameValidator(nameRe: RegExp): ValidatorFn { return (control: AbstractControl): ValidationErrors | null =\u003e { const forbidden = nameRe.test(control.value); return forbidden ? { forbiddenName: { value: control.value } } : null; }; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import { Component } from \"@angular/core\"; import { FormBuilder, Validators } from \"@angular/forms\"; @Component({ // .. }) export class TriumphsComponent implements AfterViewInit { // .. triumphForm = this.formBuilder.group({ name: [\"\", [Validators.required, forbiddenNameValidator(/bob/i)]], yearOfAchieving: [\"\", Validators.required], placeOfAchieving: this.formBuilder.group({ street: [\"\", Validators.required], city: [\"\", Validators.required], state: [\"\", Validators.required], zip: [\"\", [Validators.required, Validators.min(1000)]], }), aliases: this.formBuilder.array([ this.formBuilder.control(\"\", Validators.required), ]), }); constructor(private formBuilder: FormBuilder) { this.triumphForm.valueChanges.subscribe((value) =\u003e { console.log(value); // {name: '', yearOfAchieving: '', placeOfAchieving: {...}, aliases: Array[]} }); } // .. } ","categories":"","description":"Modul #F6 - Angular - Reactive Forms\n","excerpt":"Modul #F6 - Angular - Reactive Forms\n","ref":"/docs/03_web/06_angular/03_4_forms/","tags":"","title":"Reactive Forms"},{"body":"Ziele Du weisst was Angular Reactive Forms sind. Du weisst, was FormsControl, -Group und -Array sind und kannst diese anwenden. Du weisst, was der FormBuilder ist und kannst ihn anwenden. Du kennst die Validators, kannst sie verwenden und eigene schrieben. Angular Reactive Forms Angular Reactive Forms sind ein leistungsstarkes Feature von Angular, mit dem Entwickler Formulare erstellen, validieren und mit ihnen interagieren können. Im Gegensatz zu Template-driven Forms, bei denen die Formularlogik hauptsächlich im HTML-Template liegt, wird bei Reactive Forms die Formularlogik in den Components selbst geschrieben.\nDoch wieso sollte man Forms verwenden? Dies hört sich nun sehr ähnlich an wie ngModel, welches eine FormControl-Instanz erstellt und diese an ein FormControlElement anbindet. Genauere Infos zu ngModel kannst du dir hier anschauen. Wieso aber sollte man besser Reactive Forms verwenden? Dazu gibt es folgende Gründe:\nReactive Forms ermöglichen eine klare Trennung zwischen Datenmodell und View. Man erstellt ein separates FormGroup-Objekt, das die Struktur und Validierung der Formulardaten definiert. Dieses Datenmodell kann unabhängig von dem View-Component existieren und ermöglicht eine bessere Organisation und Wiederverwendbarkeit des Codes. Mit Reactive Forms hat man die volle Kontrolle über die Formulare, da man FormControls und FormGroups programmatisch erstellen und manipulieren kann. Man kann dynamisch Formularfelder hinzufügen, entfernen oder ändern, Validierungsregeln anpassen und auf Ereignisse reagieren. Reactive Forms bieten eine umfangreichere Unterstützung für komplexe Validierungsszenarien. Man kann benutzerdefinierte Validatoren erstellen oder viele bereits existierende verwenden. Insgesamt bietet die Verwendung von Reactive Forms eine flexiblere, leistungsfähigere und besser strukturierte Möglichkeit, Formulare in Angular zu verwalten. Sie ermöglichen eine bessere Kontrolle, erweiterte Validierungsoptionen und eine klarere Trennung zwischen Datenmodell und View-Komponenten.\nImportieren in Module Bevor man Reactive Forms verwenden kann, muss man die ReactiveFormsModule in das Modul / den Component importieren, in dem man Reactive Forms verwenden möchte.\n1 2 3 4 5 6 7 import { ReactiveFormsModule } from \"@angular/forms\"; @NgModule({ imports: [ReactiveFormsModule], // .. }) export class AppModule {} FormControl Ein FormControl ist ein Objekt, das ein einzelnes Formularelement repräsentiert und steuert. Es ermöglicht die Verwaltung des Werts, der Validierung und des Zustands des Formularelements.\nWenn man ein FormControl verwenden möchte, kann man dieses mittels new FormControl('') einer Variable zuweisen. Dadurch ist die Variable nun die FormControl. Damit man es nun im HTML verwenden kann, um es zu binden, muss man bei einem input-tag [formControl]=\"\" verwenden. In die \"\" kommt dann der Variabelname der FormControl.\n1 2 3 4 5 6 7 8 9 10 11 12 13 import { Component } from \"@angular/core\"; import { FormControl } from \"@angular/forms\"; @Component({ // .. }) export class TriumphsComponent implements AfterViewInit { // .. triumphForm: FormControl = new FormControl(\"\"); // .. } 1 2 3 4 5 \u003cdiv\u003e \u003clabel for=\"triumph\"\u003eTitel: \u003c/label\u003e \u003cinput id=\"triumph\" type=\"text\" [formControl]=\"triumphForm\" /\u003e \u003cp\u003eValue: {{ triumphForm.value }}\u003c/p\u003e \u003c/div\u003e Man kann der FormControl auch einen Defaultwert geben, dazu einfach innerhalb der runden Klammern anstelle von einem leeren String den Defaultwert einfügen. Auch den Value kann man manuell im Typescript verändern, das funktioniert mittels der setValue() Methode.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import { Component } from \"@angular/core\"; import { FormControl } from \"@angular/forms\"; @Component({ // .. }) export class TriumphsComponent implements AfterViewInit { // .. triumphForm: FormControl = new FormControl(\"default Title\"); // .. updateTitle() { this.triumphForm.setValue(\"Triumphs\"); } } 1 2 3 4 5 6 \u003cdiv\u003e \u003clabel for=\"triumph\"\u003eTitel: \u003c/label\u003e \u003cinput id=\"triumph\" type=\"text\" [formControl]=\"triumphForm\" /\u003e \u003cp\u003eValue: {{ triumphForm.value }}\u003c/p\u003e \u003cbutton type=\"button\" (click)=\"updateTitle()\"\u003eUpdate Title\u003c/button\u003e \u003c/div\u003e Wenn man in Typescript direkt auf Änderungen der FormControl subscriben möchte, damit man immer den aktuellen Value der FormControl hat, kann man valueChanges benutzen. Somit hat man im Typescript denselben aktuellen Value wie im HTML mittels {{ name.value }}.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import { Component } from \"@angular/core\"; import { FormControl } from \"@angular/forms\"; @Component({ // .. }) export class TriumphsComponent implements AfterViewInit { // .. triumphForm: FormControl = new FormControl(\"default Title\"); constructor() { this.triumphForm.valueChanges.subscribe((value) =\u003e { console.log(value); }); } // .. } 1 2 3 4 5 \u003cdiv\u003e \u003clabel for=\"triumph\"\u003eTitel: \u003c/label\u003e \u003cinput id=\"triumph\" type=\"text\" [formControl]=\"triumphForm\" /\u003e \u003cp\u003eValue: {{ triumphForm.value }}\u003c/p\u003e \u003c/div\u003e FormGroup Da ein Form-Element normalerweise aus mehr als einem Control-Element besteht, kann man FormControls jeweils zu einer gruppieren.\nFür die FormGroup erstellt man auch eine neue Instanz der FormGroup, in welcher sich die FormControl’s befinden. Die FormGroup wird in einer Variable gespeichert, die FormControls werden mit eindeutigem Key-Value-Prinzip definiert. Man kann auch hier auf die Group mittels valueChanges subscriben, nur dass hier dann nicht einfach der Value des Inputs ausgegeben wird, sondern ein Objekt mit den Controls als Key-Value geliefert wird. Um eine FormGroup im HTML zu verwenden, sollte der form-tag verwendet werden. In diesem muss man die FormGroup mittels [formGroup]=\"\" angeben, auch hier kommt in die \"\" der Variablenname der FormGroup. Um nun die FormControls anzugeben, verwendet man nicht mehr [formControl]=\"\", sondern formControlName=\"\", hier kommt in die \"\" der Key der FormControl.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import { Component } from \"@angular/core\"; import { FormGroup, FormControl } from \"@angular/forms\"; @Component({ // .. }) export class TriumphsComponent implements AfterViewInit { // .. triumphForm: FormGroup = new FormGroup({ name: new FormControl(\"\"), yearOfAchieving: new FormControl(\"\"), }); constructor() { this.triumphForm.valueChanges.subscribe((value) =\u003e { console.log(value); // {name: '', yearOfAchieving: ''} }); } // .. } 1 2 3 4 5 6 7 8 9 \u003cform [formGroup]=\"triumphForm\"\u003e \u003clabel for=\"name\"\u003eTitle Name: \u003c/label\u003e \u003cinput id=\"name\" type=\"text\" formControlName=\"name\" /\u003e \u003clabel for=\"yearOfAchieving\"\u003eYear of Achieving: \u003c/label\u003e \u003cinput id=\"yearOfAchieving\" type=\"number\" formControlName=\"yearOfAchieving\" /\u003e \u003c/form\u003e \u003cp\u003eValue Title Name: {{ triumphForm.value.name }}\u003c/p\u003e \u003cp\u003eValue Year of Achieving: {{ triumphForm.value.yearOfAchieving }}\u003c/p\u003e Es ist auch möglich, eine FormGroup innerhalb einer anderen FormGroup zu verwenden und so das gesamte zu verschachteln, um komplexe Forms mit hierarchischer Struktur zu erstellen. Das funktioniert genau gleich, hier muss dann einfach die zweite FormGroup auch als Key-Value angegeben werden. Die zweite FormGroup muss dann mit formGroupName=\"\" angegeben werden und nicht mehr mit [formGroup]=\"\", innerhalb der \"\" kommt hier dann auch der Key der zweiten FormGroup. Man sollte für die zweite FormGroup dann ein div-tag verwenden.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import { Component } from \"@angular/core\"; import { FormGroup, FormControl } from \"@angular/forms\"; @Component({ // .. }) export class TriumphsComponent implements AfterViewInit { // .. triumphForm: FormGroup = new FormGroup({ name: new FormControl(\"\"), yearOfAchieving: new FormControl(\"\"), placeOfAchieving: new FormGroup({ street: new FormControl(\"\"), city: new FormControl(\"\"), state: new FormControl(\"\"), zip: new FormControl(\"\"), }), }); constructor() { this.triumphForm.valueChanges.subscribe((value) =\u003e { console.log(value); // {name: '', yearOfAchieving: '', placeOfAchieving: {...}} }); } // .. } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u003cform [formGroup]=\"triumphForm\"\u003e \u003clabel for=\"name\"\u003eTitle Name: \u003c/label\u003e \u003cinput id=\"name\" type=\"text\" formControlName=\"name\" /\u003e \u003clabel for=\"yearOfAchieving\"\u003eYear of Achieving: \u003c/label\u003e \u003cinput id=\"yearOfAchieving\" type=\"number\" formControlName=\"yearOfAchieving\" /\u003e \u003cdiv formGroupName=\"placeOfAchieving\"\u003e \u003ch2\u003ePlace of Achieving\u003c/h2\u003e \u003clabel for=\"street\"\u003eStreet: \u003c/label\u003e \u003cinput id=\"street\" type=\"text\" formControlName=\"street\" /\u003e \u003clabel for=\"city\"\u003eCity: \u003c/label\u003e \u003cinput id=\"city\" type=\"text\" formControlName=\"city\" /\u003e \u003clabel for=\"state\"\u003eState: \u003c/label\u003e \u003cinput id=\"state\" type=\"text\" formControlName=\"state\" /\u003e \u003clabel for=\"zip\"\u003eZip Code: \u003c/label\u003e \u003cinput id=\"zip\" type=\"number\" formControlName=\"zip\" /\u003e \u003c/div\u003e \u003c/form\u003e \u003cp\u003eValue Title Name: {{ triumphForm.value.name }}\u003c/p\u003e \u003cp\u003eValue Year of Achieving: {{ triumphForm.value.yearOfAchieving }}\u003c/p\u003e \u003cp\u003eValue Street: {{ triumphForm.value.placeOfAchieving.street }}\u003c/p\u003e \u003cp\u003eValue City: {{ triumphForm.value.placeOfAchieving.city }}\u003c/p\u003e \u003cp\u003eValue State: {{ triumphForm.value.placeOfAchieving.state }}\u003c/p\u003e \u003cp\u003eValue Zip: {{ triumphForm.value.placeOfAchieving.zip }}\u003c/p\u003e Wenn man eine so grosse FormGroup hat und nun einen Wert über Typescript ändern möchte, kann man dies auch mittels setValue() tun. Das kann jedoch mühsam sein, da man bei dieser Methode alle Values (FormControls) der FormGroup angeben muss. Wenn man aber nur einzelne anpassen möchte, kann man die Methode patchValue() verwenden. Diese Methode erlaubt es nämlich, dass man nur einzelne der Values (FormControls) angeben muss.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import { Component } from \"@angular/core\"; import { FormGroup, FormControl } from \"@angular/forms\"; @Component({ // .. }) export class TriumphsComponent implements AfterViewInit { // .. triumphForm: FormGroup = new FormGroup({ name: new FormControl(\"\"), yearOfAchieving: new FormControl(\"\"), placeOfAchieving: new FormGroup({ street: new FormControl(\"\"), city: new FormControl(\"\"), state: new FormControl(\"\"), zip: new FormControl(\"\"), }), }); constructor() { this.triumphForm.valueChanges.subscribe((value) =\u003e { console.log(value); // {name: '', yearOfAchieving: '', placeOfAchieving: {...}} }); } // .. updateTriumph() { this.triumphForm.patchValue({ name: \"Assably\", placeOfAchieving: { street: \"123 Down Street\", }, }); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \u003cform [formGroup]=\"triumphForm\"\u003e \u003clabel for=\"name\"\u003eTitle Name: \u003c/label\u003e \u003cinput id=\"name\" type=\"text\" formControlName=\"name\" /\u003e \u003clabel for=\"yearOfAchieving\"\u003eYear of Achieving: \u003c/label\u003e \u003cinput id=\"yearOfAchieving\" type=\"number\" formControlName=\"yearOfAchieving\" /\u003e \u003cdiv formGroupName=\"placeOfAchieving\"\u003e \u003ch2\u003ePlace of Achieving\u003c/h2\u003e \u003clabel for=\"street\"\u003eStreet: \u003c/label\u003e \u003cinput id=\"street\" type=\"text\" formControlName=\"street\" /\u003e \u003clabel for=\"city\"\u003eCity: \u003c/label\u003e \u003cinput id=\"city\" type=\"text\" formControlName=\"city\" /\u003e \u003clabel for=\"state\"\u003eState: \u003c/label\u003e \u003cinput id=\"state\" type=\"text\" formControlName=\"state\" /\u003e \u003clabel for=\"zip\"\u003eZip Code: \u003c/label\u003e \u003cinput id=\"zip\" type=\"number\" formControlName=\"zip\" /\u003e \u003c/div\u003e \u003c/form\u003e \u003cbutton type=\"button\" (click)=\"updateTriumph()\"\u003eUpdate Triumph\u003c/button\u003e \u003cp\u003eValue Title Name: {{ triumphForm.value.name }}\u003c/p\u003e \u003cp\u003eValue Year of Achieving: {{ triumphForm.value.yearOfAchieving }}\u003c/p\u003e \u003cp\u003eValue Street: {{ triumphForm.value.placeOfAchieving.street }}\u003c/p\u003e \u003cp\u003eValue City: {{ triumphForm.value.placeOfAchieving.city }}\u003c/p\u003e \u003cp\u003eValue State: {{ triumphForm.value.placeOfAchieving.state }}\u003c/p\u003e \u003cp\u003eValue Zip: {{ triumphForm.value.placeOfAchieving.zip }}\u003c/p\u003e FormArray FormArray ist eine Alternative zu FormGroup, wird jedoch verwendet, wenn man eine unbestimmte Anzahl von FormControl-Elemente, FormGroups oder weiteren FormArrays haben möchte. Dadurch hat man die Möglichkeit, dynamisch Formularelemente während der Laufzeit hinzuzufügen oder zu löschen. Praktisch ist, dass man keinen Key für die Formularelemente definieren muss und man nicht weiss, wie viele Elemente es am Schluss sein werden.\nUm auf das FormArray zugreifen zu können muss man eine get-Methode schreiben, diese findet man im folgenden Code.\nWie man Elemente in das FormArray hinzufügt und löscht ist auch im untenstehenden Code zu finden.\nIm HTML muss man das FormArray mittels formArrayName=\"\" angeben, auch hier kommt innerhalb der \"\" der Key des FormArrays. Um an die einzelnen Elemente zu gelangen, muss man mittels einem *ngFor darüber iterieren. Im folgenden Beispiel wird die ID des Inputs dynamisch mittels des Index des Elements erstellt.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 import { Component } from \"@angular/core\"; import { FormGroup, FormControl, FormArray } from \"@angular/forms\"; @Component({ // .. }) export class TriumphsComponent implements AfterViewInit { // .. triumphForm: FormGroup = new FormGroup({ name: new FormControl(\"\"), yearOfAchieving: new FormControl(\"\"), placeOfAchieving: new FormGroup({ street: new FormControl(\"\"), city: new FormControl(\"\"), state: new FormControl(\"\"), zip: new FormControl(\"\"), }), aliases: new FormArray([new FormControl(\"\")]), }); constructor() { this.triumphForm.valueChanges.subscribe((value) =\u003e { console.log(value); // {name: '', yearOfAchieving: '', placeOfAchieving: {...}, aliases: Array[]} }); } get aliases() { return this.triumphForm.get(\"aliases\") as FormArray; } addAlias() { this.aliases.push(new FormControl(\"\")); } removeAlias(index: number): void { this.aliases.removeAt(index); } // .. } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 \u003cform [formGroup]=\"triumphForm\"\u003e \u003clabel for=\"name\"\u003eTitle Name: \u003c/label\u003e \u003cinput id=\"name\" type=\"text\" formControlName=\"name\" /\u003e \u003clabel for=\"yearOfAchieving\"\u003eYear of Achieving: \u003c/label\u003e \u003cinput id=\"yearOfAchieving\" type=\"number\" formControlName=\"yearOfAchieving\" /\u003e \u003cdiv formGroupName=\"placeOfAchieving\"\u003e \u003ch2\u003ePlace of Achieving\u003c/h2\u003e \u003clabel for=\"street\"\u003eStreet: \u003c/label\u003e \u003cinput id=\"street\" type=\"text\" formControlName=\"street\" /\u003e \u003clabel for=\"city\"\u003eCity: \u003c/label\u003e \u003cinput id=\"city\" type=\"text\" formControlName=\"city\" /\u003e \u003clabel for=\"state\"\u003eState: \u003c/label\u003e \u003cinput id=\"state\" type=\"text\" formControlName=\"state\" /\u003e \u003clabel for=\"zip\"\u003eZip Code: \u003c/label\u003e \u003cinput id=\"zip\" type=\"number\" formControlName=\"zip\" /\u003e \u003c/div\u003e \u003cdiv formArrayName=\"aliases\"\u003e \u003ch2\u003eAliases\u003c/h2\u003e \u003cdiv *ngFor=\"let alias of aliases.controls; let i=index\"\u003e \u003c!-- The repeated alias template --\u003e \u003clabel for=\"alias-{{ i }}\"\u003eAlias:\u003c/label\u003e \u003cinput id=\"alias-{{ i }}\" type=\"text\" [formControlName]=\"i\" /\u003e \u003cbutton type=\"button\" (click)=\"removeAlias(i)\"\u003e- Remove alias\u003c/button\u003e \u003c/div\u003e \u003cbutton type=\"button\" (click)=\"addAlias()\"\u003e+ Add another alias\u003c/button\u003e \u003c/div\u003e \u003c/form\u003e \u003cp\u003eValue Title Name: {{ triumphForm.value.name }}\u003c/p\u003e \u003cp\u003eValue Year of Achieving: {{ triumphForm.value.yearOfAchieving }}\u003c/p\u003e \u003cp\u003eValue Street: {{ triumphForm.value.placeOfAchieving.street }}\u003c/p\u003e \u003cp\u003eValue City: {{ triumphForm.value.placeOfAchieving.city }}\u003c/p\u003e \u003cp\u003eValue State: {{ triumphForm.value.placeOfAchieving.state }}\u003c/p\u003e \u003cp\u003eValue Zip: {{ triumphForm.value.placeOfAchieving.zip }}\u003c/p\u003e Form Builder Wie man bei der verschachtelten FormGroup gesehen hat, besteht der Code zum Teil aus einigen Duplikaten. Um dies zu vermeiden, kann man beim Erstellen einer Form einen Hilfsservice namens FormBuilder benutzen. Diesen muss man auch importieren und dann im Constructor injecten. Anstelle von new FormGroup() verwendet man nun this.formBuilder.group(), bei FormArray schreibt man mittels dem FormBuilder noch this.formBuilder.array(). Bei den Controls kann man jedoch einfach nur das Key-Value Paar angeben.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import { Component } from \"@angular/core\"; import { FormBuilder } from \"@angular/forms\"; @Component({ // .. }) export class TriumphsComponent implements AfterViewInit { // .. triumphForm = this.formBuilder.group({ name: [\"\"], yearOfAchieving: [\"\"], placeOfAchieving: this.formBuilder.group({ street: [\"\"], city: [\"\"], state: [\"\"], zip: [\"\"], }), aliases: this.formBuilder.array([this.formBuilder.control(\"\")]), }); constructor(private formBuilder: FormBuilder) { this.triumphForm.valueChanges.subscribe((value) =\u003e { console.log(value); // {name: '', yearOfAchieving: '', placeOfAchieving: {...}, aliases: Array[]} }); } // .. } Validators Es gibt eine Vielzahl von Validators, die man verwenden kann, um die Eingaben der Benutzer zu überprüfen und sicherzustellen, dass sie den gewünschten Anforderungen entsprechen. Die am häufigsten verwendeten Validators sind:\nValidators.required: Dieser Validator stellt sicher, dass das Formularelement einen Wert enthält und nicht leer ist.\nValidators.minLength(minLength): Dieser Validator überprüft, ob der Value des Formularelements einer Mindestlänge entspricht, die durch den Parameter minLength festgelegt wird.\nValidators.maxLength(maxLength): Dieser Validator überprüft, ob der Value des Formularelements einer Maximallänge entspricht, die durch den Parameter maxLength festgelegt wird.\nValidators.pattern(pattern): Dieser Validator überprüft den Value des Formularelements anhand eines regulären Ausdrucks, der durch den Parameter pattern definiert wird. Man kann damit bestimmte Muster wie z.B. eine gültige E-Mail-Adresse, Telefonnummer etc. voraussetzen. Das pattern funktioniert wie ein Regex und kann in diesem Format angegeben werden, z:B so: [a-zA-Z0-9]\nValidators.email: Dieser Validator überprüft, ob der Value des Formularelements eine gültige E-Mail-Adresse ist.\nValidators.min(min): Dieser Validator überprüft, ob der Value des Formularelements grösser oder gleich dem angegebenen Minimum (min) ist. Dieser Validator wird zumeist für numerische Eingabefelder verwendet.\nValidators.max(max): Dieser Validator überprüft, ob der Value des Formularelements kleiner oder gleich dem angegebenen Maximum (max) ist. Auch dieser Validator wird zumeist für numerische Eingabefelder verwendet.\nEs können auch mehrere Validators eingesetzt werden, dazu muss man diese einfach in Form eines Arrays angeben. Grundsätzlich setzen die Validators jeweils die CSS-Klassen ng-valid (bei einer positiven Validierung) und ng-invalid (bei einer negativen Validierung) auf des entsprechende Element. Das Ergebnis hingegen muss aber jeweils vom Entwickler visualisiert werden.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import { Component } from \"@angular/core\"; import { FormBuilder, Validators } from \"@angular/forms\"; @Component({ // .. }) export class TriumphsComponent implements AfterViewInit { // .. triumphForm = this.formBuilder.group({ name: [\"\"], yearOfAchieving: [\"\", Validators.required], placeOfAchieving: this.formBuilder.group({ street: [\"\", Validators.required], city: [\"\", Validators.required], state: [\"\", Validators.required], zip: [\"\", [Validators.required, Validators.min(1000)]], }), aliases: this.formBuilder.array([ this.formBuilder.control(\"\", Validators.required), ]), }); constructor(private formBuilder: FormBuilder) { this.triumphForm.valueChanges.subscribe((value) =\u003e { console.log(value); // {name: '', yearOfAchieving: '', placeOfAchieving: {...}, aliases: Array[]} }); } // .. } Custom Validators Man hat zudem die Möglichkeit, benutzerdefinierte Validators zu erstellen, um spezifische Validierungslogik für Formularelements zu implementieren.\nDer Ausdruck /bob/i wird verwendet, um nach dem Namen “Bob” im Eingabewert zu suchen, und das “i” am Ende steht für “case insensitive” (Gross- und Kleinschreibung wird ignoriert).\n1 2 3 4 5 6 export function forbiddenNameValidator(nameRe: RegExp): ValidatorFn { return (control: AbstractControl): ValidationErrors | null =\u003e { const forbidden = nameRe.test(control.value); return forbidden ? { forbiddenName: { value: control.value } } : null; }; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import { Component } from \"@angular/core\"; import { FormBuilder, Validators } from \"@angular/forms\"; @Component({ // .. }) export class TriumphsComponent implements AfterViewInit { // .. triumphForm = this.formBuilder.group({ name: [\"\", [Validators.required, forbiddenNameValidator(/bob/i)]], yearOfAchieving: [\"\", Validators.required], placeOfAchieving: this.formBuilder.group({ street: [\"\", Validators.required], city: [\"\", Validators.required], state: [\"\", Validators.required], zip: [\"\", [Validators.required, Validators.min(1000)]], }), aliases: this.formBuilder.array([ this.formBuilder.control(\"\", Validators.required), ]), }); constructor(private formBuilder: FormBuilder) { this.triumphForm.valueChanges.subscribe((value) =\u003e { console.log(value); // {name: '', yearOfAchieving: '', placeOfAchieving: {...}, aliases: Array[]} }); } // .. } ","categories":"","description":"Modul #F6 - Angular - Reactive Forms\n","excerpt":"Modul #F6 - Angular - Reactive Forms\n","ref":"/de/docs/03_web/06_angular/03_4_forms/","tags":"","title":"Reactive Forms"},{"body":"Motivation Die JavaScript-Konsole bietet viele hilfreiche Tools an, um Texte zu loggen. Diese Möglichkeiten schauen wir uns hier an.\nZiele Du kennst Alternativen zu console.log(...). Basics Die console.log(...)-Struktur in JavaScript ist das Äquivalent zu System.out.println(...) in Java, Console.WriteLine(...) in C#, print(...) in Python oder puts ... in Ruby.\nEs gibt in JavaScript noch weitere Alternativen zu console.log(...), die durchaus nützlich sind.\nZum Beispiel kannst du den Logs eine Kategorie zuordnen, wobei die Logs in unterschiedlichen Farben angezeigt werden:\nconsole.info(...) (neutral) console.warn(...) (gelb/orange/grün) console.error(...) (rot) console.debug(...) (blau, aber nur sichtbar, wenn “Alle [Log-]Ebenen” in der Konsole angezeigt werden) Nie mehr Counter-Variablen für Debugging-Zwecke! Wenn du beispielsweise feststellen möchtest, wie oft etwas aufgerufen wird, kann dir console.count(\"\") weiterhelfen:\n1 2 console.count(\"alarm\"); \u003e\u003e\u003e alarm: 3 Objekte loggen Wenn du Objekte mit ihren Attributen und Werten loggen möchtest, dann bietet sich die console.dir(...)-Funktion an:\n1 2 3 4 5 6 7 console.dir(person); \u003e\u003e\u003e Person { name: 'Confused Nick Young', age: undefined, gender: 'male', lovesJavaScript: true } Tabelle loggen Möchtest du beispielsweise ein Array in Form einer Tabelle loggen, kannst du das mit console.table(...) bewerkstelligen.\n1 2 3 4 5 6 7 8 9 10 console.table( [person1, person2] ) \u003e\u003e\u003e ┌─────────┬────────────────────────┬───────────┬───────────┬─────────────────┐ │ (index) │ name │ age │ gender │ lovesJavaScript │ ├─────────┼────────────────────────┼───────────┼───────────┼─────────────────┤ │ 0 │ 'Confused Nick Young' │ undefined │ 'male' │ false │ │ 1 │'Tuxedo Winnie the Pooh'│ undefined │ undefined │ true │ └─────────┴────────────────────────┴───────────┴───────────┴─────────────────┘ Log stylen Wenn du %c zu der Message im Log hinzufügst, kannst du den angezeigten Text stylen:\n1 2 3 4 console.log( \"%cHello World\", \"color: blue; font-weight: bolder; background-color: white; border: 1px solid; border-radius: 2em; padding: 1em;\", ); Fehlerhafte Werte loggen Als Entwickler:in möchtest du informiert werden, wenn an einem Ort fehlerhafte Werte zurückgegeben wurden (zum Beispiel Rückgabe-Werte von Funktionen).\nHierfür bietet sich console.assert(...) an:\n1 2 3 4 5 6 7 8 9 10 11 12 let connectionToDatabase = connectToDatabase(); // returns `null` if connection fails. console.assert( connectionToDatabase != null, { connectionToDatabase: connectionToDatabase, errorMsg: \"Es konnte keine Verbindung zur Datenbank hergestellt werden. ¯\\_(ツ)_/¯\" }); \u003e\u003e\u003e Assertionsfehler: { connectionToDatabase: null, errorMsg: 'Es konnte keine Verbindung zur Datenbank hergestellt werden. ¯_(ツ)_/¯' } ","categories":"","description":"Modul #F4 - JavaScript - Die Browser-Konsole\n","excerpt":"Modul #F4 - JavaScript - Die Browser-Konsole\n","ref":"/docs/03_web/03_javascript/23_console.logs/","tags":"","title":"Advanced console.log(...)'s"},{"body":"Motivation Die JavaScript-Konsole bietet viele hilfreiche Tools an, um Texte zu loggen. Diese Möglichkeiten schauen wir uns hier an.\nZiele Du kennst Alternativen zu console.log(...). Basics Die console.log(...)-Struktur in JavaScript ist das Äquivalent zu System.out.println(...) in Java, Console.WriteLine(...) in C#, print(...) in Python oder puts ... in Ruby.\nEs gibt in JavaScript noch weitere Alternativen zu console.log(...), die durchaus nützlich sind.\nZum Beispiel kannst du den Logs eine Kategorie zuordnen, wobei die Logs in unterschiedlichen Farben angezeigt werden:\nconsole.info(...) (neutral) console.warn(...) (gelb/orange/grün) console.error(...) (rot) console.debug(...) (blau, aber nur sichtbar, wenn “Alle [Log-]Ebenen” in der Konsole angezeigt werden) Nie mehr Counter-Variablen für Debugging-Zwecke! Wenn du beispielsweise feststellen möchtest, wie oft etwas aufgerufen wird, kann dir console.count(\"\") weiterhelfen:\n1 2 console.count(\"alarm\"); \u003e\u003e\u003e alarm: 3 Objekte loggen Wenn du Objekte mit ihren Attributen und Werten loggen möchtest, dann bietet sich die console.dir(...)-Funktion an:\n1 2 3 4 5 6 7 console.dir(person); \u003e\u003e\u003e Person { name: 'Confused Nick Young', age: undefined, gender: 'male', lovesJavaScript: true } Tabelle loggen Möchtest du beispielsweise ein Array in Form einer Tabelle loggen, kannst du das mit console.table(...) bewerkstelligen.\n1 2 3 4 5 6 7 8 9 10 console.table( [person1, person2] ) \u003e\u003e\u003e ┌─────────┬────────────────────────┬───────────┬───────────┬─────────────────┐ │ (index) │ name │ age │ gender │ lovesJavaScript │ ├─────────┼────────────────────────┼───────────┼───────────┼─────────────────┤ │ 0 │ 'Confused Nick Young' │ undefined │ 'male' │ false │ │ 1 │'Tuxedo Winnie the Pooh'│ undefined │ undefined │ true │ └─────────┴────────────────────────┴───────────┴───────────┴─────────────────┘ Log stylen Wenn du %c zu der Message im Log hinzufügst, kannst du den angezeigten Text stylen:\n1 2 3 4 console.log( \"%cHello World\", \"color: blue; font-weight: bolder; background-color: white; border: 1px solid; border-radius: 2em; padding: 1em;\", ); Fehlerhafte Werte loggen Als Entwickler:in möchtest du informiert werden, wenn an einem Ort fehlerhafte Werte zurückgegeben wurden (zum Beispiel Rückgabe-Werte von Funktionen).\nHierfür bietet sich console.assert(...) an:\n1 2 3 4 5 6 7 8 9 10 11 12 let connectionToDatabase = connectToDatabase(); // returns `null` if connection fails. console.assert( connectionToDatabase != null, { connectionToDatabase: connectionToDatabase, errorMsg: \"Es konnte keine Verbindung zur Datenbank hergestellt werden. ¯\\_(ツ)_/¯\" }); \u003e\u003e\u003e Assertionsfehler: { connectionToDatabase: null, errorMsg: 'Es konnte keine Verbindung zur Datenbank hergestellt werden. ¯_(ツ)_/¯' } ","categories":"","description":"Modul #F4 - JavaScript - Die Browser-Konsole\n","excerpt":"Modul #F4 - JavaScript - Die Browser-Konsole\n","ref":"/de/docs/03_web/03_javascript/23_console.logs/","tags":"","title":"Advanced console.log(...)'s"},{"body":"Ziele Du weisst, wofür die Internationalisierung verwendet wird. Du kannst diese in deinen Projekten anwenden. Wofür wird die Internationalisierung verwendet? Internationalisierung (i18n) bezieht sich auf die Anpassung einer Anwendung, um sie für verschiedene Sprachen und Regionen weltweit zugänglich und benutzbar zu machen. Durch Internationalisierung wird die Anwendung so gestaltet, dass sie leicht in verschiedene Sprachen übersetzt werden kann, um eine breitere Benutzerbasis anzusprechen.\nMeistens wird die Internationalisierung mit JSON und einer Translate-Pipe umgesetzt. Dabei werden JSON-Dateien verwendet, um die einzelnen Texte jeweils pro Sprache zu speichern, und die Translate-Pipe wird verwendet, um die passenden Übersetzungen abzurufen und anzuzeigen. Wichtig zu beachten ist hierbei, dass bei einem Wechsel der Sprache die Texte umgeschalten werden, ohne dass die Seite neu laden muss.\nInternationalisierung mit JSON und einer Translate-Pipe einrichten Zuerst muss man für die jeweiligen Übersetzungen JSON-Dateien erstellen: Für jede Sprache, die man unterstützen möchte, sollte man ein eigenes JSON erstellen. Diese sollten in einen neuen Ordner names i18n in den assets des Projekts abgelegt werden. Die JSON-Dateien werden meistens [kürzel].json benannt. Also zum Beispiel für Deutsch de.json. Inhalt einfügen: Nun kann man die Wörter und Texte, die man dynamisch übersetzen lassen möchte, in die JSON-Dateien eintragen. Diese werden nach dem Key-Value Prinzip eingetragen, wobei der Key in Capslock ist. Zudem müssen die Keys für die jeweiligen entsprechenden Textteile in allen JSON-Dateien immer gleich sein, ansonsten funktioniert die Übersetzung nicht. Man kann einem Key auch mehrere weitere Key-Value Paare geben, was gemacht wird, wenn sie zueinander gehören. 1 2 3 4 5 6 7 8 9 10 11 // de.json { \"TITEL\": \"Hallo, \", \"TEXT\": { \"DRAGONWARRIOR\": { \"WELCOME\": \"Willkommen im Kampf gegen den Feind Angular!\", \"OTHER\": \"Möge dein Weg von Ruhm und Triumph erfüllt sein!\" }, \"OTHER\": \"Du bist nicht der wahre Drachenkrieger. Du bist dieses Kampfes nicht würdig.\" } } 1 2 3 4 5 6 7 8 9 10 11 // en.json { \"TITEL\": \"Hello, \", \"TEXT\": { \"DRAGONWARRIOR\": { \"WELCOME\": \"Welcome to the battle against the enemy Angular!\", \"OTHER\": \"May your path be filled with glory and triumph!\" }, \"OTHER\": \"You are not the true Dragon Warrior. You are not worthy of this battle.\" } } Library installieren: Nun muss man eine Library installieren, um die translate-Pipe verwenden zu können. Dazu kann man den Befehl npm install @ngx-translate/core benutzen, um die @ngx-translate/core-Library zu installieren. Und den Befehl npm install @ngx-translate/http-loader, damit man die Library @ngx-translate/http-loader verwenden kann. Diese wird verwendet, damit der HTTPLoader in ngx-translate verwendet werden kann. Das Translate-Module importieren: Um die Übersetzung App-weit zu ermöglichen, muss das TranslateModule im AppComponent imporiert werden. 1 2 3 4 5 6 7 8 9 @Component({ //... standalone: true, imports: [CommonModule, TranslateModule], //... }) export class AppComponent { //.... } Falls es noch kein environment-File im Projekt gibt, muss dieses erstellt werden. Dazu muss in src ein Ordner environments erstellt werdne. Darin dann das File environment.ts. 1 2 3 4 export const environment = { // ... languages: [\"de\", \"en\"], }; Sprachlokalisierung aktivieren: Mithilfe des TranslateService kann man die gewünschte Sprache einstellen und die übersetzten Texte in der entsprechenden Sprache anzeigen. Man kann die Sprache basierend auf Benutzervorlieben oder anderen Kriterien festlegen. Das wird immer im app.components.ts gemacht. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import { TranslateService } from \"@ngx-translate/core\"; import { environment } from \"src/environments/environments\"; @Component({ // ... }) export class AppComponent implements OnInit { // .. constructor(private translateService: TranslateService) {} ngOnInit() { this.translateService.addLangs(environment.languages); this.setLanguage(\"en\"); } setLanguage(lang: string) { this.translateService.use(lang); } } Translate-Pipe in den HTML-Dateien: In den HTML-Dateien der Components kann man nun die Translate-Pipe verwenden, um die lokalisierten Texte anzuzeigen. Dazu die Pipe translate mit dem Übersetzungs-Key verwenden, um die Übersetzungen abzurufen. Wurden einem Key mehrere neue Key-Value Paare gegeben, so ruft man den äussersten Schlüssel auf und fügt ihn mittels eines Punktes (.) mit dem nächsten Key zusammen. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u003ch1\u003e{{ 'TITEL' | translate }}{{ name }}!\u003c/h1\u003e \u003cng-container *ngIf=\"name === 'Dragon Warrior'; else otherName\"\u003e \u003cng-container *ngTemplateOutlet=\"dragonWarrior\"\u003e\u003c/ng-container\u003e \u003c/ng-container\u003e \u003cng-template #dragonWarrior\u003e \u003cp\u003e{{ 'TEXT.DRAGONWARRIOR.WELCOME' | translate }}\u003c/p\u003e \u003cp\u003e{{ 'TEXT.DRAGONWARRIOR.OTHER' | translate }}\u003c/p\u003e \u003c/ng-template\u003e \u003cng-template #otherName\u003e \u003cp\u003e{{ 'TEXT.OTHER' | translate }}\u003c/p\u003e \u003c/ng-template\u003e Anwendungsbeispiele 1 2 3 4 5 6 7 8 // Fügt die Sprachen \"en\" und \"de\" zu den möglichen Sprachen hinzu. this.translateService.addLangs([\"en\", \"de\"]); // Gibt Englisch als standardmässig verwendete Sprache an. this.translateService.setDefaultLang(\"en\"); // Liest die derzeitige im Browser verwendete Sprache aus. const browserLang = translateService.getBrowserLang(); // Prüft, ob die derzeitige im Browser verwendete Sprache englisch oder deutsch entspricht. Entspricht einer der beiden Fälle this.translateService.use(browserLang.match(/en|de/) ? browserLang : \"en\"); ","categories":"","description":"Modul #F6 - Angular - Internationalization\n","excerpt":"Modul #F6 - Angular - Internationalization\n","ref":"/docs/03_web/06_angular/03_5_internationalization/","tags":"","title":"Internationalization (i18n)"},{"body":"Ziele Du weisst, wofür die Internationalisierung verwendet wird. Du kannst diese in deinen Projekten anwenden. Wofür wird die Internationalisierung verwendet? Internationalisierung (i18n) bezieht sich auf die Anpassung einer Anwendung, um sie für verschiedene Sprachen und Regionen weltweit zugänglich und benutzbar zu machen. Durch Internationalisierung wird die Anwendung so gestaltet, dass sie leicht in verschiedene Sprachen übersetzt werden kann, um eine breitere Benutzerbasis anzusprechen.\nMeistens wird die Internationalisierung mit JSON und einer Translate-Pipe umgesetzt. Dabei werden JSON-Dateien verwendet, um die einzelnen Texte jeweils pro Sprache zu speichern, und die Translate-Pipe wird verwendet, um die passenden Übersetzungen abzurufen und anzuzeigen. Wichtig zu beachten ist hierbei, dass bei einem Wechsel der Sprache die Texte umgeschalten werden, ohne dass die Seite neu laden muss.\nInternationalisierung mit JSON und einer Translate-Pipe einrichten Zuerst muss man für die jeweiligen Übersetzungen JSON-Dateien erstellen: Für jede Sprache, die man unterstützen möchte, sollte man ein eigenes JSON erstellen. Diese sollten in einen neuen Ordner names i18n in den assets des Projekts abgelegt werden. Die JSON-Dateien werden meistens [kürzel].json benannt. Also zum Beispiel für Deutsch de.json. Inhalt einfügen: Nun kann man die Wörter und Texte, die man dynamisch übersetzen lassen möchte, in die JSON-Dateien eintragen. Diese werden nach dem Key-Value Prinzip eingetragen, wobei der Key in Capslock ist. Zudem müssen die Keys für die jeweiligen entsprechenden Textteile in allen JSON-Dateien immer gleich sein, ansonsten funktioniert die Übersetzung nicht. Man kann einem Key auch mehrere weitere Key-Value Paare geben, was gemacht wird, wenn sie zueinander gehören. 1 2 3 4 5 6 7 8 9 10 11 // de.json { \"TITEL\": \"Hallo, \", \"TEXT\": { \"DRAGONWARRIOR\": { \"WELCOME\": \"Willkommen im Kampf gegen den Feind Angular!\", \"OTHER\": \"Möge dein Weg von Ruhm und Triumph erfüllt sein!\" }, \"OTHER\": \"Du bist nicht der wahre Drachenkrieger. Du bist dieses Kampfes nicht würdig.\" } } 1 2 3 4 5 6 7 8 9 10 11 // en.json { \"TITEL\": \"Hello, \", \"TEXT\": { \"DRAGONWARRIOR\": { \"WELCOME\": \"Welcome to the battle against the enemy Angular!\", \"OTHER\": \"May your path be filled with glory and triumph!\" }, \"OTHER\": \"You are not the true Dragon Warrior. You are not worthy of this battle.\" } } Library installieren: Nun muss man eine Library installieren, um die translate-Pipe verwenden zu können. Dazu kann man den Befehl npm install @ngx-translate/core benutzen, um die @ngx-translate/core-Library zu installieren. Und den Befehl npm install @ngx-translate/http-loader, damit man die Library @ngx-translate/http-loader verwenden kann. Diese wird verwendet, damit der HTTPLoader in ngx-translate verwendet werden kann. Das Translate-Module importieren: Um die Übersetzung App-weit zu ermöglichen, muss das TranslateModule im AppComponent imporiert werden. 1 2 3 4 5 6 7 8 9 @Component({ //... standalone: true, imports: [CommonModule, TranslateModule], //... }) export class AppComponent { //.... } Falls es noch kein environment-File im Projekt gibt, muss dieses erstellt werden. Dazu muss in src ein Ordner environments erstellt werdne. Darin dann das File environment.ts. 1 2 3 4 export const environment = { // ... languages: [\"de\", \"en\"], }; Sprachlokalisierung aktivieren: Mithilfe des TranslateService kann man die gewünschte Sprache einstellen und die übersetzten Texte in der entsprechenden Sprache anzeigen. Man kann die Sprache basierend auf Benutzervorlieben oder anderen Kriterien festlegen. Das wird immer im app.components.ts gemacht. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import { TranslateService } from \"@ngx-translate/core\"; import { environment } from \"src/environments/environments\"; @Component({ // ... }) export class AppComponent implements OnInit { // .. constructor(private translateService: TranslateService) {} ngOnInit() { this.translateService.addLangs(environment.languages); this.setLanguage(\"en\"); } setLanguage(lang: string) { this.translateService.use(lang); } } Translate-Pipe in den HTML-Dateien: In den HTML-Dateien der Components kann man nun die Translate-Pipe verwenden, um die lokalisierten Texte anzuzeigen. Dazu die Pipe translate mit dem Übersetzungs-Key verwenden, um die Übersetzungen abzurufen. Wurden einem Key mehrere neue Key-Value Paare gegeben, so ruft man den äussersten Schlüssel auf und fügt ihn mittels eines Punktes (.) mit dem nächsten Key zusammen. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u003ch1\u003e{{ 'TITEL' | translate }}{{ name }}!\u003c/h1\u003e \u003cng-container *ngIf=\"name === 'Dragon Warrior'; else otherName\"\u003e \u003cng-container *ngTemplateOutlet=\"dragonWarrior\"\u003e\u003c/ng-container\u003e \u003c/ng-container\u003e \u003cng-template #dragonWarrior\u003e \u003cp\u003e{{ 'TEXT.DRAGONWARRIOR.WELCOME' | translate }}\u003c/p\u003e \u003cp\u003e{{ 'TEXT.DRAGONWARRIOR.OTHER' | translate }}\u003c/p\u003e \u003c/ng-template\u003e \u003cng-template #otherName\u003e \u003cp\u003e{{ 'TEXT.OTHER' | translate }}\u003c/p\u003e \u003c/ng-template\u003e Anwendungsbeispiele 1 2 3 4 5 6 7 8 // Fügt die Sprachen \"en\" und \"de\" zu den möglichen Sprachen hinzu. this.translateService.addLangs([\"en\", \"de\"]); // Gibt Englisch als standardmässig verwendete Sprache an. this.translateService.setDefaultLang(\"en\"); // Liest die derzeitige im Browser verwendete Sprache aus. const browserLang = translateService.getBrowserLang(); // Prüft, ob die derzeitige im Browser verwendete Sprache englisch oder deutsch entspricht. Entspricht einer der beiden Fälle this.translateService.use(browserLang.match(/en|de/) ? browserLang : \"en\"); ","categories":"","description":"Modul #F6 - Angular - Internationalization\n","excerpt":"Modul #F6 - Angular - Internationalization\n","ref":"/de/docs/03_web/06_angular/03_5_internationalization/","tags":"","title":"Internationalization (i18n)"},{"body":"Ziele Du weisst, wie du in VSCode JavaScript-Code debuggen kannst. Du weisst, wie du in IntelliJ JavaScript-Code debuggen kannst. Wieso ist Debugging wichtig? Es gibt eine Vielzahl von Gründen, warum JavaScript-Anwendungen Fehler enthalten können. Typische Fehler sind zum Beispiel unerwartete Nutzereingaben, Netzwerkprobleme, inkonsistente Daten oder eine fehlerhafte Logik innerhalb des Codes. Debugging kann dazu beitragen, diese Fehler zu identifizieren und zu beseitigen.\nEin weiterer wichtiger Grund, warum Debugging in JavaScript relevant ist, ist, dass JavaScript eine dynamisch typisierte Sprache ist. Das bedeutet, dass Typfehler während der Laufzeit auftreten können, wenn eine Variable unbeabsichtigt einen anderen Datentyp zugewiesen bekommt, als erwartet. Typfehler können schwer zu finden sein, da sie nicht immer sofort zu offensichtlichen Fehlern, sondern häufig zu unerwartetem Verhalten führen können.\nIst es schlau, für das Debugging console.log() zu verwenden? Die Antwort ist Jein.\nconsole.log() ist eine der gängigsten Methoden, die für das Debuggen verwendet wird, da sie es sehr schnell und einfach ist. Jedoch beeinträchtigen zu viele Logs die Leistung des Codes, was dann zum Problem wird, wenn man beim Pushen in das GIT-Verzeichnis vergisst, die Logs herauszunehmen. So passiert es dann schnell, dass die Konsole mit sinnlosen Logs überfüllt wird. Ausserdem können Logs auch zu Sicherheitsproblemen führen, wenn sensible Daten geloggt werden.\nSomit ist es besser, mit den Tools der jeweiligen IDE zu debuggen.\nDebugging nach alter Schule Es gibt eine Möglichkeit, die immer funktioniert, wenn du JavaScript-Code im Browser debuggen möchtest.\nPraktisch jeder Browser (sogar der Internet Explorer!) bietet Debugging-Tools an.\nMöchtest du an einer bestimmten Stelle im Code einen Breakpoint setzen und die Ausführung pausieren, wenn dieser erreicht ist, dann kannst du das mit folgender Anweisung erreichen:\n1 debugger; Wenn diese Stelle im Code erreicht wird, dann pausiert der Browser automatisch. Je nach Browser musst du hierfür die Entwickler-Tools geöffnet haben.\nIn der Debugging-Ansicht siehst du dann den aktuellen Code:\nFolgende Dinge lassen sich erkennen:\nDas Script ist an der Stelle pausiert, an welcher debugger; steht. Du kannst dir die Werte der Variablen anschauen, indem du mit der Maus darüber stehen bleibst. Hier siehst du zum Beispiel, was in der Variable browser gespeichert ist. Auf der rechten Seite oben kannst du die Ausführung wie gewöhnlich fortsetzen lassen oder Schritt-für-Schritt weiterdebuggen. Weiter unten sind die Breakpoints aufgelistet. Du kannst im Browser direkt weitere Breakpoints hinzufügen, indem du auf eine Zeilennummer klickst. Bei den Breakpoints siehst du auch die Möglichkeit, dass das Script automatisch einen Breakpoint aktivieren soll, wenn ein Fehler geworfen wird (auch wenn er später gecatched wird). Das Schöne an dieser Möglichkeit ist, dass sie praktisch immer funktioniert, egal welches Framework du für deine HTML-Seiten verwendest.\nWenn dir aber deine Entwicklungsumgebung eine Lösung anbietet, dann verwende diese! Verwendest du das debugger-Keyword im Code, so musst du immer wieder daran denken, es vor dem Pushen wieder zu entfernen.\nDebuggen in VSCode HTML-Datei mit JavaScript debuggen (Client-seitig) Möchtest du JavaScript-Code in einer lokalen HTML-Datei debuggen, dann kannst du das wie folgt tun:\nKlicke auf “Run and Debug” im Debugging-Tab:\nDann solltest du gefragt werden, auf welche Art du debuggen möchtest:\nDort wählst du den Browser aus, mit dem du Debuggen möchtest.\nNun ist das Debugging in HTML- und JavaScript-Dateien möglich, indem du Breakpoints setzt:\nMöchtest du das Debugging auf Knopfdruck starten? Dann:\nKlicke im “Run and Debug”-Tag auf “create a launch.json file” statt auf “Run and Debug”. Wähle wieder den richtigen Browser aus. In der Datei “.vscode/launch.json” wurde nun eine Konfiguration erstellt. Du kannst sie wie folgt generalisieren:\n1 2 3 4 5 6 7 8 9 10 11 { \"version\": \"0.2.0\", \"configurations\": [ { \"type\": \"msedge\", // bzw. chrome. \"request\": \"launch\", \"name\": \"Open current html\", \"file\": \"${file}\" } ] } Wenn du nun deine Datei ausgewählt hast und [F5] klickst, wird automatisch ein Browser geöffnet, der die aktuelle Seite im Browser anzeigt. Ausserdem sollten alle Breakpoints direkt funktionieren.\nDebuggen in VSCode mit LiveServer (Client-seitig) Wenn du die Extension Live Server verwendest, dann muss das Debugging anders konfiguriert werden.\nAls Erstes muss man das launch.json erweitern, denn es muss einen neue Configuration hinzugefügt werden (innerhalb des Arrays configurations).\n1 2 3 4 5 6 7 8 9 10 { \"name\": \"Live Server: Chrome\", \"type\": \"chrome\", \"request\": \"launch\", \"url\": \"http://localhost:5500/${relativeFile}\", \"webRoot\": \"${workspaceFolder}\", \"sourceMapPathOverrides\": { \"webpack:///./src/*\": \"${webRoot}/*\" } } Für Microsoft Edge gibst du natürlich \"type\": \"edge\" an. Achte darauf, dass du den gleichen Port wie der Live Server verwendest. Normalerweise ist das der Port 5500. Es kann aber auch vorkommen, dass sich der Port ändert. Den Port siehst du unten rechts in VS Code (im Beispiel 5501), wenn der Live Server läuft: Nun müssen die gewünschten Breakpoints gesetzt werden, dann kann gestartet werden.\nUm zu Debuggen\nmusst du zuerst den Live Server starten (beispielsweise mit einem Rechtsklick auf die entsprechende HTML-Datei, dann “Open with Live Server”) Danach beim Debuggen den Eintrag “Live Server: Chrome” im Dropdown wählen und mit dem sich daneben befindenden grünen Startbutton das Gesamte starten. Man kann jedoch auch nur im Dropdown das Gewollte auswählen und mit F5 starten: Es öffnet sich ein Chrome Fenster mit den Ordnern, wo man dann in das gewollte File navigieren kann. Wird nun eine Aktion ausgeführt, die einen Breakpoint beinhält, kann man wie gewohnt Debuggen.\nJavaScript-Dateien mit NodeJS (Server-seitig) debuggen Damit man in VSCode Server-seitigen JavaScript-Code mit NodeJS debuggen kann, muss man zuerst eine Datei launch.json erstellen. Das geht am besten, indem man rechts in der Menüleiste auf das vierte Icon klickt:\nMan muss natürlich auch den Debugger wählen, den man verwenden möchte: Nun muss man den Code im launch.json mit dem folgenden ersetzen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 { \"version\": \"0.2.0\", \"configurations\": [ { \"type\": \"node\", \"request\": \"launch\", \"name\": \"Launch Program\", \"skipFiles\": [\"\u003cnode_internals\u003e/**\"], \"program\": \"${file}\", \"cwd\": \"${workspaceFolder}\" } ] } Jetzt kann man den Debugger mittels F5 starten.\nDamit dieser jedoch etwas bringt, muss man auch Breakpoints setzen. Dafür kann man links neben der Zeilenzahl mittels Links-Klick einen normalen Breakpoint setzen oder mit Rechts-Klick die Optionen ansehen:\nBreakpoints Die Optionen zeigen die folgenden drei Breakpoints:\nBreakpoints: Normale Breakpoints sind die am häufigsten verwendeten. Sie ermöglichen es, den Programmfluss an einer bestimmten Stelle zu unterbrechen und den Code schrittweise zu debuggen. Logpoints: Logpoints ermöglichen es, während des Debuggings eine Nachricht in der Konsole auszugeben, ohne den Programmfluss zu unterbrechen. Conditional Breakpoints: Conditional Breakpoints ermöglichen es, einen Breakpoint zu setzen, der nur unter bestimmten Bedingungen ausgelöst wird. Setzt man einen Logpoint oder Conditional Breakpoint, kann man im Dropdown noch zwei weitere auswählen.\nException Breakpoints: Exception Breakpoints ermöglichen es, den Programmfluss an der Stelle zu unterbrechen, an der eine Ausnahme (Exception) auftritt. Hit count breakpoint: Hit count Breakpoints ermöglichen es, den Code an einer bestimmten Stelle zu unterbrechen, wenn eine bestimmte Bedingung erfüllt ist. Der “Hit count” bezieht sich dabei auf die Anzahl der Male, die dieser Breakpoint erreicht wurde. Wenn man im Debug-Modus ist, kann man links ein Panel mit drei Unterteilungen sehen:\nWatch: Die “Watch”-Funktion ermöglicht es, die Werte von Variablen, Objekten und Ausdrücken in Echtzeit zu überwachen. Man kann Variablen hinzufügen, um ihre Werte zu verfolgen und sie zu überprüfen, während man durch den Code geht. Das ist besonders nützlich, wenn man einen Fehler vermutet und den Wert einer bestimmten Variable überprüfen möchte. Call Stack: Die “Call Stack”-Funktion zeigt die Aufrufliste der Codezeilen an. Man kann sehen, welche Funktionen in welcher Reihenfolge aufgerufen wurden. Das ist hilfreich, um zu verstehen, wie der Code funktioniert und wo Fehler auftreten können. Man kann auch zurückgehen und zu einem bestimmten Punkt in der Liste springen, um den Code von diesem Punkt aus zu überprüfen. Variables: Die “Variables”-Funktion zeigt eine Liste der Variablen an, die im aktuellen Kontext verfügbar sind. Man kann den Wert jeder Variable überprüfen und sie ändern, um zu sehen, wie sich der Code verhält. Diese Funktion ist besonders nützlich, wenn man eine Variable suchen und ihren Wert überprüfen muss, um einen Fehler zu finden. Die Debugging Actions Die Debugging Actions sind wichtig für die Navigation während des Debuggings. Die Icons auf dem folgenden Bild werden darunter von links nach rechts erklärt:\nFortsetzen/Pause (F5): Fortsetzen: Setzt die normale Programm- oder Skriptausführung fort (bis zum nächsten Breakpoint). Pause: Ermöglicht die Inspektion des Codes, der gerade ausgeführt wird.\nSchritt über (F10): Führt die nächste Anweisung aus, ohne ihre Bestandteile zu inspizieren.\nSchritt in (F11): Betritt die nächste Methode, um ihre Ausführung Zeile für Zeile zu verfolgen.\nSchritt zurück (⇧F11): Wenn man sich innerhalb einer Methode oder Unterprozedur befinden, kehrt man zum früheren Ausführungskontext zurück, indem man die verbleibenden Zeilen der aktuellen Methode als einzelnen Befehl ausführt.\nNeu starten (Ctr+⇧+F5 bzw. ⇧⌘F5): Beendet die aktuelle Programmausführung und startet das Debuggen erneut mit der aktuellen Ausführungskonfiguration.\nStoppen (⇧F5): Beendet die aktuelle Programmausführung.\nDie Debugging-Konsole Während des Debuggings bietet VS Code die Debugging-Konsole an:\nHier erscheinen die gleichen Logs wie in der Browser-Konsole. Ausserdem kannst du hier auch Ausdrücke testen (ob z.B. browser.includes(\"Chrome\") wahr ist) und Code ausführen lassen.\nIm Zusammenhang mit dem Browser klingt das vielleicht sehr unspektakulär, ist aber enorm praktisch, wenn du eine server-seitige Anwendung (Backend) mit NodeJS, Java, Python oder etwas Ähnlichem laufen lässt.\nDebuggen in IntelliJ Um in IntelliJ zu debuggen, muss man nicht zuerst ein File erstellen oder eine Extension installieren. Es reicht bereits, wenn man die Breakpoints setzt. Dafür kann man, wie bei VSCode, links neben der Zeilenzahl mittels Links-Klick einen normalen Breakpoint setzen oder mit Rechts-Klick die Optionen ansehen:\nHier gibt es neben dem normalen Breakpoint den Conditional Breakpoint. Dieser wird gleich verwendet wie in VSCode.\nHier gibt es dann die Möglichkeit, noch mehr Optionen auszuwählen. Dazu muss man auf more klicken, worauf sich ein Popup öffnet.\nHier kann man, wie bei VSCode, einen Log erstellen. Der Breakpoint ist verhält sich nun gleich wie ein Logpoint in VS Code. Man kann auch einstellen, dass der Breakpoint entfernt werden soll, sobald er einmal aufgerufen wurde, oder dass er so lange inaktiv sein soll, bis ein anderer Breakpoint ausgelöst wurde.\nUm den Debug-Modus zu starten, kann man in IntelliJ oben rechts das Icon, das wie ein Käfer aussieht, verwenden:\nDas Debugging-Panel unten auf der Benutzeroberfläche besitzt verschiedene nützliche Tools:\nDebugger Controls Debug Console Frames Variables Watches Debugger Controls: Rerun: Dieser Button startet das Programm im Debug-Modus neu.\nStop: Mit diesem Button stoppt man den Debug-Modus.\nPause: Dieser Button unterbricht den Programmablauf und hält den Debugger an. Man benutzt ihn, um das Programm zu pausieren und den aktuellen Zustand der Variablen und Objekte zu überprüfen.\nResume Program: Mit diesem Button kann man das Programm im Debug-Modus fortsetzen, nachdem es unterbrochen wurde.\nStep Over: Dieser Button führt das aktuelle Statement im Code aus und hält an der nächsten Zeile an. Wenn das Statement eine Methode aufruft, wird die Methode ausgeführt und der Debugger hält an der nächsten Zeile an.\nStep Into: Diese Schaltfläche führt das aktuelle Statement im Code aus und hält an der nächsten Zeile an. Wenn das Statement eine Methode aufruft, wird der Debugger in die Methode hineinspringen und an der ersten Zeile der Methode anhalten.\nStep Out: Mit dieser Schaltfläche kann man aus einer Methode heraus zurückkehren und den Debugger an der nächsten Zeile nach der Methode anhalten.\nView Breakpoints: Mit diesem Button kann man alle Breakpoints anzeigen und konfigurieren, einschliesslich Bedingungen und Aktionen, die bei der Unterbrechung ausgelöst werden sollen.\nMute Breakpoints: Mit diesem Button kann man alle Breakpoints stumm schalten, ohne sie entfernen zu müssen. Das ist nützlich, wenn man schnell durch den Code navigieren möchte, ohne dass der Debugger bei jedem Breakpoint stoppt.\nDebug Console: Hier kann man interaktiv mit dem Code interagieren, indem man JS-Befehle eingibt und die jeweilige Ausgabe sieht. Man kann auch Fehlermeldungen oder Ausnahmen sehen, die während der Ausführung des Codes auftreten.\nFrames: In diesem Bereich werden die Stack-Frames angezeigt, die den aktuellen Programmablauf darstellen. Man kann durch die Frames navigieren, indem man auf den Namen des Frames klickt. Ein Stack Frame ist ein “Stapel”, der die zur Laufzeit des Programms gerade aufgerufenen Unterprogramme enthält.\nVariables: Hier kann man die Werte von Variablen während des Debugging-Prozesses überwachen. Man kann die Variablen auswählen, um ihre aktuellen Werte anzuzeigen, oder man kann Ausdrücke eingeben, um ihre Werte zu berechnen.\nWatches: Man kann eine Liste von Variablen erstellen, die man überwachen möchte. Man kann Variablen zur Watchlist hinzufügen, indem man mit der rechten Maustaste auf die Variable klickt und “Add to Watches” auswählt. Die Variable kann man auch im Input-Feld eingeben und auf das Plus-Icon am Ende klicken, um sie in die Watchlist hinzuzufügen:\nDie Watches werden dann über den Variablen aufgelistet:\nGenau wie beim Hinzufügen kann man einen Watcher auch entfernen, indem man einen rechten Mausklick auf die Variable tätigt und “Remove Watch” anklickt.\n","categories":"","description":"Modul #F4 - JavaScript - Debugging ist in jeder Programmiersprache wichtig und die IDE hat dazu viele nützliche Tools, welche hier angeschaut werden.\n","excerpt":"Modul #F4 - JavaScript - Debugging ist in jeder Programmiersprache …","ref":"/docs/03_web/03_javascript/24_debugging/","tags":"","title":"Debugging"},{"body":"Ziele Du weisst, wie du in VSCode JavaScript-Code debuggen kannst. Du weisst, wie du in IntelliJ JavaScript-Code debuggen kannst. Wieso ist Debugging wichtig? Es gibt eine Vielzahl von Gründen, warum JavaScript-Anwendungen Fehler enthalten können. Typische Fehler sind zum Beispiel unerwartete Nutzereingaben, Netzwerkprobleme, inkonsistente Daten oder eine fehlerhafte Logik innerhalb des Codes. Debugging kann dazu beitragen, diese Fehler zu identifizieren und zu beseitigen.\nEin weiterer wichtiger Grund, warum Debugging in JavaScript relevant ist, ist, dass JavaScript eine dynamisch typisierte Sprache ist. Das bedeutet, dass Typfehler während der Laufzeit auftreten können, wenn eine Variable unbeabsichtigt einen anderen Datentyp zugewiesen bekommt, als erwartet. Typfehler können schwer zu finden sein, da sie nicht immer sofort zu offensichtlichen Fehlern, sondern häufig zu unerwartetem Verhalten führen können.\nIst es schlau, für das Debugging console.log() zu verwenden? Die Antwort ist Jein.\nconsole.log() ist eine der gängigsten Methoden, die für das Debuggen verwendet wird, da sie es sehr schnell und einfach ist. Jedoch beeinträchtigen zu viele Logs die Leistung des Codes, was dann zum Problem wird, wenn man beim Pushen in das GIT-Verzeichnis vergisst, die Logs herauszunehmen. So passiert es dann schnell, dass die Konsole mit sinnlosen Logs überfüllt wird. Ausserdem können Logs auch zu Sicherheitsproblemen führen, wenn sensible Daten geloggt werden.\nSomit ist es besser, mit den Tools der jeweiligen IDE zu debuggen.\nDebugging nach alter Schule Es gibt eine Möglichkeit, die immer funktioniert, wenn du JavaScript-Code im Browser debuggen möchtest.\nPraktisch jeder Browser (sogar der Internet Explorer!) bietet Debugging-Tools an.\nMöchtest du an einer bestimmten Stelle im Code einen Breakpoint setzen und die Ausführung pausieren, wenn dieser erreicht ist, dann kannst du das mit folgender Anweisung erreichen:\n1 debugger; Wenn diese Stelle im Code erreicht wird, dann pausiert der Browser automatisch. Je nach Browser musst du hierfür die Entwickler-Tools geöffnet haben.\nIn der Debugging-Ansicht siehst du dann den aktuellen Code:\nFolgende Dinge lassen sich erkennen:\nDas Script ist an der Stelle pausiert, an welcher debugger; steht. Du kannst dir die Werte der Variablen anschauen, indem du mit der Maus darüber stehen bleibst. Hier siehst du zum Beispiel, was in der Variable browser gespeichert ist. Auf der rechten Seite oben kannst du die Ausführung wie gewöhnlich fortsetzen lassen oder Schritt-für-Schritt weiterdebuggen. Weiter unten sind die Breakpoints aufgelistet. Du kannst im Browser direkt weitere Breakpoints hinzufügen, indem du auf eine Zeilennummer klickst. Bei den Breakpoints siehst du auch die Möglichkeit, dass das Script automatisch einen Breakpoint aktivieren soll, wenn ein Fehler geworfen wird (auch wenn er später gecatched wird). Das Schöne an dieser Möglichkeit ist, dass sie praktisch immer funktioniert, egal welches Framework du für deine HTML-Seiten verwendest.\nWenn dir aber deine Entwicklungsumgebung eine Lösung anbietet, dann verwende diese! Verwendest du das debugger-Keyword im Code, so musst du immer wieder daran denken, es vor dem Pushen wieder zu entfernen.\nDebuggen in VSCode HTML-Datei mit JavaScript debuggen (Client-seitig) Möchtest du JavaScript-Code in einer lokalen HTML-Datei debuggen, dann kannst du das wie folgt tun:\nKlicke auf “Run and Debug” im Debugging-Tab:\nDann solltest du gefragt werden, auf welche Art du debuggen möchtest:\nDort wählst du den Browser aus, mit dem du Debuggen möchtest.\nNun ist das Debugging in HTML- und JavaScript-Dateien möglich, indem du Breakpoints setzt:\nMöchtest du das Debugging auf Knopfdruck starten? Dann:\nKlicke im “Run and Debug”-Tag auf “create a launch.json file” statt auf “Run and Debug”. Wähle wieder den richtigen Browser aus. In der Datei “.vscode/launch.json” wurde nun eine Konfiguration erstellt. Du kannst sie wie folgt generalisieren:\n1 2 3 4 5 6 7 8 9 10 11 { \"version\": \"0.2.0\", \"configurations\": [ { \"type\": \"msedge\", // bzw. chrome. \"request\": \"launch\", \"name\": \"Open current html\", \"file\": \"${file}\" } ] } Wenn du nun deine Datei ausgewählt hast und [F5] klickst, wird automatisch ein Browser geöffnet, der die aktuelle Seite im Browser anzeigt. Ausserdem sollten alle Breakpoints direkt funktionieren.\nDebuggen in VSCode mit LiveServer (Client-seitig) Wenn du die Extension Live Server verwendest, dann muss das Debugging anders konfiguriert werden.\nAls Erstes muss man das launch.json erweitern, denn es muss einen neue Configuration hinzugefügt werden (innerhalb des Arrays configurations).\n1 2 3 4 5 6 7 8 9 10 { \"name\": \"Live Server: Chrome\", \"type\": \"chrome\", \"request\": \"launch\", \"url\": \"http://localhost:5500/${relativeFile}\", \"webRoot\": \"${workspaceFolder}\", \"sourceMapPathOverrides\": { \"webpack:///./src/*\": \"${webRoot}/*\" } } Für Microsoft Edge gibst du natürlich \"type\": \"edge\" an. Achte darauf, dass du den gleichen Port wie der Live Server verwendest. Normalerweise ist das der Port 5500. Es kann aber auch vorkommen, dass sich der Port ändert. Den Port siehst du unten rechts in VS Code (im Beispiel 5501), wenn der Live Server läuft: Nun müssen die gewünschten Breakpoints gesetzt werden, dann kann gestartet werden.\nUm zu Debuggen\nmusst du zuerst den Live Server starten (beispielsweise mit einem Rechtsklick auf die entsprechende HTML-Datei, dann “Open with Live Server”) Danach beim Debuggen den Eintrag “Live Server: Chrome” im Dropdown wählen und mit dem sich daneben befindenden grünen Startbutton das Gesamte starten. Man kann jedoch auch nur im Dropdown das Gewollte auswählen und mit F5 starten: Es öffnet sich ein Chrome Fenster mit den Ordnern, wo man dann in das gewollte File navigieren kann. Wird nun eine Aktion ausgeführt, die einen Breakpoint beinhält, kann man wie gewohnt Debuggen.\nJavaScript-Dateien mit NodeJS (Server-seitig) debuggen Damit man in VSCode Server-seitigen JavaScript-Code mit NodeJS debuggen kann, muss man zuerst eine Datei launch.json erstellen. Das geht am besten, indem man rechts in der Menüleiste auf das vierte Icon klickt:\nMan muss natürlich auch den Debugger wählen, den man verwenden möchte: Nun muss man den Code im launch.json mit dem folgenden ersetzen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 { \"version\": \"0.2.0\", \"configurations\": [ { \"type\": \"node\", \"request\": \"launch\", \"name\": \"Launch Program\", \"skipFiles\": [\"\u003cnode_internals\u003e/**\"], \"program\": \"${file}\", \"cwd\": \"${workspaceFolder}\" } ] } Jetzt kann man den Debugger mittels F5 starten.\nDamit dieser jedoch etwas bringt, muss man auch Breakpoints setzen. Dafür kann man links neben der Zeilenzahl mittels Links-Klick einen normalen Breakpoint setzen oder mit Rechts-Klick die Optionen ansehen:\nBreakpoints Die Optionen zeigen die folgenden drei Breakpoints:\nBreakpoints: Normale Breakpoints sind die am häufigsten verwendeten. Sie ermöglichen es, den Programmfluss an einer bestimmten Stelle zu unterbrechen und den Code schrittweise zu debuggen. Logpoints: Logpoints ermöglichen es, während des Debuggings eine Nachricht in der Konsole auszugeben, ohne den Programmfluss zu unterbrechen. Conditional Breakpoints: Conditional Breakpoints ermöglichen es, einen Breakpoint zu setzen, der nur unter bestimmten Bedingungen ausgelöst wird. Setzt man einen Logpoint oder Conditional Breakpoint, kann man im Dropdown noch zwei weitere auswählen.\nException Breakpoints: Exception Breakpoints ermöglichen es, den Programmfluss an der Stelle zu unterbrechen, an der eine Ausnahme (Exception) auftritt. Hit count breakpoint: Hit count Breakpoints ermöglichen es, den Code an einer bestimmten Stelle zu unterbrechen, wenn eine bestimmte Bedingung erfüllt ist. Der “Hit count” bezieht sich dabei auf die Anzahl der Male, die dieser Breakpoint erreicht wurde. Wenn man im Debug-Modus ist, kann man links ein Panel mit drei Unterteilungen sehen:\nWatch: Die “Watch”-Funktion ermöglicht es, die Werte von Variablen, Objekten und Ausdrücken in Echtzeit zu überwachen. Man kann Variablen hinzufügen, um ihre Werte zu verfolgen und sie zu überprüfen, während man durch den Code geht. Das ist besonders nützlich, wenn man einen Fehler vermutet und den Wert einer bestimmten Variable überprüfen möchte. Call Stack: Die “Call Stack”-Funktion zeigt die Aufrufliste der Codezeilen an. Man kann sehen, welche Funktionen in welcher Reihenfolge aufgerufen wurden. Das ist hilfreich, um zu verstehen, wie der Code funktioniert und wo Fehler auftreten können. Man kann auch zurückgehen und zu einem bestimmten Punkt in der Liste springen, um den Code von diesem Punkt aus zu überprüfen. Variables: Die “Variables”-Funktion zeigt eine Liste der Variablen an, die im aktuellen Kontext verfügbar sind. Man kann den Wert jeder Variable überprüfen und sie ändern, um zu sehen, wie sich der Code verhält. Diese Funktion ist besonders nützlich, wenn man eine Variable suchen und ihren Wert überprüfen muss, um einen Fehler zu finden. Die Debugging Actions Die Debugging Actions sind wichtig für die Navigation während des Debuggings. Die Icons auf dem folgenden Bild werden darunter von links nach rechts erklärt:\nFortsetzen/Pause (F5): Fortsetzen: Setzt die normale Programm- oder Skriptausführung fort (bis zum nächsten Breakpoint). Pause: Ermöglicht die Inspektion des Codes, der gerade ausgeführt wird.\nSchritt über (F10): Führt die nächste Anweisung aus, ohne ihre Bestandteile zu inspizieren.\nSchritt in (F11): Betritt die nächste Methode, um ihre Ausführung Zeile für Zeile zu verfolgen.\nSchritt zurück (⇧F11): Wenn man sich innerhalb einer Methode oder Unterprozedur befinden, kehrt man zum früheren Ausführungskontext zurück, indem man die verbleibenden Zeilen der aktuellen Methode als einzelnen Befehl ausführt.\nNeu starten (Ctr+⇧+F5 bzw. ⇧⌘F5): Beendet die aktuelle Programmausführung und startet das Debuggen erneut mit der aktuellen Ausführungskonfiguration.\nStoppen (⇧F5): Beendet die aktuelle Programmausführung.\nDie Debugging-Konsole Während des Debuggings bietet VS Code die Debugging-Konsole an:\nHier erscheinen die gleichen Logs wie in der Browser-Konsole. Ausserdem kannst du hier auch Ausdrücke testen (ob z.B. browser.includes(\"Chrome\") wahr ist) und Code ausführen lassen.\nIm Zusammenhang mit dem Browser klingt das vielleicht sehr unspektakulär, ist aber enorm praktisch, wenn du eine server-seitige Anwendung (Backend) mit NodeJS, Java, Python oder etwas Ähnlichem laufen lässt.\nDebuggen in IntelliJ Um in IntelliJ zu debuggen, muss man nicht zuerst ein File erstellen oder eine Extension installieren. Es reicht bereits, wenn man die Breakpoints setzt. Dafür kann man, wie bei VSCode, links neben der Zeilenzahl mittels Links-Klick einen normalen Breakpoint setzen oder mit Rechts-Klick die Optionen ansehen:\nHier gibt es neben dem normalen Breakpoint den Conditional Breakpoint. Dieser wird gleich verwendet wie in VSCode.\nHier gibt es dann die Möglichkeit, noch mehr Optionen auszuwählen. Dazu muss man auf more klicken, worauf sich ein Popup öffnet.\nHier kann man, wie bei VSCode, einen Log erstellen. Der Breakpoint ist verhält sich nun gleich wie ein Logpoint in VS Code. Man kann auch einstellen, dass der Breakpoint entfernt werden soll, sobald er einmal aufgerufen wurde, oder dass er so lange inaktiv sein soll, bis ein anderer Breakpoint ausgelöst wurde.\nUm den Debug-Modus zu starten, kann man in IntelliJ oben rechts das Icon, das wie ein Käfer aussieht, verwenden:\nDas Debugging-Panel unten auf der Benutzeroberfläche besitzt verschiedene nützliche Tools:\nDebugger Controls Debug Console Frames Variables Watches Debugger Controls: Rerun: Dieser Button startet das Programm im Debug-Modus neu.\nStop: Mit diesem Button stoppt man den Debug-Modus.\nPause: Dieser Button unterbricht den Programmablauf und hält den Debugger an. Man benutzt ihn, um das Programm zu pausieren und den aktuellen Zustand der Variablen und Objekte zu überprüfen.\nResume Program: Mit diesem Button kann man das Programm im Debug-Modus fortsetzen, nachdem es unterbrochen wurde.\nStep Over: Dieser Button führt das aktuelle Statement im Code aus und hält an der nächsten Zeile an. Wenn das Statement eine Methode aufruft, wird die Methode ausgeführt und der Debugger hält an der nächsten Zeile an.\nStep Into: Diese Schaltfläche führt das aktuelle Statement im Code aus und hält an der nächsten Zeile an. Wenn das Statement eine Methode aufruft, wird der Debugger in die Methode hineinspringen und an der ersten Zeile der Methode anhalten.\nStep Out: Mit dieser Schaltfläche kann man aus einer Methode heraus zurückkehren und den Debugger an der nächsten Zeile nach der Methode anhalten.\nView Breakpoints: Mit diesem Button kann man alle Breakpoints anzeigen und konfigurieren, einschliesslich Bedingungen und Aktionen, die bei der Unterbrechung ausgelöst werden sollen.\nMute Breakpoints: Mit diesem Button kann man alle Breakpoints stumm schalten, ohne sie entfernen zu müssen. Das ist nützlich, wenn man schnell durch den Code navigieren möchte, ohne dass der Debugger bei jedem Breakpoint stoppt.\nDebug Console: Hier kann man interaktiv mit dem Code interagieren, indem man JS-Befehle eingibt und die jeweilige Ausgabe sieht. Man kann auch Fehlermeldungen oder Ausnahmen sehen, die während der Ausführung des Codes auftreten.\nFrames: In diesem Bereich werden die Stack-Frames angezeigt, die den aktuellen Programmablauf darstellen. Man kann durch die Frames navigieren, indem man auf den Namen des Frames klickt. Ein Stack Frame ist ein “Stapel”, der die zur Laufzeit des Programms gerade aufgerufenen Unterprogramme enthält.\nVariables: Hier kann man die Werte von Variablen während des Debugging-Prozesses überwachen. Man kann die Variablen auswählen, um ihre aktuellen Werte anzuzeigen, oder man kann Ausdrücke eingeben, um ihre Werte zu berechnen.\nWatches: Man kann eine Liste von Variablen erstellen, die man überwachen möchte. Man kann Variablen zur Watchlist hinzufügen, indem man mit der rechten Maustaste auf die Variable klickt und “Add to Watches” auswählt. Die Variable kann man auch im Input-Feld eingeben und auf das Plus-Icon am Ende klicken, um sie in die Watchlist hinzuzufügen:\nDie Watches werden dann über den Variablen aufgelistet:\nGenau wie beim Hinzufügen kann man einen Watcher auch entfernen, indem man einen rechten Mausklick auf die Variable tätigt und “Remove Watch” anklickt.\n","categories":"","description":"Modul #F4 - JavaScript - Debugging ist in jeder Programmiersprache wichtig und die IDE hat dazu viele nützliche Tools, welche hier angeschaut werden.\n","excerpt":"Modul #F4 - JavaScript - Debugging ist in jeder Programmiersprache …","ref":"/de/docs/03_web/03_javascript/24_debugging/","tags":"","title":"Debugging"},{"body":"Ziele Du weisst, was Angular Material ist und wie du es verwendest. Was ist Material Material Design ist eine Designsprache, die für das neue Betriebssystem von Google Android entwickelt wurde, das im Sommer 2014 angekündigt wurde. Obwohl sich Material Design hauptsächlich auf das Touch-Based-Design mobiler Apps konzentriert, ist es möglich, dieselben Ideen in das Webdesign zu übertragen.\nMaterial in Angular Für Angular gibt es eine speziell angefertigte Version von Material Design.\nAuf der offiziellen Website von Angular Material ist einsehbar, welche Components zur Verfügung gestellt werden.\nWenn wir zum Beispiel den MatSlider in unsere Applikation implementieren möchten, gibt es einige Schritte, welche wir beachten müssen. Jeder Component wird auf der Website von Material wie folgt beschrieben:\nOverview: Auf der Übersicht wird beschrieben, wie und wozu man den Component anwenden kann. Oftmals werden hier auch erweiterte Funktionen eines Components aufgelistet. Daher gilt: Immer aufmerksam durchlesen! Wenn du einen spezifischen Use-Case mit einem Material-Component abdecken möchtest, kannst du so im Vorhinein schon bestimmen, ob der der Component das von dir gewünschte Verhalten / Design umsetzen kann. API: In diesem Abschnitt ist für uns vor allem der Import wichtig. Für jeden Component muss erst das dazugehörige Modul importiert werden: 1 2 3 4 5 6 7 8 9 10 import { MatSliderModule } from '@angular/material/slider'; ... @Component({ selector: 'xyz', templateUrl: 'xyz.html', styleUrl: 'xyz.scss', imports:[ MatSliderModule ] }) Examples: In diesem Abschnitt werden jeweils Anwendungsbeispiele aufgezeigt, von welchen wir unseren Code ableiten können. Das ist insbesondere nützlich, wenn man noch nicht mit dem Component vertraut ist und sich einen Überblick verschaffen möchte, was alles damit umsetzbar ist. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u003cmat-slider class=\"example-margin\" [disabled]=\"disabled\" [invert]=\"invert\" [max]=\"max\" [min]=\"min\" [step]=\"step\" [thumbLabel]=\"thumbLabel\" [tickInterval]=\"getSliderTickInterval()\" [(ngModel)]=\"value\" [vertical]=\"vertical\" aria-labelledby=\"example-name-label\" \u003e \u003c/mat-slider\u003e Wie man Material in seiner Angular-Applikation installiert, wird auf der offiziellen Website ausführlich beschrieben.\nMaterial Theming Material Design unterstützt Theming. Ein Theme ist eine Farbpalette, welche defaultmässig auf jeden Angular Material Component angewendet wird und der App somit ohne grösseren Aufwand einen von Anfang an relativ einheitlichen Look verleiht.\nEin Theme besteht aus:\nEiner Primärfarbe Einer Akzentfarbe Einer Farbe für Warnungen Einer Farbe für den Vordergrund Einer Farbe für den Hintergrund Es gibt verschiedene pre-built Themes in Material Design, sodass man sich das Erstellen eines Themes von Hand ersparen kann:\ndeeppurple-amber.css indigo-pink.css pink-bluegrey.css purple-green.css Um ein solches Theme zu verwenden, müssen wir dies in unserem globalen Stylesheet importieren:\n1 @import '@angular/material/prebuilt-themes/deeppurple-amber.css'; Bei der ersten Installation von Material wird man bereits gefragt, ob man ein Theme für seine App haben möchte. Insofern bei der Installation also bereits ein Theme ausgewählt wurde, kann man sich den obenstehenden Schritt sparen.\nNatürlich kann man auch sein eigene Theme für Angular Material erstellen. Wie ihr dies machen könnt, wird hier ausführlich beschrieben (Für diejenigen, die mit den Übungen frühzeitig fertig sind).\n","categories":"","description":"Modul #F6 - Angular - Angular Material\n","excerpt":"Modul #F6 - Angular - Angular Material\n","ref":"/docs/03_web/06_angular/04_1_material/","tags":"","title":"Angular Material, Responsive Web Design und Accessibility"},{"body":"Ziele Du weisst, was Angular Material ist und wie du es verwendest. Was ist Material Material Design ist eine Designsprache, die für das neue Betriebssystem von Google Android entwickelt wurde, das im Sommer 2014 angekündigt wurde. Obwohl sich Material Design hauptsächlich auf das Touch-Based-Design mobiler Apps konzentriert, ist es möglich, dieselben Ideen in das Webdesign zu übertragen.\nMaterial in Angular Für Angular gibt es eine speziell angefertigte Version von Material Design.\nAuf der offiziellen Website von Angular Material ist einsehbar, welche Components zur Verfügung gestellt werden.\nWenn wir zum Beispiel den MatSlider in unsere Applikation implementieren möchten, gibt es einige Schritte, welche wir beachten müssen. Jeder Component wird auf der Website von Material wie folgt beschrieben:\nOverview: Auf der Übersicht wird beschrieben, wie und wozu man den Component anwenden kann. Oftmals werden hier auch erweiterte Funktionen eines Components aufgelistet. Daher gilt: Immer aufmerksam durchlesen! Wenn du einen spezifischen Use-Case mit einem Material-Component abdecken möchtest, kannst du so im Vorhinein schon bestimmen, ob der der Component das von dir gewünschte Verhalten / Design umsetzen kann. API: In diesem Abschnitt ist für uns vor allem der Import wichtig. Für jeden Component muss erst das dazugehörige Modul importiert werden: 1 2 3 4 5 6 7 8 9 10 import { MatSliderModule } from '@angular/material/slider'; ... @Component({ selector: 'xyz', templateUrl: 'xyz.html', styleUrl: 'xyz.scss', imports:[ MatSliderModule ] }) Examples: In diesem Abschnitt werden jeweils Anwendungsbeispiele aufgezeigt, von welchen wir unseren Code ableiten können. Das ist insbesondere nützlich, wenn man noch nicht mit dem Component vertraut ist und sich einen Überblick verschaffen möchte, was alles damit umsetzbar ist. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u003cmat-slider class=\"example-margin\" [disabled]=\"disabled\" [invert]=\"invert\" [max]=\"max\" [min]=\"min\" [step]=\"step\" [thumbLabel]=\"thumbLabel\" [tickInterval]=\"getSliderTickInterval()\" [(ngModel)]=\"value\" [vertical]=\"vertical\" aria-labelledby=\"example-name-label\" \u003e \u003c/mat-slider\u003e Wie man Material in seiner Angular-Applikation installiert, wird auf der offiziellen Website ausführlich beschrieben.\nMaterial Theming Material Design unterstützt Theming. Ein Theme ist eine Farbpalette, welche defaultmässig auf jeden Angular Material Component angewendet wird und der App somit ohne grösseren Aufwand einen von Anfang an relativ einheitlichen Look verleiht.\nEin Theme besteht aus:\nEiner Primärfarbe Einer Akzentfarbe Einer Farbe für Warnungen Einer Farbe für den Vordergrund Einer Farbe für den Hintergrund Es gibt verschiedene pre-built Themes in Material Design, sodass man sich das Erstellen eines Themes von Hand ersparen kann:\ndeeppurple-amber.css indigo-pink.css pink-bluegrey.css purple-green.css Um ein solches Theme zu verwenden, müssen wir dies in unserem globalen Stylesheet importieren:\n1 @import '@angular/material/prebuilt-themes/deeppurple-amber.css'; Bei der ersten Installation von Material wird man bereits gefragt, ob man ein Theme für seine App haben möchte. Insofern bei der Installation also bereits ein Theme ausgewählt wurde, kann man sich den obenstehenden Schritt sparen.\nNatürlich kann man auch sein eigene Theme für Angular Material erstellen. Wie ihr dies machen könnt, wird hier ausführlich beschrieben (Für diejenigen, die mit den Übungen frühzeitig fertig sind).\n","categories":"","description":"Modul #F6 - Angular - Angular Material\n","excerpt":"Modul #F6 - Angular - Angular Material\n","ref":"/de/docs/03_web/06_angular/04_1_material/","tags":"","title":"Angular Material, Responsive Web Design und Accessibility"},{"body":"Ziele Du weisst, was Angular Lyne ist und wo du Informationen zu den Components finden kannst. Du weisst, wie du Lyne in einem Angular-Projekt integrieren kannst. Du weisst, wie man Lyne in einem Angular-Projekt einbindet. Was ist Angular Lyne? Angular Lyne ist ein von der SBB entworfenes und gepflegtes Design System, womit Lyne mit Material vergleichbar, aber nicht gleichzusetzen ist. Das System wurde entworfen, um SBB-weit eine konsistente und wartbare Designsprache um ein besseres Verständnis innerhalb der verschiedenen Anspruchsgruppen (Entwickler, Stakeholder etc.) zu gewährleisten.\nDie weiter oben verlinkte Dokumentation wird als “the Single Source of Truth” - also die einzige Quelle der Wahrheit behandelt. Das heisst konkret, dass alle Guidelines, Designentscheidungen, Baublöcke (=Einzelkomponenten) und weiteres auf der Seite zu finden sind.\nEinige Vorteile von Lyne umfassen:\nEs ist eine einzelne, firmenweit genutzte Sprache für Design Eine klare, optimisierte Kollaboration wird durch bspw. klare Feedbackmechanismen gewährleistet Lyne und die einzelnen Komponenten durchlaufen jeweils einen soliden Testprozess, was das Risiko von potenziell entstehenden Fehlern minimiert. Es wird ein Fokus auf eine langfristige Nutzung gelegt, was zukünftige Refactorings unwahrscheinlich macht. Und viele weitere. Es gibt aber auch ein paar Risiken, welche von Seiten des Lyne-Teams klar kommuniziert werden:\nLyne stellt einen “Single Point of Failure” dar. Wenn das Design-System ausfällt, betrifft das viele andere Projekte. Es besteht Potenzial, aufgrund der vorgegebenen Komponenten die Kreativität des Designers einzuschränken. Da die Dokumentation den Single Point of Truth darstellt, besteht das Risiko, dass stellenweise Informationen fehlen. Wie integriere ich Lyne in ein Angular-Projekt? Man kann Lyne in drei verschiedene Arten von Projekten einbinden:\nProjekte, die pures Javascript nutzen Projekte, die Angular nutzen Projekte, die React / Next.js nutzen Im Rahmen dieser Dokumentation fokussieren wir uns ausschliesslich auf die Einbindung in ein Angular-Projekt. Möchtest du aber sehen, wie man Lyne in eine der anderen beiden Projektarten einbindet, kannst du das auf der Getting Started-Page von Lyne nachlesen.\nFür diese Anleitung gilt es als Voraussetzung, dass die Angular CLI installiert ist und bereits ein Angular-Projekt besteht. (Vorzugsweise ein leeres, um Konflikte zu vermeiden) Um Lyne in ein Angular-Projekt einzubinden, gilt es, den folgenden Schritten zu folgen:\nInstalliere mit dem folgenden Befehl über die Konsole das @sbb-esta/lyne-elements-Package: 1 npm install --save @sbb-esta/lyne-elements Es wird vom Lyne-Team schärfstens empfohlen, die global styles zu inkludieren. Das kannst du tun, indem du die folgende Anpassung im styles-Tag in der angular.json-Datei vornimmst: 1 2 3 4 5 6 ... \"styles\": [ \"src/styles.scss\", \"node_modules/@sbb-esta/lyne-elements/standard-theme.css\" ], ... Um die Web-Components in Angular zu nutzen, musst du zuletzt noch das CUSTOM_ELEMENT_SCHEMA aus dem @angular/core-Package im AppComponent importieren: 1 2 3 4 5 6 7 8 9 10 11 import { CUSTOM_ELEMENTS_SCHEMA, Component } from \"@angular/core\"; import \"@sbb-esta/lyne-elements/button.js\"; @Component({ selector: \"lyne-app\", standalone: true, schemas: [CUSTOM_ELEMENTS_SCHEMA], template: ` \u003csbb-button\u003eLorem ipsum\u003c/sbb-button\u003e `, }) export class App {} Wie nutze ich Lyne in meinem Projekt? Im Rahmen dieses Abschnitts sollen exemplarisch einige wichtige Aspekte beleuchtet werden, die beim Styling mit Lyne gut zu wissen sind.\nCSS-Dateien Die von Lyne genutzten Styles befinden sich grundsätzlich alle in der standard-theme.css-Datei, welche nach der Integration von Lyne bereits im Projekt vorhanden sein sollten.\nMöchtest du aber beispielsweise spezifischer aussuchen, welche Styles du genau brauchen möchtest, gibt es grundsätzlich folgende Dateien, welche von Lyne bereitgestellt werden:\nDateiname Beschreibung standard-theme.css Beinhält normalizing, core styles und alle verfügbaren CSS-Klassen. font-characters-extension.css Beinhält das gesamte Character-Set für die SBB-Font. normalize.css Beinhält grundlegende Styles, die die defaultmässigen Browser-Styles resetten. core.css Beinhält nötige Basics, um die Lyne-Komponenten nutzen zu können. (Bspw. Design Tokens) a11y.css Stellt CSS-Klassen bereit, welche der Accesibility dienen. animation.css Stellt CSS-KLassen bereit, die Animation deaktivieren. (Bspw. nützlich für Testing) layout.css Stellt CSS-KLassen bereit, die dem Layouting dienen. (Bspw. page-spacing, grid, etc.) lists.css Stellt CSS-Klassen bereit, die für das Styling von Listen gebraucht werden. scrollbar.css Stellt CSS-Klassen bereit, die für das Styling der Scrollbar gebraucht werden. table.css Stellt CSS-Klassen bereit, die für das Styling von Tabellen gebraucht werden. typography.css Stellt CSS-Klassen bereit, die für die Typographie gebraucht werden. Lean variant Es ist möglich, mit Lyne Komponenten automatisch den kleinsten möglichen size-Wert annehmen zu lassen, um ohne viel Aufwand ein kompaktes Design zu ermöglichen. Wichtig dabei zu beachten ist, dass das jeweils nur bei Komponenten funktioniert, die auch ein size-Property besitzen. Um den “lean mode” zu aktivieren, muss lediglich die CSS-Klasse sbb-lean zum html-Tag hinzugefügt werden:\n1 2 3 4 5 6 7 8 \u003chtml lang=\"en\" class=\"sbb-lean\"\u003e \u003chead\u003e \u003ctitle\u003eLean example\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e ... \u003c/body\u003e \u003c/html\u003e Full Font Die standard-theme.css-Datei beinhält ein Subset der SBB-Fonts, welche nicht alle Zeichen beinhält. Um die Fonts mit den fehlenden Zeichensätzen zu ergänzen, muss die font-characters-extension.css-Datei in der Datei styles.css importiert werden. Wichtig: Der Import muss direkt nach dem Import der standard-theme.css-Datei gemacht werden:\n1 2 @import \"@sbb-esta/lyne-elements/standard-theme.css\"; @import \"@sbb-esta/lyne-elements/font-characters-extension.css\"; CSS-Klassen Grundsätzlich sind die von Lyne bereitgestellten Styles in den Components. Es ist aber dennoch möglich, dass man in spezifischen Fällen die Styles von Components überschreiben möchte. Um das zu bewerkstelligen, können die CSS Variablen eines Components verwendet werden. Die spezifischen Variablen, die man anpassen kann, sind in der Dokumentation des jeweiligen Lyne-Components einsehbar.\nAnimations Animations gehören grundsätzlich zum von Lyne vorgesehenen Design und sollten nicht unterdrückt / deaktiviert werden, es kann aber für das Testing stellenweise dennoch nützlich sein, die Animationen (zeitweise) zu deaktivieren. Um die Animationen für ein Element zu deaktivieren, kann die CSS-Klasse sbb-disable-animations zum Element hinzugefügt werden. Wenn nur für ein übergreifendes Element (bspw. einen Wrapper) die Animation deaktiviert werden soll, kann die CSS-Klasse sbb-disable-animations-locally verwendet werden. Es ist ebenfalls möglich, die Animationen des Parent-Elements mit sbb-disable-animations zu deaktivieren und die der Child-Components mit sbb-enable-animations zu aktivieren, was dasselbe bewerkstelligt:\n1 2 3 4 5 6 7 8 9 10 11 \u003csbb-component class=\"sbb-disable-animation-locally\"\u003e \u003c!-- animations will play --\u003e \u003c/sbb-component\u003e \u003c!-- Or alternatively--\u003e \u003csbb-component class=\"sbb-disable-animation\"\u003e \u003csbb-component class=\"sbb-enable-animation\"\u003e \u003c!-- animations will play --\u003e \u003c/sbb-component\u003e \u003c/sbb-component\u003e Masseinheiten Alle Tokens und Components von Lyne verwenden als Masseinheit rem. Damit keine Inkosistenzen beim Design entstehen, wird empfohlen, für den Rest der Applikation ebenfalls rem als Masseinheit zu verwenden.\nFonts Die SBB stellt einige verschiedene Fonts bereit, welche von der font-weight abhängen. Grundsätzlich wird in Lyne zwischen drei Arten von font-weight unterschieden:\nRoman Bold Light Lyne mappt die Fonts automatisch auf das font-weight-Property. Wenn einem Element beispielsweise die Eigenschaft font-weight: bold hinzugefügt wird, wählt Lyne für dieses Element automatisch den korrespondierenden Zeichensatz aus. Die SBB bietet zwar mehr Fonts an, Lyne beschränkt sich aber auf die drei genannten Fonts.\n","categories":"","description":"Modul #F6 - Angular - Angular Lyne\n","excerpt":"Modul #F6 - Angular - Angular Lyne\n","ref":"/docs/03_web/06_angular/04_2_lyne/","tags":"","title":"Angular Lyne - Custom Components der SBB"},{"body":"Ziele Du weisst, was Angular Lyne ist und wo du Informationen zu den Components finden kannst. Du weisst, wie du Lyne in einem Angular-Projekt integrieren kannst. Du weisst, wie man Lyne in einem Angular-Projekt einbindet. Was ist Angular Lyne? Angular Lyne ist ein von der SBB entworfenes und gepflegtes Design System, womit Lyne mit Material vergleichbar, aber nicht gleichzusetzen ist. Das System wurde entworfen, um SBB-weit eine konsistente und wartbare Designsprache um ein besseres Verständnis innerhalb der verschiedenen Anspruchsgruppen (Entwickler, Stakeholder etc.) zu gewährleisten.\nDie weiter oben verlinkte Dokumentation wird als “the Single Source of Truth” - also die einzige Quelle der Wahrheit behandelt. Das heisst konkret, dass alle Guidelines, Designentscheidungen, Baublöcke (=Einzelkomponenten) und weiteres auf der Seite zu finden sind.\nEinige Vorteile von Lyne umfassen:\nEs ist eine einzelne, firmenweit genutzte Sprache für Design Eine klare, optimisierte Kollaboration wird durch bspw. klare Feedbackmechanismen gewährleistet Lyne und die einzelnen Komponenten durchlaufen jeweils einen soliden Testprozess, was das Risiko von potenziell entstehenden Fehlern minimiert. Es wird ein Fokus auf eine langfristige Nutzung gelegt, was zukünftige Refactorings unwahrscheinlich macht. Und viele weitere. Es gibt aber auch ein paar Risiken, welche von Seiten des Lyne-Teams klar kommuniziert werden:\nLyne stellt einen “Single Point of Failure” dar. Wenn das Design-System ausfällt, betrifft das viele andere Projekte. Es besteht Potenzial, aufgrund der vorgegebenen Komponenten die Kreativität des Designers einzuschränken. Da die Dokumentation den Single Point of Truth darstellt, besteht das Risiko, dass stellenweise Informationen fehlen. Wie integriere ich Lyne in ein Angular-Projekt? Man kann Lyne in drei verschiedene Arten von Projekten einbinden:\nProjekte, die pures Javascript nutzen Projekte, die Angular nutzen Projekte, die React / Next.js nutzen Im Rahmen dieser Dokumentation fokussieren wir uns ausschliesslich auf die Einbindung in ein Angular-Projekt. Möchtest du aber sehen, wie man Lyne in eine der anderen beiden Projektarten einbindet, kannst du das auf der Getting Started-Page von Lyne nachlesen.\nFür diese Anleitung gilt es als Voraussetzung, dass die Angular CLI installiert ist und bereits ein Angular-Projekt besteht. (Vorzugsweise ein leeres, um Konflikte zu vermeiden) Um Lyne in ein Angular-Projekt einzubinden, gilt es, den folgenden Schritten zu folgen:\nInstalliere mit dem folgenden Befehl über die Konsole das @sbb-esta/lyne-elements-Package: 1 npm install --save @sbb-esta/lyne-elements Es wird vom Lyne-Team schärfstens empfohlen, die global styles zu inkludieren. Das kannst du tun, indem du die folgende Anpassung im styles-Tag in der angular.json-Datei vornimmst: 1 2 3 4 5 6 ... \"styles\": [ \"src/styles.scss\", \"node_modules/@sbb-esta/lyne-elements/standard-theme.css\" ], ... Um die Web-Components in Angular zu nutzen, musst du zuletzt noch das CUSTOM_ELEMENT_SCHEMA aus dem @angular/core-Package im AppComponent importieren: 1 2 3 4 5 6 7 8 9 10 11 import { CUSTOM_ELEMENTS_SCHEMA, Component } from \"@angular/core\"; import \"@sbb-esta/lyne-elements/button.js\"; @Component({ selector: \"lyne-app\", standalone: true, schemas: [CUSTOM_ELEMENTS_SCHEMA], template: ` \u003csbb-button\u003eLorem ipsum\u003c/sbb-button\u003e `, }) export class App {} Wie nutze ich Lyne in meinem Projekt? Im Rahmen dieses Abschnitts sollen exemplarisch einige wichtige Aspekte beleuchtet werden, die beim Styling mit Lyne gut zu wissen sind.\nCSS-Dateien Die von Lyne genutzten Styles befinden sich grundsätzlich alle in der standard-theme.css-Datei, welche nach der Integration von Lyne bereits im Projekt vorhanden sein sollten.\nMöchtest du aber beispielsweise spezifischer aussuchen, welche Styles du genau brauchen möchtest, gibt es grundsätzlich folgende Dateien, welche von Lyne bereitgestellt werden:\nDateiname Beschreibung standard-theme.css Beinhält normalizing, core styles und alle verfügbaren CSS-Klassen. font-characters-extension.css Beinhält das gesamte Character-Set für die SBB-Font. normalize.css Beinhält grundlegende Styles, die die defaultmässigen Browser-Styles resetten. core.css Beinhält nötige Basics, um die Lyne-Komponenten nutzen zu können. (Bspw. Design Tokens) a11y.css Stellt CSS-Klassen bereit, welche der Accesibility dienen. animation.css Stellt CSS-KLassen bereit, die Animation deaktivieren. (Bspw. nützlich für Testing) layout.css Stellt CSS-KLassen bereit, die dem Layouting dienen. (Bspw. page-spacing, grid, etc.) lists.css Stellt CSS-Klassen bereit, die für das Styling von Listen gebraucht werden. scrollbar.css Stellt CSS-Klassen bereit, die für das Styling der Scrollbar gebraucht werden. table.css Stellt CSS-Klassen bereit, die für das Styling von Tabellen gebraucht werden. typography.css Stellt CSS-Klassen bereit, die für die Typographie gebraucht werden. Lean variant Es ist möglich, mit Lyne Komponenten automatisch den kleinsten möglichen size-Wert annehmen zu lassen, um ohne viel Aufwand ein kompaktes Design zu ermöglichen. Wichtig dabei zu beachten ist, dass das jeweils nur bei Komponenten funktioniert, die auch ein size-Property besitzen. Um den “lean mode” zu aktivieren, muss lediglich die CSS-Klasse sbb-lean zum html-Tag hinzugefügt werden:\n1 2 3 4 5 6 7 8 \u003chtml lang=\"en\" class=\"sbb-lean\"\u003e \u003chead\u003e \u003ctitle\u003eLean example\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e ... \u003c/body\u003e \u003c/html\u003e Full Font Die standard-theme.css-Datei beinhält ein Subset der SBB-Fonts, welche nicht alle Zeichen beinhält. Um die Fonts mit den fehlenden Zeichensätzen zu ergänzen, muss die font-characters-extension.css-Datei in der Datei styles.css importiert werden. Wichtig: Der Import muss direkt nach dem Import der standard-theme.css-Datei gemacht werden:\n1 2 @import \"@sbb-esta/lyne-elements/standard-theme.css\"; @import \"@sbb-esta/lyne-elements/font-characters-extension.css\"; CSS-Klassen Grundsätzlich sind die von Lyne bereitgestellten Styles in den Components. Es ist aber dennoch möglich, dass man in spezifischen Fällen die Styles von Components überschreiben möchte. Um das zu bewerkstelligen, können die CSS Variablen eines Components verwendet werden. Die spezifischen Variablen, die man anpassen kann, sind in der Dokumentation des jeweiligen Lyne-Components einsehbar.\nAnimations Animations gehören grundsätzlich zum von Lyne vorgesehenen Design und sollten nicht unterdrückt / deaktiviert werden, es kann aber für das Testing stellenweise dennoch nützlich sein, die Animationen (zeitweise) zu deaktivieren. Um die Animationen für ein Element zu deaktivieren, kann die CSS-Klasse sbb-disable-animations zum Element hinzugefügt werden. Wenn nur für ein übergreifendes Element (bspw. einen Wrapper) die Animation deaktiviert werden soll, kann die CSS-Klasse sbb-disable-animations-locally verwendet werden. Es ist ebenfalls möglich, die Animationen des Parent-Elements mit sbb-disable-animations zu deaktivieren und die der Child-Components mit sbb-enable-animations zu aktivieren, was dasselbe bewerkstelligt:\n1 2 3 4 5 6 7 8 9 10 11 \u003csbb-component class=\"sbb-disable-animation-locally\"\u003e \u003c!-- animations will play --\u003e \u003c/sbb-component\u003e \u003c!-- Or alternatively--\u003e \u003csbb-component class=\"sbb-disable-animation\"\u003e \u003csbb-component class=\"sbb-enable-animation\"\u003e \u003c!-- animations will play --\u003e \u003c/sbb-component\u003e \u003c/sbb-component\u003e Masseinheiten Alle Tokens und Components von Lyne verwenden als Masseinheit rem. Damit keine Inkosistenzen beim Design entstehen, wird empfohlen, für den Rest der Applikation ebenfalls rem als Masseinheit zu verwenden.\nFonts Die SBB stellt einige verschiedene Fonts bereit, welche von der font-weight abhängen. Grundsätzlich wird in Lyne zwischen drei Arten von font-weight unterschieden:\nRoman Bold Light Lyne mappt die Fonts automatisch auf das font-weight-Property. Wenn einem Element beispielsweise die Eigenschaft font-weight: bold hinzugefügt wird, wählt Lyne für dieses Element automatisch den korrespondierenden Zeichensatz aus. Die SBB bietet zwar mehr Fonts an, Lyne beschränkt sich aber auf die drei genannten Fonts.\n","categories":"","description":"Modul #F6 - Angular - Angular Lyne\n","excerpt":"Modul #F6 - Angular - Angular Lyne\n","ref":"/de/docs/03_web/06_angular/04_2_lyne/","tags":"","title":"Angular Lyne - Custom Components der SBB"},{"body":"Ziele Du weisst, was RxJS ist und welches Konzept die Technologie folgt. Du kennst Observables, Observers und Subscriptions und kannst diese anwenden. RxJS RxJS (Reactive Extensions for JavaScript) ist eine Library für funktionale, reaktive Programmierung in JavaScript. Das Konzept von RxJS basiert auf der Idee, dass alles in der Welt um uns herum ständig Veränderungen unterworfen ist und dass wir diese Veränderungen mithilfe der Verarbeitung von Ereignissen und Datenströmen verwalten können.\nRxJS bietet eine Reihe von Tools und Operatoren, mit denen man Ereignisse und Ströme von Daten auf eine reaktive und deklarative Weise verarbeiten kann. Dabei wird der Fokus nicht auf den Ablauf des Codes, sondern auf die Verarbeitung der Daten selbst gelegt.\nRxJS bietet verschiedene Arten von Observables und Subjects an, um Daten innerhalb einer Anwendung zu verwalten und zu teilen. Diese können verwendet werden, um Daten zwischen verschiedenen Komponenten zu übertragen oder um globale Ereignisse zu verwalten.\nKonzept Das zentrale Konzept von RxJS ist das Observable-Pattern. Ein Observable ist eine Art von Datenstrom, der Ereignisse oder Werte über einen Zeitraum hinweg ausgibt. Ein Observable kann auf Ereignisse wie Benutzerinteraktionen, Datenbankabfragen, API-Aufrufe und mehr reagieren und diese verarbeiten.\nMit RxJS kannst du Observable-Ströme transformieren, filtern, kombinieren und verwalten, indem du eine Kette von Operatoren auf die Observable anwendest. Das Ergebnis dieser Verarbeitung ist ein neuer Observable-Strom, der die transformierten Daten oder Ereignisse ausgibt.\nInstallation Um RxJS in ein Angular-Projekt zu installieren, kann man die folgenden Schritte ausführen:\nSicherstelle, dass Node.js und npm (Node Package Manager) auf dem Computer installiert ist. (Kann mit npm -verledigt werden.) Nun ein Terminal öffnen oder eine andere Shell und navigiere zum Hauptverzeichnis des Projekts. Folgenden Befehl ausführen, um NgRx zu installieren: 1 npm install rxjs Observables Wie schon angeschnitten wurde, ist ein Observable eine Art Datenstrom, der Werte oder Ereignisse asynchron und über einen bestimmten Zeitraum hinweg ausgibt. Ein Observable kann auf Ereignisse wie Benutzerinteraktionen, Datenbankabfragen, API-Aufrufe und weitere reagieren und diese verarbeiten.\nEin Observable ist im Grunde genommen eine Funktion, die einen Datenstrom definiert und zurückgibt. Diese Funktion kann dann durch verschiedene Operatoren transformiert werden, um den Datenstrom auf verschiedene Weisen zu bearbeiten.\nBei Observables gilt prinzipiell die Konvention, dass Variablennamen mit einem $ enden. Das macht Observables einfacher erkennbar und macht es Entwicklern einfacher, diese von “normalen” Variablen zu unterscheiden.\nBeispiel zur Erstellung eines Observables:\n1 2 3 4 5 6 7 8 9 10 import { Observable } from \"rxjs\"; const myObservable$ = new Observable((observer) =\u003e { // einziger Wert des Observables // mit next() wird der Wert an die Subscriber gesendet observer.next(\"Hello Dragon Warrior!\"); // schliesst das Observable ab observer.complete(); }); Observer In RxJS ist ein Observer ein Objekt, das eine Funktion oder eine Reihe von Funktionen definiert, um auf Werte oder Ereignisse zu reagieren, die von einem Observable ausgegeben werden. Ein Observer wird in der Regel beim Subscriben eines Observables verwendet, um die ausgegebenen Werte zu verarbeiten.\nEin Observer-Objekt in RxJS muss mindestens eine der folgenden Funktionen implementieren:\nnext(value: T): Wird aufgerufen, wenn ein neuer Wert von einem Observable ausgegeben wird. Der Parameter value enthält den ausgegebenen Wert. error(error: any): Wird aufgerufen, wenn ein Fehler bei der Ausgabe eines Wertes auftritt. Der Parameter error enthält den Fehler. complete(): Wird aufgerufen, wenn das Observable abgeschlossen ist und keine weiteren Werte ausgegeben werden. Ein Observer wird normalerweise durch eine subscribe Methode an das Observable angehängt, um den Output des Observables zu empfangen.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import { Observable } from \"rxjs\"; const myObservable$ = new Observable((observer) =\u003e { observer.next(\"Hello Dragon Warrior!\"); observer.complete(); }); const myObserver = { next: (value) =\u003e console.log(value), error: (error) =\u003e console.error(error), complete: () =\u003e console.log(\"Observable completed\"), }; myObservable$.subscribe(myObserver); Es ist möglich, einen Observer als Callback (Subscription) zu verwenden. Dies ist die gängigste Verwendungsmöglichkeit von Observers.\n1 2 3 4 5 6 7 8 9 10 11 12 import { Observable } from \"rxjs\"; const myObservable$ = new Observable((observer) =\u003e { observer.next(\"Hello Dragon Warrior!\"); observer.complete(); }); myObservable$.subscribe( (value) =\u003e console.log(\"Received value:\", value), (error) =\u003e console.error(\"Error:\", error), () =\u003e console.log(\"Completed\"), ); Es ist wichtig zu beachten, dass jede dieser Funktionen optional ist und weggelassen werden kann, wenn sie nicht benötigt wird.\n1 2 3 4 5 6 7 8 9 import { Observable } from \"rxjs\"; const myObservable$ = new Observable((observer) =\u003e { observer.next(\"Hello Dragon Warrior!\"); }); myObservable$.subscribe((value) =\u003e { console.log(value); }); Subscription Eine Subscription kann durch die subscribe Methode auf einem Observable erstellt werden. Wenn eine Subscription erstellt wird, wird eine Verbindung zwischen dem Observable und dem Observer hergestellt und der Datenfluss wird gestartet. Die Subscription gibt ein Objekt zurück, das eine Methode unsubscribe enthält. Diese Methode kann aufgerufen werden, um die Subscription zu beenden und den Datenfluss zu stoppen. Sie wird verwendet um den Datenfluss kontrollieren und den Speicherbedarf reduzieren, indem man ungenutzte Datenströme stoppt.\nIn dem folgenden Beispiel ist mySubscription die Subscription, diese wird erstellt durch myObservable.subscribe.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import { Observable } from \"rxjs\"; const myObservable$ = new Observable((observer) =\u003e { observer.next(\"Hello Dragon Warrior!\"); observer.complete(); }); const mySubscription = myObservable$.subscribe( (value) =\u003e { console.log(\"Received value:\", value); }, (error) =\u003e { console.log(\"Error:\", error); }, () =\u003e { console.log(\"Observable completed.\"); }, ); mySubscription.unsubscribe(); ","categories":"","description":"Modul #F6 - Angular - RxJS\n","excerpt":"Modul #F6 - Angular - RxJS\n","ref":"/docs/03_web/06_angular/05_1_rxjs/","tags":"","title":"RxJS"},{"body":"Ziele Du weisst, was RxJS ist und welches Konzept die Technologie folgt. Du kennst Observables, Observers und Subscriptions und kannst diese anwenden. RxJS RxJS (Reactive Extensions for JavaScript) ist eine Library für funktionale, reaktive Programmierung in JavaScript. Das Konzept von RxJS basiert auf der Idee, dass alles in der Welt um uns herum ständig Veränderungen unterworfen ist und dass wir diese Veränderungen mithilfe der Verarbeitung von Ereignissen und Datenströmen verwalten können.\nRxJS bietet eine Reihe von Tools und Operatoren, mit denen man Ereignisse und Ströme von Daten auf eine reaktive und deklarative Weise verarbeiten kann. Dabei wird der Fokus nicht auf den Ablauf des Codes, sondern auf die Verarbeitung der Daten selbst gelegt.\nRxJS bietet verschiedene Arten von Observables und Subjects an, um Daten innerhalb einer Anwendung zu verwalten und zu teilen. Diese können verwendet werden, um Daten zwischen verschiedenen Komponenten zu übertragen oder um globale Ereignisse zu verwalten.\nKonzept Das zentrale Konzept von RxJS ist das Observable-Pattern. Ein Observable ist eine Art von Datenstrom, der Ereignisse oder Werte über einen Zeitraum hinweg ausgibt. Ein Observable kann auf Ereignisse wie Benutzerinteraktionen, Datenbankabfragen, API-Aufrufe und mehr reagieren und diese verarbeiten.\nMit RxJS kannst du Observable-Ströme transformieren, filtern, kombinieren und verwalten, indem du eine Kette von Operatoren auf die Observable anwendest. Das Ergebnis dieser Verarbeitung ist ein neuer Observable-Strom, der die transformierten Daten oder Ereignisse ausgibt.\nInstallation Um RxJS in ein Angular-Projekt zu installieren, kann man die folgenden Schritte ausführen:\nSicherstelle, dass Node.js und npm (Node Package Manager) auf dem Computer installiert ist. (Kann mit npm -verledigt werden.) Nun ein Terminal öffnen oder eine andere Shell und navigiere zum Hauptverzeichnis des Projekts. Folgenden Befehl ausführen, um NgRx zu installieren: 1 npm install rxjs Observables Wie schon angeschnitten wurde, ist ein Observable eine Art Datenstrom, der Werte oder Ereignisse asynchron und über einen bestimmten Zeitraum hinweg ausgibt. Ein Observable kann auf Ereignisse wie Benutzerinteraktionen, Datenbankabfragen, API-Aufrufe und weitere reagieren und diese verarbeiten.\nEin Observable ist im Grunde genommen eine Funktion, die einen Datenstrom definiert und zurückgibt. Diese Funktion kann dann durch verschiedene Operatoren transformiert werden, um den Datenstrom auf verschiedene Weisen zu bearbeiten.\nBei Observables gilt prinzipiell die Konvention, dass Variablennamen mit einem $ enden. Das macht Observables einfacher erkennbar und macht es Entwicklern einfacher, diese von “normalen” Variablen zu unterscheiden.\nBeispiel zur Erstellung eines Observables:\n1 2 3 4 5 6 7 8 9 10 import { Observable } from \"rxjs\"; const myObservable$ = new Observable((observer) =\u003e { // einziger Wert des Observables // mit next() wird der Wert an die Subscriber gesendet observer.next(\"Hello Dragon Warrior!\"); // schliesst das Observable ab observer.complete(); }); Observer In RxJS ist ein Observer ein Objekt, das eine Funktion oder eine Reihe von Funktionen definiert, um auf Werte oder Ereignisse zu reagieren, die von einem Observable ausgegeben werden. Ein Observer wird in der Regel beim Subscriben eines Observables verwendet, um die ausgegebenen Werte zu verarbeiten.\nEin Observer-Objekt in RxJS muss mindestens eine der folgenden Funktionen implementieren:\nnext(value: T): Wird aufgerufen, wenn ein neuer Wert von einem Observable ausgegeben wird. Der Parameter value enthält den ausgegebenen Wert. error(error: any): Wird aufgerufen, wenn ein Fehler bei der Ausgabe eines Wertes auftritt. Der Parameter error enthält den Fehler. complete(): Wird aufgerufen, wenn das Observable abgeschlossen ist und keine weiteren Werte ausgegeben werden. Ein Observer wird normalerweise durch eine subscribe Methode an das Observable angehängt, um den Output des Observables zu empfangen.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import { Observable } from \"rxjs\"; const myObservable$ = new Observable((observer) =\u003e { observer.next(\"Hello Dragon Warrior!\"); observer.complete(); }); const myObserver = { next: (value) =\u003e console.log(value), error: (error) =\u003e console.error(error), complete: () =\u003e console.log(\"Observable completed\"), }; myObservable$.subscribe(myObserver); Es ist möglich, einen Observer als Callback (Subscription) zu verwenden. Dies ist die gängigste Verwendungsmöglichkeit von Observers.\n1 2 3 4 5 6 7 8 9 10 11 12 import { Observable } from \"rxjs\"; const myObservable$ = new Observable((observer) =\u003e { observer.next(\"Hello Dragon Warrior!\"); observer.complete(); }); myObservable$.subscribe( (value) =\u003e console.log(\"Received value:\", value), (error) =\u003e console.error(\"Error:\", error), () =\u003e console.log(\"Completed\"), ); Es ist wichtig zu beachten, dass jede dieser Funktionen optional ist und weggelassen werden kann, wenn sie nicht benötigt wird.\n1 2 3 4 5 6 7 8 9 import { Observable } from \"rxjs\"; const myObservable$ = new Observable((observer) =\u003e { observer.next(\"Hello Dragon Warrior!\"); }); myObservable$.subscribe((value) =\u003e { console.log(value); }); Subscription Eine Subscription kann durch die subscribe Methode auf einem Observable erstellt werden. Wenn eine Subscription erstellt wird, wird eine Verbindung zwischen dem Observable und dem Observer hergestellt und der Datenfluss wird gestartet. Die Subscription gibt ein Objekt zurück, das eine Methode unsubscribe enthält. Diese Methode kann aufgerufen werden, um die Subscription zu beenden und den Datenfluss zu stoppen. Sie wird verwendet um den Datenfluss kontrollieren und den Speicherbedarf reduzieren, indem man ungenutzte Datenströme stoppt.\nIn dem folgenden Beispiel ist mySubscription die Subscription, diese wird erstellt durch myObservable.subscribe.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import { Observable } from \"rxjs\"; const myObservable$ = new Observable((observer) =\u003e { observer.next(\"Hello Dragon Warrior!\"); observer.complete(); }); const mySubscription = myObservable$.subscribe( (value) =\u003e { console.log(\"Received value:\", value); }, (error) =\u003e { console.log(\"Error:\", error); }, () =\u003e { console.log(\"Observable completed.\"); }, ); mySubscription.unsubscribe(); ","categories":"","description":"Modul #F6 - Angular - RxJS\n","excerpt":"Modul #F6 - Angular - RxJS\n","ref":"/de/docs/03_web/06_angular/05_1_rxjs/","tags":"","title":"RxJS"},{"body":"Ziele Du weisst, was RxJS-Subjects sind. Du kennst die vier Arten von Subjects und kannst diese erläutern und anwenden. RxJS-Subjects sind spezielle Arten von Observables, die sowohl als Observables als auch als Observer fungieren können. In anderen Worten ermöglichen sie das Senden und Empfangen von Werten und Ereignissen und das Weiterleiten dieser Werte und Ereignisse an andere Observable-Subscriber.\nEs gibt vier Arten von Subjects:\nSubject: Ein einfaches Subject, das die neuesten Werte an seine jeweiligen Abonnenten weiterleitet. BehaviorSubject: Ein Subject, das den letzten Wert beibehält, der an ihn gesendet wurde, und ihn an jeden neuen Abonnenten sofort weitergibt. ReplaySubject: Ein Subject, das alle Werte an seine neuen Abonnenten weiterleitet, unabhängig davon, wann sie das Abonnement starten. AsyncSubject: Ein Subject, das nur den letzten Wert weiterleitet, wenn es vollständig abgeschlossen ist. Subjects sind besonders nützlich, wenn du einen zentralen Knotenpunkt benötigst, um Daten innerhalb deiner Anwendung zu verwalten und zu teilen. Zum Beispiel kannst du ein Subject verwenden, um Benutzerinteraktionen zu verfolgen und diese Daten an verschiedene Komponenten deiner Anwendung weiterzuleiten, um sie zu aktualisieren oder anzuzeigen.\nSubject Das Subject speichert keine Werte, die vor der Registrierung/Abonnierung (Subscription) der Observer gesendet wurden. Wenn ein Observer sich später registriert, empfängt er nur die Werte, die nach seiner Registrierung/Abonnierung gesendet wurden.\nEs ist zu beachten, dass die Observer in der Reihenfolge registriert werden, in der sie die subscribe-Methode aufrufen.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import { Subject } from \"rxjs\"; const mySubject = new Subject(); mySubject.subscribe((value) =\u003e { console.log(\"Observer 1 received value:\", value); }); mySubject.next(\"Hello Dragon Warrior!\"); mySubject.subscribe((value) =\u003e { console.log(\"Observer 2 received value:\", value); }); mySubject.next(\"Another value\"); // Observer 1 received value: Hello Dragon Warrior! // Observer 1 received value: Another value // Observer 2 received value: Another value BehaviorSubject Im Gegensatz zum normalen Subject speichert das BehaviorSubject den letzten gesendeten Wert, sodass es ihn an neue Observer weitergeben kann. Wenn keine Werte zuvor gesendet wurden, gibt das BehaviorSubject den initialen Wert zurück, der ihm während der Initialisierung zugewiesen wurde.\nEin BehaviorSubject kann nützlich sein, wenn man einen Wert benötigt, auf den man jederzeit zugreifen kann, auch wenn es keine neuen Ereignisse gibt.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import { BehaviorSubject } from \"rxjs\"; const myBehaviorSubject = new BehaviorSubject(\"initial value\"); myBehaviorSubject.subscribe((value) =\u003e { console.log(\"Observer 1 received value:\", value); }); mySubject.next(\"Hello Dragon Warrior!\"); myBehaviorSubject.subscribe((value) =\u003e { console.log(\"Observer 2 received value:\", value); }); myBehaviorSubject.next(\"Another value\"); // Observer 1 received value: initial value // Observer 1 received value: Hello Dragon Warrior! // Observer 2 received value: Hello Dragon Warrior! // Observer 1 received value: Another value // Observer 2 received value: Another value ReplaySubject Im Gegensatz zum BehaviorSubject, welches nur den letzten Wert speichert, speichert das ReplaySubject eine definierte Anzahl von Werten, die es an neue Observer weitergibt. Wenn ein neuer Observer sich beim ReplaySubject registriert, erhält er die gespeicherten Werte in der Reihenfolge, in der sie gesendet wurden, bevor er auf zukünftige Werte wartet.\nEin ReplaySubject kann nützlich sein, wenn man eine feste Anzahl von Werten benötigt, auf die man jederzeit zugreifen kann, auch wenn es keine neuen Ereignisse gibt.\nZu beachten ist, dass die Grösse des ReplaySubject bei der Initialisierung angegeben wird und die maximale Anzahl der gespeicherten Werte definiert. Wenn mehr Werte gesendet werden, als die Größe des ReplaySubject zulässt, werden ältere Werte entfernt.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import { ReplaySubject } from \"rxjs\"; const myReplaySubject = new ReplaySubject(2); myReplaySubject.next(\"Value 1\"); myReplaySubject.next(\"Value 2\"); myReplaySubject.next(\"Value 3\"); myReplaySubject.subscribe((value) =\u003e { console.log(\"Observer 1 received value:\", value); }); myReplaySubject.next(\"Value 4\"); myReplaySubject.subscribe((value) =\u003e { console.log(\"Observer 2 received value:\", value); }); // Observer 1 received value: Value 2 // Observer 1 received value: Value 3 // Observer 1 received value: Value 4 // Observer 2 received value: Value 3 // Observer 2 received value: Value 4 AsyncSubject Im Gegensatz zu anderen Typen von Subjects speichert das AsyncSubject nur den letzten Wert, der von einem Observable gesendet wurde, wenn das Observable vollständig abgeschlossen (complete()) ist, selbst wenn die next() Methode aufgerufen wurde. Wurde das Observable vollständig abgeschlossen, wird der letzte Wert an alle Observer weitergegeben, die auf das AsyncSubject subscriben. Ansonsten wird der letzte Wert nicht weitergegeben.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import { AsyncSubject } from \"rxjs\"; const myAsyncSubject = new AsyncSubject(); myAsyncSubject.subscribe((value) =\u003e { console.log(\"Observer 1 received value:\", value); }); myAsyncSubject.next(\"Value 1\"); myAsyncSubject.next(\"Value 2\"); myAsyncSubject.subscribe((value) =\u003e { console.log(\"Observer 2 received value:\", value); }); myAsyncSubject.next(\"Value 3\"); myAsyncSubject.complete(); myAsyncSubject.subscribe((value) =\u003e { console.log(\"Observer 3 received value:\", value); }); // Observer 1 received value: Value 3 // Observer 2 received value: Value 3 // Observer 3 received value: Value 3 ","categories":"","description":"Modul #F6 - Angular - RxJS Subjects\n","excerpt":"Modul #F6 - Angular - RxJS Subjects\n","ref":"/docs/03_web/06_angular/05_2_rxjs-subjects/","tags":"","title":"RxJS Subjects"},{"body":"Ziele Du weisst, was RxJS-Subjects sind. Du kennst die vier Arten von Subjects und kannst diese erläutern und anwenden. RxJS-Subjects sind spezielle Arten von Observables, die sowohl als Observables als auch als Observer fungieren können. In anderen Worten ermöglichen sie das Senden und Empfangen von Werten und Ereignissen und das Weiterleiten dieser Werte und Ereignisse an andere Observable-Subscriber.\nEs gibt vier Arten von Subjects:\nSubject: Ein einfaches Subject, das die neuesten Werte an seine jeweiligen Abonnenten weiterleitet. BehaviorSubject: Ein Subject, das den letzten Wert beibehält, der an ihn gesendet wurde, und ihn an jeden neuen Abonnenten sofort weitergibt. ReplaySubject: Ein Subject, das alle Werte an seine neuen Abonnenten weiterleitet, unabhängig davon, wann sie das Abonnement starten. AsyncSubject: Ein Subject, das nur den letzten Wert weiterleitet, wenn es vollständig abgeschlossen ist. Subjects sind besonders nützlich, wenn du einen zentralen Knotenpunkt benötigst, um Daten innerhalb deiner Anwendung zu verwalten und zu teilen. Zum Beispiel kannst du ein Subject verwenden, um Benutzerinteraktionen zu verfolgen und diese Daten an verschiedene Komponenten deiner Anwendung weiterzuleiten, um sie zu aktualisieren oder anzuzeigen.\nSubject Das Subject speichert keine Werte, die vor der Registrierung/Abonnierung (Subscription) der Observer gesendet wurden. Wenn ein Observer sich später registriert, empfängt er nur die Werte, die nach seiner Registrierung/Abonnierung gesendet wurden.\nEs ist zu beachten, dass die Observer in der Reihenfolge registriert werden, in der sie die subscribe-Methode aufrufen.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import { Subject } from \"rxjs\"; const mySubject = new Subject(); mySubject.subscribe((value) =\u003e { console.log(\"Observer 1 received value:\", value); }); mySubject.next(\"Hello Dragon Warrior!\"); mySubject.subscribe((value) =\u003e { console.log(\"Observer 2 received value:\", value); }); mySubject.next(\"Another value\"); // Observer 1 received value: Hello Dragon Warrior! // Observer 1 received value: Another value // Observer 2 received value: Another value BehaviorSubject Im Gegensatz zum normalen Subject speichert das BehaviorSubject den letzten gesendeten Wert, sodass es ihn an neue Observer weitergeben kann. Wenn keine Werte zuvor gesendet wurden, gibt das BehaviorSubject den initialen Wert zurück, der ihm während der Initialisierung zugewiesen wurde.\nEin BehaviorSubject kann nützlich sein, wenn man einen Wert benötigt, auf den man jederzeit zugreifen kann, auch wenn es keine neuen Ereignisse gibt.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import { BehaviorSubject } from \"rxjs\"; const myBehaviorSubject = new BehaviorSubject(\"initial value\"); myBehaviorSubject.subscribe((value) =\u003e { console.log(\"Observer 1 received value:\", value); }); mySubject.next(\"Hello Dragon Warrior!\"); myBehaviorSubject.subscribe((value) =\u003e { console.log(\"Observer 2 received value:\", value); }); myBehaviorSubject.next(\"Another value\"); // Observer 1 received value: initial value // Observer 1 received value: Hello Dragon Warrior! // Observer 2 received value: Hello Dragon Warrior! // Observer 1 received value: Another value // Observer 2 received value: Another value ReplaySubject Im Gegensatz zum BehaviorSubject, welches nur den letzten Wert speichert, speichert das ReplaySubject eine definierte Anzahl von Werten, die es an neue Observer weitergibt. Wenn ein neuer Observer sich beim ReplaySubject registriert, erhält er die gespeicherten Werte in der Reihenfolge, in der sie gesendet wurden, bevor er auf zukünftige Werte wartet.\nEin ReplaySubject kann nützlich sein, wenn man eine feste Anzahl von Werten benötigt, auf die man jederzeit zugreifen kann, auch wenn es keine neuen Ereignisse gibt.\nZu beachten ist, dass die Grösse des ReplaySubject bei der Initialisierung angegeben wird und die maximale Anzahl der gespeicherten Werte definiert. Wenn mehr Werte gesendet werden, als die Größe des ReplaySubject zulässt, werden ältere Werte entfernt.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import { ReplaySubject } from \"rxjs\"; const myReplaySubject = new ReplaySubject(2); myReplaySubject.next(\"Value 1\"); myReplaySubject.next(\"Value 2\"); myReplaySubject.next(\"Value 3\"); myReplaySubject.subscribe((value) =\u003e { console.log(\"Observer 1 received value:\", value); }); myReplaySubject.next(\"Value 4\"); myReplaySubject.subscribe((value) =\u003e { console.log(\"Observer 2 received value:\", value); }); // Observer 1 received value: Value 2 // Observer 1 received value: Value 3 // Observer 1 received value: Value 4 // Observer 2 received value: Value 3 // Observer 2 received value: Value 4 AsyncSubject Im Gegensatz zu anderen Typen von Subjects speichert das AsyncSubject nur den letzten Wert, der von einem Observable gesendet wurde, wenn das Observable vollständig abgeschlossen (complete()) ist, selbst wenn die next() Methode aufgerufen wurde. Wurde das Observable vollständig abgeschlossen, wird der letzte Wert an alle Observer weitergegeben, die auf das AsyncSubject subscriben. Ansonsten wird der letzte Wert nicht weitergegeben.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import { AsyncSubject } from \"rxjs\"; const myAsyncSubject = new AsyncSubject(); myAsyncSubject.subscribe((value) =\u003e { console.log(\"Observer 1 received value:\", value); }); myAsyncSubject.next(\"Value 1\"); myAsyncSubject.next(\"Value 2\"); myAsyncSubject.subscribe((value) =\u003e { console.log(\"Observer 2 received value:\", value); }); myAsyncSubject.next(\"Value 3\"); myAsyncSubject.complete(); myAsyncSubject.subscribe((value) =\u003e { console.log(\"Observer 3 received value:\", value); }); // Observer 1 received value: Value 3 // Observer 2 received value: Value 3 // Observer 3 received value: Value 3 ","categories":"","description":"Modul #F6 - Angular - RxJS Subjects\n","excerpt":"Modul #F6 - Angular - RxJS Subjects\n","ref":"/de/docs/03_web/06_angular/05_2_rxjs-subjects/","tags":"","title":"RxJS Subjects"},{"body":"Ziele Du kennst die verschiedenen RxJS-Operatoren und kannst diese anwenden. Operators RxJS bietet eine Vielzahl von Operatoren, die auf Observables angewendet werden können, um sie zu transformieren, zu filtern, zu kombinieren und vieles mehr. Folgend werden die wichtigsten vorgestellt.\nPiping Die pipe() ist ein wichtiger Operator, der es ermöglicht, eine Observable-Kette zu erstellen, indem verschiedene Operatoren nacheinander angewendet werden. Der Piping-Operator wird verwendet, um die Lesbarkeit und Wartbarkeit von Observable-Ketten zu verbessern, indem man sie in kleinere und leichter zu verstehende Abschnitte unterteilt. Wie eine map funktioniert, kannst du hier nachlesen.\n1 2 3 4 5 6 7 8 9 import { of, map } from \"rxjs\"; of(1, 2, 3) .pipe(map((x) =\u003e x * x)) .subscribe((v) =\u003e console.log(`value: ${v}`)); // value: 1 // value: 4 // value: 9 Creation Operators from Der from-Operator wandelt eine Reihe von Werten oder ein Iterable in ein Observable um. Er akzeptiert eine Quelle von Werten, wie beispielsweise ein Array oder eine Map, und gibt ein Observable zurück, das die Werte dieser Quelle nacheinander emittiert.\nDer from-Operator ist daher primär für Werte geeignet, die aus verschiedenen dynamischen Quellen resultieren. Er splittet die Eingabe, was der of-Operator nicht tut. Mögliche Argumente sind dabei subscribable Objects, Promises, Observable-artige Objekte, Arrays, iterierbare Datenstrukturen oder ein Array-artige Objekte.\n1 2 3 4 5 6 7 8 9 10 11 import { from } from \"rxjs\"; const source = from([1, 2, 3, 4, 5]); source.subscribe((value) =\u003e console.log(value)); // 1 // 2 // 3 // 4 // 5 of Der of-Operator wandelt wie der from-Operator auch eine feste Anzahl von Werten in ein Observable um. Der Operator akzeptiert jedoch eine beliebige Anzahl von Argumenten und gibt ein Observable zurück, das diese Argumente in der Reihenfolge ihres Auftretens emittiert.\nDieser Operator ist besonders nützlich, um eine feste Anzahl von Werten zu emittieren, die bekannt sind, bevor das Observable abonniert wird. Wenn man eine Quelle von Werten hat, die dynamisch generiert werden, ist es wahrscheinlich sinnvoller, den from Operator zu verwenden.\n1 2 3 4 5 6 7 8 9 10 11 import { of } from \"rxjs\"; const source = of(1, 2, 3, 4, 5); source.subscribe((value) =\u003e console.log(value)); // 1 // 2 // 3 // 4 // 5 Join Creation Operators Info: In RxJS bezieht sich “Emission” auf den Wert, der von einem Observable emittiert / ausgegeben wird.\nforkJoin forkJoin ist ein Kombinationsoperator, der ein Array von Observables akzeptiert und wartet, bis alle Observables ihre Emissionen abgeschlossen haben, bevor er ein neues Observable zurückgibt. Das zurückgegebene Observable gibt ein Array von Werten zurück, das den letzten Wert jedes Observables enthält, das dem forkJoin Operator übergeben wurde.\nDieser Operator ist besonders nützlich, wenn man mehrere Quellen von Daten hat, die parallel verarbeitet werden können, und man auf alle Ergebnisse warten muss, bevor man mit der nächsten Phase der Verarbeitung fortfahren kann.\nZu beachten ist, dass der Operator fehlschlägt, wenn eines der übergebenen Observables einen Fehler emittiert, bevor es seine Emissionen abgeschlossen hat.\n1 2 3 4 5 6 7 8 9 10 import { forkJoin, of } from \"rxjs\"; const source1 = of(\"Hello\"); const source2 = of(\"World!\"); forkJoin([source1, source2]).subscribe(([value1, value2]) =\u003e { console.log(value1 + \" \" + value2); }); // \"Hello World!\" concat Der concat-Operator kombiniert mehrere Observables sequentiell, indem er die Emissionen des ersten Observables vollständig verarbeitet, bevor er mit dem nächsten Observable fortfährt. Das bedeutet, dass das zweite Observable erst dann subscribed wird, wenn das erste Observable seine Emissionen vollständig abgeschlossen hat und so weiter.\nDieser Operator ist besonders nützlich, wenn man sicherstellen muss, dass bestimmte Aktionen in einer bestimmten Reihenfolge ausgeführt werden, oder wenn man die Emissionen von Observables in einer bestimmten Sequenz verarbeiten muss.\nZu beachten ist jedoch, dass der Operator blockierend ist und erst dann zur nächsten Phase der Verarbeitung übergeht, wenn das vorherige Observable abgeschlossen wurde.\n1 2 3 4 5 6 7 8 9 10 11 import { concat, of } from \"rxjs\"; const source1 = of(\"Hello\"); const source2 = of(\"Dragon Warrior!\"); concat(source1, source2).subscribe((value) =\u003e { console.log(value); }); // \"Hello\" // \"Dragon Warrior!\" merge Der merge-Operator kombiniert auch mehrere Observables, indem er die Emissionen aller Observables in einem einzigen Observable zusammenführt. Im Gegensatz zum concat-Operator führt der merge-Operator die Emissionen parallel aus, unabhängig davon, welches Observable die Emissionen zuerst ausgibt.\nBeachten muss man jedoch, dass dieser Operator keine Garantie für die Reihenfolge der Emissionen gibt und dass es möglich ist, dass die Emissionen der Observables sich gegenseitig überschneiden.\n1 2 3 4 5 6 7 8 9 10 11 import { merge, of } from \"rxjs\"; const source1 = of(\"Hello\"); const source2 = of(\"Dragon Warrior!\"); merge(source1, source2).subscribe((value) =\u003e { console.log(value); }); // \"Hello\" // \"Dragon Warrior!\" zip Der zip Operator kombiniert die Emissionen mehrerer Observables zu einer einzelnen Emission. Dabei werden die Emissionen jedes Observables zu einer Gruppe kombiniert, und sobald alle Observables eine Emission abgegeben haben, wird diese Gruppe als Emission des resultierenden Observables ausgegeben.\nDieser Operator ist besonders nützlich, wenn man mehrere Datenströme kombiniert und sicherstellen muss, dass alle Daten synchronisiert sind. Man muss jedoch beachten, dass der Operator die Emissionen jedes Observables zu einer Gruppe kombiniert, was bedeutet, dass die Grösse jeder Emission vom Observable mit der geringsten Anzahl an Emissionen begrenzt wird.\nAuch zu beachten ist, dass der Operator darauf wartet, dass alle Observables eine Emission abgeben, bevor er eine Emission ausgibt. Wenn ein Observable keine Emission abgibt, wird das resultierende Observable keine Emissionen ausgeben.\nDer Hauptunterschied vom zip-Operator zum forkJoin-Operator ist, dass mit zip die reinkommenden Werte Schritt für Schritt kombiniert werden, während forkJoin die Werte erst emittiert, nachdem alle Input-Observables completed wurden.\n1 2 3 4 5 6 7 8 9 10 11 import { zip, of } from \"rxjs\"; const source1 = of(\"Hello\"); const source2 = of(\"Dragon\"); const source3 = of(\"Warrior\"); zip(source1, source2, source3).subscribe((value) =\u003e { console.log(value); }); // [\"Hello\", \"Dragon\", \"Warrior\"] Transformation Operators map Der meist verwendete RxJS-Operator ist der map Operator. Dieser wird verwendet, um die Werte eines Observables zu transformieren. Es gibt viele Anwendungsfälle für diesen Operator, einschliesslich der Umwandlung von Daten in ein anderes Format, der Extraktion von bestimmten Werten aus einem Datenstrom oder der Anwendung einer Funktion auf jeden Wert in einem Observable.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import { of } from \"rxjs\"; import { map } from \"rxjs/operators\"; const source = of(1, 2, 3, 4, 5); const doubled = source.pipe(map((value) =\u003e value * 2)); doubled.subscribe((value) =\u003e console.log(value)); // 2 // 4 // 6 // 8 // 10 mergeAll/mergeMap Es kann passieren, dass ein Observable eine Methode aufruft, die ein weiteres Observable zurückgibt. Dieser Verhalten kommt oft bei API-Abfragen vor. Somit hat man dann ein äusseres und inneres Observable. Um nun an die Daten zu gelangen, müsste man auf beide subscriben, was auch möglich ist:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import { of, from, map } from \"rxjs\"; const getData = (param) =\u003e { return of(`retrieved new data with param ${param}`); }; from([1, 2, 3, 4]) .pipe(map((param) =\u003e getData(param))) .subscribe((value) =\u003e value.subscribe((data) =\u003e console.log(data))); // retrieved new data with param 1 // retrieved new data with param 2 // retrieved new data with param 3 // retrieved new data with param 4 Das ist aber alles andere als optimal, weshalb man alternativ mergeMap benutzen kann. mergeMap ist eine Kombination von mergeAll und map. mergeAll erledigt die subscription auf das innere Observable, auf diese Weise muss man dann nicht mehr zweimal subscriben. Zudem merged es das innere Observable in das äussere.\nBeispiel mit mergeAll:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import { of, from, map, mergeAll } from \"rxjs\"; const getData = (param) =\u003e { return of(`retrieved new data with param ${param}`); }; from([1, 2, 3, 4]) .pipe( map((param) =\u003e getData(param)), mergeAll(), ) .subscribe((value) =\u003e console.log(value)); // retrieved new data with param 1 // retrieved new data with param 2 // retrieved new data with param 3 // retrieved new data with param 4 Beispiel mit mergeMap:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import { of, from, mergeMap } from \"rxjs\"; const getData = (param) =\u003e { return of(`retrieved new data with param ${param}`); }; from([1, 2, 3, 4]) .pipe(mergeMap((param) =\u003e getData(param))) .subscribe((value) =\u003e console.log(value)); // retrieved new data with param 1 // retrieved new data with param 2 // retrieved new data with param 3 // retrieved new data with param 4 Hinweis: Oft wird flatMap als Alias für mergeMap verwendet. Lass dich also nicht verwirren, wenn die Begriffe teilweise wechseln.\nswitchAll/switchMap switchMap funktioniert ähnlich wie mergeMap. Der Operator subscribed auch auf das innere Observable. Auch hier ist switchMap eine Kombination, und zwar von switchAll und map. switchAll canceled die vorherige Subscription und subscribed auf die neue, wenn ein neues Observable reinkommt.\nHier kannst du nachlesen, wie delay funktioniert.\nBeispiel mit switchAll:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import { of, from, map, switchAll, delay } from \"rxjs\"; const getData = (param) =\u003e { return of(`retrieved new data with param ${param}`).pipe(delay(1000)); }; from([1, 2, 3, 4]) .pipe( map((param) =\u003e getData(param)), switchAll(), ) .subscribe((value) =\u003e console.log(value)); // retrieved new data with param 4 Beispiel mit switchMap:\n1 2 3 4 5 6 7 8 9 10 11 import { of, from, switchMap, delay } from \"rxjs\"; const getData = (param) =\u003e { return of(`retrieved new data with param ${param}`).pipe(delay(1000)); }; from([1, 2, 3, 4]) .pipe(switchMap((param) =\u003e getData(param))) .subscribe((value) =\u003e console.log(value)); // retrieved new data with param 4 concatMap Auch concatMap subscribed auf das innere Observable. Der Unterschied zu switchMap ist, dass concatMap nicht die Subscription cancelled, wenn ein neues Observable reinkommt. Es subscribed stattdessen solange nicht auf das nächste Observable, bis das momentane fertig ist.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import { of, from } from \"rxjs\"; import { delay, concatMap } from \"rxjs/operators\"; const getData2 = (param) =\u003e { return of(`2 retrieved new data with param ${param}`).pipe(delay(1000)); }; from([1, 2, 3, 4]) .pipe(concatMap((param) =\u003e getData2(param))) .subscribe((value) =\u003e console.log(value)); // [wait 1s] // 2 retrieved new data with param 1 // [wait 1s] // 2 retrieved new data with param 2 // 2 [wait 1s] // 2 retrieved new data with param 3 // [wait 1s] // 2 retrieved new data with param 4 groupBy Die groupBy()-Methode ermöglicht es, ein Observable in mehrere Observables aufzuteilen, die auf der Grundlage eines bestimmten Schlüssels gruppiert sind.\nDer Prozess besteht darin, die ursprünglichen Emissionen in Gruppen aufzuteilen, die jeweils auf einen eindeutigen Schlüssel abgebildet werden. Jede Gruppe ist ein eigenes Observable, das alle Emissionen enthält, die diesem Schlüssel zugeordnet sind.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import { from } from \"rxjs\"; import { groupBy, mergeMap, toArray } from \"rxjs/operators\"; interface Person { name: string; age: number; } const people: Person[] = from([ { name: \"John\", age: 30 }, { name: \"Jane\", age: 25 }, { name: \"Bob\", age: 30 }, { name: \"Alice\", age: 25 }, ]); people .pipe( groupBy((person) =\u003e person.age), mergeMap((group) =\u003e group.pipe(toArray())), ) .subscribe((group) =\u003e console.log(group)); // [ { name: 'Jane', age: 25 }, { name: 'Alice', age: 25 } ] // [ { name: 'John', age: 30 }, { name: 'Bob', age: 30 } ] Filtering Operators elementAt elementAt() wird benutzt, um ein Element eines Observable an der angegebenen Indexposition auszugeben und das Observable zu schliessen. Der Operator gibt ein Observable zurück, das nur das angeforderte Element emittiert und dann vollständig geschlossen wird.\nMan kann nach der Indexposition auch einen Defaultwert angeben, welcher zurückgegeben wird, wenn das Element an der angegebenen Indexposition nicht gefunden wurde.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import { of } from \"rxjs\"; import { elementAt } from \"rxjs/operators\"; const source$ = of(\"A\", \"B\", \"C\", \"D\", \"E\"); // ohne Defaultwert source$ .pipe( elementAt(2), // 'C' ) .subscribe(console.log); // mit Defaultwert source$ .pipe( elementAt(10, \"F\"), // 'F' ) .subscribe(console.log); filter filter wird verwendet, um Observable-Elemente zu filtern, die nicht den Bedingungen entsprechen, die in der übergebenen Funktion definiert wurden. Die Filterfunktion gibt ein neues Observable zurück, das nur Elemente enthält, die die Bedingungen der Filterfunktion erfüllen.\n1 2 3 4 5 6 7 8 import { of } from \"rxjs\"; import { filter } from \"rxjs/operators\"; const source = of(1, 2, 3, 4, 5); const filtered = source.pipe(filter((x) =\u003e x % 2 === 0)); filtered.subscribe((x) =\u003e console.log(x)); // 2 // 4 first Der first Operator gibt nur das erste Element aus einem Observable zurück. Man kann den Operator aber auch mittels einer Funktion ergänzen, um eine Bedienung zu schaffen, somit wird dann das erste Element zurückgegeben, welches auf diese Bedingung zutrifft. Nach der Funktion kann man auch einen Defaultwert hinzufügen, welcher zurückgegeben werden soll, wenn kein Element gefunden wird. Gibt man keinen Defaultwert an und die Bedingung trifft nicht zu, so wird ein fehler ausgegeben.\n1 2 3 4 5 6 7 8 9 10 import { of } from \"rxjs\"; import { first } from \"rxjs/operators\"; const source = of(1, 2, 3); source.pipe(first()).subscribe((value) =\u003e console.log(value)); // 1 source.pipe(first((x) =\u003e x \u003e 2)).subscribe((value) =\u003e console.log(value)); // 3 source.pipe(first((x) =\u003e x \u003e 3, null)).subscribe((value) =\u003e console.log(value)); // null last Der last Operator funktioniert genau gleich wie der first Operator. Nur ist es so, dass hier immer das letzte Element zurückgegeben wird.\n1 2 3 4 5 6 7 8 9 10 import { of } from \"rxjs\"; import { first, last } from \"rxjs/operators\"; const source = of(1, 2, 3); source.pipe(last()).subscribe((value) =\u003e console.log(value)); // 3 source.pipe(last((x) =\u003e x \u003e 2)).subscribe((value) =\u003e console.log(value)); // 3 source.pipe(last((x) =\u003e x \u003e 3, null)).subscribe((value) =\u003e console.log(value)); // null skip Der skip Operator gibt an, wie viele Ereignisse in einem Observable übersprungen werden sollen, bevor sie an einen Subscriber weitergegeben werden. Es wird verwendet, um den Startpunkt eines Observables zu verschieben.\n1 2 3 4 5 6 7 8 import { of } from \"rxjs\"; import { skip } from \"rxjs/operators\"; const source = of(1, 2, 3, 4, 5); const result = source.pipe(skip(3)); result.subscribe((value) =\u003e console.log(value)); // 4 // 5 take Der take() Operator gibt eine bestimmte Anzahl von Werten eines Observables aus und schliesst es dann ab. Der Operator akzeptiert als Parameter die Anzahl der Werte, die ausgegeben werden sollen. Wenn der Parameter nicht angegeben wird, wird standardmässig nur ein Wert ausgegeben. Sind weniger Werte verfügbar als angegeben, gibt der Operator die Anzahl Werte aus, die er zur Verfügung hat.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import { of } from \"rxjs\"; import { take } from \"rxjs/operators\"; const source = of(1, 2, 3, 4, 5); source.pipe(take(3)).subscribe((value) =\u003e console.log(value)); // 1 // 2 // 3 source.pipe(take(10)).subscribe((value) =\u003e console.log(value)); // 1 // 2 // 3 // 4 // 5 takeUntil takeUntil ist ein Operator, der ein Observable subscribed, bis ein anderes Observable ein Ereignis ausgibt. Es wird verwendet, um das Subscriben eines Observables basierend auf einem anderen Observable zu beenden.\nDas zweite Observable wird als “Abbruch- oder Trigger-Observable” bezeichnet. Sobald das Trigger-Observable ein Ereignis ausgibt, wird das Subscriben des ersten Observables beendet und das Observable gibt keine weiteren Werte mehr aus.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import { interval, Subject } from \"rxjs\"; import { takeUntil } from \"rxjs/operators\"; const stop$: Subject\u003cvoid\u003e = new Subject\u003cvoid\u003e(); // ein Observable, das jede Sekunde eine Zahl sendet const observable$ = interval(1000).pipe(takeUntil(stop$)); observable$.subscribe((val) =\u003e console.log(val)); // Observable nach 5 Sekunden stoppen setTimeout(() =\u003e { stop$.next(); stop$.complete(); }, 5000); // 0 // 1 // 2 // 3 // 4 In der Praxis wird takeUntil häufig in Kombination mit ngOnDestroy verwendet. ngOnDestroy()ist eine Lifecycle-Methode welche aufgerufen wird, bevor eine Komponente aus dem DOM entfernt wird. Somit kann man takeUntil verwenden, um Subscriptions zu beenden und somit Ressourcen freizugeben und Speicherlecks zu vermeiden.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import { Component, OnInit, OnDestroy } from \"@angular/core\"; import { interval, Subject } from \"rxjs\"; import { takeUntil } from \"rxjs/operators\"; @Component({ // .. }) export class WeaponComponent implements OnInit, OnDestroy { private destroy$: Subject\u003cvoid\u003e = new Subject\u003cvoid\u003e(); // Ein Subject erstellen, das das Zerstören des Observable signalisiert ngOnInit() { interval(1000) .pipe(takeUntil(this.destroy$)) // Das Observable subscriben und es beenden, wenn das destroy$-Subject ein Ereignis auslöst .subscribe((value) =\u003e console.log(value)); } ngOnDestroy() { this.destroy$.next(); // Das destroy$-Subject ein Ereignis auslösen, um das Observable zu beenden this.destroy$.complete(); // Das destroy$-Subject komplett schliessen, um Speicherlecks zu vermeiden } } Error Handling Operators catchError catchError ist ein Operator, der verwendet wird, um Fehler in Observables zu verarbeiten. Er erlaubt es, ein alternatives Observable zurückzugeben oder eine andere Aktion auszuführen, wenn ein Fehler im ursprünglichen Observable auftritt.\nDenn normalerweise ist es so, dass im Falle eines Fehler in einem Observable, das gesamte Observable abgebrochen wird und keine weiteren Werte emittiet werden. Wenn man jedoch catchError verwendet, kann man eine Funktion angeben, die den Fehler verarbeitet und ein alternatives Observable zurückgibt. Dadurch kann man das Observable weiterlaufen lassen, anstatt es abzubrechen.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import { of } from \"rxjs\"; import { catchError, map } from \"rxjs/operators\"; const source = of(1, 2, 3, 4, 5); const result = source.pipe( map((value) =\u003e { if (value === 3) { throw new Error(\"Value cannot be 3\"); } return value; }), catchError((error) =\u003e { console.log(`Caught error: ${error}`); return of(\"one\", \"two\"); }), ); result.subscribe({ next: (value) =\u003e { console.log(`Result: ${value}`); }, error: (error) =\u003e { console.log(`Error: ${error}`); }, complete: () =\u003e { console.log(\"Complete\"); }, }); // Result: 1 // Result: 2 // Caught error: Error: Value cannot be 3 // Result: one // Result: two // Complete retry retry() versucht, das Observable beim ersten Fehler neu zu starten. Dabei wird das gesamte Observable neu subscribed. Wenn das erneute Subscriben wieder einen Fehler erzeugt, wird das Observable erneut neu gestartet und so weiter, bis das erneute Subscriben erfolgreich ist.\nWenn man dies aber nicht unbegrenzt lange machen möchte, bis man erfolgreich ist, kann man die Anzahl der Wiederholungen als Parameter im retry()-Operator mitgeben.\nIn der Praxis verwendet man retry() oft, um API-Requests zu wiederholen, wenn sie fehlschlagen sollten, da sie eventuell zu lange gebraucht haben.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import { interval } from \"rxjs\"; import { retry, map } from \"rxjs/operators\"; const result = interval(1000).pipe( map((value) =\u003e { if (Math.random() \u003c 0.5) { throw new Error(\"Something went wrong\"); } return value; }), retry(2), ); result.subscribe( (value) =\u003e console.log(\"Value: \", value), (error) =\u003e console.log(\"Error: \", error), ); Utility Operators tap Das tap Operator ermöglicht es, “side actions” auf den Werten auszuführen, die von einem Observable emittiert werden, ohne die emittierten Werte zu verändern. Man kann es verwenden, um die emittierten Werte zu debuggen und zu untersuchen oder um eine Aktion auf Grundlage dieser Werte auszulösen, ohne die Observable-Pipeline zu beeinflussen.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import { tap } from \"rxjs/operators\"; import { of } from \"rxjs\"; const source = of(1, 2, 3); source .pipe( tap((value) =\u003e console.log(`Value before: ${value}`)), tap((value) =\u003e value * 2), tap((value) =\u003e console.log(`Value after: ${value}`)), ) .subscribe((value) =\u003e console.log(value)); // Value before: 1 // Value after: 1 // 1 // Value before: 2 // Value after: 2 // 2 // Value before: 3 // Value after: 3 // 3 delay delay verzögert das Weiterleiten von Werten eines Observables um eine bestimmte Zeitspanne. Dadurch kann man eine Verzögerung in der Ausführung von Aktionen erzielen, was besonders nützlich ist, wenn man z.B. Animationen oder Zeitabhängigkeiten implementiert.\n1 2 3 4 5 6 7 import { delay, of } from \"rxjs\"; const source = of(1, 2, 3, 4, 5); const delayedSource = source.pipe(delay(1000)); // dauert eine Sekunde bis alle Werte ausgegben werden delayedSource.subscribe((value) =\u003e console.log(value)); Conditional and Boolean Operators every Der every Operator prüft, ob alle Werte, die von einem Observable emittiert werden, eine bestimmte Bedingung erfüllen. Wenn die Bedingung für alle Werte true zurückgibt, gibt der Operator true zurück. Wenn die Bedingung für mindestens einen Wert false zurückgibt, gibt auch der Operator false zurück.\n1 2 3 4 5 6 7 8 9 10 import { from } from \"rxjs\"; import { every } from \"rxjs/operators\"; const source = from([1, 2, 3, 4, 5]); const resultTrue = source.pipe(every((value) =\u003e value \u003c 6)); const resultFalse = source.pipe(every((value) =\u003e value \u003c 5)); resultTrue.subscribe(console.log); // Output: true resultFalse.subscribe(console.log); // Output: false find find ist ein Operator, welcher es ermöglicht, in einem Observable nach dem ersten Element zu suchen, das eine angegebene Bedingung erfüllt. Wenn das Element gefunden wird, wird es in einem Observable zurückgegeben und die Suche wird beendet.\n1 2 3 4 5 6 7 8 9 10 11 12 import { from } from \"rxjs\"; import { find } from \"rxjs/operators\"; const numbers = from([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]); numbers.pipe(find((x) =\u003e x \u003e 5)).subscribe( (value) =\u003e console.log(value), // 6 ); numbers.pipe(find((x) =\u003e x \u003e 10)).subscribe( (value) =\u003e console.log(value), // undefined ); findIndex Der findIndex Operator gibt den Index des ersten Elements in eines Observables zurück, das die angegebene Bedingung erfüllt. Sie funktioniert ähnlich wie find, aber gibt den Index des Elements statt des Elements selbst zurück.\n1 2 3 4 5 6 7 8 9 10 11 import { findIndex, from } from \"rxjs\"; const numbers = from([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]); numbers.pipe(findIndex((x) =\u003e x \u003e 5)).subscribe( (value) =\u003e console.log(value), // 5 ); numbers.pipe(findIndex((x) =\u003e x \u003e 10)).subscribe( (value) =\u003e console.log(value), // -1 ); isEmpty isEmpty ist ein Operator, welcher prüft, ob ein Observable leer ist. Wenn das Observable leer ist, gibt der Operator true zurück, andernfalls false.\n1 2 3 4 5 6 7 8 9 10 11 import { of } from \"rxjs\"; import { isEmpty } from \"rxjs/operators\"; const emptySource = of(); const fullSource = of(1, 2, 3, 4, 5); const emptyObservable = emptySource.pipe(isEmpty()); const fullObseravle = fullSource.pipe(isEmpty()); emptyObservable.subscribe((value) =\u003e console.log(value)); // true fullObseravle.subscribe((value) =\u003e console.log(value)); // false ","categories":"","description":"Modul #F6 - Angular - RxJS Operators\n","excerpt":"Modul #F6 - Angular - RxJS Operators\n","ref":"/docs/03_web/06_angular/05_3_rxjs-operators/","tags":"","title":"RxJS Operators"},{"body":"Ziele Du kennst die verschiedenen RxJS-Operatoren und kannst diese anwenden. Operators RxJS bietet eine Vielzahl von Operatoren, die auf Observables angewendet werden können, um sie zu transformieren, zu filtern, zu kombinieren und vieles mehr. Folgend werden die wichtigsten vorgestellt.\nPiping Die pipe() ist ein wichtiger Operator, der es ermöglicht, eine Observable-Kette zu erstellen, indem verschiedene Operatoren nacheinander angewendet werden. Der Piping-Operator wird verwendet, um die Lesbarkeit und Wartbarkeit von Observable-Ketten zu verbessern, indem man sie in kleinere und leichter zu verstehende Abschnitte unterteilt. Wie eine map funktioniert, kannst du hier nachlesen.\n1 2 3 4 5 6 7 8 9 import { of, map } from \"rxjs\"; of(1, 2, 3) .pipe(map((x) =\u003e x * x)) .subscribe((v) =\u003e console.log(`value: ${v}`)); // value: 1 // value: 4 // value: 9 Creation Operators from Der from-Operator wandelt eine Reihe von Werten oder ein Iterable in ein Observable um. Er akzeptiert eine Quelle von Werten, wie beispielsweise ein Array oder eine Map, und gibt ein Observable zurück, das die Werte dieser Quelle nacheinander emittiert.\nDer from-Operator ist daher primär für Werte geeignet, die aus verschiedenen dynamischen Quellen resultieren. Er splittet die Eingabe, was der of-Operator nicht tut. Mögliche Argumente sind dabei subscribable Objects, Promises, Observable-artige Objekte, Arrays, iterierbare Datenstrukturen oder ein Array-artige Objekte.\n1 2 3 4 5 6 7 8 9 10 11 import { from } from \"rxjs\"; const source = from([1, 2, 3, 4, 5]); source.subscribe((value) =\u003e console.log(value)); // 1 // 2 // 3 // 4 // 5 of Der of-Operator wandelt wie der from-Operator auch eine feste Anzahl von Werten in ein Observable um. Der Operator akzeptiert jedoch eine beliebige Anzahl von Argumenten und gibt ein Observable zurück, das diese Argumente in der Reihenfolge ihres Auftretens emittiert.\nDieser Operator ist besonders nützlich, um eine feste Anzahl von Werten zu emittieren, die bekannt sind, bevor das Observable abonniert wird. Wenn man eine Quelle von Werten hat, die dynamisch generiert werden, ist es wahrscheinlich sinnvoller, den from Operator zu verwenden.\n1 2 3 4 5 6 7 8 9 10 11 import { of } from \"rxjs\"; const source = of(1, 2, 3, 4, 5); source.subscribe((value) =\u003e console.log(value)); // 1 // 2 // 3 // 4 // 5 Join Creation Operators Info: In RxJS bezieht sich “Emission” auf den Wert, der von einem Observable emittiert / ausgegeben wird.\nforkJoin forkJoin ist ein Kombinationsoperator, der ein Array von Observables akzeptiert und wartet, bis alle Observables ihre Emissionen abgeschlossen haben, bevor er ein neues Observable zurückgibt. Das zurückgegebene Observable gibt ein Array von Werten zurück, das den letzten Wert jedes Observables enthält, das dem forkJoin Operator übergeben wurde.\nDieser Operator ist besonders nützlich, wenn man mehrere Quellen von Daten hat, die parallel verarbeitet werden können, und man auf alle Ergebnisse warten muss, bevor man mit der nächsten Phase der Verarbeitung fortfahren kann.\nZu beachten ist, dass der Operator fehlschlägt, wenn eines der übergebenen Observables einen Fehler emittiert, bevor es seine Emissionen abgeschlossen hat.\n1 2 3 4 5 6 7 8 9 10 import { forkJoin, of } from \"rxjs\"; const source1 = of(\"Hello\"); const source2 = of(\"World!\"); forkJoin([source1, source2]).subscribe(([value1, value2]) =\u003e { console.log(value1 + \" \" + value2); }); // \"Hello World!\" concat Der concat-Operator kombiniert mehrere Observables sequentiell, indem er die Emissionen des ersten Observables vollständig verarbeitet, bevor er mit dem nächsten Observable fortfährt. Das bedeutet, dass das zweite Observable erst dann subscribed wird, wenn das erste Observable seine Emissionen vollständig abgeschlossen hat und so weiter.\nDieser Operator ist besonders nützlich, wenn man sicherstellen muss, dass bestimmte Aktionen in einer bestimmten Reihenfolge ausgeführt werden, oder wenn man die Emissionen von Observables in einer bestimmten Sequenz verarbeiten muss.\nZu beachten ist jedoch, dass der Operator blockierend ist und erst dann zur nächsten Phase der Verarbeitung übergeht, wenn das vorherige Observable abgeschlossen wurde.\n1 2 3 4 5 6 7 8 9 10 11 import { concat, of } from \"rxjs\"; const source1 = of(\"Hello\"); const source2 = of(\"Dragon Warrior!\"); concat(source1, source2).subscribe((value) =\u003e { console.log(value); }); // \"Hello\" // \"Dragon Warrior!\" merge Der merge-Operator kombiniert auch mehrere Observables, indem er die Emissionen aller Observables in einem einzigen Observable zusammenführt. Im Gegensatz zum concat-Operator führt der merge-Operator die Emissionen parallel aus, unabhängig davon, welches Observable die Emissionen zuerst ausgibt.\nBeachten muss man jedoch, dass dieser Operator keine Garantie für die Reihenfolge der Emissionen gibt und dass es möglich ist, dass die Emissionen der Observables sich gegenseitig überschneiden.\n1 2 3 4 5 6 7 8 9 10 11 import { merge, of } from \"rxjs\"; const source1 = of(\"Hello\"); const source2 = of(\"Dragon Warrior!\"); merge(source1, source2).subscribe((value) =\u003e { console.log(value); }); // \"Hello\" // \"Dragon Warrior!\" zip Der zip Operator kombiniert die Emissionen mehrerer Observables zu einer einzelnen Emission. Dabei werden die Emissionen jedes Observables zu einer Gruppe kombiniert, und sobald alle Observables eine Emission abgegeben haben, wird diese Gruppe als Emission des resultierenden Observables ausgegeben.\nDieser Operator ist besonders nützlich, wenn man mehrere Datenströme kombiniert und sicherstellen muss, dass alle Daten synchronisiert sind. Man muss jedoch beachten, dass der Operator die Emissionen jedes Observables zu einer Gruppe kombiniert, was bedeutet, dass die Grösse jeder Emission vom Observable mit der geringsten Anzahl an Emissionen begrenzt wird.\nAuch zu beachten ist, dass der Operator darauf wartet, dass alle Observables eine Emission abgeben, bevor er eine Emission ausgibt. Wenn ein Observable keine Emission abgibt, wird das resultierende Observable keine Emissionen ausgeben.\nDer Hauptunterschied vom zip-Operator zum forkJoin-Operator ist, dass mit zip die reinkommenden Werte Schritt für Schritt kombiniert werden, während forkJoin die Werte erst emittiert, nachdem alle Input-Observables completed wurden.\n1 2 3 4 5 6 7 8 9 10 11 import { zip, of } from \"rxjs\"; const source1 = of(\"Hello\"); const source2 = of(\"Dragon\"); const source3 = of(\"Warrior\"); zip(source1, source2, source3).subscribe((value) =\u003e { console.log(value); }); // [\"Hello\", \"Dragon\", \"Warrior\"] Transformation Operators map Der meist verwendete RxJS-Operator ist der map Operator. Dieser wird verwendet, um die Werte eines Observables zu transformieren. Es gibt viele Anwendungsfälle für diesen Operator, einschliesslich der Umwandlung von Daten in ein anderes Format, der Extraktion von bestimmten Werten aus einem Datenstrom oder der Anwendung einer Funktion auf jeden Wert in einem Observable.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import { of } from \"rxjs\"; import { map } from \"rxjs/operators\"; const source = of(1, 2, 3, 4, 5); const doubled = source.pipe(map((value) =\u003e value * 2)); doubled.subscribe((value) =\u003e console.log(value)); // 2 // 4 // 6 // 8 // 10 mergeAll/mergeMap Es kann passieren, dass ein Observable eine Methode aufruft, die ein weiteres Observable zurückgibt. Dieser Verhalten kommt oft bei API-Abfragen vor. Somit hat man dann ein äusseres und inneres Observable. Um nun an die Daten zu gelangen, müsste man auf beide subscriben, was auch möglich ist:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import { of, from, map } from \"rxjs\"; const getData = (param) =\u003e { return of(`retrieved new data with param ${param}`); }; from([1, 2, 3, 4]) .pipe(map((param) =\u003e getData(param))) .subscribe((value) =\u003e value.subscribe((data) =\u003e console.log(data))); // retrieved new data with param 1 // retrieved new data with param 2 // retrieved new data with param 3 // retrieved new data with param 4 Das ist aber alles andere als optimal, weshalb man alternativ mergeMap benutzen kann. mergeMap ist eine Kombination von mergeAll und map. mergeAll erledigt die subscription auf das innere Observable, auf diese Weise muss man dann nicht mehr zweimal subscriben. Zudem merged es das innere Observable in das äussere.\nBeispiel mit mergeAll:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import { of, from, map, mergeAll } from \"rxjs\"; const getData = (param) =\u003e { return of(`retrieved new data with param ${param}`); }; from([1, 2, 3, 4]) .pipe( map((param) =\u003e getData(param)), mergeAll(), ) .subscribe((value) =\u003e console.log(value)); // retrieved new data with param 1 // retrieved new data with param 2 // retrieved new data with param 3 // retrieved new data with param 4 Beispiel mit mergeMap:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import { of, from, mergeMap } from \"rxjs\"; const getData = (param) =\u003e { return of(`retrieved new data with param ${param}`); }; from([1, 2, 3, 4]) .pipe(mergeMap((param) =\u003e getData(param))) .subscribe((value) =\u003e console.log(value)); // retrieved new data with param 1 // retrieved new data with param 2 // retrieved new data with param 3 // retrieved new data with param 4 Hinweis: Oft wird flatMap als Alias für mergeMap verwendet. Lass dich also nicht verwirren, wenn die Begriffe teilweise wechseln.\nswitchAll/switchMap switchMap funktioniert ähnlich wie mergeMap. Der Operator subscribed auch auf das innere Observable. Auch hier ist switchMap eine Kombination, und zwar von switchAll und map. switchAll canceled die vorherige Subscription und subscribed auf die neue, wenn ein neues Observable reinkommt.\nHier kannst du nachlesen, wie delay funktioniert.\nBeispiel mit switchAll:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import { of, from, map, switchAll, delay } from \"rxjs\"; const getData = (param) =\u003e { return of(`retrieved new data with param ${param}`).pipe(delay(1000)); }; from([1, 2, 3, 4]) .pipe( map((param) =\u003e getData(param)), switchAll(), ) .subscribe((value) =\u003e console.log(value)); // retrieved new data with param 4 Beispiel mit switchMap:\n1 2 3 4 5 6 7 8 9 10 11 import { of, from, switchMap, delay } from \"rxjs\"; const getData = (param) =\u003e { return of(`retrieved new data with param ${param}`).pipe(delay(1000)); }; from([1, 2, 3, 4]) .pipe(switchMap((param) =\u003e getData(param))) .subscribe((value) =\u003e console.log(value)); // retrieved new data with param 4 concatMap Auch concatMap subscribed auf das innere Observable. Der Unterschied zu switchMap ist, dass concatMap nicht die Subscription cancelled, wenn ein neues Observable reinkommt. Es subscribed stattdessen solange nicht auf das nächste Observable, bis das momentane fertig ist.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import { of, from } from \"rxjs\"; import { delay, concatMap } from \"rxjs/operators\"; const getData2 = (param) =\u003e { return of(`2 retrieved new data with param ${param}`).pipe(delay(1000)); }; from([1, 2, 3, 4]) .pipe(concatMap((param) =\u003e getData2(param))) .subscribe((value) =\u003e console.log(value)); // [wait 1s] // 2 retrieved new data with param 1 // [wait 1s] // 2 retrieved new data with param 2 // 2 [wait 1s] // 2 retrieved new data with param 3 // [wait 1s] // 2 retrieved new data with param 4 groupBy Die groupBy()-Methode ermöglicht es, ein Observable in mehrere Observables aufzuteilen, die auf der Grundlage eines bestimmten Schlüssels gruppiert sind.\nDer Prozess besteht darin, die ursprünglichen Emissionen in Gruppen aufzuteilen, die jeweils auf einen eindeutigen Schlüssel abgebildet werden. Jede Gruppe ist ein eigenes Observable, das alle Emissionen enthält, die diesem Schlüssel zugeordnet sind.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import { from } from \"rxjs\"; import { groupBy, mergeMap, toArray } from \"rxjs/operators\"; interface Person { name: string; age: number; } const people: Person[] = from([ { name: \"John\", age: 30 }, { name: \"Jane\", age: 25 }, { name: \"Bob\", age: 30 }, { name: \"Alice\", age: 25 }, ]); people .pipe( groupBy((person) =\u003e person.age), mergeMap((group) =\u003e group.pipe(toArray())), ) .subscribe((group) =\u003e console.log(group)); // [ { name: 'Jane', age: 25 }, { name: 'Alice', age: 25 } ] // [ { name: 'John', age: 30 }, { name: 'Bob', age: 30 } ] Filtering Operators elementAt elementAt() wird benutzt, um ein Element eines Observable an der angegebenen Indexposition auszugeben und das Observable zu schliessen. Der Operator gibt ein Observable zurück, das nur das angeforderte Element emittiert und dann vollständig geschlossen wird.\nMan kann nach der Indexposition auch einen Defaultwert angeben, welcher zurückgegeben wird, wenn das Element an der angegebenen Indexposition nicht gefunden wurde.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import { of } from \"rxjs\"; import { elementAt } from \"rxjs/operators\"; const source$ = of(\"A\", \"B\", \"C\", \"D\", \"E\"); // ohne Defaultwert source$ .pipe( elementAt(2), // 'C' ) .subscribe(console.log); // mit Defaultwert source$ .pipe( elementAt(10, \"F\"), // 'F' ) .subscribe(console.log); filter filter wird verwendet, um Observable-Elemente zu filtern, die nicht den Bedingungen entsprechen, die in der übergebenen Funktion definiert wurden. Die Filterfunktion gibt ein neues Observable zurück, das nur Elemente enthält, die die Bedingungen der Filterfunktion erfüllen.\n1 2 3 4 5 6 7 8 import { of } from \"rxjs\"; import { filter } from \"rxjs/operators\"; const source = of(1, 2, 3, 4, 5); const filtered = source.pipe(filter((x) =\u003e x % 2 === 0)); filtered.subscribe((x) =\u003e console.log(x)); // 2 // 4 first Der first Operator gibt nur das erste Element aus einem Observable zurück. Man kann den Operator aber auch mittels einer Funktion ergänzen, um eine Bedienung zu schaffen, somit wird dann das erste Element zurückgegeben, welches auf diese Bedingung zutrifft. Nach der Funktion kann man auch einen Defaultwert hinzufügen, welcher zurückgegeben werden soll, wenn kein Element gefunden wird. Gibt man keinen Defaultwert an und die Bedingung trifft nicht zu, so wird ein fehler ausgegeben.\n1 2 3 4 5 6 7 8 9 10 import { of } from \"rxjs\"; import { first } from \"rxjs/operators\"; const source = of(1, 2, 3); source.pipe(first()).subscribe((value) =\u003e console.log(value)); // 1 source.pipe(first((x) =\u003e x \u003e 2)).subscribe((value) =\u003e console.log(value)); // 3 source.pipe(first((x) =\u003e x \u003e 3, null)).subscribe((value) =\u003e console.log(value)); // null last Der last Operator funktioniert genau gleich wie der first Operator. Nur ist es so, dass hier immer das letzte Element zurückgegeben wird.\n1 2 3 4 5 6 7 8 9 10 import { of } from \"rxjs\"; import { first, last } from \"rxjs/operators\"; const source = of(1, 2, 3); source.pipe(last()).subscribe((value) =\u003e console.log(value)); // 3 source.pipe(last((x) =\u003e x \u003e 2)).subscribe((value) =\u003e console.log(value)); // 3 source.pipe(last((x) =\u003e x \u003e 3, null)).subscribe((value) =\u003e console.log(value)); // null skip Der skip Operator gibt an, wie viele Ereignisse in einem Observable übersprungen werden sollen, bevor sie an einen Subscriber weitergegeben werden. Es wird verwendet, um den Startpunkt eines Observables zu verschieben.\n1 2 3 4 5 6 7 8 import { of } from \"rxjs\"; import { skip } from \"rxjs/operators\"; const source = of(1, 2, 3, 4, 5); const result = source.pipe(skip(3)); result.subscribe((value) =\u003e console.log(value)); // 4 // 5 take Der take() Operator gibt eine bestimmte Anzahl von Werten eines Observables aus und schliesst es dann ab. Der Operator akzeptiert als Parameter die Anzahl der Werte, die ausgegeben werden sollen. Wenn der Parameter nicht angegeben wird, wird standardmässig nur ein Wert ausgegeben. Sind weniger Werte verfügbar als angegeben, gibt der Operator die Anzahl Werte aus, die er zur Verfügung hat.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import { of } from \"rxjs\"; import { take } from \"rxjs/operators\"; const source = of(1, 2, 3, 4, 5); source.pipe(take(3)).subscribe((value) =\u003e console.log(value)); // 1 // 2 // 3 source.pipe(take(10)).subscribe((value) =\u003e console.log(value)); // 1 // 2 // 3 // 4 // 5 takeUntil takeUntil ist ein Operator, der ein Observable subscribed, bis ein anderes Observable ein Ereignis ausgibt. Es wird verwendet, um das Subscriben eines Observables basierend auf einem anderen Observable zu beenden.\nDas zweite Observable wird als “Abbruch- oder Trigger-Observable” bezeichnet. Sobald das Trigger-Observable ein Ereignis ausgibt, wird das Subscriben des ersten Observables beendet und das Observable gibt keine weiteren Werte mehr aus.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import { interval, Subject } from \"rxjs\"; import { takeUntil } from \"rxjs/operators\"; const stop$: Subject\u003cvoid\u003e = new Subject\u003cvoid\u003e(); // ein Observable, das jede Sekunde eine Zahl sendet const observable$ = interval(1000).pipe(takeUntil(stop$)); observable$.subscribe((val) =\u003e console.log(val)); // Observable nach 5 Sekunden stoppen setTimeout(() =\u003e { stop$.next(); stop$.complete(); }, 5000); // 0 // 1 // 2 // 3 // 4 In der Praxis wird takeUntil häufig in Kombination mit ngOnDestroy verwendet. ngOnDestroy()ist eine Lifecycle-Methode welche aufgerufen wird, bevor eine Komponente aus dem DOM entfernt wird. Somit kann man takeUntil verwenden, um Subscriptions zu beenden und somit Ressourcen freizugeben und Speicherlecks zu vermeiden.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import { Component, OnInit, OnDestroy } from \"@angular/core\"; import { interval, Subject } from \"rxjs\"; import { takeUntil } from \"rxjs/operators\"; @Component({ // .. }) export class WeaponComponent implements OnInit, OnDestroy { private destroy$: Subject\u003cvoid\u003e = new Subject\u003cvoid\u003e(); // Ein Subject erstellen, das das Zerstören des Observable signalisiert ngOnInit() { interval(1000) .pipe(takeUntil(this.destroy$)) // Das Observable subscriben und es beenden, wenn das destroy$-Subject ein Ereignis auslöst .subscribe((value) =\u003e console.log(value)); } ngOnDestroy() { this.destroy$.next(); // Das destroy$-Subject ein Ereignis auslösen, um das Observable zu beenden this.destroy$.complete(); // Das destroy$-Subject komplett schliessen, um Speicherlecks zu vermeiden } } Error Handling Operators catchError catchError ist ein Operator, der verwendet wird, um Fehler in Observables zu verarbeiten. Er erlaubt es, ein alternatives Observable zurückzugeben oder eine andere Aktion auszuführen, wenn ein Fehler im ursprünglichen Observable auftritt.\nDenn normalerweise ist es so, dass im Falle eines Fehler in einem Observable, das gesamte Observable abgebrochen wird und keine weiteren Werte emittiet werden. Wenn man jedoch catchError verwendet, kann man eine Funktion angeben, die den Fehler verarbeitet und ein alternatives Observable zurückgibt. Dadurch kann man das Observable weiterlaufen lassen, anstatt es abzubrechen.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import { of } from \"rxjs\"; import { catchError, map } from \"rxjs/operators\"; const source = of(1, 2, 3, 4, 5); const result = source.pipe( map((value) =\u003e { if (value === 3) { throw new Error(\"Value cannot be 3\"); } return value; }), catchError((error) =\u003e { console.log(`Caught error: ${error}`); return of(\"one\", \"two\"); }), ); result.subscribe({ next: (value) =\u003e { console.log(`Result: ${value}`); }, error: (error) =\u003e { console.log(`Error: ${error}`); }, complete: () =\u003e { console.log(\"Complete\"); }, }); // Result: 1 // Result: 2 // Caught error: Error: Value cannot be 3 // Result: one // Result: two // Complete retry retry() versucht, das Observable beim ersten Fehler neu zu starten. Dabei wird das gesamte Observable neu subscribed. Wenn das erneute Subscriben wieder einen Fehler erzeugt, wird das Observable erneut neu gestartet und so weiter, bis das erneute Subscriben erfolgreich ist.\nWenn man dies aber nicht unbegrenzt lange machen möchte, bis man erfolgreich ist, kann man die Anzahl der Wiederholungen als Parameter im retry()-Operator mitgeben.\nIn der Praxis verwendet man retry() oft, um API-Requests zu wiederholen, wenn sie fehlschlagen sollten, da sie eventuell zu lange gebraucht haben.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import { interval } from \"rxjs\"; import { retry, map } from \"rxjs/operators\"; const result = interval(1000).pipe( map((value) =\u003e { if (Math.random() \u003c 0.5) { throw new Error(\"Something went wrong\"); } return value; }), retry(2), ); result.subscribe( (value) =\u003e console.log(\"Value: \", value), (error) =\u003e console.log(\"Error: \", error), ); Utility Operators tap Das tap Operator ermöglicht es, “side actions” auf den Werten auszuführen, die von einem Observable emittiert werden, ohne die emittierten Werte zu verändern. Man kann es verwenden, um die emittierten Werte zu debuggen und zu untersuchen oder um eine Aktion auf Grundlage dieser Werte auszulösen, ohne die Observable-Pipeline zu beeinflussen.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import { tap } from \"rxjs/operators\"; import { of } from \"rxjs\"; const source = of(1, 2, 3); source .pipe( tap((value) =\u003e console.log(`Value before: ${value}`)), tap((value) =\u003e value * 2), tap((value) =\u003e console.log(`Value after: ${value}`)), ) .subscribe((value) =\u003e console.log(value)); // Value before: 1 // Value after: 1 // 1 // Value before: 2 // Value after: 2 // 2 // Value before: 3 // Value after: 3 // 3 delay delay verzögert das Weiterleiten von Werten eines Observables um eine bestimmte Zeitspanne. Dadurch kann man eine Verzögerung in der Ausführung von Aktionen erzielen, was besonders nützlich ist, wenn man z.B. Animationen oder Zeitabhängigkeiten implementiert.\n1 2 3 4 5 6 7 import { delay, of } from \"rxjs\"; const source = of(1, 2, 3, 4, 5); const delayedSource = source.pipe(delay(1000)); // dauert eine Sekunde bis alle Werte ausgegben werden delayedSource.subscribe((value) =\u003e console.log(value)); Conditional and Boolean Operators every Der every Operator prüft, ob alle Werte, die von einem Observable emittiert werden, eine bestimmte Bedingung erfüllen. Wenn die Bedingung für alle Werte true zurückgibt, gibt der Operator true zurück. Wenn die Bedingung für mindestens einen Wert false zurückgibt, gibt auch der Operator false zurück.\n1 2 3 4 5 6 7 8 9 10 import { from } from \"rxjs\"; import { every } from \"rxjs/operators\"; const source = from([1, 2, 3, 4, 5]); const resultTrue = source.pipe(every((value) =\u003e value \u003c 6)); const resultFalse = source.pipe(every((value) =\u003e value \u003c 5)); resultTrue.subscribe(console.log); // Output: true resultFalse.subscribe(console.log); // Output: false find find ist ein Operator, welcher es ermöglicht, in einem Observable nach dem ersten Element zu suchen, das eine angegebene Bedingung erfüllt. Wenn das Element gefunden wird, wird es in einem Observable zurückgegeben und die Suche wird beendet.\n1 2 3 4 5 6 7 8 9 10 11 12 import { from } from \"rxjs\"; import { find } from \"rxjs/operators\"; const numbers = from([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]); numbers.pipe(find((x) =\u003e x \u003e 5)).subscribe( (value) =\u003e console.log(value), // 6 ); numbers.pipe(find((x) =\u003e x \u003e 10)).subscribe( (value) =\u003e console.log(value), // undefined ); findIndex Der findIndex Operator gibt den Index des ersten Elements in eines Observables zurück, das die angegebene Bedingung erfüllt. Sie funktioniert ähnlich wie find, aber gibt den Index des Elements statt des Elements selbst zurück.\n1 2 3 4 5 6 7 8 9 10 11 import { findIndex, from } from \"rxjs\"; const numbers = from([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]); numbers.pipe(findIndex((x) =\u003e x \u003e 5)).subscribe( (value) =\u003e console.log(value), // 5 ); numbers.pipe(findIndex((x) =\u003e x \u003e 10)).subscribe( (value) =\u003e console.log(value), // -1 ); isEmpty isEmpty ist ein Operator, welcher prüft, ob ein Observable leer ist. Wenn das Observable leer ist, gibt der Operator true zurück, andernfalls false.\n1 2 3 4 5 6 7 8 9 10 11 import { of } from \"rxjs\"; import { isEmpty } from \"rxjs/operators\"; const emptySource = of(); const fullSource = of(1, 2, 3, 4, 5); const emptyObservable = emptySource.pipe(isEmpty()); const fullObseravle = fullSource.pipe(isEmpty()); emptyObservable.subscribe((value) =\u003e console.log(value)); // true fullObseravle.subscribe((value) =\u003e console.log(value)); // false ","categories":"","description":"Modul #F6 - Angular - RxJS Operators\n","excerpt":"Modul #F6 - Angular - RxJS Operators\n","ref":"/de/docs/03_web/06_angular/05_3_rxjs-operators/","tags":"","title":"RxJS Operators"},{"body":"Ziele Du weisst, was Signals in Angular sind und wie man diese verwendet. Signals Signals funktionieren in Angular ähnlich wie Observables. Ein Signal umfasst einen Wrapper um einen Wert, welcher Konsumenten benachrichtigen kann, wenn sich der Wert ändert. Signals gibt es als Read-Only- oder als Writable-Variante. Der Wert eines Signals wird immer durch eine getter-function gelesen. Wenn man ein Signal aufruft, wird der Wert darin gelesen. Man kann Signals von primitiven bis hin zu komplexen Datenstrukturen definieren.\nWritable Signals Ein writable Signal kann ganz einfach erstellt werden, nämlich indem man die signal()-Funktion mit dem initialen Wert aufruft.\n1 2 3 4 5 import { signal } from \"@angular/core\"; const count = signal(0); // Signals are getter functions - calling them reads their value. console.log(\"The count is: \" + count()); Wenn man den gesamten Wert unabhängig vom momentanen ändern möchte, kann man .set() aufrufen.\n1 count.set(3); Möchte man jedoch mithilfe des momentanen Wertes etwas machen, muss man .update() aufrufen.\n1 2 // Increment the count by 1. count.update((value) =\u003e value + 1); Die Variable count nimmt übrigens automatisch den Typ WritableSignal an.\nComputed signals (Read-Only) Ein Computed Signal erhält seinen Wert von einem andern Signal, meist von einem Writable Signal. Möchte man ein Computed Signal erstellen, muss die computed() Funktion verwendet werden.\n1 2 const count: WritableSignal\u003cnumber\u003e = signal(0); const doubleCount: Signal\u003cnumber\u003e = computed(() =\u003e count() * 2); Bei einem Computed Signal kann man nicht direkt einen wert mit .set() setzen, wie es bei den Writable Signals der Fall ist. Es wird einen Compilation Error geben, wenn man das versucht.\nlazily evaluated and memoized Der Wert des Computed Signals wird so lange nicht berechnet, bis man es aufruft, danach wird der Wert gecached. Wenn man nun den Wert des Computed Signals erneut liest, wird es nicht neu berechnet, sondern nimmt den Wert aus dem Cache. Wenn man jedoch das Writable Signal, welches im Computed Signal verwendet wird, ändert, weiss Angular, dass der Wert im Cache für das Computed Signal nicht mehr valide ist. Somit wird der Wert neu berechnet wenn man das Computed Signal das nächste Mal aufruft und wieder darin gespeichert.\nComputed signal dependencies are dynamic Es werden nur die Signals getracked, die während der Ableitung auch gelesen werden.\nZum Beispiel wird im folgenden Beispiel das Signal count nur gelesen, wenn das Signal showCount true entspricht.\n1 2 3 4 5 6 7 8 9 const showCount = signal(false); const count = signal(0); const conditionalCount = computed(() =\u003e { if (showCount()) { return `The count is ${count()}.`; } else { return \"Nothing to see here!\"; } }); Beim Lesen von conditionalCount wird, wenn showCount false ist, die Nachricht “Nothing to see here!” zurückgegeben, ohne das Signal count zu lesen. Das bedeutet, dass eine spätere Aktualisierung von count nicht dazu führt, dass conditionalCount neu berechnet wird.\nWenn showCount auf true gesetzt wird und dann erneut conditionalCount gelesen wird, wird die Ableitung erneut ausgeführt und der Zweig ausgeführt, in dem showCount wahr ist. Es wird die Nachricht zurückgegeben, die den Wert von count anzeigt. Eine Änderung von count würde dann den zwischengespeicherten Wert von `conditionalCount ungültig machen.\nZu beachten ist, dass Dependencies während einer Ableitung sowohl hinzugefügt als auch entfernt werden können. Wenn showCount später wieder auf false gesetzt wird, wird count nicht mehr als Dependency von conditionalCount betrachtet.\nEffects Signals sind ein interessanter Aspekt in Angular, da sie consumers benachrichtigen, wenn sie sich ändern. Der effect ist eine Operation, welche ausgeführt wird, sobald sich ein oder mehrere Werte eines Signals ändern. effects werden folgendermassen erstellt:\n1 2 3 effect(() =\u003e { console.log(`The current count is: ${count()}`); }); effects werden immer mindestens einmal ausgeführt. Wenn ein effect ausgeführt wird, verfolgt er alle gelesenen Werte des Signals. Immer wenn sich einer dieser Werte ändert, wird der effect erneut ausgeführt. Ähnlich wie bei Computed Signals verfolgen effects ihre Dependencies dynamisch und erfassen nur Signals, die in der aktuellsten Ausführung gelesen wurden. effects werden immer asynchron während des Change-Detection-Prozesses ausgeführt.\neffects werden in den meisten Anwendungsfällen nur selten benötigt, können jedoch in speziellen Situationen durchaus nützlich sein. Hier sind einige Beispiele für Situationen, in denen ein effect eine gute Lösung darstellen kann:\nLogging von angezeigten Daten und deren Änderungen, entweder für Analysezwecke oder als Debugging-Tool. Synchronisierung von Daten mit window.localStorage. Hinzufügen von benutzerdefiniertem DOM-Verhalten, das nicht mit der Template-Syntax ausgedrückt werden kann. Durchführung von benutzerdefiniertem Rendering auf einem \u003ccanvas\u003e, in einer Diagrammbibliothek oder einer anderen UI-library von Drittanbietern. Advanced topics Signal equality functions Wenn man ein Signal (egal ob Writable oder Computed) erstellt, kann man optional eine equality function angeben. Diese wird verwendet, um zu prüfen, ob ein neuer Wert sich zum vorherigen unterscheidet.\n1 2 3 4 5 6 7 import _ from \"lodash\"; const data = signal([\"test\"], { equal: _.isEqual }); // Even though this is a different array instance, the deep equality // function will consider the values to be equal, and the signal won't // trigger any updates. data.set([\"test\"]); Reading without tracking dependencies Vereinzelt ist es erforderlich, Code auszuführen, der möglicherweise Signale innerhalb einer reaktiven Funktion wie computed oder effect liest, ohne eine Dependency zu erstellen.\nNehmen wir beispielsweise an, dass bei einer Änderung von currentUser der Wert eines counters protokolliert werden soll. Es kann ein Effekt erstellen werden, der beide Signale liest:\n1 2 3 effect(() =\u003e { console.log(`User set to ${currentUser()} and the counter is ${counter}`); }); Dieses Beispiel gibt eine Meldung aus, wenn sich entweder currentUser oder counter ändert. Wenn der Effekt jedoch nur dann ausgeführt werden soll, wenn sich currentUser ändert, ist das Lesen von counter nur zufällig, und Änderungen an counter sollten keine neue Meldung protokollieren.\nMan kann verhindern, dass ein Signal-Lesen durchgeführt wird, indem man seinen Getter mit untracked aufruft:\n1 2 3 4 5 effect(() =\u003e { console.log( `User set to ${currentUser()} and the counter is ${untracked(counter)}`, ); }); untracked ist auch nützlich, wenn ein Effekt externen Code aufrufen muss, der nicht als Dependency behandelt werden soll:\n1 2 3 4 5 6 7 8 effect(() =\u003e { const user = currentUser(); untracked(() =\u003e { // If the `loggingService` reads signals, they won't be counted as // dependencies of this effect. this.loggingService.log(`User set to ${user}`); }); }); Effect cleanup functions Effekte können lang laufende Operationen starten, die abgebrochen werden sollten, wenn der Effekt zerstört wird oder bevor die erste Operation abgeschlossen ist und der Effekt erneut gestartet wird. Wenn man einen Effekt erstellt, kann die Funktion optional eine onCleanup-Funktion als ihren ersten Parameter akzeptieren. Diese onCleanup-Funktion ermöglicht es, einen Callback zu registrieren, welcher aufgerufen wird, bevor der nächste Durchlauf des Effekts beginnt oder wenn der Effekt zerstört wird.\n1 2 3 4 5 6 7 8 9 effect((onCleanup) =\u003e { const user = currentUser(); const timer = setTimeout(() =\u003e { console.log(`1 second ago, the user became ${user}`); }, 1000); onCleanup(() =\u003e { clearTimeout(timer); }); }); ","categories":"","description":"Modul #F6 - Angular - Signals in Angular\n","excerpt":"Modul #F6 - Angular - Signals in Angular\n","ref":"/docs/03_web/06_angular/05_4_signals/","tags":"","title":"Signals"},{"body":"Ziele Du weisst, was Signals in Angular sind und wie man diese verwendet. Signals Signals funktionieren in Angular ähnlich wie Observables. Ein Signal umfasst einen Wrapper um einen Wert, welcher Konsumenten benachrichtigen kann, wenn sich der Wert ändert. Signals gibt es als Read-Only- oder als Writable-Variante. Der Wert eines Signals wird immer durch eine getter-function gelesen. Wenn man ein Signal aufruft, wird der Wert darin gelesen. Man kann Signals von primitiven bis hin zu komplexen Datenstrukturen definieren.\nWritable Signals Ein writable Signal kann ganz einfach erstellt werden, nämlich indem man die signal()-Funktion mit dem initialen Wert aufruft.\n1 2 3 4 5 import { signal } from \"@angular/core\"; const count = signal(0); // Signals are getter functions - calling them reads their value. console.log(\"The count is: \" + count()); Wenn man den gesamten Wert unabhängig vom momentanen ändern möchte, kann man .set() aufrufen.\n1 count.set(3); Möchte man jedoch mithilfe des momentanen Wertes etwas machen, muss man .update() aufrufen.\n1 2 // Increment the count by 1. count.update((value) =\u003e value + 1); Die Variable count nimmt übrigens automatisch den Typ WritableSignal an.\nComputed signals (Read-Only) Ein Computed Signal erhält seinen Wert von einem andern Signal, meist von einem Writable Signal. Möchte man ein Computed Signal erstellen, muss die computed() Funktion verwendet werden.\n1 2 const count: WritableSignal\u003cnumber\u003e = signal(0); const doubleCount: Signal\u003cnumber\u003e = computed(() =\u003e count() * 2); Bei einem Computed Signal kann man nicht direkt einen wert mit .set() setzen, wie es bei den Writable Signals der Fall ist. Es wird einen Compilation Error geben, wenn man das versucht.\nlazily evaluated and memoized Der Wert des Computed Signals wird so lange nicht berechnet, bis man es aufruft, danach wird der Wert gecached. Wenn man nun den Wert des Computed Signals erneut liest, wird es nicht neu berechnet, sondern nimmt den Wert aus dem Cache. Wenn man jedoch das Writable Signal, welches im Computed Signal verwendet wird, ändert, weiss Angular, dass der Wert im Cache für das Computed Signal nicht mehr valide ist. Somit wird der Wert neu berechnet wenn man das Computed Signal das nächste Mal aufruft und wieder darin gespeichert.\nComputed signal dependencies are dynamic Es werden nur die Signals getracked, die während der Ableitung auch gelesen werden.\nZum Beispiel wird im folgenden Beispiel das Signal count nur gelesen, wenn das Signal showCount true entspricht.\n1 2 3 4 5 6 7 8 9 const showCount = signal(false); const count = signal(0); const conditionalCount = computed(() =\u003e { if (showCount()) { return `The count is ${count()}.`; } else { return \"Nothing to see here!\"; } }); Beim Lesen von conditionalCount wird, wenn showCount false ist, die Nachricht “Nothing to see here!” zurückgegeben, ohne das Signal count zu lesen. Das bedeutet, dass eine spätere Aktualisierung von count nicht dazu führt, dass conditionalCount neu berechnet wird.\nWenn showCount auf true gesetzt wird und dann erneut conditionalCount gelesen wird, wird die Ableitung erneut ausgeführt und der Zweig ausgeführt, in dem showCount wahr ist. Es wird die Nachricht zurückgegeben, die den Wert von count anzeigt. Eine Änderung von count würde dann den zwischengespeicherten Wert von `conditionalCount ungültig machen.\nZu beachten ist, dass Dependencies während einer Ableitung sowohl hinzugefügt als auch entfernt werden können. Wenn showCount später wieder auf false gesetzt wird, wird count nicht mehr als Dependency von conditionalCount betrachtet.\nEffects Signals sind ein interessanter Aspekt in Angular, da sie consumers benachrichtigen, wenn sie sich ändern. Der effect ist eine Operation, welche ausgeführt wird, sobald sich ein oder mehrere Werte eines Signals ändern. effects werden folgendermassen erstellt:\n1 2 3 effect(() =\u003e { console.log(`The current count is: ${count()}`); }); effects werden immer mindestens einmal ausgeführt. Wenn ein effect ausgeführt wird, verfolgt er alle gelesenen Werte des Signals. Immer wenn sich einer dieser Werte ändert, wird der effect erneut ausgeführt. Ähnlich wie bei Computed Signals verfolgen effects ihre Dependencies dynamisch und erfassen nur Signals, die in der aktuellsten Ausführung gelesen wurden. effects werden immer asynchron während des Change-Detection-Prozesses ausgeführt.\neffects werden in den meisten Anwendungsfällen nur selten benötigt, können jedoch in speziellen Situationen durchaus nützlich sein. Hier sind einige Beispiele für Situationen, in denen ein effect eine gute Lösung darstellen kann:\nLogging von angezeigten Daten und deren Änderungen, entweder für Analysezwecke oder als Debugging-Tool. Synchronisierung von Daten mit window.localStorage. Hinzufügen von benutzerdefiniertem DOM-Verhalten, das nicht mit der Template-Syntax ausgedrückt werden kann. Durchführung von benutzerdefiniertem Rendering auf einem \u003ccanvas\u003e, in einer Diagrammbibliothek oder einer anderen UI-library von Drittanbietern. Advanced topics Signal equality functions Wenn man ein Signal (egal ob Writable oder Computed) erstellt, kann man optional eine equality function angeben. Diese wird verwendet, um zu prüfen, ob ein neuer Wert sich zum vorherigen unterscheidet.\n1 2 3 4 5 6 7 import _ from \"lodash\"; const data = signal([\"test\"], { equal: _.isEqual }); // Even though this is a different array instance, the deep equality // function will consider the values to be equal, and the signal won't // trigger any updates. data.set([\"test\"]); Reading without tracking dependencies Vereinzelt ist es erforderlich, Code auszuführen, der möglicherweise Signale innerhalb einer reaktiven Funktion wie computed oder effect liest, ohne eine Dependency zu erstellen.\nNehmen wir beispielsweise an, dass bei einer Änderung von currentUser der Wert eines counters protokolliert werden soll. Es kann ein Effekt erstellen werden, der beide Signale liest:\n1 2 3 effect(() =\u003e { console.log(`User set to ${currentUser()} and the counter is ${counter}`); }); Dieses Beispiel gibt eine Meldung aus, wenn sich entweder currentUser oder counter ändert. Wenn der Effekt jedoch nur dann ausgeführt werden soll, wenn sich currentUser ändert, ist das Lesen von counter nur zufällig, und Änderungen an counter sollten keine neue Meldung protokollieren.\nMan kann verhindern, dass ein Signal-Lesen durchgeführt wird, indem man seinen Getter mit untracked aufruft:\n1 2 3 4 5 effect(() =\u003e { console.log( `User set to ${currentUser()} and the counter is ${untracked(counter)}`, ); }); untracked ist auch nützlich, wenn ein Effekt externen Code aufrufen muss, der nicht als Dependency behandelt werden soll:\n1 2 3 4 5 6 7 8 effect(() =\u003e { const user = currentUser(); untracked(() =\u003e { // If the `loggingService` reads signals, they won't be counted as // dependencies of this effect. this.loggingService.log(`User set to ${user}`); }); }); Effect cleanup functions Effekte können lang laufende Operationen starten, die abgebrochen werden sollten, wenn der Effekt zerstört wird oder bevor die erste Operation abgeschlossen ist und der Effekt erneut gestartet wird. Wenn man einen Effekt erstellt, kann die Funktion optional eine onCleanup-Funktion als ihren ersten Parameter akzeptieren. Diese onCleanup-Funktion ermöglicht es, einen Callback zu registrieren, welcher aufgerufen wird, bevor der nächste Durchlauf des Effekts beginnt oder wenn der Effekt zerstört wird.\n1 2 3 4 5 6 7 8 9 effect((onCleanup) =\u003e { const user = currentUser(); const timer = setTimeout(() =\u003e { console.log(`1 second ago, the user became ${user}`); }, 1000); onCleanup(() =\u003e { clearTimeout(timer); }); }); ","categories":"","description":"Modul #F6 - Angular - Signals in Angular\n","excerpt":"Modul #F6 - Angular - Signals in Angular\n","ref":"/de/docs/03_web/06_angular/05_4_signals/","tags":"","title":"Signals"},{"body":"Ziele Du weisst, was ein JWT ist und wie dieser zusammengesetzt ist. Exkurs JWT JWT ist ein offener Standard (RFC 7519) zur sicheren Übermittlung eines JSON-Objekts. In der Regel muss sich der Benutzer anmelden und erhält dann einen Token für API-Calls. Das Token besteht aus drei Teilen: Header, Payload und Signatur. Da der Payload alle erforderlichen Informationen enthält, ist für die Authentifizierung keine Datenbankabfrage erforderlich. Das ist besonders für die Skalierung zustandsloser Backend-Architekturen super! Das JWT kann von jedem Service selbständig validiert werden. Es braucht also keine zentrale Datenbank, welche alle Sessions abspeichert und von den verschiedenen Services abgerufen werden muss.\nEs ist jedoch wichtig, JWT mit Vorsicht zu verwenden und Sicherheitsvorkehrungen zu treffen, um Angriffe wie Token-Entführung oder Token-Manipulation zu verhindern. Dazu gehören Massnahmen wie die sichere Speicherung von geheimen Schlüsseln, die Verwendung von HTTPS für die Token-Übertragung und die Implementierung von Ablaufzeiten und erneuerbaren Tokens.\nSichere Kommunikation mit JSON Web Token Ein JWT kann von jedem dekodiert und gelesen werden. Tatsächlich ist das für den Client und das Debuggen nützlich. Die Payload wird nicht verschlüsselt (für Verschlüsselung s. JWE), aber gültige Signaturen können nur erstellt werden, wenn man ein Geheimnis kennt. Jedes Mal, wenn ein Token empfangen wird, muss eine Integritätsprüfung die Signatur bestätigen. So wird sichergestellt, dass der Token nicht manipuliert wurde. Danach wird sein Inhalt als vertrauenswürdig eingestuft.\nDie Gültigkeitsdauer des Tokens kann begrenzt werden, indem zeitbezogene Claims wie iat (“Issued At”), nbf (“Not Before”) und exp (“Expiration Time”) einbezogen werden. Ein abgelaufener JWT ist zwar weiterhin gültig, da es jedoch nicht möglich ist, Einträge zu manipulieren, ohne die Signatur zu zerstören, wird bei der serverseitigen Integritätsprüfung das Ablaufdatum des Tokens gelesen und der Zugriff verweigert.\nEin Nachteil davon ist das sehr komplizierte Widerrufen eines Tokens. Eine gängige Lösung ist das Blacklisting. Ausserdem helfen kurze Gültigkeitsdauern.\nBeispiel für die Erstellung eines JSON Web Token\nEin typisches JWT sieht aus wie folgt (Header, Payload, Signature):\nxxxxx.yyyyyy.zzzzzz\nHeader Der Header ist typischerweise in zwei Parts aufgeteilt: der erste Part ist der genutzte Algorithmus und der zweite der Typ des Tokens. Unten ein Beispiel dazu:\n1 2 3 4 { \"alg\": \"HS256\", \"typ\": \"JWT\" } Payload Der zweite Teil des Tokens ist der Payload, welcher die erstellten Forderungen enthält. Forderungen sind Aussagen über eine Entität (normalerweise den Benutzer) und zusätzliche Daten. Es gibt drei Arten von Forderungen : registrierte, öffentliche und private.\nRegistrierte: Reihe vordefinierter Forderungen die nicht obligatorisch, aber empfohlen sind; iss(Aussteller), exp(Ablaufzeit), sub(Betreff) und aud(Zielgruppe) Öffentliche: Können nach Belieben definiert werden. Um Kollisionen zu vermeiden, sollten sie jedoch in der IANA JSON Web Token Registry definiert sein. Private: Hierbei handelt es sich um benutzerdefinierte Forderungen, die erstellt wurden, um Informationen zwischen Parteien auszutauschen, die sich auf deren Verwendung einigen und weder registrierte noch öffentliche Forderungen sind 1 2 3 4 5 { \"sub\": \"1234567890\", \"name\": \"John Doe\", \"admin\": true } Signatur Um den Signaturteil zu erstellen, muss man den codierten Header, den codierten Payload, ein Secret und den im Header angegebenen Algorithmus verwenden und diesen signieren. Wenn man beispielsweise den HMAC SHA256-Algorithmus verwenden möchte, wird die Signatur folgendermaßen erstellt:\n1 2 3 4 HMACSHA256( base64UrlEncode(header) + \".\" + base64UrlEncode(payload), secret) Die Signatur wird verwendet, um zu überprüfen, ob die Nachricht nicht geändert wurde. Bei Tokens, die mit einem privaten Schlüssel signiert wurden, kann auch überprüft werden, ob der Absender des JWT derjenige ist, für den er sich ausgibt.\nAlles zusammenführen Wie man nun ein solches JWT erstellt und im Frontend verwendet, wird nachfolgend erklärt.\nDazu muss man als Erstes das JWT zusammenstellen, wie es oben erklärt wurde und dieses dann in den SessionStorage speichern. Besitzt man nun sein JWT, so kann man es bei den HTTP-Anfragen verwenden und an das Backend mitsenden, wo man es dann verifizieren muss.\nToken erstellen und speichern:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 const header = { alg: \"HS256\", typ: \"JWT\", }; const payload = { sub: \"1234567890\", name: \"John Doe\", admin: true, }; const secret = \"mysecretkey\"; // Header und Payload zu JSON-Strings konvertieren const encodedHeader = btoa(JSON.stringify(header)); const encodedPayload = btoa(JSON.stringify(payload)); // Signatur erstellen const signature = btoa(encodedHeader + \".\" + encodedPayload + secret); // JWT-Token erstellen const token = encodedHeader + \".\" + encodedPayload + \".\" + signature; // Token im Local Storage speichern sessionStorage.setItem(\"token\", token); Token bei HTTP-Anfragen mitsenden:\n1 2 3 4 5 6 7 8 9 10 11 12 import { HttpClient, HttpHeaders } from \"@angular/common/http\"; // Token aus dem Local Storage abrufen const token = sessionStorage.getItem(\"token\"); // HTTP-Header mit dem Token erstellen const headers = new HttpHeaders().set(\"Authorization\", `Bearer ${token}`); // HTTP-Anfrage mit dem Header senden this.http.get(\"/api/data\", { headers }).subscribe((response) =\u003e { // Verarbeitung der Serverantwort }); ","categories":"","description":"In diesem Exkurs ist zu sehen, was ein JSON Web Token (JWT) ist und wie dieser funktioniert.\n","excerpt":"In diesem Exkurs ist zu sehen, was ein JSON Web Token (JWT) ist und …","ref":"/docs/03_web/06_angular/07_1_exkurs-jwt/","tags":"","title":"Json Web Token Authorization (JWT)"},{"body":"Ziele Du weisst, was ein JWT ist und wie dieser zusammengesetzt ist. Exkurs JWT JWT ist ein offener Standard (RFC 7519) zur sicheren Übermittlung eines JSON-Objekts. In der Regel muss sich der Benutzer anmelden und erhält dann einen Token für API-Calls. Das Token besteht aus drei Teilen: Header, Payload und Signatur. Da der Payload alle erforderlichen Informationen enthält, ist für die Authentifizierung keine Datenbankabfrage erforderlich. Das ist besonders für die Skalierung zustandsloser Backend-Architekturen super! Das JWT kann von jedem Service selbständig validiert werden. Es braucht also keine zentrale Datenbank, welche alle Sessions abspeichert und von den verschiedenen Services abgerufen werden muss.\nEs ist jedoch wichtig, JWT mit Vorsicht zu verwenden und Sicherheitsvorkehrungen zu treffen, um Angriffe wie Token-Entführung oder Token-Manipulation zu verhindern. Dazu gehören Massnahmen wie die sichere Speicherung von geheimen Schlüsseln, die Verwendung von HTTPS für die Token-Übertragung und die Implementierung von Ablaufzeiten und erneuerbaren Tokens.\nSichere Kommunikation mit JSON Web Token Ein JWT kann von jedem dekodiert und gelesen werden. Tatsächlich ist das für den Client und das Debuggen nützlich. Die Payload wird nicht verschlüsselt (für Verschlüsselung s. JWE), aber gültige Signaturen können nur erstellt werden, wenn man ein Geheimnis kennt. Jedes Mal, wenn ein Token empfangen wird, muss eine Integritätsprüfung die Signatur bestätigen. So wird sichergestellt, dass der Token nicht manipuliert wurde. Danach wird sein Inhalt als vertrauenswürdig eingestuft.\nDie Gültigkeitsdauer des Tokens kann begrenzt werden, indem zeitbezogene Claims wie iat (“Issued At”), nbf (“Not Before”) und exp (“Expiration Time”) einbezogen werden. Ein abgelaufener JWT ist zwar weiterhin gültig, da es jedoch nicht möglich ist, Einträge zu manipulieren, ohne die Signatur zu zerstören, wird bei der serverseitigen Integritätsprüfung das Ablaufdatum des Tokens gelesen und der Zugriff verweigert.\nEin Nachteil davon ist das sehr komplizierte Widerrufen eines Tokens. Eine gängige Lösung ist das Blacklisting. Ausserdem helfen kurze Gültigkeitsdauern.\nBeispiel für die Erstellung eines JSON Web Token\nEin typisches JWT sieht aus wie folgt (Header, Payload, Signature):\nxxxxx.yyyyyy.zzzzzz\nHeader Der Header ist typischerweise in zwei Parts aufgeteilt: der erste Part ist der genutzte Algorithmus und der zweite der Typ des Tokens. Unten ein Beispiel dazu:\n1 2 3 4 { \"alg\": \"HS256\", \"typ\": \"JWT\" } Payload Der zweite Teil des Tokens ist der Payload, welcher die erstellten Forderungen enthält. Forderungen sind Aussagen über eine Entität (normalerweise den Benutzer) und zusätzliche Daten. Es gibt drei Arten von Forderungen : registrierte, öffentliche und private.\nRegistrierte: Reihe vordefinierter Forderungen die nicht obligatorisch, aber empfohlen sind; iss(Aussteller), exp(Ablaufzeit), sub(Betreff) und aud(Zielgruppe) Öffentliche: Können nach Belieben definiert werden. Um Kollisionen zu vermeiden, sollten sie jedoch in der IANA JSON Web Token Registry definiert sein. Private: Hierbei handelt es sich um benutzerdefinierte Forderungen, die erstellt wurden, um Informationen zwischen Parteien auszutauschen, die sich auf deren Verwendung einigen und weder registrierte noch öffentliche Forderungen sind 1 2 3 4 5 { \"sub\": \"1234567890\", \"name\": \"John Doe\", \"admin\": true } Signatur Um den Signaturteil zu erstellen, muss man den codierten Header, den codierten Payload, ein Secret und den im Header angegebenen Algorithmus verwenden und diesen signieren. Wenn man beispielsweise den HMAC SHA256-Algorithmus verwenden möchte, wird die Signatur folgendermaßen erstellt:\n1 2 3 4 HMACSHA256( base64UrlEncode(header) + \".\" + base64UrlEncode(payload), secret) Die Signatur wird verwendet, um zu überprüfen, ob die Nachricht nicht geändert wurde. Bei Tokens, die mit einem privaten Schlüssel signiert wurden, kann auch überprüft werden, ob der Absender des JWT derjenige ist, für den er sich ausgibt.\nAlles zusammenführen Wie man nun ein solches JWT erstellt und im Frontend verwendet, wird nachfolgend erklärt.\nDazu muss man als Erstes das JWT zusammenstellen, wie es oben erklärt wurde und dieses dann in den SessionStorage speichern. Besitzt man nun sein JWT, so kann man es bei den HTTP-Anfragen verwenden und an das Backend mitsenden, wo man es dann verifizieren muss.\nToken erstellen und speichern:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 const header = { alg: \"HS256\", typ: \"JWT\", }; const payload = { sub: \"1234567890\", name: \"John Doe\", admin: true, }; const secret = \"mysecretkey\"; // Header und Payload zu JSON-Strings konvertieren const encodedHeader = btoa(JSON.stringify(header)); const encodedPayload = btoa(JSON.stringify(payload)); // Signatur erstellen const signature = btoa(encodedHeader + \".\" + encodedPayload + secret); // JWT-Token erstellen const token = encodedHeader + \".\" + encodedPayload + \".\" + signature; // Token im Local Storage speichern sessionStorage.setItem(\"token\", token); Token bei HTTP-Anfragen mitsenden:\n1 2 3 4 5 6 7 8 9 10 11 12 import { HttpClient, HttpHeaders } from \"@angular/common/http\"; // Token aus dem Local Storage abrufen const token = sessionStorage.getItem(\"token\"); // HTTP-Header mit dem Token erstellen const headers = new HttpHeaders().set(\"Authorization\", `Bearer ${token}`); // HTTP-Anfrage mit dem Header senden this.http.get(\"/api/data\", { headers }).subscribe((response) =\u003e { // Verarbeitung der Serverantwort }); ","categories":"","description":"In diesem Exkurs ist zu sehen, was ein JSON Web Token (JWT) ist und wie dieser funktioniert.\n","excerpt":"In diesem Exkurs ist zu sehen, was ein JSON Web Token (JWT) ist und …","ref":"/de/docs/03_web/06_angular/07_1_exkurs-jwt/","tags":"","title":"Json Web Token Authorization (JWT)"},{"body":"Ziele Ich bin bereit für das Examen ⏱️ Geschätzte Lesezeit: 10 Minuten 1. Repository aufräumen Master/Main Branch erstellen Parallel zum Modul Java Grundlagen hast du auch schon erste Erfahrungen mit Git gesammelt und viele Branches angelegt.\nDurch deinen Praxisbildner oder das Selbststudium weisst du nun auch, was ein Main- oder Master-Branch ist.\nFühre nun alle deine Branches in den Master/Main Branch zusammen und lösche die übrigen Branches. Falls du Probleme beim Mergen hast, frag die anderen Auszubildenden oder einen Praxisbildner um Hilfe.\nUnnötige Dateien aus dem Repository entfernen Zu Beginn haben wir einfach alle Dateien ins Repository committed. Einige davon gehören jedoch nicht in ein Repository:\nlokale Konfigurationsdateien von IntelliJ Build-Output temporär erstellte Dateien Das Aufräumen erfolgt in folgenden Schritten:\nErstelle einen neuen Branch (wie immer, wenn du eine Änderung machen willst). Du kannst ihn cleanup nennen. Erstelle ein .gitignore für IntelliJ. Committe die .gitignore-Datei. Lösche in den einzelnen Projekten die nicht notwendigen Dateien und Verzeichnisse, falls vorhanden: im .idea-Verzeichnis alles ausser dem Unterverzeichnis runConfigurations das target-Verzeichnis die Datei .itninja.hugo.json ZIP-Dateien (ausser wenn in einer Übung benötigt) vorhandene *.iml-Dateien Committe deine Änderungen. Push auf origin und erstelle einen Pull-/Merge-Request. Lass den Request von einem anderen Auszubildenden prüfen und mergen. 2. Praxisbildner zu einem Fachgespräch einladen Nutze diesen Moment, um dich mit deinem Praxisbildner über das Gelernte auszutauschen. Vielleicht erhältst du noch den einen oder anderen Hinweis oder Tipp.\nSende einem deiner Praxisbildner eine Terminanfrage für 1 Stunde. Die Einladung muss einen Link zu deinem Repository enthalten.\nStelle sicher, dass der Praxisbildner Lese- und Schreibrechte auf das Repository hat.\nDer Praxisbildner benötigt vor dem Fachgespräch Zeit, um sich das Repository anzuschauen. Plane deshalb mindestens 1–2 Arbeitstage zwischen dem Versenden deiner Einladung und dem Termin ein. Nutze die Zeit bis zum Fachgespräch und gehe die Java Grundlagen nochmals durch. Das Fachgespräch bietet dir die Möglichkeit, offene Fragen zu klären und deinem Praxisbildner dein Wissen zu zeigen. ","categories":"","description":"Du hast das Modul Java Grundlagen abgeschlossen. Folgendes musst du noch erledigen, bevor du mit dem Examen beginnen kannst.\n","excerpt":"Du hast das Modul Java Grundlagen abgeschlossen. Folgendes musst du …","ref":"/docs/02_java/03_java-grundlagen/99_wrap_up/","tags":"","title":"Module abschliessen"},{"body":"In diesem Bereich findest du hilfreiche Tools und Anleitungen zur Arbeit mit Entwicklungsumgebungen, Dokumentation, Versionskontrolle und nützlichen Helferlein.\nProgramme und Tools Die folgenden Programme sollten heruntergeladen und installiert werden, sie werden für die Grundausbildung verwendet.\nAnwendung Link Zweck IntelliJ IDEA IntelliJ IDEA einrichten Entwicklungsumgebung für Java Notepad++ https://notepad-plus-plus.org/downloads/ Erweiterter Texteditor mit vielen nützlichen Funktionen Google Chrome https://www.google.com/intl/de/chrome/ Web-Browser von Google mit sehr guten Entwickler-Funktionen GIT https://git-scm.com/download/win Zugriff auf das Versionsverwaltungssystem GIT Apache Maven Bereits in IntelliJ integriert Build Management Tool von Apache JDK Bereits in IntelliJ integriert Java Development Kit zur Herstellung von Java-Anwendungen Firewall / Sicherheit Dein Betriebssystem verfügt mit dem Windows-Betriebssystem über eine eigene Firewall. Du bist persönlich für deren Konfiguration verantwortlich. Gleichzeitig verfügt das SBB-Netzwerk selbstverständlich über entsprechende Schutzmechanismen, darunter auch diverse Firewalls. Im Intranet der SBB ist der Besuch von diversen Webseiten eingeschränkt. Dein Browser informiert dich sofort, wenn du auf eine nicht zugelassene Seite navigierst.\nLies den folgenden Artikel im Intranet betreffend Weisungen über Datensicherheit und Datenschutz: https://sbb.sharepoint.com/sites/intranet_servicessupport/SitePages/datensicherheit-und-datenschutz.aspx\n","categories":"","description":"","excerpt":"In diesem Bereich findest du hilfreiche Tools und Anleitungen zur …","ref":"/docs/99_tools/","tags":"","title":"Tools"},{"body":"Einführung Das Lernprojekt dient dazu, das in den Modulen erarbeitete Wissen praktisch anzuwenden.\nDu entwickelst über mehrere Monate hinweg ein Projekt, das schrittweise um neue Funktionen erweitert wird.\nWährend am Anfang viele Vorgaben bestehen, liegt der Fokus später auf der eigenständigen Entwicklung von Features sowie dem Schreiben von User Stories. So wird nicht nur das technische Verständnis vertieft, sondern auch das Arbeiten nach agilen Prinzipien geübt.\nÜbersicht Jedes Projekt hat ein eigenes Ziel. So kannst du dich an den realen Fortschritt anpassen und praxisnah arbeiten.\nWir freuen uns auch über Feedback und Vorschläge für weitere Projekte, die in Zukunft angeboten werden könnten. ","categories":"","description":"Im Lernprojekt wendest du dein erlerntes Wissen praktisch an. Die Projekte orientieren sich am jeweiligen Ausbildungsstand und wachsen zu einer Gesamtlösung zusammen.\n","excerpt":"Im Lernprojekt wendest du dein erlerntes Wissen praktisch an. Die …","ref":"/project/","tags":"","title":"Lernprojekt"},{"body":"20250904-0616-130 2025-09-04 06:16 CEST auf origin/master\nSeiten-Änderungen Geändert Docs / Tools / Nützliche Tips, Tricks und Anleitungen / Reguläre Ausdrücke 20250903-1654-126 2025-09-03 16:54 CEST auf origin/master\nSeiten-Änderungen Hinzugefügt Docs / Java / Java Grundlagen / Module abschliessen Geändert Docs / Tools / Entwicklungsumgebungen - IDE / IntelliJ IDEA – dein Einstieg ins professionelle Programmieren / Git mit IntelliJ nutzen 20250903-1632-125 2025-09-03 16:32 CEST auf origin/master\nSeiten-Änderungen Hinzugefügt Docs / Java / Java Grundlagen / Enums – Grundlagen Lernprojekt / Projekt 2025 – Online Game / Projekt: Logger Lernprojekt / Projekt 2025 – Online Game Geändert About Docs / Java / Java Grundlagen / Reguläre Ausdrücke in Java (RegEx) Docs / Java / Java Grundlagen / Utility Klassen Docs / Tools / Nützliche Tips, Tricks und Anleitungen / Reguläre Ausdrücke Labs / Java Labs / Java Exercises - Grundlagen / Java Exercises - Strings Lernprojekt ","categories":"","description":"Übersicht der Änderungen für 2025 (Release Notes und Seitenänderungen).\n","excerpt":"Übersicht der Änderungen für 2025 (Release Notes und …","ref":"/about/latest-changes/","tags":"","title":"Latest Changes"},{"body":"title: “Shells” linkTitle: “Shells” weight: 7 description: \u003e Häufig genutzte Shells\n","categories":"","description":"","excerpt":"title: “Shells” linkTitle: “Shells” weight: 7 description: \u003e Häufig …","ref":"/docs/99_tools/shell/","tags":"","title":""},{"body":" Freie Plattform für IT Berufsbildung. SBB Puzzle ITC Nexplore ","categories":"","description":"","excerpt":" Freie Plattform für IT Berufsbildung. SBB Puzzle ITC Nexplore ","ref":"/about/","tags":"","title":"About"},{"body":" IT Ninjas Freie Plattform für IT Berufsbildung. SBB Puzzle ITC Nexplore ","categories":"","description":"","excerpt":" IT Ninjas Freie Plattform für IT Berufsbildung. SBB Puzzle ITC …","ref":"/de/about/","tags":"","title":"About"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/","tags":"","title":"Categories"},{"body":"","categories":"","description":"","excerpt":"","ref":"/de/categories/","tags":"","title":"Categories"},{"body":"Übersicht ","categories":"","description":"","excerpt":"Übersicht ","ref":"/challenges/","tags":"","title":"Challenges"},{"body":"Übersicht ","categories":"","description":"","excerpt":"Übersicht ","ref":"/de/challenges/","tags":"","title":"Challenges"},{"body":"Willkommen bei deinem Start ins Abenteuer Softwareentwicklung!\nUnser Ausbildungsprogramm ist dein persönlicher Fahrplan durch die Welt der IT – strukturiert, praxisnah und auf deinen Lernerfolg ausgerichtet.\nEinleitung Du beginnst direkt mit Java – der meistgenutzten Programmiersprache der Welt. Du schreibst echten Code, baust Anwendungen und bekommst sofort Rückmeldung. Schritt für Schritt erarbeitest du dir die wichtigsten Skills für die Berufswelt von heute.\nJedes Modul ist klar aufgebaut:\nLernstoff im Selbststudium – verständlich aufbereitet, mit Beispielen und Übungen. Labs zum Mitmachen – du setzt das Gelernte direkt um. Examen zum Abschluss eine Moduls oder über mehrere Module hinweg – stelle das gelernte unter Beweis und zeige was du kannst. Das Ziel: Du lernst nicht nur Java, sondern auch moderne Tools und Frameworks wie Maven, JUnit, Spring Boot und Angular kennen – und zwar genau so, wie sie auch in echten Projekten eingesetzt werden.\nDein technischer Werkzeugkasten Am Ende des Programms kannst du sicher mit diesen Technologien umgehen:\n✅ Java – die Basis moderner Softwareentwicklung ✅ Maven \u0026 Testing – Projekte strukturieren und zuverlässig testen ✅ Spring Boot – professionelle Backend-Entwicklung ✅ HTML, CSS \u0026 JavaScript – dein Einstieg ins Web ✅ TypeScript \u0026 Angular – moderne Webanwendungen bauen Wenn du Webseiten oder Webanwendungen entwickelst, unterscheidet man grob zwei Bereiche:\nFrontend – das ist alles, was die Benutzer:innen direkt sehen und bedienen können. Es läuft vorwiegend im Browser und umfasst HTML, CSS, JavaScript und Frameworks wie Angular.\nBackend – das ist die „unsichtbare“ Logik im Hintergrund. Hier laufen Programme (z. B. in Java mit Spring Boot), die Daten speichern, verarbeiten und Schnittstellen bereitstellen.\nAlles im begleiteten Selbststudium – individuell, effizient und mit maximalem Praxisbezug.\nAnpassen der Webseite Unter Konfiguration kannst du it-ninjas an deine Bedürfnisse anpassen. Wir empfehlen dir, das gleich zu tun, damit du optimal arbeiten kannst. Hey cool, willkommen in der Talent Factory!\nBoxen wie diese geben dir zusätzliche Informationen, wie du mit den Tools und Werkzeugen bei SBB deine Herausforderungen meistern kannst.\nGewisse Tools bedingen, dass du per VPN mit dem Netzwerk von der Talent Factory bei der SBB verbunden bist! Übersicht Ausbildungsprogramm Falls du an einem Ausbildungsprogram teilnimmst und dies in der Konfiguration auch entsprechend ausgewählt hast, findest du hier dein Ausbildungsprogramm.\nKlicke hier für die Vollansicht.\nBeachte, die Zeiten sind grobe Vorgaben. Jeder hat sein eigenes Tempo. Es ist wichtig dass du dir Zeit nimmst und den Inhalt verstehst. Nachfolgenden Module bauen oft auf das erlernte Wissen auf. Die berufsübergreifenden Workshops und Erfahrungstransfers sind ebenfalls wichtig – du findest sie ausserhalb von IT-Ninjas in separaten Angeboten. Starte mit dem Ausbildungsprogramm Starte jetzt mit den Java Grundlagen um bald ein it-ninjas zu werden! Klicke auf den Link hier oder wähle rechts aus dem Menu das Modul Java.\nWeitere Links Direkt zu den Debugging-Seiten Debugging von Java Code in IntelliJ Frontend-Debugging Direkt zu den Testing-Seiten Testing Konzepte / JUnit / Mockito Spring Boot Testing Rest-Schnittstellen testen Angular Testfiles ","categories":"","description":"","excerpt":"Willkommen bei deinem Start ins Abenteuer Softwareentwicklung!\nUnser …","ref":"/docs/","tags":"","title":"Docs"},{"body":"Übersicht Ausbildungsprogramm Das Ausbildungsprogramm 2024/2025 besteht aus diversen einzelnen Ausbildungs-Modulen.\nDas Wissen aus jedem technischen Modul wird durch Selbst-Studium erworben und bei Bedarf eigenständig durch zusätzlich gesuchtes Wissen ergänzt. Nahezu jedes Modul bringt seine eigenen Übungen (Labs) mit. Einige der Module müssen durch ein Exam abgeschlossen werden. Die Resultate deiner Übungen und Exams besprichst du immer mit einer/einem Praxisbildner:in im Rahmen eines Reviews. Er/Sie wird dir Feedback geben und dir idealerweise die Freigabe für das nächste Modul erteilen. Gewisse Module bieten freiwillige Challenges an, bei denen du dein Wissen mit anderen messen kannst.\nDas Ziel des technischne Ausbildungsprogramms ist\ndas Erlernen der Programmiersprache Java das Erwerben von Kenntnissen zu Maven und Testing das Erwerben von Kenntnissen zum Spring Framework und zu Spring Boot das Erlernen von HTML/CSS und JavaScript das Erlernen der Programmiersprache Typescript und des Web-Frameworks Angular im begleiteten Selbst-Studium innerhalb des ersten Lehr-/Studienjahres.\nBerufsübergreifende Module finden in Form von Workshops und Erfahrungstransfers statt. Diese Module sind nicht in den IT-Ninjas aufgeführt.\nAbsprung zu den Debugging-Seiten Debugging von Java Code in IntelliJ Frontend-Debugging Absprung zu den Testing-Seiten Testing Konzepte / JUnit / Mockito Spring Boot Testing Rest-Schnittstellen testen Angular Testfiles ","categories":"","description":"","excerpt":"Übersicht Ausbildungsprogramm Das Ausbildungsprogramm 2024/2025 …","ref":"/de/docs/","tags":"","title":"Docs"},{"body":"Übersicht ","categories":"","description":"","excerpt":"Übersicht ","ref":"/exams/","tags":"","title":"Exams"},{"body":"Übersicht ","categories":"","description":"","excerpt":"Übersicht ","ref":"/de/exams/","tags":"","title":"Exams"},{"body":"","categories":"","description":"","excerpt":"","ref":"/labs/99_tools/java/05_secrets/","tags":"","title":"Geheimnisse sicher aufbewahren"},{"body":" Willkommen bei IT-Ninjas Die Ausbildungsplattform für angehende Informatiker:innen bei den Firmen 89grad, unic, Puzzle ITC und SBB CFF FFS. Auf dieser Seite lernst du alles, um erfolgreich Software entwickeln zu können. Von Java als Programmiersprache bis Angular als Web-Frontend bieten wir kostenlos einen Ausbildungsplan hin zum Full-Stack-Entwickler. Das erste mal hier? Dann starte am besten mit der Dokumentation Docs Dokumentationen zum kompletten Ausbildungs-Modulplan. Baue dein Wissen auf! Zur Dokumentation Labs Hands-on Übungen um das Gelernte zu vertiefen. Der beste Weg ist Lernen durch Tun. Zu den Labs Exams Prüfe deine neu erlernten Fähigkeiten am Ende eines Ausbildungs-Moduls. Zu den Exams Projekte Ganz neu und noch im Aufbau. In einem Projekt wirst du alles erlernte anwenden können. Zu den Projekten ","categories":"","description":"","excerpt":" Willkommen bei IT-Ninjas Die Ausbildungsplattform für angehende …","ref":"/","tags":"","title":"IT Ninjas"},{"body":" IT Ninjas Docs Labs Exams Challenges Docs Read the documentation to learn java and web technologies.\nWeiterlesen …\nLabs Start with labs to reinforce theory and gain experience.\nWeiterlesen …\nExams Take an exam to test your knowledge and complete a block of training.\nWeiterlesen …\nChallenges Participate in volunteer challenges and give your best for the perfect solution.\nWeiterlesen …\n","categories":"","description":"","excerpt":" IT Ninjas Docs Labs Exams Challenges Docs Read the documentation to …","ref":"/de/","tags":"","title":"IT Ninjas Labs"},{"body":"","categories":"","description":"","excerpt":"","ref":"/labs/99_tools/java/","tags":"","title":"Java"},{"body":" it-ninjas bietet dir einige einfache Konfigurationsmöglichkeiten, die dir die Arbeit erleichtern.\nDu kannst diese Einstellungen jederzeit anpassen – ganz nach deinen Bedürfnissen.\nZu deiner Sicherheit: Diese Einstellungen werden nur lokal in deinem Browser gespeichert und verlassen deinen Rechner nicht.\nDas bedeutet allerdings, dass du sie auf einem anderen Gerät erneut eingeben musst. Die Einstellungen dienen dazu, Inhalte, welche für dich nicht relevant sind auszublenden. Es handelt sich dabei um keine vertraulichen Informationen oder Geheimnisse… ⏳ Einstellungen werden geladen... Benutzername (siehe Hinweis unten!):\nPfad zum lokalen Repository (dort wo du deine Übungen speichern willst):\nBetriebssystem des Entwicklungsrechners:\nWindows Linux Wahl der Ausbildungsstätte:\n(keine) SBB 89grad Puzzle ITC unic Speichern\nWie finde ich meinen Benutzernamen heraus? Öffne eine !*Cmd Shell und gib folgenden Befehl ein:\nKopieren echo %username% 1 echo %username% Kopieren echo $USER 1 echo $USER Einstellungen gespeichert!\n","categories":"","description":"","excerpt":" it-ninjas bietet dir einige einfache Konfigurationsmöglichkeiten, die …","ref":"/config/","tags":"","title":"Konfiguration"},{"body":"Übungen bei it-ninjas Auf den folgenden Seiten findest du eine Vielzahl von Übungen zu den einzelnen Modulen. Wir empfehlen dir jeweils zuerst die Dokumentation durchzugehen und danach die Übungen hier auszuführen\nIn der Dokumentation wird jeweils auf die passenden Übungen verwiesen, so dass du Schritt für Schritt das erlernte durch die Übungen festigen kannst. ","categories":"","description":"","excerpt":"Übungen bei it-ninjas Auf den folgenden Seiten findest du eine …","ref":"/labs/","tags":"","title":"Labs"},{"body":"Übersicht ","categories":"","description":"","excerpt":"Übersicht ","ref":"/de/labs/","tags":"","title":"Labs"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/","tags":"","title":"Tags"},{"body":"","categories":"","description":"","excerpt":"","ref":"/de/tags/","tags":"","title":"Tags"},{"body":"","categories":"","description":"","excerpt":"","ref":"/labs/99_tools/","tags":"","title":"Tools"}]