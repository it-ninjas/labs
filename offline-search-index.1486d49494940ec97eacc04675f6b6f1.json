
























































































































































[{"body":"Jetzt wird es Zeit, dass du auch Programm-Logik auf deiner Website einbauen kannst. Dafür lernst du gleich die Programmiersprache JavaScript kennen, die von praktisch allen bekannten Browsern unterstützt wird.\nDamit du eine Übersicht über die Programmiersprache bekommst, kannst du z.B. dieses Video schauen, ohne dass du den ersten Satz verstehen musst.\nMotivation für JavaScript JavaScript hat sehr viele Verwendungen im Browser. Einerseits können Funktionen ähnlich wie mit Java programmiert werden, sodass z.B. Berechnungen ausgeführt werden können. Zudem kann aber auch direkt mit dem angezeigten Inhalt interagiert werden. So können Validierungen oder auch Animationen ausgeführt werden. Wenn du mal sehen willst, wie eine Website aussieht ohne JS kannst du dir hier eine Chrome extension herunterladen mit welcher du JS komplett ausschalten kannst.\nNun beginnen wir aber zuerst klein: Mit einem Button, der beim Klick eine MessageBox anzeigt.\n1 2 3 4 5 6 7  \u003cbutton onclick=\"onClickMeClick()\" type=\"button\"\u003eKlick mich\u003c/button\u003e \u003cscript\u003e function onClickMeClick() { alert('Klick mich nicht an!!'); } \u003c/script\u003e   Versuche zuerst, dieses Beispiel ohne Erläuterung zu verstehen.\n Erläuterung (click to expand) Zuerst hast du im HTML einen Button erstellt mit dem Text \"Klick mich\". Weiter unten siehts du ein \u003cscript\u003e-Element. Dort drin ist eine Funktion namens onClickMeClick() definiert. Die Funktion ruft alert(message: string) auf. Diese alert-Funktion öffnet eine MessageBox mit der übergebenen Nachricht.\nWie du siehst, wird die selbst definierte Funktion beim Klick auf den Button aufgerufen. Dies passiert, weil du diesen Aufruf im onclick-Attribut des \u003cbutton\u003es definiert hast. Beachte in diesem Beispiel, dass nicht die Funktion sondern deren Aufruf drin steht. Im Prinzip wird beim Button-Klick der Wert des onclick-Attributs ausgeführt. Theoretisch könntest du auch direkt onclick=\"alert('Klick mich nicht an!!')\" schreiben.\n JavaScript einbinden Wie du im oberen Beispiel gesehen hast, wird Javascript via \u003cscript\u003e-Tag eingebunden. Dein Code kann direkt im \u003cscript\u003e-Tag geschrieben werden:\n1 2 3  \u003cscript\u003e console.log('my Js Code'); \u003c/script\u003e   Du kannst aber dein Code auch in einem separatem .js File haben und via Script Tag referenzieren:\nindex.html\n1 2  \u003cscript src=\"mycode.js\"\u003e\u003c/script\u003e   mycode.js\n1  console.log('my Js Code');   Die zweite Variante ist meist sauberer, da Code und HTML sauber aufgeteilt wird. Bei unseren Übungen wirst du aber meist direkt im \u003cscript\u003e-Tag arbeite können ohne separates JS File.\n","categories":"","description":"Nun sagst du dem Browser, was er machen soll!\n","excerpt":"Nun sagst du dem Browser, was er machen soll!\n","ref":"/docs/web/javascript/01_js_intro/","tags":"","title":"JavaScript: Einführung"},{"body":"Wie funktionieren Webseiten? Im Gegensatz zu Desktop-Programmen SOLLTEN Webseiten auf jedem Betriebssystem und Browser gleich laufen und aussehen. Damit das funktionieren kann, müssen die Webseiten so programmiert/geschrieben worden sein, dass sie von jedem Browser verstanden werden können.\nGenau das wird mit HTML erreicht. Jeder Browser versteht HTML.\nWas ist HTML? Beginnen wir mit der Definition der Abkürzung “HTML”. Diese steht für “HyperText Markup Language”. Okay, was aber bedeutet das?\nMit HyperText ist ein Dokument gemeint, das nicht dafür gemacht ist, um von oben nach unten gelesen zu werden. HyperText enthält also z.B. Links, die auf andere Dokumente führen. Unter Markup ist zu verstehen, dass das Dokument strukturiert (Kopfzeilen, Hauptteil, Fusszeilen) und formatiert (z.B. kursiver/fetter Text) ist.\nSomit ist HTML also eine Sprache, die alle Elemente auf einer Webseite BESCHREIBT. Die Betonung liegt hier auf “beschreibt”. Das bedeutet, dass HTML keine Programmiersprache ist. Code, der auf der Webseite ausgeführt wird, ist in JavaScript geschrieben.\nÜbersicht zu HTML, CSS und JavaScript (JS) Während Deiner Einführung in die Webentwicklung wirst du die Begriffe “HTML”, “CSS” und “JavaScript” immer wieder hören bzw. lesen. Deswegen beginnen wir mit einem Überblick:\nIm HTML beschreibst du die Struktur einer Webseite und fügst auch die wichtigsten Elemente davon ein. Diese Elemente können Text, UI-Elemente, Bilder und vieles mehr sein.\nIn CSS beschreibst du, wie das HTML im Browser aussehen soll. Beispielsweise kannst du Schriftfarben, -arten, -grössen, das Aussehen von UI-Elementen und Layouts damit beschreiben.\nMöchtest du im Browser Code ausführen, dann geschieht das mit der Programmiersprache JavaScript. Zum Beispiel kannst Du im HTML definieren, dass eine JavaScript-Funktion ausgeführt wird, wenn Du auf einen Button klickst.\n","categories":"","description":"Erstelle Deine erste Webseite mit HTML. Eine erste Einführung in HTML.\n","excerpt":"Erstelle Deine erste Webseite mit HTML. Eine erste Einführung in HTML. …","ref":"/docs/web/html_css/01_html_intro/","tags":"","title":"HTML"},{"body":"","categories":"","description":"Entwickungsumgebung aufsetzen\n","excerpt":"Entwickungsumgebung aufsetzen\n","ref":"/docs/web/ide/","tags":"","title":"Frontend IDE"},{"body":"","categories":"","description":"Exams zu HTML, CSS und JavaScript.\n","excerpt":"Exams zu HTML, CSS und JavaScript.\n","ref":"/exams/web/html_css/","tags":"","title":"HTML-, CSS- und JavaScript-Exams"},{"body":"IDE Die Beispiele in diesem Modul werden mit Visual Studio Code erklärt. Visual Studio Code ist ein kostenloser Codierungseditor, mit welchem du schnell mit dem Coden beginnen kannst. Du kannst Visual Studio Code verwenden, um in jeder Programmiersprache zu programmieren, ohne den Editor zu wechseln. Es unterstützt viele Sprachen, darunter sind JavaScript, Angular, Vue und viele mehr. https://code.visualstudio.com/\n15' - Einzelarbeit\nInstalliere die IDE und richte sie entsprechend deiner Präferenz ein. Folgende VS Code-Extensions sind praktisch für die Entwicklung von Webapps: - Code Spell Checker - ESLint - GitLens - Material Icon Theme - Path Intellisense - Prettier – Code formatter  Git Git ist dir bereits bekannt ein Codeversionierungssystem, welches bei diesem Modul genutzt wird.\n5' - Einzelarbeit\nInstalliere Git. Hierfür gibt es zwei Möglichkeiten: 1. Vielleicht klappt es unter Windows direkt mit diesem Kommandozeilenbefehl: winget install --id Git.Git -e --source winget 2. Ansonsten lade es unter folgendem Link herunter: https://git-scm.com/. Bei der Installation sind keine Anpassungen zwingend. Vielleicht helfen dir in Zukunft die \"Components\" \"Windows Explorer integration - Git Bash Here\" und \"Add a Git Bash Profile to Windows Terminal\". Ansonsten kannst du dich einfach durchklicken.  Tools Node.js Node.js ist eine plattformübergreifende Opensource-JavaScript-Runtime, damit du den nötigen Webserver betreiben kannst, die für die Webentwicklung notwendig ist. Mit Node können wir später diverse Packages installieren und in unserer Webapplikation brauchen.\n5' - Einzelarbeit\nInstalliere Node.js unter folgendem Link: https://nodejs.org/en/. Verwende die LTS Version, diese werden für die meisten Nutzer empfohlen. Bei der Installation sind keine Anpassungen notwendig. Du kannst dich einfach durchklicken.  Postman Postman ist eine API Platform, um die API des Backends zu testen. Dies hilft dir dabei beispielsweise zu prüfen, ob deine Nutzer die du erstellt hast, auch in der Datenbankdatei korrekt gespeichert wurde.\n10' - Einzelarbeit\nInstalliere Postman unter folgendem Link:https://www.postman.com/downloads/. Bei der Installation sind keine Anpassungen notwendig. Du kannst dich einfach durchklicken. Du kannst Postman ohne Account benutzen.  Überprüfen Nun hoffen wir, dass alle nötigen Installationen erfolgreich ausgeführt wurden.\n5' - Einzelarbeit\n- Öffne VS-Code - Öffne ein neues Terminal - git --version - npm -v Sofern alle Versionen angezeigt werden, war die Installation erfolgreich. Anderweitig solltest du einen Coach konsultieren. ","categories":"","description":"In diesem Kapitel werden die IDE und genutzte Tools in der Theorie beschrieben, Anleitungen platziert oder auch vereinzelte Aufgaben gestellt.\n","excerpt":"In diesem Kapitel werden die IDE und genutzte Tools in der Theorie …","ref":"/docs/web/ide/01_ide_tools/","tags":"","title":"IDE und Tools"},{"body":"Was ist ein Framework? Das Wort Frontend deutet schon darauf hin, worum es sich handelt. Es ist das, was der Nutzer sieht. Bei einer Webapplikation ist es das, was dem Besucher im Browser angezeigt wird: die Benutzeroberfläche.\nEs ist der Teil der Software, den der Benutzer sieht und über den er die Software anwendet.\nJS Frameworks JavaScript-Frameworks sind eine Art Tool, das die Arbeit mit JavaScript einfacher und reibungsloser macht.\nDurch verschiedensteFrameworks wird die Gestaltung von Websites sehr flexibel, daher bevorzugen es die meisten Entwickler.\nDie bekanntesten JS-Frameworks:\nAngular Eines der leistungsstärksten, effizientesten und Open-Source-JavaScript-Frameworks ist Angular.\nGoogle betreibt dieses Framework, welches für die Entwicklung einer Single Page Application (SPA) verwendet wird.\nReact Das von Facebook erstellte Framework React hat innerhalb kurzer Zeit an Popularität gewonnen.\nEs wird verwendet, um die dynamische Benutzeroberfläche der Webseiten mit hohem eingehenden Datenverkehr zu entwickeln und zu betreiben.\nVue.js Obwohl dieses JavaScript-Framework erst im Jahr 2016 entwickelt wurde, hat es bereits seinen Weg in den Markt gefunden und sich durch verschiedene Funktionen bewährt. Es ist sehr zuverlässig um Cross-Plattform zu entwickeln.\n","categories":"","description":"Tools, die das Arbeiten mit JavaScript sehr vereinfachen.\n","excerpt":"Tools, die das Arbeiten mit JavaScript sehr vereinfachen.\n","ref":"/docs/web/angular/02_javascript_frameworks/","tags":"","title":"Javascript Frameworks"},{"body":"","categories":"","description":"Exams zu Java Technologie\n","excerpt":"Exams zu Java Technologie\n","ref":"/exams/java/","tags":"","title":"Java Exams"},{"body":"Die folgenden Aufgaben dienen der Vertiefung der beiden Themen Reflection API und Annotations.\nAufgabe 1 Implementiere eine eigene Annotation. Die Annotation soll der Dokumentation einer Klasse dienen und die folgenden Eigenschaften aufweisen:\n Verfügbar zur Compile Time Verfügbar auf Klassen Attribut zur Aufnahme von einem oder mehreren Autoren als String-Array Attribut zur Aufnahme einer Beschreibung als String, der Default-Wert soll ein leerer String sein Attribut zur Aufnahme einer Version als String, der Default-Wert ist 0.0.1  Der Name der Annotation soll anhand ihres Zwecks gewählt werden.\nAufgabe 2 Implementiere eine sinnvolle Modell-Klasse und wende deine neue Annotation an. Fülle die Werte für Autor, Beschreibung und Version ab.\nAufgabe 3 Implementiere einen Annotations-Prozessor, welcher die oben geschriebene Annotation auf der Modell-Klasse auswertet. Die Auswertung soll auf die Kommandozeile erfolgen.\nSchritt 1 Implementiere eine neue Klasse, welche die folgende Basis hat:\n1 2 3 4 5 6 7 8 9 10  @SupportedAnnotationTypes(/*1*/) @SupportedSourceVersion(SourceVersion.RELEASE_8) public class DocumentationProcessor extends AbstractProcessor { @Override public boolean process(Set\u003c? extends TypeElement\u003e annotations, RoundEnvironment roundEnv) { return false; } }   Füge beim Punkt 1 den kompletten Pfad (Package und Name) deiner Annotation ein.\nSchritt 2 Die beiden Parameter annotations und roundEnv werden durch den Annotations-Prozessor benutzt, um während der Kompilierung die entsprechende Annotation zu erhalten. Im Set annotations befinden sich alle Annotationen, welche unter Punkt 1 angegeben werden. Die Klasse RoundEnvironment erlaubt den Zugriff auf alle Elemente während der Kompilierung. Ergänze die Methode des Annotations-Prozessors mit den folgenden Loops:\n1 2 3 4 5 6  for(TypeElement annotation:annotations){ Set\u003c?extends Element\u003e annotatedElements = roundEnv.getElementsAnnotatedWith(annotation); for(Element element:annotatedElements){ X annotation=element.getAnnotation(X.class); } }   Die Klasse X kannst du durch deine Annotation ersetzen. Jetzt hast du Zugriff auf die Elemente deiner Annotation.\nSchritt 3 Ergänze die Implementation, um den Klassennamen der Modell-Klasse und die Werte der Annotation auszudrucken. Hier ein Beispiel, wie der Ausdruck in etwa aussehen könnte:\n1 2 3 4 5 6  ------ Person ------ Model class representing a person with a name and age [u210148 (Claudio Zesiger)] 0.0.1   Schritt 4 Kompiliere die Annotation und den Annotations-Prozessor auf der Kommandozeile (Terminal) mit dem Befehl javac.\n1 2  javac \u003cpackage\u003e.\u003cannotation\u003e.java javac \u003cpackage\u003e.\u003cannotationprocessor\u003e.java   Ersetze das Package und die Namen der Annotation/des Annotations-Prozessors mit deinen Angaben.\nSchritt 5 Kompiliere die implementierte Modell-Klasse mit dem folgenden Befehl:\n1  javac -processor \u003cpackage\u003e.\u003cannotationsprocessor\u003e \u003cmodel-klasse\u003e.java   Die Ausgabe auf die Kommandozeile durch den Annotations-Prozessor sollte anschliessend angezeigt werden.\n","categories":"","description":"Aufgaben zu Modul #J6 - Annotationen \u0026 Reflection API\n","excerpt":"Aufgaben zu Modul #J6 - Annotationen \u0026 Reflection API\n","ref":"/labs/java/java-reflection-and-annotations/01_annotations_exercises/","tags":"","title":"Annotationen - Aufgaben"},{"body":"Ziele  Ich habe die Ersteinrichtung des Laptops vollständig durchgeführt Ich bin im Besitz von permanenten Admin-Rechten Ich weiss, wo ich Hard- und Software bestellen kann Ich habe die notwendigen Programme heruntergeladen und installiert Ich weiss, wie ich von Zuhause aus auf das SBB-Netzwerk zugreifen kann: Citrix Gateway Ich verstehe was ein Proxy ist und wie ich ihn einstellen muss   Adminrechte überprüfen / bestellen Damit du auf deinem SBB-Laptop Programme installieren kannst, muss dein angemeldeter Benutzer über Adminrechte verfügen. Über den folgenden Link kannst du dein Inventar anzeigen lassen und überprüfen, ob dein Benutzer bereits Adminrechte besitzt: https://sbb.service-now.com/sbb?id=show_inventory Wenn die Liste deines Inventars den Eintrag “Local admin right” enthält, dann besitzt du bereits Adminrechte und musst nichts weiter unternehmen.\nFalls du keine Adminrechte besitzt, müssen diese im Service-Portal bestellt werden. Es ist wichtig zu wissen, dass es zwei Arten von Adminrechten gibt: Temporäre und permanente Adminrechte. Temporäre Adminrechte erhältst du nach ca. 10 Minuten und daher eignen sich diese für die rasche Installation von Software. Diese Rechte verfallen jedoch nach 24h. Permanente Adminrechte sind endlos gültig, du erhältst sie aber nicht sofort, die Bestellung muss zuerst freigegeben werden. Die Bestellung von temporären und permanenten Adminrechten sollte separat erfolgen, da die gesamte Bestellung sonst auf die Freigabe der permanenten Adminrechte warten muss. Bei der Bestellung musst du die K-Nummer deines SBB-Laptops angeben, die Bestellung in den Einkaufswagen legen und anschliessend die Bestellung abschliessen. temporäre Adminrechte bestellen\npermanente Adminrechte bestellen Nach der Bestellung muss eine Weile gewartet werden, bis die Bestellung abgeschlossen ist, dies dauert rund 10 Minuten. Nach einem Neustart des Gerätes sollten die Adminrechte aktiv sein.\nDie Bestellung von Hardware oder lizenzierter Software ist über das Service-Now möglich.\n Programme und Tools Die folgenden Programme sollten heruntergeladen und installiert werden, sie werden für die Grundausbildung verwendet.\n   Anwendung Link Zweck     JetBrains Toolbox (optional) https://www.jetbrains.com/toolbox/app/ Management für Entwicklungsumgebungen   IntelliJ IDEA Durch die JetBrains Toolbox oder direkt unter https://www.jetbrains.com/de-de/idea/download/ Entwicklungsumgebung, beim Starten den Lizenzserver eintragen: http://intellij-license.sbb.ch   Notepad++ https://notepad-plus-plus.org/downloads/ Erweiterter Texteditor mit vielen nützlichen Funktionen   Google Chrome https://www.google.com/intl/de/chrome/ Web-Browser von Google mit sehr guten Entwickler-Funktionen   GIT https://git-scm.com/download/win Zugriff auf das Versionsverwaltungssystem GIT   Apache Maven https://maven.apache.org/download.cgi Build Management Tool von Apache, beim Herunterladen das Binary auswählen (nicht die Source)   JDK https://www.oracle.com/java/technologies/javase-jdk14-downloads.html Java Development Kit zur Herstellung von Java-Anwendungen   Postman https://www.postman.com/downloads/ Anwendung zum Absetzen von Requests an REST-Schnittstellen     Citrix Gateway Auf deinem SBB-Laptop befindet sich eine Anwendung mit dem Namen Citrix Gateway. Diese Anwendung erlaubt dir eine Verbindung zum SBB Intranet. Wenn du also von Zuhause aus oder in der Berufsschule auf das SBB Intranet zugreifen willst, dann brauchst du diese Anwendung. Wenn die Anwendung gestartet wird, wirst du automatisch mit dem SBB-Netz verbunden. In der Taskleiste erscheint das folgende Symbol Durch einen Klick auf das Icon siehst du den Verbindungsstatus Innerhalb eines SBB-Gebäudes mit Verbindung zu einem LAN oder WLAN der SBB brauchst du diese Anwendung nicht. Falls keine Verbindung zu irgendeiner Webseite oder einer Anwendung im SBB-Intranet besteht prüfe immer zuerst, ob der Citrix Gateway aktiv ist und ob du dort eine Verbindung hast.\n Firewall / Sicherheit Dein Betriebssystem verfügt mit dem Windows-Betriebssystem über eine eigene Firewall. Du bist persönlich für deren Konfiguration verantwortlich. Gleichzeitig verfügt das SBB-Netzwerk selbstverständlich über entsprechende Schutzmechanismen, darunter auch diverse Firewalls. Im Intranet der SBB ist der Besuch von diversen Webseiten eingeschränkt. Dein Browser informiert dich sofort, wenn du auf eine nicht zugelassene Seite navigierst.\nLies den folgenden Artikel im Intranet betreffend Weisungen über Datensicherheit und Datenschutz: https://sbb.sharepoint.com/sites/intranet_servicessupport/SitePages/datensicherheit-und-datenschutz.aspx\n Proxy Ein Proxy ist eine Kommunikationsstelle in einem Netzwerk. Je nachdem, in welchem Netzwerk du dich befindest ist die Konfiguration eines Proxys unumgänglich. Für die Nutzung von Services wie beispielsweise GIT sollten generell die folgenden Angaben für den Proxy verwendet werden:\nTyp: HTTP\nHostname: zscaler.sbb.ch\nPort: 10465\nKein Proxy für: localhost, 127.0.0.0/24, 10.0.0.0/8, 192.168.0.0/16, *.sbb.ch, *.cff.ch, *.ffs.ch, *.adrail.ch, *.sbb-wzu.net, *.wzu.io, *.sbb-aws.net, *.sbb-cloud.net, *.sbbintra.ch, *.swisspass.ch, *.sbbcargo.com\nProxy Authentifizierung: Personalnummer und Passwort\nDiese Einstellungen können in Applikationen wie IntelliJ oder Postman hinterlegt werden.\nDEV-Proxy Um bessere Verbindungen zu ermöglichen, gibt es noch den DEV-Proxy der Werkzeugunterstützung (WZU). Das Tutorial zum Einrichten gibt es hier: Entwickler-Proxy\n","categories":"","description":"Modul #O4 - Entwicklungsumgebung\n","excerpt":"Modul #O4 - Entwicklungsumgebung\n","ref":"/docs/java/entwicklungsumgebung/","tags":"","title":"Entwicklungsumgebung einrichten"},{"body":"Gegeben Gegeben ist das folgende Array mit Zahlen:\n1 2 3 4 5 6 7 8 9 10 11  int[] numbers = { -8, 0, 13, 0, -8, 23, -22, 18, -6, -1, -21, -1, 2, 20, -24, 21, 25, -16, -10, -2, -20, 15, -15, 0, -16, -19, 13, 24, -3, 7, 21, -15, 21, -11, 4, -17, 3, 11, 22, 12, 11, 12, 6, -4, -21, -20, -24, -3, -25, -13, 17, 19, 19, 20, 22, 9, -10, 12, 16, -1, 21, -24, 12, 19, -7, 15, 5, -22, 23, 12, 6, 2, -14, 12, 17, -13, 3, -4, -16, 8, 16, 6, -23, 0, 3, -16, -6, -14, 8, 25, -22, 2, 7, 8, -6, 20, 3, -5, -19, -15 };   Aufgabe 1 Schreibe eine Methode, welche alle Zahlen im Array zählt, welche zwischen 0 und 10 liegen und keine 5 sind. Die Methode liefert die Anzahl dieser Zahlen zurück.\nAufgabe 2 Schreibe eine Methode, welche aus dem Array alle positiven Zahlen inklusive 0 in ein neues Array schreibt Die Reihenfolge der Zahlen im Array muss gleich bleiben. Die Methode liefert das neue Array zurück.\nAufgabe 3 Schreibe eine Methode, welche aus dem Array alle Zahlen sucht, welche nicht mehr als 10 von der Zahl -6 abweichen. Schreibe diese Zahlen in ein neues Array. Die Methode liefert das neue Array zurück.\nAufgabe 4 Schreibe eine Methode, welche alle Zahlen aus dem Array in positive Zahlen verwandelt und diese in ein neues Array schreibt. Die Methode liefert das neue Array zurück.\nAufgabe 5 Schreibe eine Methode, welche alle Zahlen aus dem Array ausliest, die sich von ihren direkten Nachbarn um jeweils nicht mehr als den Wert 5 unterscheiden. Schreibe diese Zahlen in ein neues Array. Die Methode liefert das neue Array zurück. Für die erste und die letzte Zahl im Array gibt es nur einen Nachbar.\n","categories":"","description":"Einfache Aufgaben mit einem Zahlen-Array\n","excerpt":"Einfache Aufgaben mit einem Zahlen-Array\n","ref":"/exams/java/java-grundlagen/exam1/","tags":"","title":"Exam Java Grundlagen - Zahlen-Array"},{"body":"Die folgenden Aufgaben bestehen zum Teil aus Exception Handling. Behandle die Exception also auch so, wie es in der Theorie erklärt wurde.\nAufgabe 1: File Reader Hier findest du eine Datei, welche eine Liste mit ungefähr 466 Tausend englischen Wörtern enthält.\nSchreibe eine Anwendung, welche diese Wörter einlesen kann, und schreibe jeweils eine Methode für die folgenden Aufgaben:\n Zähle alle Wörter in dieser Liste Zähle alle Wörter, welche den Buchstaben Q benutzen Gib alle Sonderzeichen zurück, welche in der Liste vorkommen (jedes Zeichen wird nur einmal zurückgegeben) 2 weitere Methoden deiner Wahl  Implementiere vorher ein Interface, um deine Methoden zu definieren.\nAufgabe 2: File Writing Die Verwendung von System.out.println() hat das Problem, dass nach einem Neustart der Applikation alle Logs aus der Konsole verschwinden, dies kann mit der Zeit mühsam werden. Schreibe eine Klasse mit mindestens einer öffentlichen Methode, welcher man einen Text als Parameter gibt. Die Methode soll diesen Text zuerst in eine Datei mit dem Namen application.log speichern und nachher mit System.out.println() in die Konsole schreiben. Achte auch hier wieder auf ein entsprechendes Exception Handling.\nAufgabe 3: ParseInt Wenn wir Zahlen von einem User über die Konsole entgegennehmen wollen, kann man scanner.nextLine() brauchen. Wir können aber nie sicher sein, ob es sich bei der Eingabe wirklich um eine Zahl handelt. Darum müssen wir mit einem Exception Handling die Programmlogik vor einem solchen Fall schützen.\nSchreibe eine Anwendung, welche den User einzeln für zwei Zahlen fragt und diese dann entweder addiert, subtrahiert, multipliziert, oder dividiert. Die Auswahl der Rechnungsmethode kann zufällig oder durch den Benutzer erfolgen.\n","categories":"","description":"Aufgaben zu Modul #J5 - Exception Handling\n","excerpt":"Aufgaben zu Modul #J5 - Exception Handling\n","ref":"/labs/java/java-exception-handling/01_exercises/","tags":"","title":"Exception Handling - Aufgaben"},{"body":"Aufgabe 1 - generische Methode um alle Elemente in einem Array auszugeben Schreibe eine generische Methode, welche ein Array als Parameter erhält und alle Elemente im Array ausgibt. Verwende diese Methode jeweils mit Arrays, welche folgende Typen beinhalten: Integer, String, Double.\nAufgabe 2 - generische Klasse Schreibe eine generische Klasse “NumberList”, welche eine Liste von Zahlen erhält und folgende Operationen auf diesen Zahlen ausführen kann:\n Die grösste Zahl in der Liste finden Die kleinste Zahl in der Liste finden  Die Typen der Input-Zahlen können unterschiedlich sein (Ganzzahlen, Kommazahlen…)\n","categories":"","description":"Aufgaben zu Modul #J2 - Generics I\n","excerpt":"Aufgaben zu Modul #J2 - Generics I\n","ref":"/labs/java/java-generics/01_exercises/","tags":"","title":"Generics I - Aufgaben"},{"body":"Aufgabe 1 - Input-Elemente Um zu zeigen, wie einfach Input-Elemente verwendet werden könnten, kannst du folgendes Beispiel ausprobieren:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u003ch2\u003eLogin\u003c/h2\u003e \u003cform action=\"https://www.w3schools.com/action_page.php\" method=\"get\"\u003e \u003clabel\u003eemail: \u003cinput type=\"email\" name=\"your-email\" /\u003e\u003c/label\u003e \u003cbr /\u003e \u003clabel for=\"pw\"\u003epassword:\u003c/label\u003e \u003cinput type=\"password\" name=\"your-password\" id=\"pw\" /\u003e \u003cbr /\u003e \u003clabel\u003e\u003cinput type=\"checkbox\" name=\"stay\" value=\"yes\" /\u003eStay logged in.\u003c/label\u003e \u003ch4\u003eFavorite Language?\u003c/h4\u003e \u003cp\u003e \u003cinput type=\"radio\" id=\"html\" name=\"fav_language\" value=\"HTML\"\u003e \u003clabel for=\"html\"\u003eHTML\u003c/label\u003e\u003cbr\u003e \u003cinput type=\"radio\" id=\"css\" name=\"fav_language\" value=\"CSS\"\u003e \u003clabel for=\"css\"\u003eCSS\u003c/label\u003e\u003cbr\u003e \u003c/p\u003e \u003cinput type=\"submit\" /\u003e \u003c/form\u003e   Entwickle eine Registrierungsseite. Auf dieser Seite soll man mindestens folgendes angeben müssen:\n Name Email Gewünschtes Passwort Mögliche Interessen (mittels Checkboxen) Geburtsdatum Lieblingsfarbe Geschlecht (mittels Radiobuttons) Handynummer  Als Backend kannst du “https://www.w3schools.com/action_page.php\" (wie im vorherigen Beispiel) verwenden. Schaue nach dem Klick an, wie die Daten übermittelt worden sind. Wie sieht die URL im Browser aus? Variiere die HTTP Request Method.\nAufgabe 2 - Inspiziere diese Seite Suche auf dieser Website (ja, auf dieser IT Ninjas-Seite) mit Hilfe der Entwicklertools ([F12]-Taste) den \u003cheader\u003e, eine \u003cnav\u003e und den \u003cfooter\u003e.\nNotiere dir deine Erkenntnisse. Versuche zudem folgende Fragen zu beantworten:\n Wie ist diese Seite aufgebaut? Wo befinden sich \u003cheader\u003e, \u003cnav\u003e, usw.? Halte das in einer Skizze fest. Wie wurde die Übersicht (am linken Rand) und das rechte Aside (mit Git-Informationen) realisiert. Welche Tags und Attribute sind deiner Meinung nach die relevantesten? Würdest du das gleich realisieren? Oder was würdest du anders machen?  Aufgabe 3 - Dokument als HTML Suche einen spanneden Text (z.B. aus einer alten Word-Datei, Wikipedia-Artikel, Anleitung). Dieser Text sollte mehrere Überschriften und Bilder besitzen. Setze diesen Text mit HTML um und versuche bereits, viele Semantic Tags zu verwenden. Zeige dein Resultat einem Coach.\n","categories":"","description":"Aufgaben zu Modul #F3 - HTML\n","excerpt":"Aufgaben zu Modul #F3 - HTML\n","ref":"/labs/web/html_css/01_html/","tags":"","title":"HTML - Aufgaben"},{"body":"","categories":"","description":"Exercises zu HTML, CSS und JavaScript\n","excerpt":"Exercises zu HTML, CSS und JavaScript\n","ref":"/labs/web/html_css/","tags":"","title":"HTML, CSS und JavaScript - Aufgaben"},{"body":"","categories":"","description":"Challenges zu Java Module\n","excerpt":"Challenges zu Java Module\n","ref":"/challenges/java/","tags":"","title":"Java Challenges"},{"body":"","categories":"","description":"Labs zu Java\n","excerpt":"Labs zu Java\n","ref":"/labs/java/","tags":"","title":"Java Labs"},{"body":"Ziele  Ich kann Text und Zahlen auf der Konsole ausgeben Ich kann Text und Zahlen auf der Konsole eingeben und diese wieder ausgeben Ich kann statische Methoden schreiben, die einfache Rechnungen durchführen Ich kann statische Methoden mit Parametern und Return-Statements schreiben Ich verstehe und kenne die verschiedenen Conditional Statements Ich weiss, wann und wie ich welches Conditional Statement einsetzen sollte Ich verstehe, was Loops sind und kenne die verschiedenen Loops Ich weiss, wann und wie ich welchen Loop brauchen soll Ich kann mit Hilfe von String-Methoden Strings bearbeiten Ich kann Arrays initialisieren, auf deren Werte zugreifen und Werte in einem Array verändern Ich kann mein Programm mit einem Debugger zur Laufzeit untersuchen  Aufgabe 1 - Ausgaben auf die Kommandozeile Gib die folgenden Daten auf die Kommandozeile aus:\n Hello World Hello +  Zeichne ein Haus, nutze dazu beliebige Zeichen Zeichne eine Schweizerfahne  Aufgabe 2 - Eingaben von der Kommandozeile Lies zuerst deinen Namen und danach dein Alter über einen Scanner von der Kommandozeile ein und gib dann die folgenden Daten auf die Kommandozeile aus\n Hello + + you are + + years old  Aufgabe 3 - Einfache Berechnungen Berechne die folgenden Dinge:\n Fläche eines Rechtecks Fläche eines Kreises Umfang eines Rechtecks Inhalt einer Pyramide mit quadratischen Grundriss und einer bestimmten Höhe Berechne dein Alter am heutigen Tag in Jahren, Monaten und Tagen Schreibe eine Methode, welche eine beliebige Ganzzahl als Parameter übernimmt und die Vielfache von 3 zusammen mit der Vielfache von 5 dieser Zahl summiert.  Aufgabe 4 - Methoden Löse die folgende Aufgaben:\n Schreibe eine Methode, die zwei beliebigen Ganzzahlen als Parameter übernimmt und die Summe der beiden zurückliefert. Schreibe eine eigene Methode, die als Parameter einen Namen übernimmt. Die Methode soll dann die folgenden Daten auf die Kommandozeile ausgeben Hello + \u003cParameter-Name\u003e  Aufgabe 5 - Conditional Statements Löse die folgende Aufgaben:\n Schreibe eine Methode, die feststellen kann, ob eine Zahl (als Parameter) grösser, kleiner oder gleich 0 ist Schreibe eine Methode, die dich begrüsst wenn dein Name als Parameter übergeben wird Schreibe eine Methode, die feststellt, ob das übergebene Jahr ein Schaltjahr ist Schreibe eine Methode, die überprüft, ob eine Zahl (als Parameter) gerade oder ungerade ist Debugge mindestens zwei dieser Methoden mit einem Breakpoint  Aufgabe 6 - Loops Löse die folgenden Aufgaben:\n Schreibe eine Methode, welche eine beliebige Ganzzahl als Parameter übernimmt und die Fakultät dieser Zahl berechnet. Schreibe einen Loop, welcher alle Zahlen von 1 bis 100 zusammenzählt, welche durch 8 teilbar sind  Erweitere deine Lösung mit einer Methode, welche eine Zahl entgegennimmt und dann die Zahlen zusammenzählt, welche durch diese Zahl teilbar sind    Aufgabe 7 - Strings Löse die folgende Aufgaben:\n Schreibe eine Methode, welche als Parameter einen beliebigen String übernimmt und dessen Zeichenfolge umkehrt Schreibe eine Methode, welche als Parameter einen beliebigen String übernimmt und die Anzahl Wörter darin ausgibt  Aufgabe 8 - Arrays Löse die folgenden Aufgaben:\n Schreibe eine Methode, welche zwei Parametern übernimmt: einen beliebigen Zahlen-Array und eine beliebige Zahl. Die Methode gibt die Position der Zahl im Array aus. Schreibe eine Methode, welche als Parameter einen beliebigen Zahlen-Array übernimmt und die grösste Zahl im Array zurückliefert.  ","categories":"","description":"Exercises zu Modul #J1\n","excerpt":"Exercises zu Modul #J1\n","ref":"/labs/java/java-grundlagen/01_basicexercises/","tags":"","title":"Java Exercises - Grundlagen"},{"body":"Die Aufgabe besteht darin ein “Vier-Gewinnt” Spielfeld in Form eines zweidimensionalen Arrays zu überprüfen. Das zweidimensionale Array hat in beiden Dimensionen eine variable Grösse. Die zweite Dimension ist jedoch bei allen Arrays gleich gross.\nDas Ziel ist herauszufinden, ob auf einem gegebenen Spielfeld einer der Spieler gewonnen hat. Die Gewinnkombination in Form von vier aufeinanderfolgenden gleichen Feldern kann dabei horizontal, vertikal oder diagonal auf dem Spielfeld liegen. Im Spielfeld kommen drei Zeichen vor: “X” für Spielsteine von Spieler 1, “O” für Spielsteine von Spieler 2 und \" \" für ein Feld, wo noch kein Spielstein liegt.\nDie Methode, welche das Spielfeld überprüft liefert einen String als Rückgabewert zurück. Der Rückgabewert ist “X” falls Spieler 1 gewonnen hat, “O” wenn Spieler 2 gewonnen hat und \" \" wenn noch keiner der Spieler eine Gewinnkombination hat.\nDie Implementation muss in der folgenden Klasse gemacht werden:\n1 2 3 4 5 6 7 8 9  public class ConnectFourExtra implements ConnectFourCheck { @Override public String checkWin(String[][] board) { // TODO: Implementation here ...  // TODO: Change return value according to the challenge description  return \" \" + \"X\" + \"O\"; } }   Das dazugehörige Interface kann einfach als neue Klasse im gleichen Package angelegt werden:\n1 2 3  interface ConnectFourCheck { String checkWin(String[][] board); }   Wenn du an der Challenge teilnehmen willst, dann musst du die Aufgabe alleine lösen. Die Lösung vom Pult-Nachbar interessiert uns also (leider) nicht.\n","categories":"","description":"Challenge zu Modul #J1\n","excerpt":"Challenge zu Modul #J1\n","ref":"/challenges/java/java-grundlagen/01_basicchallenge/","tags":"","title":"Java Grundlagen Challenge"},{"body":"","categories":"","description":"Exams zu Modul #J1\n","excerpt":"Exams zu Modul #J1\n","ref":"/exams/java/java-grundlagen/","tags":"","title":"Java Grundlagen Exams"},{"body":"Persistente Notenverwaltungssystem Schreibe eine Konsolen-basierte Java Anwendung, welche deine Schulnoten verwaltet und in einer Datenbank persistiert.\nDie Anwendung soll mindestens die folgende Funktionalität beinhalten:\n Neue Note für ein bestimmtes Fach erfassen (inkl. Datum) Eine bestehende Note löschen Eine bestehende Note bearbeiten Den aktuellen Notenstand eines Fachs ausgeben (Auflistung aller Noten und die Durchschnittsnote) Die Durchschnittsnoten aller Fächer ausgeben (#Zeugnis)  Verwende eine MariaDB und setzte sie selbst auf. Den nötigen Treiber dazu findest du im Internet. Die Datenbank muss mindestens die folgenden Tabellen beinhalten:\n SCHOOL_SUBJECT - beinhaltet alle Schulfächer GRADE - beinhaltet alle gültigen Noten zwischen 1 und 6 (in 0.25 Stufen -\u003e also 1, 1.25. 1.5, 1.75, 2 usw..) SCHOOL_SUBJECT_GRADE - beinhaltet die Relation zwischen Schulfächern und Noten. Jede Zeile stellt eine Note für ein Fach an einem bestimmten Tag dar.  Achte auf korrektes Exception-Handling (denke an “try with resources”) und sauberen Code.\n","categories":"","description":"Modul #J8 - JDBC\n","excerpt":"Modul #J8 - JDBC\n","ref":"/labs/java/java-jdbc/01_jdbc_exercises/","tags":"","title":"JDBC - Aufgaben"},{"body":"java.util.List Listen sind geordnete Collections, denn sie enthalten beliebige Objekte in einer bestimmten Reihenfolge. In Listen werden eine Menge von Elemente (genauer genommen Referenzen auf Objekte) abgespeichert, wobei die Menge geordnet ist, da jedes Element an einer bestimmten Position zu finden ist:\nBeachte, dass wir bei den Listen, die Indexierung der Positionen bei 0 beginnt, genauso wie bei dem primitiven Datentyp Array.\nListen haben eine dynamische Grösse, d.h. die Grösse der Liste muss bei der Erstellung nicht bekannt sein und die Anzahl der enthaltenen Elemente kann sich während der Laufzeit ändern. Daher ist es möglich, fortlaufend Elemente zur Liste hinzuzufügen oder aus der Liste zu entfernen. Hierbei entstehen nie Lücken: Fügt man ein Element an einer bestimmten Position zur Liste hinzu, dann rutschen alle nachfolgenden Elemente eine Position nach. Entfernt man ein Element an einer bestimmten Position, so rutschen alle nachfolgen Elemente eine Position nach oben.\nMan kann auf Elemente über ihren ganzzahligen Index (Position in der Liste) zugreifen und nach Elementen in der Liste suchen.\nEin Element aus einer Liste entfernen:\nWie zu Beginn erwähnt, enthalten Lists Referenzen auf Objekte. Deshalb ist es nicht möglich, Listen zu erstellen, welche primitive Datentypen als Elemente enthalten (int, double, boolean, char, ...). Dafür müssen die sogenannten Wrapper-Klassen verwendet werden. Wrapper-Klassen bieten eine Möglichkeit, primitive Datentypen (int, double, boolean, char, …) als Objekte zu verwenden: java.lang.Integer, java.lang.Double, java.lang.Boolean, java.lang.Character,..\nSchauen wir uns die folgenden Beispiele an, wo wir einer Liste mit Elementen vom Typ Integer das Element 3 hinzufügen:\n1 2  List\u003cInteger\u003e integerList = new ArrayList\u003c\u003e(); integerList.add(Integer.valueOf(3));   Oben haben wir der Liste das Integer-Objekt 3 hinzugefügt - also ein Integer-Objekt und nicht der Wert des primitiven Datentyps int.\n1 2  List\u003cInteger\u003e integerList = new ArrayList\u003c\u003e(); integerList.add(3);   Beim unteren Beispiel haben wir der Liste den int-Wert 3 als primitiven Datentyp hinzu. Obwohl wir den int-Wert 3 als primitiver Datentypen und nicht als Integer-Objekte zur Liste integerList hinzufügen, kompiliert dieser Code genau so ohne Fehler. integerList ist jedoch eine Liste von Integer-Objekten und nicht eine Liste von int-Werten. Warum haben wir dann beim Kompilieren dieses Codes kein gekriegt?\nDer Copmiler konvertiert den int-Wert zu einem Integer-Objekt und fügt dieses dann zur Liste integerList hinzu. Diese Konvertierung nennt man Autoboxing. Autoboxing ist die automatische Konvertierung zwischen den primitiven Datentypen zu Objekten ihrer entsprechenden Wrapper-Klassen, die der Java Compiler durchführt (beispielsweise int zu Integer, double zu Double, ect.). Wenn die Konvertierung in die andere Richtung erfolgt, nennt man dies Unboxing.\nSomit ist es nicht mehr nötig, dass wir dieses Autoboxing wie im ersten Beispiel selber durchführen müssen.\nEinige Methoden vom Interface java.util.List 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  /* * Gibt die Anzahl der Elemente in dieser Liste zurück. */ int size(); /* * Gibt true zurück, wenn diese Liste keine Elemente enthält. */ boolean isEmpty(); /* * Gibt true zurück, wenn diese Liste das angegebene Element enthält. */ boolean contains(Object o); /* * Gibt das Element an der angegebenen Position in dieser Liste zurück. */ E get(int index); /* * Ersetzt das Element an der angegebenen Position in dieser Liste durch das angegebene Element. */ E set(int index,E element); /* * Gibt den Index des ersten Auftretens des angegebenen Elements in dieser Liste zurück, * oder -1, wenn diese Liste das Element nicht enthält. */ int indexOf(Object o); /* * Hängt das angegebene Element an das Ende der Liste an */ boolean add(E e); /* * Fügt das angegebene Element an der angegebenen Position in dieser Liste ein. * Verschiebt das Element, das sich derzeit an dieser Position befindet (falls vorhanden), * und alle nachfolgenden Elemente. */ void add(int index,E element); /* * Entfernt das erste Vorkommen des angegebenen Elements aus dieser Liste, * sofern es vorhanden ist. Wenn diese Liste das Element nicht enthält, * bleibt sie unverändert. */ boolean remove(Object o); /* * Entfernt das Element an der angegebenen Position in dieser Liste. */ E remove(int index); /* * Entfernt alle Elemente aus dieser Liste. /* void clear(); ...   Das Interface java.util.List im Collection Framework ist der Datentyp der Listen, wobei in der abstrakten Klasse java.util.AbstractList die grundlegenden Funktionalitäten implementiert sind, sodass diese den verschiedenen konkreten Listen-Implementierungen weiter geerbt werden können.\nAuf der nächsten Seite geht es mit einer konkreten Umsetzung einer List weiter. Nun wird es also praktischer!\n","categories":"","description":"Das Interface List.\n","excerpt":"Das Interface List.\n","ref":"/docs/java/java-collections/01_list/","tags":"","title":"List"},{"body":"Aufgabe 1 Wir programmieren eine eigene ArrayList-Klasse MyArrayList:\n Die Elemente sollen in einem Array gespeichert werden. Es dürfen keine Klassen aus dem Collection-Framework verwendet werden. Die Klasse muss das Interface MyListInterfaceSimple implementieren. Die Klasse weiss nicht, wie viele Element man speichert. Sie muss die Grösse der internen Datenstruktur dynamische anpassen. Die toString() der java.lang.Object Klasse soll von der MyArrayList so überschrieben werden, dass die Elemente kommasepariert ausgegeben werden: [Cat, Hamster, Dog, Goldfish]  Input  Inferface MyListInterfaceSimple 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  package com.examples.list; public interface MyListInterfaceSimple\u003cE\u003e { /** * Appends the specified element to the end of this list . * @param element element to be appended to this list */ void add(E element); /** * Returns the element at the specified position in this list. * @param index index of the element to return * @return the element at the specified position in this list * @throws IndexOutOfBoundsException if the index is out of range */ E get(int index) throws IndexOutOfBoundsException; /** * Removes the element at the specified position in this list. * Returns the element that was removed from the list. * soll IndexOutOfBoundsException werfen * @param index the index of the element to be removed * @return the element previously at the specified position */ E remove(int index) throws IndexOutOfBoundsException; /** * Returns the number of elements in this list. * If this list contains more than Integer.MAX_VALUE elements, returns Integer.MAX_VALUE. * @return the number of elements in this list */ int size(); /** * Returns true if this list contains no elements. * @return true if this list contains no elements */ boolean isEmpty(); /** * Removes all the elements from this list. The list will be empty after this call returns. */ void clear(); }    Aufgabe 2 Nun erweitern wir unsere MyArrayList Klasse.\n Erstelle eine Kopie deiner Klasse und nenne diese MyArrayListExtended. Diese soll das Interface MyListInterfaceExtended implementieren, welche folgende zusätzliche Methoden aufweist:   void add(int index, E element) boolean contains(Object o) int indexOf(Object o) E set(int index, E element) boolean equals(Object o) boolean remove(Object o)  Input  Inferface MyListInterfaceExtended 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97  package com.examples.list; public interface MyListInterfaceExtended\u003cE\u003e { /** * Appends the specified element to the end of this list . * @param element element to be appended to this list */ void add(E element); /** * Returns the element at the specified position in this list. * @param index index of the element to return * @return the element at the specified position in this list * @throws IndexOutOfBoundsException if the index is out of range */ E get(int index) throws IndexOutOfBoundsException; /** * Removes the element at the specified position in this list. * Returns the element that was removed from the list. * soll IndexOutOfBoundsException werfen * @param index the index of the element to be removed * @return the element previously at the specified position */ E remove(int index) throws IndexOutOfBoundsException; /** * Returns the number of elements in this list. * If this list contains more than Integer.MAX_VALUE elements, returns Integer.MAX_VALUE. * @return the number of elements in this list */ int size(); /** * Returns true if this list contains no elements. * @return true if this list contains no elements */ boolean isEmpty(); /** * Removes all the elements from this list. The list will be empty after this call returns. */ void clear(); /** * Inserts the specified element at the specified position in this list. * Shifts the element currently at that position (if any) and any subsequent elements to the right. * @param index index at which the specified element is to be inserted * @param element element to be inserted * @throws IndexOutOfBoundsException if the add operation is not supported by this list */ void add(int index, E element) throws IndexOutOfBoundsException; /** * Returns true if this list contains the specified element. * @param o element whose presence in this list is to be tested * @return true if this list contains the specified element */ boolean contains(Object o); /** * Returns the index of the first occurrence of the specified element in this list, * or -1 if this list does not contain the element. * @param o element to search for * @return the index of the first occurrence of the specified element in this list, * or -1 if this list does not contain the element */ int indexOf(Object o); /** * Replaces the element at the specified position in this list with the specified element. * @param index index of the element to replace * @param element element to be stored at the specified position * @return the element previously at the specified position * @throws IndexOutOfBoundsException if the index is out of range */ E set(int index, E element) throws IndexOutOfBoundsException; /** * Compares the specified object with this list for equality. * Returns true if and only if the specified object is also a list, both lists have the same size, * and all corresponding pairs of elements in the two lists are equal. * @param o the object to be compared for equality with this list * @return true if the specified object is equal to this list */ boolean equals(Object o); /** * Removes the first occurrence of the specified element from this list, if it is present. * If this list does not contain the element, it is unchanged. * @param o element to be removed from this list, if present * @return true if this list contained the specified element */ boolean remove(Object o); }    Aufgabe 3 Erstelle ein Programm, welches ein Zeugnis bestehend aus Modulen und deren Schlussnoten generiert und in der Konsole ausgibt.\nDazu sollen die Klassen Modul und LBV (Prüfung) erstellt werden. Zur weiteren Hilfe soll die ModulNotGradeableException dienen.\nAnforderungen an die LBV-Klasse:\n Die Note der LBV ist als Float-Attribut gespeichert Die Gewichtung der LBV ist ebenfalls als Float-Attribut gespeichert  Anforderungen an die Modul-Klasse:\n Ein Modul hat den Modulnamen als Attribut. Alle LBVs des Moduls, werden in einer ArrayList gespeichert. LBVs werden dem Modul über die addLBV(LBV exam) Methode hinzugefügt. Der Moduldurchschnitt, soll von der Methode getFinalModuleGrade() als float zurückgegeben werden. Das Modul kann nur bewertet werden, wenn die Gewichtung aller LBVs genau 1 ergib. Ansonsten soll eine ModulNotGradeableException geworfen werden. Die Methode printReportEntry() soll den Zeugnis-Eintrag des Moduls generieren und ausgeben. Dieser ist im Format \u003c MODUL_NAME\u003e : \u003cMODUL_SCHLUSSNOTE\u003e auszugeben.  ","categories":"","description":"Aufgaben zu [Java Collections - List](../../../../docs/java/java-collections/02_array-list)\n","excerpt":"Aufgaben zu [Java Collections - …","ref":"/labs/java/java-collections/01_list/","tags":"","title":"List - Aufgaben"},{"body":"Aufgabe 1 Schreibe ein Programm, welche aus der Kommandozeile eine Reihe von Zahlen liest und die Zahl an der Position x (x ist die erste Zahl in der Reihe) in der Konsole ausgibt. Folgende Bedingungen müssen eingehalten werden:\n Die Anzahl der Zahlen in der Reihe kann beliebig variert werden. Wenn es die Position nicht gibt, wird “ERROR! Die Position x existiert nicht” in der Konsole ausgegeben  Bei der Umsetzung dürfen keine Streams verwendet werden!\nBeispiel 1\nInput: 3 45 6 23 76 34\nOutput: Die Zahl an der Position 3 ist: 23\nBeispiel 2\nInput: 8 45 6 23 76 34\nOutput: ERROR! Die Position 8 existiert nicht\n Aufgabe 2 Schreibe ein Programm, welche einen Text mit einer beliebigen Anzahl Wörter aus der Kommandozeile liest und folgendes damit macht:\n Die Anzahl gelesene Wörter ausgeben Alle gelesenen Wörter in der Konsole wiedergeben Alle Nomen aus dem Text (Wörter, die mit einem grossen Buchstaben beginnen) in Grossbuchstaben ausgeben Alle gelesene Wörter in umgekehrte Reihenfolge ausgeben  Bei der Umsetzung dürfen keine Streams verwendet werden!\n","categories":"","description":"Aufgaben zu Modul #J2 - Lists Basics\n","excerpt":"Aufgaben zu Modul #J2 - Lists Basics\n","ref":"/labs/java/java-lists-and-streams-basics/01_listexercises/","tags":"","title":"Lists Basics - Aufgaben"},{"body":"Ziele  Ich weiss, was Markdown ist und welche Vorteile es hat Ich weiss, wie man mit Markdown eine einfache Dokumentation erstellt Ich weiss, wie man verschiedene Titel erstellt Ich weiss, wie man Paragraphen und Zeilenumbrüche erstellt Ich weiss, wie man fett und kursiv schreibt oder die beiden kombiniert Ich weiss, wie man Texte hervorheben kann Ich weiss, wie man Listen erstellt Ich weiss, wie man Code-Blöcke mit entsprechender Syntax erstellt Ich weiss, wie man Bilder und Links einfügen kann Ich weiss, wie man Tabellen erstellt   Einführung Lies den Markdown-Guide zur Einführung Markdown - Getting started durch. Das IntelliJ enthält per Default die Möglichkeit Markdown-Dateien zu bearbeiten und ihr finales Aussehen anzuzeigen. Um eine Markdown-Datei anzusehen gibt es auch die Möglichkeit den Online Markdown Editor Dillinger zu verwenden.\nAndere Markdown-Editoren sind:\n Ghostwriter Markdown Monster  Für Linux und Mac stehen jeweils andere Editoren zur Verfügung.\n Basic Syntax Lies die Dokumentation zur Basic Syntax durch. Dort erfährst du, wie man die wichtigsten Elemente im Markdown anlegen kann, um eine Dokumentation zu erstellen.\n Extended Syntax In der Erweiterung lernst du Tabellen und weitere nützliche Funktionen kennen. Lies das Kapitel durch und mach dich mit den Tabellen und dem Hervorheben von Code vertraut.\n Hacks Wenn du noch mehr wissen willst, bringt dich das Kapitel Hacks noch tiefer in nicht offizielle Funktionen von Markdown hinein.\n Cheat Sheet Das Cheat-Sheet mit den wichtigsten Teilen der Markdown-Syntax findest du hier\n","categories":"","description":"Modul #O4 - Markdown\n","excerpt":"Modul #O4 - Markdown\n","ref":"/docs/tools/markdown/","tags":"","title":"Markdown"},{"body":"Auftrag Einrichten von Maven  Generierung REPOSITORY_KEY Aufsetzen settings.xml IntelliJ Einstellungen überprüfen Umgebungsvariable einstellen  Maven-Projekt aufsetzen Erstellen eines neuen Projektes, welches wir später für das Modul Unit-Testing verwenden werden.\n Erstellen eines neuen persönlichen Repositories auf code.sbb.ch, der Name kann frei gewählt werden Klonen des neuen Repositories mit IntelliJ IDEA Repository aufsetzen wie unter code.sbb.ch beschrieben (nachdem man das Repo erstellt hat) Im IntelliJ die für Maven erforderliche Ordnerstruktur erstellen  Ordner src erstellen Im Ordner src zwei Ordner erstellen: main und test In den beiden Ordnern main und test jeweils zwei weitere Ordner erstellen: java und resources Die Ordner markieren (Rechtsklick -\u003e Mark Directory as…)  src/main/java -\u003e Sources Root src/main/resources -\u003e Resources Root src/test/java -\u003e Test Sources Root src/test/resources -\u003e Test Resources Root     Am Root des Projektes eine Datei mit dem Namen pom.xml anlegen und den folgenden Inhalt einfügen: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97  \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cgroupId\u003eDeine Group-ID\u003c/groupId\u003e \u003cartifactId\u003eDeine Artifact-ID\u003c/artifactId\u003e \u003cversion\u003e0.0.1-SNAPSHOT\u003c/version\u003e \u003cname\u003eName des Projekts\u003c/name\u003e \u003cdescription\u003eBeschreibung des Projekts\u003c/description\u003e \u003cproperties\u003e \u003cproject.build.sourceEncoding\u003eUTF-8\u003c/project.build.sourceEncoding\u003e \u003cjava.version\u003eJava-Version wählen\u003c/java.version\u003e \u003cmaven.build.timestamp.format\u003eyyyy-MM-dd HH:mm\u003c/maven.build.timestamp.format\u003e \u003ctimestamp\u003e${maven.build.timestamp}\u003c/timestamp\u003e \u003c/properties\u003e \u003cdependencies\u003e \u003c!-- Test --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter\u003c/artifactId\u003e \u003cversion\u003e5.6.2\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter-api\u003c/artifactId\u003e \u003cversion\u003e5.6.2\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter-engine\u003c/artifactId\u003e \u003cversion\u003e5.6.2\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter-params\u003c/artifactId\u003e \u003cversion\u003e5.6.2\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.vintage\u003c/groupId\u003e \u003cartifactId\u003ejunit-vintage-engine\u003c/artifactId\u003e \u003cversion\u003e5.6.2\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.platform\u003c/groupId\u003e \u003cartifactId\u003ejunit-platform-engine\u003c/artifactId\u003e \u003cversion\u003e1.7.0-RC1\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.platform\u003c/groupId\u003e \u003cartifactId\u003ejunit-platform-commons\u003c/artifactId\u003e \u003cversion\u003e1.7.0-RC1\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mockito\u003c/groupId\u003e \u003cartifactId\u003emockito-core\u003c/artifactId\u003e \u003cversion\u003e4.1.0\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003cbuild\u003e \u003cplugins\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e \u003cartifactId\u003emaven-compiler-plugin\u003c/artifactId\u003e \u003cconfiguration\u003e \u003ccompilerVersion\u003e${java.version}\u003c/compilerVersion\u003e \u003csource\u003e${java.version}\u003c/source\u003e \u003ctarget\u003e${java.version}\u003c/target\u003e \u003c/configuration\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c/build\u003e \u003cdevelopers\u003e \u003cdeveloper\u003e \u003cid\u003eDeine Personalnummer\u003c/id\u003e \u003cname\u003eDein Name\u003c/name\u003e \u003cemail\u003eDein E-Mail\u003c/email\u003e \u003corganization\u003eSBB\u003c/organization\u003e \u003corganizationUrl\u003ehttps://www.sbb.ch\u003c/organizationUrl\u003e \u003croles\u003e \u003crole\u003eDeine Rolle\u003c/role\u003e \u003c/roles\u003e \u003c/developer\u003e \u003c/developers\u003e \u003c/project\u003e    Das Projekt im IntelliJ als Maven-Projekt hinterlegen, zu diesem Zweck Ctrl+Shift+A drücken und als Aktion “Maven” eintragen.\nAus der Liste dann entweder “Add as Maven Project” oder “Add Maven Projects” wählen.\nBei der ersten Aktion wird das Projekt direkt hinzugefügt, bei der zweiten muss das pom.xml noch ausgewählt werden Auf der rechten Seite im IntelliJ gibt es den Tab Maven, dort müsste das Projekt nun erscheinen.  Wenn alles geklappt hat, dann werden die definierten Abhängigkeiten aus dem POM in das lokale Repository heruntergeladen.\n","categories":"","description":"Aufgaben zu Modul #S2 - Maven\n","excerpt":"Aufgaben zu Modul #S2 - Maven\n","ref":"/labs/java/maven/01_exercises/","tags":"","title":"Maven und Continuous Integration - Aufgaben"},{"body":"Schreibe eine Anwendung, in welcher Patienten einen medizinischen Check-Up durchgehen, um ihre Daten für das Spital zu erfassen.\nEin Patient\n hat einen Namen  Der Checkup nimmt\n die Grösse, das Gewicht, die Temperatur und ob der Patient geimpft ist  Die Anwendung soll  mit einem Patienten einen Check-Up durchführen die Grösse eines Patienten zurückgeben das Gewicht eines Patienten zurückgeben die Temperatur eines Patienten zurückgeben Überprüfen ob der Patient geimpft ist  Es sollen keine Set Methoden für das Einfügen der Werte verwendet werden!\n","categories":"","description":"Aufgabe zu Modul #J2 - OOP - Patienten\n","excerpt":"Aufgabe zu Modul #J2 - OOP - Patienten\n","ref":"/labs/java/java-oop/01_patienten/","tags":"","title":"Patienten"},{"body":"Aufgabe 1 Schreibe ein Programm, welches aus der Kommandozeile eine Reihe von Zahlen in einer beliebigen Reihenfolge liest und die unsortierte wie auch die sortierte Liste in der Konsole ausgibt.\nAufgabe 2 Schreibe ein Programm, welches aus der Kommandozeile eine Reihe von Zahlen in einer beliebigen Reihenfolge liest. Jede Zahl in der Liste wird mit sich selber multipliziert und schlussendlich werden die ursprüngliche wie auch die neue Liste (mit den Berechnungen) in der Konsole ausgegeben - einmal unsortiert und einmal sortiert.\n","categories":"","description":"Aufgaben zu Modul #J2 - Lists Basics\n","excerpt":"Aufgaben zu Modul #J2 - Lists Basics\n","ref":"/labs/java/java-lists-and-streams-basics/02_streamexercises/","tags":"","title":"Streams Basics - Aufgaben"},{"body":"Inhalt In diesem Bereich werden Tools vorgestellt, welche du beim Erstellen von Lerndokumentation o.ä\neinsetzen wirst.\n","categories":"","description":"Einführung Markdown,   Word Basics\n","excerpt":"Einführung Markdown,   Word Basics\n","ref":"/docs/tools/","tags":"","title":"Tools"},{"body":"Die folgenden Aufgaben bestehen darin für bestehende Programmlogik entsprechende Unit-Tests zu schreiben.\nAufgabe 1: Tageszeit Schreibe Unit-Tests, um die Logik der folgenden Methode zu testen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  import java.time.LocalDateTime; public class TimeOfDay { public String getTimeOfDay(LocalDateTime time) { if (time.getHour() \u003c 6) { return \"Night\"; } if (time.getHour() \u003c 12) { return \"Morning\"; } if (time.getHour() \u003c 18) { return \"Afternoon\"; } return \"Evening\"; } }   Aufgabe 2 Schreibe Unit-Tests, um die Methode move zu testen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  public class Mover { private LocalDateTime lastMovingTime; private Direction lastDirection; public void move(Direction direction) { if (Direction.getOpposite(direction) != this.lastDirection) { this.lastDirection = direction; this.lastMovingTime = LocalDateTime.now(); } } public LocalDateTime getLastMovingTime() { return lastMovingTime; } public Direction getLastDirection() { return lastDirection; } private enum Direction { NORTH, EAST, SOUTH, WEST; public static Direction getOpposite(Direction direction) { switch (direction) { case NORTH -\u003e { return SOUTH; } case EAST -\u003e { return WEST; } case SOUTH -\u003e { return NORTH; } case WEST -\u003e { return EAST; } } return null; } } }   Falls du meinst, dass es unmöglich ist diese Methode genau zu testen. Schreibe die Methode um, damit sie einfacher zu testen ist. Benutze dazu ein Clock-Objekt. Weitere Informationen findest du hier.\nAufgabe 3 In dieser Aufgabe geht es darum, dass die Unit-Tests für eine bestimmte Methode schon geschrieben wurden. Die Methode muss nun implementiert werden, so dass sie alle Unit-Tests erfüllt. Arbeite dich von Test zu Test durch.\nTest Source\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  import static org.junit.jupiter.api.Assertions.assertTrue; import org.junit.jupiter.api.Test; public class PasswordValidatorTest { private PasswordValidator uut; @Test public void testPasswordNull() { assertFalse(this.uut.isPasswordValid(null)); } @Test public void testPasswordTooShort() { assertFalse(this.uut.isPasswordValid(\"1234567\")); } @Test public void testPasswordTooLong() { assertFalse(this.uut.isPasswordValid(\"ABCDEFGHIJKLMNOPQRSTU\")); } @Test public void testPasswordContainsNoSpace() { assertFalse(this.uut.isPasswordValid(\"ABCDEFGHIJKLMNOPQR T\")); } @Test public void testPasswordContainsNoNumeric() { assertFalse(this.uut.isPasswordValid(\"ABCDEFGHIJKLMNOPQRST\")); } @Test public void testPasswordContainsNoLowercaseChar() { assertFalse(this.uut.isPasswordValid(\"ABCDEFGHIJ0123456789\")); } @Test public void testPasswordContainsNoUppercaseChar() { assertFalse(this.uut.isPasswordValid(\"abcdefghij0123456789\")); } @Test public void testPasswordContainsNoSpecialChar() { assertFalse(this.uut.isPasswordValid(\"abcdeFGHIJ0123456789\")); } @Test public void testPasswordValid() { assertTrue(this.uut.isPasswordValid(\"abcdeFGHIJ01234$*%?+\")); } }   Source\n1 2 3 4 5 6  public class PasswordValidator { public boolean isPasswordValid(String password) { // Ersetze die Exception durch deine Implementation...  throw new IllegalStateException(); } }   Wenn du eine Lösung gefunden hast, dann kannst du diese noch aufräumen (Refactoring).\n","categories":"","description":"Aufgaben zu Modul #J4 - Unit Testing / JUnit\n","excerpt":"Aufgaben zu Modul #J4 - Unit Testing / JUnit\n","ref":"/labs/java/java-testing/01_unit-testing/","tags":"","title":"Unit Testing mit JUnit - Aufgaben"},{"body":" Git [ɡɪt] ist eine freie Software zur verteilten Versionsverwaltung von Dateien, die durch Linus Torvalds initiiert wurde.\n Inhalt  Was ist Versionsverwaltung Geschichte Name Wie funktioniert Git  Was ist Versionsverwaltung Eine Versionsverwaltung ist ein System, welches Änderungen an einer oder mehreren Dateien über die Zeit protokolliert, um die Entwicklung nachvollziehbar zu machen und womit man jederzeit auf bestimmte vorherige Versionen zugreifen kann.\nLokale Versionsverwaltung Eine lokale Versionsverwaltung hat wohl fast jeder schon mal bei sich eingesetzt. Die einfachste Version davon ist, wenn man zum Beispiel eine Datei kopiert und an der Kopie weiter arbeitet:\n1 2  [user@computer ~/gymi/arbeit/]$ ls matura_arbeit.docx matura_arbeit_fastfertig.docx matura_arbeit_wirklichfertig.docx matura_arbeit_wirklichfertig_formatiert.docx matura_final.docx   Dies ist jedoch sehr Fehleranfällig, da man schnell die falsche Datei erwischt. Aus diesem Grund, haben Programmierer bereits vor langer Zeit, lokale Versionsverwaltungssysteme entwickelt, die alle Änderungen an allen relevanten Dateien in einer Datenbank verwalten. Ein Beispiel dafür ist RCS\nZentrale Versionsverwaltung Um die Zusammenarbeit von mehreren Personen zu vereinfachen wurden zentrale Versionsverwaltungssysteme entwickelt. Diese Systeme basieren auf einem zentralen Server der alle Dateien verwaltet. User holen eine Datei ab (Auschecken oder engl. to check out) editieren sie und nur berechtigte User dürfen die Datei anschliessend wieder auf den Server stellen. Ein Beispiel dafür ist SVN\nVerteilte Versionsverwaltung Im Gegensatz zu zentralen Systeme wo der Benutzer nur den letzten Stand zur Verfügung hat, kopiert er bei verteilten Versionsverwaltungen eine vollständiger Klon des Repositories auf sein System und hat somit auch die komplette Geschichte lokal. Dies vereinfacht dem Entwickler das lokale arbeiten und erhöht die Ausfallsicherheit. Zusätzlich können solche System gut mit verschiedenen externen Repositories (Remotes) umgehen was die Zusammenarbeit weiter vereinfacht. Ein Beispiel dafür ist GIT\nGeschichte Git entstand aufgrund einer Lizenzänderung von BitKeeper, der Versionsverwaltung welche vom Linux Kernel bis 2005 verwendet wurde. Da die Kernel Entwickler die Software nicht mehr kostenlos nutzen konnten, entwickelten sie selber eine Lösung. Ziele der neuen Software waren Geschwindigkeit, einfaches Design, gute Unterstützung von nicht linearer Entwicklung, dezentrale Struktur und die Fähigkeit grosse Projekte effektiv zu verwalten. Git wird seit 2005 kontinuierlich weiterentwickelt.\nName Der Name „Git“ bedeutet in der britischen Umgangssprache so viel wie „Blödmann“. Linus Torvalds erklärte seine Wahl des ungewöhnlichen Namens mit einem Witz sowie damit, dass das Wort praktikabel und in der Softwarewelt noch weitgehend unbenutzt war:\n „Ich bin ein egoistischer Mistkerl, und ich benenne all meine Projekte nach mir. Zuerst ‚Linux‘, jetzt eben ‚Git‘.“\n – Linus Torvalds\nDazu muss man anmerken, dass Linus den Namen Linux nur widerwillig akzeptierte.\nWie funktioniert Git Git funktioniert im Gegensatz zu den meisten anderen Versionsverwaltungen nicht indem es eine Liste von Änderungen an einer Datei abspeichert, sondern eher wie ein Dateisystem, welches bei jedem Commit ein Snapshot aller Dateien anlegt. Um effizient zu bleiben, werden unveränderte Dateien nicht kopiert sondern nur verknüpft. Weiter stellt Git die Integrität aller verwalteten Dateien sicher, indem es eine Prüfsumme jeder Datei anlegt. Dies verunmöglicht Änderungen an Dateien, ohne dass es Git mitbekommen würde.\nDrei Zustände einer Datei Eine Datei in einem Git Repository kann drei (Haupt-) Zustände haben:\n Modified: Die Datei wurde geändert aber noch nicht in die lokale Datenbank eingecheckt. Staged: Die Datei wurde im aktuellen Zustand für den nächsten Commit vorgemerkt. Commited: Die Datei ist im aktuellen Zustand in die lokale Datenbank eingecheckt.  Minimaler Workflow Hat man ein Repository von einem anderen Rechner geklont, kann man eine oder mehrere Dateien im Verzeichnisbaum editieren. Anschliessend staged man diese Änderungen und commited diese anschliessend.\n","categories":"","description":"","excerpt":" Git [ɡɪt] ist eine freie Software zur verteilten Versionsverwaltung …","ref":"/docs/git/was-ist-git/","tags":"","title":"Was ist Git"},{"body":"Schreibe eine Anwendung, welche einen Zoo modelliert. Die Anwendung soll folgende Klassen enthalten:\n Personen Gehege Tiere  Jede dieser Klassen soll mehrere Spezialisierungen enthalten.\nBei den Personen wird zwischen Mitarbeitern und Mitgliedern unterschieden. Ein Mitarbeiter hat beispielsweise einen Lohn, welcher ein Mitglied nicht hat. Die folgenden Attribute sollen vorhanden sein:\n Lohn Beschreibung des Jobs Telefonnummer Mitglied seit Nummer der Mitglied-Karte  Verteile die Attribute also korrekt auf die Generalisierung und die Spezialisierungen.\nBei den Gehegen wird unterschieden zwischen Gelände, Terrarium, Aquarium und Käfig. Die einzigartigen Eigenschaften der verschiedenen Gehege sollen wie folgt modelliert werden:\n Gehege-Nummer Grösse in Quadratmeter Temperatur Feuchtigkeit Süss- / Salzwasser Fassungsvermögen Zaunhöhe Wassergraben vorhanden  Verteile die Attribute also korrekt auf die Generalisierung und die Spezalisierung. Selbstverständlich kann ein Gehege auch von einem anderen abgeleitet werden.\nBei den Tieren könnt ihr selber entscheiden, welche Tiere euer Zoo enthalten soll und wie diese auf die Gehege verteilt werden.\nFalls ihr keine Ideen habt, gibt es hier ein paar Beispiele:\n Landtiere Amphibien Wassertiere Vögel  oder\n Aufteilung nach Spezies wie Insekten, Säugetiere, Wirbeltiere, Reptilien  oder\n Aufteilung nach Ernährung (Fleischfresser, Pflanzenfresser, Allesfresser :-))  Der Zoo hat also Mitarbeiter und Mitglieder und verschiedene Tiere, die in verschiedenen Gehegen leben. Die Beziehung zwischen den einzelnen Klassen wie dem Zoo seinen Gehegen und Tieren soll sich an der realen Welt orientieren.\n","categories":"","description":"Aufgabe zu Modul #J3 - OOD - Zoo\n","excerpt":"Aufgabe zu Modul #J3 - OOD - Zoo\n","ref":"/labs/java/java-ood/01_zoo/","tags":"","title":"Zoo"},{"body":"Eine Nachricht loggen In Java hast du Text mit System.out.println(...), in C# mit Console.WriteLine(...) und in Python vielleicht mit print(...) geloggt. Genau das gibt es auch in JavaScript.\nIn einer HTML-Datei kannst du folgendes hinzufügen:\n1 2 3 4 5  \u003cscript\u003e ... console.log('hello world'); \u003c/script\u003e   Um diese Meldung sehen zu können, musst du die Konsole des Browsers öffnen. Dies kannst du machen, indem du die Entwickler-Tools des Browsers öffnest (z.B. mit der [F12]-Taste). Anschliessend navigierst du zum “Konsole”-Tab. Nun solltest du die geloggte Nachricht entdecken können:\nCode direkt im Browser ausführen Du kannst Code direkt in der Konsole des Browsers ausführen lassen. Klicke hierfür in das Eingabefeld unterhalt deiner geloggten Nachricht. Dort kannst du dann folgendes reinkopieren:\n1 2 3  for (let i = 0; i \u003c 10; i++){ console.log(i); }   Nun sollten in deiner Konsole die Zahlen 0 - 9 geloggt worden sein. Den Code solltest du bereits seit deiner Einführung in Java verstehen. Das einzig neue hier ist, dass du hier die Nummer-Variable mit let deklariert hast.\nDu hast gesehen, wie einfach du Code auf der Website mit Hilfe der Konsole ausführen kannst. Die Konsole ist ein sehr mächtiges Tool, das die Entwicklung mit JavaScript extrem vereinfachen kann. Bevor du Code in der IDE (also deiner Entwicklungsumgebung) eingibst, kannst du vorher in der Konsole ausprobieren, ob dein Code zum gewünschten Resultat führt.\n","categories":"","description":"Konsole des Browsers benutzen.\n","excerpt":"Konsole des Browsers benutzen.\n","ref":"/docs/web/javascript/02_js_browser_tools/","tags":"","title":"JavaScript: Konsole"},{"body":"Eine HTML-Seite mit formatiertem Text erstellen Wir beginnen ganz unkompliziert. Erstellen wir zuerst eine Text-Datei. Dafür erstellen wir zuerst ein Ordner, in dem wir später unsere Projekt-Dateien speichern. Anschliessend kannst du diesen Ordner mit der IDE (Entwicklungsumgebung) deiner Wahl öffnen (hier VS Code). Erstelle nun eine neue HTML-Datei im soeben erstellten Ordner. In VS Code kannst du das z.B. wie folgt machen:\nFülle diese Datei nun mit irgendeinem Text. Speichere diese Datei. Kopiere nun den Pfad zu dieser Datei. In VS Code kannst du den Pfad mit einem Rechtsklick auf die Datei kopieren:\nGib diesen Pfad nun im Browser deiner Wahl ein. Du solltest nun einen unformatierten Text im Browser sehen:\nAbwohl du vorher evtl. Zeilenumbrüche und mehrer Leerschläge hattest, verschwinden diese im Browser nun. Dies kannst du umgehen, indem den Text mit Hilfe von HTML-Tags formatierst. Den HTML-Code könnte z.B. dann so aussehen:\n1 2 3 4 5 6  \u003ch1\u003eKleiner Witz\u003c/h1\u003e \u003cp\u003eWie viele Softwareentwickler braucht man, um eine Glühbirne auszuwechseln?\u003c/p\u003e \u003cp\u003eKeinen, das ist ein Hardware-Problem!\u003c/p\u003e   Nun hast du eine Seite mit formatiertem Text:\nWas haben wir hier genau gemacht? Das erfährst du auf der nächsten Seite.\n","categories":"","description":"Beginne mit der Entwicklung mit HTML.\n","excerpt":"Beginne mit der Entwicklung mit HTML.\n","ref":"/docs/web/html_css/02_html_first_code/","tags":"","title":"Erste Seite erstellen"},{"body":"","categories":"","description":"Exams zu TypeScript und Angular.\n","excerpt":"Exams zu TypeScript und Angular.\n","ref":"/exams/web/angular/","tags":"","title":"Angular Exams"},{"body":"Was ist TypeScript Die Programmiersprache wurde von Microsoft entwickelt und wurde im Jahr 2012 mit der ersten Version veröffentlicht. Seitdem wird die Programmiersprache kontinuierlich weiterentwickelt. Zahlreiche JavaScript-Frameworks setzen heute auf die Verwendung von TypeScript. Dazu gehören zum Beispiel Angular 2+ und React.\nTypeScript bildet eine Obermenge von JavaScript, erweitert also JavaScript um bestimmte Features. Es handelt sich dabei also um ein sogenanntes Superset von JavaScript.\nDa Quellcode geschrieben in TypeScript zu JavaScript transpiliert wird, ist der Code in jedem Browser lauffähig.\nVorteile von TypeScript  TypeScript hebt Fehler während der Kompilierung hervor, während JavaScript - zur Laufzeit. TypeScript unterstützt statische Typisierung. Ermöglicht bessere Code-Strukturierung und Objekt-Orientierte Programmiertechniken. TypeScript ist in jedem Browser oder JS Engine lauffähig. Hervorragendes “Tooling” mit IntelliSense, das beim Hinzufügen des Codes aktive Hinweise liefert.  Grundlegende Syntax Da es sich bei TypeScript um ein Superset von JavaScript handelt, ist JavaScript-Code auch gültiger TypeScript-Code. Jedoch fügt TypeScript darüber hinaus viele neue Funktionen hinzu.\nMit TypeScript wird JavaScript mehr wie eine stark typisierte, objektorientierte Sprache, die C # und Java ähnelt. Dies bedeutet, dass TypeScript-Code für grosse Projekte leichter zu verwenden ist und dass Code leichter zu verstehen und zu verwalten ist. Die starke Typisierung bedeutet auch, dass die Sprache vorkompiliert werden kann und dass Variablen keine Werte zugewiesen werden können, die ausserhalb ihres angegebenen Bereichs liegen. Wenn zum Beispiel eine TypeScript-Variable als Zahl deklariert ist, kann man dieser Variable keinen Textwert zuweisen.\nTypanmeldungen Typdeklarationen können zu Variablen, Funktionsparametern und Funktionsrückgabetypen hinzugefügt werden. Der Typ folgt jeweils nach einem Doppelpunkt hinter dem Variablennamen:\n1  var num: number = 1;   Der Compiler überprüft dann die Typen während des Kompilierens und meldet allfällige Typfehler.\nDie verschiedenen Grundtypen von TypeScript sind hier ersichtlich.\nDer Objektorientierte Ansatz Bei der objektorientierten Programmierung handelt es sich um einen Programmierstil / eine Denkweise.\nMan kann sich das so vorstellen, dass alles in der objektorientierten Programmierung durch Objekte abgebildet wird. Jedes “Teil” eines Programmes wird durch ein Objekt beschrieben.\nEin Beispiel:\n In einer Spielewelt gibt es einen frei herumlaufenden Hund. Dann wäre dieser Hund nichts anderes als ein Objekt. Nun könnte man sich fragen, wie man diesen Hund wahrnimmt, denn nicht jeder Hund ist gleich. Sie könnten sich in Rasse, Gattung etc. unterscheiden. Ein Objekt kann also verschiedene Eigenschaften besitzen, diese werden auch Attribute genannt.\n Nun kann sich unser Hund von Anderen unterscheiden, jedoch kann er noch nicht bellen. Deshalb haben Objekte auch Funktionen (Methoden). In unserem Beispiel könnte der Hund z.B. über die Methode “bark()” verfügen, welche ihm erlaubt zu bellen.\nIn unserem Beispiel handelt es sich bei dem Hund um eine Klasse. Klassen sind also wie Baupläne für Objekte.\nNun sagen wir, dass es in unserer Spielwelt auch Katzen gibt. An dieser Stelle kommt dann die Vererbung ins Spiel.\nHunde sowie Katzen sind beides Tiere. In der Objektorientierten Programmierung würde man dazu also eine Klasse “Animal” erstellen. Die beiden Klassen “Cat” und “Dog” würden dann die Klasse “Animal” erben. Dies Bedeutet, dass sie die Eigenschaften der Klasse “Animal” übernehmen und durch ihre eigenen Eigenschaften erweitern.\nDa sich beide Tiere fortbewegen, könnte man also der Klasse “Animal” die Funktion “move()” geben, welche dann von den beiden anderen Klassen geerbt werden würde. Dadurch hat man verhindert, dass sich die Funktion zum bewegen mehrmals im Quellcode befindet.\nKlassen Ein einfaches Beispiel einer Klasse:\n1 2 3 4 5 6 7 8 9 10 11  class Greeter { greeting: string; constructor(message: string) { this.greeting = message; } greet() { return \"Hello, \" + this.greeting; } } let greeter = new Greeter(\"world\");   In diesem Beispiel wird eine neue Klasse “Greeter” deklariert. Die Klasse enthält 3 Member:\n Das Property “greeting” Den Konstruktor Die Methode “greet”  Wenn wir in einer Klasse auf ein Member innerhalb der Klasse referenzieren, verwenden wir this..\nAuf der letzten Zeile erstellen wir eine neue Instanz der Klasse Greeter mit new.\nVererbung In TypeScript können wir allgemeine objektorientierte Muster verwenden. Eines der grundlegendsten Muster in der klassenbasierten Programmierung ist die Möglichkeit, vorhandene Klassen durch Vererbung zu erweitern, um neue Klassen zu erstellen.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Animal { move(distanceInMeters: number = 0){ console.log(`Animal moved ${distanceInMeters}m.`); } } class Dog extends Animal { bark(){ console.log(\"Woof!\"); } } const dog = new Dog(); dog.bark(); dog.move(10); dog.bark();   Dieses Beispiel zeigt die grundlegendste Vererbungsfunktion: Klassen erben Eigenschaften und Methoden von Basisklassen. Dog ist hier eine abgeleitete Klasse, die mit dem Schlüsselwort extends von der Basisklasse Animal abgeleitet wird. Abgeleitete Klassen werden häufig als Unterklassen bezeichnet, und Basisklassen als Superklassen.\nDa Dog die Funktionalität von Animal erweitert, konnten wir eine Instanz von Dog erstellen, die sowohl bark() als auch move() ausführen konnte.\nEin komplexeres Beispiel zur Vertiefung:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  class Animal { name: string; constructor(theName: string){ this.name = theName; } move(distanceInMeters: number = 0){ console.log(`Animal moved ${distanceInMeters}m.`); } } class Snake extends Animal { constructor(name: string){ super(name); } move(distanceInMeters: number = 5){ console.log(\"Slithering...\"); super.move(distanceInMeters); } } class Horse extends Animal { constructor(name: string){ super(name); } move(distanceInMeters: number = 45){ console.log(\"Galloping...\"); super.move(distanceInMeters); } } let sammy = new Snake(\"Sammy the Python\"); let tom: Animal = new Horse(\"Tom the Palomino\"); sammy.move(); tom.move(35);   In diesem Beispiel werden 2 neue Subklassen von Animal erstellt: Horse und Snake.\nEin Unterschied zum vorherigen Beispiel besteht darin, dass jede abgeleitete Klasse, die eine Konstruktorfunktion enthält, super() aufrufen muss, wodurch der Konstruktor der Basisklasse ausgeführt wird. Ausserdem müssen wir super() aufrufen, damit wir im Konstruktorkörper auf name mit this zugreifen können.\nKonsolenausgabe des Beispiels:\n1 2 3 4  Slithering... Sammy the Python moved 5m. Galloping... Tom the Palomino moved 34m.   Public In den gezeigten Beispielen konnten wir frei auf die Eigenschaften und Methoden einer Klasse (Member) zugreifen, die wir deklariert hatten. Jedoch mussten wir dazu public nie verwenden. Dies liegt daran, dass in TypeScript jedes Member stantardmässig public ist.\nEin Member können wir trotzdem als public markieren. Wir hätten die Klasse Animal aus dem vorherigen Abschnitt folgendermassen schreiben können:\n1 2 3 4 5 6 7 8 9  class Animal { public name: string; public constructor(theName: string){ this.name = theName; } public move(distanceInMeters: number = 0){ console.log(`Animal moved ${distanceInMeters}m.`); } }   Private Wenn ein Member einer Klasse als private markiert ist, kann von ausserhalb der Klasse nicht darauf zugegriffen werden.\n1 2 3 4 5 6 7  class Animal { private name: string; constructor(theName: string){ this.name = theName; } } new Animal(\"Cat\").name; // Error: 'name' is privae;   Protected Der Modifikator protected verhält sich ähnlich wie der Modifikator private, mit der Ausnahme, dass auf als protected deklarierte Member auch innerhalb von abgeleiteten Klassen zugegriffen werden kann.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Person { protected name: string; constructor(name: string){ this.name = name; } } class Employee extends Person { private departement: string; constructor(name: string, departement: string){ super(name); this.departement = departement; } public getElevatorPitch(){ return `Hello, my name is ${this.name}and I work in ${this.departement}.`; } } let john = new Employee(\"Howard\", \"Sales\"); console.log(john.getElevatorPitch()); console.log(john.name); // Error   name können wir ausserhalb von Person nicht verwenden, jedoch innerhalb einer Instanzmethode von Employee. Dies funktioniert, da Employee von Person abgeleitet ist.\nReadonly Mit readonly können wir Eigenschaften schreibgeschützt machen. Schreibgeschützte Eigenschaften müssen bei ihrer Deklaration oder im Konstruktor initialisiert werden.\n1 2 3 4 5 6 7 8 9 10  class Octopus { readonly name: string; readonly numberOfLegs: number = 8; constructor(name: string){ this.name = name; } } let dad = new Octopus(\"Man with the 8 strong legs\"); dad.name = \"Man with the 3-piece suit\"; // Error: name is readonly   Arrow Functions Die ES6-Version von TypeScript bietet eine arrow-function, die die Kurzform für die Definition der anonymen Funktion darstellt. In anderen Sprachen auch bekannt als Lambda-Function.\nWieso werden Arrow-Functions benutzt?\n Man muss nicht ständig “function” schreiben Es erfasst die Bedeutung des Schlüsselworts “this” Es erfasst die Bedeutung von Argumenten  Eine Arrow Function können wir in 3 Teile aufteilen:\n Parameter Die arrow-notation =\u003e Statements  Schauen wir uns ein Beispiel an:\n1 2 3 4 5 6 7 8 9  // ES5: Without arrow function var getResult = function(unsername, points){ return username + 'scored' + points + ' points!'; } // ES6: With arrow function var getResult = (unsername: string, points: number): string =\u003e { return `${username}scored ${points}points!'`; }   Arrow-functions benötigen natürlich nicht unbedingt Parameter. Ein Beispiel mit Parameter würde so aussehen:\n1 2 3 4  let sum = (a:number, b: number): number =\u003e{ return a + b; } console.log(sum(20,30)); // returns 50   Ein Beispiel ohne Parameter:\n1 2  let Print = () =\u003e console.log(\"Hello TypeScript\"); Print() // returns \"Hello TypeScript\"   Async / Await Async Requests ‘Asynchronität’ in der Computerwelt bedeutet, dass der Programmfluss unabhängig erfolgt. Es wird nicht darauf gewartet, dass eine Aufgabe erledigt wird, sondern der nächste Task wird ausgeführt.\nDoch was passiert mit der Aufgabe, die noch nicht abgeschlossen ist? Stellt euch vor ein Mitarbeiter erledigt die noch nicht erledigten Aufgaben im Hintergrund und sendet die Daten zurück, sobald sie erledigt sind.\nNun ergibt sich die Frage, wie wir mit den zurückgegebenen Daten umgehen. Die Antwort lautet: Promises, Observables, Callbacks und weitere. Bei einer asynchronen Anforderung wartet der Client nicht auf die Antwort. Nichts ist blockiert. Schauen wir uns dieses Konzept anhand eines häufigen Szenarios an.\nIn der Web-Welt wird häufig auf den Server zugegriffen, um Daten wie die Details eines Benutzers, eine Liste usw. abzurufen. Wir wissen, dass dieses Szenario einige Zeit dauern kann. In diesem Fall werden die Daten nicht abgewartet, sondern asynchron verarbeitet (kein Warten), damit unsere Anwendung nicht blockiert wird. Solche Anfragen sind asynchrone Anfragen.\nSchauen wir uns also an, wie wir mit diesen asynchronen Anforderungen umgehen können.\nCallbacks Callback-Funktionen werden aufgerufen wenn die Anforderung abgeschlossen ist und die Daten oder einen Error zurückgegeben wird. Code zum besseren Verständnis:\n1 2 3 4 5 6 7 8 9  const request = require(\"request\"); request(\"https://www.example.com\", function(err, response, body){ if(error){ // Error handling  } else{ // Success  } });   In diesem Beispiel wird nun ein Request verarbeitet. Wie sieht es jedoch aus, falls wir nach dem erfolgreichen Erhalten von Daten nochmals einen Request durchführen wollen? Bevor Promises in JavaScript integriert wurden, war dies ein mühseliges Problem. Callback-hell Beispiel.\nPromises Im Wesentlichen ist ein Promise in JavaScript einem Versprechen im wirklichen Leben sehr ähnlich. Versprechen werden im wirklichen Leben entweder eingehalten oder gebrochen werden, in JavaScript werden Promises entweder aufgelöst oder abgelehnt.\nAls Beispiel schauen wir, wie ein kleines Kind, das seinen Eltern verspricht, sein Zimmer zu reinigen, in JavaScript aussieht.\n1 2 3 4 5 6 7 8 9  let promiseToCleanTheRoom = new Promise(function(resolve, reject){ let isClean = trueM if(isClean){ resolve(\"Clean\"); } else{ reject(\"not Clean\"); } });   In JavaScript werden in einem Promise zwei Rückrufe berücksichtigt: resolve und reject. Wenn wir den obigen Code durchlesen, ist es offensichtlich, dass unser kleines Kind sein Versprechen, sein Zimmer zu putzen, erfüllt hat. Daher wird unser Promise-Objekt hier - sobald es aufgerufen wurde - als Antwort Clean zurückzugeben. Nehmen wir an, unser Kind hat es nicht geschafft, das Schnäppchen zu machen, dann würde isClean auf false gesetzt. Dann wird unser Versprechen hier abgelehnt und als Antwort not Clean zurückgegeben.\nWir können jetzt unsere Funktion promiseToCleanTheRoom ausführen, indem wir Folgendes schreiben:\n1 2 3 4 5  promiseToCleanTheRoom.then(function(result){ console.log(\"the room is \" + result); }).catch(function(result){ console.log(\"the room is \" + result); })   Sobald promiseToCleanTheRoom ausgeführt wird, wird unsere then-Funktion nur dann ausgelöst, wenn das Promise resolved wird. Ebenso wird unsere catch-Funktion nur ausgelöst, wenn das Promise rejected wird.\nObservables Ein Observable ermöglicht die Übergabe von null oder mehr Ereignissen, bei denen der Rückruf für jedes Ereignis aufgerufen wird.\nBei Observables spielt es keine Rolle, ob man 0, 1 oder mehrere Ereignisse behandeln möchte. Sie können jeweils die gleiche API verwenden.\nObservable hat gegenüber Promise den Vorteil, stornierbar zu sein. Wenn das Ergebnis einer HTTP-Anforderung an einen Server oder eines anderen kostspieligen asynchronen Vorgangs nicht mehr benötigt wird, kann man mit der Subscription einer Observable das Abonnement abbrechen.\nCodebeispiel:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  import { Observable } from 'rxjs/Obvervable'; // Create a new Obvervable, providing the subscribe function. const observable: Observable\u003cstring\u003e = new Obvervable(observer =\u003e { const interval = setInterval(() =\u003e { observer.next(\"Hello from Obvervableland!\"); }, 1000); // teardown  return () =\u003e { clearInterval(interval); } }); // Subscribe to Notifications. observable.subscribe(value =\u003e console.log(value));   Zunächst müssen wir die Observable-Klasse aus dem RxJS-Modul importieren, da Observables noch nicht Teil von ECMAScript (JavaScript) sind. Anschliessend erstellen wir ein neues Observable und stellen die Abonnementfunktion bereit, die aufgerufen wird, wenn ein Observer das Observable abonniert.\nWir verwenden die next()-Methode für ein Observer-Objekt, um Werte an den Observer zu senden. Das Observer-Interface enthält 3 Methoden: next(), catch() and complete(). Um asynchrone Ereignisse zu faken, verwenden wir in diesem Beispiel die Funktion setInterval(), die im Laufe der Zeit Werte ausgibt. Jede Sekunde geben wir den String Hello from Observableland! aus. Wir geben dann eine Funktion zurück, die aufgerufen wird, wenn sich alle Observer vom Observable abgemeldet haben.\nSchliesslich rufen wir die Methode subscribe() auf, die eine Funktion bereitstellt, die jedes Mal aufgerufen wird, wenn der Wert next() an alle Observer gesendet wird.\nTeste dein Wissen Du hast nun viel Neues über TypeScript gelernt. Teste hier, ob du das Wichtigste verstanden hast.\n","categories":"","description":"JavaScript mit Typen.\n","excerpt":"JavaScript mit Typen.\n","ref":"/docs/web/angular/03_1_intro_typescript/","tags":"","title":"Einführung in TypeScript"},{"body":"","categories":"","description":"Webseiten erstellen mit HTML und CSS.\n","excerpt":"Webseiten erstellen mit HTML und CSS.\n","ref":"/docs/web/html_css/","tags":"","title":"HTML und CSS"},{"body":"","categories":"","description":"Exams zu Web-Technologien\n","excerpt":"Exams zu Web-Technologien\n","ref":"/exams/web/","tags":"","title":"Web Exams"},{"body":"","categories":"","description":"Labs zu Angular\n","excerpt":"Labs zu Angular\n","ref":"/labs/web/angular/","tags":"","title":"Angular Labs"},{"body":"In diesem Lab wirst du Angular installieren.\nDas Lab orientiert sich stark an der offiziellen Dokumentation von Angular. Die Dokumentation findest du unter angular.io/docs.\nTeil 1 - Installation von Node.js In diesem ersten Schritt wirst du Node.js installieren, falls Node.js noch nicht bei dir installiert ist.\nÜberprüfe zuerst, ob Node.js bereits auf deinem System installiert ist:\n1  node --version   Falls Node.js noch nicht auf deinem System installiert ist, kannst du Node.js über nvm (Node Version Manager) installieren.\nUm nvm zu installieren, verwende das Skriptinstall.sh, das sich innerhalb des repository github.com/nvm-sh/nvm befindet:\n1  curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash   Verwende den Befehl\n1  nvm --version   um zu überprüfen, ob nvm richtig installiert wurde.\nnvm install\nUm eine spezifische Version\u003cx.y.z\u003evon Node.js zu installieren (Beispiel 12.22.7), verwende den Befehl\n1  nvm install \u003cversion\u003e   Angular benötigt eine Active LTS (long-term support) oder eine Maintenance LTS Version von Node.js. Die aktuellen Active LTS und Maintenance LTS Versionen von Node.js sind unten abgebildet (Stand Oktober 2021), und unter nodejs.org/en/about/releases aufgelistet.\n\nnvm list\nVerwende den Befehl\n1  nvm list   um alle installierten Versionen von Node.js aufzulisten.\nnvm use\nFalls bereits eine Version von Node.js auf deinem System installiert war, und du nvm nachträglich installiert hast, kannst du mit dem Befehl\n1  nvm use system   die bereits vorher installierte Version zur Verwendung auswählen.\nEine über nvm installierte Version \u003cx.y.z\u003e von Node.js kannst du mit\n1  nvm use \u003cx.y.z\u003e   zur Verwendung auswählen.\nnvm alias default\nZum Schluss, verwende\n1  nvm alias default \u003cversion\u003e   um eine mit Angular kompatible Version \u003cversion\u003e (Beispiele system, 12.22.7) von Node.js als Standard festzulegen.\n Für die Installation von Angular im nächsten Schritt brauchst du den package mangager npm von Node.js. Stelle sicher, dass npm ebenfalls auf deinem System installiert ist:\n1  npm --version   Teil 2 - Installation des CLI von Angular In diesem Schritt wirst du das CLI (command line interface) von Angular über npm installieren.\nVerwende dazu den Befehl\n1  npm install -g @angular/cli   Mit der Flag -g wird das CLI von Angular global installiert. Das heisst unter anderem, dass executables in einem Verzeichnis installiert oder referenziet werden, das in der Umgebungsvariablen PATH aufgelistet ist. Mehr Informationen dazu findest du hier.\nZur Überprüfung, ob Angular richtig installiert wurde, verwende\n1  ng version   Teil 3 - Erstellen einer App mit dem CLI Das Grundgerüst einer Angular-App erstellt man mit dem Befehl ng new.\nVerwende den Befehl\n1  ng new my-app   um eine neue App mit der Bezeichnung my-app zu erstellen.\nBei den zwei Eingabeaufforderungen / Prompts kannst du mit Enter die Standardoption bestätigen. Das CLI erstellt anschliessend ein Verzeichnis mit dem Namen my-app und den generierten Dateien.\nTeil 4 - Ausführen einer App mit dem CLI Das CLI von Angular einthält einen Server, der eine App lokal bereitstellen kann.\nVerwende innerhalb des mit dem CLI erstellten Verzeichnisses den Befehl\n1  ng serve   um die in der letzten Aufgabe erstellte App zu builden und zu starten.\nMit der zusätzlichen Option--openöffnet das CLI die App direkt in einem Browser. Per default wird die App unter der Webadresse localhost:4200 bereitgestellt.\nFalls alles erfolgreich war, wird eine von Angular generierte Standardseite angezeigt. Die Seite ist unten abgebildet.\n\n","categories":"","description":"Angular Setup\n","excerpt":"Angular Setup\n","ref":"/labs/web/angular/angular_setup/","tags":"","title":"Angular Setup"},{"body":"Exam 1 - HTML5 \u0026 CSS3 - Einzelarbeit\nErstelle mit Hilfe deines aktuellen Wissen eine neue Webseite. Sie soll nur die HTML-Elemente und das CSS-Styling besitzen. Die logischen Instrumente sind nicht nötig, da wir uns im nächsten Kurs mit Javascript/Typescript beschäftigen werden. Verwende die HTML5 konformen Tags.\nRTM Nachzubauen ist die neue Webseite vom RTM(login).\nNachfolgend werden die einzelnen Komponenten erklärt. Es werden nur diverse Stylings gegeben, denn Rest müsst ihr selber versuchen zu definieren. Zu unterst im File findet ihr noch diverse Hints, welche euch helfen könnten.\nDie Icons sind hier hinterlegt. Header    Was Farbe Logo Grösse Hover Farbe     Hintergrundfarbe in Header rgba(236,239,242,1); - height: 57.25px; -   login Logo - login_logo.svg width: 180px; -   Text in Header rgba(119,119,119,1); - - -   Datum(Tag) rgba(213,45,40,1); - - -   Kommen Logo - kommen.svg width: 22px; height: 22px; rgba(255,255,255,1);   Farbe untere Zeile Logo rgba(255,0,0,1); - width: 250px; rgba(255,255,255,1);   Uhr Logo - uhr.svg width: 22px; height: 22px; rgba(255,255,255,1);   Pfeil (Menu Sprache) Logo - pfeil_unten.svg - rgba(255,255,255,1);   Refresh Logo - refresh.svg width: 22px; height: 22px; rgba(255,255,255,1);   Personen Logo - persons.svg width: 22px; height: 22px; rgba(255,255,255,1);   Profil Logo - profil.svg width: 22px; height: 22px; rgba(255,255,255,1);   Logout Logo - logout.svg width: 22px; height: 22px; rgba(255,255,255,1);    Linke Sidenav    Was Farbe Logo Grösse Hover Farbe     Hintergrund in Sidenav rgba(0,158,195,1) - width: 180px; rgba(0,100,128,1);   Profil Logo - profil.svg width: 88px;height: 88px; -   Abwesend Text rgb(211, 47, 47); - - -   Cockpit Logo background: rgba(230,230,230,1);color: rgba(115,115,115,1); cockpit.svg width: 16px; height: 16px; -   Personen Logo - persons.svg width: 16px; height: 16px; background: rgba(0,100,128,1);   Einsatzplan Logo - einsatzplan.svg width: 16px; height: 16px; background: rgba(0,100,128,1);   Abfragen Logo - abfragen.svg width: 16px; height: 16px; background: rgba(0,100,128,1);   Abfragen Pfeil Logo - pfeil_oben.svg width: 9px; height: 14px; rgba(0,100,128,1);   Palungsliste Logo - einsatzplan.svg width: 16px; height: 16px; rgba(0,100,128,1);   Tagesübersicht Logo - buchung.svg width: 16px; height: 16px; rgba(0,100,128,1);   Buchungsliste Logo - buchung.svg width: 16px; height: 16px; rgba(0,100,128,1);   Zeitwertliste Logo - buchung.svg width: 16px; height: 16px; rgba(0,100,128,1);   Saldoübersicht Logo - saldo.svg width: 16px; height: 16px; rgba(0,100,128,1);   Spesenauswertung Logo - buchung.svg width: 16px; height: 16px; rgba(0,100,128,1);   Auftragsauswertung Logo - buchung.svg width: 16px; height: 16px; rgba(0,100,128,1);   Berichte Logo - drucken.svg width: 16px; height: 16px; rgba(0,100,128,1);    Rechte Sidenav    Was Farbe Logo Grösse Hover Farbe     Hintergrund in Sidenav rgba(255, 255, 255, 1); - width: 250px; rgba(245, 245, 245, 1);   Anwesend Text rgba(66,159,70,1); - - -   Profil Logo - profil.svg width: 35px; height: 35px; -   Uhr Logo - clock.svg width: 24px; height: 28px; -   Abwesend Text rgba(255,0,0,1); - - -   Text allgemein rgba(33,33,33,1); - - -    Content    Was Farbe Logo Grösse Hover Farbe     Hintergrund in Content background: rgb(243, 243, 243,1); color: rgba(33,33,33,1); - - -   Bearbeiten Logo - edit.svg width: 14px; height: 14px; rgba(250, 250, 250, 1);   Plus Logo (disabled) plus.svg color: lightgrey; width: 11px; height: 14px; rgba(250, 250, 250, 1);   Pfeil-Unten Logo (disabled) pfeil_unten.svg color: lightgrey; width: 9px; height: 14px; rgba(250, 250, 250, 1);   Speichern Logo (disabled) save.svg color: lightgrey; width: 12px; height: 14px; rgba(250, 250, 250, 1);   Rückgängig Logo (disabled) undo.svg color: lightgrey; width: 12px; height: 14px; rgba(250, 250, 250, 1);   SBB Crackhead rgba(217,230,242,1); - width: 716.5px; height: 180px; rgba(224,231,235,1);   Profil Logo - profil.svg width: 140px; height: 140px; -   Ausrufezeichen Logos - request.svg width: 24px; height: 24px; -   Absenzen Text rgb(33, 150, 243); - width: 352.75px; height: 180px; -   Visum Text rgb(16, 85, 192); - width: 352.75px; height: 180px; -   Warnung Logo - warning.svg width: 24px; height: 24px; -   Warnung Text rgb(219, 73, 216); - width: 352.75px; height: 180px; -   Alarm Logo - alert.svg width: 24px; height: 24px; -   Alart Text rgb(255, 67, 81); - width: 352.75px; height: 180px; -    Hint: über allen hover-Elementen pointer\nSchatten: box-shadow\nScrollleiste: overflow-y oder overflow-x\nSobald du fertig bist… Wenn du fertig mit diesem Exam bist, zeige dein Resultat einem Coach. Nach dem Okay des Coaches kannst du mit der Theorie zu Bootstrap und dann mit JavaScript beginnen.\n","categories":"","description":"Erstelle dein eigenes Zeiterfassungs-Dashboard - zumindest das Layout dafür ;).\n","excerpt":"Erstelle dein eigenes Zeiterfassungs-Dashboard - zumindest das Layout …","ref":"/exams/web/html_css/01_exam_html_css_rtm/","tags":"","title":"Exam zu den HTML- und CSS-Basics"},{"body":"Übungen Übung 1 - Einzelarbeit Übung 1\nErstelle eine Website, welche anhand von Observables eine Browsernotification ausgibt. Dazu soll sich auf der Website ein Button befinden, welcher das Event auslöst, um die Notification im Browser anzuzeigen. Vorgehen: Lade die Datei im Titel herunter und öffne sie in VS Code. Die Datei enthält lediglich das Grundgerüst der Übung, füge an den auskommentierten Stellen den entsprechenden Code ein. Am Grundgerüst der Datei soll nichts verändert werden.  Damit die Notifications fehlerfrei funktionieren, muss die Extenstion “Live Server” in VS Code hinzugefügt und angewendet werden. Übung 2 Einrichtung Da du Node.js bereits installiert hast, kannst du nun anhand des Node Package Manager mühelos typescript installieren. Dazu öffnest du eine Konsole und gibst diesen Befehl ein: npm install -g typescript\nSobald die Installation abgeschlossen ist, erstellst du eine Datei und nennst diese hello-world.ts. Öffne die Datei mit VS Code und schreib die erste Codezeile: console.log(\"Hello World\");\nNun hast du unser erstes Typescript “Projekt” erstellt. Um dies auszuführen, müsst du den Quellcode zu JS transpilieren. Dazu öffnest du eine Konsole und begibst dich in das Verzeichnis indem sich die Datei befindet.\nDanach gibst du folgenden Befehl in der Konsole ein: tsc hello-world.ts\nWie du nun sehen kannst, befindet sich im Verzeichnis eine gleichnamige JS Datei.\nDiese kannst du nun anhand von Node ausführen: node hello-word.js\nFalls alles funktioniert hat, gibt die Konsole Hello World aus.\nÜbung - Einzelarbeit Übung 2\nLade die Datei im Titel herunter und fülle wo nötig Quellcode ein. Die Person soll sich folgendermassen vorstellen: \"Hallo, mein Name ist [Name]\" Die Grundstruktur, sowie die letzten 2 Codezeilen dürfen nicht verändert werden.  Übung 3 - Einzelarbeit\nIn dieser Übung wollen wir die Vererbung in einem Fallbeispiel anwenden. Wir erweitern in dieser Aufgabe den Quellcode von Übung 2. Erstelle dazu am Besten gleich eine neue Datei und kopiere den Quellcode von Aufgabe 2. Lösche die letzten 2 Zeilen, sodass nur noch die Klasse \"Person\" übrig ist. Erstelle anschliessend die Klasse \"Friend\", welche die Klasse \"Person\" erbt. Diese Klasse soll die Methode \"timeKnown()\", sowie \"introduceSelf()\" der Parent-Klasse zur Verfügung stellen. Die Methode \"timeKnown()\" soll folgendes ausgeben können: \"Wir sind Freunde seit [AnzahlJahre] Jahren\" Achte also darauf, welche zusätzlichen Eigenschaften \"Friend\" besitzen muss. Erstelle am Schluss (wie bei Übung 2) eine neue Instanz von \"Friend\". Verwende als Parameter \"Peter\" und \"5\". Führe dann \"introduceSelf()\" und \"timeKnown()\" aus.  In der Konsole sollte Dir nun folgendes angezeigt werden.\nHallo, mein Name ist Peter Wir sind Freunde seit 5 Jahren Übung 4 - Einzelarbeit Übung 4, https://nodejs.org/api/readline.html\nIn dieser Aufgabe wollen wir Benutzereingabe in der Konsole verarbeiten. Dazu verwenden wir in diesem Beispiel readline von NodeJS. Wir wollen nun ein kleines Programm schreiben, welches wie folgt aussieht.  1 2 3 4  Wie ist dein name? Hansli hallo Hansli War diese Aufgabe lehrreich für dich= [j / n]j Super!   1 2 3 4  Wie ist dein name? Hansli hallo Hansli War diese Aufgabe lehrreich für dich= [j / n]n Schade! :(   Zuerst wird der Anwender nach seinem Namen gefragt. Danach wird er begrüsst. Und anschliessend wird gefragt ob diese Aufgabe lehrreich für ihn war.\nFülle in der Aufgabendatei den benötigten Code an den enstprechenden Stellen ein.\n- Info zu readline.\nUm readline benutzen zu können, musst du erst den entsprechenden npm-Befehl ausführen. Achte darauf, dass du den Befehl im selben Verzeichnis ausführst, indem sich die .ts-Datei befindet!  Zurück zur Theorie Hier gelangst du zurück zur Theorie.\nEventuell noch eine kleiner Exam (ToDo!!!!!) ","categories":"","description":"Einfache Aufgaben zu den Basics von TypeScript.\n","excerpt":"Einfache Aufgaben zu den Basics von TypeScript.\n","ref":"/exams/web/angular/03_2_intro_typescript_exam/","tags":"","title":"Exam zu den TypeScript-Basics"},{"body":"","categories":"","description":"Labs zu Web\n","excerpt":"Labs zu Web\n","ref":"/labs/web/","tags":"","title":"Web Labs"},{"body":"Schreibe ein Programm, welches ein Adressbuch implementiert. Die Anwendung soll die einzelnen Kontakte der Personen in ein Adressbuch eintragen, wenn die entsprechende Methode aufgerufen wurde.\nEine Person besitzt\n einen Namen eine Email-Adresse eine Telefonnummer  Das Adressbuch soll\n die Anzahl der Kontakte im Adressbuch zurückliefern können einen neuen Kontakt in das Adressbuch einfügen einen Kontakt im Adressbuch durch den Namen finden einen Kontakt aus dem Adressbuch über die E-Mail-Adresse entfernen  Generell gilt die Regel, dass jede E-Mail-Adresse einzigartig sein muss\n","categories":"","description":"Aufgabe zu Modul #J2 - OOP - Adressbuch\n","excerpt":"Aufgabe zu Modul #J2 - OOP - Adressbuch\n","ref":"/labs/java/java-oop/02_adressbuch/","tags":"","title":"Adressbuch"},{"body":"java.util.ArrayList java.util.ArrayList erbt von der abstrakten Klasse java.util.AbstractList und liefert eine konkrete Implementierung für das Interface java.util.List. Die ArrayList Klasse implementiert alle Methoden des Interface java.util.List. Der Implementierung der ArrayList Klasse liegen Arrays zugrunde, weshalb diese konkrete Klasse auch ArrayList heisst. Die Klasse ArrayList enthält also ein normales Array. Wenn ein Element hinzugefügt wird, wird es in dieses Array eingefügt. Wenn das Array nicht groß genug ist, wird ein neues, größeres Array erstellt, um das alte zu ersetzen, d.h. die Kapazität des Arrays wird fortlaufend angepasst.\nMethodenübersicht 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  /* * Konstruktor: Erstellt eine initial leere Liste */ public ArrayList\u003cE\u003e() /* * Appends the specified element to the end of this list. */ public boolean add(E e) /* * Fügt das angegebene Element an der angegebenen Position in diese Liste ein. */ public void add(int index,E element) /* * Entfernt alle Elemente aus dieser Liste. */ public void clear() /* * Entfernt das Element an der angegebenen Position in dieser Liste. */ public E remove(int index) /* * Gibt das Element an der angegebenen Position in dieser Liste zurück. */ public E get(int index) /* * Gibt den Index des ersten Auftretens des angegebenen Elements in dieser Liste zurück, * oder -1, wenn diese Liste das Element nicht enthält. */ public int indexOf(Object o) /* * Gibt die Anzahl der Elemente in dieser Liste zurück. */ public int size() /* * Gibt true zurück, wenn diese Liste keine Elemente enthält. */ public boolean isEmpty() /* * Gibt true zurück, wenn diese Liste das angegebene Element enthält. */ public boolean contains(Object o)     Beispiel    IndexOutOfBoundsException Eine der häufigsten Exceptions, die im Zusammenhang mit Listen auftritt, ist folgende: Es wird versucht, auf ein Element mit einem Index zuzugreifen, wobei der Index grösser als (oder gleich wie) die Länge der Liste ist. Dann wird die IndexOutOfBoundsException geworfen:\n1 2 3 4 5 6  List\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"uno\"); list.add(\"dos\"); list.add(\"tres\"); System.out.println(list.get(3));   Hier wird dann diese Meldung angezeigt:\n1  \"java.lang.IndexOutOfBoundsException: Index 3 out of bounds for length 3\"   Der Fehler war hier, dass die Liste 3 Elemente enthielt, und versucht wird, auf das 4. Element (also Index 3) zuzugreifen. Weil das 4. Element in dieser Liste nicht existiert, wird eine Exception geworfen.\nGanz generell wird die IndexOutOfBoundException geworfen, wenn versucht wird, auf einen ungültigen Index innerhalb einer Collection zuzugreifen. Hat eine Liste die Grösse x:\n dann sind die gültigen Indizes, um auf Elemente zuzugreifen 0, 1, 2, …, x-1 und die Indizes x, x+1, x+2, … wären ungültig.  Diese Exception kann bei den folgenden Methoden von oben geworfen werden: (Diese Liste hier ist genau so nicht vollständig, wie die oben.)\n public void add(int index, E element) (beachte das Argument index.) public E remove(int index) public E get(int index)  Beispiel Beispiel 1 - ArrayList Im folgenden Beispiel erstellen wir zunächst eine leere ArrayList mit Elementen vom Typ String und wenden einige einfache ArrayList Methoden an und sehen, wie diese funktionieren (Das Hinzufügen von Elementen, das Entfernen von Elementen, …),\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  import java.util.ArrayList; import java.util.List; public class Pets { public static void main(String[] args) { // Creating an ArrayList of String  List\u003cString\u003e pets = new ArrayList\u003c\u003e(); System.out.println(pets); // Output: []  // Adding new elements to the ArrayList  pets.add(\"Cat\"); pets.add(\"Hamster\"); pets.add(\"Dog\"); pets.add(\"Goldfish\"); System.out.println(pets); // Output: [Cat, Hamster, Dog, Goldfish]  // Adding an element at a particular index in an ArrayList  pets.add(2, \"Guinea pigs\"); System.out.println(pets); // Output: [Cat, Hamster, Guinea pigs, Dog, Goldfish]  pets.remove(2); System.out.println(pets); // Output: [Cat, Hamster, Dog, Goldfish]  pets.remove(\"Dog\"); System.out.println(pets); // Output: [Cat, Hamster, Goldfish]  pets.clear(); System.out.println(pets); // Output: []  } }   Beispiel 2 - for-Schleife Dieses Beispiel zeigt auf wie mit einer for-Schleife über die Elemente einer Liste iteriert werden kann.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  import java.util.ArrayList; class ListSum { public static void main(String[] args) { ArrayList\u003cInteger\u003e numbers = new ArrayList\u003c\u003e(); numbers.add(1000); numbers.add(2500); numbers.add(3750); numbers.add(625); int listSum = 0; for (Integer e : numbers) { listSum += e; } System.out.println(\"Die Summe der Elemente beträgt \" + listSum); } }   Output:\n1 2  Die Summe der Elemente beträgt 7875   Beispiel 3 - while-Schleife Dieses Beispiel zeigt auf wie mit einer while-Schleife über die Elemente einer Liste iteriert werden kann.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  import java.util.Arrays; import java.util.List; public class WhileLoopExample { public static void main(String[] args) { String[] namesArray = { \"Anna\", \"Simon\", \"Jan\", \"Nicole\"}; // convert array to list  List\u003cString\u003e namesArrayList = Arrays.asList(namesArray); int i = 0; while (i \u003c namesArrayList.size()) { System.out.println(namesArrayList.get(i)); i++; } } }   Output:\n1 2 3 4 5  Anna Simon Jan Nicole     Aufgaben    Aufgaben Aufgaben zu Modul #J7 - Java Collections - List\n","categories":"","description":"Eine konkrete Umsetzung einer List: Die ArrayList.\n","excerpt":"Eine konkrete Umsetzung einer List: Die ArrayList.\n","ref":"/docs/java/java-collections/02_array-list/","tags":"","title":"ArrayList"},{"body":"Schreibe eine Anwendung, welche eine Bibliothek modelliert. In der Bibliothek findet man unterschiedliche Exemplare. z.B: Bücher, Zeitschriften, CDs, DVDs.\nEin Item\n hat einen Titel  Folgende Arten von Items können sich in der Bibliothek befinden:\n Buch  hat einen Autor hat ein Genre   Zeitschrift  hat einen Herausgeber hat ein Datum   CD  hat den Namen des Interpreten hat eine Anzahl von Songs   DVD  hat den Namen des Regisseurs hat ein Genre    Die Anwendung soll  ein Inventar von unterschiedlichen Items verwalten (also Bücher, DVDs usw.) es ermöglichen ein Item auszuleihen, wenn es noch nicht ausgeliehen worden ist es ermöglichen ein Item zurückzugeben Auskunft zu den vorhandenen Items im Inventar geben  Verwende Generics überall wo es Sinn macht!\n","categories":"","description":"Aufgabe zu Modul #J2 - Generics I - Bibliothek\n","excerpt":"Aufgabe zu Modul #J2 - Generics I - Bibliothek\n","ref":"/labs/java/java-generics/02_bibliothek/","tags":"","title":"Bibliothek"},{"body":"Aufgabe 1 - Header-Navigation Erstelle nachfolgende Seite.\nDer Schwerpunkt ist die Navigation im Header: Das Bild und die Links auf der rechten Seite.\nAufgabe 2 - relative Positionierung In Aufgabe 1 hast du eine Seite mit Header und Navigation erstellt hast.\nAdjustiere dort das Bild oben links.\nAufgabe 3 - Info-Box Erstelle eine HTML-Seite (oder erweitere eine andere so, dass) die ganz unten eine Meldung anzeigt mit einem “OK”-Button.\nInspiriere dich an den nervigen Cookie-Meldungen von anderen Seiten.\nDu kannst die Meldung ganz unten oder in der Mitte des Bildschirms anzeigen.\nWenn du willst, kannst du über alles andere ein “Overlay” schmeissen mit einem Transparenzwert von 50 - 90%, damit der User sich automatisch auf die Meldung fokussiert.\nWenn du willst, kannst du alles andere auch verschwommen darstellen. Hierfür könnte das CSS-Property backdrop-filter interessant sein, siehe https://www.w3schools.com/cssref/css3_pr_backdrop-filter.php.\nErstelle nun eine Cookie-Meldung wie diese (der weisse Teil mit dem roten Button ist die Meldung, der Rest gehört zum Hintergrund):\nAufgabe 4 - Bootstrap Nachfolgend ist eine Beispiel-Seite. Setze diese mit Bootstrap um:\nSchaue dir diese Seite auf auf kleineren Bildschirmen an - also verändere die Fenster-Breite deines Browsers. Du wirst sehen, dass z.B. die einzelnen Abos untereinander erscheinen, wenn die Breite kleiner wird. Berücksichtige dies auch in deinem Code.\n Hinweis Solltest du nicht weiterkommen, dann schaue in den Entwickler-Tools ([F12]-Taste) im DOM nach. Da diese Seite auch mit Bootstrap umgesetzt wurde, kannst du nachschauen, welche Bootstrap-Klassen sie verwendet haben.\n ","categories":"","description":"Aufgaben zu Modul #F3 - CSS\n","excerpt":"Aufgaben zu Modul #F3 - CSS\n","ref":"/labs/web/html_css/02_css/","tags":"","title":"CSS - Aufgaben"},{"body":"Gegeben Gegegeben ist der folgende String:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59  String endOfTheWorld = \"That's great, it starts with an earthquake \" + \"Birds and snakes, and aeroplanes \" + \"And Lenny Bruce is not afraid \" + \"Eye of a hurricane, listen to yourself churn \" + \"World serves its own needs \" + \"Don't mis-serve your own needs \" + \"Speed it up a notch, speed, grunt, no, strength \" + \"The ladder starts to clatter \" + \"With a fear of height, down, height \" + \"Wire in a fire, represent the seven games \" + \"And a government for hire and a combat site \" + \"Left her, wasn't coming in a hurry \" + \"With the Furies breathing down your neck \" + \"Team by team, reporters baffled, trumped, tethered, cropped \" + \"Look at that low plane, fine, then \" + \"Uh oh, overflow, population, common group \" + \"But it'll do, save yourself, serve yourself \" + \"World serves its own needs, listen to your heart bleed \" + \"Tell me with the Rapture and the reverent in the right, right \" + \"You vitriolic, patriotic, slam fight, bright light \" + \"Feeling pretty psyched \" + \"It's the end of the world as we know it \" + \"It's the end of the world as we know it \" + \"It's the end of the world as we know it and I feel fine \" + \"Six o'clock, T.V. hour, don't get caught in foreign tower \" + \"Slash and burn, return, listen to yourself churn \" + \"Lock him in uniform, book burning, bloodletting \" + \"Every motive escalate, automotive incinerate \" + \"Light a candle, light a motive, step down, step down \" + \"Watch your heel crush, crush, uh oh \" + \"This means no fear, cavalier, renegade and steering clear \" + \"A tournament, a tournament, a tournament of lies \" + \"Offer me solutions, offer me alternatives and I decline \" + \"It's the end of the world as we know it (I had some time alone) \" + \"It's the end of the world as we know it (I had some time alone) \" + \"It's the end of the world as we know it and I feel fine (time I had some time alone) \" + \"I feel fine (I feel fine) \" + \"It's the end of the world as we know it (time I had some time alone) \" + \"It's the end of the world as we know it (time I had some time alone) \" + \"It's the end of the world as we know it and I feel fine (time I had some time alone) \" + \"The other night I drifted nice continental drift divide \" + \"Mountains sit in a line, Leonard Bernstein \" + \"Leonid Brezhnev, Lenny Bruce and Lester Bangs \" + \"Birthday party, cheesecake, jellybean, boom \" + \"You symbiotic, patriotic, slam but neck, right, right \" + \"It's the end of the world as we know it (time I had some time alone) \" + \"It's the end of the world as we know it (time I had some time alone) \" + \"It's the end of the world as we know it and I feel fine (time I had some time alone) \" + \"It's the end of the world as we know it \" + \"It's the end of the world as we know it \" + \"It's the end of the world as we know it and I feel fine (time I had some time alone) \" + \"It's the end of the world as we know it (time I had some time alone) \" + \"It's the end of the world as we know it (time I had some time alone) \" + \"It's the end of the world as we know it and I feel fine (time I had some time alone) \" + \"It's the end of the world as we know it (time I had some time alone) \" + \"It's the end of the world as we know it (time I had some time alone) \" + \"It's the end of the world as we know it and I feel fine (time I had some time alone)\"; // Copyright R.E.M.   Aufgabe 1 Schreibe eine Methode, welche die Anzahl Wörter zählt, welche mindestens zweimal im Text vorkommen. Entferne zu diesem Zweck zuerst die Sonderzeichen. Die Methode liefert die Anzahl dieser Wörter zurück.\nAufgabe 2 Schreibe eine Methode, welche die Wörter aus dem Text oben alphabetisch sortiert. Entferne zu diesem Zweck zuerst die Sonderzeichen. Die Methode liefert ein Array mit den sortierten Wörtern zurück.\nAufgabe 3 Schreibe eine Methode, welche die durchschnittliche Wortlänge berechnet. Entferne zu diesem Zweck zuerst die Sonderzeichen. Die Methode liefert die durchschnittliche Wortlänge als Gleitkommazahl zurück.\nAufgabe 4 Schreibe eine Methode, welche die Wörter aus dem Text nach ihrer Länge sortiert. Kurze Wörter kommen dabei zuerst. Entferne zu diesem Zweck zuerst die Sonderzeichen. Die Methode liefert ein Array mit den sortierten Wörtern zurück.\nAufgabe 5 Schreibe eine Methode, welche das Wort zurückliefert, das im Text oben am häufigsten vorkommt. Entferne zu diesem Zweck zuerst die Sonderzeichen. Die Methode liefert das gesuchte Wort zurück.\nAufgabe 6 Schreibe eine Methode, welche die einzelnen Buchstaben des Textes in ein zweidimensionales Array von Strings überführt. Die erste Dimension hat dabei die Grösse der verschiedenen vorkommenden Zeichen im Text in alphabetischer Reihenfolge. Sonderzeichen sind ebenfalls Teil dieser alphabetischen Reihenfolge, die Sortierung richtet sich nach dem Integer-Wert der einzelnen Zeichen. Die zweite Dimension enthält pro Zeichen ein Array mit den Positionen der Zeichen im Text. An erster Stelle steht dabei das jeweilige Zeichen. Sämtliche Buchstaben sollen immer nur als kleingeschriebene Buchstaben behandelt werden.\nBeispiel:\nString text = \"Hallo mein Name ist Claudio\"\n    a c d e h i l m n o s t u     5 1 20 24 7 0 8 2 6 9 4 17 18 23   10 12   14  16 3 13 11 26      15                19                 ","categories":"","description":"Einfache Aufgaben mit Strings\n","excerpt":"Einfache Aufgaben mit Strings\n","ref":"/exams/java/java-grundlagen/exam2/","tags":"","title":"Exam Java Grundlagen - Strings"},{"body":"Inhalt  Git unter Windows installieren  Git unter Windows installieren  Navigiere zum Git für Windows Installer und lade die neuste Version herunter. Folge den Installationsanweisungen bis die Installation abgeschlossen ist.  Es wird empfohlen während der Installation Git Bash zu installieren  Es wird empfohlen während der Installation den PATH zu ändern.    Öffne Git Bash Schreibe git version zum Überprüfen, ob Git erfolgreich installiert wurde.  ","categories":"","description":"","excerpt":"Inhalt  Git unter Windows installieren  Git unter Windows installieren …","ref":"/docs/git/git-install/","tags":"","title":"Install Git"},{"body":"Ziele  Ich kenne die wichtigsten Funktionen der IntelliJ IDEA Ich kann Projekte innerhalb IntelliJ IDEA neu anlegen, konfigurieren und verwalten Ich kann IntelliJ IDEA zusammen mit einem GIT-Repository verwenden Ich kann Plugins suchen und installieren Ich verstehe das Grundprinzip von Debugging   Einführung in IntelliJ IDEA Besuche die folgenden Links und lies die Informationen durch:\n Navigation und Suche Benutzer Interface  Die Ansicht und/oder das Verhalten kann abhängig von den installierten Plugins, der IntelliJ IDEA Version oder den Benutzereinstellungen variieren.\nDefault Keymap IntelliJ verfügt über diverse Tastenkombinationen, um die Produktivität zu erhöhen. Im unten stehenden PDF findest du die standardmässig eingestellten Tastenkombinationen. IntelliJ IDEA Reference Card\nPersonalisierte Keymap Es kann vorkommen, dass einige Tastenkombinationen nicht ausführbar sind, als Beispiel ist die Kombination Ctrl + / nur ausführbar, wenn die Tastatur über einen Nummernblock verfügt. Um die Tastenkombinationen deinen Bedürfnissen anzupassen, kannst du in den Einstellungen im IntelliJ nach Keymap und der entsprechenden Funktion suchen und diese anpassen. Zusätzlich bietet IntelliJ IDEA diverse Keymaps an, welche sich z.B. an den Tastenkombinationen von Eclipse oder Visual Studio orientieren und die Umstellung erleichtern sollen.\nFalls Du die Tastenkombinationen deinen Bedürfnissen angepasst hast, kannst du dir deine personalisierte Keymap als PDF von IntelliJ IDEA erstellen lassen unter Help → Keymap Reference.\nWichtige Kombinationen für den Anfang    Funktion Shortcut     Einstellungen öffnen Ctrl + Alt + S   Überall suchen 2x Shift   Smart Code Completion Ctr + Alt + Space   Code formatieren Ctrl + Alt + L   Imports optimieren Ctrl + Alt + O   Generiere Code (Constructor, Getter, Setter, etc.) Alt + Insert    Wichtige Kombinationen zur Code-Generierung IntelliJ bietet nicht nur Tastenkombinationen, um die Produktivität zu verbessern, sondern auch vordefinierte Wörter, Kürzel oder Buchstaben, welche automatisch Code generieren. Mit der Tastenkombination Ctrl + J kannst du diese anzeigen lassen.\n   Code Shortcut     eine main()-Methode psvm   eine forEach-Schleife foreach   eine for-Schleife mit “i” als Zähler fori   einen if == null check ifn   eine Iteration (while-Schleife) über einen Iterator itit   eine Iteration (for-Schleife) über eine Liste itli   eine print()-Methode, welche einen Error auf der Konsole ausgibt serr   eine print()-Methode sout   eine formatierte print()-Methode souf    Neues Projekt anlegen Um einen ersten Einblick in die Erstellung eines neuen Projektes zu erhalten kann das folgende Tutorial von IntelliJ IDEA absolviert werden: https://www.jetbrains.com/help/idea/creating-and-running-your-first-java-application.html\nInstallation von Plugins Plugins erweitern die Kernfunktionalität von IntelliJ IDEA.\n Plugins ermöglichen die Integration mit Versionskontrollsystemen, Anwendungsservern und anderen externen Applikationen Plugins fügen Unterstützung bei der Kodierungshilfe für verschiedene Sprachen und Frameworks hinzu Plugins steigern die Produktivität mit Shortcut-Hinweisen, Live-Vorschauen, File Watchers etc. Plugins helfen dir beim Erlernen einer neuen Programmiersprache mit Programmierübungen und Verifizierung  Plugins müssen über den Marktplatz von IntelliJ installiert werden. Dieser ist über die Einstellungen unter Plugins verfügbar. Dort können Plugins gesucht und über einen Klick auf Install einfach und unkompliziert installiert werden.\nHilfreiche Plugins für den Anfang Ein sehr hilfreiches Plugin ist der “Key Promoter X”. Dieses Plugin ermöglicht das Erlernen der IntelliJ IDEA Tastenkombinationen. Jede verfügbare Tastenkombinationen wird dir bei Verwendung eines Menüs oder Kontextmenüs angezeigt.\nCode-Formatierung hinterlegen Die SBB verwendet den Google Java Code Style und passt ihn nur dort an wo es notwendig ist. Der Java Code Styleguide der SBB in der Version 5 ist hier zu finden: Java Code Styleguide SBB\nDer Import dieses Code Styles in das IntelliJ wird über eine XML-Datei gemacht, welche hier zu finden ist: SbbStyle\nDie XML-Datei kann im IntelliJ als Konfiguration hinterlegt werden. Die folgenden Schritte sind dazu notwendig:\nCode-Formatierung: File → Settings → Editor → Code-Style → Java\nNeben dem Profilnamen auf das Zahnrad-Icon klicken und den Eintrag Import Scheme → Intellij IDEA code style XML auswählen. Anschliessend die XML-Datei auswählen. Das Profil wird importiert und kann anschliessend aus dem Drop-Down ausgewählt und aktiviert werden.\nDie Anordnung von Imports muss manuell angepasst werden. Nach der Auswahl des Profils aus dem Drop-Down klickst du auf den Tab Imports. Die Einstellungen richten sich nach den beiden folgenden Screenshots: Debugging-Grundlagen Der Debugger wird benutzt, um mithilfe von Breakpoints den Code während der Ausführung anzuhalten, zu analysieren und Fehler im Code zu finden. Mehr Informationen dazu gibt es unter dem folgenden Link: Debug Code\n","categories":"","description":"Modul #O4 - IntelliJ\n","excerpt":"Modul #O4 - IntelliJ\n","ref":"/docs/java/intellij-einrichten/","tags":"","title":"IntelliJ IDEA einrichten"},{"body":"Inhalt Dieser Bereich ermöglicht dir das Erlernen der Java-Programmiersprache von Grund auf. Nach der Einrichtung der Entwicklungsumgebung lernst du die Basics von Java kennen. Die objektorienterte Programmierung bringt dich tiefer in die Möglichkeiten von Java hinein. Das Arbeiten mit Listen und Streams vereinfacht dir die Übungen der objektorientierten Programmierung. Das objektorientierte Design erlaubt dir die reale Welt innerhalb von Java besser abzubilden. Mit Maven lernst du ein mächtiges Build-Management Tool kennen. Das Schreiben von automatisierten Tests erlaubt dir deine Applikationen zu testen.\n","categories":"","description":"Einrichten der Entwicklungsumgebung\u003cbr\u003e IntelliJ IDEA und Plugins\u003cbr\u003e Erlernen der Programmiersprache Java\u003cbr\u003e Maven\u003cbr\u003e Testing mit jUnit und Mockito\n","excerpt":"Einrichten der Entwicklungsumgebung\u003cbr\u003e IntelliJ IDEA und Plugins\u003cbr\u003e …","ref":"/docs/java/","tags":"","title":"Java"},{"body":"","categories":"","description":"Exercises zu Modul #J2 - OOP\n","excerpt":"Exercises zu Modul #J2 - OOP\n","ref":"/labs/java/java-oop/","tags":"","title":"Java Exercises - OOP"},{"body":"Ziele  Ich weiss, wie man mit Microsoft Word eine einfache Dokumentation erstellt Ich weiss, wie man ein Deckblatt einfügt Ich weiss, wie man eine Kopf- und Fusszeile einfügt und bearbeitet Ich weiss, wie man Bilder einfügt und bearbeitet Ich weiss, wie man die Formatvorlagen benutzt Ich weiss, wie man ein Inhaltsverzeichnis generieren und aktualisieren kann   Deckblatt einfügen Um einen guten Einstieg in eine Dokumentation zu erhalten, kann man ein Deckblatt einfügen. Dies geht ganz simpel über das Register Einfügen und dann die Option Deckblatt auswählen. Dort gibt es einige Vorlagen, welche man aber auch anpassen kann. Es dient als gute Vorlage um wichtige Informationen wie den Autor oder den Titel des Dokuments darzustellen.\n Kopf- und Fusszeile In den Kopf- und Fusszeilen werden Texte eingegeben (oder auch Bilder eingefügt), die im gesamten Dokument oder einem gewissen Bereich des Dokuments am oberen oder unteren Seitenrand dargestellt werden. Typische Anwendungen sind zum Beispiel ein Firmenlogo in der Kopfzeile und die Seitenzahl oder der Dateiname in der Fusszeile.\nUm für das Dokument Kopf- und Fusszeile zu erstellen kann man in der Menüleiste auf das Register Einfügen wechseln. Im Abschnitt Kopfzeile oder Fusszeile können wir nun diese einfügen. Word hat schon einige Vorlagen, die wir benutzen können, aber es ist auch möglich eigene Formatvorlagen zu erstellen. Sobald man eine Kopf- oder Fusszeile erstellt hat, wechselt Word automatisch das Register. Nun können wir einige Einstellungen anpassen.\nDie wichtigsten Anpassungen sind folgende:\nSeitenzahl\nUm die Seitenzahl automatisch generieren zu lassen, kann man diese direkt einfügen lassen. Auch dort ist uns Word sehr behilflich und bietet uns einige Vorlagen an.\nOptionen\nIn den meisten Fällen ist die erste Seite eines Dokuments ein Titelblatt. Dort werden die Kopf- und Fusszeilen nicht dargestellt. Um das einzustellen, kann man unter Optionen den Punkt Erste Seite anders auswählen. Damit bekommt die erste Seite eine eigene Kopf- und Fusszeile.\n Bilder einfügen Um ein Bild einzufügen, kann man entweder über das Register Einfügen ein Bild über einen Dateipfad einfügen oder man kann das Bild auch direkt in das Dokument kopieren. Das Bild können wir nun bearbeiten. Zum Beispiel können wir es zuschneiden, die Grösse anpassen, eine Formatvorlage hinzufügen oder verschiedene Effekte hinzufügen.\nDamit man in einer Dokumentation die Bilder zusammen mit Text darstellen kann, gibt es für die Bilder Layoutoptionen. Mit diesen Optionen kann man den Textumbruch verändern und somit das Bild in den Text integrieren.\n Formatvorlagen Formatvorlagen vereinheitlichen das Dokument und lassen es professioneller wirken. Diese sind direkt im Register Start zu finden. Die verschiedenen Formatvorlagen kann man anpassen oder auch selbst neue Formatvorlagen erstellen. Um eine Vorlage zu bearbeiten, macht man einfach einen Rechtsklick auf die Vorlage und wählt dort Ändern aus. Nun kann man alle Optionen individuell anpassen.\n Inhaltsverzeichnis Um eine Übersicht über das Dokument zu erhalten, kann man ein Inhaltsverzeichnis generieren lassen. Dafür ist unter dem Register Referenzen die Option Inhaltsverzeichnis. Dort finden wir Vorlagen für integrierte Inhaltsverzeichnisse, die von Word selber bearbeitet werden. Wenn wir mit Inhaltsverzeichnissen arbeiten, müssen wir auch mit dem Formatvorlagen für die Titel arbeiten. So können Titel und Untertitel im Inhaltsverzeichnis erkannt und abgebildet werden. Zum Beispiel die Formatvorlage Überschrift 2 wird im Inhaltsverzeichnis eingerückt, da sie als Untertitel verwendet wird.\nNimmt man nach dem Einfügen vom Inhaltsverzeichnis noch weitere Änderungen am Dokument vor, muss man das Verzeichnis aktualisieren. Dafür klickt man einfach auf das Inhaltsverzeichnis im Dokument und kann dann oberhalb vom Verzeichnis auf Inhaltsverzeichnis aktualisieren klicken. Damit werden die Titel und Seitenzahlen aktualisiert.\n","categories":"","description":"Modul #O4 - Microsoft Word\n","excerpt":"Modul #O4 - Microsoft Word\n","ref":"/docs/tools/ms-word/","tags":"","title":"Microsoft Word"},{"body":"Eine Wörterbuch-Anwendung bewahrt die Einträge in einer Datenbank. Die Interaktion mit der Datenbank wird durch ein DictionaryRepository umgesetzt.\nEin DictionaryRepository setzt folgendes Interface um:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  public interface DictionaryRepository { /** * Die Methode erhält ein Wort und die Definition dazu und speichert diese als Eintrag in der Datenbank * * @Param word das Wort, welche in dem Wörterbuch hinzugefügt werden soll * @Param definition die Definition des Wortes * */ void add(String key, String value); /** * Die Methode aktualisiert die Definition des Wortes in der Wörterbuch-Datenbank * * @Param word das Wort, welche in dem Wörterbuch bereits existiert * @Param definition die aktualisierte Definition des Wortes * */ void update(String key, String value); /** * Die Methode liefert die Definition für das gegebene Wort aus der Wörterbuch-Datenbank zurück. * * @Param word das Wort, dessen Definition gesucht wird * @Return die Definition des Wortes aus der Wörterbuch-Datenbank, falls vorhanden, ansonsten null * */ String getDefinition(String word); }   Die Klasse Dictionary beinhaltet die Business-Logik des Wörterbuchs und verwendet ein DictionaryRepository, um die Einträge in der Datenbank zu speichern und zu finden:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  public enum DictionaryStatus { ADDED, UPDATED, INVALID, NOT_FOUND } public class Dictionary { private final DictionaryRepository repository; public Dictionary(DictionaryRepository repository) { this.repository = repository; } /** * Die Methode schreibt eine Definition für ein Wort in der Wörterbuch-Datenbank. * Zuerst wird geschaut, ob das Wort in der Datenbank bereits existiert. * Falls das Wort noch nicht existiert, wird einen neuen Eintrag in der Datenbank erstellt. * Falls das Wort bereits existiert, wird seine Definition aktualisiert. * * @Param word das Wort, welche in dem Wörterbuch hinzugefügt oder aktualisiert werden soll * @Param definition die Definition des Wortes * @Return DictionaryStatus.ADDED falls das Wort neu ist, DictionaryStatus.UPDATED falls das Wort * bereits vorhanden war und DictionaryStatus.INVALID, falls das Wort ein leerer String ist oder Zahlen beinhaltet * */ public DictionaryStatus addOrUpdateWord(String word, String definition) { //TODO gemäss JavaDoc umsetzen  } /** * Die Methode sucht nach der Definition des gegebenen Worts. * Falls das Wort existiert, wird die Definition zurückgeliefert und ansonsten einen * Text, welcher darauf hinweist, dass das Wort nicht vorhanden ist. * * @Param word das Wort, dessen Definition gesucht wird * @Return die Definition des Wortes, falls das Wort im Wörterbuch existiert. Ansonsten folgenden Text: * \"Das Wort xxx konnte im Wörterbuch nicht gefunden werden\" (xxx steht als Platzhalter für das gesuchte Wort) * */ public String getDefinition(String word) { //TODO gemäss JavaDoc umsetzen  } }   Aufgabe Schreibe eine Test-Klasse für Dictionary, welche folgende Tests beinhaltet:\n Tests der Methode addOrUpdateWord:  Das Wort befindet sich noch nicht in der Datenbank Das Wort befindet sich bereits in der Datenbank Das Wort ist ein leerer String Das Wort beinhaltet Zahlen   Tests der Methode getDefinition:  Das gesuchte Wort existiert in der Datenbank Das gesuchte Wort existiert nicht in der Datenbank Das gesuchte Wort is ungültig: leerer String Das gesuchte Wort is ungültig: das Wort beinhaltet Zahlen    Anforderungen\n Schreibe jeweils einen Test und erweitere den Code dann nur soweit bis der Test grün ist. Wiederhole dies für alle Tests (die bestehende Tests müssen weiterhin funktionieren!). Der Interface DictionaryRepository darf nicht umgesetzt werden. Für die Tests wird ein Mock oder ein Spy aus dem Mockito-Framework verwendet. Jede Test-Methode hat folgendes Namensschema: 1 2 3  public void given_when_then() { ... }   Wobei:\n given die Ausgangslage definiert when ist der Name der Methode, welche getestet wird then ist das Ergebnis, welche erwartet wird   Jede Test-Methode prüft, dass alle Methoden eines Mocks/Spy’s welche aufgerufen werden müssen, auch aufgerufen wurden. Jede Test-Methode prüft, dass alle Methoden eines Mocks/Spy’s welche NICHT aufgerufen werden sollen, auch nicht aufgerufen wurden.  ","categories":"","description":"Aufgaben zu Modul #J4 - Testing / Mockito\n","excerpt":"Aufgaben zu Modul #J4 - Testing / Mockito\n","ref":"/labs/java/java-testing/02_mockito/","tags":"","title":"Mockito - Aufgaben"},{"body":"Hogwarts Sorting Hat System Hogwarts ist bekanntlich die beste Schule für Hexerei und Zauberei. Alle Hogwarts Schüler:innen werden vor Beginn des ersten Schuljahres gemäss ihren Charakter-Eigenschaften und Fähigkeiten in einem der vier Hogwarts “Häuser” eingeteilt. Die Einteilung in die Häuser ist die Aufgabe des “sprechenden Hutes” (engl. “Sorting Hat”).\nDer sprechende Hut ist mittlerweile mehr als 1000 Jahre alt und soll in den verdienten Ruhestand gehen. Dazu ist die Digitalisierung auch bei Hogwarts endlich angekommen und der Schulmeister möchte dich beauftragen ein Sorting-Hat System zu bauen, welche die Aufgabe des sprechenden Hutes übernimmt und neue Schüler:innen in eines der vier Hogwarts-Häuser aufgrund von bestimmten Kriterien und Eigenschaften einteilt.\nDie Hogwarts Häuser und ihre Eigenschaften/Merkmale Die vier Hogwarts Häuser - Gryffindor, Hufflepuff, Ravenclaw und Slytherin - haben bestimmte Merkmale und Eigenschaften, welche dem sprechenden Hut dabei helfen, die Schüler:innen in das richtige Haus einzuteilen.\nDie folgende Tabelle listet ein paar wichtige Merkmale für jedes Haus auf:\n   Haus Wichtigste Charakter-Eigenschaften Hausfarben Haustier Element Gründer:in Anzahl Schüler:innen     Gryffindor Tapferkeit, Kühnheit, Courage, Ritterlichkeit, Entschlossenheit Gold, Scharlachrot Löwe Feuer Godric Gryffindor 31   Hufflepuff Fleiss, Hingabe, Geduld, Loyalität, Fairplay Gelb, Schwarz Dachs Erde Helga Hufflepuff 15   Ravenclaw Intelligenz, Wissen, Neugier, Kreativität, geistige Wendigkeit Blau, Bronze Adler Luft Rowena Ravenclaw 33   Slytherin Ehrgeiz, Führerschaft, Selbsterhaltung, List, Einfallsreichtum Smaragdgrün, Silber Schlange Wasser Salazar Slytherin 48    Einteilungsalgorithmus Der sprechende Hut teilt angehende Hogwarts Schüler:innen in eines der vier Hogwarts-Häuser anhand von bestimmten Kriterien ein. Diese Kriterien sind:\n Charakter-Eigenschaften der Person, verglichen mit den Charakter-Eigenschaften, welche dem/der Gründer:in des Hauses wichtig waren Lieblingsfarbe, verglichen mit den Hausfarben Verwandtschaft mit einem ehemaligen Mitglied eines der Häuser Das Wunschhaus der Person, welche eingeteilt werden soll  Der/die Schüler:in wird zu jedem Kriterium befragt (mehrere Antworten sind bei den meisten Kriterien möglich!). Die Antworten zu jedem Kriterium werden bewertet, sodass am Schluss für jedes Haus eine Gesamtbewertung vorliegt. Der/die Schüler:in wird in das Haus mit dem höchsten Wert eingeteilt.\nAber vorsicht, es gelten auch folgende Bestimmungen, welche die Auswertung des gewählten Hauses beeinflussen:\n Nicht alle Kriterien/Werte werden beim Einteilungsentscheid gleich gewichtet (die Gewichtung wird später erläutert). Wenn zwei Häuser die gleiche Bewertung erhalten, wird das Haus mit der niedrigeren Anzahl Schüler:innen ausgewählt. Das Wunschhaus wird bei der Gesamtbeurteilung manchmal berücksichtigt und manchmal nicht (mehr dazu später)  Gewichtung der Kriterien Folgend findest du die Bestimmungen und Gewichtungen, welche bei der Auswertung des passenden Hauses eingehalten werden müssen. Die Gesamtauswertung eines Hauses besteht aus der Summe aller Punkte, welche bei jedem Kriterium für dieses Haus berechnet worden sind.\nCharakter-Eigenschaften Es sind insgesamt 20 Charakter-Eigenschaften möglich (siehe Tabelle der Hogwarts-Häuser hier oben). Der/die Benutzer:in muss mindestens drei Charakter-Eigenschaften auswählen, welche zu ihm/ihr passen.\nPer Haus, hat jede Charakter-Eigenschaft ein Gewicht zwischen 1 und 20. Die wichtigsten Charakter-Eigenschaften eines Hauses erhalten die höchsten Gewichtswerte für dieses Haus. Die anderen Charakter-Eigenschaften bekommen niedrigere Werte. Bei der Auswertung werden für jedes Haus die Gewichtswerte für die eingegebenen Eigenschaften zusammenaddiert.\nFarben In Hogwarts gibt es vier Hausfarben-Paare, also insgesamt acht Hausfarben (siehe Tabelle der Hogwarts-Häuser hier oben). Der/die Benutzer:in gibt seine/ihre Lieblingsfarbe ein. Wenn die Farbe, mit einer Hausfarbe übereinstimmt, erhält dieses Haus zusätzliche 10 Punkte.\nVerwandtschaft Eine Person kann mehrere Verwandte haben, welche in Hogwarts studiert haben und entsprechend einem Haus eingeteilt wurden.\nDie Anzahl Verwandte, welche einem Haus eingeteilt wurden, gibt diesem Haus einen zusätzlichen Wert, welcher der Fakultät dieser Anzahl Verwandten entspricht.\nHinweis: eine Person kann mehrere Verwandte haben, welche in unterschiedliche Häuser eingeteilt worden waren…\nWunschhaus Der/die Benutzer:in kann sein/ihr Wunschhaus eingeben. Das Wunschhaus “schenkt” dem gewählten Haus eine zufällige Anzahl Punkte zwischen 5 und 10 zur Gesamtbeurteilung aber nur wenn der/die Benutzer:in auch eine der Hausfarben dieses Hauses als Lieblingsfarbe ausgewählt hat.\nAnforderungen an das System  Verwende viele verschiedene Klassen, um dein System zu modellieren Erzeuge ein gutes Abbild der Aufgabenstellung Die main Methode soll nur zur Interaktion mit dem/der Benutzer:in dienen. Skizziere dein Modell, sodass du es danach auch erklären kannst Teil der Aufgabe ist es, bestimmte Prinzipien kennenzulernen und zu verstehen. Wende entsprechend bei der Umsetzung folgende Prinzipien an:  Single Responsibility Principle Immutable Objects    Bonus Anforderungen\n Wenn sinnvoll, wende Generics an Verwende, wenn möglich, Streams statt Loops Füge ein Einteilungskriterium hinzu  Wenn du an der Challenge teilnehmen willst, dann musst du die Aufgabe alleine lösen. Die Lösung vom Pult-Nachbar interessiert uns also nicht.\n","categories":"","description":"Challenge zu Modul #J2\n","excerpt":"Challenge zu Modul #J2\n","ref":"/challenges/java/java-oop/01_oop_challenge/","tags":"","title":"Objektorientierte Programmierung Challenge"},{"body":"Für dieses Exam dürfen auch Inhalte der Themen Lists und Generics verwendet werden\nCØØP Unsere Supermarkt-Kette heisst CØØP. CØØP ist ein Supermarkt welcher an vielen Orten in der Schweiz vertreten ist. Der Name einer Filiale ist einzigartig, dies macht es dem ganzen System ein wenig einfacher.\nIm CØØP findet man verschiedenste Artikel von Lebensmitteln, über Haushaltsgeräte bis zu Baustoffen wie Holz und Metall. CØØP ist sehr modern eingerichtet und es ist es dem System genau bekannt wie viele Regale jeder Standort besitzt. Das System weiss auch, welcher Artikel sich bei welchem Laden in welchem Regal befindet.\nNatürlich hat nicht jeder Artikel im CØØP einen Barcode für die Kasse, da ja z.B. ein Gipfeli kein Barcode hat. Also muss an der Kasse beim Scannen bemerkt werden, ob der Artikel einen Barcode hat oder nicht. Falls dies nicht der Fall ist, muss der Artikel von Hand in die Kasse eingetragen werden.\nHab ich schon erwähnt, dass einige Filialen im CØØP auch Self-Service Kassen besitzen? Dort kann der Kunde seine Ware selber “scannen” und anschliessend bezahlen.\nUm den Kunden den Einkauf zu erleichtern, haben unsere Kunden die Möglichkeit unser System über dedizierte Tablets ansprechen zu können. Über das Tablet kann ein Kunde abfragen, ob ein gewünschtes Produkt in einer bestimmten Filiale vorhanden ist. Falls dies der Fall ist, soll dem Kunden zusätzlich angezeigt werden, in welchem Regal sich der Artikel befindet.\nCØØP hat eine eigene Karte namens Schüpercard (ja mit ü). Diese kann beim Einkaufen gescannt werden. Denke daran, dass jede Schüpercard einzigartig ist. Falls die Schüpercard beim Einkaufen gescannt, so wird dem Konto des Kunden pro 1.- CHF Einkaufswert 1 Schüperpunkt gutgeschrieben (Es werden keine halben Punkte verteilt und es wird immer abgerundet).\nJeder Mitarbeiter einer CØØP Filiale ist im System hinterlegt. Es wird auch jederzeit nachgeführt, welcher Mitarbeiter sich zurzeit in welcher Filiale befindet. So kann der Chef die Anwesenheit aller Mitarbeiter sauber überprüfen.\n","categories":"","description":"Exam zu Modul #J2\n","excerpt":"Exam zu Modul #J2\n","ref":"/exams/java/java-oop/oopexam/","tags":"","title":"Objektorientierte Programmierung Exam"},{"body":"Die folgende Aufgabe dient der Vertiefung der beiden Themen Reflection API und Annotations.\nAufgabe 1 Implementiere eine Klasse Person mit den Attributen Namen und Alter. Die Klasse muss einen Konstruktor mit beiden Attributen aufweisen. Für beide Attribute muss eine Get-Methode implementiert werden.\nImplementiere zudem eine toString Methode.\nAufgabe 2 Implementiere eine eigene Annotation. Die Annotation soll der Auffindung der Klasse zur Erzeugung von Instanzen der oben genannten Klasse dienen und die folgenden Eigenschaften aufweisen:\n Verfügbar zur Laufzeit Verfügbar auf Klassen  Der Name der Annotation soll anhand ihres Zwecks gewählt werden. Die Annotation hat keine Attribute.\nAufgabe 3 Implementiere eine weitere Annotation. Die Annotation soll der Angabe von Daten für Personen dienen. Sie muss die folgenden Eigenschaften aufweisen:\n Verfügbar zur Laufzeit Verfügbar auf Konstruktoren Attribut für die Namen von Personen als String-Array Attribut für das Alter von Personen als Integer-Array  Aufgabe 4 Wende die beiden Annotationen auf deine Person-Klasse an. Eine auf der Klasse, die Andere auf dem Konstruktor.\nDie Annotation auf dem Konstruktor muss mindestens drei Namen und drei Altersangaben aufweisen.\nAufgabe 5 Implementiere eine Main-Klasse mit einer Main-Methode und nutze Reflection, um Instanzen anhand der Konstruktor-Annotation zu erzeugen. Gehe dabei wie folgt vor:\n Hol dir eine Klasseninstanz über den Package- und Klassennamen oder über das statische Feld class Hol dir auf der Klasseninstanz den Konstruktor Hol dir vom Konstruktor die Annotation Hol aus der Annotation die Namen und Altersangaben Nutze die Angaben in einem Loop, um entsprechend viele Instanzen der Klasse Person zu erzeugen Drucke die Angaben der Personen auf der Kommandozeile aus  ","categories":"","description":"Aufgaben zu Modul #J6 - Annotationen \u0026 Reflection API\n","excerpt":"Aufgaben zu Modul #J6 - Annotationen \u0026 Reflection API\n","ref":"/labs/java/java-reflection-and-annotations/02_reflection_exercises/","tags":"","title":"Reflection API - Aufgaben"},{"body":"In dieser Aufgabe wird ein Fantasy-Rollenspiel mit Vererbung modelliert. Lies zuerst die Einführung und arbeite dann die untenstehenden Aufgaben ab.\nEinführung Spielfiguren  Es gibt verschiedene Spielfiguren:  Menschen Zwerge Elfen Orks Goblins Trolle   Jede Spielfigur hat einen Namen und besitzt eine bestimmte Anzahl an Lebenspunkten. Diese Lebenspunkte werden später im Kampf mit anderen Spielfiguren verringert Jede Spielfigur hat eine gewisse Tragkraft um Gegenstände und Ausrüstung mit sich herumtragen zu können (siehe weiter unten) Elfen können zaubern und haben einen Zauberwert Alle Spielfigur-Klassen sollen in einem entsprechenden Package angelegt werden  Waffen  Es gibt verschiedene Waffenarten  Nahkampfwaffen (Schwert und Keule) Fernkampfwaffen (Bogen und Wurfmesser)   Alle Waffen haben einen Angriffswert Nahkampfwaffen haben zusätzlich zu ihrem Angriffswert noch einen Verteidigungswert Alle Waffen haben ein Gewicht Alle Waffen-Klassen sollen in einem entsprechenden Package angelegt werden  Gegenstände  Es gibt verschiedene Gegenstände  Tränke (Heiltrank und Stärketrank)  Ein Heiltrank kann bei einer Spielfigur eine bestimmte Anzahl an Lebenspunkten wiederherstellen Ein Stärketrank erhöht den Angriffswert einer Spielfigur dauerhaft um einen bestimmten Wert   Zauberringe (Kraftring, Schutzring)  Ein Kraftring erhöht die Tragkraft einer Spielfigur dauerhaft um einen bestimmten Wert Ein Schutzring verringert dauerhaft den erlittenen Schaden     Jeder Gegenstand hat eine Bezeichnung und ein Gewicht Alle Gegenstand-Klassen sollen in einem entsprechenden Package angelegt werden   Aufgabe 1 Implementation\n der Packages der Klassen der Instanzvariablen in den Klassen der Beziehungen zwischen den einzelnen Klassen  Vergiss nicht, dass es Generalisierungen und Spezalisierungen gibt. Achte auf eine gute Namensgebung bei Klassen und Variablen.\n Aufgabe 2 Ergänze die Applikation mit den folgenden Möglichkeiten:\nSpielfigur  Jede Spielfigur braucht einen Namen um instanziiert werden zu können Zu Beginn hat eine Spielfigur keine Waffe Jede Spielfigur hat eine Methode, die ihren Kampfwert zurückgibt  Der Kampfwert der Spielfigur setzt sich aus dem Kampfwert der akitven Waffe und der Multiplikation mit einer Zufallszahl zusammen. Die Zufallszahl liegt zwischen 0.9 und 1.1 Wenn eine Spielfigur keine Waffe besitzt, so ist ihr Kampfwert 1    Elfen\n Um einen Elfen instanziieren zu können, muss zusätzlich zum Namen der Zauberwert des Elfen angegeben werden Einem Elfen wird die Hälfte seines Zauberwerts zum Kampfwert addiert Elfen sind gute Bogenschützen, ihr Kampfwert erhöht sich um 50%, wenn sie einen Bogen als aktive Waffe benutzen  Goblins\n Goblins sind gute Bogenschützen, ihr Kampfwert erhöht sich um 50%, wenn sie einen Bogen als aktive Waffe benutzen  Trolle\n Trolle verdoppeln ihren Kampfwert wenn sie eine Keule verwenden  Orks\n Orks können in einen Kampfrausch verfallen, wenn ihre Lebenspunkte unter 25% fallen. Sie erhalten dann den dreifachen Kampfwert und erleiden nur den halben Schaden  Waffen  Jede Spielfigur kann mit einer Waffe ausgerüstet werden  Wird eine Waffe aufgenommen, wird die Tragkraft entsprechend reduziert Ist die Waffe zu schwer für die verbleibende Tragkraft, so kann die Spielfigur die Waffe nicht aufnehmen Eine Spielfigur kann mehrere Waffen mit sich rumtragen, aber jeweils nur eine Waffe aktiv verwenden   Spielfiguren können Waffen ablegen, um die verbleibende Tragkraft zu erhöhen Alle Keulen haben den Angriffswert 5 und den Verteidigungswert 5. Die beiden Werte sind also konstant Jede Waffe hat einen Kampfwert  Waffen geben als Kampfwert ihren Angriffswert zurück Bei Nahkampfwaffen wird zum Angriffswert der halbe Verteidigungswert hinzuaddiert    Gegenstände  Jede Spielfigur kann Gegenstände bis zur maximalen Tragkraft aufnehmen  Wird ein Gegenstand aufgenommen, wird die Tragkraft entsprechend reduziert Ist der Gegenstand zu schwer für die verbleibende Tragkraft, so kann die Spielfigur den Gegenstand nicht aufnehmen Eine Spielfigur kann mehrere Gegenstände mit sich rumtragen und diese Gegenstände später im Kampf aktiv einsetzen    Kampf  Jede Spielfigur kann gegen eine andere Spielfigur kämpfen  Der Kampf findet in Runden statt Es wird solange gekämpft, bis eine oder beide Spielfiguren keine Lebenspunkte mehr haben Steht nach 20 Runden noch kein Sieger fest, wird der Kampf abgebrochen Bei jeder Runde wird der Kampfwert der einen Spielfigur den Lebenspunkten des Gegners abgezogen und umgekehrt Diejenige Spielfigur mit den meisten verbliebenen Lebenspunkten gewinnt Jede Spielfigur kann in einem Kampf von ihren Gegenständen Gebrauch machen     Aufgabe 3  Definiere nun eigene Regeln für deine Spielfiguren, damit das Spiel ein wenig ausgeglichener wird Die Regeln können beliebig geändert werden Es dürfen natürlich auch neue Waffen und Gegenstände eingeführt werden Dein Entwurf soll mindestens eine neue Spielfigur, eine neue Waffe, einen neuen Gegenstand und eine neue Spezialität für eine Spielfigur enthalten   Aufgabe 4  Die Kämpfe können sehr unausgeglichen sein Das Spiel soll so gestaltet werden, dass nicht immer die gleichen Spielfiguren gewinnen   Aufgabe 5  Das Spiel soll für alle Aktionen einen übersichtlichen Log generieren Eine Ausgabe für die Kommandozeile genügt, wenn sie sauber formatiert ist   Aufgabe 6 Die Applikation hat nun aufgrund der vielen Klassen und Möglichkeiten eine gewisse Grösse erreicht und damit auch an Übersichtlichkeit verloren. Die Logik der Applikation ist nun, je nach Implementation, in sehr vielen unterschiedlichen Klassen vorhanden. In bestimmten Fällen, wie der Spezalisierung einer bestimmten Klasse, ist dies in Ordnung.\nWir arbeiten aber wenn immer möglich nach dem Single-Responsibility-Principle. Dieses Prinzip besagt, dass jeder Teil (bspw. Klasse, Methode) einer Applikation nur für genau eine Aufgabe innerhalb dieser Applikation zuständig und verantwortlich ist. Kurz gesagt: eine Methode macht beispielsweise niemals zwei verschiedene Dinge gleichzeitig.\n Erstelle eine Klasse, welche den Kampf zwischen zwei Spielfiguren verwaltet. Diese Klasse enthält diverse Methoden und ist verantwortlich für:  das Starten eines neuen Kampfes zwischen zwei Spielfiguren das Zählen der Kampfrunden das Verrechnen von Schaden das Ermitteln des Gewinners   Stelle sicher, dass die spezalisierten Modell-Klassen (Elf, Heiltrank) nur die Logik enthalten, die für eine Spezalisierung gerechtfertigt ist  Beispiel 1: die Berechnung des Kampfwerts eines Elfen gehört in die Elf-Klasse, die diese die Spezialisierung für einen Elfen enthält Beispiel 2: der Kampf zwischen zwei Spielfiguren gehört NICHT in die Spielfigur-Klasse, da diese generell gültige Informationen zu einer Spielfigur enthält und das eigentliche “Spiel” mit dem Kampf zweier Spielfiguren nicht die Aufgabe dieser Klasse ist     Aufgabe 7  Das Spiel soll erweitert werden, dass eine Spielfigur eine Rüstung tragen kann Es gibt leichte und schwere Rüstungen  Elfen und Goblins dürfen nur leichte Rüstungen tragen Menschen, Zwerge und Orks dürfen schwere Rüstungen tragen Trolle können aufgrund ihrer Grösse keine Rüstung tragen Eine Spielfigur, welche eine schwere Rüstung tragen kann, kann selbstverständlich auch eine leichte Rüstung anziehen   Eine Spielfigur muss nicht zwingend eine Rüstung tragen Jede Rüstung hat ein Gewicht, welches die Tragkraft der Spielfigur entsprechend verringert Eine Spielfigur kann eine Rüstung anziehen oder sie ablegen Mit dem Tragen einer Rüstung ist es einer Spielfigur möglich im Kampf pro Runde den Schaden komplett zu verhindern. Die schwere Rüstung ist dabei erfolgreicher. Das Verhindern von Schaden passiert zufällig   Aufgabe 8  Verhindere die Instanziierung von Klassen, die keinen Sinn ergeben (Beispiel Waffe, Spielfigur, …)   Aufgabe 9  Jede Spielfigur erhält einen Initiative-Wert Je höher der Wert, desto früher darf die Spielfigur im Kampf zuschlagen Tiefere Werte verteilen also ihren Schaden später als höhere Werte Eine Spielfigur mit tiefem Initiative-Wert kann nicht mehr zurückschlagen wenn sie getötet wird Das Tragen von schweren Rüstungen verringert den Initiative-Wert  ","categories":"","description":"Aufgabe zu Modul #J3 - OOD - Rollenspiel\n","excerpt":"Aufgabe zu Modul #J3 - OOD - Rollenspiel\n","ref":"/labs/java/java-ood/02_rollenspiel/","tags":"","title":"Rollenspiel"},{"body":"Aufgabe 1 Schreibe ein Programm, welches die Personen von vier Vereine auswertet.\n Pro Verein existiert ein Set mit allen Vereinsmitlieder (siehe Input). Das Programm analysiert die Vereinsmitglieder und schreibt verschiedene Aussagen in die Konsole (siehe Ausgabe). Die Namen der Personen müssen in alphabetischer Reihenfolge angezeigt werden.  Input  4 Sets 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  Set\u003cString\u003e fussballVerein = Set.of( \"Emil\", \"Hans\", \"Felix\", \"Fritz\", \"Patrick\", \"Hanne\", \"Anja\", \"Paula\", \"Petra\", \"Anna\" ); Set\u003cString\u003e schwimmVerein = Set.of( \"Emil\", \"Klaus\", \"Paul\", \"Fritz\", \"Patrick\", \"Hanne\", \"Anina\", \"Nicole\", \"Petra\", \"Gerda\" ); Set\u003cString\u003e musikVerein = Set.of( \"Kari\", \"Hans\", \"Max\", \"Karin\", \"Petra\", \"Anna\" ); Set\u003cString\u003e tanzVerein = Set.of( \"Emil\", \"Hans\", \"Paul\", \"Felix\", \"Max\", \"Lara\", \"Anja\", \"Sabine\", \"Anna\" );    Ausgabe Die Ausgabe muss das folgende Format aufweisen:\n1 2 3 4  - Wie viele Personen machen min. in einem Verein mit: 2: Maria,Xaver - Alle Personen, welche im Fussball und Tanz Verein sind: 2: Maria,Xaver - Alle Personen, welche im Fussball sind und nicht im Tanz oder Schwimm Verein: 2: Maria,Xaver   Ausgabe überprüfen Wie können wir die Ausgabe überprüfen, ohne dass ihr die Lösung kennt? Wir benützen dazu eine kleine Hilfsklasse OutputValidation. Die Klasse erlaubt es eure System.out.println() Anweisungen mit OutputValidation.logAndPrint() zu ersetzten. Am Schluss des Programmes kann man mit OutputValidation.printControlHash() den Hash-Wert der eigenen Ausgabe anzeigen, oder mit OutputValidation.verifyControlHash() einen Hash-Wert zur Überprüfung mit eurer Ausgabe überreichen.\nEin Anwendungsbeispiel seht ihr unter OutputValidationUsage.\nDer Hash für diese Aufgabe ist: -1421274666\nAufgabe 2 Wir programmieren eine eigene Set-Klasse MySet, welche noch kein Hash-Code verwendet.\n Es dürfen keine Klassen aus dem Collection-Framework verwendet werden. Die Klasse muss das Interface MySetInterfaceSimple implementieren. Die Klasse weiss nicht, wie viele Elemente man speichern muss. Sie muss die Grösse des Arrays dynamische anpassen. Die toString() der java.lang.Object Klasse soll von der MySet so überschrieben werden, dass die Elemente kommasepariert ausgegeben werden.  Input  Inferface MySetInterfaceSimple 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  package com.examples.list; public interface MySetInterfaceSimple\u003cE\u003e { /** * AAdds the specified element to this set if it is not already present. * @param element element to be appended to this list * @return true if this set did not already contain the specified element */ boolean add(E element); /** * Removes the specified element from this set if it is present. * @param object object to be removed from this set, if present * @return true if the set contained the specified element */ boolean remove(Object object); /** * Returns true if this set contains the specified element. * @param object element whose presence in this set is to be tested * @return true if this set contains the specified element */ public boolean contains(Object object); /** * Returns the number of elements in this set. * @return the number of elements in this set */ int size(); /** * Returns true if this set contains no elements. * @return true if this set contains no elements */ boolean isEmpty(); /** * Removes all the elements from this set. The set will be empty after this call returns. */ void clear(); }    Aufgabe 3 (Optional) Wir Kopieren unsere MySet Klasse zu der Klasse MyHashSet und erweitern diese, damit sie Hash Funktionalität verwendet:\n Beim Hinzufügen von neuen Elementen wird deren Hash-Code berechnet und ebenfalls abgespeichert. Die Suche nach bestehenden Elementen wird anschliessend über den gespeicherten Hash-Code durchgeführt statt über die Elemente selbst.  ","categories":"","description":"Aufgaben zu [Java Collections - Set](../../../../docs/java/java-collections/03_set)  \n","excerpt":"Aufgaben zu [Java Collections - …","ref":"/labs/java/java-collections/02_set/","tags":"","title":"Set - Aufgaben"},{"body":"Exam - Zeiterfassungs-Dashboard mit JavaScript ergänzen - Einzelarbeit\nBei diesem Exam geht es darum, dass du das Dashboard, welches du im HTML-CSS-Exam geschrieben hast, mit JavaScript-Logik ergänzt.\nDie Seite sollte ungefähr so aussehen:\nZeitangaben aktualisieren Oben links im Zeiterfassungstool ist die aktuelle Zeit zu finden.\nSchreibe ein JavaScript auf dieser Seite, das die aktuelle Zeit oben links anzeigt.  Hinweis:\nUm auf die aktuelle Uhrzeit und auf das Datum zuzugreifen, wirst du sicher auf die Klasse Date zugreifen müssen. Hier findest du mehr Informationen darüber: https://www.w3schools.com/jsref/jsref_obj_date.asp\nDie Kalenderwoche (KW) hinzuzufügen, ist ein bisschen tricky und deswegen optional. Wenn du diese trotzdem hinzufügen möchtest, dann informiere dich bitte zuerst darüber, was genau eine Kalenderwoche ist. Soweit ich weiss, gibt es keine eingebaute Methode, mit der du die Kalenderwoche bekommst, aber du kannst sie berechnen.\nNavigation zuklappen Auf der linken Seite hast du eine Navigation. Das Element für “Abfragen” hat wiederum Elemente untergeordnet. Diese Unterelemente sollten beim Klick auf den Pfeil gegen oben (^) verschwinden/zugeklappt werden.\nSchreibe ein JavaScript, das dem User erlaubt, das \"Abfragen\"-Element zuzuklappen und wenn es zugeklappt ist, wieder aufzuklappen.   Animationen Wenn du möchtest, kannst du dem Ganzen Animationen verleihen:\n der Pfleil dreht sich, jenachdem ob das Element zu- oder aufgeklappt ist das “Berichte”-Element geht langsam nach oben (bzw. der Container mit den Unterelementen wird immer kleiner)  Animationen (bzw. transitions) können sehr einfach mit CSS umgesetzt werden, siehe https://www.w3schools.com/css/css3_transitions.asp.\nDamit du weniger Schwierigkeiten damit hast, hier ein kleiner Tipp: Gib allen CSS-Properties einen Default-Wert. Wenn du z.B. einen Wert ändern möchtest, füge dem Element eine genauere CSS-Klasse mit JavaScript hinzu, welche die entsprechenden Regeln überschreibt. Du kannst einem Element eine Klasse hinzufügen bzw. entfernen mit .classList.toggle(className, show?) (Beispiel: document.getElementById('abfragen').classList.toggle('show-child-elements', true)).\n Dashboard-Daten dynamisch laden Im HTML-CSS-Exam hast du den Text für die Kacheln hartcodiert. Das soll sich nun ändern.\nSchreibe nun ein JavaScript, dass den Inhalt der Kacheln dynamisch befüllt. Dein Script soll die Daten von hier laden: https://raw.githubusercontent.com/it-ninjas/labs/master/static/files/json/dashboard.json  Personen für den Chat dynamisch laden Auf der rechten Seite hast du eine Liste mit Personen für einen Chat. Nun geht es darum, auch diese Liste anhand eines JSONs zu generieren.\nErgänze dein JavaScript so, dass die Namen für die Chat-Liste von hier geladen werden: https://raw.githubusercontent.com/it-ninjas/labs/master/static/files/json/chat.json Zeige die Personen dann zeitlich versetzt an: Füge zuerst die erste Person ein, warte dann ca. 0.3 Sekunden, zeige dann die zweite Person an usw.  Suchfunktion Oben rechts hast du eine “Suche”.\nImplementiere eine Suchfunktion, die nur noch diejenigen Chat-Kontakte anzeigt, wenn der Suchbegriff in deren Namen vorkommt. Implementiere die Suche so, dass die Liste beim Tippen aktualisiert wird.  Refresh-Button Oben rechts gibt es einen Refresh-Button.\nVerändere dein HTML und JavaScript so, dass die Daten neu geladen werden, wenn der User auf diesen Refresh-Button klickt. Neu geladen werden sollen die Zeitangaben, die Kacheln und der Chat Achte darauf, dass du möglichst keine Code-Duplikation hast.  ","categories":"","description":"Erweitere dein eigenes Zeiterfassungs-Dashboard - mit JavaScript.\n","excerpt":"Erweitere dein eigenes Zeiterfassungs-Dashboard - mit JavaScript.\n","ref":"/exams/web/html_css/02_exam_js/","tags":"","title":"Exam zu JavaScript"},{"body":"Auf DOM-Elemente zugreifen Eines der häufigsten Anwendungszwecke von JavaScript ist es, mit Elementen auf einer Website zu interagieren.\nNehmen wir folgendes Code-schnipsel als Beispiel:\n1 2 3 4  \u003cdiv id=\"message-div\"\u003e\u003c/div\u003e \u003cp\u003eThis page has \u003cspan id=\"likes-count\"\u003e0\u003c/span\u003e likes.\u003c/p\u003e \u003cbutton type=\"button\"\u003e+1\u003c/button\u003e   Mit JavaScript möchten wir, dass sich die Zahl im \u003cspan\u003e erhöht. In einem ersten Schritt versuchen wir, auf das \u003cspan\u003e-Element zuzugreifen und eine andere Zahl reinzuschreiben. Das probieren wir direkt in der Konsole des Browsers aus:\n1 2  let span = document.getElementById('likes-count'); span.textContent = 999;   Du wirst sehen, dass sich die Zahl im \u003cspan\u003e tatsächlich verändert hat. Probieren wir aber zuerst, den Code zu verstehen!\n Erläuterung (click to expand)  document ist ein Objekt, das uns im Browser zur Verfügung steht. Dieses Objekt repräsentiert das DOM. Mit diesem document-Objekt können wir auf die Elemente im Browser zugreifen. getElementById(...) ist eine Methode auf diesem document-Objekt. Diese Methode sucht auf der aktuellen Seite ein Element, das die übergebene id besitzt. Das gefundene Element möchten wir in einer Variablen namens span zwischenspeichern. textContent ist ein Feld (= ein Attribut) auf diesem Element, das den Inhalt des Elements (als Text) repräsentiert. Diesen Wert können wir einfach so kopieren.   Mit diesem Code konnten wir die Anzahl Likes auf eine andere Zahl setzen. Nun möchten wir aber, dass sich diese Anzahl um genau 1 erhöht. Dafür benötigen wir noch zwei Zwischenschritte:\n Die aktuelle Zahl auslesen Diese Zahl von einem String in eine Nummer konvertieren Und die erhöhte Zahl ins \u003cspan\u003e schreiben.  Versuche dies zu implementieren, bevor du dir die Lösung ansiehst.\n Lösung (click to expand) Das könnte ungefähr so aussehen: 1 2 3 4  let span = document.getElementById('likes-count'); let likes = parseInt(span.textContent); likes++; span.textContent = likes;   Neu dazugekommen ist\n der Aufruf von parseInt(...). Diese Methode ist standartmässig Global verfügbar und kann somit ohne imports verwendet werden. Diese Methode versucht, den übergeben Wert in eine Ganzzahl (Integer) zu konvertieren. likes++ bedeutet gleich viel wie likes = likes + 1. Damit erhöhen wir die likes-Variable also um 1. Mit span.textContent = likes setzen wir den Text des spans neu. Eine Umwandlung in String ist nicht notwendig.  Versuche das ganze nun mal ohne die parseInt Methode. Du wirst sehen, dass es trotzdem funktioniert. Das liegt daran, dass JS keine “starke” typen (strong types) kennt. Sprich der JS-Interpreter versucht auch einen String als Zahl zu verwenden und wenn es sich wirklich um eine Zahl handelt, funktioniert das auch:\n1 2 3 4 5 6  function onLikeClick() { let span = document.getElementById('likes-count'); let likes = span.textContent; likes++; span.textContent = likes; }   Dies ist aber sehr fragil, daher ist es good practice, die Variablen trotzdem in die korrekten typen umzuwandeln. Gut zu wissen, ist das sich JavaScript teilweise etwas unerwartet verhält.\n Manipulation beim Button-Klick ausführen lassen Nun wollen wir noch, dass das, was wir vorher programmiert haben, dann passiert, wenn der User auf den Button klickt. Ändere die HTML-Seite wie folgt ab:\n1 2 3 4 5 6 7 8 9 10 11 12  ... \u003cbutton type=\"button\" onclick=\"onLikeClick()\"\u003e+1\u003c/button\u003e \u003cscript\u003e function onLikeClick() { let span = document.getElementById('likes-count'); let likes = parseInt(span.textContent); likes++; span.textContent = likes; } \u003c/script\u003e ...   Ein neues Element hinzufügen Manchmal möchtest du ein neues Element auf der Website generieren lassen.\nIm kommenden Beispiel möchten wir so viele Bilder von “Thumbs Ups” (also 👍) wie Likes anzeigen.\nUm das zu erzielen, kannst du die onLikeClick-Funktion wie folgt erweitern:\n1 2 3 4 5 6 7 8  // draw a thumb up for every like: const imgHtml = '\u003cimg src=\"https://upload.wikimedia.org/wikipedia/commons/c/ce/Emoji_u1f44d.svg\" alt=\"like\" height=\"25\"\u003e'; let insertHtml = ''; for (let i = 0; i \u003c likes; i++) { insertHtml += imgHtml; } const messageDiv = document.querySelector('div#message-div'); messageDiv.innerHTML = insertHtml;   Dieser Code macht folgendes:\n für jedes Like, wird im \u003cdiv id=\"message-div\"\u003e folgendes Element/Bild hinzugefügt: \u003cimg src=\"https://upload.wikimedia.org/wikipedia/commons/c/ce/Emoji_u1f44d.svg\" alt=\"like\" height=\"25\"\u003e Das HTML für dieses Bild haben wir zuerst in einer Konstante (const) gespeichert. const ist das Gleiche wie let mit dem Unterschied, dass sich dieser Wert nie verändern darf innerhalb dieser Methode. Wenn sich eine Variable nie im definierten Block verändert, so wird empfohlen, const statt let zu verwenden. Die String-Variable insertHtml brauchen wir als Zwischenspeicher, in welcher wir den HTML-String zusammensetzen, welche wir später im HTML/DOM haben möchten. Die for-Schlaufe wird so oft durchlaufen, wie es Likes gab. Das bedeutet, dass pro Like ein Bild ins insertHtml kopiert wird. Anschliessend holen wir uns das \u003cdiv id=\"message-div\"\u003e via JavaScript. Wir hätten hier auch document.getElementById('message-div') verwenden können. Aber querySelector funktioniert hier auch. Die querySelector-Methode akzeptiert ein CSS-Selektor und gibt dann das Element zurück, das damit angesprochen wird. In diesem Beispiel war div#message-div ein möglicher CSS-Selektor (wie #message-div eigentlich auch), der das \u003cdiv id=\"message-div\" anspricht. Als letztes verändern wir das HTML dieses \u003cdiv\u003es, indem wir das innerHTML-Feld neu setzen.  Super, nun hast du schon ein paar Dinge auf deiner Seite mit JavaScript dynamisch verändert.\nBitte denke daran, dass das Verwenden von .innerHTML als eine Art “Holzfäller-Methode” angesehen wird. JavaScript bietet hierfür bereits eine elegantere Möglichkeit, die aber oft viel zu umständlich ist. Bitte schaue dir diese trotzdem kurz an: https://www.w3schools.com/js/js_htmldom_nodes.asp\n","categories":"","description":"Die Website mit Hilfe von JavaScript verändern.\n","excerpt":"Die Website mit Hilfe von JavaScript verändern.\n","ref":"/docs/web/javascript/03_js_dom_manipulation/","tags":"","title":"Mit JavaScript das DOM verändern"},{"body":"Erklärung zum vorherigen Beispiel Im vorherigen Beispiel hatten wir diesen Code:\n1 2 3 4 5 6  \u003ch1\u003eKleiner Witz\u003c/h1\u003e \u003cp\u003eWie viele Softwareentwickler braucht man, um eine Glühbirne auszuwechseln?\u003c/p\u003e \u003cp\u003eKeinen, das ist ein Hardware-Problem!\u003c/p\u003e   Du hast gesehen, dass es das zwischen \u003ch1\u003e und \u003c/h1\u003e wie ein Titel formatiert wurde. Der Text zwischen \u003cp\u003e und \u003c/p\u003e in eigenen Abschnitten dargestellt.\nHTML Tags Du hast schon die ersten “HTML Tags” kennengelernt: \u003ch1\u003e und \u003cp\u003e. \u003ch1\u003e wird für Titel und \u003cp\u003e wird für Paragrafen verwendet.\nHTML Tags sind wie Keywords (Schlüsselbegriffe), die beschreiben, wie der Browser deren Inhalt (Content) formatiert bzw. darstellt.\nDie Tags inklusiv deren Inhalt nennen wir “Element”. Das Element ist wie folgt aufgebaut:\nJedes Element beginnt mit einem “Opening Tag”. Zwischen diesem und dem Closing Tag befindet sich der Content, der auf Grundlage des Tags formatiert wird. Der Content wird oft “InnerText” oder “InnerHtml” genannt. Das Closing Tag hat immer vor dem Tag-Namen ein “/”, das symbolisiert, dass es sich um ein Closing Tag handelt.\nIm Opening Tag können Attribute vorkommen, die den Tag “konfigurieren”. Eine solche Konfiguration beinhaltet in den meisten Fällen ein Attribut-Key und -Value, welche mit einem Gleichzeichen verbunden werden. Der Attribut-Value (Wert) beginnt und endet IN JEDEM FALL mit einem Anführungs- bzw. Schlusszeichen, auch wenn der Wert eine Zahl oder true bzw. false ist.\n","categories":"","description":"Die wichtigsten Grundlagen zu HTML.\n","excerpt":"Die wichtigsten Grundlagen zu HTML.\n","ref":"/docs/web/html_css/03_html_basics/","tags":"","title":"Basics zu HTML"},{"body":"Architektur Angular wird für Frontend-Applikationen verwendet. Oft wird ein Backend via HTTP(s) angebunden. Angular Data Bindings Interpolation  Anhand von diesem One-Way Binding kann man Properties des Components im Template anzeigen.\nWenn sich das Property im Component ändert, wird das Template aktualisiert, um die neuen Änderungen anzuzeigen.  Property Binding  Anhand von Property Bindings können wir einen Wert unseres Components auf eine Eigenschaft eines Elements binden.\nWenn sich also der bestimme Wert im Component verändern sollte, wird dies im Template aktualisiert.  Event Binding  Event Binding ist definiert als das Aktualisieren/Senden des Werts/der Information einer bestimmten Variablen vom Template zum Component.\nZum Beispiel das Klicken eines Buttons.  Two-Way-Binding  Two-Way-Binding ist eine Kombination aus Property- und Eventbinding. Daten werden kontinuierlich synchronisiert: vom Template zum Component und vom Component zum Template.\nDies bedeutet also, dass Änderungen, die an den Daten des Components vorgenommen wurden, werden mit dem Template synchronisiert und sofort aktualisiert.\nUmgekehrt funktioniert es auf dieselbe Weise, daher auch der Name “Two-Way-Binding”.  Aufgabe 1 Folgender Code ist gegeben:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  class Fahrrad{ name?: string; url?: string; } import { HttpClient } from '@angular/common/http'; import { Component, OnInit } from '@angular/core'; @Component({ selector: 'app-fahrrad', templateUrl: './fahrrad.component.html', styleUrls: ['./fahrrad.component.scss'] }) export class FahrradComponent implements OnInit { fahrrad: Fahrrad; liebslingsFahrraeder:any = []; constructor(protected httpClient: HttpClient) { this.fahrrad = new Fahrrad(); this.fahrrad.name = \"Specialized Diverge Pro Carbon\"; this.fahrrad.url = \"https://assets.specialized.com/i/specialized/96220-10_DIVERGE-PRO-CARBON-ETAP-REDWD-SMK-CHRM_HERO?bg=rgb(241,241,241)\u0026w=2500\u0026h=1406\u0026fmt=auto\" } ngOnInit(): void { } nameDesFahrrads(){ alert(this.fahrrad.name); } bildLiebslingsFahrrad(){ this.liebslingsFahrraeder = []; let url = \"https://www.googleapis.com/customsearch/v1?key=AIzaSyDNGfS6NUdgwXOwKu9xlZPJFm84ylG6J4g\u0026cx=005124428384360536924:rstfldysumw\u0026q=\" + this.fahrrad.name + \"\u0026searchType=image\u0026safe=high\"; this.httpClient.get(url).subscribe((response:any) =\u003e{ for (var i = 0; i \u003c 4; i++) { var item = response.items[i]; item.image.height = 200 / item.image.width * item.image.height; item.image.width = 200; this.liebslingsFahrraeder.push(item); } }); } }   Folgendes muss angezeigt werden, wenn die Seite geladen wurde:\n “Wie heisst mein Fahrrad?” ist mit der Funktion “nameDesFahrrads()” verknüpft. “Mein Liebslingsfahrrad suchen” ist mit der Funktion “bildLiebslingsFahrrad()” verknüpft. Für die Anzeige der Lieblingsfahrräder muss ein *ngFor gebraucht werden. Tipp: Die Weite und Höhe der Bilder kann direkt mit einem Propertybinding gemacht werden.  Folgende Seite wird nach dem Klick auf “Mein Lieblingsfahrrad suchen” angezeigt:\n","categories":"","description":"Angular ist ein Framework um SPA’s (Single Page Applications) mittels HTML und JavaScript zu erstellen und besteht aus verschiedenen core und optionalen JavaScript Bibliotheken\n","excerpt":"Angular ist ein Framework um SPA’s (Single Page Applications) mittels …","ref":"/docs/web/angular/04_1_einf%C3%BChrung_angular/","tags":"","title":"Einführung Angular"},{"body":"Einführung Javascript ist eine interpretierte (nicht kompilierte) “cross-platform” Sprache. Sie kann Client- wie auch Server-seitig eingesetzt werden.\n","categories":"","description":"Die Programmiersprache jedes Browsers kennenlernen.\n","excerpt":"Die Programmiersprache jedes Browsers kennenlernen.\n","ref":"/docs/web/javascript/","tags":"","title":"JavaScript"},{"body":"Hallo Ninja! 🥷\nEs freut uns das du git kennen lernen willst!\nWir haben hier ein Lab für dich zusammengestellt damit du in dieses Thema eintauchen kannst. Finde für dich heraus warum git eine Zeitmaschine ist und was es mit den Paralleluniversen auf sich hat.\nZiele Du kannst …\n git konfigurieren Repositories auschecken Branches erstellen und auschecken Commits erstellen und klare Commit Messages formulieren Änderungen vom Server pullen Merge-/Pullrequests erstellen (z.B. auf Github, Bitbucket, Gitlab) Änderungen anhand der Git History nachvollziehen Mergen und Rebasen von Branches  Vielleicht sogar …\n Commits squashen Tags erstellen und pushen Aliasse einrichten Blame anwenden  Schwerpunkte Dieses Lab unterteilt sich in folgende Themenbereiche:\n Was ist dieses Git? Git installieren Git Basics Git Branches GitHub Git Erweitert  Let’s play! Meisterst du diese Challenges?\n oh my git! learn git branching git immersion  Voraussetzungen  git installiert  ","categories":"","description":"Verteilte Versionsverwaltung mit Git","excerpt":"Verteilte Versionsverwaltung mit Git","ref":"/docs/git/","tags":"","title":"Git"},{"body":"Exam 2 - Angular - Einzelarbeit\nAusgangslage In deinem Unternehmen werden die Arbeitszeiten immer noch im Excel erfasst. Dein Linienvorgesetzter ist mit diesem Excel-File nicht mehr so zufrieden. Er verlangt von dir, dass du ein Angular-Projekt realisieren sollst, welches das aktuelle Excel-File ablöst. Designtechnisch ist alles dir überlassen. Du kannst entweder mit einem lokalen Projekt arbeiten oder eine Backendschnittstelle basteln.\nAnforderungen Funktionale Anforderungen Dein Linienvorgesetzter gibt dir folgende funktionale Anforderungen für das Arbeitszeitprogramm:\n Die Mittagszeit von 30 Minuten muss gemacht werden. Sofern über 9h gearbeitet wird, muss mindestens 1h Mittagspause gemacht werden. Man kann entweder von Hand oder mit Hilfe eines QR-Codes ein- und ausstempeln. Es gibt drei Rollen: Admin, Vorgesetzter und Mitarbeiter.\nDer Admin kann neue Mitglieder (Admin, Vorgesetzter, Mitarbeiter) hinzufügen und den Vorgesetzten zuweisen. Sieht aber keine Zeitaufschreibung ausser die eigene. Der Vorgesetzte sieht die eigene Zeit, wieauch die Zeit seiner Mitarbeiter. Der Mitarbeiter sieht nur seine eigene Zeit. Der Admin kann neue Auftragszeiten (Projekt X, Projekt Y, Daily Business, etc.) hinzufügen, welche von allen Mitarbeitern gewählt werden können. Jedes Mitglied muss bei der Zeitaufschreibung ein Auftrag wählen, wo er gerade arbeitet. Diese Projekte können favorisiert werden, damit man sie nicht jedes Mal wählen muss. Jedes Mitglied kann zudem diverse Zeitcodes anwenden, welche vom Admin hinzugefügt werden. Das sind beispielsweise: Krank, Kompensation, Berufsschule, Ferien,etc. Man kann die Zeiten im späteren Verlauf noch ändern. Hierzu werden aber alle geänderten Zeiten (Datum bearbeitung, etc.) angezeigt. Jedes Mitglied kann sein Passwort (und Profilbild) ändern. Der Admin kann die Daten jedes Mitglieds ändern(Nachname, Vorname, Abteilung, etc.) oder löschen.  Nicht-funktionale Anforderungen  Das System muss innerhalb von 100ms die Daten liefern. IT-Sicherheit: Das System bockiert nach drei Fehlrversuchen die Anmeldung. Abfragen können nur mit einem JWT ausgeführt werden.  Daten Mitglieder-Daten Die Mitglieder bestehen aus folgenden Werten:\n Nachname Vorname Passwort(muss bei der ersten Anmeldung geändert werden) Abteilung Arbeitszeit(bspw. 100% oder 8h) Rolle (nicht zwingend Profilbild)  Zeit-Daten Die Zeit besteht aus folgenden Werten:\n Von Bis Datum  Auftragszeit-Daten Die Auftragszeit besteht aus folgenden Werten:\n Auftragsnummer Text  Zeitcodes-Daten Die Zeitcodes besteht aus folgenden Werten:\n Nummer Beschreibung  - Hinweis:\nBeziehungen zwischen Daten nicht vergessen.\nBei Fragen ungeniert melden.\n","categories":"","description":"Einfache Aufgaben zu den Basics von Angular.\n","excerpt":"Einfache Aufgaben zu den Basics von Angular.\n","ref":"/exams/web/angular/07_2_exam_angular/","tags":"","title":"Exam zu den Angular-Basics"},{"body":"Git kann auf unterschiedliche Arten eingesetzt werden, es gibt graphische Oberflächen und die meisten Git-Server Software bieten Weboberflächen, welche das interagieren mit Git Repositories kinderleicht gestalten. Da diese Oberflächen meist sehr Produktspezifisch sind und oft auch nicht alle Funktionen beinhaltet werden hier nur die Kommandozeilen Befehle angeschaut. Ausserdem empfiehlt es sich mit git auf der Kommandozeile zu starten da es so viel verständlicher ist.\nInhalt  Konfiguration von Git Hilfe Ein Git Repository anlegen Änderungen verfolgen und im Repository speichern Anzeigen der Commit Historie Änderungen rückgängig machen Mit Remotes arbeiten  Konfiguration von Git Git kann, wie die viele Software unter Linux, auf unterschiedlichen Level konfiguriert werden:\n /etc/gitconfig enthält die Werte, welche für alle Benutzer auf dem System gelten. Die Datei kann mit git config --system gelesen oder editiert werden. Man braucht Administrator- oder Superuser-Rechte um die Datei zu editieren. ~/.gitconfig oder ~/.config/git/config enthält die Werte, welche für den aktuellen Benutzer konfiguriert sind. Mit git config --global können Werte gesetzt oder ausgelesen werden. Die Datei config im .git Verzeichnis innerhalb eines Repositories enthält die Konfiguration, welche nur für dieses Repository zählt. Das Flag für git config ist in diesem Fall --local, ist jedoch in der Regel die Standardoption und kann weggelassen werden.  Jede dieser Konfiguration wird von der nächsten überschrieben, sodass die Repository bezogene Konfiguration den höchsten Wert hat. Um zu die aktuelle Konfiguration und ihren Ursprung anzusehen kann folgender Befehl ausgeführt werden:\n1 2 3 4 5 6 7 8 9 10 11 12 13  $ git config --list --show-origin file:/home/lehrling/.gitconfig user.email=lehrling@puzzle.ch file:/home/lehrling/.gitconfig user.name=Lehrling Puzzle file:/home/lehrling/.gitconfig push.default=simple file:/home/lehrling/.gitconfig merge.tool=meld file:.git/config core.repositoryformatversion=0 file:.git/config core.filemode=true file:.git/config core.bare=false file:.git/config core.logallrefupdates=true file:.git/config remote.origin.url=git@github.com:puzzle-bbt/training-sbb-puzzle.git file:.git/config remote.origin.fetch=+refs/heads/*:refs/remotes/origin/* file:.git/config branch.master.remote=origin file:.git/config branch.master.merge=refs/heads/master   Konfigurationsbeispiele Nach der Installation von Git sollte als erstes der Name und die Email Adresse konfiguriert werden, da diese beiden Angaben bei jedem Commit benötigt werden:\n1 2  $ git config --global user.name \"John Doe\" $ git config --global user.email johndoe@example.com   Wie wir bereits gelernt haben, schreiben wir mit dem --global Flag in die Konfiguration in unserem home Verzeichnis und sie gilt somit für alle Repositories, welche wir mit unserem User bearbeiten. Wollen wir dies fur ein bestimmtes Repo übersteuern, haben wir immer noch die Möglichkeit dies mit --local zu machen.\nEine weitere Konfiguration die evtl. hilfreich sein kann ist core.editor mit welcher, der Texteditor definiert werden kann. Git benutzt, falls hier nichts definiert ist, den standard Editor des Systems.\nHilfe Git bietet mehrere Möglichkeit, wie man an Hilfe gelangt, wenn mal einmal nicht weiter weiss:\n1 2 3 4 5  $ git help \u003cverb\u003e $ git \u003cverb\u003e --help $ man git-\u003cverb\u003e # Kurzversion: $ git \u003cverb\u003e -h   Wenn man also nicht mehr genau weiss, wie dies mit der Konfiguration von Git funktioniert kann man sich folgendermassen weiterhelfen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  $ git help config #ruft die Manpage auf [..] $ git config -h usage: git config [\u003coptions\u003e] Config file location --global use global config file --system use system config file --local use repository config file --worktree use per-worktree config file -f, --file \u003cfile\u003e use given config file --blob \u003cblob-id\u003e read config from given blob object Action --get get value: name [value-regex] --get-all get all values: key [value-regex] --get-regexp get values for regexp: name-regex [value-regex] --get-urlmatch get value specific for the URL: section[.var] URL --replace-all replace all matching variables: name value [value_regex] --add add a new variable: name value --unset remove a variable: name [value-regex] --unset-all remove all matches: name [value-regex] --rename-section rename section: old-name new-name --remove-section remove a section: name -l, --list list all -e, --edit open an editor --get-color find the color configured: slot [default] --get-colorbool find the color setting: slot [stdout-is-tty] Type -t, --type \u003c\u003e value is given this type --bool value is \"true\" or \"false\" --int value is decimal number --bool-or-int value is --bool or --int --path value is a path (file or directory name) --expiry-date value is an expiry date Other -z, --null terminate values with NUL byte --name-only show variable names only --includes respect include directives on lookup --show-origin show origin of config (file, standard input, blob, command line) --show-scope show scope of config (worktree, local, global, system, command) --default \u003cvalue\u003e with --get, use default value when missing entry   Ein Git Repository anlegen Um lokal ein neues Git Repository anzulegen gibt es zwei Varianten:\n Umwandeln eines Verzeichnis, welches (noch) nicht mit Git verwaltet wird zu einem Git Repository Klonen eines existierenden Repositories von einem anderen Ort  Ein Verzeichnis zu einem Git Repository verwandeln Um aus einem Ordner ein Git Repository zu erstellen, muss man zuerst in den Ordner wechseln und anschliessend das Repository initialisieren:\n1 2  $ cd ~/path/to/folder $ git init   Der zweite Befehl erzeugt ein .git Unterverzeichnis, welches die Repository Daten beinhaltet. Im Moment werden noch keine Dateien von Git verwaltet, sondern die müssen zuerst hinzugefügt (git add) werden und committed werden (git commit). Wenn wir von einem leeren Ordner aus gehen, müssen die Dateien natürlich zuerst noch erstellt werden:\n1 2 3  $ vim README.md $ git add README.md $ git commit -m 'Initial Commit'   Ein bestehendes Repository klonen Um ein Repository zu klonen wird der Befehl git clone verwendet:\n1 2 3  $ git clone https://github.com/libgit2/libgit2 $ ls libgit2   Git legt dann automatisch ein Verzeichnis libgit2 an mit allen Dateien und initialisiert das Repository mit einem .git Verzeichnis im Hauptverzeichnis. Wird hinter der URL noch etwas angegeben, wird dies als Name des Zielverzeichnisses interpretiert:\n1 2 3  $ git clone https://github.com/libgit2/libgit2 mylibgit $ ls mylibgit   Änderungen verfolgen und im Repository speichern Zur Erinnerung, eine Datei in einem Git Folder kann vier Zustände haben:\n Untracked: Die Datei liegt im Ordner, wird aber nicht von Git versioniert Unmodified: Die Datei wird von Git versioniert, sie ist seit dem letzten Commit unverändert. Modified: Die Datei wurde seit dem letzten Commit verändert Staged: eine neue oder editierte Datei wurde für den nächsten Commit vorgemerkt.  Der Befehl zum überprüfen, ob man Dateien in einem anderen Zustand als unmodified hat ist git status:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  $ git status On branch feature/git-basics Your branch is up to date with 'origin/feature/git-basics'. Changes to be committed: (use \"git restore --staged \u003cfile\u003e...\" to unstage) modified: content/en/docs/02.0/02.md Changes not staged for commit: (use \"git add \u003cfile\u003e...\" to update what will be committed) (use \"git restore \u003cfile\u003e...\" to discard changes in working directory) modified: content/en/docs/02.0/02.md Untracked files: (use \"git add \u003cfile\u003e...\" to include in what will be committed) .gitignore   Wollen wir nun die Änderungen der Datei content/en/docs/02.0/02.md (oder die Datei .gitignore) zum nächsten Commit hinzufügen können wir dies mit git add \u003cpfad/zur/datei\u003e. Im Beispiel oben sehen wir, dass die Datei content/en/docs/02.0/02.md bereits gestaged ist. Ändern wir diese Datei erneut, wird die Datei sowohl bei Changes to be committed: wie auch bei Changes not staged for commit: auftauchen. Einmal mit den Änderungen, welche wir bereits gestaged haben und einmal mit den Änderungen, welche wir nach dem Stagen (git add) gemacht haben. Wollen wir beide Änderungen im gleichen Commit, können wir die Datei einfach wieder mit git add stagen und anschliessend commiten, wollen wir die Änderungen in separaten Commit, commiten wir zuerst die gestagten Änderungen und stagen anschliessend die zweite Änderungen und commiten erneut.\n.gitignore Bevor wir lernen, wie man seine Änderungen commited wollen wir noch kurz die spezielle Datei .gitignore anschauen. In dieser Datei können Dateien erfasst werden, welche Git nicht als untracked aufzählen soll, respektive ignorieren soll. Die Datei wird ganz normal wie jede andere auch ins Repo eingecheckt.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  $ cat .gitignore # ignore all .a files *.a # but do track lib.a, even though you're ignoring .a files above !lib.a # only ignore the TODO file in the current directory, not subdir/TODO /TODO # ignore all files in any directory named build build/ # ignore doc/notes.txt, but not doc/server/arch.txt doc/*.txt # ignore all .pdf files in the doc/ directory and any of its subdirectories doc/**/*.pdf   Weitere Informationen bekommt man mit man gitignore oder unter https://github.com/github/gitignore findet man nützliche Beispiele.\nÜberprüfen der Änderungen Bevor man seine Änderungen commited, empfiehlt es sich diese nochmals zu überprüfen. Mit git status sieht man, welche Dateien geändert wurden, jedoch nicht, was sich geändert hat. Dafür gibt es den Befehl git diff:\n1 2 3 4 5 6 7 8 9 10  diff --git a/content/en/docs/02.0/02.md b/content/en/docs/02.0/02.md index 1e6db46..dd7161b 100644 --- a/content/en/docs/02.0/02.md +++ b/content/en/docs/02.0/02.md @@ -145,3 +145,60 @@ mylibgit  ## Änderungen verfolgen und im Repository speichern +Zur Erinnerung, eine Datei in einem Git Folder kann vier Zustände haben: -Zur Erinnerung, eine Datei in einem Git Folder kann vier Zustaende haben   git diff vergleicht die Änderungen welche noch nicht gestaged wurden, will man bereits gestagte Änderungen überprüfen braucht es zusätzlich das Flag --staged oder --cached (die beiden Flags sind Synonyme).\nAnders als git diff funktioniert git diff-tool mit einem externen Tool, welches dir die Änderungen anzeigt. Beispiele dafür sind ‘P4Merge’ oder auch ‘Beyond Compare’. Sie versuchen die Bearbeitungen besser zu visualisieren und es dem Benutzer einfacher zu machen, diese in einer Datei / im Code einzusehen. Jetzt bleibt die Frage: Wann brauchen wir was? Grundsätzlich wird git diff bei folgenden Situationen gebraucht:\n Wenn wir kein GUI haben und nur mit dem Output des Terminals arbeiten Falls wir gar kein externes Tool zur Verfügung haben Wenn du keine ‘schweren’ externen Tools starten möchtest, sondern so schnell wie möglich zum Ergebnis kommen willst.  git diff-tool kann man dann überall dort einsetzen, bei denen die oben erwähnten Situationen nicht zutreffen. Zu Beachten ist aber, dass es noch viele weitere Situationen gibt, in welchen man auf git diff-tool verzichten kann. Zur genaueren Einsicht ist Googel immer eine gute Anhaltestelle.\nCommiten Ist man sicher, dass man nur die Änderungen gestaged hat, welche man auch commiten will, kann man dies mit dem Befehl git commit bewerkstelligen. Dadurch wird ein Editor geöffnet und man wird gebeten eine Beschreibung für die Änderungen anzugeben. Wie solche Beschreibungen gestaltet werden sollen und was alles in eine “Commit Message” gehört, darüber gibt es ganz unterschiedliche Meinungen. Idealerweise probiert man sich vorzustellen, was man an Zusätzlichen Informationen braucht, wenn man die Änderungen in zwei Jahren wieder anschaut, um zu verstehen, was und warum das geändert wurde.\nOft gibt es pro Projekt Konventionen wie eine Commit Message aussehen soll. Falls dies nicht existiert gibt es ein paar wenige Punkte welche die Messages einiges lesbarer und verständlicher machen:\n Sprache: Englisch Kurze und prägnante Message, idealerweise unter 50 Zeichen Details Mit Grossbuchstaben beginnen Details Kein Punkt am Schluss Details Den imperative mood (Befehlsform) verwenden, also «Fix bug with X» statt «Fixed bug with X» oder «More fixes for broken stuff» Details Wenn vorhanden das Ticket referenzieren:  Bei Gitlab/Github Issues: «Add X #12345»    (Puzzle Docs)\nWeitere Quellen dazu:\n https://chris.beams.io/posts/git-commit/ https://www.conventionalcommits.org/en/v1.0.0/  Ein paar hilfreiche Flags zu git commit:\n -m um eine Message gleich anzugeben und nicht den Editor zu öffnen (kann je nach Commit Message Guideline hinderlich sein, da es keine Multiline Kommentare erlaubt):  1 2 3 4  git commit -m \"Story 182: added important Information to Readme\" [master 463dc4f] Story 182: added important Information to Readme 2 files changed, 2 insertions(+) create mode 100644 README     -a um alle editierten Dateien gleich mitzustagen. (Kurzform von git add --all \u0026\u0026 git commit) !ACHTUNG! kann gefährlich sein da so schnell Änderungen in einen Commit rutschen die nicht rein gehören!\n  -v um ein git diff --staged im Editor angezeigt zu bekommen. So muss man sich nicht merken, was man eigentlich geändert hat und bekommt es beim schreiben der Commit Message noch einmal präsentiert.\n  WICHTIG: Es ist einiges einfacher Fehler vor dem Commiten als nach dem Commiten zu beheben, ein zweites mal über die Änderungen schauen ist sehr empfehlenswert!\nDateien löschen Um eine Datei zu löschen muss diese zuerst entfernt und dann gestaged werden, damit dies in der Git Datenbank ankommt. Um nicht zuerst rm foo und dann git add foo eingeben zu müssen, gibt es den Befehl git rm foo. Will man eine bereits gestagte Datei aus der Versionsverwaltung jedoch nicht vom Filesystem löschen, weil man diese zum Beispiel im .gitignore ergänzen möchte, dann kann man dies mit git rm --cached foo erledigen.\nWICHTIG: Jede Datei die irgendwann mal commited wurde ist für immer in der Git Geschichte und kann nur durch neu schreiben der selbigen wieder entfernt werden. Wer also zum Beispiel sein Passwort commited weil dies in einer secret.yml Datei steht, der sollte sich sofort bei einem 10x-Git-Profi-Engineer Hilfe holen.\nDateien Verschieben Genauso wie löschen, muss auch beim Verschieben die Änderung Git mitgeteilt werden: mv README.md README \u0026\u0026 git rm README.md \u0026\u0026 git add README oder in kurz und hübsch: git mv README.md README.\nAnzeigen der Commit Historie Um die Geschichte eines Git Repositories anzuzeigen gibt es den Befehl git log. Ohne Argumente zeigt git log die Commits in umgekehrter chronologischer Reihenfolge, sprich jüngster Commit zuoberst. Pro Commit wird jeweils der Commit-Hash, der Name und Email Adresse des Authors, das Datum und die Commit-Message angezeigt. Um die effektiven Änderungen anzuzeigen gibt es das -p oder --patch Flag verwendet werden. Da der Output schnell gross wird und man wahrscheinlich auch nicht bis an den Ursprung der Geschichte zurück will empfiehlt es sich die Anzahl Commits anzugeben, will man zum Beispiel die letzten drei Commits anschauen macht man dies mit -3. Oder man schränkt die Änderungen basierend auf die Zeit ein mit --since= und --until= ein (es werden die unterschiedlichsten Zeitangaben akzeptiert, am besten probiert man etwas aus. Bsp: --since=2.weeks oder --until=\"2020-06-03\"). Auch mit --grep oder --author kann man die Resultate einschränken. Weitere Information liefert die Manpage man git log und die Hilfefunktion git log -h.\nÄnderungen rückgängig machen Wo gehobelt wird fallen Späne. Die meisten Schnitzer kann man jedoch selber wieder ausglätten. Am häufigsten committed man wohl zu schnell, hat eine Datei vergessen dazuzufügen oder hat sich bei der Commit Message vertan. Hier kann man ganz einfach die Änderungen noch vornehmen und an den letzten Commit berichtigen mit git commit --amend (Wichtig, man editiert nicht den letzten Commit, sondern man löscht ihn und erstellt eine korrigierte neue Version davon. Dies kann dazuführen, dass ein Remote den Commit nicht mehr annimmt, da die History nicht mehr übereinstimmt. Aber mehr dazu später.)\nUm eine gestagte Datei wieder zu modified (aber eben nicht gestaged) zu verschieben kann man git reset HEAD \u003cfile\u003e verwenden. Um die Änderungen einer Datei rückgängig zu machen (also modified zu unmodified) kann sie neu ausgecheckt werden mit git checkout -- \u003cfile\u003e. Achtung Alle Änderungen seit dem letzte Commit gehen damit verloren!!! Wenn man sich an die beiden Befehle gerade mal nicht erinnern kann, dann kann man einfach ein git status eingeben und den Hilfetext studieren 😉.\nMit Remotes arbeiten Um mit anderen an einem Git-Projekt mitarbeiten zu können, braucht es Remotes, sprich eine Version des Projekts im Netzwerk, wo alle Beteiligten ihre Änderungen hin pushen und die Änderungen der Anderen pullen können.\nNachdem man ein Repo gecloned hat sieht man ein Remote, man kann jedoch auch weitere definieren:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  $ git clone git@github.com:puzzle-bbt/training-sbb-puzzle.git Cloning into 'training-sbb-puzzle'... remote: Enumerating objects: 8485, done. remote: Counting objects: 100% (8485/8485), done. remote: Compressing objects: 100% (5276/5276), done. remote: Total 8485 (delta 3095), reused 8456 (delta 3079), pack-reused 0 Receiving objects: 100% (8485/8485), 17.06 MiB | 5.11 MiB/s, done. Resolving deltas: 100% (3095/3095), done. $ cd training-sbb-puzzle $ git remote origin $ git remote -v origin\tgit@github.com:puzzle-bbt/training-sbb-puzzle.git (fetch) origin\tgit@github.com:puzzle-bbt/training-sbb-puzzle.git (push) $ git remote add private git remote add private git@github.com:Lehrling/training-sbb-puzzle.git $ git remote -v origin\tgit@github.com:puzzle-bbt/training-sbb-puzzle.git (fetch) origin\tgit@github.com:puzzle-bbt/training-sbb-puzzle.git (push) private\tgit@github.com:Lehrling/training-sbb-puzzle.git (fetch) private\tgit@github.com:Lehrling/training-sbb-puzzle.git (push)   Wollen wir nun alle Information holen, welches der Lehrling hat, jedoch noch nicht im Repo sind kann man dies mit git fetch private ausführen.\nFetching und Pulling Es gibt zwei Arten, wie man Daten von einem Remote abholen kann, nach dem man das Repo gecloned hat.\n  git fetch \u003cremote\u003e: holt alle Änderungen vom Remote seit dem letzten abholen und speichert die lokal. Wichtig zu beachten ist, dass git fetch die Änderungen nicht mit den lokalen Änderungen zusammenfügt, sondern dies manuell ausgeführt werden muss.\n  git pull: Wenn der lokale Branch mit einem remote Branch verknüpft ist, holt git pull die Änderungen dieses remotes und fügt sie gleich mit den Änderungen im lokalen Branch zusammen (merge). Was Branches sind und wie ein Merge funktioniert schauen wir uns in kürze an, nur soviel, wird ein Repo gecloned, wird der lokale sogenannte master Branch mit dem master Branch des origin Remotes verknüpft.\n  Pushen Wenn man seine Änderungen soweit hat, dass man sie mit dem Rest vom Team teilen will, dann kann man diese mit git push \u003cremote\u003e \u003cbranch\u003e auf den Server laden. Dies funktioniert jedoch nur, wenn man auf dem Server auch Schreibrechte hat und niemand anderes vor einem gepusht hat.\n","categories":"","description":"","excerpt":"Git kann auf unterschiedliche Arten eingesetzt werden, es gibt …","ref":"/docs/git/git-basics/","tags":"","title":"Git Basics"},{"body":"java.util.Set Eine Set verwendet man, um eine Menge von Elemente zu speichern. Dabei werden keine Duplikate gespeichert. Die java.util.HashSet ist die gebräuchlichste Implementierung eines Sets. Man könnte zum Beispiel in einem Set alle Wörter eines Texts speichern. Tritt ein Wort mehrmals auf, so wird dieses Wort nur bei ersten Male gespeichert. Im Set sind so alle auftretenden Wörter gespeichert und die size() Methode liefert die Anzahl unterschiedlicher Wörter zurück.\nEin Set hat keine Duplikate!  Dabei ist der Schlüssel immer eindeutig. Speichert man zwei Zuweisungen mit dem gleichen Schlüssel, so wird die erste Zuweisung überschrieben.\nDie Benennung eines Sets sollte der Inhalt beschreiben.\nZum Beispiel:\n nameSet –\u003e ein Set mit Namen names –\u003e mehrere Namen  Methodenübersicht 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  Set\u003cString\u003e nameSet = new HashSet\u003c\u003e(); nameSet.add(\"Peter\"); nameSet.add(\"Anna\"); nameSet.add(\"Kurt\"); nameSet.add(\"Anna\"); nameSet.add(\"Petra\"); System.out.println(nameSet.size()); // Output: 4 System.out.println(nameSet.contains(\"Peter\")); // Output: true System.out.println(nameSet.remove(\"Emil\")); // Output: false System.out.println(nameSet.remove(\"Anna\")); // Output: true System.out.println(nameSet.size()); // Output: 3 nameSet.clear(); System.out.println(nameSet.isEmpty()); // Output: true    Die Elemente eines Set kann man mit den Collection Methoden abrufen:\n iterator(): Ein Iterator über die Elemente stream(): Ein sequentieller Stream über die Elemente forEach(): Führt eine bestimmte Aktion über alle Elemente aus  Die Reihenfolge der Elemente ist nicht garantiert. Es existieren Implementierung wie das SortedSet, welche eine bestimmte Reihenfolge sicherstellt.\n Beispiel    Beispiel Für die Beispiele verwenden wir die folgende initialisierte HashMap:\n1 2 3 4 5 6 7  Set\u003cString\u003e nameSet = new HashSet\u003c\u003e(); nameSet.add(\"Peter\"); nameSet.add(\"Anna\"); nameSet.add(\"Kurt\"); nameSet.add(\"Anna\"); nameSet.add(\"Petra\");   Beispiel 1 - Set erstellen 1 2 3 4 5 6 7 8 9  // mit Konstruktor Set\u003cString\u003e nameSet = new HashSet\u003c\u003e(); nameSet.add(\"Peter\"); nameSet.add(\"Emil\"); // mit statischer of() Methode Set\u003cString\u003e nameSet = Set.of(\"Peter\", \"Emil\"); // of() liefert ein unmodifizierbares Set zurück. Kein HashSet!    Beispiel 2 - Auslesen der Elemente 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // Abfrage der Elemente mit einem Iterator: Iterator\u003cString\u003e iterator = nameSet.iterator(); while(iterator.hasNext()) { System.out.println(iterator.next()); } // Abfrage der Elemente mit einer for Schleife: for (String name : nameSet){ System.out.println(name); } // Abfrage der Elemente mit einem Stream: nameSet.stream().forEach(name -\u003e System.out.println(name)); // Abfrage der Elemente mit einem forEach: nameSet.forEach(name -\u003e System.out.println(name));     Aufgaben    Aufgaben Aufgaben zu Modul #J7 - Java Collections - Set\n","categories":"","description":"Die gebräuchlichste Umsetzung eines Set: HashSet.\n","excerpt":"Die gebräuchlichste Umsetzung eines Set: HashSet.\n","ref":"/docs/java/java-collections/03_set/","tags":"","title":"HashSet"},{"body":"","categories":"","description":"Exercises zu Modul #J2 - Lists Basics\n","excerpt":"Exercises zu Modul #J2 - Lists Basics\n","ref":"/labs/java/java-lists-and-streams-basics/","tags":"","title":"Java Exercises - List und Streams Basics"},{"body":"Ziele  Ich weiss, was eine Klasse ist Ich weiss, was Variablen und Datentypen sind Ich kenne die primitiven Datentypen in Java: boolean, byte, short, int, long, double, float, char Ich kenne die Klasse String Ich kenne Arrays und kann diese instanzieren, ihnen Werte von Indexen entnehmen und Werte an Indexe zuweisen Ich kann eine Variable deklarieren und initialisieren Ich kenne den Unterschied zwischen statischen und nicht statischen Elementen Ich weiss, wann ich das Schlüsselwort static verwenden sollte und wann nicht Ich kenne den Zugriff auf statische und nicht statische Elemente Ich weiss, was eine statische Methode ist und kann sie aufrufen Ich weiss, was eine Utility-Klasse ist und kenne deren wichtigste Bestandteile Ich verstehe den Unterschied zwischen Methoden mit und ohne Rückgabewert Ich kann eine Methodensignatur für Methoden mit und ohne Rückgabewert richtig schreiben Ich kann Methoden schreiben, die Parameter entgegennehmen Ich weiss, dass jede Anweisung mit einem Strichpunkt abgeschlossen werden muss Ich weiss, dass geschweifte Klammern einen Block definieren und ich verwende sie in jeder Kontrollstruktur, um die Code-Blocks voneinander abzugrenzen (lieber zu viel klammern als zu wenig) Ich kenne die Main-Methode und weiß, warum eine Applikation nur EINE Main-Methode haben sollte Ich kenne die Methode ‘System.out.println’ und kann sie anwenden Ich kann eine Eingabe von der Konsole lesen und in einer Variablen speichern Ich kann arithmetische Ausdrücke schreiben: Addition, Subtraktion, Multiplikation, Division, Modulo (Rest einer Division) Ich kenne die relationalen Operatoren: ==, \u003e=, \u003c=, \u003e, \u003c, != Ich kenne die booleschen Operatoren: \u0026\u0026 (AND), || (OR), ! (NOT), ^(XOR) Ich weiß, was eine bedingte Anweisung ist und kann sie korrekt anwenden Ich kann eine Schleife programmieren: for, foreach, while und do-while Ich kenne die switch-Anweisung  Cheatsheet zum Herunterladen Core Java Cheatsheet\n Einführung Was ist Java? Java ist eine objektorientierte Programmiersprache, die schon seit ca. zwei Jahrzehnten große Popularität genießt. Die Entwicklung von Java begann Anfang der 1990er-Jahre beim US-amerikanischen Hard- und Softwarehersteller Sun Microsystems. 1995 wurde die erste Version veröffentlicht. 2010 wurde Sun Microsystems von Oracle übernommen. Gegenwärtig erscheinen im Halbjahrestakt neue Java-Versionen; die neuste Version, Java 17, wurde im September 2022 veröffentlicht.\n Wichtigste Merkmale von Java Plattformunabhängigkeit: «Write once, Run anywhere» Der Compiler wandelt den Quellcode in Bytecode um (Kompilat) und anschliessend führt die Java Virtual Machine (JVM) den Bytecode aus. Jedes Betriebssystem hat eine andere JVM, aber jede JVM kann den Bytecode ausführen, daher kann ein- und dieselbe Java-Anwendung auf Windows, Linux, Mac OS und anderen Plattformen lauffähig sein.\nMehrfach-Paradigma Java ist in erster Linie eine objektorientierte und imperative Programmiersprache, bei der fast alles ein Objekt einer Klasse (eines Typs) ist. Wir können ein typisches Java-Programm als eine Menge von interagierenden Objekten betrachten. Die Objekte können Entitäten aus der realen Welt oder eine Art von Programmierabstraktionen darstellen. Wenn wir ein Programm schreiben, erklären wir, wie die Objekte miteinander interagieren sollen. Java unterstützt aber auch andere Programmierparadigmen, darunter generische Programmierung, parallele Programmierung, funktionale Programmierung (teilweise unterstützt) und andere.\nAusführbarer Bytecode Eine kompilierte Klasse, welche bestimmte Voraussetzungen erfüllt (dazu später), kann eigenständig ausgeführt werden. Applikationen und Klassenbibliotheken bestehen oft aus mehreren Klassen und werden als Java Archive (JAR-Datei genannt) verpackt, verteilt und bereitgestellt. Eine JAR-Datei ist technisch gesehen eine komprimierte Datei in ZIP-Format und kann auch so erstellt werden, dass sie von der JVM ausgeführt werden kann.\nKlassenpfad Um den Bytecode ausführen zu können, muss die JVM wissen wo sich dieser befindet. Damit die JVM nicht überall suchen muss, wird mit einem Klassenpfad (Classpath) angegeben, wo sie nach dem Bytecode suchen soll. Der Klassenpfad besteht aus einer Liste von Ordnern und .jar Dateien (sog. Java-Archive) und kann entweder als Parameter bei der Ausführung des Programms oder als eine Umgebungsvariable angegeben werden.\nGarbage Collector Der Garbage Collector (Teil der JVM) führt zur Laufzeit eine automatische Speicherbereinigung von unbenutzten Objekten durch. Der Entwickler muss sich also nicht um das Aufräumen von unbenutzen Objekten kümmern.\nMultithreading Java unterstützt Multithreading auf der Ebene der Sprache und der Standardbibliothek. Es ermöglicht die gleichzeitige und parallele Ausführung mehrerer Teile eines Java-Programms.\n Code, Compile, Run Ein/e Java-Entwickler/in schreibt ein Programm in eine Textdatei mit der Erweiterung .java. Ein Programm kann eine Vielzahl solcher Dateien enthalten. Dann übersetzt der Compiler (normalerweise javac) das Programm in eine .class-Datei, die den Bytecode des Programms enthält. Danach führt die JVM das Programm aus und gibt Low-Level-Befehle an den Computer. Der Computer ist hier eine Abstraktion, welche ein Server, ein PC oder sogar ein mobiles Gerät sein kann. Tatsächlich sind die Prozesse komplexer, als hier gezeigt wird. Es ist wichtig, Folgendes zu verstehen: Der Teil vor der JVM ist plattformunabhängig, der Teil nach der JVM ist plattformabhängig.  Terminologie    Begriff Beschreibung     Programm Eine Folge von Anweisungen (engl. “statement”), welche nacheinander ausgeführt werden (von oben nach unten)   Anweisung (statement) Eine einzelne Aktion, wie zum Beispiel das Ausgeben eines Satzes auf der Konsole. Ein Statement wird mit einem Semikolon abgeschlossen   Block Eine Gruppe von keiner, einer oder mehreren Anweisungen, die von geschweiften Klammern {…} umgeben ist   Methode Was in anderen Programmiersprachen als «Funktion» bezeichnet wird, heißt in Java «Methode». Eine Methode ist eine Folge von Anweisungen, welche eine bestimmte Aufgabe ausführt (auch bekannt als Unterprogramm oder Prozedur)   Syntax Eine Reihe von Regeln, die definieren wie ein Programm geschrieben werden muss, um gültig zu sein. Es handelt sich um eine Art Grammatik   Keyword Ein Wort, welches in der Programmiersprache eine besondere Bedeutung hat (public, class und viele andere). Diese Wörter können nicht als Variablennamen verwendet werden   Bezeichner (identifier) oder Name Ein Wort, das sich auf etwas in einem Programm bezieht (z. B. eine Variable oder einen Methodennamen)   Kommentar Eine Erklärung dazu, was eine bestimmte Anweisung oder Methode macht. Einzeilige Java-Kommentare beginnen mit // und mehrzeilige sind von den Zeichen /* */ umgeben   Whitespace Tabulator- oder Leerzeichen dienen lediglich der Lesbarkeit, vom Compiler werden sie ignoriert     Hello World Anhand des simplen Hello-World-Programms können wir bereits vieles über die zentralen Bestandteile einer Java-Anwendung erklären. Der folgende Sourcecode ist in einer Datei mit dem Namen HelloWorld.java abgelegt.\n1 2 3 4 5  public class HelloWorld { public static void main(String[] args) { System.out.println(\"Hello, world!\"); } }   Bei diesem Beispiel arbeiten wir uns nun von aussen nach innen vor. Der erste Teil definiert eine neue Klasse mit dem Namen HelloWorld. Die Deklaration der Klasse besteht aus dem Zugriffsmodifizierer public (dazu später mehr) gefolgt vom Keyword class und dem Klassennamen. Jede Java-Datei darf nur eine Klasse mit dem Zugriffsmodifizierer public enthalten, weitere Klassen ohne public sind jedoch erlaubt. Der Name der Klasse mit dem Modifizierer public muss stets mit dem Dateinamen übereinstimmen. Der Klassenname wird stets gross geschrieben, einzelne Wörter werden durch einen erneuten Grossbuchstaben getrennt. Dies wird CamelCase genannt. Der Block der Klasse wird durch geschweifte Klammern angegeben.\nInnerhalb der Klasse wird nun eine Main-Methode definiert. Diese Methode ist der Einstiegspunkt eines jeden Java-Programms. Nur über eine solche Methode kann eine Java-Anwendung gestartet werden. Die Methode besteht aus dem Zugriffsmodifizierer public, dem Keyword static, dem Rückgabewert void und dem Methodennamen main. An den Namen der Methode schliesst sich ein paar runde Klammern an. Innerhalb dieser Klammern befinden sich die Parameter der Methode, in diesem Fall handelt es sich um ein String-Array. Die Angabe der genannten Teile einer Methode nennt man Methodensignatur. Der Block der Methode wird durch geschweifte Klammern angegeben. Die Main-Methode hat immer die oben gezeigte Signatur.\nInnerhalb der Main-Methode sehen wir ein einzelnes Statement. Es besteht aus einer einfachen Anweisung, welche den Text “Hello, world!” auf die Kommandozeile ausgibt. Die statische Methode println() auf dem öffentlich zugänglichen Feld der Klasse System dient dazu Text auf der Konsole auszugeben. Das Statement wird mit einem Semikolon abgeschlossen.\n Variablen Namensgebung Variablen dienen dazu Werte aufzunehmen. Je nach Scope leben diese Variablen unterschiedlich lang. Zur Benennung von Variablen gibt es vier Regeln:\n Variablennamen beginnen mit einem Kleinbuchstaben Ein Variablenname darf die Buchstaben A-Z und a-z enthalten Ein Variablenname darf beliebige Zahlen von 0-9 enthalten Ein Variablenname darf die Sonderzeichen $ und _ enthalten  Best Practices Der Name einer Variable sollte so gewählt werden, dass klar ist, welcher Wert darin gespeichert wird. Als Beispiel wählen wir den Namen sum für eine Variable, welche das Resultat einer Addition enthält.\nDeklaration Unter der Deklaration einer Variable versteht man das erste “Erwähnen” einer Variable. In einer statisch typisierten Sprache wie Java bedeutet dies, dass der Typ der Variable festgelegt wird. Der Wert selbst muss bei der Deklaration je nach Scope nicht festgelegt werden. Zur Laufzeit wird für die Variable ein Bereich im Arbeitsspeicher reserviert. Hier werden später Werte, die der Variablen zugewiesen werden, gespeichert. Die Größe des Speicherbereichs hängt vom Typ der Variable ab.\nFormal gilt:\n1  \u003cvariable type\u003e \u003cvariable identifier\u003e;   Wir geben also den Datentyp und den Namen der Variable an.\nInitialisierung Unter dem Begriff Initialisierung wird die direkte Zuweisen eines Wertes bei der Deklaration einer Variablen verstanden. Lokale Variablen (Variablen, die lediglich innerhalb einer Methode gültig sind) müssen initialisiert werden, bevor sie verwendet werden können.\nBeispiel:\n1 2 3 4 5  public static void main(String[] args) { int firstSummand = 2; int secondSummand; int sum = firstSummand + secondSummand; }   Die Variable secondSummand wurde nicht initialisiert. Die Zuweisung int sum = firstSummand + secondSummand wird also nicht funktionieren.\nDeklaration mit Initialisierung Wir können eine Variable nacheinander deklarieren und dann initialisieren oder beides zusammen:\n1 2 3 4  int number; // 1. Deklaration number = 2; // 2. Initialisierung  int number = 2; // beides in einer Zeile   Formal:\n1  \u003cvariable type\u003e \u003cvariable identifier\u003e = \u003cinitial value\u003e;    Datentypen In Java sind Variablen stark typisiert. Das heisst, dass alle Variablen bei ihrer Erstellung mit einem Datentyp versehen werden müssen. Seit Java 10 gibt es Typinferenz für lokale Variablen, das heisst, eine lokale Variable kann deklariert und initialisiert werden (muss gleichzeitig geschehen), ohne dass ein Datentyp angegeben werden muss - anstelle des Datentyps kann var verwendet werden:\n1  var sum = 20;   Es gibt zwei Arten von Datentypen: Primitive Datentypen und Referenztypen. Der grundlegende Unterschied besteht darin, dass eine primitive Variable den tatsächlichen Wert speichert, während eine Referenzvariable die Adresse des Objekts speichert, auf welches sie sich bezieht. Dies hat mit dem Java Memory Modell zu tun. Das nachfolgende Bild zeigt das Java Memory Modell als einfache Darstellung, es besteht grundsätzlich aus dem Stack Memory und dem Heap Space. Primitive Datentypen werden nur auf dem Stack angelegt. Objekte, wie das im Bild gezeigte Auto (Car), sind im Heap abgelegt. Die Referenz auf das Objekt wird auf dem Stack angelegt. Die Referenz “zeigt” also auf das Objekt im Heap. Dieser fundamentale Unterschied ist relevant beim Vergleich von Werten und Referenzen. Der Operator für den Vergleich ==, vergleicht stets die Werte auf dem Stack miteinander. Bei Referenzen wird dort also überprüft, ob sie auf dasselbe Objekt zeigen. Wenn der Inhalt von Objekten verglichen werden soll, so muss dies mit der Methode equals gemacht werden.\n Primitive Datentypen Integraler Datentyp Integrale Datentypen sind immer ganze Zahlen, sie besitzen also keine Nachkommastellen. Die folgenden Datentypen speichern ganzzahlige Werte, sie unterscheiden sich nur in ihrer Grösse:\n   Datentyp Speicherbedarf Bereich     byte 8 Bit -128 … 127   short 16 Bit -32768 … 32767   int 32 Bit -2 147 483 648 … 2 147 483 647 (-2^31 … 2^31-1)   long 64 Bit -2^63 … 2^63-1    In den Werten von integralen Datentypen sind Underscores erlaubt, um die Lesbarkeit zu erhöhen (1_000_000).\nBeispiele:\n1 2  int count = 0; int million = 1_000_000;   Gleitkomma-Datentyp Gleitkomma-Datentypen speichern wie der Name bereits sagt, Zahlen mit Nachkommastellen. Diese Zahlen besitzen nur eine bestimmte Genauigkeit, sie dürfen also nicht als unendlich genau betrachtet werden. Die folgenden Datentypen speichern Zahlen mit Nachkommastellen, sie unterscheiden sich in ihrer Grösse und der Art und Weise wie sie innerhalb von Java abgelegt werden:\n   Datentyp Speicherbedarf Bereich Interne Ablage     float 32 Bit +/-1,4E-45 … +/-3,4E+38 Dezimalbruch   double 64 Bit +/-4,9E-324 … +/-1,7E+308 Gleitkommazahl    Beispiele:\n1 2  float radius = 8.5f; double area = 16.48739d;   Trotz Nachkommastellen dürfen Fliesskommzahlen des Typs float niemals zur Berechnung von Währungen verwendet werden. Innerhalb von Java wird ein float stets als Dezimalbruch geführt und die Ungenauigkeit verunmöglicht es diesen Datentyp für Währungsrechnungen zu verwenden.\nZeichen-Datentyp Ein char ist ein (vorzeichenloser) 16-Bit-Integer-Datentyp, der ein einzelnes Zeichen darstellt. Dieser Datentyp erlaubt die Repräsentation von Zeichen im so genannten Unicode-Zeichensatz.\nEin einzelnes Zeichen kann eine Ziffer, einen Buchstaben oder ein anderes Symbol sein. Um ein Zeichen zu schreiben, verwenden wir einfache Anführungszeichen wie folgt:\n1  'A', 'B', 'C', 'x', 'y', 'z', '0', '1', '2', '9'   Zeichenliterale können Symbole eines Alphabets, Ziffern von ‘0’ bis ‘9’, Whitespaces (' ‘) oder andere Zeichen oder Symbole ('$') darstellen. Verwechsle nicht die Zeichen, die Zahlen (‘9’) darstellen mit den Zahlen selbst (9). Ein Zeichen kann nicht zwei und mehr Ziffern oder Buchstaben enthalten, da es nur ein einziges Symbol darstellt.\nWir können Zeichen auf verschiedene Arten initialisieren:\n   Beschreibung Code     Einfache Anführungszeichen char A = 'A';   Wir können ein Char-Literal als Integral-Literal angeben, das den Unicode-Wert des Zeichens darstellt, und Integral-Literale können entweder in Dezimal-, Oktal- oder Hexadezimalform angegeben werden.Der zulässige Bereich liegt zwischen 0 und 65535. char A = 65;   In der Unicode-Darstellung '\\\\uxxxx' können Zeichenliterale angegeben werden. Hier steht xxxx für 4 Hexadezimalzahlen. char A = '\\u0041';    Beispiele:\n1 2 3  char letter = 'a'; char point = '.'; letter++; // 'b'   Don’t get confused:  123 ist ein Integer, “123” ist ein String; ‘A’ ein Zeichen (char), “A” ist ein String; ‘1’ ist ein Zeichen (char), 1 ist ein Integer;  Logischer Datentyp Dieser Datentyp bezieht sich nur auf die zwei Werte true und false.\n1 2  boolean done = false; boolean isBigger = true;    Referenztypen Nebst primitiven Datentypen gibt es Referenzdatentypen. Eine Variable diesen Typs enthält nicht die Werte selbst wie eine Variable primitiven Typs, sondern nur einen Verweis (Referenz) auf den\nSpeicherort der Daten. Der Standardwert von Referenzvariablen ist null, welcher besagt, dass die Variable auf kein Objekt verweist.\nEs gibt zwei Unterarten von Referenztypen:\n Array: Eine Datenstruktur fester Grösse, die dazu dient, mehrere Elemente gleichen Typs zu speichern Objektdatentyp, repräsentiert ein beliebiges Objekt   Arrays Definition Häufig benötigen Software-Entwickler mehrere zusammengehörige Variablen desselben Datentyps, die logisch oder verwaltungstechnisch zusammengehören. Es wäre aber sehr aufwendig, diese Variablen alle einzeln zu deklarieren und zu verarbeiten. Zudem ist es möglich, dass die Anzahl an Objekten noch unbekannt ist und erst bei der Ausführung des Programms definiert wird. Deswegen wird in Java, wie in anderen Programmiersprachen auch, die Verwendung von Arrays unterstützt. In Arrays lassen sich beliebige primitiven Datentypen und Objekte speichern und systematisch bearbeiten. Alle Variablen haben einen gemeinsamen Namen, werden aber über unterschiedliche Indizes angesprochen.\nDeklaration Die Deklaration eines Arrays enthält folgende Bestandteile:\n   Reihenfolge Bedeutung Beispiel     1. Typ String, int, double, char, ...   2. Eckige Klammern []   3. Bezeichner / Namen words, numbers, values, letters...    1  String[] words;   Länge eines Arrays Die Anzahl der Elemente in einem Array wird als Länge eines Arrays bezeichnet. Diese Länge wird zum Zeitpunkt der Erstellung eines Arrays einmal festgelegt. Sie kann später in einem Programm nur durch Definition eines neuen Arrays und dem Kopieren von Werten geändert werden.\nWir können die Länge eines Arrays mithilfe einer in Java integrierten Funktionalität überprüfen:\n1  words.length   Indizierung Die Indizes in einem Array reichen immer von 0 bis length-1. Ein Array mit den ersten 100 natürlichen Zahlen hat beispielsweise eine Länge von 100 und Indizes von 0 bis 99.\nSyntax In Java müssen wir zum Zeitpunkt der Deklaration eines Arrays folgendes angeben:\n den Datentyp den Namen  und zum Zeitpunkt der Initialisierung:\n die Größe  Syntaktisch können wir ein Array eines ganzzahligen Datentyps auf folgende Weise deklarieren:\n1 2  String[] words; String words[];   Die zweite Form wird bei uns nicht verwendet.\nDieser Code deklariert die Variable words, erstellt das Array-Objekt jedoch noch nicht. Der Operator new wird in Java zum Erstellen von neuen Objekten verwendet.\n1  String[] words = new String[5];   Damit wird ein Array-Objekt der Länge 5 instanziiert. Die fünf Elemente dieses Arrays wurden mit Standardwerten initialisiert. Bei einem Array des Datentyps String ist der Default-Wert null. Alle Werte im Array werden also mit null aufgefüllt.\nWir können auch direkt die Werte der Array-Elemente angeben:\n1  String[] words = { \"Hai\", \"Oktopus\", \"Rochen\", \"Wal\", \"Fisch\" };   Es wird also ein Array mit der Grösse 5 und den angegebenen Werten erstellt.\nZugriff auf Elemente Wenn wir den Wert eines Elements in unserem Array verändern möchten, geschieht dies folgendermaßen:\n1  words[index] = value;   Wenn wir den Wert eines Array-Elements in einer Variablen außerhalb des Arrays speichern wollen:\n1  String value = words[index];    String Eine Variable, die eine Zeichenkette enthält, hat den Typ String.\n1  String hello = \"Hello, Java\";   Diese Zeichenkette besteht aus 11 Zeichen, einschließlich eines Leerzeichens. Wie wir hier ebenfalls sehen, müssen String-Literale von doppelten Anführungszeichen umgeben sein. Ein Objekt des Typs String ist unveränderlich, die Werte innerhalb eines Strings können also nach dessen Erstellung nicht mehr verändert werden.\nMethoden Der folgende Code zeigt die Verwendung einiger Methoden der Klasse String. Alle Methoden sind in der API unter java.lang.String zu finden.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124  public class StringMethoden { public static void main(String[] args) { String house = \"house\"; /** * Returns the char value at the specified index (indexing starts from 0) */ char o = house.charAt(1); /** * Returns the length of this string. */ int length = house.length(); /** * Returns true if and only if this string contains the specified sequence of char values */ boolean isContaining = house.contains(\"us\"); /** * Returns the index within this string of the first occurrence of the specified character */ int indexChar = house.indexOf('s'); /** * Returns the index within this string of the first occurrence of the specified substring */ int indexSubstring = house.indexOf(\"us\"); /** * Tests if this string starts with the specified prefix */ boolean startsWithPrefix = house.startsWith(\"Ho\"); // false  boolean startsWithPrefix2 = house.startsWith(\"ho\"); // true  /** * Tests if this string ends with the specified suffix */ boolean endsWithSuffix = house.endsWith(\"se\"); // true  /** * Returns a new string resulting from replacing all occurrences of oldChar in this string with newChar */ String mouse = house.replace('h', 'm'); String houseHouse = \"House, House\"; String mouseMouse = houseHouse.replace('H', 'M'); /** * Returns a new string that is a substring of this string, starting from the specified index */ String applePearLemon = \"Apple, pear, lemon\"; String pearLemon = applePearLemon.substring(7); /** * Returns a new string that is a substring of this string */ String pear = applePearLemon.substring(7, 11); /** * Converts all of the characters in this String to upper case */ String apple = \"Apple\"; String appleUpperCase = apple.toUpperCase(); // APPLE  /** * Converts all of the characters in this String to lower case. */ String appleLowerCase = apple.toLowerCase(); // apple  /** * Splits this string around matches of the given regular expression, puts them in a String array */ String applePear = \"Apple, pear\"; String[] fruits = applePear.split(\",\\\\s\"); // \\\\s means whitespace  /** * Converts this string to a new character array */ char[] charArray = applePearLemon.toCharArray(); /** * Compares this string to the specified object */ String appleOne = \"Apple\"; String appleTwo = \"Apple\"; boolean isEqual = appleOne.equals(appleTwo); /** * Compares two strings lexicographically. * The comparison is based on the Unicode value of each character in the strings. * The result is a negative integer if this String object lexicographically precedes the argument string. * The result is a positive integer if this String object lexicographically follows the argument string. * The result is zero if the strings are equal */ String abcd = \"abcd\"; String cdef = \"cdef\"; if (abcd.compareTo(cdef) \u003c 0) { System.out.println(abcd + \" precedes \" + cdef); } if (house.compareTo(house) == 0) { System.out.println(house + \" is equal to \" + house); } if (cdef.compareTo(abcd) \u003e 0) { System.out.println(cdef + \" follows \" + abcd); } /** * Capital letters precede lower case letters */ String houseLowerCase = \"house\"; String houseUpperCase = \"HOUSE\"; if (houseLowerCase.compareTo(houseUpperCase) \u003e 0) { System.out.println(houseUpperCase + \" precedes + \" houseLowerCase); } /** * Compares two strings lexicographically, ignoring case differences */ System.out.println(houseLowerCase.compareToIgnoreCase(houseUpperCase)); } }    Scanner Eine Möglichkeit, Benutzereingaben in Java vorzunehmen, besteht in der Verwendung der Scanner-Klasse, die verwendet wird, indem zuerst die Definition der Klasse wie in Zeile 1 importiert und dann ein Objekt dieser Klasse wie in Zeile 6 erstellt wird.\n1 2 3 4 5 6 7 8 9 10  import java.util.Scanner; public class TakeInput { public static void main (String[] args) { Scanner scanner = new Scanner(System.in); System.out.println(\"Enter your name: \"); String name = scanner.nextLine(); System.out.println(\"Your name is: \" + name); } }   Zeile 1\nDer erste Schritt besteht darin, die Scanner-Klasse zu importieren, damit sie im folgenden Code verwendet werden kann. Die Java Scanner-Klasse stammt aus dem Paket java.util. Es ist einfach zu bedienen, muss jedoch importiert werden, damit die Klasse funktioniert.\nZeile 6\n Wir deklarieren den Datentyp als Scanner und geben ihm den Bezeichner scanner Wir weisen der Variable scanner ein neues Objekt zu, welches den System-Eingabestream enthält (System.in)  Zeile 8\n Wir deklarieren eine Variable vom Datentyp String mit dem Bezeichner name Wir weisen der Variable name das Resultat der Methode scanner.nextLine() zu Diese Methode nimmt die Tastatureingabe vom Benutzer auf der Kommandozeile entgegen. Sie wird beendet, wenn der Benutzer die Enter-Taste drückt   Static / Non-Static Statische Elemente (Variablen und Methoden) existieren innerhalb des Java-Ökosystems pro Klasse nur einmal. Es spielt also keine Rolle wie viele Objekte einer Klasse erzeugt werden, eine statische Variable bleibt über alle Instanzen stets gleich.\nDas folgende Beispiel soll dies zeigen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  public class Student { public static int numberOfStudents = 0; private String name; public Student(String name) { this.name = name; numberOfStudents++; } public String getName() { return this.name; } }   Die Variable numberOfStudents gibt es in Bezug auf die Klasse Student nur einmal. Der Zugriff erfolgt über den Namen der Klasse.\n1 2 3 4 5 6 7 8 9  public class Main { public static void main(String[] args) { Student maria = new Student(\"Maria\"); System.out.println(Student.numberOfStudents); // output will be 1  Student rick = new Student(\"Rick\"); System.out.println(Student.numberOfStudents); // output will be 2  } }   Will man hingegen den Namen eines der Studenten holen, so erfolgt der Zugriff über die Instanz des entsprechenden Objektes.\n1 2 3 4 5 6 7 8 9  public class Main { public static void main(String[] args) { Student maria = new Student(\"Maria\"); System.out.println(maria.getName()); // output will be \"Maria\"  Student rick = new Student(\"Rick\"); System.out.println(rick.getName()); // output will be \"Rick\"  } }   Die Verwendung des Schlüsselworts this ist in einem statischen Kontext nicht möglich, da dieser ja wie erwähnt keine Referenzen verwendet.\nStatische Methoden Mittlerweile hast du bereits einige statische Methoden kennengelernt, wie zum Beispiel die Main-Methode oder die Methode println() der Klasse System oder die Methode valueOf() der String-Klasse. Hier wollen wir uns nun genauer anschauen, was statische Methoden sind, denn diese wirst du unter anderem für das Lösen der Übungen benötigen. Das Keyword static ist ein sehr nützliches Werkzeug in Java. Bei statischen Methoden sind einige wichtige Punkte zu beachten.\n Diese Methoden gehören nicht zu einer Referenz von einem bestimmten Objekt Diese Methoden werden über den Klassennamen aufgerufen und nicht über eine Referenz von einem bestimmten Objekt  Wenn also in einem Methodenkopf das Keyword static steht, dann weisst du, dass es sich um eine statische Methode handeln muss. Schauen wir uns unterschiedliche Methodendeklarationen an (folgendes gilt für statische Methoden wie auch für nicht-statische Methoden): Wenn eine Methode einen Wert an ihren Aufrufer zurückgeben soll, sprechen wir von einer Methode mit einem Rückgabewert:\n1 2 3  public static returnType methodName() { return returnValue; // der Typ des Rückgabewerts muss vom Typ sein, welcher im Methodenkopf steht }   Wir sehen, dass in der Methodendeklaration angeben werden muss, welcher Typ zurückgegeben wird.\nWenn eine Methode keinen Wert zurückgegeben soll, verwenden wir das Keyword void:\n1 2 3  public static void methodName() { }   Das Keyword return ist in Methoden ohne Rückgabewert weiterhin zulässig um die Methode zu verlassen. Die Angabe eines Rückgabewerts entfällt in diesem Fall.\nWir können auch Werte einer Methode übergeben – hierbei sprechen wir von Parametern.\n1 2 3  public static void methodName(type identifier) { }   Ein Parameter besteht immer aus dem Datentyp und einem Bezeichner. Wir können beliebig viele Parameter an eine Methode übergeben. Gemäss den SBB Code Conventions (Regeln für den Programmcode) sollte eine Methode nicht mehr als acht Parameter haben.\nRegeln  Die Reihenfolge der Schlüsselwörter im Methodenkopf darf nicht verändert werden Bei der Auswahl des Methodennamens müssen die gleichen Regeln wie bei der Benennung einer Variablen eingehalten werden Keine doppelten Methoden: Jede Methodensignatur darf in einer Klasse nur einmal vorkommen  Aufruf Innerhalb der gleichen Klasse\n1  methodName();   Ausserhalb:\n1  ClassName.methodName();   Utility-Klassen Eine Klasse, welche ausschliesslich statische Elemente besitzt nennt man Utility-Klasse. Ein gutes Beispiel dafür ist die Klasse Math. Eine solche Klasse sollte einen privaten Konstruktor aufweisen, da es keinen Sinn macht von ihr eine Referenz zu erstellen. Zudem sollte die Klasse als final deklariert werden, da eine Vererbung aufgrund des statischen Kontextes ebenfalls keinen Sinn ergibt.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  public final class SpeedConverter { private SpeedConverter() { // Utility class  } public static double toMilesPerHour(double kmh) { return kmh * 0.621; } public static double toKilometersPerHour(double mph) { return mph * 1.609; } }    Mathematik \u0026 Logik Mathe in Java ist sehr einfach. Beachte, dass mathematische Java-Operationen einer bestimmten Reihenfolge folgen (Punkt-Operationen vor Strich-Operationen)\nArithmetische Operatoren    Symbol Arithmetische Operation Beispiel     + Addition int sum = 2 + 3;   - Subtraktion int difference = 5 – 2;   / Division int quotient = 15 / 5;   * Multiplikation int product = 3 * 4;   % Division mit Rest int remainder = 7 % 3;   ++ Post und Prä-Inkrement (1 addieren) count++; // (count = count + 1)   - - Post und Prä-Dekrement (1 subtrahieren) count--; // (count = count – 1)    Post- und Prä-Inkrement Das Inkrementieren und Dekrementieren von Variablen ist eine sehr häufige Operation. Von diesem Operator gibt es zwei Varianten:\n Er kann vor der Variable stehen, wie in ++i (Präfix-Schreibweise) oder dahinter, wie bei i++ (Postfix-Schreibweise)  Der Präfix-Operator verändert die Variable vor der Auswertung der Programmzeile, und der Postfix-Operator ändert sie nach der Auswertung der Programmzeile. Mit anderen Worten: Nutzen wir einen Präfix-Operator, so wird die Variable erst herauf- bzw. heruntergesetzt und dann der Wert geliefert. Und beim Post-Operator ist es genau umgekehrt.\nPostinkrement 1 2 3  int i = 5; int c = i++; // c = 5 // ab hier ist i = 6   Präinkrement 1 2  int i = 5; int d = ++i; // d = 6   Postdekrement 1 2 3  int i = 5; int e = i--; // e = 5 // ab hier ist i = 4   Prädekrement 1 2  int i = 5; int f = --i; // f = 4    Vegleichsoperatoren Die Ergebnisse dieser Operationen sind stets Boolean-Werte.\n   Symbol Vergleich Beispiel     \u003e grösser als 5 \u003e 4   \u003c kleiner als 4 \u003c 5   \u003e= grösser gleich 3 \u003e= 3   \u003c= kleiner gleich 3 \u003c= 3   == gleich 2 == 2   != ungleich 2 != 4    Boolsche Operatoren Diese Operatoren basieren auf der boolschen Algebra. Daher arbeiten boolsche Operatoren direkt mit boolschen Werten. Es gibt vier Arten von boolschen Operatoren. Schauen wir uns zunächst ihre Symbole und deren Inhalt in der folgenden Tabelle an, bevor wir erläutern, welche Funktionen sie ausführen.\n   Symbol Boolsche Operation Erklärung     \u0026\u0026 Logisches UND (AND) AND gibt nur dann true zurück, wenn die Ausdrücke auf beiden Seiten des Operators true sind (Hinweis: Dieser Ausdruck wird lazy evaluiert. Dies bedeuetet, wenn der erste Ausdruck false ist, wird der zweite Ausdruck nicht mehr ausgewertet   || Logisches ODER (OR) OR gibt true zurück, wenn der Ausdruck auf einer oder beiden Seiten des Operators true ist (Hinweis: Dieser Ausdruck wird lazy evaluiert. Dies bedeuetet, wenn der erste Ausdruck true ist, wird der zweite Ausdruck nicht mehr ausgewertet   ! Logisches NICHT (NOT) NOT kehrt den Wert des darauffolgenden booleschen Ausdrucks um. Aus true wird also false und umgekehrt   ^ Logisches ENTWEDER-ODER (XOR) XOR gibt true zurück, wenn die beiden Ausdrücke unterschiedlich sind   \u0026 Logisches UND (AND) Im Unterschied zum obigen AND wertet dieses immer beide Ausdrücke aus   | Logisches ODER (OR) Im Unterschied zum obigen OR wertet dieses immer beide Ausdrücke aus.     Kontrollstrukturen Kontrollstrukturen dienen dazu, den Ablauf eines Programms zu steuern. Damit bietet eine Kontrollstruktur die Möglichkeit, Programmteile nur unter gewissen Bedingungen ( → bedingte Anweisungen) auszuführen oder Programmteile zu wiederholen ( → Schleifen).\nBedingte Anweisungen Eine bedingte Anweisung ist eine Konstruktion, mit der ein Programm abhängig vom Wert eines boolschen Ausdrucks (true oder false) unterschiedliche Wege geht.\nIf-Statement Die einfachste Form der bedingten Anweisung besteht aus dem Schlüsselwort if, einem boolschen Ausdruck und einem Block.\n1 2 3  if (expression) { }   Wenn der Ausdruck true ist, werden die Anweisungen im Codeblock ausgeführt. Andernfalls werden sie übersprungen.\nIf-Else Statement Der obige if-Fall kann mit dem Schlüsselwort else erweitert werden, um alternative Aktionen auszuführen, wenn der Ausdruck false ist.\n1 2 3 4 5  if (expression) { // do something } else { // do something else }   Im folgenden Beispiel gibt das Programm je nach Wert von num (gerade oder ungerade) unterschiedlichen Text aus.\n1 2 3 4 5 6  int num = ...; // the num is initialized by some value if (num % 2 == 0) { System.out.println(\"It's an even number\"); } else { System.out.println(\"It's an odd number\"); }   Da eine Zahl nur gerade oder ungerade sein kann, wird nur eine der beiden Ausgaben gemacht.\nElse-If-Statements Ein Else-Statement kann durch ein If-Statement erweitert werden.\n1 2 3 4 5 6 7 8 9  if (expression0) { // do something } else if (expression1) { // do something else 1 } else if (expressionN) { // do something else N } else { // in all other cases: do this… }   Wenn also der erste Ausdruck false ist, wird der zweite Ausdruck überprüft, usw.\nBeispiel:\n1 2 3 4 5 6 7 8 9 10  long dollars = ...; // your budget if (dollars \u003c 1000) { System.out.println(\"Buy a laptop\"); } else if (dollars \u003c 2000) { System.out.println(\"Buy a personal computer\"); } else if (dollars \u003c 100_000) { System.out.println(\"Buy a server\"); } else { System.out.println(\"Buy a data center or a quantum computer\"); }   Switch-Statement Die Switch-Anweisung bietet eine Möglichkeit, basierend auf dem Wert einer einzelnen Variablen (kein Ausdruck!) zwischen mehreren Fällen zu wählen. Die Variable kann eine Ganzzahl, ein Zeichen, eine Zeichenfolge oder eine Aufzählung sein.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  switch (variable) { case value1: // do something here  break; case value2: // do something here  break; //... other cases  case valueN: // do something here  break; default: // do something by default  break; // it can be omitted }   Die Schlüsselwörter switch und case werden hier immer benötigt. Die Schlüsselwörter break und default sind optional. Das Schlüsselwort break verlässt die Switch-Anweisung. Wenn ein Fall nicht über das Keyword break verfügt, wird auch der darauffolgende Fall ausgewertet. Dies ist spannend, um die einzelnen Auswertungen verketten zu können. Der Default-Fall wird ausgewertet, wenn kein Fall mit dem Variablenwert übereinstimmt.\nSchleifen (Loops) Manchmal müssen wir einen Codeblock für eine bestimmte Anzahl wiederholen. Zu diesem Zweck stellt Java die Schleife bereit. Diese Schleife wird häufig verwendet, um über einen Wertebereich oder durch ein Array zu iterieren. For-Loops arbeiten mit einem Schleifenzähler, welcher sehr gut für Indizes von Arrays verwendet werden kann. Bei allen Schleifen ist Vorsicht geboten, da es rasch zu einer unendlichen Anzahl von Ausführungen kommen kann.\nFor-Loop 1 2 3  for (initialization; condition; modification) { // do something }    Bevor die Schleife beginnt, wird einmal die Initialisierungsanweisung (initialization) ausgeführt. Wir bezeichnen diese Variable als Schleifenvariable. Es sind mehrere Schleifenvariablen erlaubt, sie können durch Kommas getrennt werden. Die Bedingung (condition) ist ein boolscher Ausdruck, der die Notwendigkeit der nächsten Iteration bestimmt. Wenn die Auswertung der Bedingung false ist, wird die Schleife beendet – ansonsten folgt eine weitere Iteration Die Modifikation ist eine Anweisung, die den Wert der Schleifenvariablen verändert. Sie wird nach jeder Iteration aufgerufen. Normalerweise wird der Wert der Variable inkrementiert oder dekrementiert.  Beispiel:\n1 2 3 4 5  int n = 9; for (int i = 0; i \u003c= n; i++) { System.out.print(i + \" \"); } // Output: 0 1 2 3 4 5 6 7 8 9   Innerhalb des Schleifenkörpers kann das Programm wiederum alle möglichen Java-Anweisungen ausführen. Es kann sogar andere Schleifen enthalten. Wie bei allen Blöcken sind die Schleifenvariablen nur innerhalb des Schleifenkörpers sichtbar. Die Schleifenvariable wird meistens mit einfachen Variablennamen wie i, j, k oder index benannt.\nHier ist ein weiteres Beispiel. Berechnen wir die Summe der Ganzzahlen von 1 bis 10 mit der for-Schleife.\n1 2 3 4 5 6 7 8 9  int startIncl = 1; int endExcl = 11; int sum = 0; for (int i = startIncl; i \u003c endExcl; i++) { sum += i; } System.out.println(sum); // Output: 55   For-Each Loop Der For-Each-Loop durchläuft alle Elemente eines Arrays oder einer Collection. Die Angaben aus dem For-Loop werden durch eine Schleifenvariable und ein Doppelpunkt ersetzt.\n1 2 3 4 5  int[] numbers = { 125, 381, 98, 12, 235 }; for (int number: numbers) { System.out.print(number + \" \"); } // Output: 125 381 98 12 235   Der gezeigte Loop wird also fünfmal ausgeführt und der Wert der Variable number nimmt bei jedem Durchlauf den jeweils nächsten Wert aus dem Array an.\nWhile-Loop Die while- Schleife besteht aus einem Codeblock und einer Bedingung (einem booleschen Ausdruck). Wenn die Bedingung erfüllt ist, wird der Code innerhalb des Blocks ausgeführt. Dieser Code wird solange wiederholt, bis die Bedingung nicht mehr erfüllt ist.\n1 2 3  while (condition) { // body: do something }   Innerhalb des Schleifenkörpers kann das Programm wiederum alle möglichen Java-Anweisungen ausführen. Es kann sogar andere Schleifen enthalten.\nBeispiel: Die folgende Schleife gibt Ganzzahlen aus, während eine Variable kleiner als 5 ist.\n1 2 3 4 5 6 7  int i = 0; while (i \u003c 5) { System.out.print(i + \" \"); i++; } // Output: 0 1 2 3 4   Do-While Loop Die Do-While-Schleife besteht aus einem Codeblock und einer Bedingung (einem boolschen Ausdruck) am Ende. Im Gegensatz zur While-Schleife wird die Do-While-Schleife mindestens einmal ausgeführt, da die Bedingung am Ende steht.\n1 2 3  do { // body: do something } while (condition);   ","categories":"","description":"Modul #J1\n","excerpt":"Modul #J1\n","ref":"/docs/java/java-grundlagen/","tags":"","title":"Java Grundlagen"},{"body":"Aufgabe 1 - Seite mit Joke Schreibe eine Website, die auf Knopfdruck einen Witz anzeigt.\nVerwende hierfür die Juck Norris-API: GET https://api.chucknorris.io/jokes/random\nSolltest du fertig mit dieser Aufgabe sein, dann melde dich bei einem Coach.\nAufgabe 2 - Eine andere API anbinden Versuche, ein(e) andere(s) API/Backend anzubinden und etwas auf einer Website anzuzeigen.\nAufgabe 3 - Uhr Schreibe ein HTML, das eine Uhrzeit visuell anzeigt.\nDeine Website soll zentriert eine Uhrzeit anzeigen. Die Uhrzeit soll analog angezeigt werden - also mit Stunden-, Minuten- und Sekundenzeiger.\nEine analoge Uhr kannst du mit Hilfe von Vektorgrafiken (SVGs) oder Canvas rendern.\nDu kannst es aber auch mit gewöhnlichen HTML-Elementen versuchen.\nHilfestellungen zu\n SVG Canvas  Aufgabe 4 - Global Scope, Function Scope und Block-Scope Im Kapitel ES6: Variablen deklarieren zu hast du die Funktionsweise vom Global und Function Scope kennengelernt mit einem Beispiel-Code mit console.log(...)s. In diesem Beispiel wurden alle Variablen mit var deklariert/definiert - also keine lets oder consts.\nÄndere in diesem Code alle vars zu lets oder consts.\nBeantworte folgende Fragen und dokumentiere deine Antworten:\n Was ist ein Scope? Was sind Global Scope, Function Scope und Block-Scope? Was sind die Unterschiede? Mit welchem Scope arbeitest du in Java? Begründe. Wie werden Variablen im globalen Scope definiert? Wie kannst du definieren, welche Variable welchen Scope haben soll? Wann könnte die Verwendung von var sinnvoll sein?  Aufgabe 5 - Die optionalen Import-Inseln Entwerfe eine HTML-Seite, welche nachfolgendes JavaScript als Daten-Grundlage verwendet.\n Hierfür musst du eine Klasse Island in der Datei island.js mit genau EINEM Konstruktor erstellen. Auf der HTML-Seite zeigst du alle Inseln an. Wenn eine Insel einen bestimmten Wert besitzt, wird dieser Wert angezeigt, ansonsten nicht. Wenn die Insel ein Bild besitzt, blendest du dieses ein. Das nachfolgende Script darfst du NICHT abändern (auch keine geschweiften Klammern beim Import hinzufügen).  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  import Island from \"./island.js\"; export const islands = [ new Island({ name: \"Atlantis\" }), new Island({ name: \"Maldives\", country: \"Maldives\", imageUrl: \"https://www.planetware.com/photos-large/SEY/best-islands-maldives.jpg\", }), new Island({ name: \"Bora Bora\", country: \"French Polynesia\", imageUrl: \"https://www.planetware.com/photos-large/SEY/best-islands-bora-bora.jpg\", }), new Island({ name: \"Seychelles\", country: \"Seychelles\", imageUrl: \"https://www.planetware.com/photos-large/SEY/best-islands-seychelles.jpg\", }), new Island({ name: \"Diomede\", imageUrl: \"https://upload.wikimedia.org/wikipedia/commons/thumb/8/8e/Little_Diomede_Island_village.jpeg/1280px-Little_Diomede_Island_village.jpeg\", }), ]; for (const island of islands) { console.info( `Explore the island ${island.name}in ${ island.country ?? \"an unknown country\" }: ${island.imageUrl ?? \"no image available :/\"}` ); }   ","categories":"","description":"Aufgaben zu Modul #F4 - JavaScript\n","excerpt":"Aufgaben zu Modul #F4 - JavaScript\n","ref":"/labs/web/html_css/03_javascript/","tags":"","title":"JavaScript - Aufgaben"},{"body":"Aufgabe 1 Postleitzahlen einlesen und verarbeiten:\n Schreibe ein Programm, welches Postleitzahlen aus einer CSV-Datei herausliest und in einer HashMap speichert. Nach dem Speichern schreibt das Programm verschiedene Informationen zu den Daten in die Konsole (siehe Ausgabe). Verwendet wieder die kleine Hilfsklasse OutputValidation zum Verifizieren von eurem Konsole-Output.  Input  PLZ (UTF8 Format) PLZ (ISO-8859-1 Format)  Ausgabe Die Ausgabe muss das folgende Format aufweisen. Beachte, dass die Aufzählungen der Ortschaften sortiert sind.\n1 2 3 4 5 6 7 8 9 10 11  - Anzahl PLZ: 42 - Kleinste PLZ der Gemeinde Bern: 4444 Bern - Grösste PLZ der Gemeinde Bern: 4444 Bern - Anzahl Gemeinden mit mehr als 10 Buchstaben: 42 - Anzahl Gemeinden mit 7 Buchstaben: 42 - Anzahl Gemeinden mit der Buchstabenfolge 'ent': 42 - Gemeinden mit 3 Buchstaben: Abc, Def, Xzz - Anzahl Buchstaben der kleinsten Gemeinden: 2 - Kleinsten Gemeinden: di, ri, ru - Anzahl Buchstaben der grössten Gemeinden: 5 - Grössten Gemeinden: diwil, riwil, ruwil    Ausgabe überprüfen\nDer Konsole-Output Hash für diese Aufgabe ist: 1768988137\n Aufgabe 2 Wir programmieren eine eigene Map-Klasse MyMap, welche noch keinen Hash-Code verwendet:\n Es dürfen keine Klassen aus dem Collection-Framework verwendet werden. Die Klasse muss das Interface MyMapInterface implementieren. Die Klasse weiss nicht, wie viele Elemente man speichert. Sie muss die Grösse internen Datenstruktur dynamische anpassen. Die toString() der java.lang.Object Klasse soll von der MyMap so überschrieben werden, dass die Elemente kommasepariert ausgegeben werden.   Inferface MyMapInterface 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61  package com.examples.list; public interface MyMapInterface\u003cK, V\u003e { /** * Associates the specified value with the specified key in this map. * @param key key with which the specified value is to be associated * @param value value to be associated with the specified key * @return the previous value associated with {@code key}, or * {@code null} if there was no mapping for {@code key}. */ V put(K key, V value); /** * Returns the value to which the specified key is mapped, * or {@code null} if this map contains no mapping for the key. * @param key the key whose associated value is to be returned * @return the value to which the specified key is mapped, or * {@code null} if this map contains no mapping for the key */ V get(Object key); /** * Returns the number of key-value mappings in this map. * @return the number of key-value mappings in this map */ int size(); /** * Removes all the mappings from this map. * The map will be empty after this call returns. */ void clear(); /** * Removes the mapping for a key from this map if it is present. * @param key key whose mapping is to be removed from the map * @return the previous value associated with {@code key}, or * {@code null} if there was no mapping for {@code key}. */ V remove(Object key); /** * Returns {@code true} if this map contains a mapping for the specified * key. * @param key key whose presence in this map is to be tested * @return {@code true} if this map contains a mapping for the specified * key */ boolean containsKey(Object key); /** * Returns {@code true} if this map maps one or more keys to the * specified value. * @param value value whose presence in this map is to be tested * @return {@code true} if this map maps one or more keys to the * specified value */ boolean containsValue(Object value); }    Aufgabe 3 (Optional) Wir Kopieren unsere MyMap Klasse zu der Klasse MyHashMap und erweitern diese, damit sie Hash Funktionalität verwendet:\n Beim Hinzufügen von Zuweisungen wird der Hash-Code vom Schlüssel berechnet und ebenfalls abgespeichert. Die Schlüsselsuche wird anschliessend über die gespeicherten Hash-Code der Schlüssel durchgeführt statt über die Schlüssel selbst.  ","categories":"","description":"Aufgaben zu [Java Collections - Map](../../../../docs/java/java-collections/04_map)\n","excerpt":"Aufgaben zu [Java Collections - …","ref":"/labs/java/java-collections/03_map/","tags":"","title":"Map - Aufgaben"},{"body":"Schreibe ein Programm, welches einen Streaming Dienst nachstellt. Die Anwendung soll die Filme und Serien in einem Streaming Dienst abspeichern, wenn die entsprechende Methode aufgerufen wurde. Der Streaming Dienst hat auch eine Liste an Personen, welche ein Abonnement bei dem Streaming Dienst gelöst haben.\nEine Person besitzt\n einen Namen eine Email-Adresse eine Kreditkarte  Ein Film\n einen Namen eine Dauer ein Genre einen Produzenten  Eine Person kann\n einen Film als gesehen markieren (View) seine Kreditkarte ändern zwischen der Zahlungsart Monatlich oder Jährlich entscheiden  Der Streaming Dienst kann\n die Anzahl der Personen zurückliefern, welche ein Abonnement gelöst haben eine neue Person registrieren eine Person löschen nach einem Film über den Namen suchen nach Filmen eines bestimmten Genres suchen die anzahl Views auf einem Film wiedergeben alle Kreditkarten der Kunden ausgeben (println) die das Abonnemente per Monatlichen Zahlung bezahlen  Generell gilt die Regel, dass jede E-Mail-Adresse und jeder Film-Name einzigartig sein muss\nZusatzaufgabe (muss nicht gelöst werden): Dies ist eine Liste aller europäischen Sprachen: BULGARIAN,CROATIAN,CZECH,DANISH,DUTCH,ENGLISH,ESTONIAN,FINNISH,FRENCH,GERMAN,GREEK,HUNGARIAN,IRISH,ITALIAN,SLOVENIA,LATVIAN,LITHUANIAN,MALTESE,POLISH,PORTUGUESE,ROMANIAN,SLOVAK,SLOVENE,SPANISH,SWEDISH\nEin Film soll um den Wert Sprachen erweitert werden. Darin wird gepseichert, in welchen Sprachen der Film verfügbar ist. Speichert die Sprache nicht in Form eines Strings!!!\n","categories":"","description":"Aufgabe zu Modul #J2 - OOP - Streaming Dienst\n","excerpt":"Aufgabe zu Modul #J2 - OOP - Streaming Dienst\n","ref":"/labs/java/java-oop/03_streaming_dienst/","tags":"","title":"Streaming Dienst"},{"body":"Übung macht den Meiser Bevor wir mit fortgeschrittenen JavaScript-Technologien weiterfahren, sollst du die Basics von JavaScript verstanden haben.\nHierfür empfehlen wir dir folgenden Online-Kurs: https://www.codecademy.com/learn/introduction-to-javascript\nDieser Kurs ist grundlegend. Da JavaScript und Java in der Syntax sehr ähnlich sind sollte ein grosser Teil für dich Repetition von Java-Teil sein.\nMöchtest du z.B. zur nächsten Aufgabe ohne die aktuelle lösen zu müssen, dann kannst du 2x auf “Run” klicken, dann auf “View Solution” und anschliessend auf “Replace with Solution”.\nEine Übersicht über die Themen erhältst du via Klick oben links auf “Course Menu”.\nSchaue, dass du mindestens folgendes verstanden hast und anwenden kannst:\n   Kaptiel Das musst du anwenden können Bemerkungen     Introduction Variablen definieren, Unterschied {var, let, const}, mathematische Operationen, typeof-Operator, String-Methoden wie {trim, startsWith, …} Prüfe zudem dein Wissen mit dem “Introduction to JavaScript”-Quiz   Conditionals if/else/switch statements, Vergleichsoperatoren, du kennst truthy und falsy Werte Löse auch ein paar Aufgaben und den Test “Conditional Statements” solltest du fehlerfrei abschliessen können.   Functions Funktions-Definition, -Aufruf, Default-Parameter, Arrow Functions, Function Expressions, Globaler und Block-Scope Die Tests sind leider nicht mehr in der kostenlosen Version inbegriffen.   Arrays Arrays/Listen erstellen, updaten, Länge bestimmen, durch Array durch iterieren    Loops Du kannst for-, while- und do while-Schlaufen benutzen und mit break kontrolliert abbrechen.    Iterators Functions as Data and Parameters, Iteratoren wie .forEach, .map, .filter, .reduce anwenden können    Objects Objekte erstellen mit Properties und Methoden, Pass By Reference verstehen, durch Objekte durchiterieren, Advanced Objects mit dem this-Keyword, Getter und Setter     ","categories":"","description":"Trainiere nun deine Fähigkeiten mit JavaScript.\n","excerpt":"Trainiere nun deine Fähigkeiten mit JavaScript.\n","ref":"/docs/web/javascript/04_js_training/","tags":"","title":"JavaScript trainieren"},{"body":"Titel (Heading) Du hast bereits erfahren, dass du mit \u003ch1\u003e für Titel verwenden kannst. Oft hast du aber einen Titel für die Seite und dann Titel, die diesem Titel untergeordnet sind. Wie in einem Word-Dokument kannst du auch in HTML Titel hierarchisch verschachteln. Das geht so:\n1 2 3 4 5 6 7 8  \u003ch1\u003eHeading 1\u003c/h1\u003e \u003cp\u003eHello\u003c/p\u003e \u003ch2\u003eHeading 2\u003c/h2\u003e \u003ch3\u003eHeading 3\u003c/h3\u003e \u003ch4\u003eHeading 4\u003c/h4\u003e \u003ch5\u003eHeading 5\u003c/h5\u003e \u003ch6\u003eHeading 6\u003c/h6\u003e \u003cp\u003eHello\u003c/p\u003e   Dies führt zu folgendem Ergebnis:\nEs gibt also Tags für Titel erster bis sechste Stufe. Grundsätzlich gilt, je kleiner die Zahl der Stufe, je grösser wird der Titel dargestellt. Das obrige Ergebnis zeigt, wie Titel per Default gestylt werden. Du kannst das Styling dieser Titel selbstverständlich anpassen (kommt im CSS-Teil).\nParagrafen Du hast bereits erfahren, dass Zeilenumbrüche in HTML keine Wirkung haben. Möchtest du eine neue Zeile einfügen, könnte dir das \u003cbr/\u003e-Tag weiterhelfen. Besser ist aber, wenn du den Text, der zusammengehört, auch entsprechend markierst: Das kannst du mit dem \u003cp\u003e-Tag erreichen. Der Text, der innerhalb dieses Tags steht, wird in einem gleichen Abschnitt dargestellt. Ausserdem trennt es diesen Inhalt mit Leerschlag zum nächsten Element. Das wird im folgenden Beispiel verdeutlicht:\n1 2 3 4 5  \u003ch2\u003eTitle\u003c/h2\u003e This is one line. This the second one. \u003cbr/\u003e And the third one. \u003cp\u003eAnd this is inside a paragraph.\u003c/p\u003e \u003cp\u003eThis too.\u003c/p\u003e   Title  This is one line. This the second one.  And the third one.\nAnd this is inside a paragraph.\nThis too.\n Beachte hier, dass \u003cp\u003e-Tags mehr Leerraum erzeugen als \u003cbr/\u003e.\nText formatieren Du wirst in die Situation kommen, wo du einen bestimmten Teil eines Textes z.B. fett oder kursiv formatieren musst.\nDas kannst du mit HTML sehr einfach erreichen, denn dafür gibt es spezielle Tags:\n1 2 3 4 5 6 7 8 9 10  \u003cp\u003e \u003cstrong\u003eHeared\u003c/strong\u003e about the new restaurant called \u003cem\u003eKarma?\u003c/em\u003e \u003c/p\u003e \u003cp\u003e There's \u003cb\u003eno menu\u003c/b\u003e: You get what you \u003ci\u003edeserve\u003c/i\u003e. \u003c/p\u003e   Um also einen bestimmten Text fett darzustellen, kannst du es in ein \u003cstrong\u003e- oder \u003cb\u003e-Element schmeissen. Beide Tags MACHEN im Prinzip genau das Gleiche, MEINEN aber nicht zwingend das Gleiche: \u003cb\u003e-Elemente sind einfach fett-gedruckt, während \u003cstrong\u003e-Elemente betont sein sollen. \u003cstrong\u003e soll dem fett-gedruckten Wort also mehr Ausdruck verleihen. Mit einem eigenen Styling (kommt im CSS-Teil) könntest du \u003cstrong\u003e-Elemente z.B. auch grösser oder rot darstellen. Mit einem \u003cb\u003e-Element sagt man im Prinzip nur, dass der Text fett-gedruckt sein soll.\nEinen Text kursiv darzustellen kannst du mit \u003ci\u003e bzw. \u003cem\u003e. Das Pendant zu \u003cb\u003e ist \u003ci\u003e (italic), und dasjenige zu \u003cstrong\u003e das \u003cem\u003e (emphasis = Betonung).\nDas obige Beispiel wird so gerendert:\n Heared about the new restaurant called Karma?  There's no menu: You get what you deserve.  Text zu formatieren ist Styling, was besser mit CSS statt HTML gemacht wird. Verwende diese Tags also mit Bedacht.\nLinks und Bilder Eines der wichtigsten Elemente in HTML sind Links auf andere Seiten. Links werden mit a-Elementen (anchor) realisiert. Einen Link kannn wie folgt erstellt werden:\n1  \u003ca href=\"https://www.sbb.ch/\"\u003eHome\u003c/a\u003e   Probiere das einmal aus.\nDu wirst einen blauen und unterstrichenen Text “Home” sehen. \u003ca\u003e ist der Tag, der generell für Hyperlinks verwendet wird. href ist ein Attribut des a-Tags, mit dem die URL des Links spezifiziert wird. In unserem Fall ist https://www.sbb.ch/ die URL, die beim Klick aufgerufen wird. Home ist der Text, der dem User angezeigt wird.\nZiemlich ähnlich kannst du auch ein Bild aus dem Internet einbinden:\n1 2 3  \u003cimg src=\"https://it-ninjas.ch/img/png/Ninja%20Elements_ninja_phone.png\" alt=\"IT Ninjas\" width=\"300\" /\u003e   Ganz offensichtlich wird das \u003cimg/\u003e-Tag (Image) für Bilder verwendet. Das \u003cimg/\u003e-Tag ist ein Tag, welches keinen Inhalt zwischen Opening- und Closing-Tag hat. Mit dem / im Opening-Tag kann man symbolisieren, dass das Tag ohne Closing-Tag geschlossen wird.\nDas wichtigste Attribut im img-Tag ist src (source = Quelle). Als src wird eine URL zu einem Bild erwartet. Vergiss bei absoluten Pfaden (wird später noch erklärt) nicht das Protokoll (also https://) anzugeben. Nicht zwingend aber erwartet ist auch das alt-Attribut (alternative). Dieser Text wird angezeigt, wenn das Bild nicht geladen werden konnte. Optional sind hingegen Attribute wie width oder height, welche die Breite und Höhe des Bildes festlegen. Diese Grössen werden aber besser mit CSS spezifiziert, da CSS genauere Spezifikationen zulässt (also nicht nur in ‘Pixel’ sondern auch anderen Einheiten).\nWenn du willst, dass man beim Klick auf ein Bild weitergeleitet wird, kannst du dein Bild in ein \u003ca\u003e-Element schmeissen:\n1 2 3  \u003ca href=\"https://it-ninjas.ch/\"\u003e \u003cimg src=\"https://it-ninjas.ch/img/png/Ninja%20Elements_ninja_phone.png\" alt=\"IT Ninjas\" /\u003e \u003c/a\u003e   Listen In HTML gibt es verschiedene Arten, um Aufzählungen darzustellen. Wir schauen uns Bullet-Point-Listen, Nummerierte-Listen und Definitions-Listen an.\nEine Bullet-Point-Liste kann man mit einer unsortierten Liste (unordered list) kreieren:\n1 2 3 4 5 6  \u003ch4\u003eWhat do you do in case of emergency?\u003c/h4\u003e \u003cul\u003e \u003cli\u003egit commit -m \"message\"\u003c/li\u003e \u003cli\u003egit push\u003c/li\u003e \u003cli\u003eLeave the building.\u003c/li\u003e \u003c/ul\u003e   Möchtest du hingegen eine Nummerierung, dann verwende eine sortierte Liste (ordered list):\n1 2 3 4 5 6 7 8  \u003ch4\u003eMost Difficult Programming Languages\u003c/h4\u003e \u003col\u003e \u003cli\u003eBrainfuck\u003c/li\u003e \u003cli\u003eCow\u003c/li\u003e \u003cli\u003eIntercal\u003c/li\u003e \u003cli\u003eMalbolge\u003c/li\u003e \u003cli\u003eWhitespace\u003c/li\u003e \u003c/ol\u003e   Das Ganze sieht dann ungefähr so aus:\nWhat do you do in case of emergency?  git commit -m “message” git push Leave the building  Most Difficult Programming Languages  Brainfuck Cow Intercal Malbolge Whitespace   Eine 3. Art von Listen sind Definitionslisten. Diese Art von Liste wird zwar nicht oft verwendet, kann aber hilfreich für ein Glossar oder ähnliches sein. Schaue dir dieses Beispiel an:\n1 2 3 4 5 6 7 8 9  \u003ch2\u003eGlossary\u003c/h4\u003e \u003cdl\u003e \u003cdt\u003ebuffoonish\u003c/dt\u003e \u003cdd\u003elike a clown \u003c/dd\u003e \u003cdt\u003eheyday\u003c/dt\u003e \u003cdd\u003ethe period of greatest prosperity or productivity\u003c/dd\u003e \u003c/dl\u003e   Glossary  buffoonish like a clown  heyday the period of greatest\u000bprosperity or productivity   Todo relative Links\n","categories":"","description":"HTML unterstützt sehr viele Tags. Auf dieser Seite wirst du die wichtigsten kennenlernen.\n","excerpt":"HTML unterstützt sehr viele Tags. Auf dieser Seite wirst du die …","ref":"/docs/web/html_css/04_weitere_tags/","tags":"","title":"Weitere HTML-Tags"},{"body":"Ein Angular Component setzt sich aus 4 Dateien zusammen:\n Template Unit Test File Stylesheet Component (Class)  Templates Was ist ein Template?  Templates definieren die Views der Components. Ein Template ist ein HTML Dokument, das Angular Elemente zum Rendern des Components enthält Dank Angular kann unser HTML Dokument anhand von Direktiven mehr Logik beinhalten.\nBeispielsweise können wir im Template eine if-Kontrollstruktur wie folgt anwenden:  1 2  \u003cdiv *ngIf=\"condition; else elseBlock\"\u003eContent to render when condition is true.\u003c/div\u003e \u003cng-template #elseBlock\u003eContent to render when condition is false.\u003c/ng-template\u003e   Welche weiteren Direktiven es gibt, könnt ihr in der offiziellen Dokumentation unter dem Abschnitt Directives nachlesen.\n","categories":"","description":"Components sind wie Grundbausteine in einer Angular-Applikation. Componentswerden mit dem \"@Component\" Decorator definiert.\nComponents sind TypeScript Klassen, die die Daten und Kontrollstrukturen zum Verhalten der Templates beinhalten. Metadaten teilen Angular mit, wie die Components verarbeitet werden sollen (selector, template, style). Ein Component hat einen von Angular verwalteten Lifecycle. Angular erstellt und rendert Components zusammen mit ihren Children, überprüft, wann sich ihre Properties ändern, und zerstört sie, bevor sie aus dem DOM entfernt werden. Angular bietet sogenannte Lifecycle-Hooks an, mit denen wir handeln können, sobald sie auftreten.\n","excerpt":"Components sind wie Grundbausteine in einer Angular-Applikation. …","ref":"/docs/web/angular/04_2_components_und_templates/","tags":"","title":"Components und Templates"},{"body":"","categories":"","description":"Angular lernen\n","excerpt":"Angular lernen\n","ref":"/docs/web/angular/","tags":"","title":"Angular"},{"body":"1: Introduction TODO: Beschreibung zu diesem Kapitel\n","categories":"","description":"Web Technologie lernen\n","excerpt":"Web Technologie lernen\n","ref":"/docs/web/","tags":"","title":"Web"},{"body":"Nachdem du die Basics von git gelernt hast, ist es Zeit dich weiter zu vertiefen.\nInhalt  Stash Cherry Pick Tag Alias  Stash Was ist stash? Mit git stash ist es möglich Änderungen zwischenzuspeichern und diese später abzurufen. Nach dem stashen kannst du an anderen Dateien arbeiten bis du die zwischengespeicherten Daten problemlos wieder abrufen kannst.\nWie funktioniert stash? Um Dateien zu stashen wird der folgende Befehl verwendet:\n1  git stash   Um Dateien im Anschluss abzurufen wird der folgende Befehl verwendet:\n1  git stash pop   Mit git stash pop werden alle Änderungen des stashes gelöscht und der ursprünglichen Datei hinzugefügt.\nDie Alternative dazu ist:\n1  git stash apply   Mit git stash apply werden die änderungen ebenfalls übernommen, der Unterschied zu git stash pop liegt darin das stash apply die Dateien nicht aus dem Stash löscht, dies kann nützlich sein, wenn dieselbe Änderung mehreren Branches hinzugefügt werden soll.\nSquash Was ist Squash squash in Git meint mehrere Commits zu vereinen. Squash wird meistens benutzt, wenn Branches gemerged werden. An dieser Stelle ist es jedoch wichtig zu erwähnen das es keinen git squash Befehl gibt.\nWie funktioniert squash? Es gibt verschiedene Wege um Commits zu squashen. Zum Beispiel gibt es die Methode des manuellen squashens, dazu wird das Interactive rebase feature von Git genutzt. Um die Interactive Rebase session zu starten wird der folgende Befehl verwendet:\n1  git rebase -i HEAD~3   Danach öffnet sich ein Editor der die letzten n Commits anzeigt, n wird durch die Zahl nach dem “~” definiert. Um jetzt die Commits zu squashen muss das pick zu beginn der zeile mit squash ersetzt werden. Jetzt werden alle Commits mit dem squash Schlüsselwort an den obersten Commit hinzugefügt.\nWieso sollte man Squashen: Angenommen du beendest die Arbeit an einem Featurebranch und willst diese in den Main branch mergen, jedoch enthält der Featurebranch viele Commits die nicht zwingend im Mainbranch aufgeführt werden sollen, in diesem Fall eignet sich das squashen, um diese Commits zusammenzufassen.\nMerge/Pull Requests Was ist der Unterschied zwischen einer Merge Request und einer Pull Request? Beide Begriffe meinen dasselbe, werden jedoch mit einer anderen Plattform assoziiert. Der Begriff Merge Request wird im Zusammenhang mit GitLab verwendet. Im Zusammenhang mit GitHub wird jedoch der Begriff Pull Request verwendet. Der Einfachheit wird im folgenden Text nur von Pull Request gesprochen.\nWas ist eine Pull Request bzw. eine Merge Request? In ihrer einfachsten Form sind Pull-Requests eine Funktion für Entwickler die andere Teammitglieder darüber informiert, dass ein Feature fertiggestellt wurde. Dies lässt alle Beteiligten wissen, dass der Code bereit für eine überprüfung ist und danach in Hauptzweig eingeführt werden kann.\nWie kann eine Pull Request erstellt werden (IntelliJ) Um eine Pull Request direkt aus Intelij zu erstellen, muss zuerst sichergestellt werden das man selber berechtigt ist eine Pull Request zu erstellen. Sind diese Berechtigungen vorhanden, kann die Pull Request in wenigen Schritten erstellt werden. Oben Links in IntelliJ befindet sich einen Button der mit Pull Request beschriftet ist. Danach öffnet sich ein Fenster in dem ausgewählt werden kann, welchen der lokalen Branches in das Ziel Repo gemerged werden soll. Danach muss nach noch einen Titel festgelegt werden. Es besteht ebenfalls die Möglichkeit eine Beschreibung hinzuzufügen, dies ist jedoch nur optional. Im Anschluss besteht die Möglichkeit einen Reviewer hinzuzufügen. Jetzt kann die Pull Request erstellt werden.\nWie kann eine Pull Request erstellt werden (Github) Um eine Pull Request direkt von GitHub aus zu senden, muss zuerst der Reiter Pull Request ausgewählt werden, Jetzt stehen verschiedene Möglichkeiten zu Auswahl, in unserem Fall wollen wir aber nur eine neue Pull Request erstellen. Im Anschluss erscheint ein neues Panel, das wichtigste dabei ist die Wahl des richtigen source und target branches. Als nächstes kann noch ein Name und eine Beschreibung für die Pull Request gesetzt werden. Wie in IntelliJ besteht auch hier die Möglichkeit einen Reviewer hinzuzufügen, der Button dazu befindet sich mittig auf der linken Seite. Da nun alle Einstellungen vorgenommen wurden, kann die Pull Request erstellt werden.\nCherry Pick Was ist Cherry-Pick ? git cherry-pick ist ein Befehl welcher es ermöglicht beliebige Git-Commits per Referenz anzusprechen und diese an den momentanen Arbeitskopf (HEAD) anzuheften. git cherry-pick kann sehr nützlich für das rückgängig Machen von Änderungen sein.\nZum Beispiel: Ein Commit ist aus Versehen im falschen Branch. Nun kannst du zum korrekten Branch wechselt und brauchst git cherry-pick um den Commit am richtigen Ort zu befestigen.\nWie funktioniert Cherry-Pick ? Um Cherry Pick anzuwenden gibt man folgenden Befehl ein:\n1  git cherry-pick \u003ccommit-hash\u003e   Der  muss natürlich noch mit dem korrekten Hash des Commits ersetzt werden, welchen man verschieben will. Anschliessend wird der Commit an den Branch angeheftet, auf dem man sich gerade befindet. Darum Achtung!: Immer zuerst kontrollieren ob man derzeit auch wirklich auf dem korrekten Branch ist.\nTag Was sind Tags ? Tags sind Referenzen, welche an einen bestimmten Punkt der History zeigen. Tagging wird üblicherweise benutzt um wichtige Ereignisse wie z.B. das Release einer Applikation festzuhalten. Ein Tag ist etwas ähnliches wie ein Branch, nur das ein Tag sich nicht verändert. Anders als ein Branch, kann ein Tag nach dem Erstellen keine weiteren Commits beinhalten.\nWie funktionieren Tags ? Um ein Tag zu erstellen wird folgender Befehl benötigt:\n1  git tag \u003ctagname\u003e   Wobei der  auch wieder durch den gewünschten String ersetzt werden muss. Will man zusätzlich zum Tag eine Beschriftung hinzufügen, macht man das mit:\n1  git tag \u003ctagname\u003e -a   Damit wird ein annotated tag erstellt.\nAuch wichtig anzumerken: Wenn du normal auf den Branch pushst, werden die Tags nicht standardmässig mitgepusht. Dazu brauchst du dann:\n1  git push origin --tags   Willst du nur ein einzelnes Tag pushen, brauche:\n1  git push origin \u003ctag\u003e   Alias Was sind Aliasse ? Ein Git-Alias ist zu vergleichen mit einem Shortcut. Aliasse werden z.b. auch beim Arbeiten mit der Bash-Konsole eingesetzt. Aliase werden gebraucht um kürzere Befehle zu realisieren. Sie ermöglichen effizienteres Programmieren.\nNehmen wir zum Beispiel den git-checkout Befehl. Dieser Befehl wird häufig verwendet und muss immer wieder neu eingetippt werden. Mit den Git-Aliassen jedoch kann man git-checkout z.B. in git.co verwandeln. Dies spart enorme Schreibarbeit über längere Zeit und verliert dennoch nicht an Wirksamkeit.\nWie funktionieren Aliasse? Um Aliasse festzulegen, müssen wir diese in der gitconfig-Datei definieren. Dort erstellen wir das Stichwort [alias]. Danach könnte das etwa so aussehen:\n1 2 3  [alias] st = status ci = commit -v   Die Aliasse können beliebig definiert werden, Ziel davon soll nur sein, die Schreibarbeit zu minimieren und das eigene Programmieren praktischer zu machen.\nGitg Was ist Gitg Gitg ist eine grafische Benutzeroberfläche für git. Es zielt darauf ab, ein kleines, schnelles und bequemes Werkzeug zu sein, um Git-Repositories zu visualisieren. Neben der Visualisierung bietet Gitg auch einfache Möglichkeiten zur Verwaltung eines Repositorys. Jedoch bietet IntelliJ standardmässig die dieselben Möglichkeiten, sollte man jedoch eine IDE ohne Git integration verwenden ist gitg ein praktisches Tool.\nInstallationsanleitung Unter Linux kann gitg mit folgendem Befehl installieren: sudo apt install gitg\nLeider ist git unter Windows nicht verfügbar. Eine empfehlenswerte Alternative dazu ist der offizielle GitHub Client.\nGithub Client Was ist der GitHub Client Der GitHub Client ist ein Windows Programm für die Verwaltung von Git Repositorys. Der GitHub Client funktioniert am besten mit GitHub repositorys, das bedeutet aber nicht das dieser keine Repositorys von anderen Quellen unterstützt. Es ist lediglich ein wenig aufwändiger Repositorys aus anderen Quellen einzubinden.\nInstallationsanleitung Unter Windows kann der GitHub Client auf der folgenden Seite heruntergeladen werden: https://desktop.github.com/ Unter Linux der Client mithilfe des folgenden Scripts heruntergeladen werden: https://gist.github.com/berkorbay/6feda478a00b0432d13f1fc0a50467f1\nGit Blame Was ist Git-Blame? Ist ein Befehl, welcher dazu dient den Author der letzten Änderung anzuzeigen. Deswegen auch git “blame”. Man “blamed” den Verfasser der letzten Änderung für seinen Fehler (falls er einen gemacht hat).\nWie funktioniert Git-Blame? Um git blame anzuwenden braucht es nicht viel:\n1  git blame \u003cfilename\u003e   Und schon haben wir den Verantwortlichen für die letzte Änderung an einem unserer Files. Jedoch bietet git blame auch andere Anwendungsmöglichkeiten:\n1  git blame -L 1,5 \u003cfilename\u003e   Hier zum Beispiel definieren wir eine Range von der Zeile 1 bis zur Zeile 5. Oder hier, noch eine weitere Variante:\n1  git blame -e \u003cfilename\u003e   Die Option -e zeigt uns anstatt des usernames des Authors, direkt die E-mail Adresse von ihm, so dass wir gerade Kontakt aufnehmen können.\nZum Schluss haben wir noch die -w Option\n1  git blame -w \u003cfilename\u003e   Dieser Befehl ignoriert wenn ein Author nur Leerschläge geändert hat. Das hat den Vorteil, dass wir nur die Authoren bekommen, welche auch wirklich etwas am Code selbst geändert und ihn nicht nur formatiert haben.\nBlobs und Trees Was sind Blobs und Trees show? Zuerst zu den Blobs: Blobs werden benutzt, um die Inhalte einzelner Dateien zu speichern. Trees wiederum beinhalten Referenzen zu anderen Blobs oder Unterbäumen.\nWozu braucht es sie? Wenn man eine Datei staged wird eine Blob-Datei erstellt. Dieser Blob hat den Inhalt der Datei und hat den Typ “blob”. Ein Blob eigentlich der Inhalt der Datei an einer bestimmten Instanz. Die verschiedenen Blobs fallen danach unter einen Tree.\nNun bildet sich hier eine Kette: Das Commit-Objekt greift auf die Tree-Objekte zu. Diese wiederum geben uns die Blob-Objekte zurück. Deshalb brauchen wir diese Konstellation also. Ohne die Trees und Blobs hätten wir keinen Zugriff auf die Inhalte unserer Dateien mehr.\nIm Diagramm kann die Abhängigkeit dementsprechend besichtigt werden. ","categories":"","description":"","excerpt":"Nachdem du die Basics von git gelernt hast, ist es Zeit dich weiter zu …","ref":"/docs/git/git-extended/","tags":"","title":"Git Erweitert"},{"body":"java.util.HashMap Eine Map verwendet man, um Zuweisungen zu speichern. Die java.util.HashMap ist die gebräuchlichste Map. Man könnte zum Beispiel ein Register mit Postleitzahlen (PLZ) und den dazugehörigen Orten speichern. Die PLZ ist der Schlüssel und der Ort ist der zugewiesene Wert.\nEine Zuweisung besteht aus einem Schlüssel (Key) und einem Wert (Value).  Dabei ist der Schlüssel immer eindeutig. Speichert man zwei Zuweisungen mit dem gleichen Schlüssel, so wird die erste Zuweisung überschrieben.\nBei der Benennung eine Map versucht man die Zuweisung zu beschreiben:\nplzToCityMap –\u003e PLZ zu City Zuweisung\nMethodenübersicht 1 2 3 4 5 6 7 8 9 10 11 12 13  Map\u003cInteger, String\u003e plzToCityMap = new HashMap\u003c\u003e(); plzToCityMap.put(3000, \"Zürich\"); plzToCityMap.put(3000, \"Bern\"); plzToCityMap.put(3011, \"Bern\"); plzToCityMap.put(1234, \"Vessy\"); plzToCityMap.put(3920, \"Zermatt\"); System.out.println(plzToCityMap.size()); // Output: 4 System.out.println(plzToCityMap.get(3000)); // Output: Bern System.out.println(plzToCityMap.containsKey(1234)); // Output: true System.out.println(plzToCityMap.containsValue(\"Zürich\")); // Output: false System.out.println(plzToCityMap.containsValue(\"Zermatt\")); // Output: true    Die Map offeriert drei Collection Ansichten auf den gespeicherten Inhalt:\n keySet(): Set auf alle Schlüssel values(): Collection auf alle Werte entrySet(): Set auf alle Schlüssel-Werte Zuweisungen forEach(): Führt eine bestimmte Aktion über alle Elemente aus  Die Reihenfolge des Inhalts hängt von der Implementierung der Iteratoren ab, welche eine konkrete Map Klasse für die einzelnen Collection-Ansichten verwendet. Manche Implementation wie die TreeMap garantiert eine bestimmte Reihenfolge, andere wie die HashMap keine.\n Beispiel    Beispiel Für die Beispiele verwenden wir folgende HashMap:\n1 2 3 4 5 6 7  Map\u003cInteger, String\u003e plzToCityMap = new HashMap\u003c\u003e(); plzToCityMap.put(3000, \"Zürich\"); plzToCityMap.put(3000, \"Bern\"); plzToCityMap.put(3011, \"Bern\"); plzToCityMap.put(1234, \"Vessy\"); plzToCityMap.put(3920, \"Zermatt\");   Beispiel 1 - Auslesen der Schlüssel, Werte und Zuweisungen Mit der Methode keySet() kann man alle Schlüssel einer Map abfragen. Der Rückgabewert ist ein Set, welches wir bestens kennen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // Abfrage der Schlüssel mit einem Iterator: Iterator\u003cInteger\u003e plzIterator = plzToCityMap.keySet().iterator(); while(plzIterator.hasNext()) { System.out.println(plzIterator.next()); } // Abfrage der Schlüssel mit einer FOR Schleife: for (Integer plz : plzToCityMap.keySet()) { System.out.println(plz); } // Abfrage der Schlüssel mit einem Stream: plzToCityMap.keySet().stream() .forEach(plz -\u003e System.out.println(plz)); }   Ebenso kann man die Werte der Zuweisungen mit der Methode values() abfragen. Als Resultat erhält man eine Collection.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // Abfrage der Werte mit einem Iterator: Iterator\u003cString\u003e nameIterator = plzToCityMap.values().iterator(); while(nameIterator.hasNext()) { System.out.println(nameIterator.next()); } // Abfrage der Werte mit einer FOR Schleife: for (String name : plzToCityMap.values()){ System.out.println(name); } // Abfrage der Werte mit einem Stream: plzToCityMap.values().stream() .forEach(name -\u003e System.out.println(name)); } // Abfrage der Werte mit einem forEach: plzToCityMap.values().forEach(name -\u003e System.out.println(name))   Es besteht auch die Möglichkeit mit der Methode entrySet() die Zuweisungen mit Schlüssel und Wert abzufragen. Man erhält wieder ein Set.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // Abfrage der Zuweisungen mit einem Iterator: Iterator\u003cMap.Entry\u003cInteger, String\u003e\u003e plzCityIterator = plzToCityMap.entrySet().iterator(); while(plzCityIterator.hasNext()) { Map.Entry\u003cInteger, String\u003e entry = plzCityIterator.next(); System.out.println(entry.getKey() + \" : \" + entry.getValue()); } // Abfrage der Zuweisungen mit einer FOR Schleife: for (Map.Entry entry : plzToCityMap.entrySet()) { System.out.println(entry.getKey() + \" : \" + entry.getValue()); } // Abfrage der Zuweisungen mit einem Stream: plzToCityMap.entrySet().stream() .forEach(plzCity -\u003e System.out.println(plzCity.getKey() + \" : \" + plzCity.getValue())); // Abfrage der Zuweisungen mit einem forEach: plzToCityMap.forEach((plz, city) -\u003e System.out.println(plz + \" : \" + city));     Aufgaben    Aufgaben Aufgaben zu Modul #J7 - Java Collections - Map\n","categories":"","description":"Die gebräuchlichste Umsetzung einer Map: HashMap.\n","excerpt":"Die gebräuchlichste Umsetzung einer Map: HashMap.\n","ref":"/docs/java/java-collections/04_map/","tags":"","title":"HashMap"},{"body":"Ziele  Ich kann Namen für Objekte in einem Text identifizieren Ich kann gute Namen für Attribute und Methoden wählen Ich kann Objekte erstellen und ihnen entsprechende Eigenschaften geben Ich kann Objekte untereinander verknüpfen  Immobilienfirma In dieser Aufgabe soll eine Immobilienfirma mit Objekten abgebildet werden. Eine solche Firma besitzt beliebige Immobilien und hat einen Firmensitz an einer bestimmten Adresse. Die Firma hat diverse Angestellte und einen Namen. Eine Immobilie kann aus diversen Wohnungen bestehen, welche vermietet werden. Eine Immobilie hat eine bestimmte Adresse und ein Angestellter der Firma ist der Immobilie als Abwart zugeteilt. Ein Angestellter der Firma ist zudem der Verwalter einer solchen Immobilie. Eine Wohnung befindet sich in einem bestimmten Stockwerk, besitzt eine Wohnungsnummer und eine Beschreibung. Wenn ein Mieter in eine Wohnung einzieht, so gibt es zwischen Firma und Mieter einen Vertrag für eine bestimmte Wohnung. Jeder Vertrag hat ein Start- und ein End-Datum, zudem regelt der Vertrag den monatlichen Preis für eine Wohnung. Die Standardangaben für eine Person werden durch ein Geburtsdatum und ein Geschlecht ergänzt.\nTeil 1 Ermittle aus dem Text oben die verschiedenen Objekte und ihre Eigenschaften. Verknüpfe dann die Objekte miteinander, zum Beispiel hat eine Immobilienfirma eine Adresse als Firmensitz.\nTeil 2 Erstelle für deine Firma mindestens zwei Immobilien mit unterschiedlichen Wohnungen. Definiere Angestellte und Abwarte. Erstelle Mieter und Verträge.\nTeil 3 Erstelle für die Firma die folgenden Funktionen:\n Ermittle die total Anzahl an Wohnungen von allen Immobilien Ermittle den Abwart für eine bestimmte Wohnung Ermittle die Verträge für eine bestimmte Immobilie Ermittle die leeren Wohnungen für eine bestimmte Immobilie Ermittle die Verträge, die im nächsten Monat ablaufen Ermittle alle Verträge sortiert nach Personen (eine Person kann mehrere Wohnungen mieten) Ermittle das monatliche Einkommen pro Immobilie Ermittle das jährliche Einkommen der Firma (ein Vertrag kann während dem Jahr ablaufen)  ","categories":"","description":"Aufgabe zu Modul #J2 - OOP - Immobilienfirma\n","excerpt":"Aufgabe zu Modul #J2 - OOP - Immobilienfirma\n","ref":"/labs/java/java-oop/04_immofirma/","tags":"","title":"Immobilienfirma"},{"body":"","categories":"","description":"Exercises zu Modul #J2 - Generics I\n","excerpt":"Exercises zu Modul #J2 - Generics I\n","ref":"/labs/java/java-generics/","tags":"","title":"Java Exercises - Generics I"},{"body":"Ziele  Ich verstehe, wie eine Klasse aufgebaut ist Ich verstehe den Unterschied zwischen einer Klasse und einem Objekt Ich weiss, was Datenfelder sind und verstehe den Unterschied zwischen statischen und nicht-statischen Feldern Ich weiss, was ein Konstruktor ist Ich kann Objekte instanziieren (erzeugen) Ich kann Getter- und Setter-Methoden schreiben Ich kenne die Zugriffsmodifikatoren ‘public’, ‘private’ und ‘protected’ Ich weiss, dass Instanzvariablen immer mit dem Schlüsselwort ‘private’ deklariert werden Ich kenne die Methoden equals() und hashCode() und weiss unter welchen Umständen und wie ich diese überschreiben soll Ich weiss was ein Enum ist und wann es benötigt wird Ich kann Enums sinnvoll einsetzen Ich kann Methoden und Konstruktoren in Enums anwenden   Einführung In der realen Welt können wir viele Objekte um uns herum finden, wie Autos, Gebäude und Menschen. Alle diese Objekte haben einen bestimmten Zustand und ein bestimmtes Verhalten. Wenn wir ein Auto betrachten so könnte sein Zustand einen Markennamen, eine bestimmte Geschwindigkeit oder den zu tankenden Kraftstoff enthalten. Mögliche Verhaltensweisen eines Autos sind normalerweise fahren und einparken.\nDefinitionen Klasse Unter einer Klasse versteht man in der objektorientierten Programmierung ein abstraktes Modell bzw. einen Bauplan für eine Reihe von ähnlichen Objekten. Die Klasse dient als Bauplan für die Abbildung von realen Objekten in Softwareobjekte und beschreibt Attribute (Eigenschaften) und Methoden (Verhaltensweisen) der Objekte.\nObjekt Ein Objekt bezeichnet in der objektorientierten Programmierung ein Exemplar eines bestimmten Datentyps oder einer bestimmter Klasse. Objekte sind konkrete Ausprägungen (=Instanzen) einer Klasse und werden zur Laufzeit erzeugt (Instanziierung).\nDatenfelder Datenfelder (Attribute) enthalten Informationen, die für Objekte dieser Klasse relevant sind. Ein Auto hat eine Höchstgeschwindigkeit, eine bestimmte Anzahl von Sitzen, usw. Das heisst, ein Feld ist eine Variable, in der Daten gespeichert werden können. Es kann einen beliebigen Typ haben, einschließlich primitiver Typen (int, float, boolean usw.) und Klassen. Eine Klasse kann auch sich selber als Feld enthalten. Eine Klasse kann beliebig viele Felder haben\nMethoden Methoden dienen dazu, den Zustand eines Objekts zu verändern. Refuel() (siehe Klassendiagramm unten) füllt beispielsweise den Tank, bis dessen Kapazität erreicht wird. Klassen werden verwendet, um benutzerdefinierte Datentypen zu erstellen. Beginnen wir mit einem Beispiel einer Auto-Klasse, hier siehst du das UML-Klassendiagramm der Klasse Car:\n   class Car     - topSpeed: int   - totalSeats: int   - fuelCapacity: int   - manufacturer: String   + refuel(): void   + park(): void   + drive(): void     Klassen und Objekte im Schnelldurchlauf Klassen deklarieren Klassenkopf: Eine neue Klasse wird mit dem Keyword class gefolgt vom Namen der Klasse deklariert. So kannst du beispielsweise eine Klasse mit dem Namen Nothing erstellen:\n1 2 3  public class Nothing { }   Der Block kann Felder, Methoden und Konstruktoren enthalten. Felder speichern Daten, Methoden definieren das Verhalten und Konstruktoren ermöglichen es uns, neue Objekte der Klasse zu erstellen und zu initialisieren. Felder und Methoden gelten als Klassenmitglieder (class members).\nDer Quellcode einer Klasse wird in eine .java-Datei eingefügt. Normalerweise enthält eine Quellcodedatei nur eine Klasse und hat denselben Namen wie diese Klasse. Manchmal kann eine Datei jedoch auch mehrere Klassen enthalten, jedoch darf es nur eine öffentliche (public) Klasse pro Datei geben. Deren Name muss mit dem Dateinamen übereinstimmen.\nPatient.java\n1 2 3 4 5 6  public class Patient { String name; // Feld bzw. Instanzvariable vom Datentyp String mit dem Bezeichner 'name'  int age; // Feld bzw. Instanzvariable vom Datentyp int mit dem Bezeichner 'age'  float size; // Feld bzw. Instanzvariable vom Datentyp float mit dem Bezeichner 'size'  String[] complaints; // ein Feld kann auch ein Array sein }   Diese Klasse repräsentiert einen Patienten in einem Krankenhausinformationssystem. Sie verfügt über vier Felder: name, age, size und complaints. Alle Objekte der Klasse Patient haben dieselben Felder, aber ihre Werte können für jedes Objekt unterschiedlich sein.\nObjekte erstellen Wir können eine Instanz der Klasse Patient mit dem Operator new erstellen:\n1  Patient patient = new Patient();   Wenn du ein neues Objekt erstellst, wird jedes Feld mit dem Standardwert des entsprechenden Typs initialisiert (insofern du keinen Konstruktor mit Argumenten verwendest, dazu aber später mehr). Wenn die Instanzvariablen eines Objektes nicht mit einem Zugriffsmodifikator wie private versehen sind (dazu unten mehr), können wir mittels Punkt-Operator auf die Variablen des Objekts zugreifen:\n1 2  System.out.println(patient.name); // es wird null ausgeben System.out.println(patient.age); // es wird 0 ausgeben   Das folgende Programm erstellt zwei Objekte der Klasse Patient und druckt die Informationen der Objekte aus.\nPatientDemo.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  public class PatientDemo { public static void main(String[] args) { // Wir erstellen einen neuen Patienten, alle Variablen werden mit ihren Standardwerten initialisiert  Patient john = new Patient(); // Wir greifen über den Punkt-Operator auf die Variablen zu und speichern Werte darin  john.name = \"John\"; john.age = 30; john.size = 180f; System.out.println(john.name + \" \" + john.age + \" \" + john.height); Patient alice = new Patient(); alice.name = \"Alice\"; alice.age = 22; alice.height = 165f; System.out.println(alice.name + \" \" + alice.age + \" \" + alice.height); } }   Patient.java\n1 2 3 4 5  class Patient { String name; int age; float size; }   Im obigen Code haben wir zwei Patienten erstellt, John und Alice, die Werte ihrer Felder definiert und dann die Informationen über sie ausgedruckt. Wir sehen, dass wir mit dem Punkt-Operator auf die Felder des Objekts zugreifen können (john.name = “John”). Allerdings soll hier erwähnt sein, dass das nur geht, wenn die Instanzvariablen nicht private sind (wir behandeln das Thema Zugriffsmodifikatoren weiter unten).\nVeränderungen an Objekten - Immutable \u0026 mutable objects In der Programmierung gibt es ein wichtiges Konzept, das Unveränderlichkeit genannt wird. Unveränderlichkeit bedeutet, dass ein Objekt immer dieselben Werte speichert. Wenn wir diese Werte ändern wollen, müssen wir ein neues Objekt erstellen. Das klassische Beispiel ist die Klasse String. Zeichenfolgen sind unveränderliche Objekte, sodass alle String-Operationen einen neuen String erzeugen.\n1 2 3 4 5  String alice = \"alice\"; alice.toUpperCase(); System.out.println(alice); // Output: alice --\u003e unveränderlich! String aliceCapitalLetters = alice.toUpperCase(); System.out.println(aliceCapitalLetters); // Output: ALICE   Die Klasse Patient ist nicht unveränderlich, da jedes Feld eines Objekts geändert werden kann.\n1 2 3  Patient patient = new Patient(); patient.name = \"Mary\"; patient.name = \"Alice\";   Referenzen teilen Objekte sind Referenztypen. In einer Variable wird also nicht das Objekt selbst, sondern die Speicheradresse hinterlegt, welche auf das Objekt zeigt. Es können sich also mehrere Referenzen auf dasselbe Objekt beziehen.\n1 2 3 4 5 6 7 8  Patient patient = new Patient(); patient.name = \"Mary\"; patient.age = 24; System.out.println(patient.name + \" \" + patient.age); // Mary 24  // Wir weisen der Variablen patient2 die Speicheradresse der Variablen patient zu Patient patient2 = patient; System.out.println(patient2.name + \" \" + patient2.age); // Mary 24   Es ist wichtig zu verstehen, dass sich die zwei Referenzen oben auf das gleiche Objekt im Speicher beziehen und nicht auf zwei unabhängige Kopien. Da unsere Klasse veränderbar ist, können wir das Objekt mit Hilfe beider Referenzen ändern.\n1 2  patient.age = 25; System.out.println(patient2.age); // 25    Packages Bevor wir uns intensiver mit den Bestandteilen einer Klasse auseinandersetzen, schauen wir uns Packages an. Ein Package dient der Gruppierung und Organisation von Klassen, Schnittstellen und anderen Packages. Es wird zwischen zwei Arten von Packages unterschieden:\n implizit importierte Packages explizit zu importierende Packages  Wenn wir beispielsweise die Klasse Scanner benötigen, müssen wir dies durch ein import Statement machen.\n1  import java.util.Scanner   Die Klasse Scanner befindet sich also im Package java und darin im Package util. Ein Package kann beliebig viele andere Packages enthalten. Ein Package wird auf dem Dateisystem als Verzeichnis behandelt.\nVorteile  Code-Organisation. Klassen von gleicher Natur (wie beispielsweise Modelle oder Services) befinden sich im gleichen Package Auffindbarkeit. Klassen sind durch die Organisation einfacher zu finden Vermeiden von Namenskonflikten. Zwei Klassen dürfen den gleichen Namen haben, solange sie in unterschiedlichen Packages liegen Zugriffsteuerung. Bestimmte Zugriffsmodifikatoren erlauben den Zugriff auf Klassen im gleichen Package  Namenskonventionen Gemäß der Namenskonvention werden Package-Namen immer in Kleinbuchstaben geschrieben. Die Trennung der verschiedenen Packages erfolgt beim Import-Statement durch einen Punkt.\nOrdnerstruktur Programmcode muss organisiert sein. Grundsätzlich legen wir Quellcode im einem Verzeichnis ab, das src genannt wird. Innerhalb dieses Verzeichnisses legen wir ein Verzeichnis main und ein Verzeichnis java an. Innerhalb des Java-Verzeichnisses können wir beliebig viele eigene Packages anlegen, um unseren Programmcode zu organisieren.\nKlassen mit gleichem Namen Es kann passieren, dass wir zwei Klassen haben, die den gleichen Namen haben. Beispiel: Wir arbeiten mit der externen Bibliothek Abstract Window Toolkit (AWT). Darin gibt es eine Klasse mit dem Namen Rectangle. Es ist natürlich erlaubt eine eigene Klasse mit diesem Namen anzulegen, solang sie sich nicht in einem Package mit dem gleichen Namen befindet.\n1 2 3 4 5 6 7 8 9 10 11 12  package ch.sbb.main; import ch.sbb.rectangle.Rectangle; public class Main { public static void main(String[] args) { java.awt.Rectangle rectAWT = new java.awt.Rectangle() // ...  Rectangle myRect = new Rectangle(); // ...  } }    Wir importieren die eigene Rectangle-Klasse mit der Import-Anweisung Wir deklarieren und initialisieren ein AWT-Rectangle, indem wir den vollständigen Namen (Package und Klassennamen) angeben  Import * Wenn sich zwei Klassen im selben Paket befinden und eine Klasse in der anderen verwendet wird, muss die Klasse nicht importiert werden. Es ist auch möglich, alle Klassen aus dem Paket zu importieren. Dazu müssen wir einen * anstelle eines bestimmten Klassennamens in das Import-Statement schreiben.\n1  import java.awt.*;   Package java.lang Obwohl wir die meisten Pakete importieren müssen, gibt es ein Java-Paket, das immer automatisch importiert wird. Es ist java.lang. Dieses Paket enthält viele weit verbreitete Klassen, wie String, System, Long, Integer, NullPointerException und andere.\nStatischer Import Wir können auch statische Elemente (Konstanten) einer Klasse in eine andere Klasse importieren. Wenn wir * in die import-Anweisung schreiben, müssen wir den importierten Klassennamen nicht angeben, bevor wir statische Methoden aufrufen oder statische Felder lesen. Hier ist ein Beispiel für den statischen Import der Klasse Arrays, die viele nützliche Methoden zur Verarbeitung von Arrays enthält:\n1 2 3 4 5 6 7 8 9 10 11  package org.hyperskill.java.packages.theory; import static java.util.Arrays.*; public class Main { public static void main(String[] args) { int[] numbers = { 10, 4, 5, 47, 5, 12 }; // an array  sort(numbers); // instead of writing Arrays.sort(...)  int[] copy = copyOf(numbers, numbers.length); // instead of writing Arrays.copyOf(...)  } }   Wenn wir bei der Implementation von Klassen keine Package-Anweisung schreiben, wird die Klasse ins Default-Package eingefügt. Dies sollte vermieden werden, da Klassen aus dem Default-Package nicht in andere Klasse importiert werden können, welche sich nicht auch im Default-Package befinden.\n Zugriffsmodifikatoren In Java können wir Feldern und Methoden Zugriffsbeschränkungen auferlegen. Diese Einschränkungen werden durch Zugriffsmodifikatoren festgelegt. Zugriffsmodifikatoren bestimmen die Sichtbarkeit von Feldern und Methoden und damit deren Verwendbarkeit aus anderen Programmteilen. Es gibt vier Zugriffsmodifikatoren.\nPrivate Auf eine private Instanzvariable oder -methode kann von ausserhalb der Klasse nicht zugegriffen werden. Es ist eine gängige Praxis, Instanzvariablen privat zu halten. Wir möchten schliesslich nicht, dass jemand unsere Daten direkt manipuliert. Dieses Prinzip nennt man auch Kapselung.\n1 2 3  class Person { private String name; }   UML-Symbol: -\nPublic Auf Variablen und Methoden, die mit dem Schlüsselwort public deklariert sind, kann von einem beliebigen Ort des Programms zugegriffen werden. Sie sind also öffentlich.\n1 2 3 4 5 6 7  class Person { private String name; public String getName() { return name; } }   Auf öffentliche Methoden und Felder kann ein Objekt über den Punkt-Operator zugreifen.\n1 2  Person p = new Person(); c.getName();   UML-Symbol: +\nProtected Wenn eine Variable oder Methode protected deklariert ist, dann kann nur vom gleichen Package oder von Unterklassen darauf zugegriffen werden (Unterklassen bzw. Vererbung folgt im Modul «Objektorientiertes Design»). UML-Symbol: #\nPackage-Private Wenn eine Variable oder Methode keinen Zugriffsmodifikator hat, so besitzt sie trotzdem einen. Dieser wird Package-Private genannt. Die Sichtbarkeit ist grundsätzlich private, wird aber auf Klasse im gleichen Package ausgeweitet.\nZusammenfassung    Modifikator Eigene Klasse Klasse im gleichen Package / innere-Klassen Unterklassen Sonstige Klassen     private ja nein nein nein   public ja ja ja ja   protected ja ja ja nein   ohne / package ja ja nein nein     Felder Wir haben bereits verschiedene Arten von Variablen kennengelernt:\n Variablen in einer Methode oder einem Codeblock - diese werden als lokale Variablen bezeichnet Variablen in Methodendeklarationen oder Konstruktoren - diese werden als Parameter bezeichnet Mitgliedsvariablen (member variables) in einer Klasse - diese werden als Felder oder Instanzvariablen bezeichnet  Wir werden uns nun den Feldern widmen. Felder sind Variablen, die innerhalb einer Klasse, aber außerhalb aller Methoden deklariert werden. Wir definieren sie üblicherweise am Anfang einer Klasse (vor den Methoden). Es gibt zwei verschiedene Typen von Feldern, statische und nicht-statische.\nStatische Felder - Klassenvariablen / Konstanten Manchmal brauchen wir eine Variable, die allen Objekten gemeinsam ist. Dann verwenden wir eine Variable, die mit Schlüsselwort static deklariert ist. Diese Variable bezeichnen wir als statisches Feld oder Klassenvariable. Ein statisches Feld ist der Klasse selbst zugeordnet und nicht den Referenzen dieser Klasse. Denn jede Instanz der Klasse teilt sich diese Klassenvariable, die sich an einem festen Ort im Speicher befindet. Egal wie viele Objekte dieser Klasse existieren, der Wert des statischen Feldes ist für alle exakt gleich. Jedes Objekt kann grundsätzlich den Wert einer Klassenvariablen lese und verändern.\n1 2 3 4 5 6 7 8 9 10 11  public class Counter { private static int count = 0; public static void main(String[] args) { Counter counter = new Counter(); counter.count++; // Erhöhen der Klassenvariable count über ein Objekt  System.out.println(count); // Output: 1  Counter.count++; // Erhöhen des statischen Feldes count über den Klassennamen (ohne Objekt!)  System.out.println(count); // Output: 2  } }   Angenommen, wir möchten eine Reihe von Bicycle-Objekten erstellen und jedem eine Seriennummer zuweisen, beginnend mit 1 für das erste Objekt. Diese ID-Nummer ist für jedes Objekt eindeutig und daher eine Instanzvariable (was Instanzvariablen sind, dazu kommen wir gleich). Um das zu realisieren, benötigen wir eine Variable, die die Anzahl Fahrräder (Anzahl erzeugter Bicycle-Instanzen) zählt. Vorsicht, diese Art von Implementation ist für mehrere Threads nicht geeignet. Da wir noch nichts von Multithreading wissen, genügt es zu wissen, dass diese Art der Implementation nicht thread-sicher ist.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  public class Bicycle { private int cadence; private int gear; private int speed; private int id; private static int numberOfBicycles = 0; // Klassenvariable, die zählt, wieviele Objekte erzeugt werden  // Diese spezielle Methode, Konstruktor genannt, wird benötigt, um Objekte zu instanzieren --\u003e siehe Kapitel Konstruktoren  public Bicycle(int startCadence, int startSpeed, int startGear) { this.gear = startGear; this.cadence = startCadence; this.speed = startSpeed; this.id = ++numberOfBicycles; // inkrementiere die Anzahl Fahrräder und weise den Wert der Instanzvariablen id zu  } }   Manchmal verwenden wir statische Felder, um Konstanten zu definieren. Eine Konstante ist eine Variable, deren Wert nicht mehr verändert werden kann, sobald man ihr einmal einen Wert zugewiesen hat. Um eine Variable als Konstante zu kennzeichnen, verwenden wir zusätzlich das Keyword final. Der Name der Konstante wird zudem immer in Grossbuchstaben geschrieben. Um mehrere Wörter abzutrennen verwenden wir den Underscore (_). Zum Beispiel definiert die folgende Variablendeklaration eine Konstante mit dem Namen PI:\n1  static final double PI = 3.141592653589793;   Nicht-statische Felder - Instanzvariablen Unter einer Instanzvariablen versteht man eine Variable, die einer Instanz einer Klasse, also einem Objekt, zugeordnet ist. Wenn eine neue Instanz erzeugt wird, werden Kopien der Instanzvariablen angelegt. Im Fall der Bicycle-Klasse sind die Instanzvariablen cadence, gear, speed und id. Jedes Bicycle-Objekt hat seine eigenen Werte für diese Variablen, d.h. sie werden an unterschiedlichen Orten gespeichert.\n Konstruktoren Konstruktoren sind spezielle Methoden, die benutzt werden sobald ein neues Objekt einer Klasse erstellt wird. Ein Konstruktor einer Klasse wird aufgerufen, wenn eine neue Instanz mit dem Schlüsselwort new erstellt wird. Ein Konstruktor unterscheidet sich von anderen Methoden darin, dass:\n er den gleichen Namen haben muss wie die Klasse, die ihn enthält er keinen Rückgabetyp (nicht einmal void) hat  Konstruktoren initialisieren Instanzen (Objekte) der Klasse. Sie können beliebige Parameter enthalten, um beispielsweise Instanzvariablen zu initialisieren.\nKonstruktoren verwenden Im folgenden Beispiel benutzen wir eine Klasse mit dem Namen Patient. Ein Objekt der Klasse hat einen Namen, ein Alter und eine Größe. Die Klasse verfügt über einen Konstruktor mit drei Parametern, um ein neues Objekt mit bestimmten Werten zu initialisieren.\n1 2 3 4 5 6 7 8 9 10 11  public class Patient { private String name; private int age; private float height; public Patient(String name, int age, float height) { this.name = name; this.age = age; this.height = height; } }   Der Konstruktor akzeptiert drei Parameter. Zum Initialisieren der Felder wird das Schlüsselwort this verwendet. Es ist ein Verweis auf die aktuelle Instanz der Klasse. Dieses Schlüsselwort ist nur erforderlich, wenn die Parameter des Konstruktors denselben Namen wie die Felder der Klasse haben (um sie voneinander unterscheiden zu können). Es ist aber allgemein Best Practices das Schlüsselwort this zu verwenden. Nun erstellen wir einige Objekte der Klasse Patient:\n1 2  Patient heinrich = new Patient(\"Heinrich\", 40, 182.0f); Patient mary = new Patient(\"Mary\", 33, 171.5f);   Jetzt haben wir zwei Objekte der Klasse Patient. Die beiden Referenzen heinrich und mary besitzen im Objekt die gleichen Felder, aber die Werte dieser Felder sind pro Objekt unterschiedlich.\nEine Klasse kann mehrere Konstruktoren enthalten, solange sich die Deklarationen der Konstruktoren unterscheiden. Zum Beispiel unterschiedliche Anzahl an Argumenten oder unterschiedliche Datentypen der Argumente.\nDefault Konstruktor Der Compiler stellt automatisch einen Standardkonstruktor ohne Argumente für jede Klasse ohne Konstruktor bereit (das heisst, wir können auch Objekte einer Klasse erstellen, deren Klassenkörper leer ist).\n1 2 3 4 5  public class Patient { private String name; private int age; private float height; }   Wir können eine Instanz der Klasse Patient mit dem Standardkonstruktor ohne Argumente erstellen.\n1  Patient patient = new Patient();   In diesem Fall werden alle Felder mit den Standardwerten ihrer Typen gefüllt. Wenn wir einen bestimmten Konstruktor definieren, wird der Standardkonstruktor nicht mehr automatisch erstellt. Wir können einen Konstruktor auch ohne Argumente definieren, aber damit Standardwerte für Felder einer Klasse festlegen. Zum Beispiel können wir das Feld name mit “Unknown” initialisieren. Durch eine solche Definition wird der Default-Konstruktor ersetzt.\n1 2 3 4 5 6 7 8 9  public class Patient { private String name; private int age; private float height; public Patient() { this.name = \"Unknown\"; } }   Zusammenfassung  Jede Java-Klasse verfügt über mindestens einen Konstruktor zum Initialisieren von Objekten Ein Konstruktor hat denselben Namen wie die Klasse, die ihn enthält Ein Konstruktor hat keinen Rückgabewert Wenn eine Klasse keine expliziten Konstruktoren hat, stellt der Java-Compiler automatisch einen Standardkonstruktor ohne Argumente bereit Wird ein eigener Konstruktor definiert, so entfällt der Standardkonstruktor   Initialisierungsblöcke Neben Konstruktoren gibt es noch zwei weitere Konstrukte, die der Initialisierung dienen. Statische und nicht-statische Initialisierungsblöcke. Diese sehen wie folgt aus:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  public class Car { static { // Statischer Initialisierungsblock \t} { // Instanzblock \t} public Car { // Konstruktor \t} }   Innerhalb dieser Initialisierungblöcke können ähnlich wie bei den Konstruktoren bestimmte Initialisierungen durchgeführt werden. Grundsätzlich können die beiden Blöcke beliebigen Programmcode enthalten. Die Reihenfolge bei der Erstellung eines neuen Objekts ist wie folgt:\n Statische Variablen Statische Initialisierungblöcke Instanzvariablen Instanzblöcke Konstruktoren  Eine Java-Klasse kann beliebig viele statische und nicht-statische Initialisierungsblöcke aufweisen. Die Reihenfolge des Aufrufs bei mehreren Blöcken richtet sich nach der Reihenfolge der Implementation.\nBeispiele\nNicht-statischer Initialisierungsblock: https://www.tutorialspoint.com/a-non-static-initialization-block-in-java\nStatischer Initialisierungblock: https://www.tutorialspoint.com/a-static-initialization-block-in-java\n Instanzmethoden Methoden werden benutzt, um Funktionen zur Verfügung zu stellen. Diese Funktionalitäten reichen von einfachen Änderungen am Zustand eines Objekts bis zu komplexen Algorithmen zur Berechnung von mathematischen Dingen. Hier passiert also die Magie in einer Applikation. Diese Methoden können also entweder den Inhalt von Datenfelder ändern oder ihre Werte verwenden, um eine bestimmte Berechnung durchzuführen. Der Zugriffsmodifizierer einer Methode sollte immer so restriktiv wie möglich gewählt werden.\nEine Methodendeklaration besteht aus bis zu sieben Komponenten:\n Zugriffsmodifikator. public, protected, private oder package-private Sonstige Modifikatoren. Beispielsweise static oder synchronized Rückgabewert. Der Datentyp des von der Methode zurückgegebenen Werts oder void, wenn die Methode keinen Wert zurückgibt Methodenname / Bezeichner Parameterliste in Klammern. Eine durch Kommas getrennte Liste von Eingabeparametern (Datentyp + Bezeichner). Wenn keine Parameter vorhanden sind, genügt die Angabe der beiden Klammern Exceptions. Dazu mehr später im Modul Exception Handling Methodenkörper.  Namenskonventionen für Methoden  Erster Buchstabe immer klein CamelCase sollten aus einem Verb und einem Nomen zusammengesetzt werden Möglichst aussagekräftige Namen Möglichst keine Abkürzungen  Getter und Setter Diese beiden Arten von Methoden sind in der objektorientierten Programmierung unverzichtbar. Eine get-Methode (Getter) ruft den Wert eines bestimmten Datenfelds ab, während eine set-Methode (Setter) ihren Wert verändert. Dies dient dem Prinzip der Kapselung und kann unter anderem dazu verwendet werden, ein bestimmtes Datenfeld read-only zu gestalten (wenn es keine Setter-Methode dazu gibt).\nNamenskonventionen Für Getter- und Setter-Methoden werden immer die gleichen Methodennamen verwendet. Als Präfix benutzen wir get und set gefolgt vom Namen des Datenfelds worauf sich die Methode bezieht.\n1 2 3 4 5 6 7 8 9 10 11  public class Car { private int speed; public int getSpeed() { return speed; } public void setSpeed(int speed) { this.speed = speed; } }   1 2 3 4 5 6 7  class Demo { public static void main(String[] args) { Car car = new Car(); car.setSpeed(100); System.out.println(car.getSpeed()); } }   Methoden überladen In Java können wir Methoden überladen. Das heisst, wir können mehrere Methoden mit demselben Namen definieren, solange die Anzahl an Parametern oder die Datentypen der Parameter variiert. Beim Aufruf der Methode wird vom Compiler die entsprechende Definition ausgewählt.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Calculator { public double product(double x, double y) { return x * y; } // Overloading the function to handle three arguments \tpublic double product(double x, double y, double z) { return x * y * z; } // Overloading the function to handle int \tpublic int product(int x, int y) { return x * y; } }   1 2 3 4 5 6 7 8 9 10 11 12 13  class Demo { public static void main(String[] args) { Calculator cal = new Calculator(); double x = 10; double y = 20; double z = 5 int a = 12; int b = 4; System.out.println(cal.product(x, y)); System.out.println(cal.product(x, y, z)); System.out.println(cal.product(a, b)); } }   Methoden, deren Parameter gleich sind (gleiche Anzahl, gleiche Datentypen) und sich lediglich in ihren Rückgabetypen unterscheiden, können nicht überladen werden, da der Compiler nicht in der Lage ist, zwischen ihren Aufrufen zu unterscheiden.\nDie Methoden equals() und hashCode() Die Methoden equals() und hashCode() gehören zu den grundlegenden Java APIs. Beide Methoden gehören automatisch zur öffentlichen Schnittstelle jeder Klasse, da sie durch die implizite Ableitung von der Object-Klasse geerbt werden (mehr dazu im Teil “Objektorientiertes Design” in diesem Modul).\nOb die Default-Umsetzung beider Methoden ausreicht, wird aufgrund von den fachlichen Gegebenheiten entschieden und ggf. werden beide Methoden überschrieben.\nequals() Die Methode equals() ermöglicht uns das aus dem fachlichen Kontext stammende Gleichheitsverständnis im Code umzusetzen.\nDie Default-Umsetzung der Methode in der Object-Klasse definiert, dass zwei Objekte nur dann gleich sind wenn sie die gleiche Identität haben. Das heisst, zwei unterschiedliche Instanzen (also zwei Objekte) einer Klasse sind gemäss dieser Umsetzung nicht gleich auch wenn alle Felder der beiden Objekten mit den gleichen Werte befüllt werden. Aufgrund der fachlichen Gegebenheiten kann diese Definition der Gleichheit nicht korrekt sein. In so einem Fall muss die Methode equals() überschrieben werden.\nBei der Umsetzung müssen folgende Bedingungen für die Definition der Gleichheit bei nicht-null Objekten gemäss API-Definition für equals() erfüllt werden:\n Reflexivität: Das Objekt liefert beim Vergleich mit sich selbst true. Symmetrie: Das Resultat des Vergleichs x mit y ist gleich wie das des Vergleichs y mit x. Es ist also egal wie verglichen wird. Transivität: Wenn x gleich y ist und y gleich z, dann ist x gleich z. Konsistenz: Egal wie häufig der Vergleich durchgeführt wird, es kommt immer dasselbe heraus, sofern sich der Inhalt der Objekte nicht verändert. Behandlung von null: Der Vergleich mit null liefert immer false.  hashCode() Die Methode hashCode() sollte für jedes Objekt einen Hashwert (Fingerabdruck) liefern, der das Objekt möglichst eindeutig identifiziert.\nDer berechnete Hashwert ermöglicht einen effizienten und schnellen Zugriff auf ein bestimmtes Objekt innerhalb eines Hash-basierten Containers wie z.B. einer HashMap.\nAuch für diese Methode definiert die API-Definition für hashCode() Bedingungen, welche erfüllt werden müssen damit die Methode zweckmässig verwendet werden kann:\n Konsistenz: Egal wie häufig hashCode() aufgerufen wird, es kommt stets dasselbe Resultat zurück, sofern der Inhalt des Objekts nicht geändert wurde. Zusammenhang equals: Zwei Objekte, die gemäss equals() gleich sind, müssen den gleichen Hashwert liefern. Zusammenhang not-equals: Zwei Objekte die gemäss equals() verschieden sind, müssen nicht zwingend unterschiedliche Hashwerte liefern. Grundsätzlich wäre es aber besser für die Performanz, wenn verschiedene Objekte auch verschiedene Hashwerte liefern würden.  In der Regel entscheiden wir uns aufgrund von fachlichen Gegebenheiten für die Überschreibung der Methode equals(). Die Überschreibung von hashCode() resultiert daraus als Konsequenz der Bedingung “Zusammenhang equals”.\nEnums Enums (kurz für “enumeration”, zu Deutsch: Aufzählung) bieten die Möglichkeit, vordefinierte Konstanten zusammen zu gruppieren. Enums werden dann verwendet, wenn alle mögliche Werte zur Kompilierzeit bekannt sind (z.B. alle Wochentage, alle Planeten im Sonnensystem usw.).\nIn Java sind Aufzählungstypen als Klassen realisiert und die definierten Werte sind als Objekte implementiert. Daraus ergeben sich folgenden nützlichen Eigenschaften:\n Enums können Konstruktoren, Instanzvariablen und Instanz-Methoden beinhalten Der Name der Enum-Werte kann mithilfe der toString-Methode (oder mit dem Keywort this) im Klartext ausgegeben werden. Mithilfe des “==\"-Operators kann auf Gleichheit geprüft werden. Enumerations können in switch-Anweisungen verwendet werden. Mithilfe der values-Methode wird ein Array zurückgegeben, das alle Elemente der Enumeration enthält. In Verbindung mit der erweiterten for-Schleife (for-each) können die Elemente sehr einfach durchlaufen werden.  Obwohl Java Enums als Klassen realisiert werden, müssen sie nicht mit new instanziiert werden. Im Gegensatz zu Klassen können Java-Enums weder erweitert werden noch von anderen Klassen erben.\nEnums definieren Enums können innerhalb oder ausserhalb einer Klasse definiert werden (nicht aber innerhalb einer Methode!). Um ein Enum zu definieren, wird das Java-Schlüsselwort enum verwendet.\nDie erste Zeile(n) innerhalb der Enum-Definition soll eine kommagetrennte Liste von Konstanten beinhalten (in Java per Konvention mit Grossbuchstaben geschrieben). Danach werden allfällige Variablen, Methoden und Konstruktoren definiert.\nJede Enum-Konstante ist implizit public static final. Weil es static ist, kann über den Enum-Namen darauf zugegriffen werden. Weil es final ist, kann es nicht erweitert werden.\nBeispiel: Definition ausserhalb einer Klasse 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  enum Weekday { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY } public class DailyPlanner { private static void dailyMood(Weekday weekday) { switch (weekday) { case MONDAY: System.out.println(\"I don't like Mondays\"); break; case FRIDAY: System.out.println(\"Thank God it's Friday\"); break; case SATURDAY: case SUNDAY: System.out.println(\"There aren't enough days in the weekend\"); break; default: System.out.println(\"Some Midweek days feel like Mondays when I wish the were Fridays\"); break; } } public static void main(String[] args) { dailyMood(Weekday.MONDAY); } }   Beispiel: Definition innerhalb einer Klasse 1 2 3 4 5 6 7 8 9  public class DailyPlanner { enum Weekday { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY } public static void main(String[] args) { System.out.println(\"I like \" + Weekday.SATURDAY + \" and \" + Weekday.SUNDAY + \" the best\"); } }   Enum mit einem Konstruktor Ein Enum-Konstruktor wird für jeder Enum-Konstante während dem Klassenladen des Enums ausgeführt. Es ist unmöglich Enum-Objekte explizit zu erzeugen. Darum kann ein Enum-Konstruktor auch nicht direkt aufgerufen werden.\nBeispiel: Enum mit einem Konstruktor 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  enum Weekday { MONDAY(1), TUESDAY(2), WEDNESDAY(3), THURSDAY(4), FRIDAY(5), SATURDAY(6), SUNDAY(7); final int dayNumber; Weekday() { System.out.println(\"Konstruktor für Tag \" + this.toString() + \" wird ausgeführt. Das ist der \" + this.dayNumber+ \". Tag in der Woche\"); } } public class TestDays { public static void main(String[] args) { Weekday monday = Weekday.MONDAY; // Output:  // Konstruktor für Tag MONDAY wird ausgeführt. Das ist der 1. Tag in der Woche  // Konstruktor für Tag TUESDAY wird ausgeführt. Das ist der 2. Tag in der Woche  // Konstruktor für Tag WEDNESDAY wird ausgeführt. Das ist der 3. Tag in der Woche  // Konstruktor für Tag THURSDAY wird ausgeführt. Das ist der 4. Tag in der Woche  // Konstruktor für Tag FRIDAY wird ausgeführt. Das ist der 5. Tag in der Woche  // Konstruktor für Tag SATURDAY wird ausgeführt. Das ist der 6. Tag in der Woche  // Konstruktor für Tag SUNDAY wird ausgeführt. Das ist der 7. Tag in der Woche  System.out.println(monday); // Output: MONDAY  } }   Enum mit Methoden Ein Enum kann konkrete wie auch abstrakte Methoden beinhalten. Wenn ein Enum eine abstrakte Methode beinhaltet, muss jede Instanz (also jede Konstante) dieses Enums diese Methode umsetzen (mehr Information über abstrakten Methoden findest du im Modul OOD).\nBeispiel: Enum mit konkreten und abstrakten Methoden 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  enum Color { RED { // Umsetzung der abstrakten Methode für die Farbe RED  @Override public void colorPoem() { System.out.println(\"Roses are red\"); } }, VIOLET { // Umsetzung der abstrakten Methode für die Farbe VIOLET  @Override public void colorPoem() { System.out.println(\"Violets are blue\"); } }; // Konkrete Methode, welche für alle Werte im Enum, dasselbe tut  public void generalColorInfo(){ System.out.println(\"Everyday color is a great color!\"); } // Abstrakte Methode, welche von jedem Wert im Enum umgesetzt werden muss  public abstract void colorPoem(); } public class Test { public static void main(String[] args) { Color violet = Color.VIOLET; violet.generalColorInfo(); // Output: Everyday color is a great color!  violet.colorPoem(); // Output: Violets are blue  Color red = Color.RED; red.generalColorInfo(); // Output: Everyday color is a great color!  red.colorPoem(); // Output: Roses are red  } }   ","categories":"","description":"Modul #J2 - OOP\n","excerpt":"Modul #J2 - OOP\n","ref":"/docs/java/java-oop/","tags":"","title":"Objektorientierte Programmierung"},{"body":"Aufgabe 1 Versuche eine eigene Stack-Klasse (MyStack\u003cE\u003e) zu implementieren mithilfe von Arrays und verwende dabei keine anderen Collections-Klassen.\nDie MyStack Klasse sollte eine dynamische Grösse haben, d.h. sie der Stack sollte beliebig wachsen können. Da der Stack mithilfe von Arrays implementiert werden soll, muss also in deiner Klasse die Kapazität des Stacks sichergestellt werden.\nImplementiere die folgenden Methoden:\n public E push(E item) public E pop( ) (soll EmptyStackException werfen) public E peek()  (soll EmptyStackException werfen) int size() public boolean empty()  Beachte, dass du die toString() Methode anpasst, sodass die MyStack-Stacks beim printen übersichtlich dargestellt werden, wie im Beispiel oben: [blue, yellow, green, orange]\nAufgabe 2 Erweitere deine MyStack Klasse. Implementiere zusätzlich die folgende Methode:\n public int search(Object o)  ","categories":"","description":"Aufgaben zu [Java Collections - Stack](../../../../docs/java/java-collections/05_stack)\n","excerpt":"Aufgaben zu [Java Collections - …","ref":"/labs/java/java-collections/04_stack/","tags":"","title":"Stack - Aufgaben"},{"body":"Webanfrage mit JavaScript Wenn du eine Webanwendung schreibst, dann muss deine Website (=Frontend) wahrscheinlich Daten von (d)einem Backend abfragen.\nIn den meisten Fällen werden hierfür HTTP-Requests verwendet, die du bereits kennengelernt hast (REST API bei Spring und HTML Forms).\nUm das einmal auszuprobieren, wollen wir eine API anfragen, die als Antwort zufällige “Fakten” über Chuck Norris zurückschickt. Wenn wir diese URL im Browser aufrufen (= HTTP GET), erhalten wir einen Witz in Form von JSON:\nGET https://api.chucknorris.io/jokes/random\n1 2 3 4 5 6 7 8 9  { \"categories\": [], \"created_at\": \"2020-01-05 13:42:20.262289\", \"icon_url\": \"https://assets.chucknorris.host/img/avatar/chuck-norris.png\", \"id\": \"6F3bv9fIRUGCPTcma6Je1w\", \"updated_at\": \"2020-01-05 13:42:20.262289\", \"url\": \"https://api.chucknorris.io/jokes/6F3bv9fIRUGCPTcma6Je1w\", \"value\": \"Albert Einstein's hair used to be neatly combed...until the day he met Chuck Norris.\" }   Folglich interessiert uns der Wert für \"value\".\nDamit für dich das Vorgehen verständlicher ist, führen wir Schritt für Schritt in der Browser-Konsole aus.\nDie Abfrage kannst du wie folgt durchführen:\n1  fetch('https://api.chucknorris.io/jokes/random', {method: 'get'})   Du wirst sehen, dass dieser Funktionsaufruf ein Promise {\u003cpending\u003e} zurückgibt. Wir sehen, dass die Anfrage noch nicht vorbei ist (pending = anstehend). Dieses Promise-Objekt wird die Antwort enthalten, sobald die Antwort verfügbar ist. Da wir sowieso erst weiterfahren möchten, wenn die Antwort bereit ist, interessieren wir uns nicht für das Promise. Daher können wir einfach mit der Fortsetzung des Scriptes solange warten, bis wir die Antwort hätten. Das können wir wie folgt machen:\n1  await fetch('https://api.chucknorris.io/jokes/random', {method: 'get'})   Das await führt dazu, dass das Script erst weitergeht, wenn die Antwort da ist. Zusätzlich wird die Antwort automatisch aus dem Promise-Objekt entpackt und wir erhalten so direkt ein Objekt vom Typ Response.\nTheoretisch haben wir nun die Daten, die wir wollen. Da wir als Antwort ein JSON-Objekt als Antwort erwarten, können wir direkt die Antwort als JavaScript-Objekt anfordern:\n1 2 3  let response = await fetch('https://api.chucknorris.io/jokes/random', {method: 'get'}); response.json();   Komischerweise erhalten wir wieder ein Promise {\u003cpending\u003e}. Was müssen wir machen, um das JSON aus diesem Promise zu kriegen?\nGenau: Wir müssen es awaiten:\n1 2 3  let response = await fetch('https://api.chucknorris.io/jokes/random', {method: 'get'}); let jokeObject = await response.json()   Dies ist notwendig, da die Methode json() asynchron den response Stream ausliest.\nWenn du nun das jokeObject loggst (z.B. mit console.log(jokeObject)), siehst du, dass wir nun das gleiche Objekt, das wir ganz oben erwartet haben, erhalten haben.\nDen Witz kannst du wie folgt ausgeben:\n1  console.log(jokeObject.value);   Anfrage in eine Funktion einbinden Im Normalfall packt man solche Logik in eine Funktion. Den oberen Code könntest du wie folgt in eine Methode einbinden:\n1 2 3 4 5 6 7 8 9 10  /** * Requests a random Chuck Norris joke and returns it. * @return {Promise\u003cstring\u003e} a random Chuck Norris joke. */ async function fetchJoke() { const response = await fetch('https://api.chucknorris.io/jokes/random', { method: 'get' }) const jokeObject = await response.json(); return jokeObject.value; }   Dir ist sicher aufgefallen, dass wir nun das async-Keyword vor function geschrieben haben. Dies ist erforderlich, wenn man await in einer Funktion verwenden möchte. Dieses async-Keyword führt auch dazu, dass die Methode ein Objekt des Typen Promise\u003c...\u003e zurückgibt.\nWenn du diese Funktion definiert hast, kannst du den Rückgabewert von ihr wie folgt loggen:\n1  console.log(await fetchJoke());   await umgehen Du wirst in die Situation kommen, wo du eine Antwort auf eine asynchrone Anfrage erhälst, aber kein await brauchen darfst, weil du dich nicht in einer mit async gekennzeichneten Funktion befindest.\nStatt ein Promise zu awaiten, kannst du auch definieren, dass eine bestimmte Aktion durchgeführt werden soll, sobald die Antwort da ist. Dies kannst du mit Promise.then(...) machen:\n1 2 3  fetchJoke().then(function(joke) { console.log(joke); });   Das kannst du auch schöner schreiben, funktioniert so aber nicht mehr im Internet Explorer:\n1  fetchJoke().then(joke =\u003e console.log(joke));   Was genau haben wir hier gemacht?\nWir haben fetchJoke() asynchron aufgerufen, ohne auf die Antwort zu warten. Deswegen erhalten wir ein Promise-Objekt. Promise-Objekte enthalten eine then-Methode. Bei dieser Methode kannst du eine Funktion übergeben. Die übergebene Funktion wird aufgerufen, sobald die Antwort erhalten wurde.\nHierzu findest du zwei Aufgaben im Lab.\nFrüher war alles besser? Die fetch-Funktion hat Webrequest stark vereinfacht. Früher durftest du dich mit XML HTTP Requests herumschlagen. Aber siehe selbst: https://www.w3schools.com/xml/xml_http.asp\n","categories":"","description":"Webrequest mit JavaScript.\n","excerpt":"Webrequest mit JavaScript.\n","ref":"/docs/web/javascript/05_js_async/","tags":"","title":"Asynchrone Anfragen"},{"body":"Wieso HTML-Formulare? Die Benutzer deiner Webseite möchten oder sollen Daten eingeben können, z.B. für ein Kontakt-Formular oder eine Login-Seite. HTML-Formulare ermöglichen genau das, auch ohne JavaScript.\nHTML-Input-Element Bevor wir uns HTML-Formulare genauer anschauen, wollen wir zuerst einen Blick auf Input-Elemente werfen, die das Eingeben von Daten überhaupt ermöglichen.\nBeginnen wir mit einer einfachen TextBox:\n1 2  Was ist dein Vorname? \u003cinput type=\"text\" name=\"firstname\"/\u003e   Probiere alle Beispiele immer selbst aus. Du hast gesehen, wie einfach eine TextBox in HTML eingebunden werden kann.\nDas type-Attribut definiert, um was für eine Art von Input-Element es sich handelt. text steht für eine gewöhnliche TextBox. Das zweite Attribut kannst du im Moment noch ignorieren.\nLabel für Input-Elemente Vor der TextBox haben wir einen Text (“Was ist dein Vorname”). Dieser Text wird auch “Label” genannt. Bei einer guten Webseite wird zudem die TextBox ausgewählt, wenn der User auf das Label klickt (nicht nur beim Klick auf die TextBox). Diese Funktionalität wollen wir hinzufügen:\n1  \u003clabel\u003eWas ist dein Vorname?\u003cinput type=\"text\" name=\"firstname\" /\u003e\u003c/label\u003e   Nun haben wir die gewünschte Funktionalität hinzufügen können. Aber was genau haben wir hier gemacht?\nWir haben das Label als Label definiert (da im label-Element). Wenn wir ein Input-Element in einem Label hinzufügen, dann wird bei einem Klick auf dieses Label automatisch dieses Input-Element fokussiert.\nNun sieht das noch ein bisschen unübersichtlich aus. Das können wir besser! Zum Beispiel so:\n1 2  \u003clabel for=\"firstname\"\u003eWas ist dein Vorname?\u003c/label\u003e \u003cinput id=\"firstname\" type=\"text\" name=\"firstname\" /\u003e   Abgesehen davon, dass das Input-Element nicht mehr im Label ist, ist der grosse Unterschied:\n dass das Input-Element nun ein id-Attribut hat und dass der Label mit dem for-Attribut darauf referenziert.  Fassen wir zusammen, weshalb wir das label-Element verwenden:\n Beim Klick auf das Label wird das entsprechende Input-Element ausgewählt. Beim Klick in das entsprechende Input-Element würde ein Screen-Reader den Namen des Labels laut vorlesen, (falls verwendet). Und ausserdem kann man später die Labels so einfacher stylen mit CSS.  Weitere Input-Elemente In HTML gibt es sehr viele weitere Input-Elemente. Eine grössere Liste findest du hier: https://www.w3schools.com/html/html_form_input_types.asp\nKennen solltest du sicher die folgenden:\n button checkbox date email file hidden number password radio  Bitte schaue dir diese Elemente auf der obengenannten Seite rasch an. Du solltest wissen, wie diese Elemente aussehen und dass es sie gibt.\nFormulare Nun solltest du im Stande sein, UI-Elemente (UI = User Interface -\u003e Benutzerschnittstelle) mit HTML auf einer Seite anzuzeigen. Jetzt wäre es schön, wenn diese Daten auch irgendwie verwendet werden könnten.\nTheoretisch könntest du mit der Programmiersprache JavaScript direkt darauf zugreifen. Im Moment wollen wir aber bei HTML bleiben. Was wir mit HTML machen können, ist, die Werte an ein Backend (=Server) zu schicken.\nAls Backend verwenden wir die folgende URL: https://www.w3schools.com/action_page.php. Das ist eine spezielle Seite: sie zeigt die Daten an, die wir ihr schicken.\nFolgender Code zeigt ein Formular, das eine E-Mail und ein Boolean beim Klick auf “Übermitteln” an das Backend schickt\n1 2 3 4 5 6 7 8  \u003cform action=\"https://www.w3schools.com/action_page.php\" method=\"get\"\u003e \u003clabel for=\"email\"\u003eEmail:\u003c/label\u003e\u003cinput type=\"email\" name=\"email\" id=\"email\" required /\u003e \u003cbr /\u003e \u003cinput type=\"checkbox\" name=\"interested\" id=\"interested\" /\u003e \u003clabel for=\"interested\"\u003eNewsletter abonnieren\u003c/label\u003e \u003cbr /\u003e \u003cinput type=\"submit\" value=\"Übermitteln\" /\u003e \u003c/form\u003e   Entscheidend ist hier das \u003cform\u003e-Tag. Das action-Attribut legt fest, wo die Daten hingeschickt werden. Die method legt fest, welche HTTP Request Method verwendet wird (GET oder POST). Bist du dir bei den Methoden nicht mehr so sicher, dann schaue bitte das “REST”-Kapitel hier noch einmal an: https://labs.it-ninjas.ch/docs/java/spring_introduction/#625-rest\nBei Formularen verwendet man meistens entweder GET oder POST. Der grosse Unterschied zwischen beiden Methoden ist, dass bei GET die Daten in der URL mitgegeben wird, wobei bei POST die Daten ein bisschen besser versteckt im HTTP Request Body mitgeschickt werden. Verschickst du ein Passwort, solltest du lieber POST verwenden, weil sonst das Passwort womöglich im Browser in der URL-Box einsehbar sein könnte. Die zu verwendende Methode wird meistens vom Backend festgelegt. Unser Backend unterstützt beide Methoden.\nWichtig für das Formular ist, dass es einen submit-Button besitzt. Dieser Submit-Button löst das Senden der Daten an die angegebene Url (action) mit der entsprechenden HTTP Request Method (method) aus. Probiere dieses Formular einmal aus. Du wirst sehen, dass etwas wie Folgendes an den Server übermittelt wird:\n1  email=hello@world.com\u0026interested=on   Die Daten werden also als Text übermittelt. Die einzelnen Felder werden jeweils mit\n1  key=value   übermittelt und mit einem “\u0026” miteinander kombiniert. Der key stammt jeweils vom name-Attribut der Input-Elemente.\nIm oben gezeigten Beispiel haben wir bereits eine kleine Validierung (Überprüfung der Eingaben) integriert:\n Einerseits haben wir mit dem required-Attribut festgelegt, dass die E-Mail-Box nicht leer sein darf beim Übermitteln. Anderseits verbietet type=\"email\" das Senden, wenn etwas anderes als eine E-Mail-Adresse eingegeben wird. Aus diesem Grund verwenden wir lieber type=\"email\" als type=\"text\" für E-Mail-Adressen, type=\"tel\" für Telefonnummern und type=\"date\" für ein Datum.  Ein komplexeres Beispiel Um zu zeigen, wie einfach Input-Elemente verwendet werden könnten, kannst du folgendes Beispiel ausprobieren:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u003ch2\u003eLogin\u003c/h2\u003e \u003cform action=\"https://www.w3schools.com/action_page.php\" method=\"get\"\u003e \u003clabel\u003eemail: \u003cinput type=\"email\" name=\"your-email\" /\u003e\u003c/label\u003e \u003cbr /\u003e \u003clabel for=\"pw\"\u003epassword:\u003c/label\u003e \u003cinput type=\"password\" name=\"your-password\" id=\"pw\" /\u003e \u003cbr /\u003e \u003clabel\u003e\u003cinput type=\"checkbox\" name=\"stay\" value=\"yes\" /\u003eStay logged in.\u003c/label\u003e \u003ch4\u003eFavorite Language?\u003c/h4\u003e \u003cp\u003e \u003cinput type=\"radio\" id=\"html\" name=\"fav_language\" value=\"HTML\"\u003e \u003clabel for=\"html\"\u003eHTML\u003c/label\u003e\u003cbr\u003e \u003cinput type=\"radio\" id=\"css\" name=\"fav_language\" value=\"CSS\"\u003e \u003clabel for=\"css\"\u003eCSS\u003c/label\u003e\u003cbr\u003e \u003c/p\u003e \u003cinput type=\"submit\" /\u003e \u003c/form\u003e   - Hierzu findest du eine Aufgabe im Lab.\n","categories":"","description":"Formular-Daten mit HTML verschicken.\n","excerpt":"Formular-Daten mit HTML verschicken.\n","ref":"/docs/web/html_css/05_forms/","tags":"","title":"HTML Formulare"},{"body":"Services Services implementieren Daten oder Logik, die in den verschiedenen Components verwendet werden, z.B.:\n Domain-Spezifische Berechnungen Applikationsweiter Datencache Kommunikation mit der Backendapplikation  Dependency Injection Was is eine Dependency Injection Dependency Injection ist ein Coding pattern, bei welchem Klassen alle Abhängigkeiten von externen Quellen erhalten, anstatt sie selbst zu erstellen.\nDependency Injection in Angular Der Angular Dependency Injector liefert uns Vorteile wie Skalierbarkeit, Testbarkeit und eine klare Trennung von Aufgaben.\nUm den Dependency Injector in Angular zu nutzen müssen wir 3 Schritte erledigen\nDen @Injectable() Decorator der Klasse/ dem Service hinzufügen. Den Injector davon erzählen, indem wir es als Provider aufzählen. Die Dependency injecten\n @Injectable importieren und nutzen:  1 2 3 4 5 6  import {Injectable} from './@angular/core'; @Injectable() export class Auto{ //.... }   Das Auto als Provider registrieren (in module.ts):  1 2 3 4 5 6 7 8 9  //... import {Auto} from './auto'; @NgModule({ declatations: [], //...  bootstrap: [AppComponent], providers: [Auto] }) export class AppModule{ }   Dependency injecten wo (in unserem Beispiel) das Auto genutzt wird:  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  import {Auto} from './auto'; @Component({ //... }) export class AutoNutzer{ //...  menschen: Menschen[]; constructor(private auto: Auto){ } ngOnInit(){ // Jetzt kann man das Auto hier einfach benutzen  this.menschen = this.auto.getInsassen(): } }   Das Minibeispiel soll lediglich die 3 wichtigen Schritte etwas besser darstellen.\nIn Euren Projekten werdet ihr dieses Verfahren für die Services anwenden.\nAufgabe 2 Folgende Datenbankstruktur ist gegeben:\n Erstelle für jede Entität ein geeignetes Model Erstelle für jede Entität einen Service Erstelle bei jedem Service Musterdaten die du in einer geeigneten Component anzeigst. Design ist noch nicht wichig, es geht nur um das Verständnis Behalte die Ordnerstruktur korrekt (Ordner für die Componenten, Ordner für die Services, etc.)  ","categories":"","description":"","excerpt":"Services Services implementieren Daten oder Logik, die in den …","ref":"/docs/web/angular/04_3_services_und_dependency_injection/","tags":"","title":"Services und Dependency Injection"},{"body":"Inhalt  Beispiel für Branching, Merging und Rebasing Einfache Mergekonflikte  Im vorherigen Kapitel haben wir gelernt, dass man nur dann seine Änderungen pushen kann, wenn einem niemand anders zuvorkam. Um diesem Problem aus dem Weg zu gehen, kann ein Branch (engl. für Ast/Zweig) verwendet werden, welcher zu einem späteren Zeitpunkt wieder auf den Hauptpfad gemerged wird.\nIm ersten Kapitel haben wir gelernt, dass Git mit jedem Commit ein Snapshot der Daten und eine Referenz auf den vorgehenden Commit speichert. Ein Branch ist nichts anderes als ein Zeiger auf einen spezifischen Snapshot.\nErzeugen wir mit git branch testing einen neuen Branch namens “testing” so wird ein Zeiger erstellt, welcher auf den selben Commit zeigt auf dem man sich im Moment befindet. Damit Git weiss, wo man sich im Moment gerade befindet gibt es einen speziellen Zeiger namens HEAD:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  +----------+ | HEAD | +----+-----+ | v +----+-----+ | master | +----+-----+ | v +----------+ +----------+ +----+-----+ | Commit 1 +\u003c-------+ Commit 2 +\u003c-------+ Commit 3 | +----------+ +----------+ +----+-----+ ^ | +----+-----+ | testing | +----------+   Wie man auf der Skizze erkennen kann, wurde der neue Branch “testing” erstellt, wir befinden uns aber immer noch auf dem “master” Branch (HEAD). Um nun auf den neuen Branch zu wechseln können wir den Befehl git checkout testing verwenden. Protipp: Um einen neuen Branch zu erstellen und gleich auf diesen zu wechseln, kann der Befehl git checkout -b \u003cbranchname\u003e verwendet werden.\nErstellen wir nun einen Commit auf dem “testing” Branch, dann zeigt sich folgendes Bild:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  +----+-----+ | master | +----+-----+ | v +----------+ +----------+ +----------+ +----------+ | Commit 1 +\u003c-------+ Commit 2 +\u003c-------+ Commit 3 |\u003c-------+ Commit 4 | +----------+ +----------+ +----------+ +----------+ ^ | +----------+ | testing | +----+-----+ ^ | +----------+ | HEAD | +----+-----+   Beispiel für Branching, Merging und Rebasing In diesem Abschnitt wird davon ausgegangen, dass es einen Fehler im aktuellen master-Branch gibt, der unter testing nicht behoben wurde, da er zur Entwicklung neuer Funktionen verwendet wird. Um den Fehler zu beheben, wird ein neuer Branch mit dem Namen bugfix erstellt, der mit der gleichen Revision wie master beginnt.\n1 2 3 4  $ git checkout master Switched to branch 'master' $ git checkout -b bugfix Switched to a new branch 'bugfix'   git commit Nachdem der Branch bugfix erstellt und ausgecheckt wurde, wird die Korrektur entwickelt und übertragen.\n1 2 3 4 5 6 7 8 9 10 11  $ git diff diff --git a/first-file.txt b/first-file.txt index 4c5fd91..aa24abd 100644 --- a/first-file.txt +++ b/first-file.txt @@ -1 +1 @@ -First file +First file with bugfix $ git commit -a -m \"Bugfix for first file\" [bugfix a27a927] Bugfix for first file 1 file changed, 1 insertion(+), 1 deletion(-)    Die erste Zeile in first-file.txt wurde geändert, indem with bugfix zur ersten Zeile hinzugefügt wurde.  Mit der neuen Übergabe an bugfix fangen die Branches an, auseinanderzulaufen.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  +----------+ | testing | +----------+ +----+-----+ | master | | +----+-----+ v | +----+-----+ v + Commit 4 | +----------+ +----------+ +----+-----+\u003c-------+----------+ | Commit 1 +\u003c-------| Commit 2 +\u003c-------+ Commit 3 + +----------+ +----------+ +----------+\u003c-------+----------+ + commit 5 | +----+-----+ ^ | +----+-----+ | bugfix | +----+-----+ ^ | +----+-----+ | HEAD | +----+-----+   Mergen der Branches Nach der Fehlerbehebung ist es nun an der Zeit, sie wieder in den Master-Branch einzubinden, damit andere Benutzer sie ebenfalls verwenden können.\ngit merge Merge ist eine Wiederholung der Änderungen eines benannten Commits (auch Branch genannt) in einen anderen Branch, da diese voneinander abwichen. Damit dies funktioniert, ändert man zuerst den Zielbranch. In diesem Fall ist das bugfix. Die Änderungen sollen nach master zurückgespielt werden. Da das Ziel master ist, ist der erste Schritt, zu diesem Branch zu wechseln.\n1 2 3 4 5 6 7 8 9 10 11  $ git checkout master Switched to branch 'master' $ git branch * master testing bugfix $ git merge bugfix Updating e303af7..a27a927 Fast-forward first-file.txt | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-)     Wechseln Sie zum Zielbranch (master).\n  Bestätigen Sie, dass Sie sich im Zielbranch befinden. Dieser Schritt ist optional.\n  Wiederholen Sie die Änderungen von bugfix in master.\n  Nach der Zusammenführung zeigen bugfix und master auf dieselbe Revision.!\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  +----+-----+ | HEAD | +----+-----+ +----------+ | | testing | v +----+-----+ +----------+ | | master | v +----+-----+ +----+-----+ | + Commit 4 | v +----------+ +----------+ +----+-----+\u003c-------+----------+ +----+-----+ | Commit 1 +\u003c-------| Commit 2 +\u003c-------+ Commit 3 +\u003c--------------------------+ commit 5 | +----------+ +----------+ +----------+ +----+-----+ ^ | +----+-----+ | bugfix | +----+-----+   git branch -d Es gibt keinen Grund mehr, den bugfix-Branch beizubehalten, da die Änderungen nun in master eingearbeitet wurden. Mit dem Befehl branch -d \u003cbranchname\u003e wird der Branch gelöscht.\n1 2 3 4 5 6 7 8  $ git branch bugfix * master testing $ git branch -d bugfix Deleted branch bugfix (was a27a927). $ git log --oneline -n 1 a27a927 (HEAD -\u003e master) Bugfix for first file     Der Branch kann beim Auschecken nicht gelöscht werden. Der aktive Branch ist master, der für die Löschung von bugfix funktioniert.\n  Der Branch wird gelöscht und die Ausgabe enthält den kurzen SHA1-Hash.\n  Die Überprüfung mit git log bestätigt, dass master auf denselben Hash zeigt wie bugfix.\n  Nachdem der Branch bugfix gelöscht wurde, bleiben nur noch master und testing übrig.\nRebasing Branches Nachdem die Fehlerkorrektur in den Branch master eingebracht wurde, ist der nächste logische Schritt, die Änderungen in den Branch testing einzubringen, um sicherzustellen, dass der nächste Release die korrigierte Version enthält. Wenn man mit mehreren Branches arbeitet, ist diese Operation notwendig, um nicht zu weit in den master zurückzufallen und viele Merge-Konflikte zu vermeiden.\ngit rebase Rebase bedeutet, dass der übergeordnete Commit der ersten Änderung im Branch verschoben und an den aktuellen Zeiger des Branches oder Commits angehängt wird, der in der Befehlszeile als Argument angegeben wird. Im folgenden Beispiel wechseln wir als erstes in den Branch, der rebase werden soll, und geben dann den Befehl rebase gegen master aus.\n1 2 3 4 5 6 7  $ git branch * master testing $ git checkout testing Switched to branch 'testing' $ git rebase master Successfully rebased and updated refs/heads/testing.     Derzeit auf dem Branch master, muss vor dem rebase auf testing wechseln.\n  Wechseln Sie zum Branch testing, der mit master rebased wird.\n  Erteilen Sie den Befehl rebase mit dem Argument master, dem Branch oder Zeiger, der für den rebase verwendet wird.\n  Die Meldung ist knapp und bezieht sich auf die git-interne Dateistruktur unter dem Verzeichnis .git.\n   Hinweis\nDie Durchführung eines rebase zwischen zwei Branches erfordert einen gemeinsamen Vorfahren im Tree.\n Nach dem Rebase sind “Master” und “Testing” wieder synchronisiert.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  +----+-----+ | master | +----+-----+ | v +----------+ +----------+ +----------+ +----------+ +----------+ | Commit 1 +\u003c-------| Commit 2 +\u003c-------+ Commit 3 +\u003c-------+ Commit 5 |\u003c-------+ Commit 4 | +----------+ +----------+ +----------+ +----------+ +----------+ ^ | +----------+ | testing | +----+-----+ ^ | +----------+ | HEAD | +----+-----+   Einfache Mergekonflikte Im oben erwähnten Beispiel ist alles automatisch gegangen beim Mergen, es gibt jedoch Fälle, bei denen Git nicht mehr in der Lage ist automatisch die Dateien Zusammenzuführen, wenn zum Beispiel eine Änderung an der gleichen Stelle einer Datei in beiden Branches vorgenommen wird. Gehen wir vom Beispiel oben aus, die Story die man da umsetzt macht auch etwas mit dem Dashboard welches wir kurzum anpassen mussten:\n1 2 3 4  $ git merge bugfix Auto-merging first-file.txt CONFLICT (content): Merge conflict in first-file.txt Automatic merge failed; fix conflicts and then commit the result.   Git konnte nicht automatisch mergen und hat somit keinen commit erstellt, wir müssen den Mergekonflikt von Hand lösen, bevor wir weiter arbeiten können. Weitere Infos liefert git status:\n1 2 3 4 5 6 7 8 9 10 11  $ git status On branch master You have unmerged paths. (fix conflicts and run \"git commit\") (use \"git merge --abort\" to abort the merge) Unmerged paths: (use \"git add \u003cfile\u003e...\" to mark resolution) both modified: first-file.txt no changes added to commit (use \"git add\" and/or \"git commit -a\")   Git fügt automatisch eine Markierung in die Dateien ein, welche gmerged werden müssen:\n1 2 3 4 5  \u003c\u003c\u003c\u003c\u003c\u003c\u003c HEAD first line from master ======= first line from testing \u003e\u003e\u003e\u003e\u003e\u003e\u003e testing   Das bedeutet, dass der HEAD (also der Masterbranch, weil auf den haben wir vor dem Mergen gewechselt) den oberen Teil (also immer alles auf Grün) und unsere neuen Änderungen den unteren Teil auf dieser Zeile hatten. Man kann den Konflikt nun lösen, indem man den ganzen Block, mit der gewünschten Änderung ersetzt. Ist der Konflikt gelöst, können wir die Datei ganz normal stagen und commiten. Gerade bei grösseren Mergekonflikten kann es praktisch sein mit tools zu Arbeiten, welche einem die Unterschiede zwischen den beiden Branches Grafisch darstellen, dafür gibt es den Befehl git mergetool.\nIn der Regel können viele Merge-Konflikte verhindert oder minimiert werden, indem:\n  Regelmässige Kommunikation von Änderungen zwischen Teammitgliedern.\n  Regelmässige Rebases mit dem Merge-Zielbranch.\n  Erstellen kleiner und atomarer Commits.\n  Hands On https://learngitbranching.js.org/\n","categories":"","description":"","excerpt":"Inhalt  Beispiel für Branching, Merging und Rebasing Einfache …","ref":"/docs/git/git-branches/","tags":"","title":"Git Branches"},{"body":"","categories":"","description":"Exercises zu Modul #J3 - OOD\n","excerpt":"Exercises zu Modul #J3 - OOD\n","ref":"/labs/java/java-ood/","tags":"","title":"Java Exercises - OOD"},{"body":"Ziele  Ich weiss, was eine Liste ist Ich weiss, wozu und wie Listen verwendet werden Ich kenne, die wichtigsten Methoden einer Liste Ich kenne die Klasse ArrayList Ich weiss was Streams sind Ich kann Streams für die Iteration über Listen anwenden Ich kenne ein paar wichtige Methoden aus dem Stream Interface   Einführung Listen Was ist eine Liste? Eine Liste ist in Java ein Behälter (Container), der Objekte in einer festen Abfolge enthält.\nIm Gegensatz zu Arrays, deren Elemente im Speicher in fortlaufender Reihenfolge abgelegt werden und deren Grösse aus diesem Grund ohne Neuinitialisierung unveränderbar ist, können Listen flexible Mengen an Objekten enthalten.\nDas List-Interface ist ein Teil des Java-Collections-Frameworks. Dieses Framework stellt einige Klassen zur Verfügung, welche das List-Interface umsetzen (mehr dazu in einem späteren Modul).\nDie wichtigsten Merkmale einer Liste  Eine Liste kann nur Objekte, bzw. die Referenzen auf diesen Objekten, beinhalten (es gibt also keine Liste mit primitiven Datentypen) Eine Liste kann nur Objekte eines Typs beinhalten. Dieser Typ wird zur Zeit der Definition der Liste bestimmt. Die Elemente innerhalb einer Liste haben eine feste Reihenfolge. Dies bedeutet, dass eine Iteration über eine Liste immer zu einem gleichen Ergebnis mit der gleichen Reihenfolge führt. Duplikate innerhalb einer Liste sind erlaubt (dasselbe Objekt darf mehrmals in einer Liste vorkommen) Eine Liste kann auch “null”-Elemente beinhalten Die Indizes in einer Liste reichen immer von 0 bis Anzahl Elemente in der Liste minus 1.   Die wichtigsten Methoden einer Liste Das List-Interface stellt mehrere Methoden zur Verfügung, welche von implementierenden Klassen dann - angepasst an ihre Struktur und ihren Zweck - umgesetzt werden.\nNachfolgend werden einige Methoden und deren Zweck aufgelistet. Dort wo “E” steht, geht es um einen generischen Typ, welcher stellvertretend für einen konkreten Objekttyp steht (Generics werden in einem separaten Modul behandelt).\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  /* * Returns: the number of elements in this list. */ int size(); /* * Appends the specified element to the end of this list */ boolean add(E e); /* * Removes the element at the specified position in this list. */ E remove(int index); /* * Removes the first occurrence of the specified element from * this list, if it is present. */ boolean remove(Object o); /* * Returns: true if this list contains the specified element. */ boolean contains(Object o);    Die Klasse ArrayList ArrayList gehört zu der Liste der Standardsammelklassen und ist im java.util-Packet definiert.\nDie ArrayList ist eine Klasse, die zum Erstellen eines dynamischen Arrays verwendet wird. Dieses Array beinhaltet Objektreferenzen und kann bei Bedarf grösser werden.\nDie ArrayList kombiniert die Vorteile eines Arrays (z.B. schneller Zugriff auf einem bestimmten Element) mit den Vorteilen einer Liste (kann dynamisch wachsen) und ist deswegen sehr nützlich um eine Sammlung von Objekten, derer Grösse nicht bekannt ist, zu bearbeiten. Die ArrayList setzt alle Methoden (obligatorische wie auch optionale) des List-Interfaces um.\nArbeiten mit einer ArrayList - Beispiel Um mit ArrayList arbeiten zu können, muss die Klasse zuerst importiert werden.\n1  import java.util.ArrayList;   Nun kann eine Variable definiert und erzeugt werden. Der Syntax hier wird in späteren Modulen erklärt, hier reicht es zu wissen, dass innerhalb der spitzigen Klammern - auf der linken Seite der Definition - der Typ der Objekte angegeben wird, welche dann in der Liste hinzugefügt werden dürfen.\n1 2 3  // Erstellen einer ArrayList für String-Objekte. // Ein Versuch, Objekte anderer Typ in der Liste hinzuzufügen wird in einem Kompilierfehler resultieren List\u003cString\u003e words = new ArrayList\u003c\u003e();   Sobald eine Liste erzeugt wurde, können beliebig viel Objekte dazu hinzugefügt oder daraus entfernt werden.\nÜber die Liste kann mit einer Schleife iteriert werden oder auch mit einem Index direkt auf ein Element zugegriffen werden.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // Elemente hinzufügen words.add(\"Hello\"); words.add(\"World\"); words.add(\"!\"); System.out.println(words); // Output: [Hello, World, !] System.out.printf(\"There are %d words in our list\\n\", words.size()); System.out.printf(\"Our list contains \\\"!\\\". True or false? %b\\n\", words.contains(\"!\")); // Output: Our list contains \"!\". True or false? true  System.out.printf(\"The second word is: %s\\n\", words.get(1)); // Output: World  for (String word: words) { System.out.println(word); } words.remove(2); // Entfernt das dritte Element aus der Liste System.out.println(words); // Output: [Hello, World] System.out.printf(\"Our list contains \\\"!\\\". True or false? %b\\n\", words.contains(\"!\")); // Output: Our list contains \"!\". True or false? false     Streams Mit Java 8 ist zum java.util-Package des JDK das Stream-API hinzugekommen. Das API ist eine Erweiterung des Java-Collection-Frameworks mit einer Schnittstelle im Stil der funktionalen Programmierung. Mit dem Stream-API wurden mächtige Möglichkeiten zur Durchführung von Operationen auf Arrays und Listen eingeführt.\nIn diesem Teil wird erklärt was Streams sind und wie sie für Operationen auf Arrays und Listen eingesetzt werden können.\nWas ist ein Stream? Streams des Interface java.util.stream.Stream stellen Ströme von Referenzen dar, die es erlauben, verkettete Operationen auf diesen Referenzen nacheinander oder parallel auszuführen. Die Daten, die durch die Referenzen repräsentiert werden, werden durch den Stream selbst nicht verändert.\nEin Stream ist also keine Datenstruktur für sich. Er erhält sein Input aus andere Datenstrukturen wie z.B. Arrays oder Listen und führt die gewünschte Operationen auf diesem Input aus ohne die ursprüngliche Datenstruktur zu verändern.\nStreams stellen Operationen zur Verfügung, welche in zwei Kategorien unterteilt werden können:\n Intermediäre Operationen, welche am Ende der Verarbeitung in einem Stream resultieren (und somit eine weitere, verkettete Verarbeitung ermöglichen). Terminale Operationen, welche am Ende der Verarbeitung einen Wert zurückliefern (und somit den Stream beenden)  Ist ein Stream einmal beendet, so können keine weiteren Operationen auf ihm ausgeführt werden.\nFolgendes Bild illustriert die Arbeitsweise von Streams Erzeugung von Streams Wie erwähnt, können Streams aus Arrays, Listen und anderen Collections oder aber auch aus Einzelobjekten erzeugt werden.\nErzeugung aus Elementes eines Arrays Aus den Elementen eines Arrays kann ein Stream mithilfe der Klasse Arrays aus dem java.util-Package wie folgt erzeugt werden:\n1 2 3 4 5  int[] numbers = {1, 2, 3, 4}; IntStream numbersStream = Arrays.stream(numbers); // IntStream ist eine Spezialisierung von Stream, welche die Verabeitung von primitive int-Werte ermöglicht  String[] greeting = {\"Hello\", \"Streams\"}; Stream\u003cString\u003e greetingStream = Arrays.stream(greeting); // Anhand der spitzigen Klammern wird ersichtlich, welche Objekttypen durch den Stream verarbeitet werden   Erzeugung aus Elementen einer Liste / eine Collection Wenn eine Liste bereits vorhanden ist, kann die Methode stream() aufgerufen werden um einen Stream aus den Elementen der Liste zu erzeugen:\n1 2 3 4 5 6  List\u003cString\u003e stringList = new ArrayList\u003c\u003e(); stringList.add(\"Hello\"); stringList.add(\"List\"); stringList.add(\"Stream\"); Stream\u003cString\u003e stream2 = stringList.stream();   Funktionale Interfaces Streams arbeiten mit sog. Lambda-Expressions (diese werden im nächsten Abschnitt erläutert). Damit klar wird, was Lambda-Expressions sind, müssen wir zuerst funktionale Interfaces verstehen.\nEin funktionales Interface (functional interface) ist ein Interface, welche eine einzige abstrakte Methode beinhaltet. Das heisst, solche Interfaces stellen eine einzige Funktionalität zur Verfügung.\nVor Java 8 mussten funktionale Interfaces, wie alle andere Interfaces auch durch Klassen implementiert werden oder es musste für sie eine innere, anonyme Klasse definiert werden. Seit Java 8 kann eine Lambda-Expression statt eine anonyme Klasse verwendet werden, um die einzige Methode des funktionalen Interfaces umzusetzen.\nLambda Expressions Lambda Expressions (Lambda-Ausdrücke) wurden in Java 8 eingeführt, um vor allem folgende Funktionalität zur Verfügung zu stellen:\n Funktionen als Argumente für Methode zu ermöglichen Funktionen erstellen, welche zu keiner Klasse gehören Eine Lambda-Expression kann wie ein Objekt weitergereicht und erst später ausgeführt werden. Da Lambda-Expressions oft in Streams verwendet werden, wird hier aufgezeigt wie Lambdas aussehen und wie sie verwendet werden können.  Lambda-Ausdrücke in Java sind quasi Methoden ohne Namen. Sie bestehen aus folgenden Elementen:\n eine Liste von formalen Parametern. Mehrere Parameter werden durch ein Komma separiert und mit Klammern umrundet. (keine Parameter werden mit leeren Klammern dargestellt, einen Parameter muss nicht zwingend mit Klammern umrundet werden) ein Pfeil-Token -\u003e ein Funktionsrumpf. Wenn der Funktionsrumpf mehrzeilig ist, wird er mit geschweiften Klammern umrundet.  Im Gegensatz zu Methoden werden der Rückgabetyp und Exceptions nicht spezifiziert, sondern vom Compiler inferiert.\nBeispiele\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // keine Parameter () -\u003e System.out.println(\"Ich habe kein Parameter\") // ein Parameter word -\u003e System.out.printf(\"Ich habe einen Parameter erhalten, nämlich: %s\", word) // zwei oder mehr Parameter (name, age) -\u003e System.out.println(\"My name is \" + name + \" and I am \" + age + \"years old\") // Funktionsrumpf mehrzeilig (name, age) -\u003e { System.out.println(\"My name is \" + name); System.out.println(\"I am \" + age + \"years old\"); }   Method Reference Eine Methoden-Referenz ist die verkürzte Schreibweise einer Lambda-Expression, welche nur einen einzigen Methodenaufruf beinhaltet. Die generische Syntax für Methodenreferenz sieht wie folgt aus: Object::method Wenn eine Methoden-Referenz verwendet wird, ist es nicht nötig die Argumente für die Methode zu deklarieren.\n1 2 3 4 5 6 7 8  // Lambda-Expression mit einem Methodenaufruf (word) -\u003e System.out.println(word) // Method-Reference Syntax der obigen Lambda-Expression // Das Argument (word) muss nicht mitgegeben werden System.out::println   Methodenausführung auf Streams Die forEach() Methode Die forEach(Consumer action) Methode gehört zu den terminalen Operationen eines Streams.\nDer Parameter “action” ist vom Typ “Consumer”. Dieser Typ repräsentiert eine Operation (eine Funktion), welche nur ein einziges Input-Argument akzeptiert und keine Ergebnisse zurückliefert. Ein Beispiel für so ein Consumer ist die Methode System.out.println, welche maximal ein einziges Objekt als Parameter akzeptiert, dieses Objekt in den Standard-Output ausgibt und “void” (also kein Ergebnis) zurückliefert. Die Methode System.out.println erfüllt also die Bedingungen eines Consumers und kann als Parameter für die forEach() Methode verwendet werden\nDie forEach() Methode kann als Ersatz für einen for-Loop verwendet werden.\nBeispiel mit einem Array\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  String[] greeting = {\"Hello\", \"Streams\"}; // Hier wid jedes Element des Arrays ausgegeben for (String word : greeting) { System.out.println(word); } // Hier wird mithilfe von Streams dasselbe erreicht wie beim for-loop Arrays.stream(greeting) .forEach(word -\u003e System.out.println(word)); // Und nun noch kürzer mit dem Method-Reference Syntax der obigen Lambda-Expression Arrays.stream(greeting) .forEach(System.out::println);   Beispiel mit einer Liste\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  List\u003cString\u003e greetingList = new ArrayList\u003c\u003e(); greetingList.add(\"Hello\"); greetingList.add(\"Stream\"); greetingList.add(\"List\"); // Einmal mit der vollen Syntax der Lambda-Expression greetingList.stream().forEach(word -\u003e System.out.println(word)); // Und einmal mit der verkürzte Variante mittels Method-Reference greetingList.stream().forEach(System.out::println); // Collection, darunter auch Listen, haben selbst eine forEach Methode, // welche die gleiche Ergebnisse liefert, wie diejenige vom Stream-Interface greetingList.forEach(System.out::println);   Die sorted() Methode Die sorted() Methode gehört zu den intermediären Operationen eines Streams.\nDie Methode liefert ein Stream zurück, worin die Elemente im Stream nach ihrer natürlichen Reihenfolge (natural order) sortiert sind.\nDie Syntax der Methode ist wie folgt: Stream sorted() wobei T der Typ der Elemente innerhalb des Streams ist\nBeispiel mit einem Array\n1 2 3 4 5 6 7 8  // Erstelle ein Array mit Strings String[] greeting = {\"C\", \"A\", \"B\"}; // Sortiere die Strings nach ihrer natürlichen Reihenfolge (alphabetisch) und // gib die sortierten Elementen in der Console wieder aus Arrays.stream(greeting) .sorted() .forEach(System.out::println);   Beispiel mit einer Liste\n1 2 3 4 5 6 7 8  // Erstelle eine Liste mit Zahlen List\u003cInteger\u003e list = Arrays.asList(-9, -18, 0, 25, 4); // Sortiere die Zahlen nach ihrer natürlichen Reihenfolge (numerisch sortiert) und // gib die sortierten Elementen in der Console wieder aus list.stream() .sorted() .forEach(System.out::println);   Die collect() Methode Die collect(Collector collector) Methode ist auch eine terminale Operation auf einem Stream. Sie ermöglicht es, die Ergebnisse der Bearbeitung des Streams in einer neuen Collection (List, Map usw.) zu speichern. Dies ist nötig, da bei der Bearbeitung des Streams die ursprüngliche Elemente nicht geändert werden können.\nDer Parameter collector ist vom Typ Collector. Die Aufgabe eines Collectors besteht darin, mehrere Input-Elemente in einem Result-Container zusammenzufassen. Zum Beispiel können die Elemente eines Streams in einer Liste “gespeichert” und zurückgeliefert werden.\nUm ein Collector zu erzeugen, wird oft die Klasse Collectors aus dem java.util.stream Packet verwendet. Diese beinhaltet mehrere öffentliche, statische Methode um Collectors unterschiedlicher Typen (List, Map usw.) erzeugen zu können.\nBeispiel\n1 2 3 4 5 6 7 8 9 10 11 12 13  // Erstelle eine Liste von unsortieren Zahlen List\u003cInteger\u003e unsortedList = Arrays.asList(-9, -18, 0, 25, 4); // Aus der unstortierte Liste, erstelle eine NEUE, sortierte Liste List\u003cInteger\u003e sortedList = unsortedList.stream() .sorted() .collect(Collectors.toList()); // hier wird aus dem sortierten Stream eine neue Liste erstellt  // gib die unsortierte Liste in der Konsole aus (die Original-Liste wurde nicht verändert!) unsortedList.forEach(System.out::println); // gib die sortierte Liste in der Konsole aus sortedList.forEach(System.out::println);   ","categories":"","description":"Modul #J2 - List Basics\n","excerpt":"Modul #J2 - List Basics\n","ref":"/docs/java/java-lists-and-streams-basics/","tags":"","title":"Java Lists und Streams Basics"},{"body":"Aufgabe 1 Wir implementieren eine einfache Job-Verarbeitung. Zwei InputWorker erstellen neue Job’s, welche parallel von einem OutputWorker abgearbeitet werden.\nJeder InputWorker erstellt eine definierte Anzahl Jobs und stoppt anschliessend. Die Anzahl könnt ihr in der Start-Klasse anpassen: Start.INPUTWORKER_NUMBER_OF_JOBS.\nNach jedem Arbeitsschritt (Job erstellen oder verarbeiten) machen die Workers eine kleine Pause. Ihr könnt die maximale zufällige Dauer über die statischen Variablen Start.INPUTWORKER_MAX_RELAX_TIME_MS und Start.OUTPUTWORKER_MAX_RELAX_TIME_MS steuern. Auch die maximal zufällige Dauer zum Abarbeiten eines Jobs kann definiert werden: Start.OUTPUTWORKER_MAX_PROCESS_TIME_MS.\nDer OutputWorker stoppt, sobald er während einer Anzahl Durchgänge (Start.OUTPUTWORKER_STOP_AFTER_EMPTY_CYCLES) keine Jobs zum Verarbeiten erhält.\nDie Worker sind mit dem ProcessingInterface entkoppelt, welches das Hinzufügen und Abholen der Jobs zur Verfügung stellt:\n Inferface ProcessingInterface 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  package ch.itninjas.labs.j7.queue; public interface ProcessingInterface { /** * Add a job to the system. * @return true if the job is added. */ public boolean addJob(Job job); /** * Get the next job for processing. */ public Job getNextJob(); /** * Put the unprocessed job back to the system. */ public void getJobBack(Job job); /** * Get the number of jobs in the system. */ public int getJobs(); /** * Has jobs in the system for processing? */ public boolean hasJobs(); }    In der Konsole seht ihr die Arbeit der Workers:\n Mögliche Konsole-Ausgabe 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  [InputWorker-1] stared successfully [InputWorker-2] stared successfully -\u003e [InputWorker-1] add job: Job{id=1, message='[InputWorker-1]: (14:52:41) It is a very hard job!', jobState=NEW} -\u003e [InputWorker-2] add job: Job{id=2, message='[InputWorker-2]: (14:52:41) It is a very hard job!', jobState=NEW} -\u003e [InputWorker-2] add job: Job{id=3, message='[InputWorker-2]: (14:52:43) It is a very hard job!', jobState=NEW} -\u003e [InputWorker-1] add job: Job{id=4, message='[InputWorker-1]: (14:52:43) It is a very hard job!', jobState=NEW} [OutputWorker-1] stared successfully \u003c- [OutputWorker-1] process job: Job{id=1, message='It is a really hard job!', jobState=IN_PROGRESS} == [OutputWorker-1] finish job: Job{id=1, message='It job is finish!', jobState=FINISH} -\u003e [InputWorker-2] add job: Job{id=5, message='[InputWorker-2]: (14:52:43) It is a very hard job!', jobState=NEW} \u003c- [OutputWorker-1] process job: Job{id=2, message='It is a really hard job!', jobState=IN_PROGRESS} -\u003e [InputWorker-1] add job: Job{id=6, message='[InputWorker-1]: (14:52:44) It is a very hard job!', jobState=NEW} == [OutputWorker-1] finish job: Job{id=2, message='It job is finish!', jobState=FINISH} \u003c- [OutputWorker-1] process job: Job{id=3, message='It is a really hard job!', jobState=IN_PROGRESS} -\u003e [InputWorker-1] add job: Job{id=7, message='[InputWorker-1]: (14:52:44) It is a very hard job!', jobState=NEW} == [OutputWorker-1] finish job: Job{id=3, message='It job is finish!', jobState=FINISH} -\u003e [InputWorker-2] add job: Job{id=8, message='[InputWorker-2]: (14:52:45) It is a very hard job!', jobState=NEW} \u003c- [OutputWorker-1] process job: Job{id=4, message='It is a really hard job!', jobState=IN_PROGRESS} == [OutputWorker-1] finish job: Job{id=4, message='It job is finish!', jobState=FINISH} \u003c- [OutputWorker-1] process job: Job{id=5, message='It is a really hard job!', jobState=IN_PROGRESS} == [OutputWorker-1] finish job: Job{id=5, message='It job is finish!', jobState=FINISH} -\u003e [InputWorker-1] add job: Job{id=9, message='[InputWorker-1]: (14:52:46) It is a very hard job!', jobState=NEW} \u003c- [OutputWorker-1] process job: Job{id=6, message='It is a really hard job!', jobState=IN_PROGRESS} -\u003e [InputWorker-2] add job: Job{id=10, message='[InputWorker-2]: (14:52:47) It is a very hard job!', jobState=NEW} == [OutputWorker-1] finish job: Job{id=6, message='It job is finish!', jobState=FINISH} \u003c- [OutputWorker-1] process job: Job{id=7, message='It is a really hard job!', jobState=IN_PROGRESS} == [OutputWorker-1] finish job: Job{id=7, message='It job is finish!', jobState=FINISH} \u003c- [OutputWorker-1] process job: Job{id=8, message='It is a really hard job!', jobState=IN_PROGRESS} == [OutputWorker-1] finish job: Job{id=8, message='It job is finish!', jobState=FINISH} \u003c- [OutputWorker-1] process job: Job{id=9, message='It is a really hard job!', jobState=IN_PROGRESS} == [OutputWorker-1] finish job: Job{id=9, message='It job is finish!', jobState=FINISH} \u003c- [OutputWorker-1] process job: Job{id=10, message='It is a really hard job!', jobState=IN_PROGRESS} == [OutputWorker-1] finish job: Job{id=10, message='It job is finish!', jobState=FINISH} ?? [OutputWorker-1] Nothing to do, I stop.    Mit der Start-Klasse wird das gesamte System gestartet. Leider fehlt ein zentraler Teil des Systems: Ihr müsst das Interface ProcessingInterface implementieren.\n Ihr findet den Programmcode im work Repo:\nhttps://github.com/it-ninjas/work/tree/main/labs/src/main/java/ch/itninjas/labs/j7/queue/lab1\n Aufgabe 1.1  Implementiert das ProcessingInterface mit einer Queue, damit die Jobs im FIFO-Prinzip (Last-In-First-Out) verarbeitet werden. Kontrolliert die Konsole-Ausgabe:  Ob alle Jobs verarbeitet wurden. Ob die Jobs in der gewünschten Reihenfolge verarbeitet wurden.   Verändert die Pausen und Verarbeitungszeit der Worker und schaut euch der Einfluss in der Konsole an.  Aufgabe 1.2  Implementiert das ProcessingInterface mit einer Queue, damit die Jobs im LIFO-Prinzip (Last-In-First-Out) verarbeitet werden. Kontrolliert die Konsole-Ausgabe:  Ob alle Jobs verarbeitet wurden. Ob die Jobs in der gewünschten Reihenfolge (Last-In-First-Out) verarbeitet wurden.   Verändert die Pausen und Verarbeitungszeit der Worker und schaut euch der Einfluss in der Konsole an.  Aufgabe 2 Erweitert den OutputWorker so, dass er vor der Verarbeitung eines Jobs die Anzahl offener Jobs anzeigt.\nAufgabe 3 (Optional) Erweitert den OutputWorker so, dass er zufällig einzelne Jobs nicht erfolgreich bearbeiten kann und diese mit der Methode ProcessingInterface.getJobBack(Job job) zurück in die Queue stellt.\nAufgabe 4 (Optional) Erstellt ein JUnit-Test (JUnit Version 5), welcher die Schnittstelle ProcessingInterface der Klasse Processing ausführlich testet.\n","categories":"","description":"Aufgaben zu [Java Collections - Queue + Deque](../../../../docs/java/java-collections/06_queue)\n","excerpt":"Aufgaben zu [Java Collections - Queue + …","ref":"/labs/java/java-collections/05_queue/","tags":"","title":"Queue + Deque - Aufgaben"},{"body":"java.util.Stack java.util.Stack ist eine weitere Datenstruktur, bei der Elemente eingefügt und wieder entfernt werden können, wobei bei Stacks immer nur auf dasjenige Element zugegriffen werden kann, das zuletzt eingefügt wurde (Last-In-First-Out = LIFO). Auf Deutsch könnte man Stack als “Stapel” übersetzen.\nEin Stack kann leer sein oder kann beliebig wachsen. Mit der Methode push(E item) legt man das Element item auf den Stack, d.h. man fügt es zu oberst hinzu. pop() entfernt das oberste Element vom Stack und gibt es zurück.\nDie Methode peek() gibt das Element zu oberst auf dem Stack zurück, ohne den Stack zu verändern.\nFalls der Stack leer ist und man die Methode pop() oder peek() aufruft, wird die Exception EmptyStackException geworfen.\nMit der Methode search(Object o) kann man ein Element im Stack suchen, wobei die Position des Elements zurückgegeben wird. Bei den Stacks hat das oberste Element des Stacks die Position 1 und das Element darunter die Position 2, das Element darunter die Position 3, ect. Das heisst anders als bei den ArrayLists fangen wir nicht bei 0 an die Elemente zu indexieren, sondern bei 1.\nAlle Methoden der Klasse java.util.Stack 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  /* * Konstruktor: Erstellt einen leeren Stack */ public Stack() /* * Fügt ein Element an die oberste Stelle dieses Stacks hinzu. */ public E push(E item) /* * Entfernt das Element an der obersten Stellen und gibt dieses Element * als Wert dieser Funktion zurück. */ public E pop() /* * Gibt das Element an der obersten Stelle des Stacks zurück, * ohne es vom Stack zu entfernen. */ public E peek() /* * Gibt true zurück, wenn der Stack keine Elemente enthält. */ public boolean empty() /* * Gibt die 1-basierte Position vom oberen Ende des Stapels zurück, * an der sich das Objekt befindet; der Rückgabewert -1 bedeutet, * dass sich das Objekt nicht auf dem Stapel befindet. */ public int search(Object o)   Beispiel Beispiel 1 Im folgenden Beispiel erstellen wir zunächst ein leeres Stack mit Elementen vom Typ String und wenden die Methoden der Stack-Klasse an und sehen, wie diese funktionieren.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  import java.util.Stack; public class StackExample { public static void main(String[] args) { Stack\u003cString\u003e colors = new Stack\u003c\u003e(); colors.push(\"blue\"); colors.push(\"yellow\"); colors.push(\"green\"); colors.push(\"orange\"); System.out.println(colors); // Output: [blue, yellow, green, orange]  System.out.println(\"Color on top: \" + colors.peek()); // Output: Color on top: orange  System.out.println(colors); // Output: [blue, yellow, green, orange]  System.out.println(\"Color on top: \" + colors.pop()); // Output: Color on top: orange  System.out.println(colors); // Output: [blue, yellow, green]  System.out.println(\"Is stack empty? \" + colors.empty()); // Output: Is stack empty? false  System.out.println(\"Size of stack: \" + colors.size()); // Output: Size of stack: 3  System.out.println(\"Position of element blue: \" + colors.search(\"blue\")); // Output: Position of element blue: 3  System.out.println(\"Position of element yellow: \" + colors.search(\"yellow\")); // Output: Position of element yellow: 2  System.out.println(\"Position of element green: \" + colors.search(\"green\")); // Output: Position of element green: 1  } }   Output:\n1 2 3 4 5 6 7 8 9 10 11  [blue, yellow, green, orange] Color on top: orange [blue, yellow, green, orange] Color on top: orange [blue, yellow, green] Is stack empty? false Size of stack: 3 Position of element blue: 3 Position of element yellow: 2 Position of element green: 1   Im oberen Beispiel verwenden wir die Methode size(). Diese Methode ist nicht in der java.util.Stack-Klasse implementiert, wird jedoch von der Vector-Mutterklasse geerbt. Diese Vector-Klasse implementiert zusätzlich weitere Methoden des List-Interfaces, weshalb diese auch für Stacks verwendet werden können. Ein Stack bzw. die Datenstruktur des Stacks wird jedoch durch die oben aufgeführten Methoden ausgemacht.\nBeispiel 2 (EmptyStackException) In diesem Beispiel rufen wir die pop()-Methode auf einem leeren Stack auf:\n1 2 3 4 5 6 7 8  import java.util.Stack; public class StackExampleEmptyStackExceptionA { public static void main(String[] args) { Stack\u003cString\u003e colors = new Stack\u003c\u003e(); colors.pop(); // Throws: Exception in thread \"main\" java.util.EmptyStackException  } }   Dies führt zu folgendem Output:\n1 2 3 4 5  Exception in thread \"main\" java.util.EmptyStackException at java.base/java.util.Stack.peek(Stack.java:102) at java.base/java.util.Stack.pop(Stack.java:84) at ch.puzzle.stack.StackExampleEmptyStackExceptionA.main(StackExampleEmptyStackExceptionA.java:8)   Das gleiche Verhalten lässt sich auch bei der peek()-Methode feststellen:\n1 2 3 4 5 6 7 8  import java.util.Stack; public class StackExampleEmptyStackExceptionB { public static void main(String[] args) { Stack\u003cString\u003e colors = new Stack\u003c\u003e(); colors.peek(); // Throws: Exception in thread \"main\" java.util.EmptyStackException  } }   Wie erwartet, kriegen wir folgenden Output:\n1 2 3 4  Exception in thread \"main\" java.util.EmptyStackException at java.base/java.util.Stack.peek(Stack.java:102) at ch.puzzle.stack.StackExampleEmptyStackExceptionB.main(StackExampleEmptyStackExceptionB.java:8)     Aufgaben    Aufgaben Aufgaben zu Modul #J7 - Java Collections - Stack\n","categories":"","description":"Die Datenstruktur \"Stapel\".\n","excerpt":"Die Datenstruktur \"Stapel\".\n","ref":"/docs/java/java-collections/05_stack/","tags":"","title":"Stack"},{"body":"Schreibe eine Anwendung, welche entscheidet ob ein Damm geöffnet sein muss oder nicht. Die Entscheidung wird anhand der Wassermenge, welche in einen See hineinfliesst, verglichen mit der Wassermenge, welche aus diesem See wieder herausfliesst, gefällt.\nEine Wassermenge\n hat eine Menge hat eine Einheit  Die Anwendung soll  Auskunft geben, ob die hineinfliessende Wassermenge gleich ist wie die herausfliessende Wassermenge Den Damm nur dann öffnen, wenn die hineinfliessende Wassermenge grösser ist als die herausfliessende Wassermenge.  Es sollen keine Set Methoden für das Einfügen der Werte verwendet werden!\n","categories":"","description":"Aufgabe zu Modul #J2 - OOP - Wassermenge\n","excerpt":"Aufgabe zu Modul #J2 - OOP - Wassermenge\n","ref":"/labs/java/java-oop/05_wassermenge/","tags":"","title":"Wassermenge"},{"body":"Code verzögert ausführen: setTimeout(…) Manchmal muss eine Aktion verzögert ausgeführt werden. Dies kannst du ganz einfach mit der Funktion setTimeout(callback, time) realisieren:\n1 2 3  setTimeout(function(){ console.log('Thanks for waiting :)'); }, 5000);   Das erste Argument ist die Aktion/Funktion, die ausgeführt wird, sobald die Zeit abgelaufen ist. Das zweite Argument ist die Zeit in Millisekunden, die verstreichen muss, bis die übergebene Funktion ausgeführt wird.\nCode immer wieder ausführen: setInterval(…) Folgender Code wird jede Sekunde ausgeführt:\n1 2 3  setInterval(function(){ console.log('hey!'); }, 1000);   Vielleicht ist dir aufgefallen, dass setTimeout(...) und setInterval(...) eine Ganzzahl zurückgeben. Das ist die ID des Timeouts bzw. Intervalls. Es macht Sinn, diesen Wert zu merken, damit man das Intervall wieder beendet werden kann:\n1 2 3 4  const intervalId = setInterval(function(){}, 1000); ... clearInterval(intervalId);   Hierzu findest du eine Aufgabe im Lab.\n","categories":"","description":"Code verzögert ausführen.\n","excerpt":"Code verzögert ausführen.\n","ref":"/docs/web/javascript/06_js_timeout_and_interval/","tags":"","title":"Timeouts und Intervalle"},{"body":"Struktur einer HTML-Seite Vorher haben wir wild und ohne erkennbare Struktur HTML-Elemente hinzugefügt. Eine HTML hat ungefähr diese Struktur:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003c!-- Place for external resources and meta tags. --\u003e \u003ctitle\u003eMy Website\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- Place for your website's content. --\u003e \u003ch1\u003eHello\u003c/h1\u003e \u003cp\u003eThis is my amazing website!\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e   Auf der ersten Zeile definieren wir, dass es sich um ein HTML-Dokument handelt. Diese Zeile ist erforderlich und seit HTML5 praktisch immer gleich.\nAlle weiteren Elemente befinden sich dann im einzigen \u003chtml\u003e-Element. Auf der nächsten Stufe gibt es nur \u003chead\u003e und \u003cbody\u003e. Im \u003chead\u003e befinden sich Meta-Informationen über die Website wie z.B. der Tab-Titel der Website. Der eigentliche Seiteninhalt befindet sich dann im \u003cbody\u003e.\nDOM (Document Object Model) In der Webentwicklung wird sehr oft vom “DOM” gesprochen. Visualisiert könnte der DOM aus dem obigen Beispiel ungefähr so aussehen:\nWas ist nun aber dieses “Document Object Model”? Ganz vereinfacht gesagt, beschreibt das DOM die Struktur der Website zur Laufzeit (also im Browser). Das DOM enthält also die Information, wie die Seite aufgebaut und verschachtelt ist mit ihren Elementen. Im Gegensatz zum HTML-Dokument kann sich das DOM während des Besuches der Seite verändern (z.B. durch JavaScript). Das DOM enthält also die Information, was aktuell auf der Seite ist.\nWeitere Informationen erhältst du hier:\n https://www.w3schools.com/js/js_htmldom.asp https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction  Wie das DOM auf deiner aktuellen Seite aussieht, kannst du ganz einfach herausfinden:\n Öffne die Entwickler-Tools von deinem Browser (z.B. mit der [F12]-taste) Wechsle zum Reiter “Elemente” Nun siehst du das aktuelle DOM:  Mache dich mit diesen Entwickler-Tools (z.B. auch mit dem Button ganz oben links im Bild) vertraut!!\nDiese Tools sind sehr praktische Hilfsmittel bei der Entwicklung von HTML-Seiten, da du damit den aktuellen Zustand deiner Seite inspizieren kannst.\nDer Head Wichtig für dich zum Wissen ist auch, dass deine HTML-Seite bestimmte Meta-Tags haben sollte, damit sie als “valid” gilt. Nachfolgend ein paar wichtigere \u003cmeta\u003e-Tags:\n1 2 3 4 5 6 7 8 9  \u003chead\u003e \u003c!-- Place for external resources and meta tags. --\u003e \u003ctitle\u003eMy Website\u003c/title\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"description\" content=\"A simple useless website\"\u003e \u003cmeta name=\"keywords\" content=\"HTML, Meta tags\"\u003e \u003cmeta name=\"author\" content=\"Karl Klammer\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\"\u003e \u003c/head\u003e    Der title ist der Tab-Text charset beschreibt, welche Zeichensatz im Dokument vorkommt. Damit du alle gängigen Zeichen brauchen kannst, wird “UTF-8” empfohlen. Das Fehlen dieser Zeile führt oft dazu, dass bestimmte Zeichen falsch dargestellt werden. Die description wird zum Beispiel von Suchmaschinen verwendet. Wie z.B. Google solche Tags auswertet, erfährst du hier: https://developers.google.com/search/docs/advanced/crawling/special-tags?hl=de. keywords geht in eine ähnliche Richtung. Die Zeile für den viewport kann praktisch immer 1-zu-1 übernommen werden. Dieser Wert führt dazu, dass die Seite auf mobilen Endgeräten nicht wie eine Desktop-Seite aussieht. Mit diesem Element wird der Text auf Smartphones meistens grösser. Dieses Meta-Tag wird empfohlen, wenn die Seite auf Smartphones gut aussehen soll.  Ist meine Seite valid? Um die Seite auf Syntax-Fehlern und gängige Fehler zu überprüfen, kann es Sinn machen, die Seite von einem Validator überprüfen zu lassen. Ein bekannter ist z.B. dieser: https://validator.w3.org/#validate_by_input\nHier kannst du deinen HTML-Code eingeben und der Validator zeigt dir dann gängige Fehler an, die es in deinem Code entdeckt hat.\n","categories":"","description":"Wie sollte eine HTML-Seite strukturiert sein?\n","excerpt":"Wie sollte eine HTML-Seite strukturiert sein?\n","ref":"/docs/web/html_css/06_html_structure/","tags":"","title":"HTML-Struktur"},{"body":"Sobald Daten eingehen, könnte man ihre rohen toString-Werte direkt in die View übertragen. Dies führt jedoch selten zu einer guten user experience. In den meisten Anwendungsfällen bevorzugen Benutzer beispielsweise die Anzeige eines Datums in einem einfachen Format wie 15. January 1929 anstelle des rohen Stringformats Tu 15. January 1929 00:00:00 GMT-0700 (Pacific Daylight Time).\nEs ist klar, dass einige Werte von etwas Bearbeitung profitieren. Viele der Transformationen werden sowohl innerhalb als auch zwischen Anwendungen wiederholt. Dazu sind Pipes sehr praktisch. Man kann sie sich fast als Stile vorstellen.\nEine Pipe nimmt Daten als Eingabe auf und wandelt sie in eine gewünschte Ausgabe um. In diesem Beispiel verwenden wir Pipes, um das Geburtstags-Property eines Components in ein leserfreundliches Datum umzuwandeln.\n1 2 3 4 5 6 7 8 9  import {Component} from '@angular/core'; @Component({ selector: 'app-birthday', template: `\u003cp\u003eThe birthday is {{birthday | date}}\u003c/p\u003e` }) export class BirthdayComponent{ birthday = new Date(1929,0,15) // Month start by 0 =\u003e January 15, 1929 }   Parametrisierte Pipes Eine Pipe kann eine beliebige Anzahl optionaler Parameter akzeptieren, um ihre Ausgabe zu optimieren. Um einer Pipe Parameter hinzuzufügen, fügen wir nach dem Pipe-Namen einen Doppelpunkt (:) und danach den Parameterwert (z. B. currency: EUR) hinzu. Wenn die Pipe mehrere Parameter akzeptiert, trennen wir die Werte durch Doppelpunkte (z. B. Slice: 1: 5).\nUnser Beispiel von vorher könnten wir z.B. so ausgeben:\n1  \u003cp\u003eThe birthday of Martin Luther King Jr is {{ birthday | date:\"mm/dd/yy\" }} \u003c/p\u003e   Chaining Pipes Wir können Pipes in nützlichen Kombinationen miteinander verketten. Im folgenden Beispiel wird der Geburtstag an die DatePipe und an die UpperCasePipe ngekettet, um den Geburtstag in Grossbuchstaben anzuzeigen.\n1  \u003cp\u003eThe chained birthday of Martin Luther King Jr is {{ birthday | date | uppercase }} \u003c/p\u003e   Der Geburtstag wird nun so angezeigt: APR 15, 1988\nCustom Pipes Für spezielle Anwendungsfälle können wir auch unsere eigenen Pipes schreiben.\nWir können Beispielsweise das size eines Files anhand einer custom Pipe im Template darstellen.\n1  {{ file.size | filesize: \"megabyte\" }}   Der Code für die custom Pipe dieses Beispiels würde so aussehen:\n1 2 3 4 5 6 7 8  import {Pipe, PipeTransform} from '@angular/core'; @Pipe({ name: 'filesize' }) export class FileSizePipe implements PipeTransform{ transform(size: number, extensions: string = \"MB\"){ return (size / (1024 * 1024)).toFixed(2) + extension; } }    Um Angular mitzuteilen, dass dies eine Pipe ist, wenden wir den @Pipe Decorator an, welchen wir aus @angular/core importieren. Die Pipe-Klasse implementiert die Methode transform des PipeTransform Interface, die einen Eingabewert gefolgt von optionalen Parametern akzeptiert und den transformierten Wert zurückgibt. Für jeden an die Pipe übergebenen Parameter gibt es ein zusätzliches Argument für die Methode transform. Unsere Pipe hat einen solchen Parameter: die extension. Mit dem @Pipe Decorator können wir den Pipe-Namen definieren, welchen wir im Template verwenden.  Aufgabe 3 In der vorherigen Aufgabe hast du eine Grundstruktur geschaffen für die Anzeige von diversen Fahrrädern und dessen Marken und Typ.\n Erstelle nun eine Pipe welche die Spalte wert im Format 1'720.00 CHF anzeigt. Der Währungstyp wird mit einem Parameter weitergegeben. Sofern nichts angegeben wird, wähle Standardmässig CHF. Geh davon aus das in der Spalte wert auch Zahlen wie 1287.87 oder 5421.21 gespeichert sind. Runde diese je nachdem auf oder ab. Auch das Hochzeichen (') soll immer nach 3 Stellen erscheinen. Erstelle eine weitere Pipe, welche den Markennamen nur mit Grossbuchstaben anzeigt und hinter den Markennamen ein Copyrightzeichen (©) setzt.  ","categories":"","description":"Jede Anwendung beginnt mit einer scheinbar einfachen Aufgabe: Daten abrufen, transformieren und Benutzern zeigen. Das Abrufen von Daten kann so einfach wie das Erstellen einer lokalen Variablen oder so komplex wie das Streamen von Daten über ein WebSocket sein.\n","excerpt":"Jede Anwendung beginnt mit einer scheinbar einfachen Aufgabe: Daten …","ref":"/docs/web/angular/04_4_pipes/","tags":"","title":"Pipes"},{"body":"GitHub ist ein Webservice für das Verwalten von Software Code via Git. Darüber hinaus bietet GitHub viele weitere Funktionen, von Projektmanagement mit Taskverwaltung, über Wikis bis zum Buildserver. GitHub ist die Plattform für Opensource Projekte.\nWeitere Infos:\n Wikipedia GitHub Doku  GitHub Alternativen Natürlich ist GitHub nicht die einzige Plattform, welche diesen Service anbietet. Alle Alternativen haben ihre eigenen Features und Limitierungen, im Kern verwenden aber alle Git.\nAlternativen:\n Gitea: https://gitea.io Gitolite: https://gitolite.com Gitosis: https://github.com/tv42/gitosis GitLab: https://gitlab.com/ Bitbucket: https://bitbucket.org  GitHub Account Falls du noch keinen GitHub-Account hast, wäre jetzt der Moment einen zu erstellen. https://github.com/signup\nGit Protokolle Um auf ein entferntes Git Repository zuzugreifen, gibt es in der Regel zwei Varianten:\n HTTPS SSH  Beide Protokolle bieten standardmässig Verschlüsselung, Authentifizierung und Komprimierung.\nGit über HTTPS Kurze Wiederholung: Um ein Repository über HTTPS zu klonen verwendet man den Befehl:\n1  $ git clone https://github.com/kelseyhightower/nocode.git   Dies ist die einfachste Variante, um Code schnell herunterzuladen und lokal im eigenen Editor zu betrachten.\nVorteile:\n Anonymer Zugriff möglich Zugriff für Systeme, auf denen SSH weniger verbreitet ist HTTPS ist auf vielen Corporate Firewalls standardmässig offen  Nachteile:\n Zwischenspeicherung der Anmeldedaten mit HTTPS weniger benutzerfreundlich als mit SSH Keys Konfiguration des Webservers etwas komplizierter als die von SSH  Git über SSH Um ein Repository mit SSH zu klonen, kommt folgender Befehl zum Einsatz:\n1  $ git clone git@github.com:cajotafer/10xengineers.git   Für die meisten Anwendungsfälle ist dies der bevorzugte Weg, um entfernte Git Repositories zu verwenden.\nVorteile:\n SSH ist auf jedem Linux System bereits vorinstalliert (server- wie clientseitig) SSH Server sind sehr einfach zu konfigurieren Der Zugriff via SSH ist sehr sicher  Nachteile:\n Bietet keinen anonymen Zugriff  GitHub Features    Feature Funktion     Issues Ermöglichen es, Tasks in einem Repo zu erstellen und zu tracken.   Pull Requests Ein Pull Request ermöglicht es, Changes zu Reviewen und zu besprechen, bevor sie in einen Branch gemerged werden.   Forks Eine Fork ist eine Kopie von einem Git-Repo. Die Fork kann dann bearbeitet und angepasst werden, ohne dass das originale Repo davon betroffen ist.   GitHub Pages Basic Webseiten welche auf GitHub gehostet werden   GitHub Actions CI/CD Integration von GitHub    Hands On Für dieses Hands-On werden wir alles via Webinterface von GitHub machen. Ein Grossteil der Tasks können jedoch auch Lokal mit Git im Terminal gemacht werden.\nBranches und Pull Requests  https://guides.github.com/activities/hello-world/  Forks, Pull Requests, Reviews  Fork erstellen vom Repo.  Weitere User auf Fork hinzufügen  Branch auf Fork erstellen hello-world.sh auf dem Master Branch anpassen und committen. 1 2 3  #!/bin/bash  echo 'Hello World Master'    hello-world.sh auf dem neuen Branch anpassen und committen. 1 2 3  #!/bin/bash  echo 'Hello World Feature'    Pull Request erstellen Da auf beiden Branches die gleich Zeile bearbeitet wurde, kann GitHub die Branches nicht automatisch Mergen. Aus diesem Grund müssen zuerst die Konflikte gelöst werden  Teamkollege als Reviewer zuweisen. Review Changes umsetzen. Pull Request mergen. Merge Request auf Original Repo erstellen Ende  ","categories":"","description":"","excerpt":"GitHub ist ein Webservice für das Verwalten von Software Code via Git. …","ref":"/docs/git/git-hub/","tags":"","title":"GitHub"},{"body":"","categories":"","description":"Exercises zu Modul #S2 - Maven\n","excerpt":"Exercises zu Modul #S2 - Maven\n","ref":"/labs/java/maven/","tags":"","title":"Java Exercises - Maven"},{"body":"Ziele  Ich weiss, was generische Programmierung ist Ich weiss, was Typsicherheit ist und wie Typverletzung entsteht Ich kenne die Vorteile von Generics Ich weiss, wann Generics angewendet werden sollen Ich weiss, was “bounded types” sind und warum sie angewendet werden Ich weiss, was Wildcards im Kontext von Generics sind und wie sie verwendet werden Ich weiss, was mit Generics nach der Kompilierung passiert (“type erasure”) Ich kann generische Klassen und Methoden definieren Ich kann generische Klassen und Methoden in meinem Code anwenden   Einführung Mit Generics sind im Java-Umfeld parametrisierte Datentypen gemeint. So werden mit Generics Datentypen (Integer, String oder auch benutzerdefinierte Datentypen) als Parameter für Klassen, Interfaces und Methoden mitgegeben. Mit Generics ist es also möglich Klassen, Interfaces und Methoden zu schreiben, welche mit unterschiedlichen Datentypen arbeiten können.\nGenerics funktionieren nur mit Referenz-Datentypen (also nicht mit primitiven Datentypen) und werden nur während der Kompilierung ausgewertet.\nTypsicherheit Typsicherheit ist einen Zustand, bei dem Datentypen gemäss ihren Definitionen verwendet werden und keine sog. Typverletzungen auftreten.\nIn der Regel wird bei einer Variable der Datentyp festgelegt. Diesen Datentyp schränkt die Menge der konkreten, zulässigen Werte für diese Variable ein. Versucht man der Variable nun einen Wert ausserhalb diesen zulässigen Bereich zuzuweisen, so liegt eine Typverletzung vor.\nDie Überprüfung der Typsicherheit in Java ist eine Aufgabe des Java-Compilers. Wenn der Compiler eine Typverletzung zur “Compile-Zeit” entdeckt gibt es einen sog. Kompilierfehler, welcher davor warnt. Wenn eine Typverletzung unentdeckt bleibt, können zur Laufzeit des Programms schwer analysierbare Fehler auftreten.\nBeispiel einer Typverletzung, welche vom Compiler entdeckt wird\nIn der folgenden Klasse wird versucht, ein String zu einer Variable des Typs Integer zuzuweisen\n1 2 3 4 5 6  public class Test { public static void main(String[] args) { Integer myInteger; myInteger = \"this is not an integer...\"; } }   Beim Versuch, die Klasse zu kompilieren erscheint folgende Fehlermeldung: Warum Generics? Programme, welche Generics verwenden, haben mehrere Vorteile gegenüber Programmen ohne Generics:\n Wiederverwendbarer Code: eine Klasse oder eine Methode kann einmal geschrieben werden und mit unterschiedlichen Datentypen verwendet werden. Typsicherheit: Generics lösen Fehler während der Kompilierung aus, welche ansonsten erst zur Laufzeit ausgelöst wären. Individuelle Typ-Casting ist nicht nötig: Wenn bei der Anwendung von Generics der konkrete Typ angegeben wird, muss danach kein Typ-Casting stattfinden.  Schauen wir wie die Typsicherheit eines Programms mit Generics verbessert werden kann.\nDie Object-Klasse in Java ist die Super-Klasse aller anderen Klassen und eine Object-Referenz kann beliebige Objekte referenzieren. Diese Features sind nicht typsicher. Auch durch das Verwenden von Polymorphismus können Typverletzungen entstehen.\nBeispiel Typverletzung, welche nicht zu einem Compiler-Fehler führt\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  import java.util.ArrayList; class Test { public static void main(String[] args) { // ArrayList erstellen ohne den Typ der Daten darin zu definieren  ArrayList hitchhikersInfo = new ArrayList(); hitchhikersInfo.add(\"Douglas\"); hitchhikersInfo.add(\"Adams\"); hitchhikersInfo.add(42); // Der Compiler erlaubt diese Zuweisung, da wir den Datentyp in der ArrayList nicht definiert haben  for (int i=0; i\u003c=hitchhikersInfo.size(); i++) { System.out.println((String) hitchhikersInfo.get(i)); // diesen Typ-Casting wäre nicht nötig gewesen, wenn wir die ArrayListe richtig definiert hätten!  } } }   Diese Klasse kompiliert ohne Fehler. Der Compiler warnt zwar, dass hier eine unsichere Operation durchgeführt wird, aber er erlaubt diese Operation und die Kompilation ist erfolgreich. Beim Ausführen des Programms kommt es jedoch zu einem Laufzeitfehler vom Typ ClassCastException, weil versucht wird ein Integer in einen String umzuwandeln (Typ-Casting): Generics helfen solche Laufzeitfehler mit sog. Typvariablen zu vermeiden. Diese Typvariablen werden zur Zeit der Implementierung zunächst durch Platzhalter repräsentiert und dann zum Zeitpunkt der Anwendung konkretisiert. Im obigen Beispiel hätte der Laufzeitfehler vermieden werden können, in dem wir die ArrayList als eine Liste von Strings definiert hätten:\n1 2 3 4  // ArrayList mit Elementen vom Typ String  ArrayList\u003cString\u003e hitchhikersInfo = new ArrayList\u003c\u003e(); ... hitchhikersInfo.add(42); // Der Compiler erlaubt diese Zuweisung nicht mehr   Beim Versuch, die Klasse erneut zu kompilieren, kommt es zum folgenden Fehler und die Kompilierung schlägt fehl: Generics in der Praxis In Java gibt es zwei Typen von Generics: generische Methoden und generische Klassen.\nEine generische Methode kann - wie andere “normale” Methoden auch - Parameter und einen Rückgabewert enthalten. Der Unterschied zu einer “normalen” Methode liegt darin, dass eine generische Methode sog. Typparameter bearbeitet. Somit kann eine generische Methode mit unterschiedlichen Datentypen benutzt werden.\nEine generische Klasse wird genau gleich wie eine nicht-generische Klasse umgesetzt. Der Unterschied liegt darin, dass die generische Klasse einen oder mehrere Typparameter definiert.\nTypparameter definieren In generischen Klassen wie auch in generischen Methoden, werden Typparameter mittels eines Grossbuchstabens definiert, welcher innerhalb spitziger Klammern geschrieben wird z.B: \u003cT\u003e oder \u003cI\u003e.\nMultiple Typparameter werden durch ein Komma getrennt: \u003cT, V\u003e\nTypparameter Namenskonvention Die Buchstaben, welche für die Definition von Typparametern verwendet werden, nutzen die folgende Namenskonvention:\n   Typname Zweck     T Type   E Element   K Key   N Number   V Value    Generische Klasse Um generische Klassen zu verwenden, wird zunächst die Klasse mit einem Typparameter definiert und bei der Anwendung dieser Klasse (bei der Instanziierung) wird innerhalb der spitzigen Klammern der konkrete Datentyp geschrieben.\nBeispiel einer benutzer-definierten, generischen Klasse\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // \u003cT\u003e definiert einen Typparameter class Test\u003cT\u003e { // Deklaration einer Member-Variable vom Typ T  T obj; // Konstruktor, erhält ein Object vom Typ T und initialisiert die Member-Variable damit  Test(T obj) { this.obj = obj; } // die Getter-Methode liefert ein Objekt vom Typ T zurück  public T getObject() { return this.obj; } }   Sofern sich die obige Klasse auf dem Klassenpfad befindet, kann sie nun wie folgt verwendet werden:\n1 2 3 4 5 6 7 8 9 10 11  class MyProgram { public static void main(String[] args) { // Instanziieren der generischen Klasse und setzen den Typ auf Integer  Test\u003cInteger\u003e integerObject = new Test\u003cInteger\u003e(42); System.out.println(integerObject.getObject()); // Output: 42  // instance of String type  Test\u003cString\u003e stringObject = new Test\u003cString\u003e(\"Generics are great!\"); System.out.println(stringObject.getObject()); // Output: Generics are great!  } }   In diesem Beispiel wurde dieselbe generische Klasse einmal mit einem Integer und einmal mit String verwendet. Dabei wurde die Typsicherheit sichergestellt.\nGenerische Methode Wie bei generischen Klassen werden auch bei generischen Methoden zunächst die Typparameter als Argumente für die Methode definiert und beim Aufruf der Methode werden die konkreten Datentypen mitgegeben.\nBeispiel einer generischen Methode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  public class Test { // Definition einer generischen Methode  static \u003cT\u003e void genericDisplay(T element) { System.out.println(element.getClass().getName() + \" = \" + element); } public static void main(String[] args) { // Die generische Methode wird mit einem Integer-Argument aufgerufen  // Achtung: hier wird nicht das primitive Typ \"int\" verwendet sondern die Wrapper-Klasse Integer!  genericDisplay(42); // Output: java.lang.Integer = 42  // Die generische Methode wird mit einem String-Argument aufgerufen  genericDisplay(\"Generics are great!!\"); // Output: java.lang.String = Generics are great!!  // Die generische Methode wird mit einem Double-Argument aufgerufen  // Achtung: hier wird nicht das primitive Typ \"double\" verwendet sondern die Wrapper-Klasse Double!  genericDisplay(42.0); // Output: java.lang.Double = 42.0  // Primitive Typen können nicht mit Generics verwendet werden  // aber eine ArrayList aus einem Array mit primitiven Typen ist erlaubt, weil Arrays Referenz-Typen sind!  ArrayList\u003cint[]\u003e arrayListOfIntArray = new ArrayList\u003c\u003e(); int[] oneAndTwo = {1, 2}; int[] threeAndFour = {3, 4}; arrayListOfIntArray.add(oneAndTwo); arrayListOfIntArray.add(threeAndFour); genericDisplay(arrayListOfIntArray); // Output: java.util.ArrayList = [[I@6b2fad11, [I@79698539]  } }   Bei der Definition von generischen Methoden gibt es einen Unterschied zwischen statischen Methoden und Member-Methoden einer Klasse.\nBei Member-Methoden, wird die generische Deklaration aus der Klassendefinition verwendet. Das heisst, der Typparameter, welche bei der Klassendefinition deklariert wird, wird dasselbe sein wie denjenigen, welche in der Member-Methode verwendet wird.\nStatische Methoden brauchen jedoch ihre eigen generische Deklaration - vor dem Rückgabewert-Typ. Das bedeutet, dass der Typparameter einer statischen Methode nicht vom selben Typ sein muss wie demjenigen aus der Klassendefinition (auch wenn beide Typparameter gleich heissen!).\n1 2 3 4 5 6 7 8 9 10 11  public class Test\u003cT\u003e { T obj; // Hier ist T nicht zwingend gleicher Typ wie denjenigen aus der Klassendefinition  public static \u003cT\u003e void staticMethod(T element) {...} // Hier entspricht der Rückgabewert-Typ denjenigen aus der Klassendefinition  public T getObject() { return this.obj; } }   Bounded Typparameter Es gibt Situationen, in denen es Sinn macht die Datentypen, welche als Argument in einem parametrisierten Typ verwendet werden dürfen, einzuschränken. Zum Beispiel, eine Methode, welche nur mit Zahlen funktionieren kann, sollte keine Datentypen zulassen, welche keine Zahl darstellen. Zu diesem Zweck werden sog. Bounded Type-Parameter verwendet.\nBounded Typparameter schränken die möglichen Typen schon bei der Erstellung der generischen Klasse/Methode ein.\nUm ein Bounded Typparameter zu definieren wird bei der Definition des Typparameters noch das Wort “extends” und der begrenzende Typ (“upper bound type”) hinzugefügt:\nBeispiel: \u003cT extends Number\u003e: T muss zwingend vom Typ Number sein\nIm folgenden Beispiel wird die Klasse “ZooExhibit” (Zoogehege) definiert, welche unterschiedlichen Arten von Tieren beherbergen kann:\n1 2 3 4  public class ZooExhibit\u003cT\u003e { private List\u003cT\u003e animals; ... }   Wenn wir die Klasse so definieren, könnte T durch alle mögliche Datentypen ersetzt werden:\n1 2 3 4 5 6 7  public class Main { public static void main(String[] args) { // T kann gemäss Definition auch z.B ein Integer sein!  // auch wenn ein Integer im Zoogehege nichts verloren hat...  ZooExhibit\u003cInteger\u003e zooExhibit = new ZooExhibit\u003c\u003e(); } }   Angenommen, wir haben eine Klasse “Animal” (mit Subklassen wie “Elephant”, “Zebra” usw.), können wir unsere ZooExhibit-Klasse so definieren, dass nur Animal-Typen verwendet werden dürfen:\n1 2 3 4 5 6 7 8 9 10 11 12 13  public class Animal { } public class Elephant extends Animal { } public class Zebra extends Animal { } public class ZooExhibit\u003cT extends Animal\u003e { private List\u003cT\u003e animals; ... }   Wenn wir nun unserem ZooExhibit befüllen möchten, erlaubt uns der Compiler dies nur mit Animal oder mit einer seinen Subklassen zu tun:\n1 2 3 4 5 6 7 8 9 10 11 12  public class Main { public static void main(String[] args) { // Die folgende Zeile wird nun vom Compiler nicht akzeptiert:  ZooExhibit\u003cInteger\u003e zooExhibit = new ZooExhibit\u003c\u003e(); // Zoogehege für Elefanten ist erlaubt, da Elephant ein Animal ist:  ZooExhibit\u003cElephant\u003e elephantExhibit = new ZooExhibit\u003c\u003e(); // Dasselbe gilt für Zebras:  ZooExhibit\u003cZebra\u003e zebraExhibit = new ZooExhibit\u003c\u003e(); } }   Wildcards In der generischen Programmierung wird das Fragezeichen (?) als Wildcard bezeichnet. Es repräsentiert eine Referenz auf einen unbekannten Typ.\nUm zu verstehen, wozu es Wildcards braucht, schauen wir uns ein Beispiel an: Angenommen, wir haben die Animal, Elephant und Zebra Klassen vom vorherigen Abschnitt definiert und dazu auch die folgende generische Klasse:\n1 2 3 4  public class AnimalList\u003cT extends Animal\u003e { private final List\u003cT\u003e animals = new ArrayList\u003c\u003e(); ... }   Nun möchten wir diese Klasse in einer anderen Klasse wie folgt verwenden:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  public class Zoo { public static void main(String[] args) { AnimalList\u003cElephant\u003e elephants = new AnimalList\u003c\u003e(); AnimalList\u003cZebra\u003e zebras = new AnimalList\u003c\u003e(); // Der Compiler gibt bei folgenden Zeilen eine Fehlermeldung!  printAnimalList(elephants); printAnimalList(zebras); } private static void printAnimalList(AnimalList\u003cAnimal\u003e animals) { System.out.println(animals) } }   Obwohl Elephant und auch Zebra beide ein Animal sind, gibt der Compiler eine Fehlermeldung beim Versuch, die Methode printAnimalList mit AnimalList resp. mit AnimalList aufzurufen.\nDieser Ansatz (die Super-Klasse zu verwenden, damit die Subklassen auch am gleichen Ort verwendet sein dürfen), funktioniert zwar mit Arrays, nicht aber mit generischen Klassen.\nDer Grund dafür ist der Zeitpunkt der Typ-Prüfung: Bei Arrays wird erst zur Laufzeit auf den richtigen Typ geprüft (und darum werden allfällige Fehler erst zur Laufzeit entdeckt). Bei Generics wird diese Prüfung durch den Compiler übernommen da sie zur Laufzeit wegen dem sog. Type-Erasure (dazu später) nicht erfolgen kann.\nDer Einsatz von Wildcards ermöglicht es, jeden beliebigen generischen Typ zu akzeptieren. Wenn wir nun die Methode printAnimalList mit einer Wildcard definieren, kompiliert der Rest vom Code einwandfrei:\n1 2 3  private static void printAnimalList(AnimalList\u003c?\u003e animals) { System.out.println(animals) }   Wenn man \u003c?\u003e verwendet, wird dies “unbeschränkter Wildcard Typ” (“unbounded wildcard”) genannt. Es besteht aber auch die Möglichkeit, Wildcards zu beschränken und zwar in zwei verschiedene Arten:\n Upper-Bound Beschränkung: Beschränkung auf einen Typ und dessen Kindtypen. Die Syntax sieht dann z.B. so aus: \u003c? extends Number\u003e (also irgendein Typ, solange er vom Typ Number oder einer Subklasse davon ist) Lower-Bound Beschränkung: Beschränkung auf einen Typ und dessen Supertypen. Die Syntax sieht dann z.B. so aus: \u003c? super Integer\u003e (also irgendein Typ, solange er vom Typ Integer oder einer Superklasse davon ist)  Type Erasure Generics werden nur vom Compiler behandelt und verschwinden zur Laufzeit. Das heisst, der Compiler entfernt beim Kompilieren alle Informationen, die durch Generics definiert wurden. Das bedeutet, dass zur Laufzeit nicht bestimmt werden kann, welcher generische Typ verwendet wurde. Grund für dieses Verhalten war die Notwendigkeit zur Bewahrung der Abwärtskompatibilität zu älteren Java-Versionen, welche keine Generics kennen.\nDas Entfernen der generischen Informationen heisst “type erasure” und der Compiler wendet dies an um:\n Alle Typparameter in generischen Typen mit ihren “bound”-Typen (falls definiert) oder mit Object umzutauschen. Der prduzierte Bytecode beinhaltet dann nur “normale” Klassen, Interfaces und Methoden. Type-Casting dort wo nötig hinzuzufügen, um die Typsicherheit bewahren zu können Sog. Bridge-Methoden zu generieren, um Polymorphismus in erweiterte generische Typen zu bewahren  ","categories":"","description":"Modul #J2 - Generics I\n","excerpt":"Modul #J2 - Generics I\n","ref":"/docs/java/java-generics/","tags":"","title":"Java Generics Grundlagen"},{"body":"Aufgabe 1 Die Aufgaben folgen in Kürze\n","categories":"","description":"Aufgaben zu [Java Collections - LinkedList](../../../../docs/java/java-collections/07_linked_list)\n","excerpt":"Aufgaben zu [Java Collections - …","ref":"/labs/java/java-collections/06_linked_list/","tags":"","title":"LinkedList - Aufgaben"},{"body":"java.util.Queue Eine Queue ist ähnlich einem Stack ein Behälter, in den Elemente eingefügt und nur in einer bestimmten Reihenfolge wieder entnommen werden können. Bei den Queues gilt das First In First Out (=FIFO) Prinzip: Das Einfügen eines Elements erfolgt an einem Ende und heisst EnQueue. Die Entfernung eines Elements erfolgt dann am anderen Ende und heisst DeQueue. Das heisst also, das erste Elemente, das einer Queue eingefügt wird, ist das Element das zuerst der Queue entnommen werden kann. Queues können in ihrer Grösse beschränkt oder unbeschränkt sein.\nAuf Deutsch könnte man Queues als “Warteschlangen” bezeichnen. Wir kennen Warteschlangen von unserem Alltag: Beispielsweise vom Einkaufen, wo es eine Schlange von Kunden gibt, die an der Kasse auf einen Kassierer warten. Ein Kunde stellt sich zu hinterst an und rückt “in der Warteschlange” vor, wenn vorherigen Kunden bedient wurden.\nAlle Methoden vom Interface java.util.Queue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  /* * Fügt das angegebene Element in diese Queue ein, * wenn dies möglich ist, ohne Kapazitätsbeschränkungen zu verletzen. * Bei Erfolg wird true zurückgegeben. Eine IllegalStateException wird ausgelöst, wenn derzeit * kein Platz verfügbar ist. */ boolean add(E e); /* * Fügt das angegebene Element in diese Queue ein, * wenn dies möglich ist, ohne Kapazitätsbeschränkungen zu verletzen. * Bei Erfolg wird true zurückgegeben und sonst wird false zurückgegeben. * * Bei der Verwendung einer Queue mit Kapazitätsbeschränkungen ist diese Methode in der Regel add(E e) vorzuziehen, * da bei Verletzung der Kapazitätsbeschränkungen keine Exception geworfen wird, sondern false zurückgegeben wird. * */ boolean offer(E e); /* * Gibt das Element am Anfang des Queues zurück und entfernt es in der Queue. * Falls die Queue leer ist, dann wird null zurückgegeben. */ E poll(); /* * Gibt das Element am Anfang des Queues zurück und entfernt es in der Queue. * Diese Methode unterscheidet sich von poll() nur darin, dass sie eine Exception auslöst, wenn die Queue leer ist. */ E remove(); /* * Gibt das Element am Anfang des Queues zurück, entfernt es aber nicht. * Gibt null zurück, wenn die Queue leer ist. */ E peek(); /* * Gibt das Element am Anfang des Queues zurück, entfernt es aber nicht. * Diese Methode unterscheidet sich von peek() nur darin, dass sie eine Exception auslöst, wenn die Queue leer ist. */ E element();   java.util.Deque Die Deque ist eine Queue mit zwei Enden, und Datenelemente können an beiden Enden hinzugefügt oder entfernt werden. Die Deque in Java wird über die das Interface java.util.Deque implementiert, die ein Subtyp des Interface java.util.Queue ist.\nAlle Methoden vom Interface java.util.Deque 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104  /* * Fügt das angegebene Element an den Anfang dieser Deque ein, * wenn dies möglich ist, ohne Kapazitätsbeschränkungen zu verletzen * und löst eine IllegalStateException aus, wenn derzeit kein Platz verfügbar ist. */ void addFirst(E e); /* * Fügt das angegebene Element an das Ende dieser Deque ein, * wenn dies möglich ist, ohne Kapazitätsbeschränkungen zu verletzen * und löst eine IllegalStateException aus, wenn derzeit kein Platz verfügbar ist. */ void addLast(E e); /* * Fügt das angegebene Element an den Anfang dieser Deque ein, * wenn dies möglich ist, ohne Kapazitätsbeschränkungen zu verletzen. * Bei Erfolg wird true zurückgegeben und sonst wird false zurückgegeben. * * Bei der Verwendung einer Deque mit Kapazitätsbeschränkungen ist diese Methode in der Regel addFirst(E e) vorzuziehen, * da bei Verletzung der Kapazitätsbeschränkungen keine Exception geworfen wird, sondern false zurückgegeben wird. * */ boolean offerFirst(E e); /* * Fügt das angegebene Element an das Ende dieser Deque ein, * wenn dies möglich ist, ohne Kapazitätsbeschränkungen zu verletzen. * Bei Erfolg wird true zurückgegeben und sonst wird false zurückgegeben. * * Bei der Verwendung einer Deque mit Kapazitätsbeschränkungen ist diese Methode in der Regel addLast(E e) vorzuziehen, * da bei Verletzung der Kapazitätsbeschränkungen keine Exception geworfen wird, sondern false zurückgegeben wird. * */ boolean offerLast(E e); /* * Gibt das Element am Anfang des Deques zurück und entfernt es in der Deque. * Falls die Deque leer ist, dann wird null zurückgegeben. */ E pollFirst(); /* * Gibt das Element am Ende des Deques zurück und entfernt es in der Deque. * Falls die Deque leer ist, dann wird null zurückgegeben. */ E pollLast(); /* * Gibt das Element am Anfang des Deques zurück und entfernt es in der Deque. * Diese Methode unterscheidet sich von pollFirst() nur darin, dass sie eine Exception auslöst, wenn die Deque leer ist. */ E removeFirst(); /* * Gibt das Element am Ende des Deques zurück und entfernt es in der Deque. * Diese Methode unterscheidet sich von pollLast() nur darin, dass sie eine Exception auslöst, wenn die Deque leer ist. */ E removeLast(); /* * Gibt das Element am Anfang des Deques zurück, entfernt es aber nicht. * Gibt null zurück, wenn die Deque leer ist. */ E peekFirst(); /* * Gibt das Element am Ende des Deques zurück, entfernt es aber nicht. * Gibt null zurück, wenn die Deque leer ist. */ E peekLast(); /* * Gibt das Element am Anfang des Deques zurück, entfernt es aber nicht. * Diese Methode unterscheidet sich von peekFirst() nur darin, dass sie eine Exception auslöst, wenn die Deque leer ist. */ E getFirst(); /* * Gibt das Element am Ende des Deques zurück, entfernt es aber nicht. * Diese Methode unterscheidet sich von peekLast() nur darin, dass sie eine Exception auslöst, wenn die Deque leer ist. */ E getLast(); /* * Entfernt das erste Vorkommen des angegebenen Elements aus dieser Deque, * sofern es vorhanden ist. Wenn diese Deque das Element nicht enthält, * bleibt sie unverändert. */ boolean removeFirstOccurrence(Object o); /* * Entfernt das letzte Vorkommen des angegebenen Elements aus dieser Deque, * sofern es vorhanden ist. Wenn diese Deque das Element nicht enthält, * bleibt sie unverändert. */ boolean removeLastOccurrence(Object o); // *** Queue methods *** ... // *** Stack methods *** ...   Im Interface java.util.Deque sind Queue und Stack Methoden ebenfalls deklariert. Deques, bei denen Elemente nur an einem Ende eingefügt und am nur anderen Ende entnommen werden, stellen wiederum Queues dar. Deques, bei denen Elemente an einem Ende eingefügt und am gleichen Ende entnommen werden, stellen Stacks dar.\n Aufgaben    Aufgaben Aufgaben zu Modul #J7 - Java Collections - Queue + Deque\n","categories":"","description":"Die Datenstruktur für eine Warteschlange: die Queue.\n","excerpt":"Die Datenstruktur für eine Warteschlange: die Queue.\n","ref":"/docs/java/java-collections/06_queue/","tags":"","title":"Queue + Deque"},{"body":"Ziele  Du weisst, wie du Variablen deklarierst. Du weisst, wann du eine Variable mit var, let oder const deklarierst. Du kannst das “Object Destructuring Assignment” anwenden  Basics In JavaScript deklarierst du Variablen mit dem let- oder const-Keyword - egal welcher Typ die Variable haben wird.\nDas folgende Listing zeigt auf, wie du mit Variablen deklarieren und zuweisen (“assign”) kannst:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  let a = \"A\"; const b = \"B\"; console.log(a); \u003e\u003e\u003e A console.log(b) \u003e\u003e\u003e B a = \"AA\" console.log(a); \u003e\u003e\u003e AA b = \"BB\" \u003e\u003e\u003e Uncaught TypeError: Assignment to constant variable. at \u003canonymous\u003e:1:3   Wie du siehst, kannst du eine mit let deklarierte Variable verändern. Veränderst du eine const-Variable, wird ein Fehler geworfen.\n Als Grundsatz gilt: Verwende immer const, ausser du willst später der Variable im gleichen Scope (nächster Abschnitt) einen anderen Wert zuweisen. Dann verwende let.\n Die Verwendung von const per Default hat die Vorteile, dass so Side-Effects vermieden werden können, welche auf Grund des Neu-Zuweisens von Variablen geschehen können. Wenn du z.B. sehr viele Variablen in einer Funktion hast, müsstest du überprüfen, dass du zuerst sicherstellen, dass deine neue Variable keine bestehende Variable im gleichen Scope überschreibst. Verwendest du standardmässig const, wird dir ein Fehler geworfen, der dir dann direkt ins Auge sticht.\nScope Block-Scope Variablen, die mit const oder let definiert wurden, sind in ihrem Block-Scope sichtbar und verwendbar.\nEs ist sehr wichtig, dass du folgenden Code komplett verstehst und wieso es zum entsprechenden Resultat führt - und warum die Verwendung von const nicht zu einem Fehler führt:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  const a = \"File\"; console.log(1, a); function myFunction(a=\"Argument\") { console.log(2, a); if (true) { const a = \"if\"; console.log(3, a); } console.log(4, a); } myFunction(); console.log(5, a);   Dies produziert folgenden Output:\n1 2 3 4 5  1 File 2 Argument 3 if 4 Argument 5 File   Global Scope und Function Scope Vor ES6 kannte JavaScript keinen Block-Scope, sondern nur einen globalen Scope und einen Function Scope.\nUm das zu verstehen, lasse diesen Code einmal laufen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  var a = 10; console.log(a); function myFunction(a = 20) { console.log(a); if (true) { var a = 21; console.log(a); for (var a = 30; a \u003c 33; a++){ console.log(a); for (var a = 40; a \u003c 44; a++) { console.log(a); } } console.log(a); } console.log(a); } myFunction(); console.log(a); var a = 11; console.log(a);   Du solltest dann folgende Zahlen im Output erhalten:\n1  10, 20, 21, 30, 40, 41, 42, 43, 45, 45, 10, 11   Wie du siehst, haben alle Variablen, die innerhalb einer Funktion mit var deklariert werden, den gleichen Scope: Das bedeutet, dass du z.B. eine var-Variable, die du ganz oben in der Funktion definierst, veränderst, wenn du eine gleichnamige später in einer for-Schleife mit var definierst.\nEinen solchen Function Scope haben nur Variablen, die mit var definiert wurden. Variablen, die mit let oder const definiert wurden, haben einen Block-Scope und sind daher innerhalb ihres Blocks (for/while-Schlaufe, if/else-Block, Funktion, Datei) definiert und sichtbar. In Java gilt der Block Scope immer.\nHierzu findest du eine Aufgabe im Lab (Aufgabe 4).\nWann var verwenden? Folgender Grundsatz gilt:\n Verwende nie var, ausser du musst sicherstellen, dass der Code in Browser funktioniert, welche vor 2015 aktualisiert worden sind.\n Wenn du wissen willst, wieso var nicht mehr verwendet werden sollte, dann kannst du dein Wissen hier vertiefen: https://medium.com/@codingsam/awesome-javascript-no-more-var-working-title-999428999994.\nDestructuring Assignment In JavaScript siehst du sehr oft, dass mehrere Variablen auf einmal definiert werden.\nWie in anderen Programmiersprachen kannst du Variablen in einem einzigen Statement definieren (das ist kein Destructuring Assignment):\n1  const a = \"A\", b = \"B\";   Nun kommt es oft vor, dass du in einem einzigen Methodenaufruf mehrere Werte zurückbekommst - in Form eines Arrays/Liste oder in Form eines Objekts. Oft willst du dann die einzelnen Werte in eigene Variablen speichern. Wie du das machen kannst, wird in den nächsten zwei Unterkapitel behandelt:\nDestructuring Arrays Bekommst du ein Array und willst du z.B. den ersten und zweiten Wert aus einem Array je einer Variablen zuweisen, dann würdest du das normalerweise tun:\n1 2  const array = ['A', 'B']; const a = array[0], b = array[1];   Diese Schreibweise kannst du mit folgender Syntax vereinfachen:\n1  const [a, b] = ['A', 'B'];   Ist z.B. das erste Element ein Index/Key/Zeilen- bzw. Spaltenname/… und der Rest das eigentliche Array, dann hilft dir vielleicht diese Schreibweise:\n1  const [name, ...values] = [\"ColumnName\", 1, 2, 3, 4];   Hier hat name den Wert “ColumnName” und values ist das Array [1, 2, 3, 4].\nObject Destructuring Diese Schreibweise ist dir sicher schon einmal aufgefallen:\n1  const {a, b} = anotherObject;   Das ist auch ein ganz einfaches Prinzip. Wenn du nachfolgenden Code verstanden hast, dann weisst du alles, was du zu diesem Thema wissen musst:\n1 2 3 4 5 6  const object = {a: \"A\", b: \"B\", c: \"C\", d: \"D\"}; const {a: one, d, b} = object; console.log(one, b, d); \u003e\u003e\u003e A B D   In diesem Beispiel haben wir den Wert für a in die Variable one kopiert.\nWie du siehst, spielt hier die Reihenfolge der Variablen keine Rolle.\n Schritt-für-Schritt-Erklärung zum Beispiel Die ersten zwei Anweisungen könnten auch in einer zusammengefasst werden:\n1  const {a: one, d, b} = {a: \"A\", b: \"B\", c: \"C\", d: \"D\"};   Ignorieren wir zuerst die Variable a bzw. one.\n Auf der linken Seite deklarieren wir die Variablen d und b. Die Felder d und b aus dem Objekt auf der rechten Seite werden in die Variablen d und b auf der linken Seite kopiert.  Die Variablen auf der linken Seite müssen nicht zwingend in der gleichen Reihenfolge stehen wie auf der rechten Seite. Sie müssen lediglich gleich heissen.   Auf der linken Seite sieht a: one vielleicht noch verwirrend aus, vor allem wenn du bereits TypeScript kennst.  Diese bedeutet nur, dass du die Variable a von der rechten Seite in eine Variable mit einem anderen Namen one kopierst. Folglich hast du eine Variable one deklariert und zugewiesen. Eine Variable a hast du hier NICHT deklariert.   Anschliessend gibts du die Werte von one, b und d aus mit console.log(one, b, d);.  Hätten wir versucht, eine Variable a auszugeben, hätte das einen Fehler verursacht, weil keine solche Variable definiert wurde. Das Gleiche mit c.     ","categories":"","description":"Seit ES2015 (ES6) gibt es in JavaScript weitere neue Möglichkeiten, wie Variablen definiert werden können. Hier schauen wir uns einige davon an.\n","excerpt":"Seit ES2015 (ES6) gibt es in JavaScript weitere neue Möglichkeiten, …","ref":"/docs/web/javascript/07_variables/","tags":"","title":"ES6: Variablen deklarieren"},{"body":"Nicht-semantische Tags Oft kommst du in die Situation, wo du mehrere Elemente in einem anderen Element gruppieren willst. In den aller meisten Fällen verwendet man dafür div-Elemente.\n\u003cdiv\u003e-Tags werden oft als Container für HTML-Elemente verwendet. Dieser Container kann dann mit CSS gestylt oder mit JavaScript manipuliert werden. Probiere das nächste Beispiel einmal aus, ohne das Styling zu verstehen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  Just a Text \u003cdiv class=\"content\"\u003e \u003ch1\u003eHello\u003c/h1\u003e \u003cp\u003eThis is my amazing website!\u003c/p\u003e \u003c/div\u003e Other Text \u003cstyle\u003e .content { width: 20em; padding: 1em; border-radius: 1em; background-color: orange; } \u003c/style\u003e   Das ist ein typisches Beispiel für die Verwendung von \u003cdiv\u003es.\nMöchtest du hingegen ein paar Wörter (aber nicht einen ganzen Block/Paragrafen) speziell stylen, wird oft ein \u003cspan\u003e-Element verwendet. Möchtest du z.B. das Datum in einem Text hervorheben, dann könnte das z.B. so aussehen:\n1 2 3 4 5 6 7 8  Das nächste Event findet am \u003cspan class=\"date\"\u003e20. Mai\u003c/span\u003e statt. \u003cstyle\u003e .date { font-size: 1.25em; font-weight: bold; color: blue; } \u003c/style\u003e   In den beiden oberen Beispielen wurde bei den Tags eine Klasse angegeben. Der Sinn dahinter war, dass wir alle Elemente mit der gleichen Klasse gleich stylen können.\nSemantische Tags Mit HTML5 wurden viele neue semantische Tags eingeführt, die in vielen Fällen \u003cdiv\u003es und \u003cspan\u003es ersetzen.\nDas “Zeit”-\u003cspan\u003e-Beispiel könnte z.B. folgendermassen vereinfacht werden:\n1 2 3 4 5 6 7 8  Das nächste Event findet am \u003ctime\u003e20. Mai\u003c/time\u003e statt. \u003cstyle\u003e time { font-size: 1.25em; font-weight: bold; color: blue; } \u003c/style\u003e   In HTML5 wurden viele neue Tags eingeführt, die die Struktur von HTML-Dateien genauer beschreiben. Oft hat eine Website eine ähnliche Struktur wie die folgende:\nDer \u003cheader\u003e ist meistens das, was auf einer Website zuoberst ist. Dieser enthält oft den Titel der Applikation, das Logo der Firma und evtl. noch eine \u003cnav\u003eigation (also Links wie für ‘Home’, ‘About’, …).\nDas Gegenteil des \u003cheader\u003es ist der \u003cfooter\u003e. Der Footer befindet sich oft am Ende der Website (also ganz unten) und enthält oft das Copyright sowie weiterführende Links wie z.B. solche zu den Datenschutzbestimmungen.\nNicht auf diesem Bild, aber trotzdem relevant: Oft befindet sich der Hauptteil einer Website (also nicht der Header, Footer, Werbung) in einem \u003cmain\u003e-Element. Wenn die Website einen Leseartikel beschreibt, dann wäre der Text inkl. Überschriften dort drin.\nEinzelne Abschnitte (z.B. Unterkapitel inkl. Überschriften) werden oft in \u003csection\u003es gepackt und sind in diesem Beispiel eine gute Alternative zu \u003cdiv\u003es.\nWas genau ein \u003carticle\u003e ist, würde den Rahmen hier definitiv sprengen. Auf jeden Fall beschreibt ein article ein von der aktuellen Website unabhängiges und in sich abgeschlossenes Element. Ein article-Element könnte man also einfach von der aktuellen Seite ausschneiden und in eine andere kopieren.\nBitte schaue dir diese Dokumentation zu HTML Semantic Tags an. Dort sind auch \u003carticle\u003es genauer beschrieben: https://www.w3schools.com/html/html5_semantic_elements.asp\nMit semantischen Tags könnte man z.B. das\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e\u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"header\"\u003e \u003ch1\u003eThe Header\u003c/h1\u003e \u003cdiv class=\"nav-links\"\u003e \u003cp\u003eNav:\u003c/p\u003e \u003cp\u003eHome\u003c/p\u003e \u003cp\u003eNews\u003c/p\u003e \u003cp\u003eAbout\u003c/p\u003e \u003c/div\u003e \u003c/div\u003e \u003cdiv id=\"content\"\u003e \u003ch1\u003eThe Article - BANANA TREE\u003c/h1\u003e \u003cdiv id=\"section-1\"\u003e \u003ch2\u003eSection 1\u003c/h2\u003e \u003cp\u003eA banana tree is a must if you wish to bring a sizeable touch of the tropics into your home.\u003c/p\u003e \u003c/div\u003e \u003cdiv id=\"section-2\"\u003e \u003ch2\u003eSection 2\u003c/h2\u003e \u003cp\u003eThere are some 400 species worldwide.\u003c/p\u003e \u003cdiv class=\"move-to-the-right\"\u003e \u003ch2\u003eA Aside - Why are bananas bent?\u003c/h2\u003e Gravity causes the fruit to hang down. \u003c/div\u003e \u003c/div\u003e \u003cp\u003eThe text is from: \u003ca href=\"https://www.thejoyofplants.co.uk/banana-tree\"\u003eThe Joy of Plants.co.uk\u003c/a\u003e\u003c/p\u003e \u003c/div\u003e \u003cdiv id=\"end-of-the-page\"\u003e \u003ch2\u003eThe Footer\u003c/h2\u003e \u003cdiv\u003e \u003cp\u003eContact\u003c/p\u003e \u003cp\u003eImpressum\u003c/p\u003e \u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e   in das vereinfachen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e\u003c/head\u003e \u003cbody\u003e \u003cheader\u003e \u003ch1\u003eThe Header\u003c/h1\u003e \u003cnav\u003e \u003cp\u003eNav:\u003c/p\u003e \u003cp\u003eHome\u003c/p\u003e \u003cp\u003eNews\u003c/p\u003e \u003cp\u003eAbout\u003c/p\u003e \u003c/nav\u003e \u003c/header\u003e \u003cmain\u003e \u003carticle\u003e \u003ch1\u003eThe Article - BANANA TREE\u003c/h1\u003e \u003csection\u003e \u003ch2\u003eSection 1\u003c/h2\u003e \u003cp\u003eA banana tree is a must if you wish to bring a sizeable touch of the tropics into your home.\u003c/p\u003e \u003c/section\u003e \u003csection\u003e \u003ch2\u003eSection 2\u003c/h2\u003e \u003cp\u003eThere are some 400 species worldwide.\u003c/p\u003e \u003caside\u003e \u003ch2\u003eA Aside - Why are bananas bent?\u003c/h2\u003e Gravity causes the fruit to hang down. \u003c/aside\u003e \u003c/section\u003e \u003cp\u003eThe text is from: \u003ca href=\"https://www.thejoyofplants.co.uk/banana-tree\"\u003eThe Joy of Plants.co.uk\u003c/a\u003e\u003c/p\u003e \u003c/article\u003e \u003c/main\u003e \u003cfooter\u003e \u003ch2\u003eThe Footer\u003c/h2\u003e \u003cdiv\u003e \u003cp\u003eContact\u003c/p\u003e \u003cp\u003eImpressum\u003c/p\u003e \u003c/div\u003e \u003c/footer\u003e \u003c/body\u003e \u003c/html\u003e   - Hierzu findest du eine Aufgabe im Lab.\n","categories":"","description":"Tags, die ihre Bedeutung dem Browser und dem Entwickler beschreiben.\n","excerpt":"Tags, die ihre Bedeutung dem Browser und dem Entwickler beschreiben.\n","ref":"/docs/web/html_css/07_html_5_semantic_tags/","tags":"","title":"HTML5 Semantic Tags"},{"body":"Dies ist sehr praktisch wenn wir Authentifizierungs Token konfigurieren, Protokolle der Requests erstellen und benutzerdefinierte Header hinzufügen wollen.\nUm einen Interceptor zu implementieren, müssen wir eine Klasse erstellen, die die “Intercept”-Methode des “HttpInterceptor”-Interface implementiert.\nDer folgende Interceptor ist sehr simpel gehalten. Er gibt einfach jeden Request in der Konsole aus:\n1 2 3 4 5 6 7 8 9 10  @Injectable() export class RequestLogInterceptor implements HttpInterceptor { intercept( request: HttpRequest\u003cany\u003e, next: HttpHandler ) : Observable\u003cHttpEvent\u003cany\u003e\u003e { console.log(request.url); return next.handle(request); } }   Die Intercept-Methode wandelt jeden Request in Observables um, die später durch Aufrufen von next.handle() aufgelöst werden. Für unsere Implementierung ist es also ganz einfach: Wir nehmen den Request entgegen, protokollieren den URL und rufen next.handle() auf, um den Request an den Server zu senden, ohne Änderungen daran vorzunehmen.\nInterceptors Providen Da Interceptors Dependencies des HttpClient sind, müssen wir sie den Providern im selben Injektor hinzufügen, der den HttpClient bereitstellt. Angenommen, wir haben unser HttpClientModule in das AppModule importiert, müssen wir die Interceptors auch dort zu den Providern hinzufügen.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  //... import { HTTP_INTERCEPTORS} from '@angular/common/http'; import { RequestLogInterceptor} from '...'; @NgModule({ //...  imports: [ HttpClientModule, ... ], providers: [ { provide: HTTP_INTERCEPTORS, useClass: RequestLogInterceptor, multi: true }, ... ], ... }) export class AppModule{ }   Die Option multi: true teilt Angular mit, dass Wir mehrere Interceptors bereitstellen, und ist erforderlich, wenn dies das Szenario ist. In unserem Beispielszenario wäre dies nicht erforderlich, da wir nur einen Interceptor implementiert haben.\nEs ist auch wichtig zu berücksichtigen, dass Angular Interceptors in der Reihenfolge anwendet, in der sie bei den Providers des Moduls angegeben sind.\n","categories":"","description":"Interceptors in Angular sind eine einfache Möglichkeit des Frameworks, die http-Requests global abzufangen und zu verändern, bevor sie an den Server gesendet werden. \n","excerpt":"Interceptors in Angular sind eine einfache Möglichkeit des Frameworks, …","ref":"/docs/web/angular/04_6_interceptors/","tags":"","title":"Interceptors"},{"body":"","categories":"","description":"Exercises zu Modul #J4 - Testing\n","excerpt":"Exercises zu Modul #J4 - Testing\n","ref":"/labs/java/java-testing/","tags":"","title":"Java Exercises - Testing"},{"body":"java.util.LinkedList LinkedLists sind verkettete Listen. D.h. die Elemnte der Listen sind zu einander verkettet und nicht wie bei einer ArrayList an bestimmten Positionen platziert.\njava.util.LinkedList implementiert zwei Collection-Interfaces: java.util.List und java.util.Deque. Das bedeutet grundsätzlich, dass sie sowohl die Methoden des List-Interfaces implementiert, als auch die des Deque-Interfaces.\nGrundsätzlich gibt es zwei Arten von verketteten Listen: Einfach verkettete Listen und doppelt verkettete Liste. Wir werden beide anschauen, wie sie im Allgeimeinen aussehen. Die java.util.LinkedList ist die Implementierung einer doppelt verketteten Liste..\nEinfach verkettete Listen Verkettete Listen bestehen aus Knoten (Nodes). Jeder Knoten enthält ein Element und eine Referenz auf einen weiteren Knoten, falls dieser vorhanden ist. Die Knoten sind somit über eine Referenz auf jeweils den nächsten Knoten miteinander verkettet. Die verkettete Liste enthält schlussendlich eine Referenz auf den ersten Knoten in der Liste. Der letzte Knoten enthält eine Referenz auf null.\nElement zu einer einfach verketten Liste hinzufügen Wird ein Knoten zu einer einfach verketteten Liste hinzugefügt, dann muss die Referenz des Knotens davor auf dieses Element zeigen und die Referenz des Elements, das hinzugefügt wird, muss auf den nächsten Knoten zeigen. So wird ein neuer Knoten zwischen zwei Knoten eingeschoben.\nElement zu aus einer einfach verketten Liste löschen Wird ein Knoten aus einer einfach verketteten Liste gelöscht, dann muss die Referenz des Knotens davor auf das zu löschende Element gelöscht werden und ersetzt werden mit der Referenz auf das nächste Element. Die Referenz des Elements, das gelöscht wird, auf das nächste Element muss auch gelöscht werden. So wird ein bestehender Knoten zwischen zwei Knoten entfernt.\nDoppelt verkettete Listen In einer doppelt verketteten Liste haben die Knoten nicht nur eine Referenz auf den nächsten Knoten, sondern auch eine Referenzen auf den vorherigen Knoten. Eine mögliche Implementierung einder doppelt verketteten Liste könnte sein, dass der letzte Knoten, wie auch schon bei einer einfach verketteten Liste eine Referenz auf null hat als nächsten Knoten und der erste Knoten in einer doppelt verketteten Liste eine Referenz auf null hat als vorherigen Knoten. Zusätzlich hat man eine Referenz auf den Kopf der Liste, d.h. auf den ersten Knoten und eine Referenze auf den letzten Knoten der Liste.\nDas Einfügen und Entfernen funktioniert analog zu einer einfach verketteten Liste.\nEin Element aus einer (einfach oder doppelt) verketteten Liste auslesen Wenn man ein Element in einer einfach verketteten Liste auslesen möchte, dann muss man vom ersten Knoten anfangen und ein Knoten nach dem anderen die Liste durchlaufen bis zu diesem Element. Im “schlimmsten” Fall muss über alle Knoten iteriert werden, wenn das Element, das mun sucht, im letzten Knoten ist.\nArrayList vs. LinkedList Der Vorteil von LinkedLists besteht darin, dass Elemente schneller hinzugefügt und schneller aus der Liste gelöscht werden können im Vergleich zu ArrayLists. Bei einer LinkedList müssen nur die Referenzen zum “Vorgänger” und “Nachfolgen” angepasst werden, wenn man ein Element einfügen oder löschen möchte. Der Nachteil jedoch besteht darin, dass der Zugriff auf Elementen der Liste an einer bestimmten Position im Vergleich zu ArrayLists langsamer ist, da in diesem Fall die Liste bis zu dem entsprechenden Element durchlaufen werden muss. Die Entscheidung für einen bestimmten Listen-Typ ist also abhängig von der Art und Anzahl der Zugriffe.\nLinkedList-Klasse im Java Die LinkedList-Klasse im Java (java.util.LinkedList) implementiert eine doppelt verkettete Liste. Sie ist so implementiert, dass sie zwei Referenzen enthält, zum einen die Referenz zum ersten Knoten und zum anderen die Referenz zum zweiten Knoten:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  public class LinkedList\u003cE\u003e extends AbstractSequentialList\u003cE\u003e implements List\u003cE\u003e, Deque\u003cE\u003e, Cloneable, java.io.Serializable { transient int size = 0; /** * Pointer to first node. */ transient Node\u003cE\u003e first; /** * Pointer to last node. */ transient Node\u003cE\u003e last; ... }   Ein Knoten, also das Objekt des Typs Node, enthält\n das Element, welches einen generischen Typ hat (deshalb Node\u003cE\u003e), die Referenz auf den vorherigen Knoten, also auf ein Node-Objekt und eine Referenz auf den nächsten Knoten.  Die statische Klasse Node\u003cE\u003e ist innerhalb der Klasse java.util.LinkedList definiert:\n1 2 3 4 5 6 7 8 9 10 11 12  private static class Node\u003cE\u003e { E item; Node\u003cE\u003e next; Node\u003cE\u003e prev; Node(Node\u003cE\u003e prev, E element, Node\u003cE\u003e next) { this.item = element; this.next = next; this.prev = prev; } }   Einige Methoden der Klasse java.util.LinkedList 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  /* * Konstruktor: Erstellt eine initial leere Liste */ public LinkedList() /* * Gibt das erste Element der Liste zurück. */ public E getFirst() /* * Gibt das letzte Element der Liste zurück. */ public E getLast() /* * Entfernt das erste Element der Liste und gibt es zurück. */ public E removeFirst() /* * Entfernt das letzte Element der Liste und gibt es zurück. */ public E removeLast() /* * Fügt das angegeben Element an den Anfang der Liste ein. */ public void addFirst(E e) /* * Fügt das angegebene Element an das Ende der Liste an. */ public void addLast(E e) ... // *** Queue and Deque methods ***  ... // *** Stack methods ***  ... // *** List methods ***  ...   Beispiele Beispiele kommen noch\n Aufgaben    Aufgaben Aufgaben zu Modul #J7 - Java Collections - LinkedList\n","categories":"","description":"Eine verkettete Liste, die LinkedList.\n","excerpt":"Eine verkettete Liste, die LinkedList.\n","ref":"/docs/java/java-collections/07_linked_list/","tags":"","title":"LinkedList"},{"body":"Ziele  Ich kann die Konzepte der Generalisierung und Spezialisierung im Kontext der Vererbung erklären und anwenden Ich weiss, wie ich Unterklassen von einer Oberklasse ableiten kann (extends) Ich kann vererbte Methoden und Attribute einer Klasse von lokalen Methoden und Attributen unterscheiden Ich kann in UML die Vererbungsbeziehung zweier Klassen erkennen Ich weiss, wie ich das Schlüsselwort super nutze, um den Konstruktor der Oberklasse zu verwenden Ich weiss, wie ich das Schlüsselwort super nutze, um eine Methode aus der Oberklasse aufzurufen Ich kann das Konzept des “Überschreibens” (Overriding) von Methoden und Attributen erklären, erkennen und nutzen Ich weiss, was Interfaces sind und wann es angebracht ist ein Interface zu verwenden Ich weiss, welche Methoden und Felder in einem Interface vorhanden sind und wie sie geschrieben werden bzw. über welche Eigenschaften sie verfügen Ich kann eine Klasse schreiben, die ein Interface implementiert   Einführung Beim objektorientierten Design (OOD) handelt es sich um die Modellierung der “echten” Welt in Klassen und Objekten. In dieser Phase der Softwareentwicklung werden Objekte und Klassen definiert, ihre Eigenschaften und Funktionen wie auch die Beziehung untereinander festgelegt.\nWichtige Konzepte/Prinzipien des objektorientierten Designs sind:\n Vererbung ermöglicht in Java die hierarchische Ordnung für Klassen festzulegen und reduziert somit die Menge des redundanten Codes. Polymorphismus ist eine Sprachstruktur, nach der beim Zugriff auf Methoden mit gleicher Signatur diese unterschiedliche Ergebnisse liefern. Abstraktion ist eine Methode, bei der durch Reduzieren oder Entfernen von Merkmalen nur die wesentlichen Eigenschaften erhalten bleiben. Kapselung ermöglicht es den Zugriff auf Methoden und Attributen von Klassen zu kontrollieren.  Das Befolgen dieser Konzepte/Prinzipien führt zu einem guten objektorientierten Design und trägt wesentlich zur Qualität der Software bei.\nVererbung Vererbung ist ein Mechanismus zum Ableiten einer neuen Klasse von einer anderen Klasse. Die neue Klasse erbt alle nicht-privaten Felder und Methoden der Basisklasse. Die Vererbung ist eines der Hauptkonzepte der objektorientierten Programmierung.\nAls Beispiel dient uns die Klasse Auto, welche von der Klasse Fahrzeug abgeleitet ist. Die Beziehung zwischen den Klassen wird als IS-A Beziehung bezeichnet. Wir würden also logischerweise sagen, dass ein Auto ein Fahrzeug ist. Die Klasse Auto wird auch als Spezialisierung der Klasse Fahrzeug bezeichnet. Umgekehrt bezeichnen wir die Klasse Fahrzeug als Generalisierung der Klasse Auto.\nSynonyme für die abgeleitete Klasse sind unter anderem: Unterklasse (Sub Class) oder Subklasse, abgeleitete Klasse (Derived Class), erweiterte Klasse (Extended Class) oder Kind-Klasse (Child Class).\nSynonyme für die Klasse, von welcher abgeleitet wird: Oberklasse (Super Class) oder Superklasse, Basisklasse (Base Class) oder Eltern-Klasse (Parent Class).\nDer Anwendungsfall der Vererbung kommt also dort zum Tragen, wo es eine IS-A Beziehung zwischen zwei Objekten gibt. Dazu ein paar Beispiele:\n Ein Quadrat ist eine geometrische Form Java ist eine Programmiersprache Ein Schwert ist eine Klingenwaffe Eine Klingenwaffe ist eine Waffe     Superklasse Subklasse     Geometrische Form Quadrat   Programmiersprache Java   Klingenwaffe Schwert   Waffe Klingenwaffe    Es gibt einige wichtige Punkte zur Vererbung in Java:\n In Java gibt es keine Mehrfachvererbung. Eine Klasse kann immer nur von maximal einer anderen Klasse erben Eine Klassenhierarchie kann beliebig viele Ebenen haben  Die Klasse Schwert erbt von der Klasse Klingenwaffe und die Klasse Klingenwaffe erbt von der Klasse Waffe   Eine Superklasse kann beliebig viele Subklassen haben  Im UML-Diagramm sind die Basisklassen oberhalb der abgeleiteten Klassen abgebildet. Die Klassen werden mit Pfeilen verbunden, wobei die Pfeilrichtung von der abgeleiteten Klasse in Richtung der Basisklasse verläuft. Der Vererbungspfeil hat eine durchgezogene Linie und ein geschlossenes Dreieck als Pfeilspitze.\nEine Subklasse kann beliebig viele neue Felder und Methoden enthalten. Geerbte und neu hinzugefügte Felder und Methoden werden wie bisher gelernt verwendet.\nDas Schlüsselwort extends In Java wird eine Vererbungsbeziehung implementiert, indem wir das Schlüsselwort extends verwenden.\n1 2 3  public class Fahrzeug { }   1 2 3  public class Auto extends Fahrzeug { }   Bei der Deklaration eines Autos ist es nun aufgrund der Vererbungsbeziehung möglich, dass wir statt eines Autos ein Fahrzeug verwenden. Dies funktioniert, weil ein Auto ja ein Fahrzeug ist (IS-A).\n1 2 3 4 5  public class Main { public static void main(String[] args) { Fahrzeug fahrzeug = new Auto(); } }   Das Schlüsselwort final Wenn eine Klasse mit dem Schlüsselwort final versehen wird, dann kann sie keine Subklassen haben. Wir können die Vererbung also verbieten.\n1 2 3  public final class NonDerivableClass { }   Viele der Standardklassen von Java sind final. Dazu gehören alle Wrapper-Klassen von primitiven Datentypen wie Integer, Long oder Float und die Klasse String.\nDas Schlüsselwort super Das Schlüsselwort super ähnelt dem Schlüsselwort this. Es erlaubt den direkten Zugriff auf Felder, Konstruktoren und Methoden der Superklasse. Bei gleicher Namensgebung von Feldern oder beim Überschreiben von Methoden ist es teilweise sogar zwingend notwendig.\nUmgang mit Konstruktoren Konstruktoren werden nicht an die Subklasse vererbt. Wenn aber ein neues Objekt einer Subklasse erzeugt werden soll, so kann der Konstruktor der Superklasse nicht einfach ignoriert werden. Beim Erzeugen von Objekten einer Subklasse unterscheiden wir zwischen den folgenden Fällen:\n Die Superklasse hat keinen Konstruktor (das heisst, sie besitzt einen Default-Konstruktor) Die Superklasse hat einen anderen Konstruktor als den Default-Konstruktor Die Superklasse hat einen anderen Konstruktor und zusätzlich einen Default-Konstruktor  Beispiel 1 - Die Superklasse hat keinen Konstruktor\n1 2 3  public class Fahrzeug { }   1 2 3  public class Auto extends Fahrzeug { }   1 2 3 4 5  public class Main { public static void main(String[] args) { Fahrzeug auto = new Auto(); } }   Beispiel 2 - Die Superklasse hat einen anderen Konstruktor als den Default-Konstruktor\n1 2 3 4 5 6 7  public class Fahrzeug { private String marke; public Fahrzeug(String marke) { this.marke = marke; } }   1 2 3 4 5 6 7 8 9 10 11  public class Auto extends Fahrzeug { // Möglichkeit 1 - Konstruktor-Weiterleitung  public Auto(String marke) { super(marke); } // Möglichkeit 2 - Fixer Wert  public Auto() { super(\"Unbekannt\"); } }   1 2 3 4 5 6 7 8  public class Main { public static void main(String[] args) { // Möglichkeit 1  Fahrzeug ferrari = new Auto(\"Ferrari\"); // Möglichkeit 2  Fahrzeug any = new Auto(); } }   Für die Erzegung eines Fahrzeugs ist nun eine Marke notwendig. Dies bedeutet automatisch, dass die Erzeugung eines Autos auch einen Wert für diese Marke besitzen muss. Der Wert kann entweder über einen weiteren Konstruktor in der Klasse Auto in das Fahrzeug gelangen oder man wählt wie im Beispiel gezeigt einen fixen Wert. Die Erzeugung eines neuen Autos ohne einen Wert für die Marke ist aber nicht möglich, da die Superklasse einen Wert verlangt.\nBeispiel 3 - Die Superklasse hat einen anderen Konstruktor und zusätzlich einen Default-Konstruktor\n1 2 3 4 5 6 7 8 9 10 11  public class Fahrzeug { private String marke; public Fahrzeug() { this.marke = \"Unbekannt\"; } public Fahrzeug(String marke) { this.marke = marke; } }   1 2 3 4 5 6 7 8 9  public class Auto extends Fahrzeug { public Auto() { super(); } public Auto(String marke) { super(marke); } }   1 2 3 4 5 6  public class Main { public static void main(String[] args) { Fahrzeug ferrari = new Auto(\"Ferrari\"); Fahrzeug any = new Auto(); } }   Hier gelten die gleichen Regeln wie beim Beispiel 2. Der einzige Unterschied besteht nun darin, dass die Klasse Auto ebenfalls beide Konstruktoren besitzen muss.\nDer geübte Entwickler behält also stets die Konstruktoren der Superklasse im Auge. Sie werden immer vor den Konstruktoren der Subklasse aufgerufen. Dies ist auch der Grund, weshalb der Aufruf des Super-Konstruktors immer als erstes Statement in einem Subklassen-Konstruktor aufgeführt werden muss.\nBeziehungen In Java gibt es vier Grundtypen von Beziehungen, welche Objekte miteinander bilden können. Diese sind:\n Generalisierung und Spezialisierung (IS-A Beziehung) Aggregation und Komposition (HAS-A Beziehung) Assoziationen (KNOWS-A Beziehung) Abhängigkeit (USES Beziehung)  Generalisierung und Spezialisierung (IS-A Beziehung) Die IS-A Beziehung beschreibt, wovon sich ein Objekt ableitet. Dies gilt für Basisklassen, abstrakte Klassen und Interfaces. Je genereller eine Funktion oder Beschreibung ist, desto höher stets sie in der Klassenhierarchie. Weiter unten in der Hierarchie sind also die spezialisierten Dinge anzutreffen.\nDarstellung der Generalisierung mit UML: Bei der Implementation eines Interfaces mit UML wird die folgende Darstellung verwendet: Aggregation und Komposition (HAS-A Beziehung) Die HAS-A Beziehung beschreibt, woraus sich ein Objekt zusammensetzt. Ein Objekt kann selbstverständlich beliebig viele andere Objekte aufnehmen. Die aufgenommenen Objekte sind dabei Bestandteile des Hauptobjekts.\nEin einfaches Beispiel wäre, dass ein Auto (normalerweise) einen Motor hat.\n1 2 3  public class Motor { }   1 2 3  public class Auto { private Motor motor; }   Die Umsetzung beider Beziehungen wird durch Instanzvariablen abgebildet, welche die entsprechenden Objekte aufnehmen. Ist bei einer Aggregation das verbundene Objekt nicht vorhanden, so wird der Instanzvariable der Wert null zugewiesen. Wenn die Beziehung zwischen den Objekten mehrfach (1 zu n) vorhanden ist, so kann dafür ein Array oder auch eine Liste verwendet werden.\nBei dieser Beziehung wird zwischen Aggregation und Komposition unterschieden.\nAggregation Die Aggregation ist\n stärker als eine Assoziation (siehe weiter unten), aber schwächer als eine Komposition eine Beziehung der Art “besitzt ein/e” in ihrer Lebensdauer nicht an die Lebensdauer des Ganzen gebunden  Beispiel 1: “Eine Taskforce hat Experten und -innen”. Das bedeutet, dass es die Experten und -innen immer noch gibt wenn die Taskforce aufgelöst wird. Beispiel 2: “Ein Auto hat einen Fahrer oder eine Fahrerin”. Die Existenz des Autos ist nicht an die Existenz des Fahrers / der Fahrerin gebunden.\nDarstellung der Aggregation mit UML: Komposition Die Komposition ist\n eine sehr starke Beziehung eine Beziehung der Art “ist ein Teil von” / “besteht aus” in ihrer Lebensdauer an die Lebensdauer des Ganzen gebunden  Beispiel 1: “Eine Labyrinth hat Wände”. Eine Labyrinth ohne Wände ist kein Labyrinth mehr. Beispiel 2: “Ein Mensch hat ein Herz”. Ein Mensch kann ohne Herz nicht existieren.\nDarstellung der Komposition in UML: Assoziation (KNOWS-A Beziehung) Wir haben bereits zwei Formen von Assoziationen kennengelernt: Aggregation \u0026 Komposition. Wenn von einer Assoziation die Rede ist, so sind damit Objekte gemeint, welche miteinander auf irgendeine Weise in Beziehung stehen. Die Komposition ist die stärkste Form der Assoziation, die Aggregation ist etwas abgeschwächt und die Assoziation selbst ist die schwächste Beziehung. Der Begriff Assoziation ist hier etwas verwirrend, weil er gleichzeitig als Oberbegriff und als Verbindung benutzt wird.\nEine Assoziation ist\n eine Beziehung der Art “benutzt ein/e”, “ist zugeordnet zu”, “hat eine Beziehung zu” auch unter der Bezeichnung KNOWS-A bekannt  Beispiel: “Eine Musikerin spielt ein Instrument”. Sie “kennt” das Instrument, das sie spielt.\nDarstellung der Assoziation in UML: Abhängigkeit (USES Beziehung) Eine Abhängigkeit ist\n eine gerichtete Beziehung zwischen einem abhängigen (Client) und einem unabhängigen Element (Supplier) eine Beziehung, wo die eine Klasse die andere zum Funktionieren braucht schwächer als eine Assoziation möglich, ohne ein Objekt der Abhängigkeit dauerhaft zu speichern  Die abhängige Klasse hat keine Instanzvariable vom Typ der unabhängigen Klasse. Es werden nur Parameter vom Typ der unabhängigen Klasse verwendet. Es ist auch möglich, eine Abhängigkeit ohne Objekte zu erstellen, zum Beispiel mit statischen Methoden.\nDarstellung der Abhängigkeit in UML: Polymorphismus Polymorphie bedeutet “Vielgestaltigkeit”. Die Polymorphie beschreibt ein Konzept der objektorientierten Programmierung, wobei der Aufruf einer Methode mit identischer Signatur unterschiedliche Ergebnisse liefern kann. Dieses Verhalten ist vorallem bei der Vererbung anzutreffen. In Java sind alle Objekte polymorph, da jedes Objekt eine IS-A Beziehung für seinen eigenen Typ und für die Klasse Object besitzt (Everything is an Object).\nEine Referenzvariable kann auf jedes Objekt ihres deklarierten Typs oder auf jeden Subtyp ihres deklarierten Typs verweisen.\nBeispiel:\n1 2 3 4 5  class Animal { public void move() { System.out.println(\"Animals can move\"); } }   1 2 3 4 5  class Dog extends Animal { public void move() { System.out.println(\"Dogs can walk and run\"); } }   1 2 3 4 5 6 7 8 9  public class Main { public static void main(String args[]) { Animal animal = new Animal(); Animal dog = new Dog(); animal.move(); dog.move(); } }   Die Ausgabe ist wie folgt: Animals can move Dogs can walk and run\nIm diesem Beispiel ist erkennbar, dass die Referenz dog (obwohl es sich um ein Animal handelt), die Methode move() der Klasse Dog ausführt. Der Grund dafür ist, dass während der Kompilierung der Referenztyp überprüft wird. Zur Laufzeit ermittelt die JVM jedoch das Objekt und führt die Methode aus, die zu der Klasse dieses Objekts gehört.\nOverriding Beim Überschreiben von Methoden wird eine Methode der Superklasse in einer Subklasse neu definiert. Eine Subklasse kann dadurch das Verhalten einer Methode der Superklasse anders spezifizieren. Das Überschreiben hat den Vorteil, dass ein Verhalten definiert werden kann, das für den Typ der Subklasse spezifisch ist. Die überschreibende Methode muss dieselbe Signatur (Methodenname; Anzahl, Typ und Reihenfolge der Parameter) aufweisen. Die zu überschreibende Methode darf nicht final sein.\nBeispiel: 1 2 3 4 5  public class Shape { public double getArea() { return 0; } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14  public class Rectangle extends Shape { private double width; private double height; public Rectangle(double width, double height) { this.width = width; this.height = height; } @Override public double getArea() { return width * height; } }   1 2 3 4 5 6 7 8 9 10 11 12  public class Circle extends Shape { private double radius; public Circle(double radius) { this.radius = radius; } @Override public double getArea() { return Math.pow(this.radius, 2.0) * Math.PI; } }   1 2 3 4 5 6 7 8 9  public class Main { public static void main(String[] args) { Shape rectangle = new Rectangle(10.0, 5.0); Shape circle = new Circle(4.0); System.out.println(\"Area of the rectangle: \" + rectangle.getArea()); System.out.println(\"Area of the circle \" + circle.getArea()); } }   Die Ausgaben sind nicht verwunderlich. Da es sich um Objekte des Typs Rectangle und Circle handelt, werden jeweils die überschriebenen Methoden aufgerufen. Wenn eine Subklasse ein bestimmte Methode nicht überschreibt, so wird die Methode der nächsthöheren Klasse (in diesem Falle der Klasse Shape) verwendet.\n@Override Die Annotation @Override weist den Compiler an die Signatur der überschreibenden Methode zu überprüfen. Die Annotation ist optional, hilft aber in einfacher Weise Fehler beim Überschreiben zu verhindern. Wenn eine mit @Override gekennzeichnete Methode die Methode der Superklasse nicht korrekt überschreibt, generiert der Compiler einen Fehler.\nAbstraktion In der objektorientierten Programmierung bezieht sich Abstraktion darauf, dem Benutzer Funktionalität bereitzustellen. Die Details der Implementierung werden dabei nicht bereitgestellt. Es ist also bekannt, was ein Objekt tun kann und nicht wie die Funktion umgesetzt ist. In Java wird Abstraktion mit Hilfe von abstrakten Klassen und Schnittstellen (Interfaces) erreicht.\nAbstrakte Klassen Eine Klasse, die das Schlüsselwort abstract in ihrer Deklaration enthält, wird als abstrakte Klasse bezeichnet.\n Abstrakte Klassen können beliebig viele abstrakte Methoden enthalten Eine abstrakte Methode besitzt keinen Block, sie muss in jedem Fall durch eine nicht-abstrakte Methode einer Klasse in der darunterliegenden Hierarchie überschrieben werden Eine abstrakte Klasse kann nicht instanziert werden, es ist also nicht möglich von einer solchen Klasse ein Objekt zu erstellen Abstrakte Klassen eignen sich, um gemeinsame Funktionalitäten von Subklassen aufzunehmen  Beispiel:\n Eine abstrakte Klasse Animal Eine abstrakte Subklasse Carnivore (Fleischfresser) Eine abstrakte Subklasse Herbivore (Pflanzenfresser) Eine Subklasse Dog Eine Subklasse Cat Eine Subklasse Sheep Eine Subklasse Cow  Alle diese Tiere sollen sich bewegen und unterschiedliche Geräusche machen können. Die Methoden move() und sound() bewerkstelligen dies.\n1 2 3 4 5 6 7  public abstract class Animal { public void move() { System.out.println(\"Animal is moving\"); } public abstract void sound(); }   1 2 3  public abstract class Carnivore extends Animal { // some carnivore specific stuff }   1 2 3  public abstract class Herbivore extends Animal { // some herbivore specific stuff }   1 2 3 4 5 6  public class Dog extends Carnivore { @Override public void sound() { System.out.println(\"Woff Woff...\"); } }   1 2 3 4 5 6  public class Cat extends Carnivore { @Override public void sound() { System.out.println(\"Meow Meow...\"); } }   1 2 3 4 5 6  public class Sheep extends Herbivore { @Override public void sound() { System.out.println(\"Baa Baa...\"); } }   1 2 3 4 5 6  public class Cow extends Herbivore { @Override public void sound() { System.out.println(\"Moo Moo...\"); } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  public class Main { public static void main(String args[]) { Animal dog = new Dog(); Animal cat = new Cat(); Animal sheep = new Sheep(); Animal cow = new Cow(); dog.sound(); dog.move(); cat.sound(); cat.move(); sheep.sound(); sheep.move(); cow.sound(); cow.move(); } }   Zusammenfassung:\n Alle Tiere können sich bewegen. Als ein gemeinsames Merkmal ist dies in der Klasse Animal implementiert Fleischfresser und Pflanzenfresser könnten in den jeweiligen Klassen spezifische Implementationen bereitstellen Alle Tiere machen unterschiedliche Geräusche und aus diesem Grund wird die Methode sound() in der Klasse Animal als abstract deklariert, so dass alle untergeordneten Klassen diese Methode auf ihre eigene Weise implementieren müssen  Eine weitere wichtige Lektion ist die Polymorphie in der Klassenhierarchie. Eine Katze ist gemäss Definition ein Fleischfresser. Das folgende Beispiel soll die mögliche Typenumwandlung erklären.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  public class Main { public static void main(String args[]) { Cat cat = new Cat(); Carnivore carnivoreCat = cat; // Möglich, da eine Katze ein Fleischfresser ist  Animal animalCat1 = cat; // Möglich, da eine Katze ein Tier ist  Animal animalCat2 = carnivoreCat; // Möglich, da ein Fleischfresser ein Tier ist  Animal animalDog = new Dog(); Carnivore carnivoreDog1 = animalDog; // Nicht möglich, da ein Tier kein Fleischfresser ist  Carnivore carnivoreDog2 = (Carnivore)animalDog; // Mit Cast-Operator möglich  Dog dog1 = animalDog; // Nicht möglich, da ein Tier kein Hund ist  Dog dog2 = (Dog)animalDog; // Mit Cast-Operator möglich  Dog dog3 = carnivoreDog2; // Nicht möglich, da ein Fleischfresser kein Hund ist  Dog dog4 = (Dog)carnivoreDog2; // Mit Cast-Operator möglich  } }   Wie wir sehen ist die Umwandlung in einen Typ, welche höher in der Klassenhierarchie liegt stets ohne Cast-Operator möglich. Bei der Umwandlung in einen unterliegenden Typ (Downcasting) muss der Cast-Operator zwingend implementiert werden. Zur Laufzeit kann es beim Downcasting jedoch zu einer ClassCastException kommen, wenn die Referenz kein Objekt des gecasteten Typs ist.\ninstanceOf Operator Durch den Einsatz des Operators instanceOf kann zur Laufzeit die Referenz eines Objektes auf einen bestimmten Typ überprüft werden.\nBeispiel:\n1 2 3 4 5 6 7 8  public class Main { public static void main(String args[]) { Animal dog = new Dog(); if (dog instanceOf Dog) { // ...  } } }   Der Operator überprüft also den Typ einer Instanz und berücksichtigt dabei Subklassen und Interfaces.\nInterfaces Ein Interface dient dem Angebot von Methoden, die durch Klassen zu implementieren sind, welche das Interface “implementieren”. Damit definiert ein Interface einen Satz von bestimmten Funktionen, die allen implementierenden Klassen des Interfaces gleich sind. Ein Interface muss dabei nicht zwingend eine Methode enthalten. Eine Schnittstelle hat im Unterschied zu einer Klasse weder ein Verhalten noch einen Status – wir können ein Interface als einen Vertrag betrachtet, den eine Klasse erfüllen muss. Ein Interface besitzt anstelle der Klassendefinition das Schlüsselwort interface.\nEin Interface kann die folgenden Dinge enthalten:\n Konstanten, also public static final Variablen, wobei die Schlüsselwörter nicht erforderlich sind public abstract Methoden, wobei die Schlüsselwörte nicht erforderlich sind Normale Methoden mit Implementierung (das Schlüsselwort default ist erforderlich) seit Java 8 Statische Methoden mit Implementierung (das Schlüsselwort static ist erforderlich) seit Java 8  Ein Interface darf die folgenden Dinge nicht enthalten:\n Instanzvariablen Konstruktoren Nicht-öffentliche abstrakte Methoden  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  public interface Vehicle { double MILES_PER_KM = 1.60934; String getBrand(); String speedUp(); String slowDown(); static double parseToKmh(double mph) { return mph * MILES_PER_KM; } static double parseToMph(double kmh) { return kmh / MILES_PER_KM; } default String turnAlarmOn() { return \"Turning the vehicle alarm on.\"; } default String turnAlarmOff() { return \"Turning the vehicle alarm off.\"; } }   Eine Klasse verwendet in ihrer Deklaration das Schlüsselwort implements, um eine Schnittstelle zu implementieren. Ein Interface verwendet jedoch das Schlüsselwort extends, um eine andere Schnittstelle zu erweitern.\nBeispiel:\n Eine Basisklasse mit dem Namen Bird Eine Subklasse mit dem Namen Parrot Eine Subklasse mit dem Namen Penguin Ein Interface mit dem Namen CanFly  1 2 3 4 5  public class Bird { public void eat() { System.out.println(getClass().getSimpleName() + \" is eating!\"); } }   1 2 3  public interface Flyable { void fly(); }   1 2 3 4 5 6  public class Parrot extends Bird implements Flyable { @Override public void fly() { System.out.println(\"Parrot is Flying!\"); } }   1 2 3  public class Penguin extends Bird { }   Wie wir sehen ist die Klasse Parrot gezwungen den Vertrag mit dem Interface Flyable zu erfüllen. Der Vorteil dieser Implementation wird erst ersichtlich wenn das Interface beispielsweise als Parameter verwendet wird. Nur Instanzen von Klassen, welche das Interface implementieren können als Parameter verwendet werden.\n1 2 3 4 5  public class Birdhouse { public void arrive(Flyable flyable) { flyable.fly(); } }   1 2 3 4 5 6 7  public class Main { public static void main(String[] args) { Flyable parrot = new Parrot(); Birdhouse birdhouse = new Birdhouse(); birdhouse.arrive(parrot); } }   Im Beispiel sehen wir, dass durch die Verwendung eines Interfaces die Abhängigkeiten zwischen den Klassen Birdhouse und Parrot vollständig aufgehoben wird. Beide Klassen kennen einander nicht, dies wird Entkopplung genannt. Dem Vogelhaus ist es also egal welcher Vogel ankommt, er muss aber fliegen können.\nKapselung Kapselung ist eines der bedeutendsten Konzepte der objektorientierten Programmierung, welches Sicherheit bietet, indem es die sensiblen Daten/Implementierungsdetails einer Klasse vor den Benutzern verbirgt.\nIn Java kann die Kapselung erreicht werden, indem die Klassenattribute/-variablen als Privat deklariert werden. Die Klasse stellt dann öffentliche Methoden zur Verfügung, welche von “aussen” (durch andere Klassen) verwendet werden können, um bestimmte Information zu erhalten oder um bestimmten Operationen, welche auf den Attributen der Klasse basiert sind, ausführen zu können.\nBeispiel\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  public class Student { private final String name; private final String lastName; private final int age; private int index = 0; private final String[] courses = {}; public Student(String name, String lastName, int age) { this.name = name; this.lastName = lastName; this.age = age; } public void enroleCourse(String course) { courses[index++] = course; } @Override public void toString() { System.out.printf(\"Name: %s\\nLastname: %s\\nAge: %d\\n\", name, lastName, age); System.out.println(\"Courses:\"); Arrays.stream(courses).forEach(System.out::println); } }   Die Student Klasse beinhaltet vier private Attribute, worauf der Benutzer dieser Klasse keinen Zugriff hat. Die Klasse stellt neben dem Konstruktor, lediglich zwei öffentliche Methoden zur Verfügung. Die interne Struktur der Student Klasse bleibt vom Benutzer verborgen. So weiss der Benutzer z.B. nicht, dass die Liste der Courses mit einem Array umgesetzt worden war. Dies erlaubt eine Strukturänderung innerhalb der Student Klasse ohne, dass der Benutzer etwas davon merkt oder seinen Code ändern muss (die öffentlichen Methoden ändern sich nicht):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  public class Student { private final String name; private final String lastName; private final int age; private final List\u003cString\u003e courses; // use List instead of Array  public Student(String name, String lastName, int age) { this.name = name; this.lastName = lastName; this.age = age; } public void enroleCourse(String course) { courses.add(course); } @Override public void toString() { System.out.printf(\"Name: %s\\nLastname: %s\\nAge: %d\\n\", name, lastName, age); System.out.println(\"Courses:\"); courses.forEach(System.out::println); } }   Die Student Klasse erlaubt zusätzlich keinen direkten Zugriff auf ihre Attributen (es gibt keine Getter-Methoden). Die Überlegung hier ist, dass die einzelnen Attribute niemanden ausserhalb der Student Klasse interessieren. Von Aussen will man lediglich dem Student ein Kurs zuweisen können und alle Informationen zum Studenten ausgeben.\nDas Befolgen des Kapselung-Prinzips führt zu einem Design, welches folgende Vorteile mit sich bringt:\n Die Attribute und damit der Zustand einer Klasse bzw. eines Objektes sind vor “fremden” Zugriff geschützt (Data-Hiding) Die Klasse hat eine öffentliche API, welche von Benutzer der Klasse verwendet werden können. Somit ist auch klar definiert, was die Aufgabe dieser Klasse ist. Die öffentliche API einer Klasse ermöglicht das Verbergen von Umsetzungsdetails. Somit haben interne Strukturänderungen dieser Klasse keinen Einfluss auf den Code des Benutzers  ","categories":"","description":"Modul #J3\n","excerpt":"Modul #J3\n","ref":"/docs/java/java-ood/","tags":"","title":"Objektorientiertes Design"},{"body":"Ziele  Du weisst, wann du in JavaScript das Keyword import brauchen kannst. Du weisst, wie du exports importieren kannst. Du weisst, welche Variablen, Klassen, Methoden usw. in einer Datei “public” sind. Du kennst die Unterschiede zwischen default und named Exports/Imports.  Basics Was ist der Einfluss, wenn ein Browser eine JavaScript-Datei mit folgendem Inhalt ladet?\n1  var x = \"Gugus\";   Diese Datei bewirkt, dass in allen anderen Dateien evlt. auch diese omniöse Variable x verfügbar ist (natürlich abhängig davon, was zuerst geladen wird).\nDas kann in sehr vielen Hinsichten schlecht sein:\n Was, wenn in mehreren Dateien eine Variable x deklariert wird? Was, wenn wir diese Variable eigentlich gar nicht veröffentlichen wollten? Diese Variable ist möglicherweise in den Entwicklungstools ([F12]-Taste) in der Konsole direkt ohne Aufwand ersichtlich, ausles- und manipulierbar. Was, wenn du eine gleichnamige Variable aus einer anderen Datei benötigst?  Um viele solche Probleme aus dem Weg zu gehen, wurde in ES6 (ECMAScript 2015, JavaScript Standard) JavaScript Modules eingeführt.\nHast du in einer JavaScript-Datei Variablen, Funktionen oder Klassen, die du in einer anderen Datei brauchen willst, dann kannst du das wie folgt tun:\n1 2 3 4 5 6 7  export const a = \"A\"; export const b = \"B\"; export class Person { name; constructor(name) { this.name = name;} }   Nun kannst du diese Variablen in einer anderen JavaScript-Datei wie folgt importieren:\n1  import { a, b, Person } from \"./path/to/your/file.js\";   Imports in HTML-Dateien Vielleicht kommst du mal aus irgendeinem Grund in die Situation, in welcher du im Browser ohne JS-Framework wie React oder Angular ein JavaScript-Modul laden musst. Das kannst du das im HTML wie folgt ganz einfach machen:\n1 2 3 4 5 6  \u003cscript type=\"module\"\u003e import {a, b, Person } from \"./file.js\"; console.log(a, b, new Person('Monkey Puppet')); \u003c/script\u003e   Beachte, dass die type-Angabe im \u003cscript\u003e-Tag zwingend ist und dass die Imports nur innerhalb dieses \u003cscript\u003e-Tags verfügbar sind.\nMöchtest du ohne die Angabe von type=\"module\" Variablen importieren (z.B. in den Browser-DevTools), dann kannst du das import-Keyword nicht wie gewöhnlich benutzen. Importieren kannst du auf folgende Art und Weise:\n1  const {a, b, Person } = await import('./file.js');   Hier hast du import(...) wie eine Funktion verwendet. Weil diese “Funktion” ein Promise zurückgibt (da sie das Modul asynchron lädt), sollte hier der Import awaited werden. So kann sichergestellt werden, dass der später folgende Code erst aufgerufen wird, nachdem das Modul komplett geladen wurde. Falls du dich nicht mit async und await auskennst, solltes du den Abschnitt “Asynchrone Anfragen” noch einmal anschauen.\ndefault Ex- und Importe Das ES6-Modul-System unterscheidet zwischen default und “named” Exporten:\n Eine Datei kann mehrere named-Exporte haben. Alle Exporte bis hier auf der Seite sind named Exporte. Eine Datei kann aber nur einen default Export besitzen. Wenn eine Datei z.B. nur etwas exportieren soll, dann eignet sich ein default-Export hierfür.  Angenommen, wir haben z.B. eine Datei “person.js”, die eine Klasse und ein paar Utility-Funktionen zu dieser Klasse anbietet, dann könnten die Exporte wie folgt aussehen:\n1 2 3 4 5 6 7 8 9 10 11  export default class Person { name; constructor(name) { this.name = name;} } export function personFromJson(jsonString){ const obj = JSON.parse(jsonString); return new Person(obj.name); } export function getNameOfPerson(person){ return person.name; };   Dies wiederum könnte z.B. wie folgt importiert werden:\n1 2 3 4 5 6 7 8  import ClassForPerson, { personFromJson, getNameOfPerson } from \"./person.js\"; const person = personFromJson('{\"name\": \"Mr. Incredible\"}'); console.log(getNameOfPerson(person)); \u003e\u003e\u003e Mr. Incredible console.log(person instanceof ClassForPerson); \u003e\u003e\u003e true   Wie du hier sehen kannst, können wir den default-Export mit irgendeinem Namen importieren, der nicht mit dem Namen in der Export-Datei übereinstimmen muss.\n","categories":"","description":"Seit ES2015 (ES6) gibt es in JavaScript die Möglichkeit, Exporte aus anderen JavaScript-Dateien zu importieren.\n","excerpt":"Seit ES2015 (ES6) gibt es in JavaScript die Möglichkeit, Exporte aus …","ref":"/docs/web/javascript/08_imports/","tags":"","title":"ES6: Importe"},{"body":"Beherrschst du HTML? Wenn ja, dann gib deinem HTML ein Styling - mit CSS! Fahre hier fort.\nHast du nicht alles verstanden oder du fühlst dich noch nicht so sattelfest? Dann kannst du gerne HTML noch ein bisschen üben. Wir empfehlen den HTML-Teil aus dem folgenden Kurs:\n Intro to HTML and CSS - Udacity  ","categories":"","description":"Du hast nun viel über HTML gelernt.\n","excerpt":"Du hast nun viel über HTML gelernt.\n","ref":"/docs/web/html_css/08_html_finish/","tags":"","title":"HTML Rekapitulieren"},{"body":"Material in Angular Für Angular gibt es eine spezifische Version von Material Design.\nAuf der offiziellen Website von Angular Material sehen wir welche Components uns zur Verfügung gestellt werden.\nWenn wir zum Beispiel den “Slider” in unsere Applikation implementieren möchten, gibt es einige Schritte welche wir beachten müssen. Jeder Component wird auf der Website wie folgt beschrieben:\n Overview: Auf der Übersicht wird beschrieben, wie und wozu man den Component anwenden kann. Oftmals werden hier auch erweiterte Funktionen eines Components aufgelistet. Daher gilt: Immer aufmerksam durchlesen! API: In diesem Abschnitt ist für uns vor allem der Import wichtig. Für jeden Component muss erst das dazugehörige Modul importiert werden:  1 2 3 4 5 6 7 8 9 10  import { MatSliderModule } from '@angular/material/slider'; ... @NgModule({ imports: [ ..., MatSliderModule, ... ], ... })    Examples: Hier werden Anwendungsbeispiele aufgezeigt, von welchen wir unseren Code ableiten können.  1 2 3 4 5 6 7 8 9 10 11 12 13  \u003cmat-slider class=\"example-margin\" [disabled]=\"disabled\" [invert]=\"invert\" [max]=\"max\" [min]=\"min\" [step]=\"step\" [thumbLabel]=\"thumbLabel\" [tickInterval]=\"getSliderTickInterval()\" [(ngModel)]=\"value\" [vertical]=\"vertical\" aria-labelledby=\"example-name-label\"\u003e \u003c/mat-slider\u003e   Wie Ihr Material in Eurer Angular-Applikation installiert, wird auf der offiziellen Website ausführlich beschrieben.\nMaterial Theming Material Design unterstützt Theming. Ein Theme ist eine Farbpalette, welche für jeden Angular Material Component angewendet wird.\nEin Theme besteht aus:\n Primärfarbe Akzentfarbe Warnung Vordergrund Hintergrund  Es gibt verschiedene pre-built Themes in Material Design, sodass man sich das Erstellen eines Themes von Hand ersparen kann:\n deeppurple-amber.css indigo-pink.css pink-bluegrey.css purple-green.css  Um ein solches Theme zu verwenden, müssen wir dies in unserem globalen Stylesheet importieren:\n1  @import '@angular/material/prebuilt-themes/deeppurple-amber.css';   Natürlich kann man auch sein eigene Theme für Angular Material erstellen. Wie ihr dies machen könnt wird hier ausführlich beschrieben (Für diejenigen, die mit den Übungen frühzeitig fertig sind).\nAufgabe 5 Um die Fahrrad-Seite nun ein bisschen schöner darzustellen, brauchen wir nun Angular Material\n Folgende Material-Komponenten sollen die Seite verschönern (es ist dir überlassen, welches Material du welcher Komponente(n) zuordnest):  Card Sidenav Snackbar Toolbar Table Input Tabs    ","categories":"","description":"Material Design ist eine Designsprache, die für das neue Betriebssystem von Google Android entwickelt wurde, das im Sommer 2014 angekündigt wurde. Obwohl sich die Material Design hauptsächlich auf das Touch-Based-Design mobiler Apps konzentriert, ist es möglich, dieselben Ideen in das Webdesign zu übertragen.\n","excerpt":"Material Design ist eine Designsprache, die für das neue …","ref":"/docs/web/angular/04_7_angular_material/","tags":"","title":"Angular Material, Responsive Web Design und Accessibility"},{"body":"","categories":"","description":"Exercises zu Modul #J5 - Exception Handling\n","excerpt":"Exercises zu Modul #J5 - Exception Handling\n","ref":"/labs/java/java-exception-handling/","tags":"","title":"Java Exercises - Exception Handling"},{"body":"Ziele  Ich kenne die Grundlagen von Maven Ich kann Maven lokal konfigurieren Ich kann im Artifactory Abhängigkeiten suchen und diese verwenden Ich kenne die Grundlagen von Project Object Models (pom) Ich kenne die wichtigsten Maven Befehle und kann diese auf der Kommandozeile anwenden Ich kann die Abhängigkeiten meiner Applikationen mit Maven verwalten Ich kann Maven Plugins konfigurieren und damit meinen Maven-Build steuern Ich kann den Begriff Continuous Integration erklären Ich kenne die Komponenten der Deployment-Pipeline und deren Aufgaben  Maven Allgemeine Informationen Apache Maven ist ein Build-Management Tool. Von einer einzelnen Datei aus, kann Maven den Build eines Projektes steuern. Diese zentrale Datei ist das Project Object Model, kurz auch POM genannt. Der Build eines Projektes kann dabei von einfacher Kompilierung bis zur Auslieferung einer Anwendung auf eine bestimmte Plattform reichen.\nDamit Maven funktionieren kann, benötigt ein Projekt die folgenden Dinge:\n Eine Maven-Installation, entweder separat oder Built-In wie beispielsweise mit IntelliJ Eine POM-Datei pro Projekt oder Modul (es handelt sich um eine XML-Datei) Ein zentrales Maven-Repository Ein lokales Maven-Repository Eine Konfigurationsdatei mit dem Namen settings.xml   Installation Die Installation von Apache Maven wurde idealerweise bereits durchgeführt. Falls nicht, kann Maven hier heruntergeladen werden: https://maven.apache.org/download.cgi, beim Herunterladen das Binary auswählen (nicht die Source).\n pom.xml Der Aufbau eines POM kann grob in folgende Abschnitte unterteilt werden, hier erklärt an einem umfangreichen Beispiel. Die einzelnen Teile werden gleich im Anschluss näher erläutert. Bitte beachte, dass dieses POM nicht alle Inhalte erklären kann, es dient nur als erstes Beispiel.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141  \u003c!-- (1) Header --\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003c!-- (2) Angaben zum Artefakt --\u003e \u003cgroupId\u003ech.sbb.interviewtool\u003c/groupId\u003e \u003cartifactId\u003einterviewtool-backend\u003c/artifactId\u003e \u003cversion\u003e0.0.1-SNAPSHOT\u003c/version\u003e \u003cpackaging\u003ejar\u003c/packaging\u003e \u003c!-- (3) Angaben zum Parent-Projekt --\u003e \u003cparent\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-parent\u003c/artifactId\u003e \u003cversion\u003e2.2.4.RELEASE\u003c/version\u003e \u003crelativePath/\u003e \u003c/parent\u003e \u003c!-- (4) Properties --\u003e \u003cproperties\u003e \u003cproject.build.sourceEncoding\u003eUTF-8\u003c/project.build.sourceEncoding\u003e \u003cjava.version\u003e1.8\u003c/java.version\u003e \u003cmaven.build.timestamp.format\u003eyyyy-MM-dd HH:mm\u003c/maven.build.timestamp.format\u003e \u003ctimestamp\u003e${maven.build.timestamp}\u003c/timestamp\u003e \u003c/properties\u003e \u003c!-- (5) Abhängigkeiten --\u003e \u003cdependencies\u003e \u003c!-- Spring Boot --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web-services\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-security\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-data-jpa\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!-- Spring --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-webmvc\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!-- Lombok --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003cversion\u003e1.18.6\u003c/version\u003e \u003c/dependency\u003e \u003c!-- Datenbank --\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e8.0.20\u003c/version\u003e \u003c/dependency\u003e \u003c!-- Unit- und Integrationstests --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.h2database\u003c/groupId\u003e \u003cartifactId\u003eh2\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter-engine\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c!-- (6) Build-Informationen --\u003e \u003cbuild\u003e \u003cplugins\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-maven-plugin\u003c/artifactId\u003e \u003c/plugin\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e \u003cartifactId\u003emaven-compiler-plugin\u003c/artifactId\u003e \u003cconfiguration\u003e \u003ccompilerVersion\u003e1.8\u003c/compilerVersion\u003e \u003csource\u003e1.8\u003c/source\u003e \u003ctarget\u003e1.8\u003c/target\u003e \u003c/configuration\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c/build\u003e \u003c!-- (7) Auslieferung --\u003e \u003cdistributionManagement\u003e \u003crepository\u003e \u003cid\u003emvn\u003c/id\u003e \u003curl\u003ehttps://bin.sbb.ch/artifactory/cca.mvn/\u003c/url\u003e \u003c/repository\u003e \u003csnapshotRepository\u003e \u003cid\u003emvn\u003c/id\u003e \u003curl\u003ehttps://bin.sbb.ch/artifactory/cca.mvn/\u003c/url\u003e \u003c/snapshotRepository\u003e \u003c/distributionManagement\u003e \u003c!-- (8) Entwickler-Informationen --\u003e \u003cdevelopers\u003e \u003cdeveloper\u003e \u003cid\u003eU000000\u003c/id\u003e \u003cname\u003eVorname Name\u003c/name\u003e \u003cemail\u003evorname.name@sbb.ch\u003c/email\u003e \u003corganization\u003eSBB\u003c/organization\u003e \u003corganizationUrl\u003ehttps://www.sbb.ch\u003c/organizationUrl\u003e \u003croles\u003e \u003crole\u003eSoftware Architect\u003c/role\u003e \u003crole\u003eLead Developer\u003c/role\u003e \u003c/roles\u003e \u003c/developer\u003e \u003c/developers\u003e \u003c/project\u003e   Abschnitt 1 Der Header einer POM-Datei bleibt grundsätzlich so wie dargestellt. Die Angaben zum Schema sind dabei optional. Falls andere Schemas verwendet werden, so sind diese hier zu deklarieren.\nAbschnitt 2 Die Angaben zum Artefakt enthalten die folgenden Informationen:\n Gruppen-ID: Normalerweise eine umgekehrte URL, also beispielsweise ch.sbb.interviewtool. Darin sollte der Projektname enthalten sein Artefakt-ID: Der Name des Projekts oder der Komponente Version: Die momentane Version des Projekts, diese wird später durch Releases verändert Paketierung: Angabe, in welcher Form das Artefakt geliefert wird. Der Default ist Java Archive (JAR)  Bei der Versionierung nutzt Maven die folgenden Standards:\n Major-Version Minor-Version Incremental-Version Build-Number Qualifier  Dazu ein paar Beispiele:\n   Typ Beispiel     Major-Version 1.2.1   Minor-Version 2.0   Incremental-Version 1.2-SNAPSHOT   Patch 1.2.1   Build-Number 1.4.2-12   Qualifier 1.2-beta-2    Alle Versionen mit Qualifier sind dabei älter als die gleiche Version ohne Qualifier. Beispielsweise ist die Version 1.2-beta-2 älter als die Version 1.2. Gleiche Versionen mit unterschiedlichen Qualifiern werden durch den Vergleich dieser als String verglichen. So ist die Version 1.2-beta-2 neuer als die Version 1.2-alpha-6.\nDer SNAPSHOT Qualifier wird verwendet, wenn eine Version noch nicht ausgeliefert wurde. So wird die Version 0.1.2-SNAPSHOT sehr wahrscheinlich als Version 0.1.2 ausgeliefert werden.\nAbschnitt 3 Falls das Projekt Bestandteil eines anderen Projektes ist, müssen hier die Artefakt-Angaben des sogenannten Parent-Projekts hinterlegt werden. Dies ist vorallem bei Spring-Boot Projekten wichtig.\nAbschnitt 4 Die Einstellungen in Maven sind beliebig wählbare Tags. So kann beispielsweise eine bestimmte Einstellung oder eine Version definiert werden.\nBeispiel:\n1  \u003cspecial.setting\u003eValue\u003c/special.setting\u003e   Innerhalb der POM-Datei kann dann mit\n1  ${special.setting}   auf die Einstellung (Tag) und damit auf deren Wert (Value) zugegriffen werden.\nAbschnitt 5 Abhängigkeiten zu Fremdbibliotheken. Diese sollten stets Gruppen-ID, Artefakt-ID und Version enthalten. Der Typ der Abhängigkeit gibt an, um welche Art von Bibliothek es sich handelt. Nicht alle Java-Bibliotheken werden als JAR ausgeliefert. Mögliche Typen sind hier zu finden: https://maven.apache.org/ref/3.6.3/maven-core/artifact-handlers.html Vielfach wird auch noch der Scope verwendet, er gibt an in welchem Umfang die Fremdbibliothek miteinbezogen wird. Mögliche Scopes sind:\n compile - Das ist der Default-Scope. Bibliotheken sind in allen Klassenpfaden verfügbar (Classpath) provided - Gleich wie compile, ausser das die Bibliothek zur Laufzeit von einem Container (wie dem JDK) erwartet und bereitgestellt wird runtime - Zeigt an, dass die Bibliothek zur Kompilierung nicht verwendet wird. Zur Laufzeit steht sie dann zur Verfügung test - Die Bibliothek steht nur für Tests zur Verfügung system - Gleich wie provided, mit der Ausnahme, dass die Bibliothek explizit auf dem System zur Verfügung stehen muss  Abschnitt 6 Die Build-Informationen konfigurieren den Ablauf des Maven-Builds. Mit Plugins kann der Build selbst durch spezifische Erweiterungen beliebig angepasst werden. Es ist auch möglich eigene Maven-Plugins zu entwickeln. Es stehen sehr viele Plugins für Maven zur Verfügung, eine Übersicht gibt es hier.\nAbschnitt 7 Die Auslieferungs-Sektion bestimmt, wo die Artefakte nach dem Build abgelegt werden sollen.\nAbschnitt 8 Die Entwickler-Informationen dienen dazu, an der Entwicklung beteiligte Personen zu identifizieren.\n settings.xml Die folgenden Angaben sind nur für SBB-Mitarbeiter von Relevanz.\nZur Konfiguration von Maven muss eine Einstellungsdatei angelegt werden. Diese Datei sollte immer settings.xml heissen und sich (auf einem SBB-Laptop) im Verzeichnis C:\\Users\\\u003cPersonalnummer\u003e\\.m2 befinden. Bitte beachten, dass das Verzeichnis mit einem Punkt im Namen beginnt.\nSie sollte folgenden Inhalt aufweisen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81  \u003csettings xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.1.0 http://maven.apache.org/xsd/settings-1.1.0.xsd\" xmlns=\"http://maven.apache.org/SETTINGS/1.1.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\u003e \u003cservers\u003e \u003cserver\u003e \u003cid\u003emvn\u003c/id\u003e \u003cconfiguration\u003e \u003chttpHeaders\u003e \u003cproperty\u003e \u003cname\u003eX-JFrog-Art-Api\u003c/name\u003e \u003cvalue\u003eREPOSITORY-KEY\u003c/value\u003e \u003c/property\u003e \u003c/httpHeaders\u003e \u003c/configuration\u003e \u003c/server\u003e \u003c/servers\u003e \u003cmirrors\u003e \u003cmirror\u003e \u003cmirrorOf\u003e*\u003c/mirrorOf\u003e \u003cname\u003emvn\u003c/name\u003e \u003curl\u003ehttps://bin.sbb.ch/artifactory/mvn\u003c/url\u003e \u003cid\u003emvn\u003c/id\u003e \u003c/mirror\u003e \u003c/mirrors\u003e \u003cproxies\u003e \u003cproxy\u003e \u003cid\u003ezscaler\u003c/id\u003e \u003cactive\u003etrue\u003c/active\u003e \u003cprotocol\u003ehttps\u003c/protocol\u003e \u003chost\u003ezscaler.sbb.ch\u003c/host\u003e \u003cport\u003e10465\u003c/port\u003e \u003cnonProxyHosts\u003erepo.sbb.ch|bin.sbb.ch\u003c/nonProxyHosts\u003e \u003c/proxy\u003e \u003c/proxies\u003e \u003cprofiles\u003e \u003cprofile\u003e \u003cid\u003eproperties\u003c/id\u003e \u003cproperties\u003e \u003ctycho.disableP2Mirrors\u003etrue\u003c/tycho.disableP2Mirrors\u003e \u003c/properties\u003e \u003c/profile\u003e \u003cprofile\u003e \u003cid\u003edefault\u003c/id\u003e \u003crepositories\u003e \u003crepository\u003e \u003cid\u003emvn\u003c/id\u003e \u003cname\u003ecentral.sbb.releases\u003c/name\u003e \u003curl\u003ehttps://bin.sbb.ch/artifactory/mvn\u003c/url\u003e \u003creleases\u003e \u003cenabled\u003etrue\u003c/enabled\u003e \u003cupdatePolicy\u003enever\u003c/updatePolicy\u003e \u003c/releases\u003e \u003csnapshots\u003e \u003cenabled\u003etrue\u003c/enabled\u003e \u003cupdatePolicy\u003ealways\u003c/updatePolicy\u003e \u003c/snapshots\u003e \u003c/repository\u003e \u003c/repositories\u003e \u003cpluginRepositories\u003e \u003cpluginRepository\u003e \u003cid\u003emvn\u003c/id\u003e \u003cname\u003ecentral.sbb.plugins\u003c/name\u003e \u003curl\u003ehttps://bin.sbb.ch/artifactory/mvn\u003c/url\u003e \u003clayout\u003edefault\u003c/layout\u003e \u003csnapshots\u003e \u003cenabled\u003etrue\u003c/enabled\u003e \u003cupdatePolicy\u003ealways\u003c/updatePolicy\u003e \u003c/snapshots\u003e \u003creleases\u003e \u003cenabled\u003etrue\u003c/enabled\u003e \u003cupdatePolicy\u003enever\u003c/updatePolicy\u003e \u003c/releases\u003e \u003c/pluginRepository\u003e \u003c/pluginRepositories\u003e \u003c/profile\u003e \u003c/profiles\u003e \u003cactiveProfiles\u003e \u003cactiveProfile\u003edefault\u003c/activeProfile\u003e \u003c/activeProfiles\u003e \u003c/settings\u003e   Auf Zeile 11 muss der persönliche Repository-Schlüssel (REPOSITORY-KEY) eingefügt werden. Um diesen Schlüssel zu generieren, müssen die folgenden Schritte ausgeführt werden:\n   # Beschreibung     1 Artifactory öffnen   2 Oben rechts auf “Log In” klicken   3 Anmelden   4 Oben rechts auf die eigene Personalnummer klicken   5 Das Menü “Edit Profile” auswählen   6 Passwort eingeben und auf “Unlock” klicken   7 Im Bereich der “Authentication Settings” einen neuen API Key generieren lassen und diesen gleich mit dem Kopieren-Button in die Zwischenablage kopieren.   8 Abmelden   9 Den API Key in die settings.xml Datei einfügen und die Datei speichern.    Der Verbindung zwischen Artifactory und einem Maven-Projekt im IntelliJ steht nun nichts mehr im Weg :-)\n IntelliJ IDEA einrichten Im IntelliJ findet man in den allgemeinen Einstellungen auch die Einstellungen für Maven. Die wichtigsten Einstellungen sind:\n   Einstellung Beschreibung     Maven home directory Zeigt auf das Verzeichnis einer Maven-Installation. Das IntelliJ verfügt bereits über eine Maven-Installation, diese wird als “Bundled” bezeichnet   User settings file Die XML-Datei, welche weiter oben angelegt wurde   Local repository Der Ablageort für das lokale Repository, dieser ist normalerweise unter C:\\Users\\\u003cPersonalnummer\u003e\\.m2.\\repository zu finden    Bei diesen Einstellungen muss überprüft werden, dass die Pfad-Angaben für die XML-Datei und das lokale Repository korrekt sind.\n Umgebungsvariable aufsetzen Damit Maven auch auf der Command-Line funktioniert, muss eine Umgebungsvariable gesetzt werden. Im Windows muss also der Pfad zur Built-In Version des IntelliJ hinterlegt werden. Die folgenden Schritte sind dazu notwendig:\n   # Beschreibung     1 Anwendung “Systemumgebungsvariablen bearbeiten” aus der Systemsteuerung starten   2 Unten rechts auf den Button “Umgebungsvariablen” klicken   3 Im unteren Teil “Systemvariablen” die Variable “Path” suchen und anklicken   4 Auf den Button “Bearbeiten…” klicken   5 Oben rechts auf den Button “Neu” klicken, es erscheint eine neue Zeile ganz unten   6 Den Pfad zum Built-In Maven einfügen. Dieser ist normalerweise “\u003cInstallationsort IntelliJ IDEA\u003e\\plugins\\maven\\lib\\maven3\\bin”   7 Alle offenen Windows-Fenster mit “OK” schliessen     Repository Lokal Zwischen dem JFrog Artifactory und deinem lokalen Repository gibt es also nun eine Verbindung. Sobald dein Projekt (in der Datei pom.xml) bestimmte Abhängigkeiten definiert, werden diese über das Artifactory aufgelöst und die entsprechenden Artefakte werden in dein lokales Repository heruntergeladen. Dies gilt für Abhängigkeiten und Plugins gleichermassen.\nBeispiel: Im pom.xml Datei wird die folgende Abhängigkeit zu der Fremdbibliothek von Lombok definiert.\n1 2 3 4 5 6  \u003c!-- Lombok --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003cversion\u003e1.18.12\u003c/version\u003e \u003c/dependency\u003e   Sobald die pom.xml Datei gespeichert wird, wird das angeforderte Artefakt durch die oben eingerichtete Verbindung im Artifactory gesucht.\nDieser Vorgang kann auch manuell gemacht werden. Dazu kann man sich im Artifactory einloggen. Auf der Seite können mit dem Suchfeld bestimmte Artefakte gesucht werden. Als Stichwort reicht ein Teil des Names des gesuchten Artefakts. Die angezeigten Resultate lassen sich durch einen Klick auf die Tabellen-Header sortieren. Ich habe die Sortierung nach Modifizierungsdatum gewählt Wie wir sehen gibt es die von uns gewünschte Lombok-Version 1.18.12 als verschiedene Artefakte: javadoc, sources, pom und jar. Wir können auch sehen, dass es bereits eine neuere Version gibt 1.18.14.\nDas angeforderte Artefakt wird nun in das lokale Repository heruntergeladen, wir müssten ihn dort also finden können. Die Artefakte sind nach Packages abgelegt. Beim Lombok-Artefakt fordern wir ja die Group-ID “org.projectlombok” an. Unter diesem Verzeichnis ist das Artefakt nun zu finden: Das Artefakt wird unterhalb der Group-ID noch in einem Ordner mit der Artifact-ID abgelegt. Innerhalb dieses Verzeichnisses werden alle bisher angeforderten Versionen von Lombok abgelegt.\nDie beiden Dateien mit der Endung “.lastUpdated” dienen Maven zur Kontrolle der letzten Synchronisierung zwischen dem lokalen und dem remote Repository.\nRemote (JFrog / Artifactory) Das Artifactory von JFrog ist das verwaltete Verzeichnis zur Speicherung und Beschreibung digitaler Objekte. Es ist also unser digitales Archiv bei der SBB. In diesem Archiv befinden sich Millionen von Fremdbibliotheken in unterschiedlichsten Versionen. Zudem werden alle Versionen von unseren ausgelieferten Bibliotheken, Artefakten, Komponenten und Applikationen dort archiviert.\n Commands Maven lässt sich auf der Kommandozeile oder im IntelliJ-Terminal ausführen. Damit wir sehen, ob das wirklich klappt könnt ihr das Terminal öffnen und den folgenden Befehl eingeben:\n1  mvn -version   Das sollte nun in etwa so aussehen:\nBevor wir die einzelnen Befehle kurz anschauen werfen wir einen Blick auf die einzelnen Phasen des Maven-Lebenszyklus.\nJeder der in der Grafik genannten Befehle wird zusätzlich die vorangehenden Befehle ausführen. Die Ausführung von “mvn package” wird also die Phasen validate, compile, test und package ausführen.\nhelp 1  mvn -help   Das Ergebnis dürfte klar sein. Maven listet alle möglichen Befehle auf.\ndependency:tree 1  mvn dependency:tree   Dieser Befehl listet alle Abhängigkeiten zu Fremdbibliotheken als Baum auf. Das ist grundsätzlich sehr praktisch wenn man doppelte Abhängigkeiten erkennen/vermeiden will.\nclean 1  mvn clean   Dieser Befehl löscht alle vorherigen lokale Maven-Build-Artefakte, indem er das Verzeichnis “target” löscht.\ncompile 1  mvn compile   Kompiliert den Sourcecode je nach Abhängigkeit von Plugins. Wenn also beispielsweise ein Maven-Compiler-Plugin verwendet wird, so wird dieses als Regelwerk für die Kompilierung herangezogen.\ntest 1  mvn test   Führt alle Tests aus. In einem Java-Projekt sind dies beispielsweise alle Unit-Tests mit jUnit.\npackage 1  mvn package   Führt einen lokalen Maven-Build aus, startet alle Tests und paketiert die Anwendung (normalerweise als JAR) in das Verzeichnis “target”.\nverify 1  mvn verify   Prüft die Testergebnisse aller ausgeführten Integrationstests, normalerweise wird das Maven-Failsafe-Plugin für diesen Maven-Befehl vorausgesetzt.\ninstall 1  mvn install   “Installiert” den Artefakt im lokalen Maven-Repository.\ndeploy 1  mvn deploy   “Installiert” den Artefakt im Remote-Repository (Artifactory).\nDie Maven-Befehle lassen sich kombinieren. Sehr nützlich ist zum Beispiel:\n1  mvn clean install   Selbstverständlich gibt es sehr viele zusätzliche Optionen für die einzelnen Maven-Befehle.\n Continuous Integration (CI) / Continuous Delivery (CD) Dieses Kapitel beschreibt CI/CD bei den SBB.\nHinweis: Für nicht-produktive Projekte darf niemals eine Build-Pipeline aufgesetzt werden!!!\nKontinuierliche Integration beschreibt den Prozess der fortlaufenden Zusammenfügung von Einzelkomponenten zu einer Anwendung. Das Ziel dabei ist stets die Steigerung der Qualität einer Software. Inhaltlich wird nicht nur die Software zusammengebaut, es können auch Tests durchgeführt oder Messungen der Code-Qualität vorgenommen werden. Der Auslöser ist stets das Hochladen (Push) von Änderungen am Programmcode in die Versionsverwaltung. Eine Weiterentwicklung der kontinuierlichen Integration stellt die kontinuierliche Auslieferung (Continuous Delivery) dar. Dort wird in bestimmten Zeitabständen, bei Erreichen einer bestimmten Qualität oder manuell eine neue Version der Software auf eine Zielplattform ausgeliefert.\n Grundsätze Die folgenden Grundsätze dienen als Basis für die gemeinsame Entwicklung innerhalb eines Projektes mit CI / CD.\n   Grundsatz Beschreibung     Versionsverwaltung Gemeinsame Codebasis für alle Projektbeteiligten   Statische Code-Analyse Einheitlich definierte Qualität der Applikation   Kontinuierliche Test-Entwicklung Änderungen an der Software sind durch entsprechende Unit-Tests abzudecken   Häufige Integration Code-Review durchführen und Änderungen möglichst rasch einchecken. Kleiner Stack an offenen Pull-Requests   Integration Develop Nahe am Develop-Branch entwickeln   Häufige Testzyklen Häufige Durchführung von vielen kleinen Tests, welche möglichst alle Test-Cases abdecken   Integrationsumgebung Alle Änderungen sollten auf einem der Produktion ähnlichen System getestet werden   Einfacher Zugriff Alle Projektbeteiligten, also auch Nicht-Entwickler, benötigen Zugriff auf die Ergebnisse der Software-Entwicklung   Automatisiertes Reporting Informationen zu Auslieferungen der Software müssen einfach und verständlich einsehbar sein   Automatisiertes Deployment Die Auslieferung der Software auf unterschiedliche Plattformen sollte so einfach wie möglich sein     Vorteile CI / CD  Probleme bei der Auslieferung können früh erkannt und behoben werden Test des Gesamtsystems als Verbund Logik-Fehler können durch Unit-Testing rasch gefunden und behoben werden Hohe Verfügbarkeit von Test- und Integrationsplattformen (auch für den Kunden) Schnelle Feedback-Zyklen verbessern die Qualität des Systems   Jenkins Die Software, welche von der SBB für CI/CD eingesetzt wird ist Jenkins. Die Anwendung ist hier erreichbar.\n Deployment-Pipeline Zum Gesamtsystem von CI/CD (bei der SBB) und damit der Deployment-Pipeline gehören die folgenden Systeme/Anwendungen:\n   System Zweck     GIT-Repository Source-Code Ablage   JFrog Artifactory Digitales Archiv   Jenkins CI/CD-Plattform   Docker Containervirtualisierung   Openshift Container Plattform Container Anwendungsplattform    Bei Änderungen am GIT-Repository wird durch den Jenkins ein Maven-Build ausgelöst. Dieser legt je nach Build-Konfiguration ein neues Artefakt im Artifactory ab (CI). Aus dem Artifactory kann dieses Artefakt über den Jenkins via Docker auf die Openshift Container Plattform ausgeliefert werden (CD).\nFür die Konfiguration einer solchen Deployment-Pipeline sind bei der SBB die folgenden Dateien notwendig:\n Jenkinsfile Pipeline-Konfiguration als JSON  Jenkinsfile Diese Datei wird durch den Jenkins in jedem GIT-Repository gesucht. Wenn Sie gefunden wird, dann wird der Jenkins anhand der Konfiguration im GIT-Repository handeln.\nDer minimale Inhalt ist wie folgt:\n1 2 3 4  #!groovy @Library(['pipeline-helper@release', 'esta-cloud-pipeline@release']) _ estaCloudPipeline([:])   Die erste Zeile markiert diese Datei als Groovy-Script. Die zweite Zeile lädt die zu verwendende Bibliothek, welche in diesem Fall der Release des Pipeline-Helpers ist. Der Source-Code des Pipeline-Helpers ist bei Interesse hier zu finden. Die letzte Zeile gibt den Namen der zu verwendenden Konfiguration an. Die Datei für die Konfiguration muss also den Namen estaCloudPipeline.json haben.\nPipeline-Konfiguration als JSON Die Pipeline-Konfiguration dient dem Jenkins zur Konfiguration der gesamten Pipeline inklusive deren auswählbaren Möglichkeiten für manuelle Optionen. Wir betrachten eine etwas umfangreichere Konfiguration am folgenden Beispiel:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84  { \"mainBranch\": \"master\", \"hotfixBranch\": \"hotfix\", \"docker\": { \"artifactoryDockerRepo\": \"cca\", \"openshiftAppName\": \"interviewtool-core\" }, \"mvn\": { \"parentPom\": \"pom.xml\", \"deployableArtifactsPom\": \"pom.xml\", \"artifactoryMavenRepo\": \"cca.mvn\" }, \"stages\": [ { \"stageName\": \"dev\", \"isOpenshiftDeploymentEnabled\": true, \"openshiftProject\": \"interviewtool-dev\", \"openshiftCluster\": \"aws\", \"openshiftJenkinsCredentialsId\": \"aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee\", \"preCiDeploymentJob\": \"\", \"postCiDeploymentJob\": \"\" }, { \"stageName\": \"int\", \"isOpenshiftDeploymentEnabled\": true, \"openshiftProject\": \"interviewtool-int\", \"openshiftCluster\": \"aws\", \"openshiftJenkinsCredentialsId\": \"aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee\", \"preCiDeploymentJob\": \"\", \"postCiDeploymentJob\": \"\" }, { \"stageName\": \"prod\", \"isOpenshiftDeploymentEnabled\": true, \"openshiftProject\": \"interviewtool-prod\", \"openshiftCluster\": \"aws\", \"openshiftJenkinsCredentialsId\": \"aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee\", \"preCiDeploymentJob\": \"\", \"postCiDeploymentJob\": \"\" } ], \"steps\": [ { \"stepType\": \"continuous\", \"isBuildEnabled\": true, \"branchNamePrefixes\": [ \"feature\", \"develop\", \"bugfix\" ], \"additionalBuildParams\": \"-DskipITs\" }, { \"stepType\": \"integrationBuild\", \"isBuildEnabled\": true, \"xrayScanEnabled\": true, \"failOnXrayScan\": false, \"sonarScanEnabled\": true, \"staging\": { \"stages\": [ \"dev\" ] }, \"triggerBuildOnCommitEnabled\": false }, { \"stepType\": \"release\", \"isBuildEnabled\": true, \"xrayScanEnabled\": true, \"failOnXrayScan\": true, \"sonarScanEnabled\": true, \"staging\": { \"stages\": [ \"dev\" ] }, \"additionalBuildParams\": \"-DskipITs\", \"triggerBuildOnCommitEnabled\": false, \"hotfixCreationEnabled\": false }, { \"stepType\": \"hotfix\", \"isBuildEnabled\": true } ] }   Die folgenden Einstellungen können in der Konfiguration gefunden werden:\n   Gruppe Einstellung Beschreibung     Root mainBranch Name des Produktions-Branches. Normalerweise master oder develop   Root hotfixBranch Prefix für Hotfix-Branches   Docker artifactoryDockerRepo Repository-Pfad für Docker   Docker openshiftAppName Name der Applikation auf der Openshift Container Plattform   Maven parentPom Pfad zum pom.xml   Maven deployableArtifactsPom Angabe aller auslieferbaren pom.xml   Maven artifactoryMavenRepo Name des Artifactory-Verzeichnisses   Stage (Angabe erfolgt pro Stage) stageName Name der Plattform als Abkürzung (dev, test, inte, prod)   Stage (Angabe erfolgt pro Stage) isOpenshiftDeploymentEnabled Deployment auf Openshift erlaubt (true / false)   Stage (Angabe erfolgt pro Stage) openshiftProject Name des Projekts auf der Openshift Container Plattform   Stage (Angabe erfolgt pro Stage) openshiftCluster Openshift Cluster (OTC, AWS, …)   Stage (Angabe erfolgt pro Stage) openshiftJenkinsCredentialsId Secret Key, damit sich Jenkins auf der Openshift Container Plattform einloggen kann   Stage (Angabe erfolgt pro Stage) preCiDeploymentJob Name des vorgelagerten Jenkins-Jobs   Stage (Angabe erfolgt pro Stage) postCiDeploymentJob Name des nachgelagerten Jenkins-Jobs   Step (Angabe erfolgt pro Step) stepType Name der Option   Step (Angabe erfolgt pro Step) isBuildEnabled Option aktiv (true / false)   Step (Angabe erfolgt pro Step) branchNamePrefixes Angabe der Präfixe der zu verwendenden Branches   Step (Angabe erfolgt pro Step) additionalBuildParams Weitere Maven-Angaben   Step (Angabe erfolgt pro Step) xrayScanEnabled XRay aktiv (true / false)   Step (Angabe erfolgt pro Step) failOnXrayScan Build schlägt fehl wenn XRay fehlschlägt (true / false)   Step (Angabe erfolgt pro Step) sonarScanEnabled Sonar aktiv (true / false)   Step (Angabe erfolgt pro Step) staging Angabe von Stages zur Auslieferung   Step (Angabe erfolgt pro Step) triggerBuildOnCommitEnabled Wird dieser Build ausgeführt, wenn ein Commit erfolgt (true / false)   Step (Angabe erfolgt pro Step) hotfixCreationEnabled Darf dieser Build einen Hotfix-Branch erzeugen (true / false)    Die genauen Beschreibungen der einzelnen Einstellungen sind sehr umfangreich. Weitere Informationen gibt es hier\nZu Beginn gibt es Konfigurationen für GIT und Docker. Anschliessend benötigt Maven den Namen und den Pfad für das POM. Die Auslieferung erfolgt auf sogenannte Stages, dies sind Projekte auf der Openshift Container Plattform. Jede Stage kann individuell konfiguriert werden. Wichtig dabei ist der Schlüssel, welcher auf dem Jenkins hinterlegt sein muss. Nur mit diesem Schlüssel kann sich der Jenkins für ein Deployment auf der Openshift Container Plattform einloggen. Für jeden Step kann konfiguriert werden, ob er auf eine oder mehrere Stages ausgeliefert werden soll.\nDie häufigsten Steps sind:\n Continuous Release Deploy  Der Continuous-Build dient dabei Branches vom Typ feature oder bugfix (je nach Konfiguration) zu bauen. Nur erfolgreiche Builds dieser Weiterentwicklungen oder Bugfixes können anschliessend in den Haupt-Entwicklungsbranch zurück gemerged werden. Dieser Build wird nicht auf eine Stage ausgeliefert.\nDer Release-Build dient der Herstellung einer neuen Version einer Anwendung. Dieser Build taggt die Version auf dem GIT-Repository und liefert sie auf die entsprechend konfigurierten Stages aus. Vorbehalten bleibt normalerweise der Release auf eine produktive Umgebung.\nDer Deploy-Build dient dem Deployment einer bestimmten Version auf eine bestimmte Stage. Die Stage kann dabei gewählt werden. Dieser Step-Typ wird normalerweise für den Release auf Integration- oder Produktionsplattformen verwendet.\nZum Nachlesen gibt es hier noch die Dokumentation der Pipeline.\n","categories":"","description":"Modul #S2\n","excerpt":"Modul #S2\n","ref":"/docs/java/maven/","tags":"","title":"Maven und Continuous Integration"},{"body":"Ziele  Du weisst, wie du in JavaScript optionale Argumente in einem Parameter einen Default-Wert zuweisen kannst. Du weisst, wie du Named Arguments in Parameter verwenden kannst.  Basics Methoden (und daher auch Konstruktore) besitzen oft Werte, die zwingend übergeben werden müssen und welche, die optional sind.\nBeim nächsten Beispiel wäre z.B. der Name bei einer Person zwingend, das Alter, Geschlecht und sein/ihr Verhältnis zu JavaScript optional:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  class Person { name; age; gender; lovesJavaScript; constructor(name, age = undefined, gender = undefined, lovesJavaScript = true) { this.name = name; this.age = age; this.gender = gender; this.lovesJavaScript = lovesJavaScript; } } // Hier wollen wir eine Person erstellen, kennen aber das Alter, Geschlecht und seine Beziehung zu JS nicht: new Person(\"Colonel Toad\"); \u003e\u003e\u003e Person {name: 'Colonel Toad', age: undefined, gender: undefined, lovesJavaScript: true} // Hier wollen wir neben dem Namen nur das Alter setzen: new Person(\"Sweating Towel Guy\", 44); \u003e\u003e\u003e Person {name: 'Sweating Towel Guy', age: 44, gender: undefined, lovesJavaScript: true} /// Möchtest du das letzte Argument setzen, dann musst du die vorherigen Variablen auch setzen: new Person(\"Man Ray\", null, null, false); \u003e\u003e\u003e Person {name: 'Man Ray', age: null, gender: null, lovesJavaScript: false}   Mit dieser Lösung hast du zwar eine Lösung, das die Präferenz einer Person bez. JavaScript speichert, auch wenn nur ein Name angebeben wird. Aber was wäre, wenn du Eine Person erstellen möchtest mit einem Geschlecht, aber das Alter nicht angeben möchtest?\nHierfür bieten sich dann Named Parameters an:\nNamed Parameters Dank dem Object Destructuring aus ES6 kannst du alle optionale Argument einzeln zuweisen bzw. überspringen. Das könnte wie folgt aussehen:\n1 2 3 4 5 6 7 8 9 10 11 12  class Person { constructor(name, {age = undefined, gender = undefined, lovesJavaScript = true}) { this.name = name; this.age = age; this.gender = gender; this.lovesJavaScript = lovesJavaScript; } } new Person(\"Steven Crowder\", {gender: \"male\"}); \u003e\u003e\u003e Person {name: 'Steven Crowder', age: undefined, gender: 'male', lovesJavaScript: true}   ","categories":"","description":"Seit ES2015 (ES6) gibt es in JavaScript die Möglichkeit, den Parametern von Methoden einen Default-Wert zu geben.\n","excerpt":"Seit ES2015 (ES6) gibt es in JavaScript die Möglichkeit, den …","ref":"/docs/web/javascript/09_optional_args/","tags":"","title":"ES6: Optionale Argumente in Methoden und Konstruktoren"},{"body":"Lazy Loading in Angular Standardmässig lädt der Browser alle Angular-Module, bevor der Benutzer mit ihnen arbeiten kann.\nNatürlich gibt es auch einige, die nicht oder zumindest nicht sofort benötigt werden.\nGenau hier setzt das Lazy Loading an, um die Startgeschwindigkeit zu optimieren: Es stellt sicher, dass nur die wichtigsten Anwendungsbestandteile im Browser landen, der Rest wird später bei Bedarf angefordert. Hierfür werden einfach Routen mit der Eigenschaft “loadChildren” verwendet\n1 2 3 4 5 6  const routes = [ { path: 'login', component: LoginComponent }, { path: 'admin', loadChildren: () =\u003e import('./admintools/admintools.module').then(m =\u003e m.AdmintoolsModule)}, { path: 'profile', canActivate: [AuthGuard], loadChildren: () =\u003e import('./profile/profile.module').then(m =\u003e m.ProfileModule)}, ... ]   Lazy Loading mit Angular Material Einige Components von Angular Material unterstützen Lazy Loading.\nEin Beispiel hierzu ist das Expansion-Panel.\nDie Inhalte des Expansion Panels werden geladen, auch wenn das Expansion-Panel geschlossen ist. Wenn man auf einer Ansicht beispielsweise 30 dieser Expansion-Panels anzeigt und den jeweiligen Inhalt lädt, kann dies zu Performance-Problemen führen.\nJedoch unterstützt dieser Component Lazy Loading, wodurch man die Performance-Probleme sehr einfach umgehen kann.\nInhalte werden erst geladen wenn sich das Expansion-Panel öffnet.\nIn den meisten Fällen ist das Anwenden von Lazy Loading in Angular Material Components auch kein grosser Aufwand.\nSchaut also auf der Angular Material Website in “Overview” des Components immer gut nach, ob der Component Lazy Loading unterstützt.\n","categories":"","description":"Lazy Loading bezeichnet ganz allgemein eine Technik in der Software-Entwicklung um Daten erst bei Bedarf nachzuladen. Im Zusammenhang mit Websites geht es darum, beispielsweise Bilder erst dann zu vom Server zu laden, wenn diese im sichtbaren Bereicht sind. Dadurch wird die Ladezeit von Websites reduziert.\n","excerpt":"Lazy Loading bezeichnet ganz allgemein eine Technik in der …","ref":"/docs/web/angular/04_8_lazy_loading/","tags":"","title":"Lazy Loading"},{"body":"","categories":"","description":"Aufgaben zu Modul #J7 - Collections\n","excerpt":"Aufgaben zu Modul #J7 - Collections\n","ref":"/labs/java/java-collections/","tags":"","title":"Aufgaben zu Java - Collections"},{"body":"","categories":"","description":"Exercises zu Modul #J6 - Annotationen \u0026 Reflection API\n","excerpt":"Exercises zu Modul #J6 - Annotationen \u0026 Reflection API\n","ref":"/labs/java/java-reflection-and-annotations/","tags":"","title":"Java Exercises - Annotationen \u0026 Reflection API"},{"body":"","categories":"","description":"Exercises zu Modul #J8 - JDBC\n","excerpt":"Exercises zu Modul #J8 - JDBC\n","ref":"/labs/java/java-jdbc/","tags":"","title":"Java Exercises - JDBC"},{"body":"Ziele  Ich weiss, warum das Testen in der Softwareentwicklung eine zentrale Bedeutung hat Ich kenne die gängigen Testarten in der Software-Entwicklung und deren Zweck Ich kenne die wichtigsten Funktionen des Frameworks JUnit 5 Ich kann für einfache Anwendungen selber Unit-Tests implementieren Ich kenne die wichtigsten Funktionen des Frameworks Mockito Ich weiss was Mocks und Spies sind und kenne den Unterschied dazwischen Ich weiss, was Test-Driven-Development ist und wie ich die Methodik anwenden kann  Einführung Tests in den unterschiedlichen Phasen der Softwareentwicklung dienen dazu festzustellen, ob die entwickelte Software die spezifizierten Anforderungen erfüllt oder nicht. Ausserdem können Tests Mängel in dem produzierten Code aufdecken noch bevor der Code produktiv geschaltet wird und stellen damit sicher, dass das Endprodukt fehlerfrei funktioniert.\nTests sind vor allem aus folgenden Gründen sehr wichtig und sollen entsprechend sehr früh (dazu später) in den Entwicklungsprozess integriert werden:\n Testing erhöht die Qualität des entwickelten Produkts da damit Mängel frühzeitig entdeckt und beseitigt werden können Testing gibt mehr Sicherheit bei Änderungen am Code da damit sichergestellt werden kann, dass die Änderung nicht zu unerwünschten Nebenwirkungen geführt haben. Testing spart Geld da damit weniger Nachbearbeitungsaufwand in Form von Bug/Hot-Fixes betrieben werden muss. Testing führt zu höherer Kundenzufriedenheit da damit weniger Fehler den Kunden davor hindern, fehlerfrei mit dem Produkt zu arbeiten  Testarten Es gibt viele verschiedene Softwaretestverfahren und Methoden, mit denen sichergestellt werden kann, dass Änderungen am Code wie erwartet funktionieren.\nSoftwaretests können in zwei Bereiche unterteilt werden: manuelles Testen und automatisiertes Testen. Beim manuellen Testen werden Testfälle manuell durch einen Menschen und ohne Unterstützung durch Werkzeuge oder Skripte ausgeführt.\nBeim automatisierten Testen werden Testfälle jedoch mithilfe von Tools, Skripten und Software ausgeführt.\nHier werden wir uns auf das automatisierte Testen konzentrieren, da dieses im Softwareentwicklungsprozess essenziell ist.\nUnit-Tests Unit-Tests sind sehr einfach und erfolgen nah an der Quelle der Anwendung.\nSie dienen zum Testen einzelner Methoden und Funktionen der von der Software verwendeten Klassen, Komponenten oder Module.\nMit Unit-Tests stellen wir sicher, dass eine Applikation mit ihren Funktionen genau das macht, was eigentlich beabsichtigt war. Dazu genügt es nicht nur die “guten” Fälle zu testen, es sollten auch Tests für Grenzwerte durchgeführt werden. Ein Unit-Test ist immer ein sog. “White-Box” Test, da der Entwickler bei der Implementation von Unit-Tests den Sourcecode kennt oder ihn einsehen kann.\nBei Unit-Tests in Java ist der Testumfang eines Unit-Tests normalerweise in der Grössenordnung einer Methode.\nIn der Regel lassen sich Unit-Tests automatisieren und können einzeln oder auch in Gruppen (sog. Test-Suites) lokal (an der eigenen Maschine) oder von einem Continuous-Integration-Server (eine externe Maschine, der dafür sorgt, dass Programmteile sofort getestet und zusammengeführt werden können) sehr schnell durchgeführt werden.\nIntegrations-Tests Mit Integrationstests wird sichergestellt, dass verschiedene Programmteile der Anwendung problemlos ineinandergreifen. So kann beispielsweise die Interaktion mit einer Datenbank oder das Zusammenspiel von Mikroservices getestet werden.\nTests dieser Art sind kostspieliger und können auch länger dauern als Unit-Tests, weil dafür mehrere Teile der Anwendung funktionsfähig sein müssen.\nEnd-to-End-Tests Bei End-to-End-Tests wird der Umgang des Benutzers (oder auch andere, externe Programme) mit der Software in einer vollständigen Anwendungsumgebung repliziert. Auf diese Weise wird das ordnungsgemässe Funktionieren von Benutzerabläufen überprüft. Die Szenarien können ganz einfach sein (z.B. Laden einer Website, Anmeldevorgang) oder auch sehr komplex (z.B. E-Mail-Benachrichtigungen, Onlinezahlungen).\nEnd-to-End-Tests sind sehr nützlich, aber auch aufwändiger zu erstellen und in automatisierter Form unter Umständen schwer zu verwalten. Es empfiehlt sich deshalb, eher weniger End-to-End-Tests zu implementieren und stattdessen eher auf weniger aufwändigen Testarten (Unit- und Integrationstests) zu setzen, um riskante Änderungen schnell erkennen zu können.\n Junit Zur Implementation von Unit-Tests steht in Java das Framework JUnit zur Verfügung. Die aktuellste Version ist 5.9.0. Dies ändert aber stetig, da das Produkt weiterentwickelt wird. Vielfach ist in Produkten und Projekten auch JUnit 4 im Einsatz. In diesem Modul wird jedoch nur die aktuellste Version von JUnit behandelt. Wir schreiben Unit-Tests also mit JUnit 5.\nWie ist JUnit 5 aufgebaut? Das Framework besteht aus folgenden Teilen:\n   Teil Verwendung     JUnit Plattform Grundlage zur Einführung von Testframeworks in die JVM. Definition der Test-Engine zur Entwicklung von Testframeworks auf der jeweiligen Plattform. Plattform-Konsole zum Starten der Plattform. Kurz gesagt: Plattform zur Ausführung von Unit-Tests   JUnit Jupiter Programmiermodell zur Implementation von Unit-Tests   JUnit Vintage Ermöglicht die Ausführung von Tests, die mit JUnit 3 oder JUnit 4 geschrieben wurden    Wo kann ich das Framework herunterladen? Damit wir nun Unit-Tests implementieren können benötigen wir zuerst die Bibliotheken von JUnit 5, dies wird in den beiden folgenden Abschnitten beschrieben.\nAbhängigkeiten einbinden ohne Maven Dieser Abschnitt kann übersprungen werden, wenn mit einem Maven-Projekt gearbeitet wird. Alle Bibliotheken sind unter den beiden folgenden Links zu finden:\n org.junit.jupiter org.junit.platform  Die folgenden JARs werden benötigt:\n Aus dem ersten Link  junit-jupiter-engine junit-jupiter-params junit-jupiter junit-jupiter-api   Aus dem zweiten Link  junit-platform-engine junit-platform-commons    Die Einbindung in ein Projekt muss (ohne Maven) manuell gemacht werden. Die folgende Anleitung soll dabei helfen:\n   # Beschreibung Screenshot     1 Ordner für Bibliotheken im Projekt anlegen. Im Projekt (Root) einfach einen neuen Ordner “lib” erzeugen.    2 Die oben genannten JAR-Bibliotheken in den neuen Ordner kopieren    3 Projekteinstellungen öffnen. Das Projekt mit einem Klick markieren und Taste F4 drücken. Die Projekteinstellungen werden geöffnet    4 Auf der linken Seite den Tab “Libraries” auswählen    5 Oben auf das Plus-Icon klicken und Java auswählen    6 Die vorhin kopierten Bibliotheken auswählen und alle Dialoge mit OK bestätigen    7 Die Bibliothek muss anschliessend dem Modul hinzugefügt werden. Der Scope sollte auf Test gestellt werden, da es sich um reine Test-Bibliotheken handelt.     Abhängigkeiten einbinden mit Maven Dieser Abschnitt kann übersprungen werden, wenn es sich nicht um ein Maven Projekt handelt.\nDie entsprechenden Abhängigkeiten für das Project Object Model (pom.xml) sind:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  \u003cdependencies\u003e \u003c!-- Plattform --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter\u003c/artifactId\u003e \u003cversion\u003e5.9.0\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c!-- API, enthält unter anderem alle Annotationen --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter-api\u003c/artifactId\u003e \u003cversion\u003e5.9.0\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c!-- Test-Engine zur Ausführung von Unit-Tests, die mit JUnit 5 geschrieben wurden --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter-engine\u003c/artifactId\u003e \u003cversion\u003e5.9.0\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c!-- JUnit 5 Erweiterung für parametrisierte Tests (Optional) --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter-params\u003c/artifactId\u003e \u003cversion\u003e5.9.0\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c!-- Test-Enginge zur Ausführung von Unit-Tests, die mit JUnit 3 oder JUnit 4 geschrieben wurden (Optional) --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.vintage\u003c/groupId\u003e \u003cartifactId\u003ejunit-vintage-engine\u003c/artifactId\u003e \u003cversion\u003e5.9.0\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c!-- Bibliotheken für die Ausführung von Unit-Tests --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.platform\u003c/groupId\u003e \u003cartifactId\u003ejunit-platform-engine\u003c/artifactId\u003e \u003cversion\u003e1.9.0\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.platform\u003c/groupId\u003e \u003cartifactId\u003ejunit-platform-commons\u003c/artifactId\u003e \u003cversion\u003e1.9.0\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e   Füge diese Abhängigkeiten (ohne die optionalen) in dein pom.xml ein. Danach besitzt du alle Bibliotheken, die zur Implementation von Unit-Tests notwendig sind.\nOrdnerstruktur anlegen Um Unit-Tests implementieren zu können benötigen wir grundsätzlich die folgende Ordnerstruktur im IntelliJ IDEA.\nFalls dein Projekt kein Maven-Projekt ist, kannst du die Verzeichnisse einfach manuell anlegen. Mit einem Rechtsklick auf die Verzeichnisse, kannst du sie mit dem Befehl “Mark Directory as” aus dem Kontext-Menü wie folgt markieren:\n   Verzeichnis Markierung Zweck     src/main/java Sources Root Source Code deiner Applikation   src/main/resources Resources Root Ressourcen deiner Applikation, die nicht Programmcode sind   src/test/java Test Sources Root Source Code deiner Unit-Tests   src/test/resources Test Resources Root Ressourcen deiner Unit-Tests, die nicht Programmcode sind    Diese Ordnerstruktur wurde ursprünglich vom Projektmanagement-Tool Gradle “erfunden” und dann von Maven übernommen. Stand heute ist dies die Standard-Ordnerstruktur innerhalb von Java-Projekten.\nImplementation von Unit-Tests an einem Beispiel Nach all den Vorbereitungen sind wir nun bereit Unit-Tests zu implementieren. Der folgende Abschnitt beschreibt die Grundlagen für das Schreiben von Unit-Tests.\nDas JUnit-Framework\n nutzt Assertions, um Resultate innerhalb eines Tests zu überprüfen nutzt Annotationen, um Testfälle zu finden und durchzuführen  Erklärung Beispiel einer Unit-Test Implementation anhand eines einfachen Beispiels.\nSource-Code\n1 2 3 4 5 6 7  package ch.sbb.talentfactory.calculator; public class Calculator { public int add(int i1, int i2) { return i1 + i2; } }   Test-Code\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  package ch.sbb.talentfactory.calculator; import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; public class CalculatorTest { private Calculator uut = new Calculator(); @Test public void testAdd() { // prepare test data  int i1 = 5; int i2 = 9; // call method  int result = this.uut.plus(i1, i2); // verify  assertEquals(14, result); } }   Der Unit-Test befindet sich im gleichen Package wie die zu testende Klasse. Innerhalb der weiter oben genannten Ordnerstruktur ist die Test-Klasse aber nicht am gleichen Ort abgelegt! Innerhalb des Unit-Tests wird zuerst eine Instanz der zu testenden Klasse angelegt. Die Bezeichnung für diese Instanz lautet normalerweise UUT, dies steht für “Unit Under Test”. Für jeden Test einer der Methoden aus dem UUT wird anschliessend eine Test-Methode implementiert. Diese Methoden sind mit @Test zu annotieren, so werden sie anschliessend vom Test-Framework als eigenständiger Test erkannt und ausgeführt. Ein Unit-Test kann beliebig viele Testmethoden enthalten. Grundsätzlich reichen aber je nach Funktionalität ein paar wenige Tests aus, um die ganze Funktionalität einer Methode zu überprüfen. Innerhalb der Test-Methoden implementieren wir dann “normalen” Programmcode, welcher den Code aus dem UUT “überprüft”. In unserem Beispiel setzen wir zwei Variablen und rufen damit die zu testende Methode auf. Mit einer Assertion vergleichen wir dann einen erwarteten Wert mit dem von der Methode zurückgelieferten Resultat. Beachte, dass der erwartete Wert in der Assertion immer an erster Stelle stehen muss. Wenn die beiden Werte identisch sind, dann ist der Unit-Test erfolgreich.\nVorgehen beim Schreiben von Unit-Tests Grundsätzlich sollte die AAA-Methode angewendet werden, sie ist auch im Beispiel oben ersichtlich. AAA steht für “Arrange”, “Act” und “Assert”. “Arrange” steht dabei für die Vorbereitung des Tests, “Act” ist die eigentliche Durchführung und mit “Assert” werden die Resultate des Tests überprüft.\nGrenzwerte austesten Vielfach sind gewisse Funktionen in einer Applikation so implementiert, dass sie sich mit wenigen Unit-Tests komplett testen lassen. Dazu ein kleines Beispiel: gegeben ist ein Rechteck mit bestimmten Koordinaten (Ecke oben links) und einer bestimmten Grösse (Höhe und Breite).\nEine Methode innerhalb des Rechtecks dient dazu herauszufinden, ob eine bestimmte Koordinate inner- oder ausserhalb des Rechtecks liegt. Punkte, die auf dem Rand zu liegen kommen gelten in diesem Sinne nicht als innerhalb des Rechtecks.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  package ch.sbb.talentfactory.rectangle; public class Rectangle { private int top; private int left; private int width; private int height; public Rectangle(int top, int left, int width, int height) { this.top = top; this.left = left; this.width = width; this.height= height; } public boolean isInside(int x, int y) { if (x \u003e left \u0026\u0026 x \u003c left + width) { if (y \u003e top \u0026\u0026 y \u003c top + height) { return true; } } return false; } }   Damit keine Verwirrung entsteht, hier das verwendete Koordinatensystem. Wie wir in der Implementation sehen können gibt es hier vier verschiedene Bedingungen. Das Ziel des Tests muss es also sein, dass wir alle diese Bedingungen überprüfen. Wenn immer möglich, sollten alle möglichen Kombinationen getestet werden. Nur so kann sichergestellt werden, dass die Methode wie gewünscht funktioniert. Aufgrund der AND-Verknüpfung werden die zweiten Bedingungen der jeweiligen Statements nicht mehr ausgewertet. Damit müssen die folgenden Kombinationen durch einen Unit-Test abgedeckt werden\n   Bedingung x \u003e left x \u003c left + width y \u003e top y \u003c top + height Resultat     Variante 1 False    False   Variante 2 True False   False   Variante 3 True True False  False   Variante 4 True True True False False   Variante 5 True True True True True    Dies bedeutet wir implementieren fünf Unit-Tests, um die Methode vollständig abzudecken.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  package ch.sbb.talentfactory.rectangle; import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; public class RectangleTest { // I know this is a square ;-)  private Rectangle uut = new Rectangle(0, 0, 10, 10); @Test public void testIsInside() { assertFalse(this.uut.isInside(-1, 5)); assertFalse(this.uut.isInside(11, 5)); assertFalse(this.uut.isInside(5, -1)); assertFalse(this.uut.isInside(5, 11)); assertTrue(this.uut.isInside(5, 5)); } }   Im IntelliJ gibt es wie bei der Ausführung einer Applikation auch die Möglichkeit einen Unit-Test zu debuggen. Zusätzlich können wir die Testabdeckung anschauen, wenn wir den Unit-Test mit “Coverage” durchlaufen lassen. Wenn der Test erfolgreich durchgelaufen ist, dann kann die getestete Klasse geöffnet werden.\nDie grünen Balken auf der linken Seite zeigen die Testabdeckung an. In diesem Fall sind sämtliche Zeilen durch einen Test durchlaufen worden.\nDa der Unit-Test nun alle Möglichkeiten der Methode abdeckt, kann ein einfaches Refactoring durchgeführt werden. In unserem Fall kann die Methode wie folgt vereinfacht werden:\n1 2 3  public boolean isInside(int x, int y) { return x \u003e left \u0026\u0026 x \u0026lt; left + width \u0026\u0026 y \u0026gt; top \u0026\u0026 y \u003c top + height; }   Der Test kann dann beliebig oft erneut durchgeführt werden, um das Refactoring zu überprüfen.\nAnnotationen von JUnit5 Die folgende Tabelle zeigt eine Übersicht über die wichtigsten Annotationen von JUnit 5. Mehr Informationen zu den jeweiligen Annotationen finden sich in den nächsten Kapiteln.\n   Annotation Beschreibung     @Test Bezeichnet einen Test   @ParameterizedTest Bezeichnet einen parametrisierten Test   @RepeatedTest Bezeichnet einen sich wiederholenden Test   @DisplayName Namensgebung für Testklassen und -methoden   @Disabled Möglichkeit eine Testklasse oder -methode nicht ausführen zu lassen   @TestMethodOrder\n@Order Ausführungsreihenfolge der Tests bestimmen.   @BeforeAll\n@BeforeEach\n@AfterAll\n@AfterEach Initialiserungen und Aufräumarbeiten vor und nach Unit-Tests    Parametrisierte Unit-Tests Der oben gezeigte Unit-Test ist ein typisches Beispiel für einen Test, der mit vielen unterschiedlichen Parametern durchlaufen werden sollte. Wenn wir den Test parametrisieren, können wir die Test-Methode wiederverwenden.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  package ch.sbb.talentfactory.calculator; import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; public class CalculatorTest { private Calculator uut = new Calculator(); @ParameterizedTest @ValueSource(ints = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }) public void testAddParameterized(int operand1) { // call method  int result = this.uut.add(operand1, 5); // verify  assertEquals(operand1 + 5, result); } }   Der gezeigte Test wird so insgesamt neun Mal durchlaufen, wobei der Parameter operand1 jeweils die Werte des angegebenen Arrays durchläuft.\nWiederholende Unit-Tests Unit-Tests können mehrmals hintereinander ausgeführt werden, dabei wird die annotierte Test-Methode einfach mehrfach aufgerufen. Die Anzahl Aufrufe wird durch den Parameter in der Annotation bestimmt.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  package ch.sbb.talentfactory.calculator; import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; public class CalculatorTest { private Calculator uut = new Calculator(); @RepeatedTest(10) public void testAddRepeated() { // prepare test data \tRandom random = new Random(); int i1 = random.nextInt(100); int i2 = random.nextInt(100); // call method  int result = this.uut.plus(i1, i2); // verify  assertEquals(i1 + i2, result); } }   Repetierende Tests können wie oben gezeigt benutzt werden, um beispielsweise mit generierten Zufallszahlen bestimmte Funktionen zu überprüfen.\nDisplay Names Testklassen und -methoden können mit der Annotation @DisplayName beliebig umbenannt werden.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  package ch.sbb.talentfactory.calculator; import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; @DisplayName(\"Special test for calculator\") public class CalculatorTest { private Calculator uut = new Calculator(); @Test @DisplayName(\"Ultimate addition test\") public void testAdd() { // prepare test data  int i1 = 5; int i2 = 9; // call method  int result = this.uut.plus(i1, i2); // verify  assertEquals(14, result); } }   Der angegebene Name erscheint dann in der Testauswertung.\nTests ausschalten Testklassen und -methoden können mit der Annotation @Disabled aus den Testläufen ausgeschlossen werden.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  package ch.sbb.talentfactory.calculator; import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; @Disabled(\"Test disabled until calculator is finished\") public class CalculatorTest { private Calculator uut = new Calculator(); @Test public void testAdd() { // prepare test data  int i1 = 5; int i2 = 9; // call method  int result = this.uut.plus(i1, i2); // verify  assertEquals(14, result); } }   Reihenfolge der Ausführung Die Reihenfolge von Tests bei der Ausführung kann durch die Verwendung von @TestExecutionOrder und @Order bestimmt werden.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  package ch.sbb.talentfactory.calculator; import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; @TestExecutionOrder(OrderAnnotation.class) public class CalculatorTest { private Calculator uut = new Calculator(); @Test @Order(1) public void testAdd() { // prepare test data  int i1 = 5; int i2 = 9; // call method  int result = this.uut.plus(i1, i2); // verify  assertEquals(14, result); } @Test @Order(2) public void testAdd() { // prepare test data  int i1 = -1; int i2 = 3; // call method  int result = this.uut.plus(i1, i2); // verify  assertEquals(2, result); } }   Die Annotation @Order wird nur verwendet, wenn der Typ der Ausführung OrderAnnation.class ist. Weitere Angaben sind “Alphanumeric” (Sortierung nach Methodenname) und “Random” (Zufällige Ausführungsreihenfolge).\nDaten initialisieren / aufräumen Mit den Annotationen @BeforeEach, @AfterEach, @BeforeAll und @AfterAll können bestimmte Initialisierungen und Aufräumarbeiten vor und nach Unit-Tests ausgeführt werden.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  package ch.sbb.talentfactory.calculator; import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; public class CalculatorTest { private Calculator uut = new Calculator(); @BeforeAll public static void setUpAll() { // Diese Methode wird VOR allen Test-Methoden EINMALIG ausgeführt \t} @BeforeEach public void setUp() { // Diese Methode wird VOR jeder Test-Methode ERNEUT ausgeführt \t} @Test public void testAdd() { // prepare test data  int i1 = 5; int i2 = 9; // call method  int result = this.uut.plus(i1, i2); // verify  assertEquals(14, result); } @AfterEach public void tearDown() { // Diese Methode wird NACH jeder Test-Methode ERNEUT ausgeführt \t} @AfterAll public static void tearDownAll() { // Diese Methode wird NACH allen Test-Methoden einmalig ausgeführt \t} }   Verwendung von Providern Bei der Verwendung von parametrisierten Tests ist es möglich, dem Unit-Test über einen Stream von Argumenten entsprechende Testdaten oder Instanzen von verschiedenen Objekten zukommen zu lassen. Das folgende Beispiel illustriert die Verwendung eines solchen Providers.\nVier Gewinnt Interface\n1 2 3  public interface ConnectFourCheck { String checkWin(String[][] board); }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  public class VierGewinntTest { private String[][] testBoard = { {\" \", \" \", \" \", \" \", \"O\"}, {\" \", \" \", \" \", \"O\", \"X\"}, {\" \", \" \", \" \", \"O\", \"X\"}, {\" \", \" \", \"O\", \"X\", \"X\"}, {\" \", \" \", \" \", \" \", \"X\"} }; // Alle Klassen des Streams (VierGewinntSolution1 und VierGewinntSolution2) implementieren das oben gezeigte Interface  private static Stream\u003cArguments\u003e instances() { return Stream.of( Arguments.of(new VierGewinntSolution1()), Arguments.of(new VierGewinntSolution2()) ); } @ParameterizedTest @MethodSource(\"instances\") public void testBoardWithWinnerX(ConnectFourCheck cfc) { try { String winner = cfc.checkWin(this.testBoard); assertEquals(\"X\", winner); } catch (Exception e) { fail(e); } } }   Mit einem solchen Provider kann derselbe Unit-Test für verschiedene Implementation (zum Beispiel eines Interfaces) wiederverwendet werden.\n Mockito Mockito ist ein Framework zum Erstellen und Benutzen von Mocks in Softwaretests. Es bietet die Möglichkeit, Verhalten von noch nicht implementierten Klassen und Methoden rudimentär zu simulieren, um so das zu testende System (trotz fehlender Teile) testen zu können. Mockito ermöglicht auch andere Systeme/Services zu simulieren, welche z.B. von einem anderen Team entwickelt werden wie auch solche, deren echtes Verhalten zum Testzweck nicht interessiert oder sogar nicht erwünscht ist (man will aber z.B. wissen, dass diese Systeme/Services vom getesteten Code angesprochen worden sind).\nMockito kann in Unit-Tests wie auch in Integrations-Tests verwendet werden.\nWo kann ich das Framework herunterladen? Wie bei JUnit, werden auch für die Arbeit mit Mockito die Bibliotheken davon benötigt.\nAbhängigkeiten einbinden ohne Maven Dieser Abschnitt kann übersprungen werden, wenn mit einem Maven-Projekt gearbeitet wird. Das letzte Release (aktuell 4.6.1) kann hier heruntergeladen werden: Mockito Core 4.6.1 Jar-Datei\nDie Heruntergeladene Jar-Datei kann nun genau wie die JUnit-Jar-Dateien eingebunden werden.\nAbhängigkeiten einbinden mit Maven Dieser Abschnitt kann übersprungen werden, wenn es sich nicht um ein Maven Projekt handelt.\nDie entsprechende Abhängigkeit für das Project Object Model (pom.xml) ist:\n1 2 3 4 5 6 7 8 9  \u003cdependencies\u003e \u003c!-- https://mvnrepository.com/artifact/org.mockito/mockito-core --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mockito\u003c/groupId\u003e \u003cartifactId\u003emockito-core\u003c/artifactId\u003e \u003cversion\u003e4.6.1\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e   Mockito Begriffe Mock Mocks sind ein vollständiger Ersatz für Objekte, Services usw., von denen der zu testende Code abhängt, um seine Kernlogik zu testen. Ein Mock kann so programmiert werden, dass es eine angegebene Ausgabe zurückgibt, wenn eine Methode des Mocks aufgerufen wird.\nMockito bietet eine Standardimplementierung für alle Methoden eines Mocks. Das bedeutet, dass beim Aufrufen einer Methode eines Mocks, nicht der “echte” Code der Methode aufgerufen wird, sondern es wird ein von Mockito vordefinierter Wert zurückgeliefert (abhängig vom Rückgabewert-Typ der Methode).\nEs gibt Situationen, in denen es nützlich sein kann, bestimmte Werte aus einer Methode zurückzuliefern statt die Mockito-Standardwerte. In diesen Situationen kann ein gewünschter Rückgabewert vorkonfiguriert werden, so dass beim Aufruf der Methode, dieser Wert zurückgeliefert wird.\nSpy Ein Spy (‘Spion’) ist im Wesentlichen ein Wrapper für eine “echte” Instanz eines gemockten Objekts. Dies bedeutet, dass eine neue Instanz des Objektes erforderlich ist und dann ein Spy darüber hinzugefügt wird.\nStandardmässig leiten Spies Methodenaufrufe an die “echten” Methoden des Objekts weiter. Das ist auch der Hauptunterschied zwischen Spies und Mocks. Letztere überschreiben den “echten” Methoden-Code.\nSpies bieten aber auch die Möglichkeit, bestimmte Methoden als Mock-Methoden vorzukonfigurieren. In solchen Fällen, wird der Methodenaufruf nicht auf den “echten” Code weitergeleitet, sondern es wird, wie beim Mock, der vorgegebene Rückgabewert zurückgeliefert.\nMockito Annotationen Damit die Mockito-Annotationen innerhalb eines JUnit-Tests verwendet werden könnten, müssen sie zuerst eingeschaltet werden. Eine Möglichkeit dies zu tun ist, die Unit-Test-Klasse mit @RunWith zu annotieren und als Parameter den Wert MockitoJUnitRunner.class anzugeben:\n1 2 3 4  @RunWith(MockitoJUnitRunner.class) public class MyUnitTest { //TODO write tests }   Die folgende Tabelle zeigt eine Übersicht über die wichtigsten Annotationen von Mockito:\n   Annotation Beschreibung     @Mock Mock-Objekte erzeugen lassen   @InjectMock Markiert ein Feld, welches mit Mocks initiiert wird   @Spy Spy-Objekte erzeugen lassen   @Captor ArgumentCaptor Objekte erzeugen lassen    Wie diese Annotationen verwendet werden, wird in den folgenden Kapiteln gezeigt.\n@Mock Annotation Diese Annotation wird dazu verwendet, um Mock-Objekte komplett von Mockito erzeugen zu lassen. Das heisst, die gesamte Mock-Funktionalität wird von Mockito zur Verfügung gestellt.\n1 2 3 4 5 6 7 8  @RunWith(MockitoJUnitRunner.class) public class MyUnitTest { @Mock private List\u003cString\u003e mockedList; // hier wird eine Liste von Strings gemockt.  // Mockito stellt eine rudimentäre Umsetzung für JEDE Methode der Liste zur Verfügung  //TODO write tests }   Was mit einem Mock gemacht werden kann und wie der Mock vorkonfiguriert werden kann, wird in einem späteren Kapitel erklärt.\n@InjectMocks Annotation Wenn eine Klasse ein Objekt-Feld beinhaltet, kann Mockito dieses Feld mit einem Mock initiieren. Damit es funktioniert, muss das Feld entweder via Konstruktor, via Setter oder via Property-Injection initialisiert werden.\nIm folgenden Beispiel, hat die Klasse Display ein Feld vom Typ ColorSelector, welches mittels Konstruktor initialisiert werden kann:\n1 2 3 4 5 6 7  public class Display { private final ColorSelector colorSelector; public Display(ColorSelector colorSelector) { this.colorSelector = colorSelector; } }   Im Test, wird ein Mock für ein ColorSelector erstellt und mit der Annotation @InjectMocks, via Konstruktor-Initialisierung in dem display-Objekt injektiert (der Konstruktor muss also nicht noch dazu aufgerufen werden):\n1 2 3 4 5 6 7 8 9 10 11  @RunWith(MockitoJUnitRunner.class) public class DisplayTest { @Mock ColorSelector mockedColorSelector; // hier wird ein ColorSelector gemockt.  @InjectMocks Display display; // der Mock von ColorSelector wird in die Display-Instanz \"injiziiert\", das heisst  // überall im Display-Objekt, wo der ColorSelector verwendet wird, wird der Mock zum Zug kommen!  //TODO write tests }   @Spy Annotation Ein Spy wird auf einem “echten” Objekt erzeugt. Dieser Spy leitet, sofern nichts anderes konfiguriert wurde, alle Methodenaufrufe an das echte Objekt weiter. Mit Hilfe der Mockito-Methoden, kann jedoch definiert werden, dass bestimmte Methoden “umgeleitet” werden und eine andere Umsetzung dafür angewendet wird.\n1 2 3 4 5 6 7 8 9  @RunWith(MockitoJUnitRunner.class) public class MyUnitTest { @Spy private List\u003cString\u003e spiedList; // Ein Spy über eine Liste. Wenn nichts anders konfiguriert wird  // werden die \"echte\" Listen-Methoden aufgerufen, wenn der Spy verwendet wird.  //TODO write tests }   Wie ein Spy verwendet werden kann, um nur einige Methoden umzuleiten, wird in einem späteren Kapitel erklärt.\n@Captor Annotation Ein ArgumentCaptor kann Argumente einer Methode “fangen” damit diese danach inspiziert werden könnten.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  @RunWith(MockitoJUnitRunner.class) public class MyUnitTest { @Mock private List\u003cString\u003e mockedList; @Captor private ArgumentCaptor\u003cString\u003e stringCaptor; // stringCaptor wird ein Argument vom Typ String \"fangen\"  public void testMockedList() { mockedList.add(\"one\"); Mockito.verify(mockedList).add(stringCaptor.capture); // während der Prüfung wird das Argument  // für die Methode add() gefangen  // und im stringCaptor aufbewahrt  assertEquals(\"one\", stringCaptor.getValue()); // mit getValue() kann das gefangene Argument inspiziert werden  } }   Mockito statische Methoden Mockito stellt mehrere statische Methoden zur Verfügung, welche das Konfigurieren von Mocks und Spies wie auch deren Überwachung ermöglichen. In diesem Kapitel werden die wichtigsten Methoden anhand von Beispielen erklärt.\nMockito.when kombiniert mit Mockito.thenReturn Die Mockito.when Methode kombiniert mit der Methode Mockito.thenReturn ermöglicht es, die Standardimplementierung einer Methode für ein gegebenen Mock zu überschreiben. Dasselbe kann auch mit der Kombination Mockito.doReturn und danach when erreicht werden.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  @RunWith(MockitoJUnitRunner.class) public class MyUnitTest { @Mock private List\u003cString\u003e mockedList; // eine Mock-Liste, mit Mockitos-Standardimplementierung für alle Methoden  public void testMockedList() { assertEquals(0, mockedList.size()); // die Mockito-Standardimplementierung für \"size()\"  // liefert immer 0 zurück  Mockito.when(mockedList.size()).thenReturn(10); // hier wird die Standardimplementierung der Methode  // size() auf dem Mock-Objekt überschrieben,  // sodass immer der Wert 10 zurückgeliefert wird.  assertEquals(10, mockedList.size()); Mockito.doReturn(20).when(mockedList).size(); // auch hier wird die Standardimplementierung der Methode  // size() auf dem Mock-Objekt überschrieben,  // diesmal mit dem Wert 20.  assertEquals(20, mockedList.size()); } }   Mockito.verify Die Mockito.verify Methode prüft, ob eine Interaktion mit dem Mock/Spy-Objekt stattgefunden hat. Geprüft werden kann unter anderem folgendes (weitere Prüfungen werden hier anhand von Beispielen erklärt):\n Es gab keine Interaktion mit dem Mock/Spy Es gab eine Interaktion mit dem Mock/Spy Es gab eine gewisse Anzahl an Interaktionen mit dem Mock/Spy Es gab mindestens eine gewisse Anzahl an Interaktionen mit dem Mock/Spy Es gab nicht mehr als eine gewisse Anzahl an Interaktionen mit dem Mock/Spy  Interaktion in diesem Sinn kann entweder eine Interaktion mit dem Objekt oder mit einer seiner Methoden sein.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  @RunWith(MockitoJUnitRunner.class) public class MyUnitTest { @Mock private List\u003cString\u003e mockedList; // eine Mock-Liste, mit Mockitos-Standardimplementierung für alle Methoden  @Spy private List\u003cString\u003e spiedList; // ein Spy über eine Liste.  public void testSpiedList() { spiedList.add(\"one\"); // hier wird die \"echte\" add Methode einer Liste aufgerufen!  Mockito.verify(spyList).add(\"one\"); // prüfe, ob die \"add\" Methode mit dem Parameter \"one\" auf dem spyList aufgerufen wurde  Mockito.verify(spiedList, never()).size(); // prüfe, ob die size() Methode nie aufgerufen wurde  spiedList.clear(); spiedList.clear(); Mockito.verify(spiedList, times(2)).clear(); // prüfe, ob die clear() Methode genau 2 Mal aufgerufen wurde  } public void testMockedList() { Mockito.verifyNoInteractions(mockedList); // bis hier gab es keine Interaktionen mit dem mockedList Objekt  mockedList.size(); mockedList.size(); mockedList.size(); mockedList.size(); verify(mockedList, atLeast(1)).size(); // prüfe, ob die size() Methode mindestens einmal aufgerufen wurde  verify(mockedList, atMost(5)).size(); // prüfe, ob die size() Methode nicht mehr als 5 Mal aufgerufen wurde  } }    Test Driven Development (TDD) Test Driven Development (TDD) (Testgetriebene Entwicklung) ist ein Softwareentwicklungsansatz, bei dem ein Test geschrieben wird, bevor der Code geschrieben wird. Sobald der neue Code den Test besteht, wird er auf einen akzeptablen Standard umgestellt.\nTDD stellt sicher, dass der Quellcode gründlich getestet wird und zu modularisiertem, flexiblem und erweiterbarem Code führt. Es konzentriert sich darauf, nur den Code zu schreiben, der notwendig ist, um Tests zu bestehen, wodurch das Design einfach und klar wird.\nMit TDD kann der Programmierer beim Schreiben von Software kleine Schritte unternehmen.\nDer Test wird vor dem Testen der Funktionalität geschrieben und stellt sicher, dass die Anwendung für die Testbarkeit geeignet ist, erst danach wird die Funktionalität implementiert. Dies wird als „Rot-Grün-Refaktor“ bezeichnet, wobei Rot bedeutet, fehlgeschlagen zu sein, und Grün zeigt einen erfolgreichen Durchlauf an. Diese Schritte werden dann wiederholt.\nSchritte eines test gesteuerten Entwicklungszyklus Der test-gesteuerte Entwicklungszyklus besteht aus folgenden, sich immer wiederholenden, Schritten:\n Hinzufügen eines Tests, der fehlschlägt: Jedes neue Feature in TDD beginnt mit einem Test, der nach seiner Implementation fehlschlagen muss, bevor die Features implementiert werden. Code schreiben und damit den Test “begrünen”: Es wird nur soviel Code geschrieben, wie zum “Begrünen” des Tests nötig ist - nicht mehr! (alle bisherigen Tests müssen weiterhin erfolgreich durchlaufen!!) Code verbessern, ohne dabei die Funktionalität zu verändern (Refactor): Code bereinigen (z.B. das Entfernen von Duplikaten, kleinere Methoden usw.) und auf “Clean Code” Standard bringen  TDD Walkthrough In diesem Walkthrough wird der TDD Entwicklungszyklus anhand eines Beispiels erläutert.\nIn diesem Beispiel geht es darum eine Klasse zu schreiben, welche ein Tier modelliert. Das Tier soll uns informieren, ob es Hunger hat oder nicht.\nHinweis im Beispielcode, wird folgendes Namensschema für Tests verwendet:\n1 2 3  public void given_when_then() { ... }   Wobei:\n given die Ausgangslage definiert (z.B. newAnimal oder animalAte) when ist der Name der Methode, welche getestet wird (z.B. isHungry) then ist das Ergebnis, welche erwartet wird (z.B. returnTrue oder returnFalse)  Schritt 1: Grundgerüst erstellen Es wird nur die Klasse erstellt, welche dann getestet werden soll:\n1 2  public class Animal { }   Schritt 2: Fehlschlagender Test schreiben 1 2 3 4 5 6 7  public class AnimalTest { @Test public void newAnimal_isHungry_returnTrue() { Animal myAnimal = new Animal(); assertTrue(myAnimal.isHungry()); } }   Zu diesem Zeitpunkt existiert die Methode “isHungry” nicht (Kompilierfehler) und natürlich gibt sie kein “true” zurück. Im nächsten Schritt wird die Methode hinzugefügt und der Test “begrünt”.\nSchritt 3: Test “begrünen” 1 2 3 4 5  public class Animal { public boolean isHungry() { return true; } }   Der Test, welcher vorher geschrieben wurde, kompiliert nun und kann erfolgreich durchlaufen werden. Somit ist dieser Zyklus beendet (es gibt noch nichts, was refactored werden soll)\nSchritt 4: Neuer, fehlschlagender Test schreiben 1 2 3 4 5 6 7 8 9 10 11 12 13 14  public class AnimalTest { @Test // Dieser Test ist nun grün...  public void newAnimal_isHungry_returnTrue() { Animal myAnimal = new Animal(); assertTrue(myAnimal.isHungry()); } @Test public void animalAte_isHungry_returnFalse() { Animal myAnimal = new Animal(); animal.eat(); // Kompilierfehler, da es diese Methode noch nicht gibt  assertFalse(myAnimal.isHungry()); } }   Schritt 5: zweiter Test “begrünen”, ohne den ersten Test “kaputt” zu machen In diesem Schritt finden wir heraus, dass wir einen Hunger-Zustand für unser Tier haben müssen, welcher sich ändert, wenn das Tier gefressen hat:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  public class Animal { private boolean isHungry = true; // müssen wir hier so setzen, damit der erste Test noch funktioniert!  public boolean isHungry() { if (isHungry) { return true; } else { return false; } } public void eat() { isHungry = false; } }   Nach diesem Schritt kompiliert der Test wieder erfolgreich und beide Tests werden erfolgreich durchlaufen.\nSchritt 6: Refactor Unser Code kann nun eleganter geschrieben werden, ohne dabei die Funktionalität zu ändern:\n1 2 3 4 5 6 7 8 9 10 11  public class Animal { private boolean isHungry = true; public boolean isHungry() { return isHungry; // if-else ersetzt, da nicht nötig  } public void eat() { isHungry = false; } }   Somit ist auch dieser Zyklus beendet.\nDer code wird so stetig weiterentwickelt und neue Funktionalitäten werden auf diese Weise Schritt für Schritt und getestet hinzugefügt. Dabei werden die bereits bestehenden Funktionalitäten durch die bisherigen Tests vor ungewollten Änderungen geschützt.\n","categories":"","description":"Modul #J4\n","excerpt":"Modul #J4\n","ref":"/docs/java/java-testing/","tags":"","title":"Testing"},{"body":"Ziele  Du weisst, wie du in JavaScript bei Klassen und Funktionen eine Beschreibung hinzufügen kannst, die dir deine Entwicklungsumgebung anzeigt, wenn du mittels Auto-Completion diese Variable auswählst. Du weisst, wie du in JavaScript eine Typ-Angabe machen kannst (die aber zur Laufzeit nichts tut).  Basics In TypeScript kannst du jeder Variable einen Typ, jeder Funktion einen Rückgabewert zuweisen. Dies kannst du in JavaScript nicht so einfach.\nTrotzdem kannst du dank dem JSDoc-Projekt (https://jsdoc.app/about-getting-started.html) Typ-Angaben machen, damit deine Entwicklungsumbegung reklamiert, wenn z.B. in einer Funktion ein Wert eines falschen Types übergeben wird.\nIn nächsten Beispiel siehst du, wie du in einer Funktion die Typen spezifizieren kannst:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  /** * Diese Funktion leitet die Argumente dem Konstruktor der Klasse `Person` weiter. * @param {string} name Der Name der Person * @param {Object} namedArgs (Eigentlich unnötig, wird aber als Label für Referenz auf die named Parameter benötigt) * @param {number} [namedArgs.age] Alter * @param {string} [namedArgs.gender] Geschlecht, darf irgend ein String sein. * @returns {Person} Ein Personen-Objekt mit den übergebenen Werten. */ function createPerson(name, { age = undefined, gender = undefined }) { return new Person(name, { age: age, gender: gender, }) }   Deine Entwicklungsumgebung könnte diese Informationen nun auch anzeigen:\nTags Im vorherigen JSDoc wurden viele Tags verwendet. Hier eine Übersicht zu den wichtigsten:\n @param: Damit wird ein Parameter beschrieben @returns: Damit wird der Rückgabewert beschrieben {number}: Das ist eine Typangabe. Hier musste das Argument eine Zahl sein. [namedArgs.gender]: Die eckigen Klammern spezifizieren das Argument als optional (nullable). Ansonsten sollten die Argument nicht den Wert undefined oder null haben.  Eine Auflistung von JSDoc-Tags findest du auch hier: https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html\nFehler anzeigen, wenn Typen falsch sind In VS Code gibt es die Möglichkeit, dass die IDE reklamiert, wenn du Werte des falschen Typs übergibst.\nUm hiervon Gebrauch zu machen, kann im Projekt-Verzeichnis eine jsconfig.json-Datei angelegt werden. Folgende Konfiguration könnte für Browser-Anwendungen Sinn ergeben, wenn sich die JS-Dateinen im Ordner “${workspaceFolder}/static/js/” (nur ein Beispiel, kann natürlich auch etwas anderes Sein) befinden:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  { \"compilerOptions\": { \"module\": \"commonjs\", \"target\": \"es6\", \"baseUrl\": \".\", \"checkJs\": true, \"importHelpers\": true, \"lib\": [ \"DOM\", \"ES2021\", \"DOM.Iterable\" ] }, \"exclude\": [ \"node_modules\" ], \"include\": [ \"static/js/*\" ] }   Dank dieser Konfiguration würde dir VS Code nun einen Fehler anzeigen, wenn du statt einem string eine number übergeben würdest:\n","categories":"","description":"Funktionen mit einer Beschreibung versehen, die bei Vorschlägen angezeigt wird.\n","excerpt":"Funktionen mit einer Beschreibung versehen, die bei Vorschlägen …","ref":"/docs/web/javascript/10_jsdoc/","tags":"","title":"JSDoc"},{"body":"Was ist CSS? Nun haben wir gelernt, was HTML ist, und wie es angewendet werden kann. Wie euch wahrscheinlich bereits aufgefallen ist, sieht pures HTML jedoch nicht besonders schön aus.\nUnd genau da kommt CSS (Cascading Style Sheets) ins Spiel. CSS ist da, um unsere HTML-Elemente zu stylen, wodurch wir unser gewünschtes Design gestalten können.\nDabei gibt es verschiedene Wege CSS zu schreiben und auch dies dann in die Webseite einzubinden.\n","categories":"","description":"Einführung ins CSS.\n","excerpt":"Einführung ins CSS.\n","ref":"/docs/web/html_css/10_css_intro/","tags":"","title":"CSS"},{"body":"Ein neues Projekt erstellen Du beginnst mit der Erstellung einer ersten Anwendung mithilfe der Angular CLI. Im Laufe dieses Tutorials wirst du diese Startanwendung modifizieren und erweitern, um die Anwendung Tour of Heroes zu erstellen.\nIn diesem Teil des Tutorials wirst du Folgendes tun:\n Richte deine Umgebung ein. Erstelle einen neuen Arbeitsbereich und ein erstes Anwendungsprojekt. Stelle die Anwendung bereit. Nimm Änderungen an der Anwendung vor.   Die Beispielanwendung, die auf dieser Seite beschrieben wird, findest du unter dieser Seite.\n Richten deine Umgebung ein Um Ihre Entwicklungsumgebung einzurichten, folge den Anweisungen in Local Environment Setup.\nErstelle einen neuen Arbeitsbereich und eine erste Anwendung Du entwickelst Anwendungen im Kontext eines Angular-Workspace. Ein Arbeitsbereich enthält die Dateien für ein oder mehrere Projekte. Ein Projekt ist eine Gruppe von Dateien, die eine Anwendung oder eine Bibliothek bilden. Für dieses Tutorial wirst du einen neuen Arbeitsbereich erstellen.\nSo erstellst du einen neuen Arbeitsbereich und ein erstes Anwendungsprojekt:\n Stelle sicher, dass du dich nicht bereits in einem Angular-Arbeitsbereich-Ordner befindest. Wenn du beispielsweise zuvor den Arbeitsbereich Erste Schritte erstellt hast, wechsle in den übergeordneten Ordner dieses Ordners. Führe den CLI-Befehl ng new aus und gib den Namen angular-tour-of-heroes ein, wie hier gezeigt:  1  ng new angular-tour-of-heroes   Der Befehl “ng new” fordert dich auf, Informationen zu den Funktionen einzugeben, die in das ursprüngliche Anwendungsprojekt aufgenommen werden sollen. Akzeptiere die Standardeinstellungen, indem du die Enter- oder Return-Taste drückst.  Die Angular-CLI installiert die notwendigen Angular-“npm”-Pakete und andere Abhängigkeiten. Dies kann ein paar Minuten dauern.\nAußerdem werden die folgenden Dateien für den Arbeitsbereich und das Starterprojekt erstellt:\n Einen neuen Arbeitsbereich mit einem Stammordner namens “angular-tour-of-heroes”. Ein erstes Skelettprojekt im Unterordner src/app. Zugehörige Konfigurationsdateien.  Das anfängliche App-Projekt enthält eine einfache Willkommensanwendung, die sofort ausgeführt werden kann.\nServe the application Wechsle in das Verzeichnis workspace und starte die Anwendung.\n1 2  cd angular-tour-of-heroes ng serve --open    Der Befehl ng serve baut die App, startet den Entwicklungsserver, überwacht die Quelldateien und baut die Anwendung neu auf, wenn du Änderungen an diesen Dateien vornimmst.\nDas --open Flag öffnet einen Browser auf http://localhost:4200/.\n Sie sollten die Anwendung in Ihrem Browser laufen sehen.\nAngular-Komponenten Die Seite, die du siehst, ist die Anwendungsshell. Die Shell wird von einer Angular Komponente namens AppComponent gesteuert.\nKomponenten sind die grundlegenden Bausteine von Angular-Anwendungen. Sie zeigen Daten auf dem Bildschirm an, warten auf Benutzereingaben und führen Aktionen basierend auf diesen Eingaben aus.\nÄnderungen an der Anwendung vornehmen Öffne das Projekt in deinem bevorzugten Editor oder IDE und navigiere zum Ordner src/app, um einige Änderungen vorzunehmen.\nDu wirst die Implementierung der Shell AppComponent über drei Dateien verteilt finden:\n app.component.ts der Code der Komponentenklasse, geschrieben in TypeScript. app.component.html das Komponententemplate, geschrieben in HTML. app.component.css die privaten CSS-Stile der Komponente.  Ändern Sie den Titel der Anwendung Öffne die Klassendatei der Komponente (app.component.ts) und ändere den Wert der Eigenschaft title in ‘Tour of Heroes’.\n1  title = 'Tour of Heroes';   Öffne die Komponententemplatendatei (app.component.html) und lösche die von der Angular CLI generierte Standardtemplate. Ersetze es durch die folgende HTML-Zeile.\n1  \u003ch1\u003e{{title}}\u003c/h1\u003e   Die doppelten geschweiften Klammern sind Angulars Syntax für die Interpolationsbindung. Diese Interpolationsbindung stellt den Eigenschaftswert title der Komponente innerhalb des HTML-Header-Tags.\nDer Browser aktualisiert sich und zeigt den neuen Anwendungstitel an.\nHinzufügen von Anwendungsstilen Die meisten Anwendungen streben ein einheitliches Aussehen in der gesamten Anwendung an. Das CLI generiert zu diesem Zweck eine leere styles.css. Lege dort deine anwendungsweiten Stile ab.\nÖffne src/styles.css und füge den folgenden Code in die Datei ein.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  /* Application-wide Styles */ h1 { color: #369; font-family: Arial, Helvetica, sans-serif; font-size: 250%; } h2, h3 { color: #444; font-family: Arial, Helvetica, sans-serif; font-weight: lighter; } body { margin: 2em; } body, input[type=\"text\"], button { color: #333; font-family: Cambria, Georgia, serif; } /* everywhere else */ * { font-family: Arial, Helvetica, sans-serif; }   Abschliessende Überprüfung des Codes Hier sind die auf dieser Seite besprochenen Codedateien.\n src/app/app.components.ts  1 2 3 4 5 6 7 8 9 10  import { Component } from '@angular/core'; @Component({ selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css'] }) export class AppComponent { title = 'Tour of Heroes'; }   src/app/app.components.html  1  \u003ch1\u003e{{title}}\u003c/h1\u003e   src/styles.css  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  /* Application-wide Styles */ h1 { color: #369; font-family: Arial, Helvetica, sans-serif; font-size: 250%; } h2, h3 { color: #444; font-family: Arial, Helvetica, sans-serif; font-weight: lighter; } body { margin: 2em; } body, input[type=\"text\"], button { color: #333; font-family: Cambria, Georgia, serif; } /* everywhere else */ * { font-family: Arial, Helvetica, sans-serif; }   Zusammenfassung  Du hast die erste Anwendungsstruktur mit dem Angular CLI erstellt. Du hast gelernt, dass Angular-Komponenten Daten anzeigen. Du hast die doppelten geschweiften Klammern der Interpolation verwendet, um den Titel der Anwendung anzuzeigen.  ","categories":"","description":"Sie beginnen mit der Erstellung einer ersten Anwendung mithilfe der Angular CLI. Im Laufe dieses Tutorials werden Sie diese Startanwendung modifizieren und erweitern, um die Anwendung Tour of Heroes zu erstellen.\n","excerpt":"Sie beginnen mit der Erstellung einer ersten Anwendung mithilfe der …","ref":"/docs/web/angular/05_1_tour_of_heroes/","tags":"","title":"Projekt aufsetzen"},{"body":"Ziele  Ich kenne die Schlüsselwörter try, catch, finally, throw und throws Ich weiss was “Unchecked” und “Checked” Exceptions sind Ich kann auftretende Exceptions abhandeln Ich kann eigene Exceptions definieren und anwenden Ich kenne Multicatch und Try-With-Resources und kann die beiden Konstrukte anwenden Ich kenne die beiden Interfaces AutoCloseable und Closeable  Voraussetzungen  Gute Grundlagenkenntnisse von Java-Anwendungen   Theorie / Einleitung In jeder Applikation kann es zu erwarteten oder unerwarteten Fehlern kommen. In Java werden diese Fehler durch den Bereich Exception Handling abgedeckt. Im Exception Handling gilt es, durch gezieltes Abhandeln von auftretenden Exceptions, Abstürze der Anwendung zu verhindern. Jeder Software-Entwickler muss sich bewusst sein, dass nicht behandelte Exceptions eine Anwendung jederzeit beenden können.\nIn Java unterscheidet man zwischen zwei Arten von Fehlern:\n Error: das sind nicht reparierbare Laufzeitfehler oder ein Hardware-Problem, welche zum Absturz des Programms führen. Exception: das sind Fehler oder nicht geplante Ereignisse, welche während der Ausführung eines Programms vorkommen und dessen normalen Ablauf stören.  Eine Java-Applikation sollte nicht versuchen Errors zu “fangen”, da die meisten Fehler dieser Art wegen abnormalen Bedingungen (wie z.B. nicht genügend Speicher) auftreten und unter normalen Bedingungen nicht behoben werden können.\nExceptions sind hingegen unerwartete Fehler, auf die das Programm reagieren muss.\nInnerhalb des Java Exception Handling unterscheiden wir zwei Arten von Exceptions:\n Unchecked Exceptions: das sind Laufzeitfehler und sie werden durch den Compiler nicht erkannt. Checked Exceptions: das sind Fehler, welche vom Compiler zum Zeitpunkt der Kompilierung erkannt werden.  Unchecked Exceptions sind oft Fehler, welche bei der Implementation übersehen werden. Der häufigste Laufzeitfehler ist die NullPointerException. Diese kann erst zur Laufzeit auftreten, da nur zur Laufzeit Objekte erzeugt werden und damit eine Referenz überhaupt null sein kann.\nDie einzige Möglichkeit Laufzeitfehler abzuhandeln ist “Safe Programming”. Das heisst, dass wir während der Implementation Prüfungen und sog. “Guards” im Code einbauen (z.B. prüfen, ob eine Referenz nicht null ist bevor wir darauf zugreifen) um sicherzustellen, dass solche Situationen zur Laufzeit nicht auftreten.\nChecked Exceptions müssen zum Zeitpunkt der Kompilierung entweder am Ort des Auftretens abgehandelt werden oder sie werden an das Objekt weitergereicht, welches die entsprechende Methode aufgerufen hat. Damit wird auch die Verantwortung die Exception abzuhandeln an den Aufrufer weitergegeben.\nDazu ein kleines Beispiel:\n1 2 3 4 5  public static void main(String[] args) { PhoneBook phoneBook = new PhoneBook(); Person person = phoneBook.findByPhoneNumber(\"079 654 32 10\"); System.out.println(person.getName()); }   Ohne die Implementation der Methode findByPhoneNumber zu kennen, muss ein Software-Entwickler an dieser Stelle das zurückgelieferte Objekt vom Typ Person zuerst auf null prüfen.\nSchauen wir uns also die Implementation dieser Methode etwas genauer an:\n1 2 3 4 5 6 7 8 9 10 11 12  public class PhoneBook { private List\u003cPerson\u003e entries = new ArrayList\u003c\u003e(); public Person findByPhoneNumber(String number) { for (Person p: this.entries) { if (p.getPhoneNumber().equals(number)) { return p; } } return null; } }   Wie (vielleicht) erwartet liefert die Methode null zurück, falls kein Eintrag mit der gesuchten Nummer gefunden wird. Dies führt in der Main-Methode im Codeblock oben auf der letzten Zeile zu einer NullPointerException, da die Referenz der Person auf null zeigt. Abhilfe schafft hier ein einfaches If-Statement:\n1 2 3 4 5 6 7  public static void main(String[] args) { AddressBook addressBook = new AddressBook(); Person person = addressBook.findByPhoneNumber(\"079 654 32 10\"); if (person != null) { System.out.println(person.getName()); } }   Der Laufzeitfehler kann nun nicht mehr auftreten. Es stellt sich nun die Frage, ob wir mit dieser Lösung zufrieden sein können.\nIm Prinzip müssten wir zumindest informiert werden, wenn keine Person mit dieser Nummer gefunden wird. Eine Möglichkeit, dies zu tun ist mittel eines Else-Statement:\n1 2 3 4 5 6 7 8 9  public static void main(String[] args) { AddressBook addressBook = new AddressBook(); Person person = addressBook.findByPhoneNumber(\"079 654 32 10\"); if (person == null) { System.out.println(person.getName()); } else { System.out.println(\"Es wurde keine Person mit dieser Nummer gefunden!\"); } }   Eine andere Lösung könnte sein das Null-Object Pattern oder auch ein Optional-Objekt zu verwenden und damit ein gültiges Objekt anstelle von null zurückzuliefern.\n try / catch / finally Um eine Checked Exception abzuhandeln, muss der Block (welcher die Exception erzeugt) innerhalb eines try-Blocks angelegt werden. Der abzuhandelnde Exception-Typ wird dabei in den catch-Block geschrieben:\n1 2 3 4 5  try { // Code, welcher eine IOException werfen könnte } catch (IOException e) { // Code für die Abhandlung der IOException }   Ein solches Statement kann beliebig viele catch-Blöcke aufweisen:\n1 2 3 4 5 6 7 8  try { int[] array = new int[2]; array[3] = 30 / 0; } catch (ArithmeticException e) { // Code für die Abhandlung der ArithmeticException } catch (ArrayIndexOutOfBoundsException e) { // Code für die Abhandlung der ArrayIndexOutOfBoundsException }   Bei mehreren catch-Blöcken muss die spezifischste Exception stets zuoberst stehen. Je weiter unten der catch-Block steht, desto genereller wird die Exception, die abgefangen werden soll. Der Grund dafür ist, dass alle Checked Exceptions von der Klasse Exception abgeleitet sind. Steht eine allgemeinere Exception weiter oben, so wird der catch-Block der spezifischeren Exception weiter unten nicht mehr erreichbar sein.\nAn jeden try-Block (ob mit oder ohne catch-Block) kann zusätzlich ein finally-Block angehängt werden. Der finally-Block wird nach der Abhandlung der Exception ausgeführt.\nWenn kein Exception aufgetreten ist, wird der Code im finally-Block direkt nach dem Code im try-Block ausgeführt.\n1 2 3 4 5 6 7  try { // Code, welcher eine IOException werfen könnte } catch (IOException e) { // Code für die Abhandlung der IOException } finally { // Code, welcher nach der Abhandlung der Exception ausgeführt werden soll }   Wie oben erwähnt, kann der catch-Block weggelassen werden:\n1 2 3 4 5  try { // Code, welcher eine beliebige Exception werfen könnte } finally { // Code, welcher nach der Abhandlung der Exception ausgeführt werden soll }   Vorsicht ist geboten bei return-Anweisungen innerhalb von catch- oder finally-Blöcken. Da der finally-Block immer zuletzt ausgeführt wird, ist das Statement in diesem Block auch massgebend für die Funktionalität.\n throw / throws Wie bereits weiter oben erwähnt, muss eine Exception nicht immer dort abgehandelt werden, wo sie gerade auftreten kann. Wenn entschieden wird, die Abhandlung in andere Klassen zu verlagern, so kann mit dem Schlüsselwort throws angegeben werden, dass die aufrufende Komponente die Exception abhandeln muss.\nDazu ein kurzes Beispiel:\n1 2 3  public class EntryForbiddenException extends Exception { }   1 2 3 4 5 6 7 8  public class Saloon { public void checkAge(int age) throws EntryForbiddenException { if (age \u003c 18) { throw new EntryForbiddenException(); } // ...  } }   1 2 3 4 5 6 7 8 9 10  public class Main { public static void main(String[] args) { Saloon saloon = new Saloon(); try { saloon.checkAge(15); } catch (EntryForbiddenException e) { // ...  } } }   Wie wir sehen, wird die Abhandlung in die Main-Methode verlagert. Die Weitergabe von Exceptions kann über beliebig viele Stufen erfolgen.\nWird die Exception jedoch von der “obersten” Stufe (in diesem Fall die Main-Methode) nicht abgehandelt, so wird die Anwendung mit der entsprechenden Exception beendet. Dies passiert, weil niemand die Exception abgehandelt hat.\n Umwandlung Laufzeitfehler in Checked Exception Mit der Lösung aus dem Beispiel weiter oben können wir nicht wirklich zufrieden sein.\nAnstatt den Rückgabewert der Methode findByPhoneNumber auf null zu prüfen, wählen wir nun einen anderen Ansatz:\nWir erweitern die Anwendung, sodass die Methode als Rückgabewert keine null-Werte mehr liefert.\nDa wir aber durch den Compiler gezwungen werden einen Rückgabewert zu definieren, bleibt uns nur noch die Möglichkeit übrig eine Exception zu werfen. Zu diesem Zweck definieren wir zuerst einmal eine entsprechende Exception:\n1 2 3  public class PersonNotFoundException extends Exception { }   Diese Exception wird nun an der entsprechenden Stelle im Sourcecode geworfen. Die Methode erhält zudem noch eine Erweiterung mit dem Schlüsselwort throws:\n1 2 3 4 5 6 7 8 9 10 11 12  public class PhoneBook { private List\u003cPerson\u003e entries = new ArrayList\u003c\u003e(); public Person findByPhoneNumber(String number) throws PersonNotFoundException { for (Person p: this.entries) { if (p.getPhoneNumber().equals(number)) { return p; } } throw new PersonNotFoundException(); } }   Beim Aufruf der Methode sind wir nun gezwungen, die Exception abzuhandeln:\n1 2 3 4 5 6 7 8 9  public static void main(String[] args) { AddressBook addressBook = new AddressBook(); try { Person person = addressBook.findByPhoneNumber(\"079 654 32 10\");\tSystem.out.println(person.getName()); } catch (PersonNotFoundException e) { System.out.println(\"Es wurde keine Person mit dieser Nummer gefunden!\"); } }   Aus dem ursprünglichen Laufzeitfehler ist nun eine abgehandelte Exception geworden. Die Implementation vermeidet, wo immer möglich, die Rückgabe von null-Werten.\n Multi-Catch Seit Java 7 gibt es die Möglichkeit für einen sogenannten Multi-Catch.\nSchauen wir uns das folgende Beispiel an:\nOhne Multi-Catch 1 2 3 4 5 6 7 8 9 10 11 12 13  public static void main(String[] args) { Scanner scn = new Scanner(System.in); try { int n = Integer.parseInt(scn.nextLine()); if (99%n == 0) { System.out.println(n + \" is a factor of 99\"); } } catch (ArithmeticException ex) { System.out.println(\"Arithmetic Exception \" + ex); } catch (NumberFormatException ex) { System.out.println(\"Number Format Exception \" + ex); } }   Mit Multi-Catch 1 2 3 4 5 6 7 8 9 10 11  public static void main(String[] args) { Scanner scn = new Scanner(System.in); try { int n = Integer.parseInt(scn.nextLine()); if (99%n == 0) { System.out.println(n + \" is a factor of 99\"); } } catch (ArithmeticException | NumberFormatException ex) { System.out.println(\"Exception \" + ex); } }   Die beiden Exceptions werden in einem catch-Block zusammengefasst. Die Exceptions innerhalb eines Multi-Catch dürfen nicht in einer Vererbungsbeziehung zueinander stehen. Der Basistyp muss also unterschiedlich sein.\n Try-With-Resources Ebenfalls seit Java 7 gibt es die Möglichkeit für automatisches Ressourcen-Management.\nBetrachten wir dazu zuerst ein Beispiel ohne automatisches Ressourcen-Management:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  public static String readFirstLine(String path) { BufferedReader br = null; try { br = new BufferedReader(new FileReader(path)); return br.readLine(); } catch (IOException e) { // handle or rethrow  } finally { try { if (br != null) { br.close(); } } catch (IOException e) { // ignore  } } return \"\"; }   Der finally-Block ist notwendig, um die verwendete Ressource des Buffered-Readers zu schliessen.\nDa beim Schliessen aber eine IOException auftreten kann benötigen wir innerhalb des finally-Blocks einen zusätzlichen try-catch-Block.\nBetrachten wir nun das gleiche Beispiel mit automatischem Ressourcen-Management:\n1 2 3 4 5 6 7 8  public static String readFirstLine(String path) { try (FileReader fr = new FileReader(path); BufferedReader br = new BufferedReader(fr)) { return br.readLine(); } catch (IOException e) { // handle or rethrow  } return \"\"; }   Wie wir sehen fällt der finally-Block zum Schliessen der Ressourcen komplett weg.\nDie beiden Ressourcen FileReader und BufferedReader werden automatisch geschlossen. Dies geschieht im Hintergrund über die Methode close, welche vom Interface AutoCloseable zur Verfügung gestellt wird.\nIn einem try-with-resources Statement dürfen also nur Objekte vorliegen, welches das genannte Interface implementieren.\nDas Closeable-Interface mit der gleichen Funktion stellt dabei die Abwärtskompatibilität zu älteren Java-Versionen sicher.\nGrundsätzlich soll das Closeable-Interface für IO Streams verwendet werden, da es mit IOExceptions arbeitet.\nDas Schliessen der Ressourcen hat stets die Reihenfolge von hinten nach vorne.\nIn unserem Beispiel wird also zuerst der BufferedReader geschlossen und danach der FileReader.\nDie Verkettung von Ressourcen innerhalb eines try-with-resources Statements ist zu vermeiden. Besser sind separate Deklarationen wie oben gezeigt.\n","categories":"","description":"Modul #J5 - Exception Handling\n","excerpt":"Modul #J5 - Exception Handling\n","ref":"/docs/java/java-exception_handling/","tags":"","title":"Exception Handling"},{"body":"Ziele  Du kennst Alternativen zu console.log(...).  Basics Das console.log(...) in JavaScript ist das Äquivalent zu System.out.println(...) in Java, das Console.WriteLine(...) in C#, das print(...) in Python oder das puts ... in Ruby.\nEs gibt aber noch sehr viele Alternativen zu console.log(...), die sehr nützlich sind.\nZ.B. kannst du den Logs noch eine Kategorie zuordnen und werden in unterschiedlichen Farben geloggt:\n console.info(...) (neutral) console.warn(...) (gelb/orange/grün) console.error(...) (rot) console.debug(...) (blau, aber nur sichtbar, wenn “Alle [Log-]Ebenen” in der Konsole angezeigt werden)  Nie mehr Counter-Variablen für Debugging-Zwecke!! Wenn du z.B. feststellen möchtest, wie oft etwas aufgerufen wird, hilft dir vielleicht console.count(\"\") weiter:\n1 2  console.count(\"alarm\"); \u003e\u003e\u003e alarm: 3   Objekte loggen Wenn du Objekte mit ihren Attributen und Werten loggen möchtest, dann bietet sich die console.dir(...)-Funktion an:\n1 2 3 4 5 6 7  console.dir(person); \u003e\u003e\u003e Person { name: 'Confused Nick Young', age: undefined, gender: 'male', lovesJavaScript: true }   Tabelle loggen 1 2 3 4 5 6 7 8 9 10  console.table( [person1, person2] ) \u003e\u003e\u003e ┌─────────┬────────────────────────┬───────────┬───────────┬─────────────────┐ │ (index) │ name │ age │ gender │ lovesJavaScript │ ├─────────┼────────────────────────┼───────────┼───────────┼─────────────────┤ │ 0 │ 'Confused Nick Young' │ undefined │ 'male' │ false │ │ 1 │'Tuxedo Winnie the Pooh'│ undefined │ undefined │ true │ └─────────┴────────────────────────┴───────────┴───────────┴─────────────────┘   Log stylen Mit einem %c im Log kannst du den Text stylen:\n1  console.log('%cHello World', 'color: blue; font-weight: bolder; background-color: white; border-radius: 2em; padding: 1em;')   Falsche Werte loggen Als Entwickler bist du informiert werden, wenn irgendwo falsche Werte zurückgegeben wurden (z.B. Rückgabe-Wert einer Funktion).\nHierfür bietet sich console.assert(...) an:\n1 2 3 4 5 6 7 8 9 10 11 12  let connectionToDatabase = connectToDatabase(); // returns `null` if connection fails. console.assert( connectionToDatabase != null, { connectionToDatabase: connectionToDatabase, errorMsg: \"Es konnte keine Verbindung zur Datenbank hergestellt werden. ¯\\_(ツ)_/¯\" }); \u003e\u003e\u003e Assertionsfehler: { connectionToDatabase: null, errorMsg: 'Es konnte keine Verbindung zur Datenbank hergestellt werden. ¯_(ツ)_/¯' }   ","categories":"","description":"Die JavaScript-Konsole bietet viele hilfreiche Tools an, um Text zu loggen. Diese Möglichkeiten schauen wir uns hier an.\n","excerpt":"Die JavaScript-Konsole bietet viele hilfreiche Tools an, um Text zu …","ref":"/docs/web/javascript/11_console.logs/","tags":"","title":"Advanced console.log(...)'s"},{"body":"Wie funktioniert CSS? Um CSS anwenden zu können, müssen wir das Grundprinzip verstehen:\nMit CSS werden selektiv HTML-Elemente ausgewählt und deren Styling angepasst. Hierfür gibt es verschiedene Möglichkeiten, welche wir im Verlaufe des Kurses kennenlernen werden.\nCSS verfolgt dabei die folgende Syntax:\n1 2 3 4  p { color: blue; background-color: red; }    Die Zeichenfolge vor den geschweiften Klammern ist der sogenannte Selektor (Englisch: Selector). Er definiert, auf welche Elemente das Styling angewendet werden soll. In diesem Fall würde das Styling auf alle Paragraphen angewendet werden. Die Zeilen innerhalb der geschweiften Klammern, definieren was für ein Styling angwendet werden soll. Beim gezeigten Beispiel würde die Textfarbe auf blau eingestellt werden und die Hintergrundfarbe rot.  Wie kann ich CSS anwenden? Als nächstes schauen wir an, wie man CSS in eine Webseite (bzw. in ein HTML File) einbinden kann. Dafür schauen wir uns folgende Abschnitte an:\nDirektes einbinden in HTML-Elemente Die wohl schnellste Möglichkeit CSS auf ein HTML-Element anzuwenden, ist, das “style”-Attribut des HTML-Elements anzupassen. Dies würde wie folgt ausschauen:\n1  \u003cp style=\"color: blue; background-color: red\"\u003eHier steht blauer Text auf rotem Hintergrund\u003c/p\u003e   Dabei ist anzumerken, dass sich die Syntax gegenüber der herkömmlichen Syntax (siehe erstes Beispiel) etwas unterscheidet. Einerseits müssen wir den Selektor nicht angeben und andererseits gibt es keine geschweiften Klammern mehr.\nEinbinden über einen Style-Tag Man kann CSS aber auch über einen sogenannten “Style” Tag ins HTML einbinden. Dies sieht wie folgt aus:\n1 2 3 4 5 6 7 8 9 10  \u003chead\u003e ... \u003cstyle\u003e p { color: blue; background-color: red; } \u003c/style\u003e ... \u003c/head\u003e   Hierbei können wir innerhalb des Style-Tags herkömmliches CSS anwenden, wie wir es bereits aus dem ersten Beispiel kennen. Der Style-Tag kann irgendwo (auch verschachtelt) irgendwo im \u003chead\u003e oder \u003cbody\u003e stehen. Wo genau darin ist jedoch nicht wichtig. Best-Practice dafür wäre im \u003chead\u003e nach den \u003cmeta\u003e-Tags.\nEinbinden über ein externes CSS-File Die wohl am weitesten verbreitete Methode CSS in eine Webseite einzubinden ist es, das CSS in ein CSS-File auszulagern und dann im HTML darauf zu verweisen.\nDies kann man wie folgt machen:\nDatei: index.html\n1 2 3 4 5 6 7 8 9 10 11 12 13  \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\" /\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003clink rel=\"stylesheet\" href=\"styles.css\" /\u003e \u003c/head\u003e \u003cbody\u003e \u003cp\u003eHier steht blauer Text auf rotem Hintergrund\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e   Datei: styles.css\n1 2 3 4  p { color: blue; background-color: red }   Der Wichtige Teil des HTML-Codes ist dabei folgender Tag im Head:\n1  \u003clink rel=\"stylesheet\" href=\"styles.css\" /\u003e   Dieser Link-Tag definiert, dass der CSS-Code der Datei mit dem Pfad “styles.css” auf die aktuelle HTML-Datei angwendet werden soll.\nWas gibt es alles für CSS-Styling-Properties? Es gibt unzählige CSS-Properties. Zu viele, um auf jedes detailliert einzugehen. Auf dieser Seite findet ihr eine ganze Reihe CSS-Properties.\nAuf die wichtigsten Properties werden wir jedoch in den nächsten Seiten genauer eingehen.\n","categories":"","description":"Grundlagen der CSS-Sprache.\n","excerpt":"Grundlagen der CSS-Sprache.\n","ref":"/docs/web/html_css/11_css_basics/","tags":"","title":"CSS-Grundlagen"},{"body":" Die Beispielanwendung, die auf dieser Seite beschrieben wird, findest du unter dieser Seite.\n Erstelle die Komponente heroes Erzeuge mit der Angular CLI eine neue Komponente mit dem Namen heroes.\n1  ng generate component heroes   Das CLI erstellt einen neuen Ordner, src/app/heroes/, und generiert die drei Dateien der HeroesComponent zusammen mit einer Testdatei.\nDie Klassendatei HeroesComponent sieht wie folgt aus:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  import { Component, OnInit } from '@angular/core'; @Component({ selector: 'app-heroes', templateUrl: './heroes.component.html', styleUrls: ['./heroes.component.css'] }) export class HeroesComponent implements OnInit { constructor() { } ngOnInit() { } }   Man importiert immer das Component-Symbol aus der Angular-Kernbibliothek und annotieren die Komponentenklasse mit @Component.\n@Component ist eine Decorator-Funktion, die die Angular-Metadaten für die Komponente spezifiziert.\nDas CLI generiert drei Metadaten-Eigenschaften:\n selektor der CSS-Elementselektor der Komponente templateUrl— der Ort der Template-Datei der Komponente. styleUrls— der Speicherort der privaten CSS-Stile der Komponente.  Der CSS-Elementselektor, 'app-heroes', entspricht dem Namen des HTML-Elements, das diese Komponente im Template einer übergeordneten Komponente identifiziert.\nDas ngOnInit() ist ein lifecyle hook. Angular ruft ngOnInit() kurz nach der Erstellung einer Komponente auf. Es ist ein guter Ort, um die Initialisierungslogik zu platzieren.\nDie Komponentenklasse immer export, damit man sie an anderer Stelle import kann … wie im AppModule.\nHinzufügen einer Hero-Eigenschaft Füge der HeroesComponent eine Helden-Eigenschaft für einen Helden namens “Windstorm” hinzu.\nheroes.component.ts (hero property)\n1  hero = 'Windstorm';   Den Helden anzeigen Öffne die Templatedatei “heroes.component.html”. Lösche den von der Angular CLI generierten Standardtext und ersetze ihn durch eine Datenbindung an die neue hero Eigenschaft.\n1  \u003ch2\u003e{{hero}}\u003c/h2\u003e   Die Ansicht HeroesComponent anzeigen Um die HeroesComponent anzuzeigen, müsst du sie zum Template der Shell AppComponent hinzufügen.\nDenke daran, dass app-heroes der Element-Selektor für die HeroesComponent ist. Füge also ein \u003capp-heroes\u003e-Element in die AppComponent-Templatdatei ein, direkt unter dem Titel.\nsrc/app/app.component.html\n1 2  \u003ch2\u003e\u003ch1\u003e{{title}}\u003c/h1\u003e \u003capp-heroes\u003e\u003c/app-heroes\u003e\u003c/h2\u003e   Unter der Annahme, dass der CLI-Befehl ng serve noch ausgeführt wird, sollte der Browser aktualisiert werden und sowohl den Titel der Anwendung als auch den Namen des Helden anzeigen.\nErstellen einer Hero-Interface Ein echter Held ist mehr als nur ein Name.\nErstelle eine Hero-Schnittstelle in einer eigenen Datei im Ordner src/app. Gib ihr die Eigenschaften id und name.\nsrc/app/hero.ts\n1 2 3 4  export interface Hero { id: number; name: string; }   Kehre zur Klasse HeroesComponent zurück und importiere die Schnittstelle Hero.\nRefaktoriere die Eigenschaft hero der Komponente, so dass sie vom Typ Hero ist. Initialisiere sie mit einer id von 1 und dem Namen Windstorm.\nDie überarbeitete Klassendatei HeroesComponent sollte wie folgt aussehen:\nsrc/app/heroes/heroes.component.ts\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  import { Component, OnInit } from '@angular/core'; import { Hero } from '../hero'; @Component({ selector: 'app-heroes', templateUrl: './heroes.component.html', styleUrls: ['./heroes.component.css'] }) export class HeroesComponent implements OnInit { hero: Hero = { id: 1, name: 'Windstorm' }; constructor() { } ngOnInit() { } }   Die Seite wird nicht mehr richtig angezeigt, weil du den Helden von einer Zeichenkette in ein Objekt geändert hast.\nZeige das Hero-Objekt an Aktualisiere die Bindung im Template, um den Namen des Helden anzuzeigen und zeige sowohl id als auch name in einem Detail-Layout wie diesem:\nheroes.component.html (HeroesComponent's template)\n1 2 3  \u003ch2\u003e{{hero.name}} Details\u003c/h2\u003e \u003cdiv\u003e\u003cspan\u003eid: \u003c/span\u003e{{hero.id}}\u003c/div\u003e \u003cdiv\u003e\u003cspan\u003ename: \u003c/span\u003e{{hero.name}}\u003c/div\u003e   Der Browser aktualisiert sich und zeigt die Informationen über den Helden an.\nFormatieren mit der UppercasePipe Ändere die Bindung hero.name wie folgt.\nsrc/app/heroes/heroes.component.html\n1  \u003ch2\u003e{{hero.name | uppercase}} Details\u003c/h2\u003e   Der Browser aktualisiert sich und der Name des Helden wird nun in Großbuchstaben angezeigt.\nDas Wort uppercase in der Interpolationsbindung, direkt nach dem Pipe-Operator ( | ), aktiviert die eingebaute UppercasePipe.\nPipes sind ein guter Weg, um Strings, Währungsbeträge, Daten und andere Anzeigedaten zu formatieren. Angular wird mit mehreren eingebauten Pipes ausgeliefert und du kannst deine eigenen erstellen.\nDen Helden bearbeiten Die Benutzer sollten den Namen des Helden in einem Textfeld “” bearbeiten können.\nDas Textfeld sollte sowohl die Eigenschaft “Name” des Helden anzeigen und diese Eigenschaft während der Eingabe des Benutzers aktualisieren. Das heißt, die Daten fließen von der Komponentenklasse nach draußen auf den Bildschirm und vom Bildschirm zurück zur Klasse.\nUm diesen Datenfluss zu automatisieren, richte eine zweiseitige Datenbindung zwischen dem Formularelement \u003cinput\u003e und der Eigenschaft hero.name ein.\nZwei-Wege-Bindung Überarbeite den Detailbereich im Template HeroesComponent so, dass er wie folgt aussieht:\nsrc/app/heroes/heroes.component.html (HeroesComponent's template)\n1 2 3 4  \u003cdiv\u003e \u003clabel for=\"name\"\u003eHero name: \u003c/label\u003e \u003cinput id=\"name\" [(ngModel)]=\"hero.name\" placeholder=\"name\"\u003e \u003c/div\u003e   [(ngModel)] ist Angulars Syntax für die Zwei-Wege-Datenbindung.\nHier bindet sie die Eigenschaft hero.name an die HTML-Textbox, so dass Daten in beide Richtungen fließen können: von der Eigenschaft hero.name zur Textbox und von der Textbox zurück zum hero.name.\nDas fehlende FormsModule Beachte, dass die Anwendung nicht mehr funktioniert, wenn du [(ngModel)] hinzufügst.\nUm den Fehler zu sehen, öffne die Browser-Entwicklungswerkzeuge und suche in der Konsole nach einer Meldung wie\n1 2  Template parse errors: Can't bind to 'ngModel' since it is not a known property of 'input'.   Obwohl ngModel eine gültige Angular-Direktive ist, ist sie standardmäßig nicht verfügbar.\nSie gehört zum optionalen FormsModule und man muss sich opt-in, um sie zu verwenden.\nAppModule Angular muss wissen, wie die Teile Ihrer Anwendung zusammenpassen und welche anderen Dateien und Bibliotheken die Anwendung benötigt. Diese Informationen werden Metadaten genannt.\nEinige der Metadaten befinden sich in den @Component-Dekoratoren, die du zu deinen Komponentenklassen hinzugefügt hast. Andere wichtige Metadaten befinden sich in @NgModule Dekoratoren.\nDer wichtigste @NgModule Dekorator annotiert die Top-Level AppModule Klasse.\nDas Angular CLI generierte eine AppModule Klasse in src/app/app.module.ts als es das Projekt erstellte. Dies ist der Ort, an dem du das FormsModule einfügst.\nImportiere _FormsModule Öffnen AppModule (app.module.ts) und importiere das Symbol FormsModule aus der Bibliothek @angular/forms.\napp.module.ts (FormsModule symbol import)\n1  import { FormsModule } from '@angular/forms'; // \u003c-- NgModel lives here   Füge dann FormsModule zum @NgModule-Metadaten-Array imports hinzu, das eine Liste der externen Module enthält, die die Anwendung benötigt.\napp.module.ts (@NgModule imports)\n1 2 3 4  imports: [ BrowserModule, FormsModule ],   Wenn der Browser aktualisiert wird, sollte die Anwendung wieder funktionieren. Du kannst den Namen des Helden bearbeiten und sehen, dass die Änderungen sofort in der \u003ch2\u003e oberhalb des Textfeldes angezeigt werden.\nDeklariere HeroesComponent Jede Komponente muss in exakt einem NgModule deklariert werden.\nDu hast die HeroesComponent nicht deklariert. Warum hat die Anwendung dann funktioniert?\nSie funktionierte, weil das Angular CLI HeroesComponent im AppModule deklarierte, als es diese Komponente generierte.\nÖffne src/app/app.module.ts und finde HeroesComponent, das ganz oben importiert wurde.\nsrc/app/app.module.ts\n1  import { HeroesComponent } from './heroes/heroes.component';   Die HeroesComponent wird in dem Array @NgModule.declarations deklariert. src/app/app.module.ts\n1 2 3 4  declarations: [ AppComponent, HeroesComponent ],   Beachte, dass AppModule beide Anwendungskomponenten, AppComponent und HeroesComponent, deklariert.\nAbschließende Überprüfung des Codes Hier sind die auf dieser Seite besprochenen Codedateien.\n src/app/heroes/heroes.component.ts  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  import { Component, OnInit } from '@angular/core'; import { Hero } from '../hero'; @Component({ selector: 'app-heroes', templateUrl: './heroes.component.html', styleUrls: ['./heroes.component.css'] }) export class HeroesComponent implements OnInit { hero: Hero = { id: 1, name: 'Windstorm' }; constructor() { } ngOnInit() { } }   src/app/heroes/heroes.component.html  1 2 3 4 5 6  \u003ch2\u003e{{hero.name | uppercase}} Details\u003c/h2\u003e \u003cdiv\u003e\u003cspan\u003eid: \u003c/span\u003e{{hero.id}}\u003c/div\u003e \u003cdiv\u003e \u003clabel for=\"name\"\u003eHero name: \u003c/label\u003e \u003cinput id=\"name\" [(ngModel)]=\"hero.name\" placeholder=\"name\"\u003e \u003c/div\u003e   src/app/app.module.ts  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  import { BrowserModule } from '@angular/platform-browser'; import { NgModule } from '@angular/core'; import { FormsModule } from '@angular/forms'; // \u003c-- NgModel lives here  import { AppComponent } from './app.component'; import { HeroesComponent } from './heroes/heroes.component'; @NgModule({ declarations: [ AppComponent, HeroesComponent ], imports: [ BrowserModule, FormsModule ], providers: [], bootstrap: [AppComponent] }) export class AppModule { }   src/app/app.component.ts  1 2 3 4 5 6 7 8 9 10  import { Component } from '@angular/core'; @Component({ selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css'] }) export class AppComponent { title = 'Tour of Heroes'; }   src/app/app.component.html  1 2  \u003ch1\u003e{{title}}\u003c/h1\u003e \u003capp-heroes\u003e\u003c/app-heroes\u003e   src/app/hero.ts  1 2 3 4  export interface Hero { id: number; name: string; }   Zusammenfassung  Du hast die CLI verwendet, um eine zweite HeroesComponent zu erstellen. Du hast die HeroesComponent angezeigt, indem du sie der AppComponent-Shell hinzugefügt hast. Du hast die UppercasePipe angewendet, um den Namen zu formatieren. Du hast die Zwei-Wege-Datenbindung mit der ngModel-Direktive benutzt. Du hast etwas über das AppModule gelernt. Du hast das FormsModule in das AppModule importiert, so dass Angular die ngModel-Direktive erkennen und anwenden konnte. Du hast gelernt, wie wichtig es ist, Komponenten im AppModule zu deklarieren und schätzt es, dass die CLI sie für dich deklariert.  ","categories":"","description":"Die Anwendung hat jetzt einen einfachen Titel. Als Nächstes erstellst du eine neue Komponente zur Anzeige von Heldeninformationen und platzierst diese Komponente in der Anwendungsschale.\n","excerpt":"Die Anwendung hat jetzt einen einfachen Titel. Als Nächstes erstellst …","ref":"/docs/web/angular/05_2_editor/","tags":"","title":"Editor"},{"body":"Ziele  Ich kann mit Reflection Informationen zu Klassen, Objekten, Methoden und Attributen zur Laufzeit ermitteln Ich kenne die Vor- und Nachteile von Reflection Ich kenne die Metadaten Class\u003cT\u003e, Field und Method Ich kann mit Reflection eine Methode auf einem Objekt aufrufen Ich kann mit Reflection zur Laufzeit eine Klasse untersuchen Ich kann mit Reflection ein neues Objekt zur Laufzeit erzeugen Ich kenne die Grundlagen von Annotationen Ich kenne die wichtigsten Standard-Annotationen des JDKs Ich kann eigene Annotationen definieren und diese zur Laufzeit auswerten  Voraussetzungen  Fundierte Grundlagenkenntnisse von Java-Anwendungen  Reflection API  Allgemeine Informationen Reflection in Java ist eine Möglichkeit, Informationen über Klassen, Methoden und andere Sprachelemente zu erhalten, ohne diese Elemente während dem Programmieren (also während der Kompilierzeit) zu kennen. Mit Reflection können Klassen, Interfaces, Konstruktoren, Methoden und Felder zur Laufzeit untersucht und auch geändert werden.\nReflection hat die folgenden Einsatzgebiete:\n Erweiterbarkeit: Eine Applikation kann mit Reflection solche Klassen instanziieren, die zum Zeitpunkt der Kompilierung noch gar nicht bekannt waren. Zur Laufzeit benötigen wir dazu nur den voll qualifizierten Namen einer solchen Klasse. Die restlichen Bestandteile der Klasse können zur Laufzeit abgefragt werden Class-Browser, Debugger, Tools zum Testen: Mit Reflection erhält eine Anwendung Zugriff auf alle Bestandteile einer Klasse. Reflection kann auch auf private Attribute und Methoden zugreifen und hebelt damit das Prinzip der Kapselung aus. Frameworks wie Spring oder jUnit nutzen Reflection, um damit ihre Annotationen auswerten zu können.  In der Regel wird Reflection eher selten benutzt da der Prozess der Komponenten-Bewertung, welcher mit Reflection getriggert wird, die Leistung und die Geschwindigkeit eines Programms erheblich beeinträchtigt. Es gibt jedoch Anwendungsfälle, die nur mit Reflection umzusetzen sind. Beim Einsatz von Reflection gilt also die folgende Regel: Wenn es eine Lösung ohne Reflection gibt, dann wähle diese!\n Grundlagen Reflection nutzt die folgenden Konstrukte, um damit eine Anwendung zu untersuchen. Diese Konstrukte werden Metadaten bzw. Metainformationen genannt:\n java.lang.Class\u003cT\u003e, Metadaten für Klassen. Beinhaltet Klassenname, implementierte Interfaces, Methoden und Attribute java.lang.reflect.Field, Metadaten für Instanzvariablen. Enthält Typ, Name, Sichtbarkeit, usw. java.lang.reflect.Method, Metadaten für Methoden. Enthält Name, Parameter, Sichtbarkeit, usw.  Damit wir an die Informationen einer Klasse gelangen können, benötigen wir einen Startpunkt. Dieser Startpunkt ist bei Reflection immer eine Instanz der Klasse java.lang.Class\u003cT\u003e.\nDie anderen Metadaten lassen sich dann über diese Instanz beziehen. Es gibt drei Möglichkeiten, an diesen Startpunkt zu gelangen:\n   # Möglichkeit Code-Beispiel Beschreibung     1 voll-qualifizierter Klassenname Class\u003c?\u003e clazz = Class.forName(“package.ClassName”); Der Name der gewünschten Klasse wird einfach als String übergeben. Dies ist sehr gut einsetzbar, wenn der konkrete Typ zur Laufzeit noch unbekannt ist. Es ist also beispielsweise möglich Klassennamen aus einer Konfigurationsdatei einzulesen.   2 Methode getClass() Class\u003c?\u003e clazz = object.getClass(); Der Aufruf der Methode getClass() auf einer Referenz liefert direkt eine Instanz des Klassenobjekts.   3 statisches Attribut .class Class\u003c?\u003e clazz = ClassName.class; Durch Kenntnis des konkreten Typs erhält man den Zugriff auf das Klassenobjekt mit dem statischen Attribut class.    Bei Arrays muss eine eher kryptische Notation verwendet werden. Hier wird aus Komplexitätsgründen nicht weiter darauf eingegangen.\n Methoden aufrufen Der nächste Schritt ist nun, dass mit Reflection eine Methode aufgerufen werden kann. Die folgende Reihenfolge gibt einen guten Überblick, welche Schritte dazu notwendig sind:\n Ermitteln der Metainformationen zur Klasse Ermitteln der Metainformationen zur Methode Aufrufen der Methode Exception Handling  Beispiel\n1 2 3 4 5  public class Greeter { public String greet(String name) { return \"Hello \" + name; } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  public class Main { public static void main(String[] args) { String methodName = \"greet\"; Class\u003c?\u003e[] parameterTypes = new Class\u003c?\u003e[]{String.class}; // Ermitteln der Metainformationen zur Klasse  Class\u003c?\u003e clazz = Greeter.class; try { // Ermitteln der Metainformationen zur Methode  Method greetMethod = clazz.getMethod(methodName, parameterTypes); // Methode aufrufen  String parameter = \"Claudio\"; Object result = greetMethod.invoke(new Greeter(), parameter); System.out.println(result); } catch (NoSuchMethodException e) { // handle exception  } catch (SecurityException e) { // handle exception  } catch (IllegalAccessException e) { // handle exception  } catch (IllegalArgumentException e) { // handle exception  } catch (InvocationTargetException e) { // handle exception  } } }   Wie wir sehen gibt es zwei grosse Nachteile beim Einsatz von Reflection:\n Viel Code: Vor Java 7 benötigt man für einen Methodenaufruf zwischen 40 und 50 Zeilen Programmcode. Viel Exception Handling: Da der Einsatz von Reflection spezielle Berechtigungen erfordert, welche je nach Sicherheitseinstellungen nicht immer verfügbar sind, ist die Anzahl mögliche Exceptions relativ gross  Seit Java 7 wurden die Nachteile ein wenig entschärft, da sich das Exception Handling deutlich eleganter gestalten lässt. Einerseits bietet Java 7 die Möglichkeit zum Multi-Catch (siehe Modul Exception Handling), andererseits wurden alle Exceptions beim Einsatz von Reflection in der Klasse java.lang.ReflectiveOperationException zusammengefasst.\nAbgekürzt lässt sich das oben gezeigte Beispiel so darstellen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  public class Main { public static void main(String[] args) { String methodName = \"greet\"; Class\u003c?\u003e[] parameterTypes = new Class\u003c?\u003e[]{String.class}; // Ermitteln der Metainformationen zur Klasse  Class\u003c?\u003e clazz = Greeter.class; try { // Ermitteln der Metainformationen zur Methode  Method greetMethod = clazz.getMethod(methodName, parameterTypes); // Methode aufrufen  String parameter = \"Claudio\"; Object result = greetMethod.invoke(new Greeter(), parameter); System.out.println(result); } catch (ReflectiveOperationException e) { // handle exception  } } }    Zugriff auf Methoden und Attribute Sobald wir ein Klassenobjekt ermittelt haben können wir auf weitere Metadaten zugreifen. Spannend ist, dass wir so nicht nur auf Methoden und Attribute, sondern auch auf Annotationen zugreifen können.\nIm Beispiel oben wurde auf eine Methode zugegriffen. Dieser Zugriff besitzt die Einschränkung, dass nur öffentlich zugängliche Methoden ermittelt werden können. Damit wir auch Zugriff auf nicht öffentlich sichtbare Bestandteile erhalten, ist etwas mehr Aufwand notwendig. Um alle definierten Methoden einer Klasse unabhängig von der Sichtbarkeit aufzulisten, können wir die Methode _ getDeclaredMethod(Class\u003c?\u003e)_ verwenden.\nMit einer Rekursion können wir sicherstellen, dass wir auch Methoden, welche aus der Super-Klasse stammen, finden:\n1 2 3 4 5 6 7 8 9 10 11 12 13  public static Method findMethod(Class\u003c?\u003e clazz,String methodName,Class\u003c?\u003e...parameterTypes){ Objects.requireNonNull(methodName,\"Methodenname darf nicht null sein\"); Objects.requireNonNull(parameterTypes,\"Parameter dürfen nicht null sein\"); if(clazz==null){ return null; } try{ return clazz.getDeclaredMethod(methodName,parameterTypes); }catch(NoSuchMethodException e){ // Rekursiver Aufruf um die Methode in der Super-Klasse zu suchen  return findMethod(clazz.getSuperclass(),methodName,parameterTypes); } }   Die Methode getField(String) liefert für den Namen eines Attributs das entsprechende Field-Objekt zurück. Mit der Methode getDeclaredField(String) erhält man auch nicht öffentliche Attribute einer Klasse.\n Eigenschaften ermitteln Für Objekte des Typs Method und Field lassen sich mit der Methode getModifiers() verschiedene Eigenschaften in Form einer Zahl abfragen. Die Auswertung kann dann mit der Hilfsklasse java.lang.reflect.Modifier erfolgen.\nMögliche Abfragen sind beispielsweise:\n isPublic(int), isProtected(int) und isPrivate(int) isStatic(int), isFinal(int) und isAbstract(int) isSynchronized(int) und isVolatile(int)  Beispiel\n1 2 3  Method greetMethod = clazz.getMethod(methodName,parameterTypes); int modifiers = greetMethod.getModifiers(); boolean isPublic = Modifier.isPublic(modifiers);    Spezialfall Konstruktoren Der Aufruf eines Konstruktors per Reflection ist mit der Methode newInstance() möglich. Dies gilt nur für den Default-Konstruktor ohne Parameter. Der Aufruf eines Konstruktors mit Parameter erfordert zuerst einen Methodenaufruf von getDeclaredConstructor(Class\u003c?\u003e…). So erhalten wir den Konstruktor mit passender Signatur als Constructor-Objekt. Auf diesem Objekt kann anschliessend der Methodenaufruf newInstance(Object…) mit den korrekten Parametern erfolgen.\n Annotationen  Einführung Eine Annotation ist ein Java-Sprachelement, welches die Einbindung von Metadaten in den Quelltext erlaubt. Eine Annotation beginnt immer mit einem @-Zeichen und wird vor das entsprechende Element geschrieben, das annotiert werden soll. Optional kann eine, in runden Klammern eingefasste, kommagetrennte Parameterliste folgen.\nDie Einsatzgebiete sind wie folgt:\n Compiler-Informationen: Bereitstellung von Informationen an den Compiler wie beispielsweise mit der Annotation @Override Informationen für Tools: Diverse Annotationen, darunter auch selber geschriebene, können von speziellen Tools ausgewertet werden. Diese Tools nennt man Annotation-Processor. Ein solcher Annotation-Processor besitzt immer die Basisklasse javax.annotation.processing.AbstractProcessor. Schwergewichtige Frameworks wie beispielsweise Spring basieren in ihrer Funktionalität zu grossen Teilen auf Annotationen und deren Auswertung Informationsbereitstellung zur Laufzeit: Annotationen und deren Parameter können zur Laufzeit über Reflection ausgelesen und auch ausgewertet werden  Nicht alle Annotationen sind für jeden der oben genannten Anwendungsfälle geeignet. Der Grund dafür sind die verschiedenen Lebensdauern von Annotationen. Abhängig von der Definition verwirft oder überträgt der Java-Compiler Annotationen in das Kompilat oder nicht.\n Standard-Annotationen des JDKs Die folgenden Annotationen werden durch das JDK zur Verfügung gestellt. Bisher haben wir sie vielleicht bereits verwendet, nun wollen wir aber ihren Zweck nochmals genauer anschauen.\n@Deprecated Zweck:\n Anzeige, dass ein markiertes Element veraltet ist und nicht mehr verwendet werden sollte Wird ein solches Element verwendet, so beschwert sich der Compiler mit einer Warnung Als zusätzliche Angabe sollte @deprecated im JavaDoc verwendet werden.  Möglich auf:\n Klassen Felder (=Instanzvariablen) Methoden Parameter Konstruktoren Lokale Variablen Packages  Beispiel:\n1 2 3 4 5 6 7 8  /** * @deprecated Diese Methode führt zu Problemen und sollte nicht mehr verwendet werden. * Bitte stattdessen {@link #newMethod(int someValue)} benutzen. */ @Deprecated public void oldMethod(int someValue){ // ... }   @Override Zweck:\n Zeigt an, dass die annotierte Methode eine gleichnamige Methode einer Basisklasse überschreibt bzw. ein Interface implementiert Die Anwendung erscheint meistens nicht sehr sinnvoll, trotzdem hat diese Annotation ihre Berechtigung. Durch die Angabe dieser Annotation gleicht der Compiler die Signatur einer Methode mit derjenigen einer Basisklasse ab und warnt, wenn keine Überschreibung vorliegt Auf diese Weise kann man sehr schnell Fehler finden, falls man sich beim Methodennamen vertippt  Möglich auf:\n Methoden  Beispiel:\n1 2 3 4  @Override public void overridingMethod(int someValue){ // ... }   @SuppressWarnings Zweck:\n Erlaubt die Unterdrückung von Compiler-Warnungen Der zu unterdrückende Typ wird als Parameter an die Annotation übergeben Damit wir keine Fehler “verstecken” sollten wir diese Annotation nur sparsam einsetzen Die folgenden vordefinierten Parameterwerte sind wichtig, sie unterdrücken die genannten Compiler-Warnungen:  boxing, für Typumwandlungen mit Auto-Boxing und Auto-Unboxing deprecation, für die Verwendung von veralteten Implementationen unused, für die Verwendung von unbenutzten Variablen und/oder Methoden unchecked, für problematische Zugriffe wo der Compiler keine Typsicherheit garantieren kann. Dies ist vor allem beim kombinierten Einsatz von generischen Datentypen und untypisierten Klassen der Fall    Möglich auf:\n Klassen Felder (=Instanzvariablen) Methoden Parameter Konstruktoren Lokale Variablen  Beispiel:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  public class WarningSuppresser { @SuppressWarnings(\"unchecked\") public static void main(String[]args){ @SuppressWarnings(value = {\"unchecked\", \"deprecation\"}) final List\u003cPerson\u003e persons = getPersons(); for(final Person person:persons) { // ...  } } @Deprecated public static List getPersons(){ return new ArrayList(); } }   In diesem Beispiel geht es wirklich nur darum, den Einsatz der Annotation zu zeigen. Das Beispiel zeigt generell eher schlechten Code, im Realfall würden wir die Methode getPersons() einfach überarbeiten, anstatt die Warnungen zu unterdrücken :-)\n Definition eigener Annotationen Annotationen werden in eigenen Dateien analog zu Klassen und Interfaces definiert. Statt des Schlüsselworts class resp. interface wird hier @interface verwendet. Das sorgt automatisch dafür, dass die Annotation den Basistyp Annotation aus dem Package java.lang.annotation besitzt.\nDie Definition einer eigenen Annotation schauen wir nun anhand eines Beispiels genauer an. Wir erstellen eine Annotation für die Klassendokumentation.\nWir definieren nun zuerst eine eigene Annotation, diese soll zur Laufzeit für Typen (Klassen, Interfaces, Enumeratoren) zur Verfügung stehen.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; // Meta-Annotationen @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) // Annotation-Definition public @interface Documentation { // Methode zur Übergabe von Informationen durch Parameter  String id(); String name() default \"\"; String functionality(); }   Das ist dann auch schon alles zur Definition einer eigenen Annotation. Bevor wir weitermachen folgt hier eine kurze Information zu den einzelnen Elementen:\n   Element Beschreibung     @Retention Festlegung zu welchem Zeitpunkt die Annotation später verfügbar sein soll. Hier wurde mit RetentionPolicy.RUNTIME die Verfügbarkeit zur Laufzeit gewählt.   @Target Festlegung wo diese Annotation später im Sourcecode angewendet werden darf. Wir wollen damit Klassen, Interfaces oder auch Enums markieren und wählen aus diesem Grund ElementType.TYPE.   default Angabe eines Default-Wertes für den entsprechenden Parameter, solche Parameter werden automatisch optional.    Der grössere Aufwand entsteht nun erst, wenn wir diese Annotation zur Laufzeit auslesen möchten.\n Eigene Annotationen zur Laufzeit auslesen Die Definition der Annotation ist nun bekannt. Wir betrachten diese nun im Einsatz und nehmen als Beispiel eine weitere Klasse, dort soll die Annotation nun zum Einsatz kommen:\nOhne Annotation 1 2 3 4 5 6 7 8 9 10 11 12 13  /** * This is the request for a job * * @author u210148 Claudio Zesiger */ @Data public class JobRequest { private String id; private String title; private String code; private String creator; private LocalDateTime creationDate; }   Mit Annotation 1 2 3 4 5 6 7 8 9 10  @Documentation(id = \"u210148\", name = \"Claudio Zesiger\", functionality = \"This is the request for a job\") @Data public class JobRequest { private String id; private String title; private String code; private String creator; private LocalDateTime creationDate; }   Auswertung Die Auswertung unserer Annotation zur Laufzeit ist beispielsweise wie folgt möglich:\n1 2 3 4 5 6 7 8 9  public class AnnotationTester { public static void main(String[]args){ Documentation documentation=JobRequest.class.getAnnotation(Documentation.class); System.out.println(JobRequest.class.getName()); System.out.println(documentation.id()); System.out.println(documentation.name()); System.out.println(documentation.functionality()); } }   Durch eine solche Auswertung liesse sich beispielsweise eine automatische Dokumentation generieren.\n","categories":"","description":"Modul #J6 - Annotationen \u0026 Reflection API\n","excerpt":"Modul #J6 - Annotationen \u0026 Reflection API\n","ref":"/docs/java/java-reflection-and-annotations/","tags":"","title":"Annotationen \u0026 Reflection API"},{"body":"Was gibt es für CSS-Selektoren? Nun da wir die Grundlagen von CSS gelernt haben, können wir uns die Selektoren genauer anschauen. Die Selektoren bestimmen, für welche HTML-Elemente die CSS-Regeln gelten (“ziehen”).\nSelektoren im Überblick Es gibt verschiedenste Selektoren, welche alle ihren eigenen Nutzen haben. In der folgenden Tabelle werden die gängigsten aufgezählt und erklärt.\n   Name Anwendung in HTML Anwendung in CSS Beschreibung     Klasse class=\"demo-class\" .demo-class {...} CSS-Klassen können mit dem “class”-Attribut auf jedes beliebige HTML-Element angewendet und dann im CSS referenziert werden. Klassen können dabei auf mehrere Elemente gegeben werden, was das Wiederverwenden der CSS-Regeln ermöglicht.   ID id=\"demo-id\" #demo-class {...} IDs können mit dem “id”-Attribut auf jedes beliebige HTML-Element angewendet werden. Grundsätzlich sollten IDs eindeutig sein, d.h. nicht an mehreren Orten verwendet werden.   Element \u003celement-name\u003e\u003c/element-name\u003e \"element-name\" {...} Um alle HTML-Elemente eines Types auszuwählen, muss man nichts spezielles im HTML anpasse. Es muss einfach gegeben sein, dass die Elemente auch tatsächlich vorhanden sind. Im CSS muss man dann nur noch den Element-Namen angeben (im Beispiel zu ersetzen mit z.B. a, p, input, body), wobei keine Prefixes notwendig sind.    Im nächsten Beispiel werden diese 3 Möglichkeiten verwendet:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  \u003cform class=\"round-container\"\u003e \u003cp\u003eBitte gib deinen Namen ein:\u003c/p\u003e \u003clabel for=\"your-name\"\u003eName\u003c/label\u003e \u003cinput type=\"text\" id=\"your-name\" name=\"name\"\u003e \u003cinput type=\"submit\" /\u003e \u003c/form\u003e \u003cstyle\u003e .round-container { width: 20em; background-color: lightgrey; border-radius: 2em; padding: 1em; } #your-name { background-color: orange; } label { font-weight: bold; } \u003c/style\u003e   In diesem Beispiel wurde die frei erfundene Klasse round-container, die ID your-name und das Element label mit CSS versehen.\nSpezifischere Selektoren Element auf Grund eines Attributes setzen Es kann vorkommen, dass du ein Element mit einem spezifischen Attribut stylen musst. Möchtest du z.B. alle Submit-Buttons stylen, dann könnte dir dieser Selektor weiterhelfen: input[type=submit] {...}\nEs gibt aber auch die Möglichkeit, ob der Attribut-Wert einen bestimmten Text enthält, damit beginnt bzw. endet. Hierfür sei auf diese Seite verwiesen: https://www.w3schools.com/cssref/css_selectors.asp\nSpezifisches Element mit Klasse Möchtest du z.B. alle \u003cform\u003e-Elemente, die die Klasse round-container enthalten, stylen, dann möchtest du wahrscheinlich folgenden Selektor: form.round-container {...}\nElemente, die sich in einem anderen Element befinden müssen Möchtest du z.B. alle labels stylen, die sich in einer form befinden, dann verwende so etwas: form label {...}. Zuerst kommt das übergeordnete Element, dann dasjenige, das tiefer verschachtelt ist. Die Elemente werden mit einem Leerzeichen voneinander getrennt. Bei diesem Selektor spielt es keine Rolle, ob label direkt in form ist, Hauptsache label befindet sich innerhalb einer form.\nIst es hingegen relevant, dass der label direkt in der form kommt (also keinen anderen Parent hat als form), dann benutze folgende Regel: form \u003e label {...}. Bei diesem Selektor bedeutet das \u003e, dass das erste Element der Parent vom zweiten Element sein muss.\nPseudoklassen Mithilfe von Pseudoklassen kann einen besonderen Zustand abgefragt werden. Mit :hover können CSS-Regeln z.B. auf Elemente beschränkt werden, wenn sich diese unterhalb des Mauszeigers befinden.\nMit dem nächsten Selektor kannst du z.B. das Aussehen beim Darüber-“Hovern” (also wenn der Mauszeiger darüber ist) vollständig verändern:\n1 2 3 4  input[type=submit]:hover { background-color: orange; color: white; }   Für \u003cinput\u003e-Elemente könnten Pseudoklassen wie :disabled oder :checked (Checkboxen) noch interessant sein.\nDu hast aber auch Zugriff auf völlig andere Sachen! Du kannst z.B. den ersten Buchstaben einem Paragraphen z.B. automatisch gross schreiben lassen:\n1 2 3  p:first-letter { font-size: 200%; }   Viele weitere interessante Pseudoklassen findest du hier beschrieben: https://web.dev/learn/css/pseudo-classes/\n","categories":"","description":"Die verschiedenen CSS-Selektoren.\n","excerpt":"Die verschiedenen CSS-Selektoren.\n","ref":"/docs/web/html_css/12_css_selectors/","tags":"","title":"CSS-Selektoren"},{"body":"Eine Auswahlliste anzeigen  Die Beispielanwendung, die auf dieser Seite beschrieben wird, findest du unter dieser Seite.\n Mock Heroes erstellen Du benötigst einige Helden, die angezeigt werden sollen.\nLetztendlich wirst du diese von einem entfernten Datenserver erhalten. Für den Moment wirst du einige mock heroes erstellen und so tun, als kämen sie vom Server.\nErstelle eine Datei namens mock-heroes.ts im Ordner src/app/. Definiere eine HEROES Konstante als Array von zehn Helden und exportiere sie. Die Datei sollte wie folgt aussehen.\nsrc/app/mock-heroes.ts\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  import { Hero } from './hero'; export const HEROES: Hero[] = [ { id: 11, name: 'Dr Nice' }, { id: 12, name: 'Narco' }, { id: 13, name: 'Bombasto' }, { id: 14, name: 'Celeritas' }, { id: 15, name: 'Magneta' }, { id: 16, name: 'RubberMan' }, { id: 17, name: 'Dynama' }, { id: 18, name: 'Dr IQ' }, { id: 19, name: 'Magma' }, { id: 20, name: 'Tornado' } ];   Anzeige der Helden Öffne die Klassendatei HeroesComponent und importiere das Mock HEROES.\nsrc/app/heroes/heroes.component.ts (import HEROES)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  import { Hero } from './hero'; export const HEROES: Hero[] = [ { id: 11, name: 'Dr Nice' }, { id: 12, name: 'Narco' }, { id: 13, name: 'Bombasto' }, { id: 14, name: 'Celeritas' }, { id: 15, name: 'Magneta' }, { id: 16, name: 'RubberMan' }, { id: 17, name: 'Dynama' }, { id: 18, name: 'Dr IQ' }, { id: 19, name: 'Magma' }, { id: 20, name: 'Tornado' } ];   Definiere in derselben Datei (Klasse HeroesComponent) eine Komponenteneigenschaft namens heroes, um das Array HEROES zur Bindung freizugeben.\nsrc/app/heroes/heroes.component.ts\n1 2 3 4  export class HeroesComponent implements OnInit { heroes = HEROES; }   Auflisten von Helden mit *ngFor Öffne die Templatedatei HeroesComponent und nimm die folgenden Änderungen vor:\n Füge ein \u003ch2\u003e am Anfang ein, Darunter fügst du eine ungeordnete HTML-Liste (\u003cul\u003e) ein. Füge ein \u003cli\u003e innerhalb des \u003cul\u003e ein, das die Eigenschaften eines Helden anzeigt. Streue einige CSS-Klassen für die Gestaltung ein (Du wirst die CSS-Stile in Kürze hinzufügen).  Das Ganze soll so aussehen:\nheroes.component.html (heroes template)\n1 2 3 4 5 6  \u003ch2\u003eMy Heroes\u003c/h2\u003e \u003cul class=\"heroes\"\u003e \u003cli\u003e \u003cspan class=\"badge\"\u003e{{hero.id}}\u003c/span\u003e {{hero.name}} \u003c/li\u003e \u003c/ul\u003e   Es wird ein Fehler angezeigt, da die Eigenschaft “hero” nicht existiert. Um Zugriff auf jeden einzelnen Helden zu haben und sie alle aufzulisten, füge ein *ngFor zum \u003cli\u003e hinzu, um die Liste der Helden zu durchlaufen:\n1  \u003cli *ngFor=\"let hero of heroes\"\u003e   Die *ngFor ist Angulars Direktive repeater. Sie wiederholt das Host-Element für jedes Element in einer Liste.\nDie Syntax in diesem Beispiel ist wie folgt:\n \u003cli\u003e ist das Host-Element. heroes enthält die Mock-Helden-Liste der Klasse HeroesComponent, die Mock-Helden-Liste. hero enthält das aktuelle Heldenobjekt für jede Iteration durch die Liste.  Vergiss nicht das Sternchen (*) vor ngFor. Es ist ein wichtiger Teil der Syntax.\nNachdem der Browser aktualisiert wurde, erscheint die Liste der Helden.\nStil der Helden Die Heldenliste sollte ansprechend sein und visuell reagieren, wenn der Benutzer mit dem Mauszeiger einen Helden aus der Liste auswählen.\nIm ersten Tutorial hast du die grundlegenden Stile für die gesamte Anwendung in styles.css festgelegt. Dieses Stylesheet enthielt keine Stile für diese Liste von Helden.\nDu kannst weitere Stile zu styles.css hinzufügen und das Stylesheet mit dem Hinzufügen von Komponenten weiter ausbauen.\nVielleicht ziehst du es stattdessen vor, private Stile für eine bestimmte Komponente zu definieren und alles, was eine Komponente braucht, zu behalten— den Code, das HTML, und das CSS —zusammen an einem Ort.\nDieser Ansatz macht es einfacher, die Komponente an anderer Stelle wiederzuverwenden und das beabsichtigte Erscheinungsbild der Komponente zu erhalten, selbst wenn die globalen Stile unterschiedlich sind.\nDu definierst private Stile entweder inline im Array @Component.styles oder als Stylesheet-Datei(en), die im @Component.styleUrls Array identifiziert werden.\nAls die CLI die HeroesComponent generierte, erstellte sie ein leeres heroes.component.css Stylesheet für die HeroesComponent und verwies in @Component.styleUrls wie folgt darauf.\nsrc/app/heroes/heroes.component.ts (@Component)\n1 2 3 4 5  @Component({ selector: 'app-heroes', templateUrl: './heroes.component.html', styleUrls: ['./heroes.component.css'] })   Öffne die Datei heroes.component.css und füge die privaten CSS-Stile für die HeroesComponent ein. Du findest sie in der finalen Code-Übersicht am Ende dieser Anleitung.\nStile und Stylesheets, die in @Component-Metadaten identifiziert werden, sind auf diese spezifische Komponente beschränkt. Die heroes.component.css-Stile gelten nur für die HeroesComponent und haben keine Auswirkungen auf das äußere HTML oder das HTML in anderen Komponenten.\nAnzeigen von Details Wenn der Benutzer auf einen Helden in der Liste klickt, sollte die Komponente die Details des ausgewählten Helden unten auf der Seite anzeigen.\nIn diesem Abschnitt wirst du auf das Klick-Ereignis für das Heldenelement warten und aktualisieren die Heldendetails.\nHinzufügen einer Klick-Ereignisbindung Füge eine Klick-Ereignis-Bindung zu \u003cli\u003e wie folgt hinzu:\nheroes.component.html (template excerpt)\n1  \u003cli *ngFor=\"let hero of heroes\" (click)=\"onSelect(hero)\"\u003e   Dies ist ein Beispiel für die Ereignisbindung-Syntax von Angular.\nDie Klammern um click sagen Angular, dass es auf das click-Ereignis des \u003cli\u003e-Elements warten soll. Wenn der Benutzer auf das Element \u003cli\u003e klickt, führt Angular den Ausdruck onSelect(hero) aus.\nIm nächsten Abschnitt definierst du eine onSelect() Methode in HeroesComponent um um den Helden anzuzeigen, der in der *ngFor Expression definiert wurde.\nFüge den Click-Event-Handler hinzu Benenne die Eigenschaft hero der Komponente in selectedHero um, aber weise sie nicht zu. Es gibt keinen selected hero, wenn die Anwendung startet.\nFüge die folgende Methode onSelect() hinzu, die den angeklickten Helden aus dem Template dem selectedHero der Komponente zuweist.\nsrc/app/heroes/heroes.component.ts (onSelect)\n1 2 3 4  selectedHero?: Hero; onSelect(hero: Hero): void { this.selectedHero = hero; }   Hinzufügen eines Detailbereichs Derzeit hast du eine Liste in dem Komponententemplate. Um auf einen Helden in der Liste zu klicken und Details über diesen Helden anzuzeigen, benötigst du einen Abschnitt für die Details, der im Template zu finden ist. Füge folgendes zu heroes.component.html unter dem Listenabschnitt hinzu:\nheroes.component.html (selected hero details)\n1 2 3 4 5 6  \u003ch2\u003e{{selectedHero.name | uppercase}} Details\u003c/h2\u003e \u003cdiv\u003e\u003cspan\u003eid: \u003c/span\u003e{{selectedHero.id}}\u003c/div\u003e \u003cdiv\u003e \u003clabel for=\"hero-name\"\u003eHero name: \u003c/label\u003e \u003cinput id=\"hero-name\" [(ngModel)]=\"selectedHero.name\" placeholder=\"name\"\u003e \u003c/div\u003e   Nach dem Aktualisieren des Browsers ist die Anwendung fehlerhaft.\nÖffne die Entwicklerwerkzeuge des Browsers und suche in der Konsole nach einer Fehlermeldung wie dieser:\n1  HeroesComponent.html:3 ERROR TypeError: Cannot read property 'name' of undefined   Was ist passiert? Wenn die Anwendung startet, ist die Eigenschaft selectedHero “undefiniert” durch Design.\nBindungsausdrücke im Template, die sich auf Eigenschaften von selectedHero beziehen—Ausdrücke wie {{selectedHero.name}}—müssen fehlschlagen, weil es keinen ausgewählten Helden gibt.\nDie Lösung - leere Details mit *ngIf ausblenden Die Komponente sollte die ausgewählten Heldendetails nur anzeigen, wenn der selectedHero existiert.\nWickle das HTML der Heldendetails in ein \u003cdiv\u003e ein. Füge die *ngIf-Direktive von Angular in das \u003cdiv\u003e ein und setze es auf selectedHero.\nVergiss nicht, das Sternchen (*) vor ngIf zu setzen. Das ist ein wichtiger Teil der Syntax.\nsrc/app/heroes/heroes.component.html (*ngIf)\n1 2 3 4 5 6 7 8 9 10  \u003cdiv *ngIf=\"selectedHero\"\u003e \u003ch2\u003e{{selectedHero.name | uppercase}} Details\u003c/h2\u003e \u003cdiv\u003e\u003cspan\u003eid: \u003c/span\u003e{{selectedHero.id}}\u003c/div\u003e \u003cdiv\u003e \u003clabel for=\"hero-name\"\u003eHero name: \u003c/label\u003e \u003cinput id=\"hero-name\" [(ngModel)]=\"selectedHero.name\" placeholder=\"name\"\u003e \u003c/div\u003e \u003c/div\u003e   Nach dem Aktualisieren des Browsers wird die Liste der Namen wieder angezeigt. Der Detailbereich ist leer. Klicke auf einen Helden in der Liste der Helden und seine Details erscheinen. Die Anwendung scheint wieder zu funktionieren. Die Helden werden in einer Liste angezeigt und die Details zu dem angeklickten Helden erscheinen unten auf der Seite.\nWarum es funktioniert Wenn selectedHero undefiniert ist, entfernt das ngIf die Heldendetails aus dem DOM. Es gibt keine selectedHero Bindungen zu berücksichtigen.\nWenn der Benutzer einen Helden auswählt, hat selectedHero einen Wert und ngIf\" setzt das Heldendetail in das DOM.\nDen ausgewählten Helden gestalten Um den ausgewählten Helden zu identifizieren, kannst die CSS-Klasse .selected in den Stilen, die du zuvor hinzugefügt hast verwenden. Um die Klasse .selected auf das \u003cli\u003e anzuwenden (wenn der Benutzer darauf klickt), verwende die Klassenbindung.\nAngulars class-binding kann eine CSS-Klasse bedingt hinzufügen und entfernen. Füge [class.some-css-class]=\"some-condition\" zu dem Element hinzu, das du gestalten möchtest.\nFüge die folgende [class.selected] Bindung zum \u003cli\u003e im HeroesComponent Template hinzu:\nheroes.component.html (toggle the 'selected' CSS class)\n1  [class.selected]=\"hero === selectedHero\"   Wenn der aktuelle Zeilenheld derselbe ist wie der selectedHero, fügt Angular die CSS-Klasse selected hinzu. Wenn die beiden Helden unterschiedlich sind, entfernt Angular die Klasse.\nDas fertige \u003cli\u003e sieht wie folgt aus:\nheroes.component.html (list item hero)\n1 2 3 4 5  \u003cli *ngFor=\"let hero of heroes\" [class.selected]=\"hero === selectedHero\" (click)=\"onSelect(hero)\"\u003e \u003cspan class=\"badge\"\u003e{{hero.id}}\u003c/span\u003e {{hero.name}} \u003c/li\u003e   Abschließende Code-Überprüfung Hier sind die auf dieser Seite besprochenen Codedateien, einschließlich der HeroesComponent-Stile.\n src/app/mock-heroes.ts  1 2 3 4 5 6 7 8 9 10 11 12 13 14  import { Hero } from './hero'; export const HEROES: Hero[] = [ { id: 11, name: 'Dr Nice' }, { id: 12, name: 'Narco' }, { id: 13, name: 'Bombasto' }, { id: 14, name: 'Celeritas' }, { id: 15, name: 'Magneta' }, { id: 16, name: 'RubberMan' }, { id: 17, name: 'Dynama' }, { id: 18, name: 'Dr IQ' }, { id: 19, name: 'Magma' }, { id: 20, name: 'Tornado' } ];   src/app/heroes/heroes.component.ts  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  import { Component, OnInit } from '@angular/core'; import { Hero } from '../hero'; import { HEROES } from '../mock-heroes'; @Component({ selector: 'app-heroes', templateUrl: './heroes.component.html', styleUrls: ['./heroes.component.css'] }) export class HeroesComponent implements OnInit { heroes = HEROES; selectedHero?: Hero; constructor() { } ngOnInit() { } onSelect(hero: Hero): void { this.selectedHero = hero; } }   src/app/heroes/heroes.component.html  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  \u003ch2\u003eMy Heroes\u003c/h2\u003e \u003cul class=\"heroes\"\u003e \u003cli *ngFor=\"let hero of heroes\" [class.selected]=\"hero === selectedHero\" (click)=\"onSelect(hero)\"\u003e \u003cspan class=\"badge\"\u003e{{hero.id}}\u003c/span\u003e {{hero.name}} \u003c/li\u003e \u003c/ul\u003e \u003cdiv *ngIf=\"selectedHero\"\u003e \u003ch2\u003e{{selectedHero.name | uppercase}} Details\u003c/h2\u003e \u003cdiv\u003e\u003cspan\u003eid: \u003c/span\u003e{{selectedHero.id}}\u003c/div\u003e \u003cdiv\u003e \u003clabel for=\"hero-name\"\u003eHero name: \u003c/label\u003e \u003cinput id=\"hero-name\" [(ngModel)]=\"selectedHero.name\" placeholder=\"name\"\u003e \u003c/div\u003e \u003c/div\u003e   src/app/heroes/heroes.component.css  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  /* HeroesComponent's private CSS styles */ .heroes { margin: 0 0 2em 0; list-style-type: none; padding: 0; width: 15em; } .heroes li { cursor: pointer; position: relative; left: 0; background-color: #EEE; margin: .5em; padding: .3em 0; height: 1.6em; border-radius: 4px; } .heroes li:hover { color: #2c3a41; background-color: #e6e6e6; left: .1em; } .heroes li.selected { background-color: black; color: white; } .heroes li.selected:hover { background-color: #505050; color: white; } .heroes li.selected:active { background-color: black; color: white; } .heroes .badge { display: inline-block; font-size: small; color: white; padding: 0.8em 0.7em 0 0.7em; background-color:#405061; line-height: 1em; position: relative; left: -1px; top: -4px; height: 1.8em; margin-right: .8em; border-radius: 4px 0 0 4px; } input { padding: .5rem; }   Zusammenfassung  Die Anwendung “Tour of Heroes” zeigt eine Liste von Helden mit einer Detailansicht an. Der Benutzer kann einen Helden auswählen und dessen Details sehen. Du hast *ngFor verwendet, um eine Liste anzuzeigen. Du hast *ngIf verwendet, um einen HTML-Block bedingt ein- oder auszuschließen. Du kannst eine CSS-Stilklasse mit einer class-Bindung umschalten.  ","categories":"","description":"Auf dieser Seite erweiterst du die Anwendung Tour der Helden, um eine Liste von Helden anzuzeigen und den Benutzern die Möglichkeit geben, einen Helden auszuwählen und die Details des Helden anzuzeigen.\n","excerpt":"Auf dieser Seite erweiterst du die Anwendung Tour der Helden, um eine …","ref":"/docs/web/angular/05_3_selection_list/","tags":"","title":"Auswahlliste"},{"body":"Ziele  Ich weiss was die JDBC-Schnittstelle ist und wofür sie benutzt wird Ich weiss was JDBC-Treiber sind und warum sie benötigt werden Ich kenne die wichtigsten Interfaces der JDBC-Schnittstelle Ich weiss wie parametrisierte SQL-Anweisungen verwendet werden können Ich kann eine Datenbank-Verbindung aus einer Java-Anwendung herstellen Ich kann CRUD-Operationen aus einer Java-Anwendung ausführen  Einleitung Die meisten Apps und Webseiten, welche wir heutzutage fast täglich verwenden, dienen lediglich der Datenverarbeitung.\nSobald du ein Bild deines Freundes likest, den Fahrplan abrufst oder eine neue Tastatur bestellst, es werden immer Daten gelesen, geschrieben, bearbeitet oder gelöscht.\nEs gibt Frameworks (darunter z.B. Spring), welche die Verbindung zu Datenbanken verwalten und die sog. “Boiler-Plate”-Details dazu von den Entwicklern verbergen. Diese Frameworks bieten auch einfache Interaktion mit der Datenbank z.B. im Form von CRUD-Operationen. Durch das Verwenden solcher Frameworks kann auf “Boiler-Plate” Code verzichtet werden. Die Entwicklung von Business-Logik ist somit von infrastrukturellen Details getrennt.\nEs gibt jedoch Situationen, wo solche Frameworks nicht benutzt werden können oder man muss bestimmte Aktivitäten, welche diese Frameworks out-of-the-box anbieten, anders gestalten. In solchen Situationen kann die JDBC-Bibliothek von Java verwendet werden.\nWas ist JDBC JDBC ist eine Schnittstelle, welche dafür benutzt wird, um aus einer Java Anwendung eine Verbindung zu einer Datenbank herzustellen und Queries auf den Daten darin (z.B. lesen oder bearbeiten) ausführen zu können.\nDie JDBC-Schnittstelle stellt eine Datenbank unabhängige API zur Verfügung und trägt damit dazu bei, dass die Anwendung nicht an einer bestimmten Datenbank stark gekoppelt ist (sprich, die Anwendung muss die unterliegende Datenbank, theoretisch, gar nicht kennen).\nUm die eigentliche Verbindung mit der Datenbank zu ermöglichen, werden JDBC-Treiber eingesetzt. Ein JDBC-Treiber ist eine Software-Komponente, welche die Zugriffstechnik für eine bestimmte Datenbank (z.B. Oracle, Postgres usw.) kennt und somit in der Lage ist, Anfragen an der Datenbank weiterzuleiten wie auch die Ergebnisse zurückzuliefern. Solche Treiber können umgetauscht werden, wenn die unterliegende Datenbank geändert werden soll, ohne dass es zu einer Anpassung in der Anwendung-Code kommt.\nEine vereinfachte Darstellung der JDBC-Architektur sieht also wie folgt aus:\nJDBC in der Praxis Die Klassen und Interfaces der JDBC-Schnittstelle befinden sich im Paket “java.sql”. Entsprechend reicht ein “import”-Statement um mit diesen Klassen/Interfaces arbeiten zu können. Die JDBC-Treiber sind jedoch separate und proprietäre Komponenten, welche zur Laufzeit vorhanden sein müssen damit der Classloader sie wirklich laden kann. Bei einem Maven-Projekt wird dies mittels einer Maven-Abhängigkeit erledigt. Ansonsten muss die Jar-Datei des Treibers auf dem Klassenpfad vorhanden sein.\nDie ersten Schritte bei der Arbeit mit der JDBC-Schnittstelle beinhalten die nötige Konfiguration um die Verbindung zur Datenbank herstellen zu können. Anschliessend können Abfragen und sonstige SQL-Anweisungen ausgeführt werden.\nDie folgenden Abschnitte zeigen die nötigen Schritte anhand von Beispielen. Diese Beispiele wurden in einem Maven-Projekt ohne das Spring-Framework erstellt.\nMaven-Dependency Sobald die gewünschte Datenbank festgelegt wurde, kann der dazugehörende JDBC-Treiber als Maven-Abhängigkeit herangezogen werden.\nDas folgende Beispiel zeigt eine Abhängigkeit zu einem MySql-Treiber:\nDie restlichen Schritte erfolgen im Java-Code.\nTreiber laden/registrieren Hinweis\nDieser Schritt wird nur bei JDBC-Versionen benötigt, welche älter sind als die Version 4! Bei neueren Versionen, werden alle Treiber geladen, welche auf dem Klassenpfad gefunden werden und somit braucht es diesen Schritt nicht mehr.\nMit der statischen Methode forName von Class wird die Klasse Driver geladen. Hier geht es um die Datenbank spezifischer Treiber, welche es der Anwendung den Datenzugriff auf der gewünschten Datenbank ermöglicht.\nIm folgenden Beispiel wird der JDBC-Treiber für MySql registriert:\nDatenbankverbindung herstellen Der Zugriff auf einer Datenbank erfordert die Konfiguration folgender Elemente:\n url: eine JDBC-URL, welche auf die gewünschte Datenquelle zeigt Benutzername: einer, für den Zugriff auf die Datenbank, autorisierter Benutzer Passwort: das Passwort des autorisierten Benutzers, womit er sich authentifizieren kann  Die Konfiguration wird hier einfachheitshalber als Klartext im Code geschrieben. Selbstverständlich dürfen vertrauliche Informationen wie z.B. das Passwort nicht als Klartext im Code stehen. Für diesen Zweck, wie auch für die Konfiguration unterschiedlichen Umgebungen, eignen sich System- oder Umgebungsvariablen (mit oder ohne Verschlüsselung) besser.\nDie obige Konfiguration kann nun für die Herstellung einer Datenbankverbindung verwendet werden. Dazu wird die statische Methode getConnection der Klasse DriverManager verwendet:\nAb diesem Punkt repräsentiert das Connection-Objekt die Verbindung zur Datenbank.\nSQL-Anweisung vorbereiten Die SQL-Anweisung kann als String vor der Ausführung vorbereitet werden:\nWenn eine IDE wie z.B. IntelliJ verwendet wird und eine Datasource mit der richtigen Datenbank definiert wird, erkennt die IDE, dass es sich um eine SQL-Anweisung handelt und liefert entsprechend Vorschläge und formatiert die Anweisung richtig und gut leserlich.\nDie obige SQL-Anweisung dient dazu alle Daten aus einer bestehenden Tabelle zu Lesen. SQL-Anweisungen können aber auch Operationen wie Tabellen erstellen, Daten einfügen, löschen oder bearbeiten usw. beinhalten.\nAls Beispiel, erstellt die folgende SQL-Anweisung eine Tabelle - falls diese noch nicht existiert - mit ein paar gewünschten Attributen (Spalten):\nSQL-Anweisung ausführen Um SQL-Anweisungen ausführen zu können wird zunächst ein Statement-Objekt aus dem vorhandenen Connection-Objekt erzeugt. Dieses Statement-Objekt wird verwendet, um die SQL-Anweisung an die Datenbank zu richten. Dazu wird eine der execute Methoden des Statement-Objektes verwendet.\nIm folgenden Beispiel wird die ein Statement-Objekt mithilfe des Connection-Objekt erstellt. Danach wird die Methode executeQuery verwendet, welche eine SQL-Anweisung als Parameter entgegennimmt, diese ausführt und eine Referenz auf die Ergebnismenge (sog. ResultSet) zurückliefert:\nParametrisierte SQL-Anweisungen Bis jetzt haben wir SQL-Anweisungen ausgeführt, welche keine Einschränkungen beinhaltet haben. Oft werden jedoch SQL-Anweisungen mit bestimmten Kriterien oder Einschränkungen benötigt damit die zurückgelieferten Daten anhand dieser Kriterien gefiltert werden können. In solchen Situationen wird der SQL “WHERE”-Befehl benutzt. Zum Beispiel:\nSELECT * FROM user WHERE username = ‘gandalf’ and age \u003e 20;\nIn diesem Beispiel, werden nur Einträge zurückgeliefert, welche die Kriterien username = ‘gandalf’ und age \u003e 20 erfüllen. Wenn nun dieselbe Anweisung mehrmals ausgeführt werden soll aber jeweils mit anderen Parameter (also mit unterschiedlichen username und age), wird die Anweisung mit Platzhaltern wie folgt geschrieben (ein Fragezeichen dient als einen Platzhalter):\nFür das eigentliche Ausführen der Anweisung müssen alle Platzhalter durch konkrete Werte ersetzt werden. Dazu wird ein PreparedStatement verwendet, welche es erlaubt, alle Platzhalter anhand ihrer Position (beginnend mit 1) mittels setXXX Methoden anzusprechen und mit den konkreten Werten zu ersetzen. Anschliessend, kann auch hier eine der executeXXX Methoden verwendet werden, um die Anweisung auszuführen:\nRückgabewerte verarbeiten Bei der Ausführung von bestimmten SQL-Anweisungen (z.B. bei SELECT Operationen), wird eine Ergebnismenge zurückgeliefert. Ein ResultSet repräsentiert einen sog. Cursor auf diese Ergebnismenge. Die Methoden des ResultSets, bewegen den Cursor (je nach Art des Cursors) vorwärts, rückwärts, zur ersten oder zur letzten Position usw. Somit kann über die gesamte Ergebnismenge, Zeile bei Zeile, iteriert werden, um die Werte zu lesen.\nIm obigen Beispiel wird die next Methode verwendet um den Cursor jeweils eine Zeile vorwärtszubewegen. Aus jeder Zeile werden aus dem ResultSet mittels getXXX Methoden (XXX steht für den Typ des Wertes) die Werte, welche in dieser aktuellen Zeile vorhanden sind. Die getXXX Methoden, bekommen als Parameter entweder die Spaltenposition oder den Spaltennamen, welche gelesen werden soll. Bei einer Spaltenposition hat die erste zurückgelieferte Spalte die Position 1. Hinter der letzten Zeile liefert die next Methode false zurück und somit wird die Schleife beendet, nachdem alle Zeilen bearbeitet worden sind.\nVerbindungen schliessen Objekte der Typ Connection, Statement oder auch PreparedStatement sind sog. Ressourcen. Solche Ressourcen müssen nach Verbrauch wieder explizit geschlossen werden:\nWenn diese Ressourcen innerhalb eines try-with-resources Befehls erstellt werden, entfällt diese explizite Schliessung der Ressourcen.\nDie Arbeit mit try-with-resources ist immer vorzuziehen, wenn es um Closable-Ressourcen geht.\nZusammenfassung Die folgende Beispiel-Methode fasst die oben erwähnten Arbeitsschritte mit JDBC (aktuelle Version) zusammen:\n","categories":"","description":"Modul #J8 - JDBC\n","excerpt":"Modul #J8 - JDBC\n","ref":"/docs/java/java-jdbc/","tags":"","title":"JDBC (Java Database connection)"},{"body":"Arten von Schriftarten Browser unterstützen mindestens diese 5 Arten von Schriftarten:\n  Die wichtigste Unterscheidung ist zwischen Serif- und Sans-Serif-Schriftarten. Serif-Schriftarten haben Serife (also dünne Linien auf den Buchstabenlinien). Eine detailliertere Beschreibung findest du hier: https://de.wikipedia.org/wiki/Serife\n  Sans-Serif-Schriftarten haben diese Serifen nicht.\n  Bei Monospace-Schriftarten beanspruchen alle Buchstaben gleich viel Platz. Ein bekanntes Beispiel hierfür ist Consolas. Diese werden oft für Code verwendet.\n  Kursive Schriftarten imitieren Handschrift.\n  Fantasy-Schriftarten werden oft für kreative Zwecke eingesetzt.\n  Schriftarten in CSS Im CSS kannst du Schriftarten wie folgt einbinden:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  .p1 { font-family: \"Times New Roman\", Times, serif; } .p2 { font-family: Arial, Helvetica, sans-serif; } .p3 { font-family: \"Consolas\", monospace; } .p4 { font-family: \"Lucida Handwriting\", cursive; } .p5 { font-family: \"Comic Sans MS\", fantasy; }   Als CSS-Property (=Eigenschaft) wird font-family verwendet. Dabei können mehrere Schriftarten übergeben werden, was auf Grund von Browser-Kompatibilität empfohlen wird. Die erste Schriftart ist die wichtigste. Sollte diese nicht geladen werden können, so wird die nächste Schriftart ausprobiert. Als Fallback kann man dann serif, sans-serif, monospace, cursive oder fantasy verwenden.\nWeitere Informationen darüber kriegst du hier: https://www.w3schools.com/css/css_font.asp\nWeitere Font-Eigenschaften Text kann auf viele weitere Arten gestylt werden:\n   CSS-Property Beispiel Beschreibung     color color: blue Schriftfarbe   background-color color: blue Hintergrundfarbe (~Anstreichen)   font-size font-size: 16px Schriftgrösse.   text-align text-align: center Einen Text zentrieren.    Auftrag Im Rahmen der Semantic-Tags hast du ein HTML-Dokument erstellt.\nVersuche alle Properties von dieser Seite auf deiner zu verwenden.\n","categories":"","description":"Arten von Schriftarten.\n","excerpt":"Arten von Schriftarten.\n","ref":"/docs/web/html_css/13_css_fonts/","tags":"","title":"Schriftarten"},{"body":"Erstelle eine Feature-Komponente Im Moment zeigt die Komponente HeroesComponent sowohl die Liste der Helden als auch die Details des ausgewählten Helden an.\nAuf dieser Seite wirst du den ersten Schritt in diese Richtung machen, indem du die Heldendetails in eine separate, wiederverwendbare HeroDetailComponent verschiebst.\nDie HeroesComponent wird nur die Liste der Helden darstellen. Die HeroDetailComponent wird die Details eines ausgewählten Helden anzeigen.\n Die Beispielanwendung, die auf dieser Seite beschrieben wird, findest du unter dieser Seite.\n Erstelle die HeroDetailComponent Verwende das Angular CLI, um eine neue Komponente mit dem Namen hero-detail zu erstellen.\n1  ng generate component hero-detail   Der Befehl führt die folgenden Schritte aus:\n Erzeugt ein Verzeichnis src/app/hero-detail.  Innerhalb dieses Verzeichnisses werden vier Dateien generiert:\n Eine CSS-Datei für die Stile der Komponente. Eine HTML-Datei für die Komponententemplate. Eine TypeScript-Datei mit einer Komponentenklasse namens HeroDetailComponent. Eine Testdatei für die Klasse HeroDetailComponent.  Der Befehl fügt auch die HeroDetailComponent als Deklaration in den @NgModule Dekorator der src/app/app.module.ts Datei ein.\nSchreibe das Template Schneide das HTML für das Heldendetail aus dem unteren Teil der HeroesComponent- aus und füge es über die generierte Boilerplate in das HeroDetailComponent-Template ein.\nDas eingefügte HTML bezieht sich auf einen selectedHero. Die neue HeroDetailComponent kann jeden Helden darstellen, nicht nur einen ausgewählten Helden. Ersetze also “selectedHero” durch “hero” überall im Template.\nWenn du fertig bist, sollte das HeroDetailComponent-Template wie folgt aussehen:\nsrc/app/hero-detail/hero-detail.component.html\n1 2 3 4 5 6 7 8 9 10  \u003cdiv *ngIf=\"hero\"\u003e \u003ch2\u003e{{hero.name | uppercase}} Details\u003c/h2\u003e \u003cdiv\u003e\u003cspan\u003eid: \u003c/span\u003e{{hero.id}}\u003c/div\u003e \u003cdiv\u003e \u003clabel for=\"hero-name\"\u003eHero name: \u003c/label\u003e \u003cinput id=\"hero-name\" [(ngModel)]=\"hero.name\" placeholder=\"name\"\u003e \u003c/div\u003e \u003c/div\u003e   Hinzufügen der @Input() Hero-Eigenschaft das Template HeroDetailComponent bindet sich an die Eigenschaft Hero der Komponente die vom Typ Hero ist.\nÖffne die Klassendatei HeroDetailComponent und importiere das Symbol Hero.\nsrc/app/hero-detail/hero-detail.component.ts (import Hero)\n1  import { Hero } from '../hero';   Die Eigenschaft hero muss eine Input-Eigenschaft sein, annotiert mit dem @Input() Dekorator, denn die externe HeroesComponent wird sich wie folgt daran binden.\n1  \u003capp-hero-detail [hero]=\"selectedHero\"\u003e\u003c/app-hero-detail\u003e   Ändere die Importanweisung @angular/core, um das Symbol Input aufzunehmen.\nsrc/app/hero-detail/hero-detail.component.ts (import Input)\n1  import { Component, OnInit, Input } from '@angular/core';   Füge eine Eigenschaft “hero” hinzu, der der Dekorator “@Input()” vorangestellt ist.\nsrc/app/hero-detail/hero-detail.component.ts\n1  @Input() hero?: Hero;   Das ist die einzige Änderung, die du an der Klasse HeroDetailComponent vornehmen solltest. Es gibt keine weiteren Eigenschaften. Es gibt keine Präsentationslogik. Diese Komponente empfängt nur ein Heldenobjekt über die Eigenschaft hero und zeigt es an.\nDie HeroDetailComponent anzeigen Die HeroesComponent hat die Heldendetails selbständig angezeigt, bevor du diesen Teil des Templates entfernt hast. Dieser Abschnitt führt dich durch die Delegierung von Logik an die HeroDetailComponent.\nDie beiden Komponenten haben eine Eltern/Kind-Beziehung. Die übergeordnete Komponente HeroesComponent steuert die untergeordnete Komponente HeroDetailComponent indem sie ihr einen neuen Helden sendet, der angezeigt wird, wenn der Benutzer einen Helden aus der Liste auswählt.\nÄndere nicht die Klasse von HeroesComponent, ändere ihr Template.\nAktualisiere das HeroesComponent-Template Der HeroDetailComponent Selektor ist 'app-hero-detail'. Füge ein \u003capp-hero-detail\u003e Element in der Nähe des unteren Endes des HeroesComponent Template hinzu, wo die Helden-Detailansicht vorher war.\nBinde die HeroesComponent.selectedHero an die Eigenschaft hero des Elements wie folgt.\nheroes.component.html (HeroDetail binding)\n1  \u003capp-hero-detail [hero]=\"selectedHero\"\u003e\u003c/app-hero-detail\u003e   [hero]=\"selectedHero\" ist eine Angular-Eigenschaftsbindung(property binding).\nEs ist eine einfache Datenbindung von der “selectedHero”-Eigenschaft der “HeroComponent” an die “hero”-Eigenschaft des Zielelements, die der “hero”-Eigenschaft der “HeroDetailComponent” zugeordnet ist.\nWenn der Benutzer nun auf einen Helden in der Liste klickt, ändert sich der selectedHero. Wenn sich der selectedHero ändert, aktualisiert die Eigenschaftsbindung hero und die HeroDetailComponent zeigt den neuen Helden an.\nDas überarbeitete HeroesComponent-Template sollte wie folgt aussehen:\nheroes.component.html\n1 2 3 4 5 6 7 8 9 10 11  \u003ch2\u003eMy Heroes\u003c/h2\u003e \u003cul class=\"heroes\"\u003e \u003cli *ngFor=\"let hero of heroes\" [class.selected]=\"hero === selectedHero\" (click)=\"onSelect(hero)\"\u003e \u003cspan class=\"badge\"\u003e{{hero.id}}\u003c/span\u003e {{hero.name}} \u003c/li\u003e \u003c/ul\u003e \u003capp-hero-detail [hero]=\"selectedHero\"\u003e\u003c/app-hero-detail\u003e   Der Browser wird aktualisiert und die Anwendung funktioniert wieder wie zuvor.\nWas hat sich geändert? Wie vorher, wenn ein Benutzer auf einen Heldennamen klickt, erscheint das Heldendetail unterhalb der Heldenliste. Jetzt zeigt die HeroDetailComponent diese Details anstelle der HeroesComponent an.\nDas Refactoring der ursprünglichen HeroesComponent in zwei Komponenten bringt Vorteile, sowohl jetzt als auch in Zukunft:\n Du hast die Verantwortlichkeiten der HeroesComponent reduziert. Du kannst die HeroDetailComponent zu einem umfangreichen Helden-Editor weiterentwickeln ohne die übergeordnete HeroesComponent zu berühren. Du kannst die HeroesComponent weiterentwickeln, ohne die Helden-Detailansicht zu berühren. Du kannst die HeroDetailComponent im Template einer zukünftigen Komponente wiederverwenden.  Abschließende Code-Überprüfung Hier sind die auf dieser Seite besprochenen Codedateien.\n src/app/hero-detail/hero-detail.component.ts  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  import { Component, OnInit, Input } from '@angular/core'; import { Hero } from '../hero'; @Component({ selector: 'app-hero-detail', templateUrl: './hero-detail.component.html', styleUrls: ['./hero-detail.component.css'] }) export class HeroDetailComponent implements OnInit { @Input() hero?: Hero; constructor() { } ngOnInit() { } }   src/app/hero-detail/hero-detail.component.html  1 2 3 4 5 6 7 8 9 10  \u003cdiv *ngIf=\"hero\"\u003e \u003ch2\u003e{{hero.name | uppercase}} Details\u003c/h2\u003e \u003cdiv\u003e\u003cspan\u003eid: \u003c/span\u003e{{hero.id}}\u003c/div\u003e \u003cdiv\u003e \u003clabel for=\"hero-name\"\u003eHero name: \u003c/label\u003e \u003cinput id=\"hero-name\" [(ngModel)]=\"hero.name\" placeholder=\"name\"\u003e \u003c/div\u003e \u003c/div\u003e   src/app/heroes/heroes.component.html  1 2 3 4 5 6 7 8 9 10 11  \u003ch2\u003eMy Heroes\u003c/h2\u003e \u003cul class=\"heroes\"\u003e \u003cli *ngFor=\"let hero of heroes\" [class.selected]=\"hero === selectedHero\" (click)=\"onSelect(hero)\"\u003e \u003cspan class=\"badge\"\u003e{{hero.id}}\u003c/span\u003e {{hero.name}} \u003c/li\u003e \u003c/ul\u003e \u003capp-hero-detail [hero]=\"selectedHero\"\u003e\u003c/app-hero-detail\u003e   src/app/app.module.ts  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  import { BrowserModule } from '@angular/platform-browser'; import { NgModule } from '@angular/core'; import { FormsModule } from '@angular/forms'; import { AppComponent } from './app.component'; import { HeroesComponent } from './heroes/heroes.component'; import { HeroDetailComponent } from './hero-detail/hero-detail.component'; @NgModule({ declarations: [ AppComponent, HeroesComponent, HeroDetailComponent ], imports: [ BrowserModule, FormsModule ], providers: [], bootstrap: [AppComponent] }) export class AppModule { }   Zusammenfassung  Du hast eine separate, wiederverwendbare HeroDetailComponent erstellt. Du hast eine Eigenschaftsbindung verwendet, um der übergeordneten HeroesComponent Kontrolle über die untergeordnete HeroDetailComponent zu geben. Du hast den @Input decorator um die hero Eigenschaft für die Bindung durch die externe HeroesComponent ersetzt.  ","categories":"","description":"Alle Funktionen in einer Komponente zu halten, während die Anwendung wächst, ist nicht wartbar. Du wirst große Komponenten in kleinere Unterkomponenten aufteilen wollen, die jeweils auf eine bestimmte Aufgabe oder einen bestimmten Arbeitsablauf ausgerichtet sind.\n","excerpt":"Alle Funktionen in einer Komponente zu halten, während die Anwendung …","ref":"/docs/web/angular/05_4_feature_component/","tags":"","title":"Komponenten"},{"body":"Zuweisen von Farben Um einem Text eine Schriftfarbe zuzuweisen, ist folgendes eine Option:\n1 2 3 4  span { /*font color:*/ color: orange; }   Den Hintergrund von einem Element kann mit dem background-color-Property bestimmt werden:\n1 2 3 4  div { /*Color of the container*/ background-color: orange; }   Arten von Farben In den oberen Beispielen wurde die Farbe mit dem Wort orange bestimmt. Es gibt aber viele Arten, diese Farbe zu übergeben:\n via Color-Name: orange via RGB-Angaben (red green blue): rgb(255,165,0) via hexadezimalen Wert (HEX color): #ffa500  Es gibt noch weitere Möglichkeiten. Du findest diese hier: https://www.w3schools.com/colors/default.asp\nDie folgende CSS-Regel setzt die Schriftfarbe auf Orange. Nur eine dieser 3 Regeln wird benötigt:\n1 2 3 4 5  .orange { color: orange; color: rgb(255,165,0); color: #ffa500; }   Da diese Farbe in CSS bereits einen Namen hat (\"orange\"), wird hier die Angabe via Farbnamen empfohlen.\nObwohl die Angabe mit RGB in CSS möglich ist, sieht man in der Webentwicklung häufiger die hexadezimale Schreibweise.\nNachfolgend sind diese 3 Varianten genauer beschrieben.\nVia Color-Name Am lesbarsten ist die Angabe der Farben via Namen. Es werden mindestens 140 Farben mit Namen unterstützt. Häufig verwendete Farben sind z.B.:\n black white gray (American) oder grey (British), lightgray blue, lightblue cornflowerblue red orange yellow  Hier findest du eine Liste der Farben: https://www.w3schools.com/colors/colors_names.asp\nvia RGB RGB steht für Rot-Grün-Blau. Wenn man die Farben via RGB angibt, so gibt man an, wie intensiv jede dieser 3 Farben in der gewünschten Farbe vorkommt. 0 bedeutet, dass die Farbe nicht vorkommt, 255 bedeutet hingegen, dass die Farbe zu 100% gebraucht wird.\nFolgende RGB-Werte solltest du als Informatiker:in kennen:\n   Name RGB     red rgb(255, 0, 0)   green rgb(0, 255, 0)   blue rgb(0, 0, 255)   yellow rgb(255, 255, 0)   white rgb(255, 255, 255)   black rgb(0, 0, 0)    In RGB (oder HEX) gibts du Farben an, die der Browser nicht per Namen kennt. Ein Beispiel hierfür wäre die Farbe ‘amber’, die es leider noch nicht in die offizielle Liste geschafft hat.\nMöchtest du herausfinden, wie der RGB- oder HEX-Wert einer Farbe ist, so kannst du dafür Online-Tools wie https://www.color-hex.com/color-names.html verwenden. Dort kannst du den Namen der Farbe eingeben und dann kannst du nachschauen, wie diese Werte für diese Farben sind. Im Beispiel der Farbe ‘amber’ erhälst du folgende Werte:\n   Name RGB HEX     amber rgb(255, 191, 0) #ffbf00    via HEX color Am häufigsten werden im Web die Farben via Hex color angegeben.\nFarben in hexadezimale sind auch in RGB angegeben, wobei jeder dieser 3 Farben 2 Stellen in diesem Code ausmachen.\nKennen solltest du sicher:\n   Farbe HEX color     red #ff0000 oder #f00   grenn #00ff00 oder #0f0   blue #0000ff oder #00f   yellow #ffff00 oder #ff0   white #ffffff oder #fff   black #000000 oder #000   gray #808080    Wenn bei allen Farben die beiden Ziffern gleich sind, dann kann bei jeder Farbe die zweite Ziffer weggelassen werden (siehe Tabelle).\n","categories":"","description":"Arten, um Farben anzugeben.\n","excerpt":"Arten, um Farben anzugeben.\n","ref":"/docs/web/html_css/14_css_colors/","tags":"","title":"Farben"},{"body":"Dienste hinzufügen Die Tour of Heroes HeroesComponent holt sich derzeit falsche Daten und zeigt sie an.\nNach dem Refactoring in diesem Tutorial wird HeroesComponent schlank sein und sich auf die Unterstützung der Ansicht konzentrieren. Es wird auch einfacher sein, Unit-Tests mit einem Mock-Service durchzuführen.\n Die Beispielanwendung, die auf dieser Seite beschrieben wird, finden Sie unter dieser Seite.\n Warum Dienste Komponenten sollten keine Daten direkt abrufen oder speichern und schon gar nicht wissentlich gefälschte Daten präsentieren. Du solltest dich auf die Darstellung von Daten konzentrieren und den Datenzugriff an einen Dienst delegieren.\nIn diesem Tutorial wirst du einen HeroService erstellen, den alle Anwendungsklassen verwenden können, um Helden zu erhalten. Anstatt diesen Dienst mit dem Schlüsselwort New zu erstellen, wirst du dich auf Angular dependency injection beziehen um ihn in den HeroesComponent-Konstruktor zu injizieren.\nDienste sind eine großartige Möglichkeit, Informationen zwischen Klassen auszutauschen, die sich nicht kennen. Du erstellst einen MessageService und injizieren ihn an zwei Stellen.\n Injektion in HeroService, der den Dienst verwendet, um eine Nachricht zu senden. Injizieren in MessagesComponent, das diese Nachricht anzeigt und auch die ID anzeigt, wenn der Benutzer auf einen Helden klickt.  Erstelle den HeroService Erstelle mit dem Angular CLI einen Dienst namens Hero.\n1  ng generate service hero   Der Befehl erzeugt eine Skelettklasse HeroService in src/app/hero.service.ts wie folgt:\nsrc/app/hero.service.ts (new service)\n1 2 3 4 5 6 7 8 9 10  import { Injectable } from '@angular/core'; @Injectable({ providedIn: 'root', }) export class HeroService { constructor() { } }   @Injectable() Dienste Beachte, dass der neue Dienst das Angular Injectable Symbol importiert und die Klasse mit dem die Klasse mit dem Dekorator @Injectable() annotiert. Dies kennzeichnet die Klasse als eine, die am dependency injection system teilnimmt. Die Klasse HeroService wird einen injizierbaren Dienst bereitstellen, und sie kann auch ihre eigenen injizierten Abhängigkeiten haben. Sie hat noch keine Abhängigkeiten, aber sie wird bald eine haben.\nDer @Injectable() Dekorator akzeptiert ein Metadaten Objekt für den Dienst, auf die gleiche Weise wie der @Component() Dekorator es für Ihre Komponentenklassen tat.\nHeldendaten erhalten Der HeroService kann Hero-Daten von überall her bekommen—ein Web-Service, lokaler Speicher oder eine Mock-Datenquelle.\nWenn du den Datenzugriff aus den Komponenten entfernst, kannst du die Meinung über die Implementierung jederzeit ändern, ohne die Komponenten zu berühren.\nDie Implementierung in diesem Tutorial wird weiterhin mock heroes liefern.\nImportiere den Hero und HEROES.\nsrc/app/hero.service.ts\n1 2  import { Hero } from './hero'; import { HEROES } from './mock-heroes';   Füge eine Methode getHeroes hinzu, um die mock heroes zurückzugeben.\nsrc/app/hero.service.ts\n1 2 3  getHeroes(): Hero[] { return HEROES; }   Bereitstellen des HeroService Du musst den HeroService für das Dependency Injection System verfügbar machen bevor Angular ihn in die HeroesComponent injizieren kann, indem ein Provider registriert wird. Ein Provider ist etwas, das einen Dienst erstellen oder liefern kann; in diesem Fall instanziiert er die HeroService Klasse, um den Dienst bereitzustellen.\nUm sicherzustellen, dass der HeroService diesen Dienst bereitstellen kann, registriere ihn mit dem injector.\nStandardmäßig registriert der Angular CLI-Befehl ng generate service einen Provider mit dem root injector für deinen Service, indem er Provider-Metadaten, also providedIn: 'root' in den @Injectable() Dekorator einfügt.\n1 2 3  @Injectable({ providedIn: 'root', })   Wenn man den Dienst auf der Root-Ebene bereitstellt, erstellt Angular eine einzelne, gemeinsame Instanz von HeroService und injiziert sie in jede Klasse, die danach fragt. Die Registrierung des Providers in den @Injectable-Metadaten erlaubt es Angular auch, eine Anwendung zu optimieren, indem der Service entfernt wird, wenn er doch nicht gebraucht wird.\n Um mehr über Provider zu erfahren, lese den Abschnitt Providers. Weitere Informationen über Injektoren findest du im Dependency Injection guide.\n Der HeroService ist nun bereit, in die HeroesComponent eingebunden zu werden.\nSofern Git Bash nicht gewählt werden kann, könnte es daran liegen, dass du die IDE neustarten musst. Dies ist ein vorläufiges Codebeispiel, das es Ihnen ermöglicht, den HeroService bereitzustellen und zu verwenden. An diesem Punkt wird sich der Code vom HeroService in der “final code review” unterscheiden.\nUpdate HeroesComponent Öffne die Klassendatei HeroesComponent.\nLösche den HEROES-Import, da du diesen nicht mehr benötigst. Importiere stattdessen den HeroService.\nsrc/app/heroes/heroes.component.ts (import HeroService)\n1  import { HeroService } from '../hero.service';   Ersetze die Definition der Eigenschaft “heroes” durch eine Deklaration.\nsrc/app/heroes/heroes.component.ts\n1  heroes: Hero[] = [];   Inject the HeroService Füge einen privaten heroService Parameter vom Typ HeroService zum Konstruktor hinzu.\nsrc/app/heroes/heroes.component.ts\n1  constructor(private heroService: HeroService) {}   Der Parameter definiert gleichzeitig eine private heroService-Eigenschaft und identifiziert sie als HeroService-Injektionsstelle.\nWenn Angular eine HeroesComponent erstellt, setzt das Dependency Injection System setzt den heroService Parameter auf die Singleton Instanz von HeroService.\nHinzufügen von getHeroes() Erstellen eine Methode, um die Helden aus dem Service abzurufen.\nsrc/app/heroes/heroes.component.ts\n1 2 3  getHeroes(): void { this.heroes = this.heroService.getHeroes(); }   Aufruf in ngOnInit() Obwohl du getHeroes() im Konstruktor aufrufen kannst, ist das nicht die beste Praxis.\nReserviere den Konstruktor für eine minimale Initialisierung, wie z.B. die Verknüpfung von Konstruktorparametern mit Eigenschaften. Der Konstruktor sollte nichts tun. Er sollte sicherlich keine Funktion aufrufen, die HTTP-Anfragen an einen entfernten Server stellt, wie es ein echter Datendienst tun würde.\nRufe stattdessen getHeroes() innerhalb des ngOnInit lifecycle hook auf und Angular ngOnInit() zu einem geeigneten Zeitpunkt nach der Erstellung einer HeroesComponent-Instanz aufrufen lassen.\nsrc/app/heroes/heroes.component.ts\n1 2 3  ngOnInit() { this.getHeroes(); }   Sehen, wie es läuft Nachdem der Browser aktualisiert wurde, sollte die Anwendung wie zuvor laufen, Es zeigt eine Liste der Helden und eine Detailansicht des Helden an, wenn du auf den Namen eines Helden klickst.\nBeobachtbare Daten Die Methode HeroService.getHeroes() hat eine synchrone Signatur, was bedeutet, dass der HeroService Helden synchron abrufen kann. Die HeroesComponent verbraucht das getHeroes() Ergebnis als ob Helden synchron geholt werden könnten.\nsrc/app/heroes/heroes.component.ts\n1  this.heroes = this.heroService.getHeroes();   Dies wird in einer echten Anwendung nicht funktionieren. Im Moment kommst du noch damit durch, weil der Dienst derzeit mock heroes zurückgibt. Aber bald wird die Anwendung Helden von einem entfernten Server abrufen, was von Natur aus ein asynchroner Vorgang ist.\nDer HeroService muss auf die Antwort des Servers warten, getHeroes() kann nicht sofort mit Heldendaten zurückkehren, und der Browser wird nicht blockieren, während der Dienst wartet.\nDie Funktion HeroService.getHeroes() muss eine asynchrone Signatur irgendeiner Art haben.\nIn diesem Tutorial wird HeroService.getHeroes() ein Observable zurückgeben zurück, weil es schließlich die Angular-Methode HttpClient.get verwenden wird, um die Helden zu holen und HttpClient.get() gibt ein Observable zurück.\nObservable HeroService Observable\" ist eine der Schlüsselklassen in der RxJS-Bibliothek.\nIn einem späteren Tutorial über HTTP wirst du lernen, dass die HttpClient-Methoden von Angular RxJS Observable zurückgeben. In diesem Tutorial wirst du das Abrufen von Daten vom Server mit der RxJS-Funktion “of()” simulieren.\nÖffne die Datei HeroService und importiere die Symbole Observable und of von RxJS.\nsrc/app/hero.service.ts (Observable imports)\n1  import { Observable, of } from 'rxjs';   Ersetze die Methode getHeroes() durch die folgende:\nsrc/app/hero.service.ts\n1 2 3 4  getHeroes(): Observable\u003cHero[]\u003e { const heroes = of(HEROES); return heroes; }   of(HEROES) gibt ein Observable\u003cHero[]\u003e zurück, das einen einzelnen Wert, das Array der Mock-Helden, ausgibt.\n Im HTTP-Tutorial rufe HttpClient.get\u003cHero[]\u003e() auf, das ebenfalls ein Observable\u003cHero[]\u003e zurückgibt, das einen einzelnen Wert, ein Array von Helden aus dem Body der HTTP-Antwort, ausgibt.\n Abonnieren in HeroesComponent Die Methode HeroService.getHeroes gab früher einen Hero[] zurück. Jetzt gibt sie ein Observable\u003cHero[]\u003e zurück.\nDu musst dich an diesen Unterschied in HeroesComponent anpassen.\nSuche die Methode getHeroes und ersetze sie durch den folgenden Code. heroes.component.ts (Observable)\n1 2 3 4  getHeroes(): void { this.heroService.getHeroes() .subscribe(heroes =\u003e this.heroes = heroes); }   heroes.component.ts (Original)\n1 2 3  getHeroes(): void { this.heroes = this.heroService.getHeroes(); }   Observable.subscribe() ist der entscheidende Unterschied.\nDie bisherige Version weist der Eigenschaft heroes der Komponente ein Array von Helden zu. Die Zuweisung erfolgt synchron, als ob der Server die Helden sofort zurückgeben könnte oder der Browser könnte die Benutzeroberfläche einfrieren, während er auf die Antwort des Servers wartete.\nDas funktioniert aber nicht, wenn der HeroService tatsächlich Anfragen an einen entfernten Server stellt.\nDie neue Version wartet darauf, dass der Observable das Array der Helden ausgibt—was könnte jetzt oder in einigen Minuten geschehen. Die Methode subscribe() übergibt das ausgegebene Array an den Callback, der die Eigenschaft Helden der Komponente setzt.\nDieser asynchrone Ansatz wird funktionieren wenn der HeroService Helden vom Server anfordert.\nNachrichten anzeigen Dieser Abschnitt führt dich durch die folgenden Schritte:\n Hinzufügen einer MessagesComponent, die Anwendungsnachrichten am unteren Rand des Bildschirms anzeigt Erstellen eines injizierbaren, app-weiten MessageService zum Senden von Nachrichten, die angezeigt werden sollen Injizieren von MessageService in den HeroService. Anzeige einer Nachricht, wenn HeroService erfolgreich Helden holt  Erstellen der MessagesComponent Verwende die CLI, um die MessagesComponent zu erstellen.\n1  ng generate component messages   Das CLI erstellt die Komponentendateien im Ordner src/app/messages und deklariert die MessagesComponent im AppModule.\nÄndere das Template AppComponent, um die erzeugte MessagesComponent anzuzeigen.\nsrc/app/app.component.html\n1 2 3  \u003ch1\u003e{{title}}\u003c/h1\u003e \u003capp-heroes\u003e\u003c/app-heroes\u003e \u003capp-messages\u003e\u003c/app-messages\u003e   Du solltest den Standardabsatz von MessagesComponent unten auf der Seite sehen.\nErstelle den MessageService Verwende die CLI, um den MessageService in src/app zu erstellen.\n1  ng generate service message   Öffne MessageService und ersetze dessen Inhalt durch den folgenden.\nsrc/app/message.service.ts\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  import { Injectable } from '@angular/core'; @Injectable({ providedIn: 'root', }) export class MessageService { messages: string[] = []; add(message: string) { this.messages.push(message); } clear() { this.messages = []; } }   Der Dienst stellt seinen Cache von Nachrichten und zwei Methoden zur Verfügung: eine, um Add() eine Nachricht zum Cache hinzuzufügen und eine andere, um Clear() den Cache zu löschen.\nInjiziere ihn in den HeroService. In HeroService importiere den MessageService.\nsrc/app/hero.service.ts (import MessageService)\n1  import { MessageService } from './message.service';   Ändere den Konstruktor mit einem Parameter, der eine private Eigenschaft messageService deklariert. Angular wird das Singleton MessageService in diese Eigenschaft injizieren wenn es den HeroService erstellt.\nsrc/app/hero.service.ts\n1  constructor(private messageService: MessageService) { }    Dies ist ein typisches “Service-in-Service\"-Szenario: Man injiziert den MessageService in den HeroService, der wiederum in die HeroesComponent injiziert wird.\n Senden einer Nachricht von HeroService Ändere die Methode getHeroes(), um eine Nachricht zu senden, wenn die Helden abgeholt werden.\nsrc/app/hero.service.ts\n1 2 3 4 5  getHeroes(): Observable\u003cHero[]\u003e { const heroes = of(HEROES); this.messageService.add('HeroService: fetched heroes'); return heroes; }   Anzeige der Nachricht von HeroService Die MessagesComponent sollte alle Nachrichten anzeigen, einschließlich der Nachricht, die vom HeroService gesendet wird, wenn er Helden holt.\nÖffne MessagesComponent und importiere den MessageService.\nsrc/app/messages/messages.component.ts (import MessageService)\n1  import { MessageService } from '../message.service';   Modifiziere den Konstruktor mit einem Parameter, der eine öffentliche Eigenschaft messageService deklariert. Angular wird das Singleton MessageService in diese Eigenschaft injizieren wenn es die MessagesComponent erstellt.\nsrc/app/messages/messages.component.ts\n1  constructor(public messageService: MessageService) {}   Die Eigenschaft messageService muss öffentlich sein, weil du in im Template daran binden wirst.\nAngular bindet nur an öffentliche Komponenteneigenschaften.\nBindung an den MessageService Ersetze das CLI-generierte MessagesComponent Template durch das folgende.\nsrc/app/messages/messages.component.html\n1 2 3 4 5 6 7 8  \u003cdiv *ngIf=\"messageService.messages.length\"\u003e \u003ch2\u003eMessages\u003c/h2\u003e \u003cbutton class=\"clear\" (click)=\"messageService.clear()\"\u003eClear messages\u003c/button\u003e \u003cdiv *ngFor='let message of messageService.messages'\u003e {{message}} \u003c/div\u003e \u003c/div\u003e   Dieses Template bindet direkt an den messageService der Komponente.\n  Das *ngIf zeigt den Nachrichtenbereich nur an, wenn es Nachrichten zu zeigen gibt.\n  Ein *ngFor stellt die Liste der Nachrichten in wiederholten \u003cdiv\u003e Elementen dar.\n  Ein Angular event-binding bindet das Click-Ereignis der Schaltfläche an MessageService.clear().\n  Die Nachrichten werden besser aussehen, wenn du die privaten CSS-Stile zu messages.component.css hinzufügst wie in einem der “final code review” Tabs unten aufgeführt.\nHinzufügen zusätzlicher Nachrichten zum Heldendienst Das folgende Beispiel zeigt, wie man jedes Mal, wenn der Benutzer auf einen Hero klickt, eine Nachricht sendet und anzeigt. einen Hero klickt, eine Nachricht sendet und anzeigt, die einen Verlauf der Auswahl des Benutzers anzeigt. Dies wird hilfreich sein, wenn du zum nächsten Abschnitt über Routing liest.\nsrc/app/heroes/heroes.component.ts\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  import { Component, OnInit } from '@angular/core'; import { Hero } from '../hero'; import { HeroService } from '../hero.service'; import { MessageService } from '../message.service'; @Component({ selector: 'app-heroes', templateUrl: './heroes.component.html', styleUrls: ['./heroes.component.css'] }) export class HeroesComponent implements OnInit { selectedHero?: Hero; heroes: Hero[] = []; constructor(private heroService: HeroService, private messageService: MessageService) { } ngOnInit() { this.getHeroes(); } onSelect(hero: Hero): void { this.selectedHero = hero; this.messageService.add(`HeroesComponent: Selected hero id=${hero.id}`); } getHeroes(): void { this.heroService.getHeroes() .subscribe(heroes =\u003e this.heroes = heroes); } }   Aktualisiere den Browser, um die Liste der Helden zu sehen, und scrolle nach unten, um die Nachrichten vom HeroService zu sehen. Jedes Mal, wenn du auf einen Helden klickst, erscheint eine neue Nachricht, die die Auswahl darstellt. Verwende die Schaltfläche Nachrichten löschen, um den Nachrichtenverlauf zu löschen.\nAbschließende Code-Überprüfung Hier oder hier sind die auf dieser Seite besprochenen Codedateien.\nZusammenfassung  Du hast den Datenzugriff auf die Klasse HeroService umstrukturiert. Du hast den HeroService als Provider seines Dienstes auf der Root-Ebene registriert, so dass er überall in der Anwendung injiziert werden kann. Du hast Angular Dependency Injection verwendet, um ihn in eine Komponente zu injizieren. Du hast der get data Methode von HeroService eine asynchrone Signatur gegeben. Du hast Observable und die RxJS Observable Bibliothek entdeckt. Du hast RxJS of() benutzt, um ein Observable von Mock-Helden (Observable\u003cHero[]\u003e) zurückzugeben. Der Lifecycle-Hook ngOnInit der Komponente ruft die Methode HeroService auf, nicht den Konstruktor. Du hast einen MessageService für lose gekoppelte Kommunikation zwischen Klassen erstellt. Der HeroService, der in eine Komponente injiziert wird, wird mit einem anderen injizierten Dienst erstellt, MessageService.  ","categories":"","description":"","excerpt":"Dienste hinzufügen Die Tour of Heroes HeroesComponent holt sich …","ref":"/docs/web/angular/05_5_services_hinzuf%C3%BCgen/","tags":"","title":"Services"},{"body":"Block- und Inline-Elemente Bevor wir Elemente dimensionieren, müssen wir wissen, welche Elemente wir überhaupt dimensionieren können.\nIn CSS gibt es zwei grundlegende “Display”-Elemente:\n Block-Elemente Inline-Elemente  Im Normalfall können wir nur Block-Elemente dimensionieren (eine Grösse geben). Was ist aber nun der Unterschied zwischen den beiden?\nBlock-Elemente Block-Elemente starten im Normalfall immer auf einer neuen Zeile und haben per Default um sich selbst herum einen Abstand zu anderen Elementen.\nBlock-Elemente beanspruchen per Default die volle Breite an Platz (von links bis rechts).\nTypische Block-Elemente sind\n \u003cp\u003e \u003cdiv\u003e \u003caddress\u003e \u003carticle\u003e \u003caside\u003e \u003cblockquote\u003e \u003ccanvas\u003e \u003cdiv\u003e \u003cfooter\u003e \u003cform\u003e \u003ch1\u003e-\u003ch6\u003e \u003cheader\u003e \u003chr\u003e \u003cmain\u003e \u003cnav\u003e \u003cnoscript\u003e \u003col\u003e, \u003cul\u003e, \u003cdd\u003e, \u003cdl\u003e, \u003cdt\u003e, \u003cli\u003e \u003cpre\u003e \u003csection\u003e \u003ctable\u003e  Um das zu verstehen, probiere bitte diesen Code aus:\n1 2 3 4 5 6 7 8 9 10  \u003cp\u003eNur ein Paragraph\u003c/p\u003e \u003cp\u003eEin Paragraph mit einem \u003cspan\u003eSpan\u003c/span\u003e.\u003c/p\u003e \u003cstyle\u003e p { background-color: red; } span { background-color: yellow; } \u003c/style\u003e   Dieser Code zeigt gut, dass das Block-Element (hier \u003cp\u003e) die ganze Breite (abzüglich eines kleinen Randes) eingenommen hat, während das \u003cspan\u003e sich auf das Wort beschränkt.\nInline-Elemente Im obigen Beispiel hast du bereits ein Inline-Element kennengelernt: \u003cspan\u003e.\nInline-Elemente kommen meistens in einem Text vor. Inline-Elemente benötigen nur so viel Platz wie nötig. Als grossen Unterschied zu Block-Elementen, beginnen Inline-Elemente nicht auf einer neuen Zeile.\nTypische Inline-Elemente sind:\n \u003ca\u003e \u003cb\u003e \u003cbr\u003e \u003cbutton\u003e \u003ccode\u003e \u003cdfn\u003e \u003cem\u003e \u003ci\u003e \u003cimg\u003e \u003cinput\u003e \u003clabel\u003e \u003cscript\u003e \u003cselect\u003e \u003csmall\u003e \u003cspan\u003e \u003cstrong\u003e \u003ctextarea\u003e \u003ctime\u003e  Und wichtig zu wissen ist, dass sich keine Block-Elemente in einem Inline-Element befinden dürfen.\nBlock-Elemente dimensionieren Bei Block-Elementen kannst du die Grösse verändern:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u003cdiv class=\"box\"\u003e \u003cp\u003eInside the first Box\u003c/p\u003e \u003c/div\u003e \u003cdiv class=\"box\"\u003e \u003cp\u003eInside the second Box\u003c/p\u003e \u003c/div\u003e \u003cstyle\u003e div.box { /*display: block;*/ width: 10em; height: 10em; background-color: cornflowerblue; } \u003c/style\u003e   Wenn du diesen Code ausprobierst, siehst du zwei hellblaue Quadrate untereinander. Mit dem width-Property definiert man die Breite und mit dem height die Höhe. Hiermit haben wir dem \u003cdiv class=\"box\"\u003e eine Höhe und Breite von 10em gegeben.\nEinheiten (Units) Im vorherigen Beispiel haben wir dem Quadrat eine Seitenlänge von 10em gegeben. Was sind aber em?\n1em entspricht der Schriftgrösse des aktuellen Elements. Gibt man einem Text zum Beispiel font-size: 2em, so definiert man, dass die Schriftgrösse doppelt so gross sein soll wie beim übergeordneten Element. Somit ist die Grösseneinheit em proportional zur aktuellen Schriftgrösse.\nStatt em kann man auch rem verwenden: rem ist im Prinzip das Gleiche wie em, nur dass es relativ zur Schriftgrösse des root-Elements ist (statt dem aktuellen Element). Somit ist rem auf der ganzen Seite immer gleich gross, em nicht.\nFür Seiten im Browser verwendet man besser relative Einheiten wie em oder rem. Aber dennoch kommt man oft nicht an der absoluten Einheit px vorbei:\nOft möchte man z.B. den dünnsten möglichen Rand um ein Element von einem Pixel haben. In diesem Fall würde man die Breite des Randes (Borders) gleich 1px setzen. Die Regel könnte so aussehen:\n1 2 3 4  div.box { ... border: 1px solid black; }   Dieses Beispiel fügt einen schwarzen Rand von 1px Breite hinzu. Das solid bedeutet, dass es eine normale Linie sein soll (also nicht gestrichtelt o.ä.).\nEinheiten in der Übersicht Grundsätzlich empfehle ich dir diese Übersicht: https://www.w3schools.com/cssref/css_units.asp\nUnter den absoluten Einheiten musst du nur folgende kennen:\n px  Die absoluten Einheiten sollten immer gleich gross sein. Sie sind aber nicht speziell für im Browser geeignet, weil sich die Bildschirmgrössen der Enduser stark unterscheiden.\nVon den relativen Einheiten solltest du mehrere kennen:\n   Einheit Beschreibung     em, rem Längeneinheit relativ zur Schriftgrösse des aktuellen bzw. des root-Elements   vw 1vw = 1% von der Weite des ViewPorts (angezeigter Teil der Browser-Seite)   vh 1vh = 1% von der Höhe des ViewPorts (angezeigter Teil der Browser-Seite)   % Relativ zum Parent. width: 50% bedeutet z.B., dass das Element halb so breit wie das übergeordnete Element sein soll. % funktioniert gut im Zusammenhang mit Breiten, aber nicht immer so gut im Zusammenhang mit Höhen.    Wenn du noch mehr über Einheiten erfahren möchtest, dann schaue dir bitte diese Seite an: https://web.dev/learn/css/sizing/\nBlock-Elemente weiter dimensionieren (Box Model) Wir haben bereits CSS-Properties wie width, height, border verwendet. Nun wird es Zeit zu verstehen, wie diese Werte die Dimensionen von Block-Elementen beeinflussen. Probiere dieses Beispiel aus:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  \u003cdiv class=\"box\"\u003e \u003cp\u003eInside the first Box\u003c/p\u003e \u003c/div\u003e \u003cdiv class=\"box\"\u003e \u003cp\u003eInside the second Box\u003c/p\u003e \u003cp class=\"half-width\"\u003eHalbe Breite\u003c/p\u003e \u003c/div\u003e \u003cstyle\u003e div.box { /*display: block;*/ width: 10em; height: 10em; background-color: cornflowerblue; } .half-width { width: 50%; background-color: white; border: 2em solid gray; } \u003c/style\u003e   Du wirst sehen, dass das weisse Feld mit “Halbe Breite” die halbe Breite der übergeordneten Box beansprucht. Zusammen mit dem Rand macht das aber mehr als die Hälfte aus! Somit schauen wir uns das Box-Modell in CSS an:\nDie “Content Box” ist so zu sagen der Inhalt des Block-Elements. Die “Border Box” ist der Rahmen des Elements. Als wir die width gesetzt hatten, haben wir die Breite des Content Box gesetzt. Oft wollen wir aber, dass die Box inkl. Rand 50% der Breite einnimmt. Hierfür gibt es mehrere Möglichkeiten:\nTheoretisch könnten wir die Weite mit einer Berechnung herbeibasteln, indem wir einfach den Rand von der Breite wegsubtrahieren:\n1 2 3 4  .half-width { width: calc(50% - 2 * 2em); ... }   Dies sieht in den meisten Fällen unnötig kompliziert aus. Und dafür gibt es eine Abkürzung:\n1 2 3 4 5  .half-width { box-sizing: border-box; width: 50%; ... }   Auf diese Weise nimmt die Box nur noch 50% der Breite insgesamt ein (inkl. Border). Der Default für box-sizing ist content-box.\nZur Vertiefung des Box Models kannst du gerne diese Seite studieren: https://web.dev/learn/css/box-model/.\nAbstände Abstände zu anderen Elementen (Margin) Ziemlich oft möchtest du, dass Elemente untereinander einen Abstand haben. Genau dafür gibt es margin. Spiele mit diesem Wert ein bisschen herum:\n1 2 3 4  div.box { ... margin: 2em; }   Du kannst die Abstände auch in jede Richtung einstellen:\n1  margin: 1em 2em 3em 4px;   was äquivalent zu dem ist:\n1 2 3 4  margin-top: 1em; margin-right: 2em; margin-bottom: 3em; margin-left: 4px;   Beachte bei der kurzen Schreibweise, dass es oben beginnt und im Uhrzeigersinn weitergeht, bzw. merke dir “TRouBLe” (Top Right Bottom Left).\nAbstand vom Border zum Content (Padding) Oft sieht es hässlich aus, wenn der Text direkt am Rand (am Border) ankommt. Das kann behoben werden, indem ein innerer Rand (Padding) eingefügt wird:\n1 2 3 4 5 6 7 8  .half-width { padding: 0.5em; ... box-sizing: border-box; width: 73%; background-color: white; border: 7px solid gray; }   Beachte, dass bei einer Angabe wie width: 40% mit box-sizing: content-box die Weite sich nur auf den Content bezieht. Das Padding kommt in diesem Beispiel zu den 40% noch hinzu!\n","categories":"","description":"Dimensionierung von (Inline-)Block-Elementen mit CSS.\nAuf dieser Seite erfährst du, wie du die Grössen von Elementen definierst.\n","excerpt":"Dimensionierung von (Inline-)Block-Elementen mit CSS.\nAuf dieser Seite …","ref":"/docs/web/html_css/15_css_sizing/","tags":"","title":"Sizing"},{"body":"Navigation mit Routing hinzufügen Es gibt neue Anforderungen für die Tour of Heroes-App:\n Hinzufügen einer Dashboard-Ansicht. Hinzufügen der Möglichkeit, zwischen den Ansichten Helden und Dashboard zu navigieren. Wenn Benutzer auf einen Heldennamen in einer der beiden Ansichten klicken, navigiere zu einer Detailansicht des ausgewählten Helden. Wenn Benutzer auf einen tiefen Link in einer E-Mail klicken, wird die Detailansicht für einen bestimmten Helden geöffnet.   Die Beispielanwendung, die auf dieser Seite beschrieben wird, findest du unter dieser Seite.\n Wenn du fertig bist, können die Benutzer wie folgt durch die Anwendung navigieren:\nHinzufügen des AppRoutingModule In Angular ist es die beste Praxis, den Router in einem separaten Modul auf oberster Ebene zu laden und zu konfigurieren zu laden und zu konfigurieren, das dem Routing gewidmet ist und von der Wurzel AppModule importiert wird.\nKonventionell heißt die Modulklasse AppRoutingModule und gehört in die app-routing.module.ts im Ordner src/app.\nVerwende die CLI, um es zu erzeugen.\n1  ng generate module app-routing --flat --module=app    --flat legt die Datei in src/app statt in ihrem eigenen Ordner ab.\n--module=app weist die CLI an, sie im imports-Array des AppModule zu registrieren.\n Die generierte Datei sieht wie folgt aus:\nsrc/app/app-routing.module.ts (generated)\n1 2 3 4 5 6 7 8 9 10  import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; @NgModule({ imports: [ CommonModule ], declarations: [] }) export class AppRoutingModule { }   Ersetze es durch das folgende:\nsrc/app/app-routing.module.ts (updated)\n1 2 3 4 5 6 7 8 9 10 11 12 13  import { NgModule } from '@angular/core'; import { RouterModule, Routes } from '@angular/router'; import { HeroesComponent } from './heroes/heroes.component'; const routes: Routes = [ { path: 'heroes', component: HeroesComponent } ]; @NgModule({ imports: [RouterModule.forRoot(routes)], exports: [RouterModule] }) export class AppRoutingModule { }   Zunächst importiert die Datei “app-routing.module.ts” die Module RouterModule und Routes, damit die Anwendung über Routing-Funktionen verfügt. Der nächste Import, HeroesComponent, gibt dem Router einen Platz, wo er hingehen kann, sobald du die Routen konfiguriert hast.\nBeachte, dass die CommonModule Referenzen und das declarations Array unnötig sind, also nicht mehr Teil von nicht mehr Teil des AppRoutingModule sind. Die folgenden Abschnitte erklären den Rest des AppRoutingModule im Detail.\nRoutes Im nächsten Teil der Datei konfigurierst du deine Routen. Routen teilen dem Router mit, welche Ansicht angezeigt werden soll, wenn ein Benutzer auf einen Link klickt oder eine URL in die Adresszeile des Browsers einfügt.\nDa app-routing.module.ts bereits HeroesComponent importiert, kannst du es im Array routes verwenden:\nsrc/app/app-routing.module.ts\n1 2 3  const routes: Routes = [ { path: 'heroes', component: HeroesComponent } ];   Eine typische Angular Route hat zwei Eigenschaften:\n path: ein String, der mit der URL in der Adressleiste des Browsers übereinstimmt. Komponente\": die Komponente, die der Router erstellen soll, wenn er zu dieser Route navigiert.  Dies weist den Router an, diese URL mit “path: ‘heroes’” abzugleichen und die HeroesComponent anzuzeigen, wenn die URL etwa localhost:4200/heroes lautet.\nRouterModule.forRoot() Die @NgModule-Metadaten initialisieren den Router und lassen ihn auf Standortänderungen des Browsers warten.\nDie folgende Zeile fügt das RouterModule zum AppRoutingModule imports Array hinzu und konfiguriert es mit den Routen in einem Schritt durch den Aufruf RouterModule.forRoot():\nsrc/app/app-routing.module.ts\n1  imports: [ RouterModule.forRoot(routes) ],    Die Methode heißt forRoot(), weil du den Router auf der Root-Ebene der Anwendung konfigurierst. Die Methode forRoot() liefert die für das Routing benötigten Service Provider und Direktiven, und führt die anfängliche Navigation auf der Grundlage der aktuellen Browser-URL durch.\n Als nächstes exportiert AppRoutingModule das RouterModule, damit es in der gesamten Anwendung verfügbar ist.\nsrc/app/app-routing.module.ts\n1  exports: [ RouterModule ]   Hinzufügen von RouterOutlet Öffne das Template AppComponent und ersetze das Element \u003capp-heroes\u003e durch ein Element \u003crouter-outlet\u003e.\nsrc/app/app.component.html (router-outlet)\n1 2 3  \u003ch1\u003e{{title}}\u003c/h1\u003e \u003crouter-outlet\u003e\u003c/router-outlet\u003e \u003capp-messages\u003e\u003c/app-messages\u003e   Das Template “AppComponent” benötigt kein \u003capp-heroes\u003e mehr, da die Anwendung die “HeroComponent” nur anzeigt, wenn der Benutzer zu ihr navigiert.\nDas \u003crouter-outlet\u003e teilt dem Router mit, wo die gerouteten Ansichten angezeigt werden sollen.\n Das RouterOutlet ist eine der Router-Direktiven, die für die AppComponent verfügbar wurden weil AppModule AppRoutingModule importiert, das RouterModule exportiert hat. Der Befehl ng generate, den du zu Beginn dieses Tutorials ausgeführt hast, fügte diesen Import aufgrund des --module=app Flags hinzu. Wenn du app-routing.module.ts manuell erstellt hast oder ein anderes Werkzeug als das CLI dafür verwendet hast, musst du AppRoutingModule in app.module.ts importieren und es zum imports-Array des NgModule hinzufügen.\n Probiere es aus. Mit diesem CLI-Befehl solltest du immer noch arbeiten.\n1  ng serve   Der Browser sollte aktualisiert werden und den Titel der Anwendung anzeigen, aber nicht die Liste der Helden.\nSchau dir die Adressleiste des Browsers an. Die URL endet auf /. Der Routenpfad zu HeroesComponent ist /heroes.\nHänge /heroes an die URL in der Adressleiste des Browsers an. Du solltest die bekannte Master-/Detailansicht von Helden sehen.\nEntferne “heroes” aus der URL in der Adressleiste des Browsers. Der Browser sollte aktualisiert werden und den Titel der Anwendung anzeigen, aber nicht die Liste der Helden.\nHinzufügen eines Navigationslinks (routerLink) Idealerweise sollten die Benutzer auf einen Link klicken können, um zu navigieren, anstatt als eine Routen-URL in die Adressleiste einzufügen.\nFüge ein \u003cnav\u003e-Element und darin ein Ankerelement ein, das, wenn es angeklickt wird, die Navigation zur HeroesComponent auslöst. Das überarbeitete “AppComponent”-Template sieht wie folgt aus:\nsrc/app/app.component.html (heroes RouterLink)\n1 2 3 4 5 6  \u003ch1\u003e{{title}}\u003c/h1\u003e \u003cnav\u003e \u003ca routerLink=\"/heroes\"\u003eHeroes\u003c/a\u003e \u003c/nav\u003e \u003crouter-outlet\u003e\u003c/router-outlet\u003e \u003capp-messages\u003e\u003c/app-messages\u003e   Ein routerLink-Attribut wird auf \"/heroes\" gesetzt, die Zeichenkette, die der Router mit der Route zu HeroesComponent verbindet. Der routerLink ist der Selektor für die RouterLink Direktive die Benutzerklicks in Routernavigationen umwandelt. Es ist eine weitere der öffentlichen Direktiven im RouterModule.\nDer Browser aktualisiert sich und zeigt den Titel der Anwendung und den Link zu den Helden an, aber nicht die Heldenliste.\nKlicke auf den Link. Die Adressleiste wird auf /heroes aktualisiert und die Liste der Helden erscheint.\n Verbessere das Aussehen dieses und zukünftiger Navigationslinks, indem du private CSS-Stile in app.component.css hinzufügst wie in der endgültigen Codeüberprüfung unten aufgeführt.\n Hinzufügen einer Dashboard-Ansicht Das Routing macht mehr Sinn, wenn es mehrere Ansichten gibt. Bis jetzt gibt es nur die Heldenansicht.\nFüge eine DashboardComponent mit Hilfe der CLI hinzu:\n1  ng generate component dashboard   Die CLI generiert die Dateien für die DashboardComponent und deklariert sie in AppModule.\nErsetze den Inhalt der Standarddateien in diesen drei Dateien wie folgt:\n src/app/dashboard/dashboard.component.html  1 2 3 4 5 6  \u003ch2\u003eTop Heroes\u003c/h2\u003e \u003cdiv class=\"heroes-menu\"\u003e \u003ca *ngFor=\"let hero of heroes\"\u003e {{hero.name}} \u003c/a\u003e \u003c/div\u003e   src/app/dashboard/dashboard.component.ts  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  import { Component, OnInit } from '@angular/core'; import { Hero } from '../hero'; import { HeroService } from '../hero.service'; @Component({ selector: 'app-dashboard', templateUrl: './dashboard.component.html', styleUrls: [ './dashboard.component.css' ] }) export class DashboardComponent implements OnInit { heroes: Hero[] = []; constructor(private heroService: HeroService) { } ngOnInit() { this.getHeroes(); } getHeroes(): void { this.heroService.getHeroes() .subscribe(heroes =\u003e this.heroes = heroes.slice(1, 5)); } }   src/app/dashboard/dashboard.component.css  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  /* DashboardComponent's private CSS styles */ h2 { text-align: center; } .heroes-menu { padding: 0; margin: auto; max-width: 1000px; /* flexbox */ display: flex; flex-direction: row; flex-wrap: wrap; justify-content: space-around; align-content: flex-start; align-items: flex-start; } a { background-color: #3f525c; border-radius: 2px; padding: 1rem; font-size: 1.2rem; text-decoration: none; display: inline-block; color: #fff; text-align: center; width: 100%; min-width: 70px; margin: .5rem auto; box-sizing: border-box; /* flexbox */ order: 0; flex: 0 1 auto; align-self: auto; } @media (min-width: 600px) { a { width: 18%; box-sizing: content-box; } } a:hover { background-color: #000; }   Das Template zeigt ein Raster von Heldennamen-Links.\n Der *ngFor Repeater erstellt so viele Links wie im heroes Array der Komponente enthalten sind. Die Links sind als farbige Blöcke in der dashboard.component.css gestylt. Die Links gehen noch nirgendwo hin, aber sie werden in Kürze….  Die Klasse ist ähnlich wie die Klasse HeroesComponent.\n Sie definiert eine Array-Eigenschaft Helden. Der Konstruktor erwartet, dass Angular den HeroService in eine private heroService Eigenschaft injiziert. Der ngOnInit() Lebenszyklus-Hook ruft getHeroes() auf.  Die Methode getHeroes() gibt die aufgeschnittene Liste der Helden an den Positionen 1 und 5 zurück, wobei nur vier der Top-Helden (2, 3, 4 und 5) zurückgegeben werden.\nsrc/app/dashboard/dashboard.component.ts\n1 2 3 4  getHeroes(): void { this.heroService.getHeroes() .subscribe(heroes =\u003e this.heroes = heroes.slice(1, 5)); }   Hinzufügen der Dashboard-Route Um zum Dashboard zu navigieren, benötigt der Router eine entsprechende Route.\nImportiere die DashboardComponent in die Datei app-routing-module.ts.\nsrc/app/app-routing.module.ts (import DashboardComponent)\n1  import { DashboardComponent } from './dashboard/dashboard.component';   Füge dem Array routes eine Route hinzu, die einem Pfad zur DashboardComponent entspricht.\nsrc/app/app-routing.module.ts\n1  { path: 'dashboard', component: DashboardComponent },   Hinzufügen einer Standard-Route Wenn die Anwendung gestartet wird, zeigt die Adressleiste des Browsers auf das Stammverzeichnis der Website. Das passt zu keiner bestehenden Route, so dass der Router nirgendwo hin navigiert. Der Platz unter dem \u003crouter-outlet\u003e ist leer.\nUm die Anwendung automatisch zum Dashboard navigieren zu lassen, füge die folgende Route in das Array routes ein.\nsrc/app/app-routing.module.ts\n1  { path: '', redirectTo: '/dashboard', pathMatch: 'full' },   Diese Route leitet eine URL, die vollständig mit dem leeren Pfad übereinstimmt, an die Route um, deren Pfad “/dashboard” lautet.\nNachdem der Browser aktualisiert wurde, lädt der Router die DashboardComponent und die Adressleiste des Browsers zeigt die URL /dashboard an.\nDashboard-Link zur Shell hinzufügen Der Benutzer sollte in der Lage sein, zwischen der DashboardComponent und der HeroesComponent hin und her navigieren können, indem er auf Links im Navigationsbereich am oberen Rand der Seite klicken.\nFüge einen Dashboard-Navigationslink zum Shell-Template AppComponent hinzu, direkt über dem Link Heroes.\nsrc/app/app.component.html\n1 2 3 4 5 6 7  \u003ch1\u003e{{title}}\u003c/h1\u003e \u003cnav\u003e \u003ca routerLink=\"/dashboard\"\u003eDashboard\u003c/a\u003e \u003ca routerLink=\"/heroes\"\u003eHeroes\u003c/a\u003e \u003c/nav\u003e \u003crouter-outlet\u003e\u003c/router-outlet\u003e \u003capp-messages\u003e\u003c/app-messages\u003e   Nach dem Aktualisieren des Browsers kannst du frei zwischen den beiden Ansichten navigieren, indem du auf die Links klickst.\nZu den Heldendetails navigieren Die HeroDetailComponent zeigt Details zu einem ausgewählten Helden an. Im Moment ist die HeroDetailComponent nur am unteren Rand der HeroesComponent sichtbar.\nDer Benutzer sollte in der Lage sein, diese Details auf drei Arten zu erreichen.\n Durch Anklicken eines Helden im Dashboard. Durch Anklicken eines Helden in der Heldenliste. Durch Einfügen einer “Deep Link”-URL in die Adressleiste des Browsers, die den anzuzeigenden Helden identifiziert.  In diesem Abschnitt wirst du die Navigation zur HeroDetailComponent aktivieren und befreist sie von der HeroesComponent.\nLöschen der Helden-Details aus der HeroesComponent. Wenn der Benutzer auf ein Heldenelement in der HeroesComponent klickt, sollte die Anwendung zur HeroDetailComponent navigieren, und die Helden-Listenansicht durch die Helden-Detailansicht ersetzen. Die Ansicht der Heldenliste sollte keine Heldendetails mehr anzeigen, wie es jetzt der Fall ist.\nÖffne Das Template HeroesComponent (heroes/heroes.component.html) und lösche das Element \u003capp-hero-detail\u003e von unten.\nDas Anklicken eines Heldenelements bewirkt jetzt nichts. Du wirst das in Kürze beheben, nachdem du das Routing zur HeroDetailComponent aktiviert hast.\nHinzufügen einer Heldendetail-Route Eine URL wie ~/detail/11 wäre eine gute URL, um zur Helden-Detail-Ansicht des Helden zu navigieren, dessen id 11 ist.\nÖffne app-routing.module.ts und importiere HeroDetailComponent.\nsrc/app/app-routing.module.ts (import HeroDetailComponent)\n1  import { HeroDetailComponent } from './hero-detail/hero-detail.component';   Füge dann eine parametrisierte Route zum Array routes hinzu, die dem Pfadmuster zur Ansicht hero detail entspricht.\nsrc/app/app-routing.module.ts\n1  { path: 'detail/:id', component: HeroDetailComponent },   Der Doppelpunkt (:) im “Pfad” zeigt an, dass “:id” ein Platzhalter für eine bestimmte “id” des Helden ist.\nZu diesem Zeitpunkt sind alle Anwendungsrouten vorhanden.\nsrc/app/app-routing.module.ts (all routes)\n1 2 3 4 5 6  const routes: Routes = [ { path: '', redirectTo: '/dashboard', pathMatch: 'full' }, { path: 'dashboard', component: DashboardComponent }, { path: 'detail/:id', component: HeroDetailComponent }, { path: 'heroes', component: HeroesComponent } ];   DashboardComponent Heldenlinks Die DashboardComponent-Heldenlinks machen im Moment noch nichts.\nJetzt, wo der Router eine Route zu HeroDetailComponent hat, fixiere die Dashboard-Heldenlinks so, dass sie über die parametrisierte Dashboard-Route navigieren.\nsrc/app/dashboard/dashboard.component.html (hero links)\n1 2 3 4  \u003ca *ngFor=\"let hero of heroes\" routerLink=\"/detail/{{hero.id}}\"\u003e {{hero.name}} \u003c/a\u003e   Du verwendest Angular interpolation binding innerhalb des *ngFor Repeaters um die hero.id der aktuellen Iteration in jeden routerLink anzuzeigen.\nHeroesComponent Helden-Links Die Heldenelemente in der HeroesComponent sind \u003cli\u003e Elemente, deren Klick-Ereignisse an die Methode onSelect() der Komponente gebunden sind.\nsrc/app/heroes/heroes.component.html (list with onSelect)\n1 2 3 4 5 6 7  \u003cul class=\"heroes\"\u003e \u003cli *ngFor=\"let hero of heroes\" [class.selected]=\"hero === selectedHero\" (click)=\"onSelect(hero)\"\u003e \u003cspan class=\"badge\"\u003e{{hero.id}}\u003c/span\u003e {{hero.name}} \u003c/li\u003e \u003c/ul\u003e   Entferne das \u003cli\u003e auf sein *ngFor zurück, verpacke das Abzeichen und den Namen in ein Ankerelement (\u003ca\u003e), und füge ein routerLink-Attribut zu dem Anker hinzu, das dasselbe ist wie im Dashboard-Template.\nsrc/app/heroes/heroes.component.html (list with links)\n1 2 3 4 5 6 7  \u003cul class=\"heroes\"\u003e \u003cli *ngFor=\"let hero of heroes\"\u003e \u003ca routerLink=\"/detail/{{hero.id}}\"\u003e \u003cspan class=\"badge\"\u003e{{hero.id}}\u003c/span\u003e {{hero.name}} \u003c/a\u003e \u003c/li\u003e \u003c/ul\u003e   Du musst das private Stylesheet (heroes.component.css) anpassen, damit die Liste wie vorher aussieht. Die überarbeiteten Styles sind im final code review am Ende dieser Anleitung zu finden.\nEntferne toten Code (optional) Während die HeroesComponent Klasse noch funktioniert, werden die Methode onSelect() und die Eigenschaft selectedHero nicht mehr verwendet.\nEs ist schön, aufzuräumen, und du wirst dich später selbst dafür dankbar sein. Hier ist die Klasse, nachdem der tote Code entfernt wurde.\nsrc/app/heroes/heroes.component.ts (cleaned up)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  export class HeroesComponent implements OnInit { heroes: Hero[] = []; constructor(private heroService: HeroService) { } ngOnInit() { this.getHeroes(); } getHeroes(): void { this.heroService.getHeroes() .subscribe(heroes =\u003e this.heroes = heroes); } }   Routable HeroDetailComponent Zuvor setzte die übergeordnete HeroesComponent die Eigenschaft HeroDetailComponent.hero Eigenschaft und die HeroDetailComponent zeigte den Helden an.\nDie HeroesComponent macht das nicht mehr. Jetzt erstellt der Router die HeroDetailComponent als Antwort auf eine URL wie ~/detail/11.\nDie HeroDetailComponent braucht einen neuen Weg, um den anzuzeigenden Helden zu erhalten. Dieser Abschnitt erklärt das Folgende:\n Abrufen der Route, die sie erstellt hat Extrahieren der “ID” aus der Route Erwerbe den Helden mit dieser “ID” vom Server mit Hilfe des “HeroService”.  Füge die folgenden Importe hinzu:\nsrc/app/hero-detail/hero-detail.component.ts\n1 2 3 4  import { ActivatedRoute } from '@angular/router'; import { Location } from '@angular/common'; import { HeroService } from '../hero.service';   Injiziere die Dienste ActivatedRoute, HeroService und Location in den Konstruktor und speichert ihre Werte in privaten Feldern:\nsrc/app/hero-detail/hero-detail.component.ts\n1 2 3 4 5  constructor( private route: ActivatedRoute, private heroService: HeroService, private location: Location ) {}   Das ActivatedRoute enthält Informationen über die Route zu dieser Instanz von HeroDetailComponent. Diese Komponente ist an den Parametern der Route interessiert, die aus der URL extrahiert wurden. Der “id” Parameter ist die “id” des anzuzeigenden Helden.\nDer HeroService erhält Heldendaten vom entfernten Server und diese Komponente wird sie verwenden, um den anzuzeigenden Helden zu erhalten.\nDie location ist ein Angular-Dienst für die Interaktion mit dem Browser. Du wirst ihn später verwenden, um zurück zu der Ansicht zu navigieren, die hierher navigiert hat.\nExtrahiere den id-Routenparameter In dem ngOnInit() Lebenszyklus-Haken Rufe getHero() auf und definiere es wie folgt.\nsrc/app/hero-detail/hero-detail.component.ts\n1 2 3 4 5 6 7 8 9  ngOnInit(): void { this.getHero(); } getHero(): void { const id = Number(this.route.snapshot.paramMap.get('id')); this.heroService.getHero(id) .subscribe(hero =\u003e this.hero = hero); }   Der route.snapshot ist ein statisches Abbild der Routeninformationen kurz nach der Erstellung der Komponente.\nDie paramMap ist ein Wörterbuch mit Routenparameterwerten, die aus der URL extrahiert wurden. Der “id”-Schlüssel gibt die “id” des abzurufenden Helden zurück.\nRoutenparameter sind immer Zeichenketten. Die JavaScript-Funktion Number wandelt die Zeichenkette in eine Zahl um, was die “id” eines Helden sein sollte.\nDer Browser wird aktualisiert und die Anwendung stürzt mit einem Compilerfehler ab. HeroService hat keine getHero() Methode. Füge sie jetzt hinzu.\nHinzufügen von HeroService.getHero() Öffne HeroService und füge die folgende getHero() Methode mit der id nach der getHeroes() Methode hinzu:\nsrc/app/hero.service.ts (getHero)\n1 2 3 4 5 6 7  getHero(id: number): Observable\u003cHero\u003e { // Im Moment wird davon ausgegangen, dass ein Held mit der angegebenen `id` immer existiert.  // Die Fehlerbehandlung wird im nächsten Schritt des Tutorials hinzugefügt.  const hero = HEROES.find(h =\u003e h.id === id)!; this.messageService.add(`HeroService: fetched hero id=${id}`); return of(hero); }   Wie getHeroes(), hat getHero() eine asynchrone Signatur. Es gibt einen mock hero als Observable zurück, unter Verwendung der RxJS of() Funktion.\nDu kannst getHero() als echte Http-Anfrage neu implementieren ohne die HeroDetailComponent zu ändern, die sie aufruft.\nVersuche es Der Browser aktualisiert sich und die Anwendung funktioniert wieder. Du kannst auf einen Helden im Dashboard oder in der Heldenliste klicken und zur Detailansicht dieses Helden navigieren.\nWenn du localhost:4200/detail/11 in die Adressleiste des Browsers einfügst, navigiert der Router zur Detailansicht für den Helden mit der id: 11, “Dr. Nice”.\nFinde den Weg zurück Mit einem Klick auf den Zurück-Button des Browsers, kannst du zur Heldenliste oder zur Dashboard-Ansicht zurückkehren, je nachdem, von wo aus du zur Detailansicht gelangt bist.\nEs wäre schön, eine Schaltfläche in der HeroDetail-Ansicht zu haben, die das kann.\nFüge eine Zurück-Schaltfläche am unteren Ende des Komponententemplate hinzu und binde sie an die Methode goBack() der Komponente.\nsrc/app/hero-detail/hero-detail.component.html (back button)\n1  \u003cbutton (click)=\"goBack()\"\u003ego back\u003c/button\u003e   Füge der Komponentenklasse eine “goBack()-Methode” hinzu, die einen Schritt zurückgeht im Verlaufsstapel des Browsers unter Verwendung des Location-Dienstes, den du zuvor injiziert hast.\nsrc/app/hero-detail/hero-detail.component.ts (goBack)\n1 2 3  goBack(): void { this.location.back(); }   Aktualisiere den Browser und beginne zu klicken. Benutzer können in der App navigieren, vom Dashboard zu den Heldendetails und zurück, von der Heldenliste zu den Minidetails, zu den Heldendetails und wieder zurück zu den Helden.\nDie Details sehen besser aus, wenn du die privaten CSS-Stile zu hero-detail.component.css hinzufügst wie in einem der “final code review” Tabs unten aufgeführt.\nFinal code review Hier oder hier sind die auf dieser Seite besprochenen Codedateien.\nZusammenfassung  Du hast den Angular-Router hinzugefügt, um zwischen verschiedenen Komponenten zu navigieren. Du hast die AppComponent in eine Navigations-Shell mit \u003ca\u003e-Links und einem \u003crouter-outlet\u003e verwandelt. Du hast den Router in einem “AppRoutingModule” konfiguriert. Du hast Routen, eine Redirect-Route und eine parametrisierte Route definiert. Du hast die routerLink-Direktive in Ankerelementen verwendet. Du hast eine eng gekoppelte Master/Detail-Ansicht in eine geroutete Detail-Ansicht umgewandelt. Du hast Router-Link-Parameter verwendet, um zur Detailansicht eines vom Benutzer ausgewählten Helden zu navigieren. Du hast den HeroService auf mehrere Komponenten verteilt.  ","categories":"","description":"","excerpt":"Navigation mit Routing hinzufügen Es gibt neue Anforderungen für die …","ref":"/docs/web/angular/05_6_navigation_routing/","tags":"","title":"Navigation mit Routing hinzufügen"},{"body":"Du hast dich sicherlich schon gefragt, wie du mehrere Elemente nebeneinander haben kannst. Hierfür müssen wir ein paar Worte über Layouting verlieren.\nFloating Vor dem Zeitalter von FlexBoxen und Grids war das Layouting noch ein bisschen mühsamer. Eine Möglichkeit war es, die Elemente, die man z.B. nebeneinander haben wollte, dass diese gefloatet werden. Das hätte ungefähr so ausgesehen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  \u003cdiv class=\"container\"\u003e \u003cdiv class=\"box\"\u003eElement 1\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 2\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 3\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 4\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 5\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 6\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 7\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 8\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 9\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 10\u003c/div\u003e \u003c/div\u003e \u003cstyle\u003e .container { overflow: auto; background-color: lightgray; } .box { display: block; float: left; margin: 1em; width: 10em; height: 10em; background-color: orange; } \u003c/style\u003e   In diesem Beispiel wurde das container-div nur zur Demonstration verwendet. Da du diese Technik wahrscheinlich nie benötigen wirst, musst du im Moment auch nicht verstehen, weshalb overflow: auto verwendet wurde.\nWas genau passiert hier? Wichtig ist, dass die gefloateten Elemente display: block haben (was bei einem \u003cdiv\u003e bereits default ist). Mit float: left werden die Elemente der Reihe nach von links nach rechts angeordnet. Wenn es in den Rand hinaus gehen würde, wird eine neue Zeile begonnen (wrap). Das wäre bereits die ganze Magie.\nÄndere den Wert auf float: right. Nun beginnt ist das erste Element rechts. Was müsstest du machen, damit die Elemente zwar rechtsbündig sind, aber das erste Element dennoch links vom zweiten usw. ist?\nFlex-Boxen Wenn du Floating oft brauchen würdest, dann wirst du schnell merken, dass diese Technik sehr mühsam sein kann.\nDie gute Nachricht ist, dass man die vorherige Technik praktisch gar nicht mehr benötigt seit der Einführung von Flex-Boxen. Das obige Beispiel kann verkürzt werden auf:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  \u003cdiv class=\"flex-container\"\u003e \u003cdiv class=\"box\"\u003eElement 1\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 2\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 3\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 4\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 5\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 6\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 7\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 8\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 9\u003c/div\u003e \u003cdiv class=\"box\"\u003eElement 10\u003c/div\u003e \u003c/div\u003e \u003cstyle\u003e .flex-container { display: flex; flex-wrap: wrap; gap: 1em; background-color: lightgray; } .box { width: 10em; height: 10em; background-color: orange; } \u003c/style\u003e   Der grosse Unterschied hier ist, dass es einen Container braucht, den “Flex-Container”. Du kannst ein beliebiges Element als Flex-Container definieren, indem du display: flex auf dieses Element anwendest.\nDas flex-wrap ist nicht zwingend nötig, ist aber dafür verantwortlich, dass es einen Zeilenumbruch gibt, wenn die Elemente in den Rand hinaus gehen würden. Ansonsten war es das bereits. Interessanter Weise muss weder Flex-Container noch Flex-Item display: block haben. In diesem Beispiel könntest du also die \u003cdiv\u003es mit \u003cspan\u003es (Inline-Element) ersetzen und es würde immer noch funktionieren (aber nicht empfehlenswert).\nWenn du den Zeilenumbruch (das wrap) nicht willst, dann kanst du die flex-wrap-Regel entfernen. Wenn du das machst, dann zieht die width: 10em-Regel nicht immer, z.B. wenn es zu wenig Platz dafür hätte. In diesem Fall kannst du width mit min-width ersetzen oder flex-shrink: 0 auf den Items (.box) setzen. flex-shrink: 0 bedeutet, dass sich die Items nicht verkleinern, wenn zu wenig Platz da ist. Beachte in beiden Fällen, dass die Elemente in den Rand hinaus gehen würden, wenn zu wenig Platz da wäre!\nDieses Problem könntest du umgehen, indem du auf dem Flex-Container definierst, dass der Teil, der aus dem Rand hinausgehen würde,\n entweder versteckt werden würde (overflow: hidden) oder eine Scrollbar angezeigt würde (overflow: auto oder overflow: scroll)  Flex-Boxen mit flexiblen Items Im Prinzip sind Flex-Boxen überhaupt nicht kompliziert, auch wenn man sehr komplexe Layouts damit machen kann.\nSchaue dir rasch CSS Flexbox in 100 Seconds an. Dort ist die ganze Technik gut und interessant zusammengefasst.\nOft möchte man z.B. mehrere Spalten nebeneinander haben, die alle gleich viel Platz beanspruchen und zugleich sollen alle Spalten zusammen möglichst dynamisch die ganze Breite des Browsers ausnutzen.\nFolgendes Beispiel macht genau das:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u003cp\u003eLorem ipsum dolor sit amet, consectetuer adipiscing elit. Maecenas porttitor congue massa. Fusce posuere, magna sed pulvinar ultricies, purus lectus malesuada libero, sit amet commodo magna eros quis urna. Nunc viverra imperdiet enim. Fusce est. \u003c/p\u003e \u003cdiv class=\"flex-container\"\u003e \u003cp style=\"flex: 1\"\u003eVivamus a tellus. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpisegestas. Proin pharetra nonummy pede. Mauris et orci. Aenean nec lorem. In porttitor.\u003c/p\u003e \u003cp style=\"flex: 1\"\u003eMauris eget neque at sem venenatis eleifend. Ut nonummy. Fusce aliquet pede non pede. Suspendisse dapibus lorem pellentesque magna. Integer nulla. \u003c/p\u003e \u003cdiv style=\"flex: 1\"\u003e \u003cimg src=\"https://it-ninjas.ch/img/png/Ninja%20Elements_ninja_phone.png\" alt=\"A picture\" style=\"max-width: 100%;\" /\u003e \u003cp\u003eMauris eget neque at sem venenatis eleifend. Ut nonummy.\u003c/p\u003e \u003c/div\u003e \u003c/div\u003e \u003cstyle\u003e .flex-container { display: flex; gap: 1em; } \u003c/style\u003e   Mit flex: 1 haben wir gesagt, dass jede dieser Spalten genau gleich viel Platz beanspruchen soll. Ändere z.B. beim \u003cdiv\u003e mit dem Bild den flex-Wert auf 2. Du wirst sehen, dass dieses \u003cdiv\u003e nun anteilmässig doppelt so viel Platz beansprucht wie die anderen.\nWelche Zahlen du genau verwendest, spielt keine grosse Rolle. Du kannst z.B. auch flex: 25% eingeben, was auch funktioniert. Wichtig zu wissen ist, dass so zu sagen alle Flex-Werte zusammen-addiert werden. Wenn du z.B. den flex-Wert des Bild-divs auf 2 geändert hast, so beansprucht dieses div 2 / (1 + 2 + 1) = 2/4 = 50% der Breite. Wenn du diese Rechnung nicht verstehen solltest, frage unbedingt nach!\nAusrichtung der Flex-Box Per Default werden die Elemente von links nach rechts angeordnet, was auch sehr viel Sinn macht: Um Elemente vertikal (also von oben nach unten) anzuordnen, braucht man eigentlich kein spezielles Layout.\nMöchtest du aber bei einem grossen Screen Elemente horizontal nebeneinander haben, aber bei einem kleinen Screen aus Platzgründen untereinander, so kannst du für kleinere Bildschirme folgende Regel hinzufügen:\n1 2 3 4 5  @media (max-width: 600px) { .flex-container { flex-direction: column; } }   Das @media (max-width: 600px) wird “Media Query” genannt. Wenn die Breite des Browsers einen bestimmten Wert unterschreitet, dann wird die Regel darin aktiv. Mehr über Media Queries erfährst du hier: https://www.w3schools.com/css/css_rwd_mediaqueries.asp\nBeide Richtungen Bevor wir an das Praktische gehen, musst du noch zwei Begriffe kennen:\n MainAxis und CrossAxis  Hat dein Flex-Container eine horizontale Ausrichtung (default: flex-direction: row), so ist die MainAxis die x-Achse (von links nach rechts) und die CrossAxis die y-Achse (oben nach unten). Bei einer vertikalen Ausrichtung (flex-direction: column) ist das genau umgekehrt.\nFlex-Elemente ausrichten Flex-Boxen machen das Ausrichten von Inhalt sehr einfach.\nDer Einfachheit halber nehmen wir einmal dieses Beispiel:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  \u003cdiv class=\"flex-container\"\u003e \u003cdiv\u003e1\u003c/div\u003e \u003cdiv\u003e2\u003c/div\u003e \u003cdiv\u003e3\u003c/div\u003e \u003c/div\u003e \u003cstyle\u003e .flex-container { display: flex; height: 20em; background-color: cornflowerblue; } .flex-container\u003ediv { background-color: white; width: 100px; height: 100px; margin: 10px; } \u003c/style\u003e   Da per Default flex-direction: row gilt, werden die Elemente von oben links nach rechts dargestellt. Um die Elemente horizontal (bzw. auf der MainAxis) zu zentrieren, kannst du folgende Regel auf den Flex-Container anwenden: justify-content: center.\nAuf horizontaler Ebene (MainAxis) kannst du die Elemente noch auf viele andere Arten ausrichten. Probiere folgende Werte für justify-content (z.B. mit Hilfe der Entwickler-Tools deines Browsers via [F12]) einmal aus:\n center space-around space-between space-evenly flex-start flex-end  Möchtest du hingegen die Elemente vertikal (auf der CrossAxis) ausrichten, dann hilft dir align-items weiter. Die Elemente kannst du vertikal zentrieren mit align-items: center. Die Elemente kannst du auch oben bzw. unten ausrichten mit align-items: flex-start bzw. flex-end.\nHast du Zeilenumbrüche drin, dann kannst du vertikal (auf der CrossAxis) die Abstände noch genauer spezifizieren. Um das auszuprobieren, setze flex-wrap: wrap auf dem Flex-Container und erstelle weitere \u003cdiv\u003es darin, damit es genug Elemente hat. Probiere im Flex-Container nun folgende Werte für align-content aus:\n center space-around space-between space-evenly flex-start flex-end  Wie du gesehen hast, sind die Property-Namen für die Ausrichtung unnötig kompliziert gewählt worden. Deshalb hier noch einmal in der Übersicht:\nUm horizontal (bzw. in der MainAxis) Elemente auszurichten:\n justify-content  Um vertikal (bzw. in der CrossAxis) Elemente auszurichten:\n align-items align-content in Kombination mit flex-wrap: wrap  Website-Layout mit Flex-Boxen Theoretisch reicht das Wissen über Flex-Boxen bereits, um eine ganze Seite zu layouten. Damit du ein Gefühl dafür bekommst, schaue dir bitte das unterste Beispiel auf dieser Seite an: https://www.w3schools.com/css/css3_flexbox_responsive.asp\nHilfestellung Hier kriegst du eine gute visuelle Übersicht über die einzelnen Flex-Properties: https://css-tricks.com/snippets/css/a-guide-to-flexbox/#aa-flexbox-properties Hier sind von w3schools die wichtigsten Eigenschaften von Flex-Boxen beschrieben: https://www.w3schools.com/css/css3_flexbox.asp\nDisplay-Flex-Properties üben Auf Flexbox Froggy kannst du dein Flexbox-Wissen auf lustige Art und Weise trainieren. Nimm dir rasch Zeit dafür.\nAufgaben im Lab Hierzu findest du eine Aufgabe im Lab.\n","categories":"","description":"Block-Elemente layouten.\n","excerpt":"Block-Elemente layouten.\n","ref":"/docs/web/html_css/16_layouting/","tags":"","title":"Layouting"},{"body":"Daten von einem Server abrufen  Der HeroService holt Heldendaten mit HTTP-Anfragen. Benutzer können Helden hinzufügen, bearbeiten und löschen und diese Änderungen über HTTP speichern. Benutzer können nach Helden anhand ihres Namens suchen.   Die Beispielanwendung, die auf dieser Seite beschrieben wird, findest du unter dieser Seite.\n Aktiviere HTTP-Dienste HttpClient ist Angulars Mechanismus, um mit einem entfernten Server über HTTP zu kommunizieren.\nMache HttpClient überall in der Anwendung in zwei Schritten verfügbar. Erstens, füge es zum Root AppModule hinzu, indem du es importierst:\nsrc/app/app.module.ts (HttpClientModule import)\n1  import { HttpClientModule } from '@angular/common/http';   Als Nächstes, immer noch im AppModule, füge HttpClientModule in das imports Array ein:\nsrc/app/app.module.ts (imports array excerpt)\n1 2 3 4 5  @NgModule({ imports: [ HttpClientModule, ], })   Einen Datenserver simulieren Dieses Tutorial-Beispiel imitiert die Kommunikation mit einem entfernten Datenserver, indem es die In-memory Web API Modul.\nNach der Installation des Moduls wird die Anwendung Anfragen an den HttpClient stellen und Antworten von diesem empfangen ohne zu wissen, dass die In-memory Web API diese Anfragen abfängt, sie auf einen In-Memory-Datenspeicher anwendet und simulierte Antworten zurückgibt.\nWenn du die In-Memory-Web-API verwendest, musst du keinen Server einrichten, um etwas über den HttpClient zu erfahren.\nInstalliere das In-memory Web API Paket von npm mit dem folgenden Befehl:\n1  npm install angular-in-memory-web-api --save   Im AppModule importiere das HttpClientInMemoryWebApiModule und die Klasse InMemoryDataService, die du in einem Moment erstellen wirst.\nsrc/app/app.module.ts (In-memory Web API imports)\n1 2  import { HttpClientInMemoryWebApiModule } from 'angular-in-memory-web-api'; import { InMemoryDataService } from './in-memory-data.service';   Nach dem HttpClientModule füge das HttpClientInMemoryWebApiModule zum AppModule imports Array hinzu und konfigurieren es mit dem InMemoryDataService.\nsrc/app/app.module.ts (imports array excerpt)\n1 2 3 4 5 6 7 8  HttpClientModule, // Das Modul HttpClientInMemoryWebApiModule fängt HTTP-Anfragen ab // und gibt simulierte Serverantworten zurück. // Entferne es, wenn ein echter Server bereit ist, Anfragen zu empfangen. HttpClientInMemoryWebApiModule.forRoot( InMemoryDataService, { dataEncapsulation: false } )   Die Konfigurationsmethode “forRoot()” nimmt eine “InMemoryDataService”-Klasse die die In-Memory-Datenbank vorbereiten.\nErzeuge die Klasse src/app/in-memory-data.service.ts mit dem folgenden Befehl:\n1  ng generate service InMemoryData   Ersetze den Standardinhalt von in-memory-data.service.ts durch den folgenden:\nsrc/app/in-memory-data.service.ts\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  import { Injectable } from '@angular/core'; import { InMemoryDbService } from 'angular-in-memory-web-api'; import { Hero } from './hero'; @Injectable({ providedIn: 'root', }) export class InMemoryDataService implements InMemoryDbService { createDb() { const heroes = [ { id: 11, name: 'Dr Nice' }, { id: 12, name: 'Narco' }, { id: 13, name: 'Bombasto' }, { id: 14, name: 'Celeritas' }, { id: 15, name: 'Magneta' }, { id: 16, name: 'RubberMan' }, { id: 17, name: 'Dynama' }, { id: 18, name: 'Dr IQ' }, { id: 19, name: 'Magma' }, { id: 20, name: 'Tornado' } ]; return {heroes}; } // Overrides the genId method to ensure that a hero always has an id.  // If the heroes array is empty,  // the method below returns the initial number (11).  // if the heroes array is not empty, the method below returns the highest  // hero id + 1.  genId(heroes: Hero[]): number { return heroes.length \u003e 0 ? Math.max(...heroes.map(hero =\u003e hero.id)) + 1 : 11; } }   Die Datei in-memory-data.service.ts wird die Funktion von mock-heroes.ts übernehmen. Lösche die Datei mock-heroes.ts jedoch noch nicht, da du sie noch für einige weitere Schritte dieses Tutorials benötigst.\nWenn der Server bereit ist, löse die In-Memory-Web-API aus, und die Anfragen der Anwendung werden an den Server weitergeleitet.\nHelden und HTTP Im HeroService importiere HttpClient und HttpHeaders:\nsrc/app/hero.service.ts (import HTTP symbols)\n1  import { HttpClient, HttpHeaders } from '@angular/common/http';   Noch im HeroService, injiziere HttpClient in den Konstruktor in einer privaten Eigenschaft namens http.\nsrc/app/hero.service.ts\n1 2 3  constructor( private http: HttpClient, private messageService: MessageService) { }   Beachte, dass du den MessageService weiterhin injizierst, aber da du ihn so häufig aufrufen wirst, verpackst du ihn in eine private log() Methode:\nsrc/app/hero.service.ts\n1 2 3 4  /** Log a HeroService message with the MessageService */ private log(message: string) { this.messageService.add(`HeroService: ${message}`); }   Definiere die heroesUrl der Form :base/:collectionName mit der Adresse der heroes-Ressource auf dem Server. Dabei ist base die Ressource, an die Anfragen gestellt werden, und collectionName ist das heroes-Datenobjekt in der in-memory-data-service.ts.\nsrc/app/hero.service.ts\n1  private heroesUrl = 'api/heroes'; // URL to web api   Abrufen von Helden mit HttpClient Das aktuelle HeroService.getHeroes() verwendet die RxJS-Funktion of(), um ein Array von Mock-Helden zurückzugeben als Observable\u003cHero[]\u003e zurückzugeben.\nsrc/app/hero.service.ts (getHeroes with RxJs 'of()')\n1 2 3 4  getHeroes(): Observable\u003cHero[]\u003e { const heroes = of(HEROES); return heroes; }   Konvertiere diese Methode zur Verwendung von HttpClient wie folgt:\nsrc/app/hero.service.ts\n1 2 3 4  /** GET heroes from the server */ getHeroes(): Observable\u003cHero[]\u003e { return this.http.get\u003cHero[]\u003e(this.heroesUrl) }   Aktualisiere den Browser. Die Heldendaten sollten erfolgreich vom Mock-Server geladen werden.\nDu hast of() gegen http.get() ausgetauscht und die Anwendung funktioniert ohne weitere Änderungen weil beide Funktionen ein Observable\u003cHero[]\u003e zurückgeben.\nHttpClient-Methoden geben einen Wert zurück Alle HttpClient-Methoden geben ein RxJS Observable von etwas zurück.\nHTTP ist ein Anfrage/Antwort-Protokoll. Man stellt eine Anfrage und erhält eine einzige Antwort zurück.\nIm Allgemeinen _kann eine Observable mehrere Werte im Laufe der Zeit zurückgeben. Eine Observable von HttpClient gibt immer einen einzigen Wert aus und beendet sich dann, um nie wieder einen Wert auszugeben.\nDieser spezielle HttpClient.get()-Aufruf gibt ein Observable\u003cHero[]\u003e zurück; das heißt, “ein Observable von Hero-Arrays”. In der Praxis wird nur ein einziges Helden-Array zurückgegeben.\nHttpClient.get() gibt Antwortdaten zurück HttpClient.get()\" gibt standardmäßig den Körper der Antwort als untypisiertes JSON-Objekt zurück. Die Anwendung des optionalen Typ-Spezifizierers \u003cHero[]\u003e fügt TypeScript-Fähigkeiten hinzu, die Fehler während der Kompilierungszeit reduzieren.\nDie Daten-API des Servers bestimmt die Form der JSON-Daten. Die Daten-API von Tour of Heroes gibt die Heldendaten als Array zurück.\n Andere APIs verbergen die gewünschten Daten möglicherweise in einem Objekt. Du musst diese Daten möglicherweise durch Verarbeitung des Observable-Ergebnisses mit dem RxJS-Operator “map()” verarbeiten.\n Obwohl hier nicht besprochen, gibt es ein Beispiel für map() in der getHeroNo404() Methode, die im Quellcode des Beispiels enthalten ist.\nFehlerbehandlung/Error handling Dinge gehen schief, besonders wenn man Daten von einem entfernten Server erhält. Die Methode HeroService.getHeroes() sollte Fehler abfangen und etwas Passendes tun.\nUm Fehler abzufangen, “pipe” das Observable Ergebnis von http.get() durch einen RxJS catchError() Operator.\nImportiere das Symbol catchError aus rxjs/operators, zusammen mit einigen anderen Operatoren, die du später benötigen wirst.\nsrc/app/hero.service.ts\n1  import { catchError, map, tap } from 'rxjs/operators';   Erweitere nun das Observable Ergebnis mit der Methode pipe() und gib ihm einen catchError() Operator.\nsrc/app/hero.service.ts\n1 2 3 4 5 6  getHeroes(): Observable\u003cHero[]\u003e { return this.http.get\u003cHero[]\u003e(this.heroesUrl) .pipe( catchError(this.handleError\u003cHero[]\u003e('getHeroes', [])) ); }   Der Operator catchError() fängt ein Observable ab, das fehlgeschlagen ist. Der Operator übergibt dann den Fehler an die Fehlerbehandlungsfunktion.\nDie folgende Methode handleError() meldet den Fehler und gibt dann ein unschädliches Ergebnis zurück, so dass die Anwendung weiter funktioniert.\nhandleError Die folgende handleError()-Methode wird von vielen HeroService-Methoden verwendet geteilt, also ist sie verallgemeinert, um ihren unterschiedlichen Bedürfnissen gerecht zu werden.\nAnstatt den Fehler direkt zu behandeln, gibt sie eine Fehlerbehandlungsfunktion an catchError zurück, die sie mit dem Namen der fehlgeschlagenen Operation und einem sicheren Rückgabewert konfiguriert hat.\nsrc/app/hero.service.ts\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  /** * Behandelt eine fehlgeschlagene Http-Operation. * Lässt die App weiterlaufen. * @param operation - Name des fehlgeschlagenen Vorgangs * @param result - optionaler Wert, der als beobachtbares Ergebnis zurückgegeben wird */ private handleError\u003cT\u003e(operation = 'operation', result?: T) { return (error: any): Observable\u003cT\u003e =\u003e { // TODO: den Fehler an die entfernte Logging-Infrastruktur senden  console.error(error); // stattdessen auf der Konsole protokollieren  // TODO: Fehler besser für den Benutzer aufbereiten  this.log(`${operation}failed: ${error.message}`); // Lasse die Anwendung weiterlaufen, indem du ein leeres Ergebnis zurückgibst.  return of(result as T); }; }   Nachdem der Fehler an die Konsole gemeldet wurde, konstruiert der Handler eine benutzerfreundliche Meldung und gibt einen sicheren Wert an die Anwendung zurück, damit diese weiterarbeiten kann.\nWeil jede Dienstmethode eine andere Art von Observable-Ergebnis zurückgibt, handleError()` einen Typ-Parameter, um den sicheren Wert als den von der Anwendung erwarteten Typ zurückgeben zu können.\nTippe auf das Observable Die HeroService-Methoden zapfen den Fluss der Observable Werte an und senden mit der Methode log() eine Nachricht an den Nachrichtenbereich am unteren Rand der Seite.\nDu tust dies mit dem RxJS-Operator “tap()”, der sich die Observable Werte ansieht, etwas mit diesen Werten macht und sie weitergibt. Der tap() Rückruf berührt die Werte selbst nicht.\nHier ist die endgültige Version von “getHeroes()” mit dem “tap()”, der die Operation protokolliert.\nsrc/app/hero.service.ts\n1 2 3 4 5 6 7 8  /** GET heroes from the server */ getHeroes(): Observable\u003cHero[]\u003e { return this.http.get\u003cHero[]\u003e(this.heroesUrl) .pipe( tap(_ =\u003e this.log('fetched heroes')), catchError(this.handleError\u003cHero[]\u003e('getHeroes', [])) ); }   Held nach ID abrufen Die meisten Web APIs unterstützen eine get by id Anfrage in der Form :baseURL/:id.\nHier ist die Basis-URL die heroesURL, die im Abschnitt Heroes und HTTP definiert ist (api/heroes) und id ist die Nummer des Helden, den du abrufen willst. Zum Beispiel, api/heroes/11.\nAktualisiere die HeroService getHero() Methode mit dem Folgenden, um diese Anfrage zu stellen:\nsrc/app/hero.service.ts\n1 2 3 4 5 6 7 8  /** GET hero by id. Will 404 if id not found */ getHero(id: number): Observable\u003cHero\u003e { const url = `${this.heroesUrl}/${id}`; return this.http.get\u003cHero\u003e(url).pipe( tap(_ =\u003e this.log(`fetched hero id=${id}`)), catchError(this.handleError\u003cHero\u003e(`getHero id=${id}`)) ); }   Es gibt drei wesentliche Unterschiede zu getHeroes():\n getHero() konstruiert eine Anfrage-URL mit der Id des gewünschten Helden. Der Server sollte mit einem einzelnen Helden antworten und nicht mit einem Array von Helden. getHero() gibt ein Observable\u003cHero\u003e (\"an observable of Hero objects\") und nicht ein Observable von Helden Arrays zurück.  Helden aktualisieren Bearbeite den Namen eines Helden in der Helden-Detailansicht. Während du tippst, wird der Name des Helden in der Überschrift oben auf der Seite aktualisiert. Wenn du jedoch auf die Schaltfläche “Zurück” klickst, gehen die Änderungen verloren.\nWenn du möchtest, dass die Änderungen erhalten bleiben, musst du sie zurück auf den den Server zurückschreiben.\nFüge am Ende der Vorlage für die Heldendetails eine Schaltfläche zum Speichern mit einem “Klick”-Ereignis Bindung, die eine neue Komponentenmethode namens save() aufruft.\nsrc/app/hero-detail/hero-detail.component.html (save)\n1  \u003cbutton (click)=\"save()\"\u003esave\u003c/button\u003e   Füge in der Komponentenklasse HeroDetail die folgende save()-Methode hinzu, die Änderungen des Heldennamens mithilfe des Heldendienstes speichert updateHero() Methode und navigiert dann zurück zur vorherigen Ansicht.\nsrc/app/hero-detail/hero-detail.component.ts (save)\n1 2 3 4 5 6  save(): void { if (this.hero) { this.heroService.updateHero(this.hero) .subscribe(() =\u003e this.goBack()); } }   Hinzufügen von HeroService.updateHero() Die allgemeine Struktur der updateHero() Methode ist ähnlich wie die von getHeroes(), aber sie verwendet http.put() um den geänderten Helden auf dem Server. Füge das Folgende zum HeroService hinzu.\nsrc/app/hero.service.ts (update)\n1 2 3 4 5 6 7  /** PUT: update the hero on the server */ updateHero(hero: Hero): Observable\u003cany\u003e { return this.http.put(this.heroesUrl, hero, this.httpOptions).pipe( tap(_ =\u003e this.log(`updated hero id=${hero.id}`)), catchError(this.handleError\u003cany\u003e('updateHero')) ); }   Die Methode HttpClient.put() benötigt drei Parameter:\n die URL die zu aktualisierenden Daten (in diesem Fall der geänderte Held) Optionen  Die URL ist unverändert. Die Web-API von heroes weiß, welcher Held zu aktualisieren ist, indem sie sich die id des Helden ansieht.\nDie heroes-Web-API erwartet eine spezielle Kopfzeile in HTTP-Speicheranforderungen. Dieser Header ist in der Konstante httpOptions im HeroService definiert. Füge Folgendes zur Klasse HeroService hinzu.\nsrc/app/hero.service.ts\n1 2 3  httpOptions = { headers: new HttpHeaders({ 'Content-Type': 'application/json' }) };   Aktualisiere den Browser, ändere einen Heldennamen und speichere deine Änderung. Die save() Methode in HeroDetailComponent navigiert zur vorherigen Ansicht. Der Held erscheint nun in der Liste mit dem geänderten Namen.\nHinzufügen eines neuen Helden Um einen Helden hinzuzufügen, benötigt diese Anwendung nur den Namen des Helden. Man kann ein \u003cinput\u003e Element gepaart mit einer Hinzufügen-Schaltfläche.\nFüge das Folgende in die HeroesComponent-Vorlage ein, nach der Überschrift ein:\nsrc/app/heroes/heroes.component.html (add)\n1 2 3 4 5 6 7 8 9  \u003cdiv\u003e \u003clabel for=\"new-hero\"\u003eHero name: \u003c/label\u003e \u003cinput id=\"new-hero\" #heroName /\u003e \u003c!-- (click) übergibt Eingabewert an add() und löscht dann die Eingabe --\u003e \u003cbutton class=\"add-button\" (click)=\"add(heroName.value); heroName.value=''\"\u003e Add hero \u003c/button\u003e \u003c/div\u003e   Rufe als Reaktion auf ein Klick-Ereignis den Click-Handler der Komponente, add(), auf und lösche dann das Eingabefeld, damit es für einen anderen Namen bereit ist. Füge das Folgende zu der Klasse HeroesComponent hinzu:\nsrc/app/heroes/heroes.component.ts (add)\n1 2 3 4 5 6 7 8  add(name: string): void { name = name.trim(); if (!name) { return; } this.heroService.addHero({ name } as Hero) .subscribe(hero =\u003e { this.heroes.push(hero); }); }   Wenn der angegebene Name kein Leerzeichen ist, erstellt der Handler ein Hero-ähnliches Objekt aus dem Namen (es fehlt nur die id) und übergibt es an die Methode addHero() des Dienstes.\nWenn addHero() erfolgreich speichert, erhält der subscribe() Callback den neuen Helden und schiebt ihn zur Anzeige in die Heldenliste.\nFüge die folgende Methode addHero() zur Klasse HeroService hinzu.\nsrc/app/hero.service.ts (addHero)\n1 2 3 4 5 6 7  /** POST: Füge einen neuen Hero dem Server hinzu */ addHero(hero: Hero): Observable\u003cHero\u003e { return this.http.post\u003cHero\u003e(this.heroesUrl, hero, this.httpOptions).pipe( tap((newHero: Hero) =\u003e this.log(`added hero w/ id=${newHero.id}`)), catchError(this.handleError\u003cHero\u003e('addHero')) ); }   Die Funktion addHero() unterscheidet sich von updateHero() in zweierlei Hinsicht:\n Es ruft HttpClient.post() anstelle von put() auf. Es erwartet, dass der Server eine ID für den neuen Helden erzeugt, die er in Observable\u003cHero\u003e an den Aufrufer zurückgibt.  Aktualisiere den Browser und füge einige Helden hinzu.\nEinen Helden löschen Jeder Held in der Heldenliste sollte einen Löschknopf haben.\nFüge das folgende Schaltflächenelement in die HeroesComponent-Vorlage ein, nach dem Helden Namen in dem wiederholten \u003cli\u003e Element.\nsrc/app/heroes/heroes.component.html\n1 2  \u003cbutton class=\"delete\" title=\"delete hero\" (click)=\"delete(hero)\"\u003ex\u003c/button\u003e   Der HTML-Code für die Liste der Helden sollte wie folgt aussehen:\nsrc/app/heroes/heroes.component.html (list of heroes)\n1 2 3 4 5 6 7 8 9  \u003cul class=\"heroes\"\u003e \u003cli *ngFor=\"let hero of heroes\"\u003e \u003ca routerLink=\"/detail/{{hero.id}}\"\u003e \u003cspan class=\"badge\"\u003e{{hero.id}}\u003c/span\u003e {{hero.name}} \u003c/a\u003e \u003cbutton class=\"delete\" title=\"delete hero\" (click)=\"delete(hero)\"\u003ex\u003c/button\u003e \u003c/li\u003e \u003c/ul\u003e   So positionierst du die Schaltfläche zum Löschen ganz rechts im Heldeneintrag, füge der Datei heroes.component.css etwas CSS hinzu. Du findest dieses CSS im Überprüfungscode unten.\nFüge der Komponentenklasse den Handler delete() hinzu.\nsrc/app/heroes/heroes.component.ts (delete)\n1 2 3 4  delete(hero: Hero): void { this.heroes = this.heroes.filter(h =\u003e h !== hero); this.heroService.deleteHero(hero.id).subscribe(); }   Obwohl die Komponente das Löschen von Helden an den HeroService delegiert, bleibt sie für die Aktualisierung ihrer eigenen Liste von Helden verantwortlich. Die Methode delete() der Komponente entfernt den zu löschenden Helden sofort aus dieser Liste, in der Erwartung, dass der HeroService auf dem Server erfolgreich sein wird.\nEs gibt wirklich nichts, was die Komponente mit dem Observable tun könnte, das von heroService.delete() zurückgegeben wird aber sie muss sich trotzdem anmelden.\nWenn du es versäumst, `subscribe()` zu abonnieren, wird der Dienst die Löschanfrage nicht an den Server senden. In der Regel tut ein `Observable` _nichts_, bis sich etwas anmeldet. Bestätige dies selbst, indem du `subscribe()` vorübergehend entfernst, auf \"Dashboard\" und dann auf \"Heroes\" klickst. Du wirst wieder die vollständige Liste der Helden sehen.  Als nächstes füge eine Methode deleteHero() zu HeroService wie folgt hinzu.\nsrc/app/hero.service.ts (delete)\n1 2 3 4 5 6 7 8 9  /** DELETE: lösche der Hero vom Server */ deleteHero(id: number): Observable\u003cHero\u003e { const url = `${this.heroesUrl}/${id}`; return this.http.delete\u003cHero\u003e(url, this.httpOptions).pipe( tap(_ =\u003e this.log(`deleted hero id=${id}`)), catchError(this.handleError\u003cHero\u003e('deleteHero')) ); }   Beachte die folgenden wichtigen Punkte:\n deleteHero() ruft HttpClient.delete() auf. Die URL ist die Ressourcen-URL des Helden plus die id des zu löschenden Helden. Man sendet keine Daten wie bei put() und post(). Sie senden immer noch die httpOptions.  Aktualisiere den Browser und probiere die neue Löschfunktion aus.\nSuche nach Namen In dieser letzten Übung lernst du, wie man Observable-Operatoren miteinander verkettet so dass du die Anzahl ähnlicher HTTP-Anfragen minimieren kannst und lernst die Netzwerkbandbreite sparsam zu nutzen.\nDu wirst dem Dashboard eine Helden-Suchfunktion hinzufügen. Wenn der Benutzer einen Namen in ein Suchfeld eingibt, wirst du wiederholte HTTP-Anfragen für nach diesem Namen gefilterte Helden stellen. Dein Ziel ist es, nur so viele Anfragen wie nötig zu stellen.\nHeroService.searchHeroes() Beginne mit dem Hinzufügen einer Methode searchHeroes() zum HeroService.\nsrc/app/hero.service.ts\n1 2 3 4 5 6 7 8 9 10 11 12 13  /* GET Heros welche der Name dem term entspechen */ searchHeroes(term: string): Observable\u003cHero[]\u003e { if (!term.trim()) { // if not search term, return empty hero array.  return of([]); } return this.http.get\u003cHero[]\u003e(`${this.heroesUrl}/?name=${term}`).pipe( tap(x =\u003e x.length ? this.log(`found heroes matching \"${term}\"`) : this.log(`no heroes matching \"${term}\"`)), catchError(this.handleError\u003cHero[]\u003e('searchHeroes', [])) ); }   Die Methode kehrt sofort mit einem leeren Array zurück, wenn es keinen Suchbegriff gibt. Der Rest der Methode ähnelt stark getHeroes(), der einzige signifikante Unterschied ist die URL, die einen Abfrage-String mit dem Suchbegriff enthält.\nSuche zum Dashboard hinzufügen Öffne die Vorlage DashboardComponent und füge das Hero-Such-Element, \u003capp-hero-search\u003e, am unteren Ende des Markups hinzu.\nsrc/app/dashboard/dashboard.component.html\n1 2 3 4 5 6 7 8 9  \u003ch2\u003eTop Heroes\u003c/h2\u003e \u003cdiv class=\"heroes-menu\"\u003e \u003ca *ngFor=\"let hero of heroes\" routerLink=\"/detail/{{hero.id}}\"\u003e {{hero.name}} \u003c/a\u003e \u003c/div\u003e \u003capp-hero-search\u003e\u003c/app-hero-search\u003e   Diese Vorlage sieht dem *ngFor-Repeater in der Vorlage HeroesComponent sehr ähnlich.\nDamit dies funktioniert, muss im nächsten Schritt eine Komponente mit einem Selektor hinzugefügt werden, der auf \u003capp-hero-search\u003e passt.\nHeroSearchComponent erstellen Erstelle eine HeroSearchComponent mit der CLI.\n1  ng generate component hero-search   Das CLI generiert die drei HeroSearchComponent Dateien und fügt die Komponente zu den AppModule Deklarationen hinzu.\nErsetze die generierte HeroSearchComponent Vorlage mit einem \u003cinput\u003e und einer Liste von passenden Suchergebnissen, wie folgt.\nsrc/app/hero-search/hero-search.component.html\n1 2 3 4 5 6 7 8 9 10 11 12  \u003cdiv id=\"search-component\"\u003e \u003clabel for=\"search-box\"\u003eHero Search\u003c/label\u003e \u003cinput #searchBox id=\"search-box\" (input)=\"search(searchBox.value)\" /\u003e \u003cul class=\"search-result\"\u003e \u003cli *ngFor=\"let hero of heroes$ | async\" \u003e \u003ca routerLink=\"/detail/{{hero.id}}\"\u003e {{hero.name}} \u003c/a\u003e \u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e   Füge private CSS-Stile zu hero-search.component.css hinzu wie in der Code-Überprüfung unten aufgeführt.\nWenn der Benutzer in das Suchfeld eingibt, ruft eine Eingabe-Ereignisbindung die Komponente die Methode search() mit dem neuen Wert des Suchfeldes auf.\nAsyncPipe Der *ngFor wiederholt Heldenobjekte. Beachte, dass *ngFor über eine Liste namens heroes$ iteriert, nicht heroes. Das $ ist eine Konvention, die anzeigt, dass heroes$ ein Observable ist, nicht ein Array.\nsrc/app/hero-search/hero-search.component.html\n1  \u003cli *ngFor=\"let hero of heroes$ | async\" \u003e   Da *ngFor nichts mit einem Observable machen kann, verwende das Pipe-Zeichen (|) gefolgt von async. Dies identifiziert Angulars AsyncPipe und abonniert automatisch ein Observable, so dass du dies nicht in der Komponentenklasse zu machen hast.\nBearbeite die Klasse HeroSearchComponent. Ersetze die generierte HeroSearchComponent Klasse und die Metadaten wie folgt.\nsrc/app/hero-search/hero-search.component.ts\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  import { Component, OnInit } from '@angular/core'; import { Observable, Subject } from 'rxjs'; import { debounceTime, distinctUntilChanged, switchMap } from 'rxjs/operators'; import { Hero } from '../hero'; import { HeroService } from '../hero.service'; @Component({ selector: 'app-hero-search', templateUrl: './hero-search.component.html', styleUrls: [ './hero-search.component.css' ] }) export class HeroSearchComponent implements OnInit { heroes$!: Observable\u003cHero[]\u003e; private searchTerms = new Subject\u003cstring\u003e(); constructor(private heroService: HeroService) {} // Push a search term into the observable stream.  search(term: string): void { this.searchTerms.next(term); } ngOnInit(): void { this.heroes$ = this.searchTerms.pipe( // wait 300ms after each keystroke before considering the term  debounceTime(300), // ignore new term if same as previous term  distinctUntilChanged(), // switch to new search observable each time the term changes  switchMap((term: string) =\u003e this.heroService.searchHeroes(term)), ); } }   Beachte die Deklaration von heroes$ als Observable:\nsrc/app/hero-search/hero-search.component.ts\n1  heroes$!: Observable\u003cHero[]\u003e;   Du wirst es in ngOnInit() einstellen. Bevor du das tust, konzentrierst du dich auf die Definition von searchTerms.\nDas RxJS-Subjekt searchTerms Bei der Eigenschaft searchTerms handelt es sich um ein RxJS Subject.\nsrc/app/hero-search/hero-search.component.ts\n1 2 3 4 5 6  private searchTerms = new Subject\u003cstring\u003e(); // Push a search term into the observable stream. search(term: string): void { this.searchTerms.next(term); }   Ein Subject ist sowohl eine Quelle von Observable Werten als auch ein Observable selbst. Man kann ein Subject wie jedes Observable abonnieren.\nMan kann auch Werte in dieses Observable schieben indem man seine next(value) Methode aufruft aufruft, wie es die Methode search() tut.\nDie Ereignisbindung an das Ereignis input des Textfeldes ruft die Methode search() auf.\nsrc/app/hero-search/hero-search.component.html\n1  \u003cinput #searchBox id=\"search-box\" (input)=\"search(searchBox.value)\" /\u003e   Jedes Mal, wenn der Benutzer in das Textfeld eingibt, ruft die Bindung search() mit dem Wert des Textfeldes, einem “Suchbegriff”, auf. Der searchTerms wird zu einem Observable, das einen stetigen Strom von Suchbegriffen ausgibt.\nVerkettung von RxJS-Operatoren Die direkte Übergabe eines neuen Suchbegriffs an searchHeroes() nach jedem Tastendruck des Benutzers würde eine übermäßige Anzahl von HTTP-Anfragen erzeugen, die die Server-Ressourcen belasten und die Datentarife auslasten.\nStattdessen leitet die Methode ngOnInit() die Observable searchTerms durch eine Reihe von RxJS-Operatoren, die die Anzahl der Aufrufe von searchHeroes() reduzieren, und schließlich eine Observable mit zeitnahen Helden-Suchergebnissen (jeweils ein Hero[]) zurückgibt.\nHier ist ein genauerer Blick auf den Code.\nsrc/app/hero-search/hero-search.component.ts\n1 2 3 4 5 6 7 8 9 10  this.heroes$ = this.searchTerms.pipe( // wait 300ms after each keystroke before considering the term  debounceTime(300), // ignore new term if same as previous term  distinctUntilChanged(), // switch to new search observable each time the term changes  switchMap((term: string) =\u003e this.heroService.searchHeroes(term)), );   Jeder Operator funktioniert wie folgt:\n  debounceTime(300) wartet, bis der Fluss neuer String-Ereignisse für 300 Millisekunden pausiert bevor er die letzte Zeichenkette weitergibt. Du wirst nie häufiger als 300ms Anfragen stellen.\n  distinctUntilChanged() stellt sicher, dass eine Anfrage nur gesendet wird, wenn sich der Filtertext geändert hat.\n  switchMap() ruft den Suchdienst für jeden Suchbegriff auf, der es durch debounce() und distinctUntilChanged() schafft. Es annulliert und verwirft vorherige Suchbeobachtungen und gibt nur die letzte Suchdienstbeobachtung zurück.\n   Mit dem switchMap-Operator, kann jedes qualifizierte Schlüsselereignis einen Aufruf der Methode HttpClient.get() auslösen. Selbst bei einer Pause von 300 ms zwischen den Anfragen können mehrere HTTP-Anfragen im Umlauf sein und diese kehren möglicherweise nicht in der gesendeten Reihenfolge zurück.\nswitchMap() behält die ursprüngliche Reihenfolge der Anfragen bei und gibt nur die Observable des letzten HTTP-Methodenaufrufs zurück. Ergebnisse von früheren Aufrufen werden abgebrochen und verworfen.\nBeachte, dass das Abbrechen einer vorherigen searchHeroes() Observable nicht wirklich eine anhängige HTTP-Anfrage abbricht. Unerwünschte Ergebnisse werden verworfen, bevor sie Ihren Anwendungscode erreichen.\n Denke daran, dass die Klasse der Komponente nicht die Observable “heroes$” abonniert. Das ist die Aufgabe der AsyncPipe in der Vorlage.\nVersuche es Starte die Anwendung erneut. Gib im Dashboard einen Text in das Suchfeld ein. Wenn du Zeichen eingibst, die mit einem vorhandenen Heldennamen übereinstimmen, siehst du etwas wie das hier.\nAbschließende Überprüfung des Codes Hier oder hier sind die auf dieser Seite besprochenen Codedateien.\nZusammenfassung Du bist am Ende Ihrer Reise angelangt und hast eine Menge erreicht.\n Du hast die notwendigen Abhängigkeiten hinzugefügt, um HTTP in der Anwendung zu verwenden. Du hast HeroService umstrukturiert, um Helden von einer Web-API zu laden. Du hast HeroService erweitert, um die Methoden post(), put() und delete() zu unterstützen. Du hast die Komponenten aktualisiert, um das Hinzufügen, Bearbeiten und Löschen von Helden zu ermöglichen. Du hast eine speicherinterne Web-API konfiguriert. Du hast gelernt, wie man Observables verwendet.  Dies ist der Abschluss des Tutorials “Tour of Heroes” herzlichen Glückwunsch.\n","categories":"","description":"In diesem Tutorial fügst du die folgenden Datenpersistenzfunktionen mit Hilfe von Angulars `HttpClient` hinzu.\n","excerpt":"In diesem Tutorial fügst du die folgenden Datenpersistenzfunktionen …","ref":"/docs/web/angular/05_7_data_server/","tags":"","title":"Daten von einem Server abrufen"},{"body":"Der Tag wird kommen, an dem du ein HTML-Element an einer bestimmten Position haben willst.\nrelative Positionierung: Element ein bisschen verschieben Angenommen, du hast z.B. ein Bild in einem Text:\n1 2 3 4 5 6 7 8 9 10 11  Are you a \u003cimg src=\"\thttps://it-ninjas.ch/img/svg/Ninja%20Elements_kopf.svg\" alt=\"\" /\u003e? \u003cstyle\u003e body { font-size: 5em; } img { height: 1em; } \u003c/style\u003e   Dann wird das Bild wahrscheinlich nicht perfekt im Text ausgerichtet sein. In diesem Beispiel wollen wir das Bild ein bisschen nach unten verschieben. Dann kannst du das wie folgt machen:\n1 2 3 4 5  img { position: relative; top: 0.2em; ... }   Mit position: relative bewirken wir, dass CSS-Properties wie top, bottom, left und right beachtet werden. Dank der relativen Positionierung dürfen wir dann das Element verschieben, ohne dass es andere Elemente bzw. den Textfluss verändert. Wir haben hier top verwendet, um oben einen Abstand einzufügen. Würdest du left verwenden, so würde sich das Element entsprechend nach rechts verschieben.\nHierzu findest du eine Aufgabe im Lab.\nabsolute Positionierung Möchtest du ein Element auf einer bestimmten Position haben, dann hilft dir womöglich position: absolute weiter:\n1 2 3 4 5 6 7 8 9 10 11 12  Are you a \u003cimg src=\"\thttps://it-ninjas.ch/img/svg/Ninja%20Elements_kopf.svg\" alt=\"\" /\u003e? \u003cstyle\u003e img { position: absolute; top: 20em; right: 10em; height: 150px; } \u003c/style\u003e   Mache den Browser mal ein bisschen kleiner und schaue, wie sich die Positionierung verhält, wenn du scrollst.\nMöchtest du, dass die Positionierung immer gleich - unabhängig vom Scrollen - ist? Dann versuche es einmal mit position: fixed.\nHierzu findest du eine Aufgabe im Lab.\n","categories":"","description":"HTML-Elemente auf der Seite positionieren.\n","excerpt":"HTML-Elemente auf der Seite positionieren.\n","ref":"/docs/web/html_css/17_css_positioning/","tags":"","title":"Positionierung"},{"body":"Bist du bereit für das Exam? Wenn nein, dann darfst du gerne den CSS-Teil aus dem Intro to HTML and CSS - Udacity-Kurs anschauen.\nWenn du bereit bist, dann prüfe dein Wissen mit dem Exam.\n","categories":"","description":"Genug Theorie! Wage dich ans Exam!\n","excerpt":"Genug Theorie! Wage dich ans Exam!\n","ref":"/docs/web/html_css/18_css_finish/","tags":"","title":"Abschluss"},{"body":"In Frontend-Projekten wirst du dich immer wieder fragen, ob bereits ein Objekt gleich gestylt wurde wie eines, welches du gerade stylen möchtest. Du wirst es aber vielleicht nicht finden oder du schreibst die genau gleiche Regel ein weiteres Mal. Das führt dazu, dass im Code sehr viele CSS-Leichen zu finden sein werden.\nUm diesem Problem entgegenzuwirken, verwendet man oft eine CSS-Datei, die für das ganze Projekt gelten soll.\nWenn du aber oft das Projekt wechselst, wirst du aber nicht den Überblick haben oder bekommen, was für ein Konzept früher im CSS-Code versucht wurde umzusetzen.\nAus diesem Grund kann es Sinn machen, projekt-übergreifend ein gleiches CSS-Framework zu verwenden, wo die gleichen CSS-Klassen immer gleich heissen.\nHier kommt Bootstrap ins Spiel: Es bietet viele CSS-Klassen bereits an und vereinfacht komplexes Styling teilweise extrem. Z.B. kannst du komplett mühelos Accordions (bzw. Tabs) erstellen, die dann beim Klick auf deren Titel ihren Inhalt dann anzeigen/verstecken inkl. Animation.\nBootstrap Bootstrap wird in sehr vielen Projekten bereits benutzt. Und so einfach kannst du es auch in deine HTML-Dateien einbinden:\n1 2 3 4 5  \u003c!-- Latest compiled and minified CSS --\u003e \u003clink href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css\" rel=\"stylesheet\"\u003e \u003c!-- Latest compiled JavaScript --\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js\"\u003e\u003c/script\u003e   Eine grosse Stärke von Bootstrap ist es, dass sich deine Seite ‘responsive’ verhält: Du kannst mit einer CSS-Klasse (col-md-4 z.B.) definieren, dass ein Element im Normalfall 4/12 der Breite einnimmt (4 ist in der Klasse angegeben, Bootstrap arbeitet mit 12 Spalten). Ist dein Browser weniger breit als eine bestimmte Weite (md -\u003e medium), so werden dann die Elemente automatisch untereinander angezeigt.\nDa wir vermehrt Bootstrap einsetzen möchten, empfehlen wir dir, Bootstrap anzuschauen. Hier findest du ein Tutorial zur aktuellen Version: https://www.w3schools.com/bootstrap5/index.php.\nBitte probiere folgendes so aus, dass du es anwenden kannst:\n GET Started Containers Grid Basic Tables Buttons Collapse Flex  Bei den folgenden solltest du einfach wissen, dass Bootstrap hierfür auch eine Lösung bereitstellt:\n Colors Images Alerts Button Groups Badges Progress Bars \u0026 Spinners Pagination List Groups Cards Dropdowns Navbar Carousel Modal Tooltip Popover Toast Scrollspy Utilities alles unter Forms  Hierzu findest du eine Aufgabe im Lab.\n","categories":"","description":"Einmal CSS schreiben genügt! Brauch ein CSS-Framework, damit wir nicht immer wieder die gleichen CSS-Regeln schreiben.\n","excerpt":"Einmal CSS schreiben genügt! Brauch ein CSS-Framework, damit wir nicht …","ref":"/docs/web/html_css/19_css_bootstrap/","tags":"","title":"Bootstrap"},{"body":"Ziele  Ich kann erklären, was Collections sind. Ich kenne grob den Aufbau des Collection Frameworks. Ich kenne die wichtigsten Interfaces und ihre Merkmale: Lists, Sets, Queues, Maps Ich kenne die wichtigsten Implementationen und ihre Merkmale: ArrayList, HashSet, HashMap Ich kenne die Klasse ArrayList gut und kann diese richtig anwenden. Ich kenne die Klasse HashSet gut und kann diese richtig anwenden. Ich kenne die Klasse HashMap gut und kann diese richtig anwenden. Ich kenne die wichtigsten Algorithmen und Methoden zu den Collections. Ich weiss, wann und wofür ich welche Collections benutzen kann.  Voraussetzungen  Gute Grundlagenkenntnisse von Java-Anwendungen   Einleitung Beim Programmieren müssen wir oft Daten speichern bzw. Informationen verwalten, um gewisse Probleme zu lösen. In diesem Modul werden wir das Java Collection Framework anschauen, weil dieses Framework uns die Werkzeuge zum effizienten Verwalten von Informationen liefert.\nEine Collection ist ein Objekt, dass eine Sammlung von Objekten darstellt, d.h. mehrere Elemente zu einer Einheit zusammenfasst. In der Regel enthält eine Collection Datenelemente, die zusammen eine natürliche Gruppe bilden, wie z.B. eine Fussballmannschaft, die eine “Sammlung” von Fussballspielern ist, d.h. Fussballspieler enthält. Collections bieten uns im Allgemeinen die Möglichkeit neue Elemente hinzuzufügen, Elemente zu löschen und sonst die Elemente zu verwalten.\nEin bekanntes Beispiel für eine Collection ist die ArrayList Klasse, wobei eine ArrayList eine Liste von Objekten darstellt, welche skalierbar ist. Die ArrayList Klasse liefert uns beispielsweise die Methode add, mit welcher Elemente an das Ende einer Liste angefügt werden kann:\n1 2 3 4 5  List\u003cString\u003e farben=new ArrayList\u003cString\u003e(); farben.add(\"rot\"); farben.add(\"blau\"); farben.add(\"gelb\"); farben.add(\"orange\");   Oder sie liefert uns die Methode remove, welche Elemente aus der Liste entfernt:\n1 2 3 4 5  List\u003cString\u003e farben=new ArrayList\u003cString\u003e(); farben.add(\"rot\"); farben.add(\"blau\"); farben.add(\"gelb\"); farben.remove(\"blau\");   Wir werden die ArrayList Klasse später noch genauer anschauen.\nDas Java Collection Framework ist eine Menge von Interfaces und Klassen, die allgemein wiederverwendbare Collection-Datenstrukturen liefern. Es bietet uns also sowohl Interfaces, die Collection-Typen definieren, als auch Klassen, die diese implementieren an. Obwohl es als Framework bezeichnet wird, funktioniert es im Grunde wie eine Library.\nDas Java Collections Frameworks stellt für uns Hochleistungsimplementierungen von Datenstrukturen und Algorithmen bereit, um Sammlungen von Objekten beliebiger Datentypen darzustellen. Da wir diese Funktionalität nicht immer selber programmieren müssen, reduziert sich für uns der Programmieraufwand markant.\nDas Java Collection Framework befindet sich im Paket java.util.\nWir haben die ArrayList Klasse (java.util.ArrayList) als Beispiel für eine Collection gesehen. Die ArrayList Klasse repräsentiert eine Collection vom Typ List (implementiert also das Interface java.util.List) und wird mithilfe von zugrunde liegenden Arrays implementiert, deshalb auch der Name ArrayList. Es gibt aber auch andere Klassen, welche Collections vom Typ List darstellen: Wir werden später einige davon noch sehen.\nTheorie  Das Java Collection Framework ist eine einheitliche Architektur zur Darstellung und Bearbeitung von Collections, welche folgendes enthält:\n  Interfaces: Dies sind abstrakte Datentypen, welche verschiedene Collections darstellen. Mithilfe von Interfaces können Collections unabhängig von den Details ihrer Darstellung bearbeitet werden. Die Interfaces bilden in Java die Hierarchie aller Collections.\n  Implementierungen/Klassen: Dies sind die konkreten Implementierungen der Collection-Interfaces. Im Grunde handelt es sich um wiederverwendbare Datenstrukturen, mit konkreten Implementierungen.\n  Algorithmen/Methoden: Dies sind die Methoden, die nützliche Algorithmen, wie z. B. Hinzufügen, Löschen, Suchen und Sortieren, von Objekten in Collections durchführen. Viele Methoden und Algorithmen sind für verschiedene Arten der Collections wiederverwendbar.\n  Die Interfaces in der folgenden Abbildung (Collections, Set, List, Queue, Deque, Map …) bilden die Grundlage des Collection Frameworks. Durch diese grundlegenden Interfaces bildet sich eine Hierarchie innerhalb des Collection Frameworks:\nAuf dieser Grafik ist sichtbar, dass zum Beispiel:\n Sets spezielle Typen von Collections sind. SortedSets wiederum sind spezielle Typen von Sets. Lists sind spezielle Typen von Collections. ArrayLists sind spezielle Typen von Lists.  In der Abbildung sieht man zu dem, dass das Collection Framework aus zwei verschiedenen Teilen besteht: Zum einen die Collections und zum anderen die Maps. Maps stellen somit keine “echten” Collections dar. Maps sind trotzdem Datenstrukturen zur Darstellung von Sammlungen von Objekten als eine Einheit.\n Collection Eine Collection ist ein Objekt, dass eine Sammlung von Objekten darstellt, d.h. mehrere Elemente zu einer Einheit zusammenfasst. In der Regel enthält eine Collection Datenelemente, die zusammen eine natürliche Gruppe bilden, wie z.B. eine Fussballmannschaft, die eine “Sammlung” von Fussballspielern ist, d.h. Fussballspieler enthält. Collections bieten uns im Allgemeinen die Möglichkeit neue Elemente hinzuzufügen, Elemente zu löschen und sonst die Elemente zu verwalten.\nAllgemeine Methoden:\nsize(), isEmpty(), contains(Object element), add(E element), remove(Object element), clear(), iterator()\nSammelmethoden:\ncontainsAll(Collection\u003c?\u003e c), addAll(Collection\u003c? extends E\u003e c), removeAll(Collection\u003c?\u003e c), retainAll(Collection\u003c?\u003e c)\nList Eine List ist eine geordnete Sequenz, welche duplizierte Elemente erlaubt. Zusätzlich zu den vererbten Methoden der Collection bietet die List folgende an:\nElemente auf Basis ihrer Position zugreifen: get, set, addAll\nSuche nach einem bestimmten Element in der Liste:\nindexOf, lastIndexOf\nIteriert durch die Liste:\nlistIterator\nEin Teilbereich der Lite erstellen:\nsublist\n Es existieren zwei allgemeine Set Implementierungen:\n ArrayList welche in Normalfall die leistungsfähigere ist. LinkedList welche bei bestimmten Anwendungsfällen die bessere Lösung ist.   Set Ein Set ist eine Collection, in welche man ein Element nur einmal hinzufügen kann. Das Set enthält die Funktionen der Collection, stellt aber sicher, dass Kopien von Elementen verhindert werden. Die equals und hashCode Funktionen spielen dabei eine wichtige Rolle. Sie definieren, wann zwei Elemente gleich sind.\nElemente hinzufügen, löschen und Infos abfragen: add(), contains(), remove(), clear(), size(), isEmpty()\nSammelmethoden: addAll(), removeAll(), containsAll()\nZugriff wie auf eine Collection: iterator()\n Es existieren drei allgemeine Set Implementierungen:\n HashSet: Speichert die Elemente in einer Hash-Table, welche die leistungsstärkste Implementierung darstellt. Nachteil: Die Implementierung garantiert keine Reihenfolge. TreeSet: Speichert die Elemente in einem Red-Black Tree und ordnet die Elemente anhand deren Werte ein. Die Implementierung ist wesentlich langsamer als das HashSet. LinkedHashSet: Speichert die Elemente in einer Hash-Tabel ab, welche als verknüpfte Liste (Linked List) implementiert ist. Die Reihenfolge der Elemente entspricht der Reihenfolge, wie sie in das Set eingefügt wurden. Diese Implementierung hat einen geringfügigen höheren Preis als das HashSet.   Map Eine Map ist ein Objekt, dass Schüssel (keys) auf Werte (values) zuordnet. Eine Map kann nicht zwei gleiche Schlüssel enthalten. Jeder Schlüssel zeigt genau auf einen Wert. Das Interface Map definiert Grundfunktionen für das Einfügen, Lesen, Löschen, Abfragen von Schlüsseln usw.\nZusätzlich zu den vererbten Methoden der Collection bietet die List folgende an:\nElemente auf Basis ihrer Position zugreifen: put(), get(), containsKey(), containsValue()\nSammelmethoden: putAll()\nZugriff wie auf eine Collection: keySet(), entrySet(), values()\n Es existieren drei allgemeine Map Implementierungen, deren Verhalten analog den drei Set Implementierungen (HashSet, TreeSet, and LinkedHashSet) entspricht:\n HashMap: Speichert die Elemente in einer Hash-Table, welche die leistungsstärkste Implementierung darstellt. Nachteil: Die Implementierung garantiert keine Reihenfolge.. TreeMap: Speichert die Elemente in einem Red-Black Tree und ordnet die Elemente anhand deren Werte ein. Die Implementierung ist wesentlich langsamer als das HashMap. LinkedHashMap: Speichert die Elemente in einer Hash-Tabel ab, welche als verknüpfte Liste (Linked List) implementiert ist. Die Reihenfolge der Elemente entspricht der Reihenfolge, wie sie in die Map eingefügt wurden. Diese Implementierung hat einen geringfügigen höheren Preis als das HashMap.   Performanz Das Collection-Framework macht regen Gebrauch von der Hash-Funktion. Klassen wie HashSet oder HashMap verwenden die Hash-Funktoin zur Steigerung der Performanz.\nHash-Funktion Alle Java Klassen erben von der Klasse java.lang.Object die Methode public int hashCode(). Diese liefert ein Hash Code von der eigenen Instanz zurück. Bei Java ist diese ein Integer.\n Hashing bezeichnet die Umwandlung einer Zeichenfolge in einen normalerweise kürzeren, numerischen Wert oder Schlüssel mit fester Länge.\n Der Java Hash Code ist nicht immer eindeutig. Es kann also vorkommen, dass unterschiedliche Instanzen von unterschiedlichen Klassen den gleichen Hash Code zurückreichen. In der Praxis ist das kein Problem, da der Hash Code nur für eine Vorselektierung verwendet wird.\nVerwendung Stellen wir uns den Einsatz bei einem Set vor: Bei einem Set können wir mit der Methode contains(Object o) abfragen, ob ein Objekt in einem Set vorhanden ist. Das Set muss somit jedes Objekt mit dem Objekt vergleichen, welches wir der Methode contains übergeben. Wenn wir uns vorstellen, dass ein Objekt viele Instanzvariablen enthalten kann, welche wiederum Objekte sein können, so kann jeder Vergleich eine aufwändige Arbeit sein.\nBei einer Handvoll Objekte im Set ist das vernachlässigbar. Bei einigen tausend Objekte sieht es schon schlechter aus.\nDie Klasse HashSet wendet eine andere Strategie an:\n Beim Hinzufügen eines neuen Objekts, berechnet sie mit der hashCode() Methode deren Hash Code. Dieser Hash Code wird für das neue Objekt gespeichert. Bei der Methode contains(Object o) berechnet sie den Hash Code des Vergleichsobjekts. Anschliessen vergleicht sie diesen mit den gespeicherten Hash Code (Integer-Vergleich). Da der Java Hash Code nicht eindeutig ist, vergleicht sie bei jedem Treffer zur Sicherheit beide Objekte mit der equals(Object o) Methode.   Mit dem Hash Code Strategie kann das HashSet die allermeisten Vergleiche auf ein Integer-Vergleich vereinfachen.\n Anforderung an die Hash Berechnung Was ist die Anforderung an die Java hashCode() Methode?\n  Die Berechnung muss schnell sein. Der Hash Code sollte in der Praxis meistens eindeutig sein.   ","categories":"","description":"Modul #J7\n","excerpt":"Modul #J7\n","ref":"/docs/java/java-collections/","tags":"","title":"Java Collections"},{"body":"In diesem Doc sind die wichtigsten Take-aways des Tour of Heroes Tutorials von Angular zusammengefasst.\nDie Dokumentation von Angular und das Tutorial findest du unter angular.io/docs.\nTeil 1 - Angular components Components sind die Bausteine von Angular-Apps. Eine App besteht normalerweise aus verschiedenen components.\nDas Grundgerüst eines component kannst du mit dem CLI von Angular erstellen.\nDie Implementierung besteht vor allem aus drei Quelldateien: TypeScript-Klasse, HTML-Template und einer Datei mit CSS-Styles.\nErstellung eines component\nUm einen component mit dem CLI zu erstellen, verwende innerhalb des im Setup erstellten Basisverzeichnis den Befehl\n1  ng generate component \u003ccomponent-name\u003e   Hier ist \u003ccomponent-name\u003e die Bezeichnung des Verzeichnis, das für den component erstellt wird. Die Abkürzungng steht für Angular.\nVerzeichnisstruktur eines component\nDie Verzeichnisse der einzelnen components befinden sich normalerweise innerhalb des Verzeichnisses \u003cbase-directory\u003e/src/app.\nDie Verzeichnisstruktur eines components \u003ccomponent-name\u003e sieht folgendermassen aus:\n1 2 3 4 5  └── \u003ccomponent-name\u003e ├── \u003ccomponent-name\u003e.component.css ├── \u003ccomponent-name\u003e.component.html ├── \u003ccomponent-name\u003e.component.spec.ts └── \u003ccomponent-name\u003e.component.ts   Quellcode eines component\nDer vom CLI erstellte Code der TypeScript-Klasse eines component mit der Bezeichnung example ist unten aufgelistet.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  import { Component, OnInit } from '@angular/core'; @Component({ selector: 'app-example', templateUrl: './example.component.html', styleUrls: ['./example.component.css'] }) export class ExampleComponent implements OnInit { constructor() { } ngOnInit() { } }   @Component ist ein decorator und enthält Metadaten für Angular. Im Code oben sind drei Eigenschaften definiert:\n selector: element selector für den component templateUrl: URL für das HTML-Template des component styleUrls: Liste mit URLs für Dateien mit CSS-Styles für den component  Element selector eines component\nMit dem element selector eines component kann man den component im HTML-Template eines anderen component einbinden. Der selector ist zusammen mit anderen Metadaten im decorator @Component definiert.\n1  \u003capp-example\u003e\u003c/app-example\u003e   Deklaration eines component\nUm einen component an einer anderen Stelle mit dem element selector zu verwenden, muss man den component in \u003cbase-directory\u003e/src/app/app.module.ts deklarieren.\n1 2 3 4  declarations: [ AppComponent, ExampleComponent ]   Allgemein muss man jeden component in genau einem NgModule deklarieren. Meistens deklariert man components im AppModule, also in \u003cbase-directory\u003e/src/app/app.module.ts .\nTeil 2 - Property binding Mit property bindings kann man im HTML-Template eines component auf Eigenschaften der TypeScript-Klasse zugreifen.\nInterpolation binding und Pipes\nEin Beispiel für interpolation ist unten aufgelistet. Im Beispiel greift man im HTML-Tmplate des component auf eine Eigenschaft der TypeScript-Klasse zu.\n example.component.ts (click to expand) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  import { Component, OnInit } from '@angular/core'; @Component({ selector: 'app-example', templateUrl: './example.component.html', styleUrls: ['./example.component.css'] }) export class ExampleComponent implements OnInit { exampleName : string = 'interpolation'; constructor() { } ngOnInit() { } }    1  \u003ch2\u003e{{exampleName}}\u003c/h2\u003e   Mit pipes | kann man Strings, die man mit interpolation im HTML-Template einbindet, formatieren.\nIm Beispiel unten formatiert man einen String in uppercase.\n1  \u003ch2\u003e{{heroName | uppercase}}\u003c/h2\u003e   Two-way binding\nMit einem two-way binding kann man eine Eigenschaft einer TypeScript-Klasse an eine HTML-Textbox binden.\nBei einem two-way binding fliessen Daten in beide Richtungen. Wenn die Eigenschaft der TypeScript-Klasse geändert wird, ändert sich der Text in der Textbox und umgekehrt.\nUm ein two-way binding zu erstellen, verwendet man das Attribut [(ngModel)].\n example.component.ts (click to expand) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  import { Component, OnInit } from '@angular/core'; @Component({ selector: 'app-example', templateUrl: './example.component.html', styleUrls: ['./example.component.css'] }) export class ExampleComponent implements OnInit { exampleName : string = 'two-way binding'; constructor() { } ngOnInit() { } }    1 2 3  \u003cdiv\u003e \u003cinput [(ngModel)]=\"exampleName\"\u003e \u003c/div\u003e   Um two-way bindings zu verwenden, muss man das Modul FormsModule im im AppModule (beziehungsweise in \u003cbase-directory\u003e/src/app/app.module.ts) importieren und im Array imports auflisten.\n1  import { FormsModule } from '@angular/forms';   1 2 3 4  imports: [ BrowserModule, FormsModule ]   Class binding\nMit einem class binding kann man eine CSS class unter einer Bedingung zu einem HTML-Element hinzufügen oder entfernen.\nim Beispiel unten ändert sich der CSS-Style abhängig davon, ob highlightName true ist oder nicht.\n example.component.ts (click to expand) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  import { Component, OnInit } from '@angular/core'; @Component({ selector: 'app-example', templateUrl: './example.component.html', styleUrls: ['./example.component.css'] }) export class ExampleComponent implements OnInit { exampleName : string = 'class binding'; highlightName : boolan = true; constructor() { } ngOnInit() { } }    1 2 3  \u003cli [class.selected]=\"highlightName\"\u003e {{exampleName}} \u003c/li\u003e   Input property binding und @Input() decorator\nMit dem decorator @Input() kann man eine Eigenschaft einer TypeScript-Klasse als input property festlegen.\nDamit kann ein externer component an diese Eigenschaft gebunden werden, im Sinn einer Eingabe-Eigenschaft.\n1  \u003capp-hero-detail [hero]=\"selectedHero\"\u003e\u003c/app-hero-detail\u003e   1  @Input() hero?: Hero;   Dabei ist [hero] die Syntax für ein property binding. Dabei handelt es sich um ein one-way data binding, von der Eigenschaft selectedHero der TypeScript-Klasse des äusseren component zur Eigenschaft hero der TypeScript-Klasse des inneren component.\nDas property binding updated bei einer Änderung der Eigenschaft selectedHero die Eigenschaft hero ebenfalls.\nMit dem property binding wird einem parent component Kontrolle über einen child component gegeben.\nTeil 3 - Angular directives ngFor, ngIf structural directives\nMit dem structural directive *ngFor kann man innerhalb des HTML-Template durch mehrere Elemente der TypeScript-Klasse iterieren.\n example.component.ts (click to expand) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  import { Component, OnInit } from '@angular/core'; @Component({ selector: 'app-example', templateUrl: './example.component.html', styleUrls: ['./example.component.css'] }) export class ExampleComponent implements OnInit { examples : string[] = [ \"interpolation\", \"two-way binding\", \"class binding\" ] constructor() { } ngOnInit() { } }    1 2 3  \u003cli *ngFor=\"let exampleName of examples\"\u003e {{exampleName}} \u003c/li\u003e   Um einen Bereich des HTML-Templates nur unter einer Bedingung darzustellen, verwendet man das structural directive *ngIf.\nZum Beispiel kann man testen, ob eine Eigenschaft der TypeScript-Klasse null oder undefined ist.\n example.component.ts (click to expand) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  import { Component, OnInit } from '@angular/core'; @Component({ selector: 'app-example', templateUrl: './example.component.html', styleUrls: ['./example.component.css'] }) export class ExampleComponent implements OnInit { exampleName : string = \"interpolation\"; selectedExample : string = \"interpolation\"; constructor() { } ngOnInit() { } }    1 2 3  \u003cdiv *ngIf=\"exampleName == selectedExample\"\u003e {{exampleName}} \u003c/div\u003e   Teil 4 - User events, event handlers Click event binding, click event handler\nUm einen click event handler zu registrieren, verwendet man das Attribut (click).\n example.component.ts (click to expand) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  import { Component, OnInit } from '@angular/core'; @Component({ selector: 'app-example', templateUrl: './example.component.html', styleUrls: ['./example.component.css'] }) export class ExampleComponent implements OnInit { examples : string[] = [ \"interpolation\", \"two-way binding\", \"class binding\" ] selectedExample : string = \"interpolation\"; constructor() { } ngOnInit() { } onSelect(example: string): void { this.selectedExample = example; } }    1 2 3 4  \u003cli *ngFor=\"let example of examples\" (click)=\"onSelect(example)\"\u003e \u003c/li\u003e \u003ch2\u003e{{selectedExample}}\u003c/h2\u003e   Teil 5 - Services Mit Services kann man in Angular Daten vom Server laden.\nUm einen Service innerhalb eines component zu verwenden, verwendet man dependency injection. Dependency injection ist ein Design Pattern, bestehend aus client, service und injector.\n@Injectable decorator\nUm einen Service über das dependency injection system von Angular zu verwenden, registriert man den Service bei einem injector.\nFür die Registrierung verwendet man den decorator @Injectable. Normalerweise registriert man den Service beim injector root.\n1 2 3  @Injectable({ providedIn: 'root', })   Wenn ein Service vom injector root bereitgestellt wird, erstellt Angular ein Singleton des Service. Das heisst, es gibt nur eine Instanz des Service. Alle clients verwenden dieselbe Instanz des Service.\nEin Service kann selber injected dependencies haben.\nDependency injection\nBei der dependency inejction übergibt man einen Service dem Konstruktor der TypeScript-Klasse eines component.\n1  constructor(private heroService: HeroService) {}   Anschliessend kann man den Service innerhalb der Klasse verwenden.Der Service ist jetzt eine Eigenschaft der TypeScript-Klasse.\nWenn man zu einer mit dependency inejction hinzugefügten Eigenschaft einer TypeScript-Klasse im HTML-Template ein binding erstellen will, muss die Eigenschaft public sein.\nLifecycle hook ngOnInit()\nServices sollten Daten nicht im Konstruktor laden, sondern im lifecycle hook ngOnInit().\nObserver Pattern\nDas Laden von Daten durch einen Service kann eine asynchrone Operation sein. Zum Beispiel weiss man beim Laden von Daten von einem Server nicht genau, wann die Daten eintreffen.\nUm dieses Problem zu vermeiden, registriert man beim Laden von Daten von einem Service eine Callback-Funktion. Sobald das Laden der Daten abgeschlossen ist, wird die Callback-Funktion aufgerufen.\nErstens hat man eine Funktion, die ein Objekt vom Typ Observable\u003cT\u003e zurückgibt. Der type parameter T gibt den Datentyp der Daten an, die man vom Service haben will.\n Funktionen für HTTP requests des http client von Angular liefern oft Daten vom Typ Observable. Mit der Funktion of kann man Daten vom Typ T in ein Objekt vom Typ Òbservable\u003cT\u003e einpacken.  1 2 3  // Code in der TypeScript-Klasse des Service  import { Observable, of } from 'rxjs';   1 2 3 4 5  // Code in der TypeScript-Klasse des Service  getHeroes(): Observable\u003cHero[]\u003e { return of(HEROES); }   Ein Objekt vom Typ Observable hat die Funktion subscribe().\nDer Funktion subscribe() übergibt man eine Callback-Funktion (im Beispiel unten eine Lambda-Expression). Sobald die Daten des Service bereit sind, werden die Daten an die Callback-Funktion übergeben.\n1 2 3 4 5 6  // Code in der TypeScript-Klasse des client  getHeroes(): void { this.heroService.getHeroes() .subscribe(loadedHeroes =\u003e this.heroes = loadedHeroes); }   Teil 6 - Router Mit dem Router von Angular ändert man den angezeigten component abhängig von der URL.\nRouter-Modul\nDen Router konfiguriert man in einem separaten Modul AppRoutingModule, beziehungsweise in der Datei {base_dir}/src/app/app-routing.module.ts.\nUm das Modul zu erstellen, verwende den folgenden Befehl:\n1  ng generate module app-routing --flat --module=app    Mit --flat wird das Modul ohne eigenes Verzeichnis erstellt. Mit --module=app wird das Modul bei den imports von AppModule aufgelistet.  Ersetze den generierten Quellcode mit folgendem Code:\n app-routing.module.ts (click to expand) 1 2 3 4 5 6 7 8 9 10 11 12 13 14  import { NgModule } from '@angular/core'; import { RouterModule, Routes } from '@angular/router'; const routes: Routes = []; @NgModule({ imports: [ RouterModule.forRoot(routes) ], exports: [ RouterModule ] }) export class AppRoutingModule { }    \nDer vom Router angezeigte component wird normalerweise mit dem selector\n1  \u003crouter-outlet\u003e\u003c/router-outlet\u003e   in das HTML-Template des component AppComponent eingebunden.\nDeklaration\nUm den selector \u003crouter-outlet\u003e zu verwenden, muss das Modul AppRoutingModule im Modul AppModule, beziehungsweise in {base_directory}/src/app/app.module.ts importiert sein.\nRoutes\nEine Route gibt dem Router an, welchen component er bei einer bestimmten URL anzeigen soll. Routes sind im Array routes des Router-Moduls AppRoutingModule aufgelistet.\nNormalerweise hat eine Route zwei Eigenschaften:\n path: String, um eine URL in der Adresszeile des Browsers zu matchen component: Component, den der Router für die gematchte URL anzeigen soll  Route ist ein Interface.\nBeispiel:\n1 2 3  const routes: Routes = [ {path : 'example', component : ExampleComponent} ];   Route für die Basis-URL\nDer path für die Basis-URL der App ist der leere String ''.\n1  path = '';   Route mit Parametern\nit der Syntax :\u003cparameter-name\u003e definiert man einen Teil einer Route als Parameter.\nIm angezeigten component liest man dann die URL aus, extrahiert den Wert des Parameters aus der URL, und passt den component an.\nBeispiel:\n1  {path: 'detail/:id', component: HeroDetailComponent},   Der Doppelpunkt gibt an, dass :id ein Parameter ist und symbolisch für einen bestimmten Wert steht.\nUm die URL auszulesen und den Wert des Parameters aus der URL auszulesen, braucht man den folgenden import:\n1  import { ActivatedRoute } from '@angular/router';   Auf die ÀctivatedRoute greift man über dependency injection zu:\n1 2 3  constructor( private route: ActivatedRoute, ) {}   Schliesslich extrahiert man den Parameter in der URL folgendermassen:\n1  id = Number(this.route.snapshot.paramMap.get('id'));   Die Werte in der paramMap sind vom Typ string. Mit der Funktion Number() wird der Wert des Parameters in einen Wert vom Typ number umgewandelt. Falls die type conversion nicht möglich ist, wird der Wert NaN (not a number) zurückgegeben.\nrouterLink directive\nUm einen Link im HTML-Template eines component einzubinden, kann man das Angular directive routerLink mit einem Pfad verwenden.\nBeispiel:\n1  \u003ca routerLink=\"/heroes\"\u003eHeroes\u003c/a\u003e   Ein directive kann man als Attribut eines Elements im HTML-Template angeben. Ein directive ist in einer TypeScript-Klasse definiert.\nTeil 7 - Server-Daten / HTTP requests Um HTTP requests zu generieren, verwendet man den HTTP client von Angular.\nUm den HTTP client zu verwenden, importiert man das HttpClientModule im AppModule, beziehungsweise in {base_dir}/src/app/app.module.ts, und fügt das HttpClientModule zum Array imports hinzu.\n1  import { HttpClientModule } from '@angular/common/http';   1 2 3 4 5  @NgModule({ imports: [ HttpClientModule, ], })   HTTP requests generiert man in der Regel innerhalb eines Service. In einem component verwendet man den Service dann über dependency injeciton.\n1 2 3  // Code innerhalb des Service  import { HttpClient, HttpHeaders } from '@angular/common/http';   Den HttpClient verwendet man innerhalb des Service auch über dependency injection:\n1 2 3 4  // Code innerhalb des Service  constructor( private http: HttpClient) {}   HTTP Get requests\nEin HTTP Get requests eines Service ist üblicherweise folgendermassen implementiert:\n1 2 3 4 5  // Code innerhalb des Service  getResult(restUrl: string): Observable\u003cT\u003e { return this.http.get\u003cT\u003e(restUrl); }   Hier enthält restUrl eine URL der REST-API, für die ein GET request generiert wird.\nDer Service liefert also ein Observable, das über einen type parameter T (üblicherweise ein Interface) das Format der geladenen Daten angibt.\nEin client, welcher den Service verwendet, muss über die Funktion subscribe() von Observable eine Callback-Funktion registrieren. Die Callback-Funktion wird aufgerufen, sobald die Daten vom Server bereit sind.\nBeispiel:\n1 2 3 4 5 6  // Code im client  getHeroes(): void { this.heroService.getHeroes() .subscribe(loadedHeroes =\u003e this.heroes = loadedHeroes); }   Anmerkung: Eine REST-API liefert Daten beispielsweise als JSON-Objekt. Die API des Servers bestimmt die Struktur des JSON-Objekts, und je nach API muss man die benötigten Daten zuerst extrahieren. Mann kann dann zum Beispiel das Interface T an die Struktur des JSON-Objekts anpassen.\nWICHTIG: Damit ein HTTP request überhaupt ausgeführt wird, muss die Funktion subscribe() des resultierenden Observable-Objekts aufgerufen werden, auch wenn man keine Callback-Funktion registriert.\nFehlerbehandlung\nOptional kann man Fehlerbehandlung einbauen, für den Fall dass der GET request fehlschlägt.\nBeispiel:\n1 2 3 4 5 6 7 8  // Code innerhalb des Service  getHeroes(): Observable\u003cHero[]\u003e { return this.http.get\u003cHero[]\u003e(this.heroesUrl) .pipe( catchError(this.handleError\u003cHero[]\u003e('getHeroes', [])) ); }   Mit pipe() wird das Observable nachbearbeitet. Für den Fall eines Fehlers wird eine Funktion für die Fehlerbehandlung registriert.\n1 2 3 4 5 6 7 8 9 10  // Code innerhalb des Service  private handleError\u003cT\u003e(operation = 'operation', result?: T) { return (error: any): Observable\u003cT\u003e =\u003e { console.error(error); return of(result as T); }; }   Im Fall eines Fehlers wird der Fehler auf der Konsole des Browsers ausgegeben, und manuell ein Observable mit einem leeren Array als Antwort für den client konstruiert.\nHTPP Put, Post und Delete requests\nAnalog zu HTTP Get requests kann man auch Put, Post und Delete requests verwenden, abhängig von der REST-API des Servers.\nWICHTIG: Damit ein HTTP request überhaupt ausgeführt wird, muss die Funktion subscribe() des resultierenden Observable-Objekts aufgerufen werden, auch wenn man keine Callback-Funktion registriert.\n","categories":"","description":"Heroes Tour: Take-aways\n","excerpt":"Heroes Tour: Take-aways\n","ref":"/docs/web/angular/take_aways/","tags":"","title":"Heroes Tour: Take-aways"},{"body":"Sichere Kommunikation mit JSON Web Token Ein JWT kann von jedem dekodiert und gelesen werden. Tatsächlich ist das für den Client und das Debuggen nützlich. Die Payload wird nicht verschlüsselt (für Verschlüsselung s. JWE), aber gültige Signaturen können nur erstellt werden, wenn man ein Geheimnis kennt. Jedes Mal, wenn ein Token empfangen wird, muss eine Integritätsprüfung die Signatur bestätigen. So wird sichergestellt, dass der Token nicht manipuliert wurde. Danach wird sein Inhalt als vertrauenswürdig eingestuft.\nDie Gültigkeitsdauer des Token kann begrenzt werden, indem zeitbezogene Claims wie iat (“Issued At”), nbf (“Not Before”) und exp (“Expiration Time”) einbezogen werden. Ein abgelaufener JWT ist zwar weiterhin gültig, da es jedoch nicht möglich ist, Einträge zu manipulieren, ohne die Signatur zu zerstören, wird bei der serverseitigen Integritätsprüfung das Ablaufdatum des Tokens gelesen und der Zugriff verweigert.\nEin Nachteil ist das sehr komplizierte Widerrufen eines Tokens. Eine gängige Lösung ist das Blacklisting. Außerdem helfen kurze Gültigkeitsdauern.\nBeispiel für die Erstellung eines JSON Web Token\nEin typisches JWT sieht folgendermassen aus (Header, Payload, Signature):\nxxxxx.yyyyyy.zzzzzz\nHeader Der Header ist typischerweise in zwei Parts aufgeteilt: der erste Part ist der benötigte Algorythmus und der zweite der Typ des Tokens. Unten ein Beispiel dazu:\n1 2 3 4  { \"alg\": \"HS256\", \"typ\": \"JWT\" }   Payload Der zweite Teil des Tokens der Payload, welche die erstellten Forderungen enthält. Forderungen sind Aussagen über eine Entität (normalerweise den Benutzer) und zusätzliche Daten. Es gibt drei Arten von Forderungen : registrierte, öffentliche und private.\n Registrierte: Reihe vordefinierter Forderungen die nicht obligatorisch aber empfohlen sind; iss(Emittent), exp(Ablaufzeit), sub(Betreff) und aud(Publikum) Öffentliche: Können nach Belieben definiert werden. Um Kollisionen zu vermeiden, sollten sie jedoch in der IANA JSON Web Token Registry definiert sein. Private: Hierbei handelt es sich um benutzerdefinierte Forderungen, die erstellt wurden, um Informationen zwischen Parteien auszutauschen, die sich auf deren Verwendung einigen und weder registrierte noch öffentliche Forderungen sind  1 2 3 4 5  { \"sub\": \"1234567890\", \"name\": \"John Doe\", \"admin\": true }   Signatur Um den Signaturteil zu erstellen, muss man den codierten Header, den codierten Payload, ein Secret und den im Header angegebenen Algorithmus verwenden und diesen signieren. Wenn man beispielsweise den HMAC SHA256-Algorithmus verwenden möchte, wird die Signatur folgendermaßen erstellt:\n1 2 3 4  HMACSHA256( base64UrlEncode(header) + \".\" + base64UrlEncode(payload), secret)   Die Signatur wird verwendet, um zu überprüfen, ob die Nachricht unterwegs nicht geändert wurde. Bei Token, die mit einem privaten Schlüssel signiert wurden, kann auch überprüft werden, ob der Absender des JWT derjenige ist, für den er sich ausgibt.\nAlles zusammenführen Die Ausgabe besteht aus drei durch Punkte getrennten Base64-URL-Zeichenfolgen, die in HTML- und HTTP-Umgebungen problemlos übergeben werden können und im Vergleich zu XML-basierten Standards wie SAML kompakter sind.\nDas Folgende zeigt eine JWT, bei der der vorherige Header und die Nutzdaten codiert sind und die mit einem Geheimnis signiert ist.\n1 2 3  eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9. eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ. SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c   Auftrag Du hast nun alle Theorie die du für das nächste Projekt brauchst. Teste nun hier, ob du alles verstanden hast.\n","categories":"","description":"JSON Web Token (JWT) ist ein offener Standard (RFC 7519) zur sicheren Kommunikation eines JSON-Objekts. In der Regel muss sich der Benutzer erfolgreich anmelden und erhält dann einen Token für API-Calls. Der Token besteht aus drei Teilen: Header, Payload und Signatur. Da die Payload alle erforderlichen Informationen enthält, ist für die Authentifizierung keine Datenbankabfrage erforderlich. Das ist besonders für die Skalierung zustandsloser Backend-Architekturen super!\n","excerpt":"JSON Web Token (JWT) ist ein offener Standard (RFC 7519) zur sicheren …","ref":"/docs/web/angular/06_1_einfuehrung_jwt/","tags":"","title":"Json Web Token Authorisation (JWT)"},{"body":"5.0: Meta 5.0.1: Goals  I know how applications work in a modern world I know what databases, backends, frontends are for I know what a monolithic application is I can divide the modules of an application  5.0.2: Changelog    Author Version Date Change     Raffael Hertle 0.1 18.1.2022 Initial version    5.0.3: Requirements  None  5.1: Applications in the modern world 5.1.1: State of the world In our state of the world now we know small applications existing and solving small problems (or even creating problems). For example we could simply create a Java application simulating a calculator on the command line. Some few lines of code would be enough to create a solution, compile the program and execute it on your local machine. Neat! But is this what modern software engineering is about? Not really.\nIn this chapter we dive a bit into the modern world of applications and take a look at how we solve problems at a bigger scale!\nSolving problems: That’s what software engineering is all about. We know a certain problem and we would like to tackle it by creating an application or automated solution. But how do we get there?\n5.2: Solving problems Let’s take a look at how we can tackle problems in the first place. There are two very well known approaches to describe and inspect problems we use every day in our jobs: Bottom-Up and Top-Down approaches.\nTo talk about how to solve problems, we need to create one in the first place.\nWe would like to sell our sneakers in an online shop. Our customers should have a neat web based UI to check out our shoes and order them online. Our application checks whether the shoes are still in stock and lets the customer pay and complete the order. Sounds simple, doesn’t it? But here already we are talking about several smaller problems by describing a bigger problem. And this is what it is all about.\n5.2.1: Top-Down In a Top-Down approach we describe the problem from the biggest scope possible and then work ourselves from top down to smaller problems and describing them. As you can easily see, we already followed a top-down approach by simply describing our problem in 5.2. The Top-Down approach is the most useful if we already know the bigger scope of our problem and can start by digging down into smaller problems. It gets harder the complexer the problem will get. As soon as the problem’s complexity is too big, a Bottom-Up approach is most likely more useful!\n5.2.2: Bottom-Up The Bottom-Up approach inverts the idea. Sometimes it’s easier to specify smaller parts of a solution first, then create the bigger solution from the puzzle of the small solutions.\n5.2.3: Assignment 1 Create a Bottom-Up specification for the problem described in 5.2. Use your own words and document the specification as a file in your git repository.\n5.3: Building blocks of modern applications Modern applications mostly do not just exist as a single system. They utilize a wide selection of other applications to perform the tasks needed. When systems are dependent on other systems we call them a Dependency of our system. These dependencies might be other applications of ours or other services. If we take a look at modern web applications the three default building blocks are mostly quite similar.\nWeb Application A web-application is an application program that is usually stored on a remote server, and users can access it through the use of Software known as web-browser.\n Java Point\n  Building Block General or abstract term for all kinds of artifacts from which software is constructed. Part of the statical structure (Building Block View) of software architecture.\nBuilding blocks can be hierarchically structured - they may contain other (smaller) building blocks.\nSome examples of alternative (concrete) names for building blocks: Component, module, package, namespace, class, file, program, subsystem, function, configuration, data-definition.\n iSAQB Definition of Building Blocks\n  These default building blocks of modern web application usually consists of:\n Frontend: Visualization of our application (Website) Backend: Backing service which handles application logic Database: Storing information for our application  Frontend The frontend of a software program or website is everything with which the user interacts. From a user standpoint, the frontend is synonymous with the user interface. From a developer standpoint, it is the interface design and the programming that makes the interface function. Conversely, the backend includes functions and data processing that takes place behind the scenes.\nOne of the primary goals of frontend development is to create a smooth or “frictionless” user experience. In other words, the front end of an application or website should be intuitive and easy to use. While this sounds like a simple goal, it can be surprisingly complex since not all users or devices are the same. For example, an app developed for a mobile device requires a significantly different frontend than a desktop application. Websites must work well on multiple devices and screen sizes, which is why modern web development typically involves responsive design.\n TechTerms.com\n  Backend In the computer world, the “backend” refers to any part of a website or software program that users do not see. It contrasts with the frontend, which refers to a program’s or website’s user interface. In programming terminology, the backend is the “data access layer,” while the frontend is the “presentation layer.”\nMost modern websites are dynamic, meaning webpage content is generated on-the-fly. A dynamic page contains one or more scripts that run on the web server each time the page is accessed. These scripts generate the content of the page, which is sent to the user’s web browser. Everything that happens before the page is displayed in a web browser is part of the backend.\n TechTerms.com\n  Database A database is a data structure that stores organized information. Most databases contain multiple tables, which may each include several different fields. For example, a company database may include tables for products, employees, and financial records. Each of these tables would have different fields that are relevant to the information stored in the table.\n TechTerms.com\n  5.4: Our shop in different styles We are now trying to describe our software solution for our online shop in a few different approaches. When designing our software solution we should always consider that there is most likely not only one correct solution available. In most cases there are several solutions possible fitting our needs and they all will have their own trade-offs.\nThere are a few architectural patterns which we can take a look at:\n5.4.1: Monolithic Architecture Monolithic Architecture The monolithic architecture is considered to be a traditional way of building applications. A monolithic application is built as a single and indivisible unit. Usually, such a solution comprises a client-side user interface, a server side-application, and a database. It is unified and all the functions are managed and served in one place.\nNormally, monolithic applications have one large code base and lack modularity. If developers want to update or change something, they access the same code base. So, they make changes in the whole stack at once.\n Usually in monolithic applications modularity comes from separating responsibilities. We will have modules handling the system interaction from outside (API / Boundary classes), business logic (Services) and data access (Repositories).\n5.4.1.1: API Monolithic Architecture Stands for “Application Programming Interface.” An API is a set of commands, functions, protocols, and objects that programmers can use to create software or interact with an external system.\n TechTerms.com\n  So we think of APIs as an instruction set to use our application. It defines how the user can interact with our software on a technical level.\n5.4.1.2: Services All class handling business logic in our applications are contained in this section. By business logic we mean all logic which is affected by the applications business not the technical world. It defines how business objects interact with each other.\nTake a look at our store example above. All the logic handling the prices, names, orders, addresses, etc. are part of the application’s business logic. It has no technical relevancy but only from the business perspective.\nBusiness logic parts are the core of our application to all users. Usually users don’t care about how things are getting done, they mostly care that things are done. That is business logic!\n5.4.1.3: Data Repositories Data repositories are the access point to our databases and data storage. Think of them as the front desk in a library. They are classes which we use to access data stored in our library (database for example) and they give us an instruction set which tells us how to access the data - an API!\n5.4.2: Microservices In the monolithic architecture world we think about all components living in the same application. The application would be divided by multiple domains (for example the order domain) which is then divided into modules for data access, business logic and the API. If we take a step further and separate a bit more we could think of all these domains as single applications. Then we would have multiple applications instead of multiple domains in one application. When one part of the software changes, not the entire landscape has to be rebuilt and redeployed onto our servers. This will lead to flexibility and adaptability in our software, but brings a lot more technical complexity to the scene.\n5.4.3: Assignment 2 It is now time for you as the architect in the web-shop project to decide how our application is built. Take your time and create two approaches for designing the application: a monolithic and microservice approach. Try to create an illustration on how your software is built, try to describe your software in a few sentences and show the different layers of your application.\n","categories":"","description":"Overview Lab: Theory of everything\n","excerpt":"Overview Lab: Theory of everything\n","ref":"/docs/java/overview/","tags":"","title":"Overview Lab"},{"body":"6.0: Meta 6.0.1: Goals  TODO  6.0.2: Changelog    Author Version Date Change     Raffael Hertle 0.1 23.1.2022 Initial version    6.0.3: Requirements  I understand Java basics I understand the difference between classes and interfaces and their usages  6.1: What is a framework Before understanding what the Spring framework is and does, we need some kind of definition of a framework:\nFramework A framework, or software framework, is a platform for developing software applications. It provides a foundation on which software developers can build programs for a specific platform. For example, a framework may include predefined classes and functions that can be used to process input, manage hardware devices, and interact with system software. This streamlines the development process since programmers don’t need to reinvent the wheel each time they develop a new application.\nA framework is similar to an application programming interface (API), though technically a framework includes an API. As the name suggests, a framework serves as a foundation for programming, while an API provides access to the elements supported by the framework. A framework may also include code libraries, a compiler, and other programs used in the software development process.\n TechTerms.com\n  6.1.1: What is the Spring framework At its core the Spring framework is a dependency injection and inversion of control framework. Don’t get too confused over these two fancy words yet, we will take a look at them in a second. The Spring framework brings us utility to do almost anything we need in a basic web application: creating web-accessible API endpoints, connecting to a database and saving objects - all comes (more or less) out of the box with the Spring framework.\nLet us dive a bit into the concepts and design patterns of enterprise application programming.\n6.2: Core concepts When designing software and facing problems, we often find ourselves in a similar situation. The problem might be similar, or the solution after a while might be very familiar with what we have done in an earlier project. By generalizing problems and their solutions we create reusable approaches which we call ‘design patterns’:\nDesign pattern Design patterns are reusable solutions for software development. They serve as templates that programmers can use when creating applications. They are not specific to individual programming languages, but instead are best practices or heuristics that can be applied in different programming environments.\nWhile design patterns are not language-dependent, they often include objects or classes. Therefore, they are typically associated with object-oriented programming. Individual patterns can be classified into three different categories: 1) creational patterns, 2) structural patterns, and 3) behavioral patterns.\n TechTerms.com\n  The following core concepts are all general design patterns used in almost every enterprise application.\n6.2.1: Inversion of Control Inversion of Control Inversion of Control (IoC) is a design principle (although, some people refer to it as a pattern). As the name suggests, it is used to invert different kinds of controls in object-oriented design to achieve loose coupling. Here, controls refer to any additional responsibilities a class has, other than its main responsibility. This includes control over the flow of an application, and control over the flow of an object creation or dependent object creation and binding.\nIoC is all about inverting the control. To explain this in layman’s terms, suppose you drive a car to your work place. This means you control the car. The IoC principle suggests to invert the control, meaning that instead of driving the car yourself, you hire a cab, where another person will drive the car. Thus, this is called inversion of the control - from you to the cab driver. You don’t have to drive a car yourself and you can let the driver do the driving so that you can focus on your main work.\nThe IoC principle helps in designing loosely coupled classes which make them testable, maintainable and extensible.\n tutorialsteacher.com\n  6.2.2: Dependency Injection Dependency Injection “In software engineering, dependency injection is a technique whereby one object supplies the dependencies of another object. A ‘dependency’ is an object that can be used, for example as a service. Instead of a client specifying which service it will use, something tells the client what service to use. The ‘injection’ refers to the passing of a dependency (a service) into the object (a client) that would use it. The service is made part of the client’s state. Passing the service to the client, rather than allowing a client to build or find the service, is the fundamental requirement of the pattern.” Source: Wikipedia\nCreating objects directly within the class is inflexible because it commits the class to particular objects and makes it impossible to change the instantiation later independently from the class. It stops the class from being reusable if other objects are required and it makes the class hard to test because real objects can not be replaced with mock objects.\n growin.com\n  We will see a practical example later. Keep the pattern in mind, even though it might be hard to understand at first.\n6.2.3: Singleton When talking about Singletons in programming, we talk about objects which are the only instantiation of its class. Meaning that when we use an object of said class, we can be sure that it is the only one instance at runtime of this class.\nRead the explanation on refactoring.guru.\nThe usage shall yet be a mystery to you, we will also use this pattern a lot in the upcoming exercise.\n6.2.4: Repository The Repository design pattern is a very common design pattern for managing data access. The repository will be the interface to access all our data stored in our database. Think of the repository being your library front desk manager. We want to access books in the library and we have no idea how they get them to us. We only know their API (instructions) and the results we can expect. The repository usually is an interface defined something like this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  public interface ArticleRepository { List\u003cArticle\u003e readAll(); List\u003cArticle\u003e readLatest(); List\u003cArticle\u003e readByTags(Tag... tags); Article readById(long id); Article create(Article article); Article update(Article article); Article delete(Article article); }   The implementation of the interface does not really concern us. Most of the times this is done by the frameworks behind the application. In our case with the Spring framework letting our class extend the Repository class of Spring Data will suffice and all the implementation is magically going to happen!\n6.2.5: REST The abbreviation REST stands for REpresentational State Transfer. It is a architectural approach and became the standard for all web-based applications and is built upon the HTTP protocol. In a RESTful world everything is called a resource. Resources are accessed using standard HTTP methods (GET / POST / DELETE / PUT).\nThe REST server simply provides access to resources and the client can read and modify these resources. The resources itself are identified by URIs and IDs. REST does not define in which “language” server and client communicate, but most of the times resources are represented by JSON objects.\nThe following standards are defined for the HTTP methods to access resources:\n GET: Provides read only access to a resource POST: Creates new resources DELETE: Deletes resources PUT: Updates or creates resource if not found  Let us take a look at how our REST resources could look like at our store web-application. As we said resources and their access are defined by HTTP Method, Resource name and ID. For example a HTTP GET request to /orders/15 would return information about the order with ID 15. Resources in a RESTful world are always written in plural. Here are some other examples:\n POST /orders: Create a new order GET /orders: List all orders available PUT /orders/15: Update order with ID 15 DELETE /orders/15: Delete the order with ID 15  6.2.6: (REST-) Resource / Controller The resource or controller will be the entrypoint of all requests reaching our web-application. Users will make HTTP requests by the frontend to our backend. This API is going to be the code representation of our REST resources.\nA representation of a REST resource for our /orders resource might look like this:\n1 2 3 4 5 6 7 8 9 10 11 12 13  @RestController @RequestMapping(\"/orders\") public class OrderResource { private OrderService orderService; @GetMapping public List\u003cOrder\u003e getAllOrders() { // Get all orders from the order magical order service  List\u003cOrder\u003e orders = orderService.findAll(); return orders; } }   Do not yet care too much about the code itself. We are going to dive into the code in a few chapters.\n6.2.7 Assignment 1 Can you provide a definition of a REST resource for an order resource in our theoretical web shop application? Define the methods and endpoints (/orders/15). List at least 5 endpoints and their usage in the API.\n6.3: The life in Spring Let us take a look at the freshly learned design patterns and how we can implement / use them with the help of the Spring framework. Up until now most of the part from this chapter might still be a lot of magic and sound confusing to you.\nMost modern web applications are most commonly divided into three layers:\n Boundary: The layer that represents the API boundary of the application Control: The control layer holds all classes with business logic Entity: The entity layer holds the representation of the data models and their data access classes (repositories)  Let us take a look at code examples representing the core concepts from the chapters before, layer by layer.\n6.3.1: Boundary Layer In the boundary layer we define our REST resources. Without further theory, here is an example REST resource for a Order class in our web shop:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  @RestController @RequestMapping(\"/orders\") public class OrderResource { private final OrderService orderService; public OrderResource(OrderService orderService) { this.orderService = orderService; } @GetMapping public List\u003cOrder\u003e findAll() { return orderService.findAll(); } @GetMapping(\"/{id}\") public Order findById(@PathVariable Long id) { return orderService.findById(id).orElseThrow(EntityNotFoundException::new); } @PostMapping public Order save(@RequestBody Order order) { return orderService.save(order); } @PutMapping(\"/{id}\") public Order update(@PathVariable Long id, @RequestBody Order order) { return orderService.update(id, order); } @DeleteMapping(\"/{id}\") public ResponseEntity delete(@PathVariable Long id) { orderService.delete(id); return ResponseEntity.ok().build(); } }   If we take a short look at the class above, we can guess what the class does and what it is used for. This class represents a REST resource in our application. The annotation @RestController (Almost all annotations discussed here are from the Spring Framework) defines the class as a REST resource. The annotation @RequestMapping(\"/orders\") defines that all HTTP calls requesting the /orders path, will invoke this REST controller.\nEach method in this REST resource defines an endpoint serving the basic CRUD REST instructions. Let us take a look at one of the methods in detail:\n1 2 3 4 5 6  @GetMapping(\"/{id}\") public Order findById(@PathVariable Long id) { return orderService.findById(id).orElseThrow(EntityNotFoundException::new); }   This method defines that in the context of the resource (/orders) all HTTP GET requests on the /{id} path will get handled by the function OrderResource.findById(...). The only parameter of this function is id: Long which is annotated by the @PathVariable annotation, telling us that the parameter called id will be handed over as a path variable. Meaning that any request coming to the endpoint /orders/10 will be interpreted as a call similar to OrderResource::findById(10). Inside the OrderResource::findById function we simply delegate the job to the OrderService instance to handle the request and fetch the desired order.\nMost of the other REST endpoints are quite similar to the function described above, except for the PUT and POST request which have another annotation:\n1 2 3 4 5 6  @PutMapping(\"/{id}\") public Order update(@PathVariable Long id, @RequestBody Order order) { return orderService.update(id, order); }   Here in the PUT mapping we have the annotation @PathVariable on the parameter id: Long which we already know. The next parameter order: Order is annotated with @RequestBody. This annotation tells the Spring framework that the parameter will come as the body part of the request:\n1 2 3  curl -X POST -d '{\"name\": \"Example\"}' -H 'Content-Type: application/json' http://localhost:8080/orders   This is an example for a valid request to the POST endpoint on /orders. As you can see the request comes with a body -d '{\"name\": \"Example\"}' which holds a JSON representation of an Order object. The Spring framework will automatically map the JSON Object in the body to the Java Object as the parameter of the request.\nAnother thing that is new is how we utilize the OrderService class. All the functions in the OrderResource get passed over to the OrderService. This is what we call separation of concern: We let the REST resource handle all the logic connected to the REST and HTTP world and the service class handle all the business logic. But as you already recognized, the object orderService: OrderService does not get initialized in this class. It gets passed to the constructor. This is what we call Constructor Injection and is a type of Dependency Injection. Here is how this works: In the Spring framework there are several annotations which define Beans in the applications context.\nBean The objects that form the backbone of your application and that are managed by the Spring IoC container are called beans. A bean is an object that is instantiated, assembled, and otherwise managed by a Spring IoC container. These beans are created with the configuration metadata that you supply to the container.\n tutorialspoint.com\n  In other words: Java classes with certain annotations (@Service , @Repository, @RestController, …) will define Singletons in the Spring frameworks context. The framework now sees that another class uses one of these beans (for example defined by constructor injection) and injects the instance in the class automatically.\n1 2 3 4 5 6 7 8 9 10 11  [...] private final OrderService orderService; public OrderResource(OrderService orderService) { this.orderService = orderService; } [...]   6.3.2: Control Layer The control layer holds all the business logic and builds normally the core of all applications. On a technical level this is the most basic and least interesting layer in the application. The orders service class looks as the following:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  @Service @Transactional public class OrderService { private final OrderRepository orderRepository; public OrderService(OrderRepository orderRepository) { this.orderRepository = orderRepository; } public List\u003cOrder\u003e findAll() { return (List\u003cOrder\u003e) orderRepository.findAll(); } public Optional\u003cOrder\u003e findById(Long id) { return orderRepository.findById(id); } public Order save(Order order) { return orderRepository.save(order); } public Order update(Long id, Order order) { Order toUpdate = orderRepository.findById(id).orElseThrow(EntityNotFoundException::new); toUpdate.setName(order.getName()); return toUpdate; } public void delete(Long id) { orderRepository.deleteById(id); } }   You can see directly that this class looks less complicated and has fewer annotations than the REST resource before. The only annotations in this class are @Service and @Transactional. The @Service annotation tells the Spring framework that the following class is a Java bean holding business logic. The @Transactional annotation will simply annotate that all the functions in the class should be executed in a single transaction. Don’t mind yet about the @Transactional annotation. As you can see we also inject another bean into this class by constructor injection: the OrderRepository.\n6.3.3: Entity Layer Classes in the entity layer represent the database entities and their access classes (repositories). The Order object is represented by the following class:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  @Entity @Table(name = \"orders\") public class Order { @Id @GeneratedValue Long id; String name; public Long getId() { return id; } public void setId(Long id) { this.id = id; } public void setName(String name) { this.name = name; } public String getName() { return this.name; } }   Without the annotations the class looks like one of the simplest java classes. The annotations are pretty straightforward too. The @Entity annotation indicates that this is a managed persistence class. The @Table(name = \"\") annotations lets you define how the table is called managing this class. The @Id annotations annotates the field id: Long to define that the field is used as the primary key in the database. @GeneratedValue lets you define values which are created by the underlying data store or database.\nTo access the database and manage the Order objects in the application we use the OrderRepository:\n1 2 3  @Repository public interface OrderRepository extends CrudRepository\u003cOrder, Long\u003e { }   You will notice that the OrderRepository is not a class but only an interface extending Spring’s CrudRepository. The type parameterization behind the CrudRepository\u003cOrder, Long\u003e indicates that the managed objects by this repository are Order and identified by Long (Remember the @Id Long id from the Order class?). If you check the documentation for Spring’s CrudRepository, you can see what methods are already defined by the interface. You will also notice that we just define an interface and do not implement any of these methods. Spring does this magic for you,\n6.4: Your own application Now it is time to get your hands dirty! The first assignment will be to have a Spring Boot application up and running. We will set up a sample dummy application.\nThere are several ways to get your first application up and running, we will take a look at two of them.\n6.4.1: UI Approach To get started with Spring Boot you can use their own starter tool called spring initializr. Open the link in the browser of your choice and click through the setup. For a simple hello world example you can just use the following configuration:\n Project: Maven project Language: Java Spring Boot: Default Project Metadata:  GroupId: ch.itninja Artifact: helloworld Name: helloworld Description: … Package name: ch.sbbt.example.helloworld Packaging: Jar Java: 11    Simply click generate afterwards and unzip the project.\n6.4.2: CLI Approach For the people who are more CLI focussed, you can use the same tool with your CLI favorites via HTTP.\n1 2 3 4 5 6 7 8 9  $ curl -G https://start.spring.io/starter.zip \\ -d dependencies=web \\ -d javaVersion=11 \\ -d groupId=ch.itninja \\ -d artifactId=helloworld \\ -d baseDir=helloworld \\ -o helloworld.zip $ unzip helloworld.zip   or\n1 2 3 4 5 6 7 8 9  $ curl -G https://start.spring.io/starter.tgz \\ -d dependencies=web \\ -d javaVersion=11 \\ -d groupId=ch.itninja \\ -d artifactId=helloworld \\ -d baseDir=helloworld \\ -o helloworld.tar $ tar -xfv helloworld.tar   depending on your preferences in compression tools.\n6.4.3: Start the Application Import the project in your favorite IDE. Most of the times this can be achieved by opening the maven project file pom.xml in your IDE of choice and then import it as a project.\nMost IDEs (including IntelliJ) support Spring applications out of the box. As soon as you have your project imported you can start up your application by running the pre-configured run-configuration. If you do not want to rely on your IDE to start up your application you can use any shell of your choice and simply execute:\n1  ./mvnw spring-boot:run   Let maven download and build your dependencies and as soon as you have a message like:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  . ____ _ __ _ _ /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.6.3) 2022-02-09 13:57:45.493 INFO 477193 --- [ main] ch.itninja.helloworld.DemoApplication : Starting DemoApplication using Java 11.0.2 on rhertle-puzzle with PID 477193 (**************************) 2022-02-09 13:57:45.495 INFO 477193 --- [ main] ch.itninja.helloworld.DemoApplication : No active profile set, falling back to default profiles: default 2022-02-09 13:57:46.050 INFO 477193 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat initialized with port(s): 8080 (http) 2022-02-09 13:57:46.057 INFO 477193 --- [ main] o.apache.catalina.core.StandardService : Starting service [Tomcat] 2022-02-09 13:57:46.057 INFO 477193 --- [ main] org.apache.catalina.core.StandardEngine : Starting Servlet engine: [Apache Tomcat/9.0.56] 2022-02-09 13:57:46.100 INFO 477193 --- [ main] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring embedded WebApplicationContext 2022-02-09 13:57:46.100 INFO 477193 --- [ main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 569 ms 2022-02-09 13:57:46.322 INFO 477193 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 8080 (http) with context path '' 2022-02-09 13:57:46.329 INFO 477193 --- [ main] ch.itninja.helloworld.DemoApplication : Started DemoApplication in 1.112 seconds (JVM running for 1.414) 2022-02-09 13:58:03.800 INFO 477193 --- [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring DispatcherServlet 'dispatcherServlet' 2022-02-09 13:58:03.801 INFO 477193 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet : Initializing Servlet 'dispatcherServlet' 2022-02-09 13:58:03.801 INFO 477193 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet : Completed initialization in 0 ms   your application has been successfully started! Congratulations!\n6.4.4: Assignment 2 No it is your turn to implement some code!\n6.4.4.1: Task 1 Create a resource GreetingResource at the path /greetings which greets you with a String “Hello World!” response when sending a GET request to /greetings.\n1 2  $ curl -X GET http://localhost:8080/greetings \"Hello World!\"   Take a look at the classes in the chapter before and implement it yourself.\n Solution Task 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  package ch.itninja.helloworld.greetings.boundary; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(\"/greetings\") public class GreetingResource { @GetMapping public String greeting() { return \"Hello, World!\"; } }   The request should return the following:\n1 2  $ curl http://localhost:8080/greetings Hello, World!%    6.4.4.2: Task 2 Continue with your DemoApplication and extend your GreetingResource by another endpoint. GET requests at /greeting/{name} should return a personalized message Hello {name}! as a response!\n1 2  $ curl -X GET http://localhost:8080/greetings/raffael \"Hello raffael!\"   Take a look at the classes in the chapter before and implement it yourself.\nIf you’re stuck, take a look at the hint.\n Hint Task 2 We can use the @PathVariable annotation to annotate a parameter of the function to get mapped to a path segment of the endpoint definition. Take a look at the example in 6.3.1!\n If you still cannot solve the Task, you can help yourself with the solution.\n Solution Task 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  package ch.itninja.helloworld.greetings.boundary; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(\"/greetings\") public class GreetingResource { @GetMapping public String greeting() { return \"Hello, World!\"; } @GetMapping(\"/{name}\") public String greetByName(@PathVariable String name) { return \"Hello \" + name + \"!\"; } }   The request should return the following:\n1 2  $ curl http://localhost:8080/greetings/raffael Hello raffael!%    6.4.4.3: Task 3: Setup application Now let’s build our Order application from the web shop example all the way! We will build all the resources for the Order class from scratch:\n Setup Application Setup database, application model and repository layer Create service / business logic layer Define REST endpoints for resources  Let’s start with the creation of our application. Create the spring application like we have already seen in the previous chapters. And make a quick check if your application is able to start up!\nTry to already create folders for the different packages: order-entity, -control, -boundary:\n1 2 3 4 5 6 7 8 9 10  └── order ├── boundary │ └── OrderResource.java ├── control │ └── OrderService.java └── entity ├── Order.java └── OrderRepository.java    Hint Task 3 If you’re stuck take a look at the first section 6.4!\n  Solution Task 3 Use the spring initializr or the CLI approach:\nWith\n1 2 3 4 5 6 7 8 9  $ curl -G https://start.spring.io/starter.zip \\ -d dependencies=web \\ -d javaVersion=11 \\ -d groupId=ch.itninja \\ -d artifactId=helloworld \\ -d baseDir=helloworld \\ -o helloworld.zip $ unzip helloworld.zip   or\n1 2 3 4 5 6 7 8 9  $ curl -G https://start.spring.io/starter.tgz \\ -d dependencies=web \\ -d javaVersion=11 \\ -d groupId=ch.itninja \\ -d artifactId=helloworld \\ -d baseDir=helloworld \\ -o helloworld.tar $ tar -xfv helloworld.tar    6.4.4.4: Task 4: Database entity To work with a database we need some additional dependencies to the project.\nLet us extend the dependency list in the pom.xml and add the following entries:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  \u003cdependencies\u003e \u003c!-- COPY FROM HERE --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-data-jpa\u003c/artifactId\u003e \u003cversion\u003eRELEASE\u003c/version\u003e \u003cscope\u003ecompile\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.h2database\u003c/groupId\u003e \u003cartifactId\u003eh2\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!-- --\u003e \u003c/dependencies\u003e   These two dependencies allow us to start up a h2 database and add the support for JPA (Java Persistence API) to our application.\nBefore we start implementing our services and data models, we need to configure the database connections. Copy the following into your application.properties file in your project:\n1 2 3 4 5 6 7 8 9 10  spring.datasource.url=jdbc:h2:mem:testdb spring.datasource.driverClassName=org.h2.Driver spring.datasource.username=sa spring.datasource.password= spring.jpa.database-platform=org.hibernate.dialect.H2Dialect spring.jpa.hibernate.ddl-auto=update spring.h2.console.enabled=true   We first create a simple Order class in the order.entity package. The Order class should have the following properties:\n id name address amount date of order  If you need a hint, here you go!\n Hint Task 4 If you’re stuck take a look at the first section 6.3.3. The other properties can be represented by the following data types:\n name: String address: String amount: Double dataOfOrder: Instant  The new fields do not need any annotations!\n If you are completely overwhelmed try the following solution:\n Solution Task 4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.Id; import javax.persistence.Table; import java.time.Instant; @Entity @Table(name = \"orders\") public class Order { @Id @GeneratedValue Long id; String name; String address; Double amount; Instant dateOfOrder; public Long getId() { return id; } public void setId(Long id) { this.id = id; } public void setName(String name) { this.name = name; } public String getName() { return this.name; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } public Double getAmount() { return amount; } public void setAmount(Double amount) { this.amount = amount; } public Instant getDateOfOrder() { return dateOfOrder; } public void setDateOfOrder(Instant dateOfOrder) { this.dateOfOrder = dateOfOrder; } }    Try to start up your application! If the application starts normally, you should be alright and ready to continue!\n6.4.4.5: Task 5: Database repository So far we have a web application and a data representation for our orders. To do anything with our data representation in our database, we need to access it. This is what the repository will be for. Create the interface OrderRepository in the order.entity package similar to the example in 6.3.3!\n Solution Task 5 1 2 3 4 5 6 7 8 9  import org.springframework.data.repository.CrudRepository; import org.springframework.stereotype.Repository; @Repository public interface OrderRepository extends CrudRepository\u003cOrder, Long\u003e { }    6.4.4.6: Task 6: Control / business logic layer In this task you will create a service bean to do the basic CRUD operations on the order entity. Take a look at the section 6.3.2 and implement an OrderService on your own.\nTo be continued…\n","categories":"","description":"A short introduction to the Spring framework\n","excerpt":"A short introduction to the Spring framework\n","ref":"/docs/java/spring_introduction/","tags":"","title":"Spring Framework Introduction"},{"body":"Routing Routing Angular Router ist ein leistungsstarker JavaScript-Router, der vom Angular Core Team erstellt und gewartet wird. Der Router wird über das Paket “@angular/router” installiert. Das Paket bietet eine vollständige Routing-Library:\n Mehrere Router-Outlets Verschiedene Strategien für Path-Matching Einfachen Zugriff auf Route-Parameter und Route-Guards zu haben, um Components vor unbefugtem Zugriff zu schützen.  Der Angular-Router ist ein zentraler Bestandteil der Angular-Plattform. Entwickler können damit Single Page Applications mit mehreren Views erstellen und zwischen diesen navigieren.\nRouter-Outlet Die Router-Library stellt uns die Router-Outlet Direktive zur Verfügung. In dieser Direktive fügt der Router den Component ein, der anhand der URL abgeglichen wird. Wir können in einer Angular-Applikation mehrere Outlets hinzufügen, um erweiterte Routing-Szenarien zu implementieren. Für den Anfang werden wir uns jedoch auf einen einzelnen Outlet beschränken.\n1  \u003crouter-outlet\u003e\u003c/router-outlet\u003e   Routen und Pfade Routen sind Objekte, die aus mindestens einem Pfad- und einem Component-Attribut bestehen. Das Pfad-Attribut bezieht sich auf den Teil der URL, der eine eindeutige View festlegt, die angezeigt werden soll. Das Component-Attribut bezieht sich auf den Angular-Component, der dem Pfad zugeordnet wird.\nJede Route ordnet einem Component einen URL-Pfad zu.\nDer Router kann, basierend auf einer von uns bereitgestellten Routendefinition, den Benutzer zu einer bestimmten View navigieren.\nDer Pfad kann auch leer sein. Dies gibt den Standardpfad einer Applikation an und ist normalerweise auch der Start der Applikation.\nDer Pfad kann einen Wildcard String (**) enthalten. Der Router wählt diese Route aus, wenn die angeforderte URL keinen Pfaden der definierten Routen entspricht. Wenn keine Übereinstimmung gefunden wird, kann man dies zum Anzeigen einer “Nicht gefunden”-View oder zum Umleiten zu einer bestimmten View verwendet werden.\nSchauen wir uns ein Beispiel einer Route an:\n1  { path: \"contacts\", component: ContactListComponent}   Falls diese Route so in der Router Konfiguration festgelegt wird, wird der Router den Component ContactListComponent rendern, sobald der URL des Browsers /contacts beinhaltet.\nRoute Guards Ein Route Guard ist ein Feature des Angular Routers, mit der wir Logik ausführen können, wenn eine Route angefordert wird. Es wird häufig verwendet, um zu überprüfen, ob ein Benutzer angemeldet ist und über die Berechtigung verfügt, bevor er zugreifen kann. Somit können wir also dem Benutzer den Zugriff auf die Route ermöglichen oder verweigern.\nFür den Route Guard müssen wir das CanActivate-Interface implementieren, welches im @angular/router Paket verfügbar ist. Die canActivate() Methode des Interfaces enthält die Logik, um den Zugriff auf die Route zuzulassen oder zu verweigern.\nBeispielsweise ermöglicht folgender Guard immer den Zugriff auf eine Route:\n1 2 3 4 5  class MyGuard implements CanActivate { canActivate(){ return true; } }   Eine Route können wir nun anhand dieses Guards schützen, indem wir das “canActivate”-Attribut des Pfades benutzen:\n1  { path: \"contacts/:id\", canActivate: [MyGuard], component: ContactListComponent}   Navigation Directive Der Angular Router stellt die routerLink-Direktive zum Erstellen von Navigationslinks bereit. Diese Direktive navigiert anhand des Pfads, welcher dem Component zugeordnet ist.\nBeispielsweise:\n1  \u003ca [routerLink]=\"'/contacts'\"\u003eContacts\u003c/a\u003e   Aufgabe 4 Nachdem du die Pipes erstellt hast, geht es darum das Routing auf die von dir erstellten Komponenten zu leiten.\n Erstelle nach deinem Ermessen für die jeweiligen Komponenten die du routen willst, eine entsprechende Weiterleitung Sofern du eine Komponente nur anzeigen lassen willst, wenn man beispielsweise angemeldet ist, versuche eine CanActivate Klasse zu erstellen Erstelle auch ein Routing auf die Typ-Komponente, welche mit Hilfe eines Parameters den jweiligen Typ anzeigt  ","categories":"","description":"","excerpt":"Routing Routing Angular Router ist ein leistungsstarker …","ref":"/docs/web/angular/04_5_routing/","tags":"","title":""},{"body":" IT Ninjas Freie Plattform für IT Berufsbildung.        SBB  Puzzle ITC  Nexplore     ","categories":"","description":"","excerpt":" IT Ninjas Freie Plattform für IT Berufsbildung.        SBB  Puzzle …","ref":"/about/","tags":"","title":"About"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/","tags":"","title":"Categories"},{"body":"Übersicht ","categories":"","description":"","excerpt":"Übersicht ","ref":"/challenges/","tags":"","title":"Challenges"},{"body":"Übersicht Ausbildungsprogramm \nDas Ausbildungsprogramm 2022/2023 besteht aus diversen einzelnen Ausbildungs-Modulen. Das Wissen aus jedem Modul wird durch Selbst-Studium erworben und bei Bedarf eigenständig durch zusätzlich gesuchtes Wissen ergänzt. Nahezu jedes Modul bringt seine eigenen Übungen (Labs) mit. Einige der Module müssen durch ein Exam abgeschlossen werden. Die Resultate deiner Übungen und Exams besprichst du am Besten mit einem Coach oder einem erfahrenen Software-Entwickler. Er wird dir Feedback geben und dir idealerweise die Freigabe für das nächste Modul erteilen. Module mit einem Stern bieten freiwillige Challenges an, bei denen du dein Wissen mit anderen messen kannst. Je nach Qualität deiner Lösung erhältst du einen entsprechenden Stern von deinem Coach.\nDas Ziel des Ausbildungsprogramms ist\n das Erlernen der Programmiersprache Java das Erwerben von Kenntnissen zu Maven und Testing das Erwerben von Kenntnissen zum Spring Framework und zu Spring Boot das Erlernen von HTML/CSS und JavaScript das Erlernen der Programmiersprache Typescript/Angular  im begleiteten Selbst-Studium innerhalb des ersten Lehrjahres\n","categories":"","description":"","excerpt":"Übersicht Ausbildungsprogramm \nDas Ausbildungsprogramm 2022/2023 …","ref":"/docs/","tags":"","title":"Docs"},{"body":"Übersicht ","categories":"","description":"","excerpt":"Übersicht ","ref":"/exams/","tags":"","title":"Exams"},{"body":"  #td-cover-block-0 { background-image: url(/featured-background_hua78cf53242ecb05212510c7bc04884e8_219671_960x540_fill_q75_catmullrom_top.jpg); } @media only screen and (min-width: 1200px) { #td-cover-block-0 { background-image: url(/featured-background_hua78cf53242ecb05212510c7bc04884e8_219671_1920x1080_fill_q75_catmullrom_top.jpg); } }  IT Ninjas Docs   Labs   Exams   Challenges             Docs Read the documentation to learn java and web technologies.\nRead more …\n   Labs Start with labs to reinforce theory and gain experience.\nRead more …\n   Exams Take an exam to test your knowledge and complete a block of training.\nRead more …\n   Challenges Participate in volunteer challenges and give your best for the perfect solution.\nRead more …\n    ","categories":"","description":"","excerpt":"  #td-cover-block-0 { background-image: …","ref":"/","tags":"","title":"IT Ninjas Labs"},{"body":"Übersicht ","categories":"","description":"","excerpt":"Übersicht ","ref":"/labs/","tags":"","title":"Labs"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/","tags":"","title":"Tags"}]